"2018-02-09 09:07:48 +0100"
diff --git a/src/kern/arm/bsp/bcm2835/Kconfig b/src/kern/arm/bsp/bcm2835/Kconfig
index bd6e34f..dd9998a 100644
--- a/src/kern/arm/bsp/bcm2835/Kconfig
+++ b/src/kern/arm/bsp/bcm2835/Kconfig
@@ -1,4 +1,24 @@
-# PF: BCM2835
-# PFDESCR: Broadcom 2835
-# PFSELECT: CAN_ARM_CPU_1176
+# PF: BCM283X
+# PFDESCR: Broadcom 2835, 2836 & 2837
 # PFDEPENDS: ARM
+
+choice
+        prompt "Raspberry Pi variant"
+        default PF_BCM283X_RPI3
+
+config PF_BCM283X_RPI1
+        bool "rpi1"
+        depends on PF_BCM283X
+        select CAN_ARM_CPU_1176
+
+config PF_BCM283X_RPI2
+        bool "rpi2"
+        depends on PF_BCM283X
+        select CAN_ARM_CPU_CORTEX_A7
+
+config PF_BCM283X_RPI3
+        bool "rpi3"
+        depends on PF_BCM283X
+        select CAN_ARM_CPU_CORTEX_A53
+
+endchoice
diff --git a/src/kern/arm/bsp/bcm2835/Modules b/src/kern/arm/bsp/bcm2835/Modules
index 4551dc8..d2f139f 100644
--- a/src/kern/arm/bsp/bcm2835/Modules
+++ b/src/kern/arm/bsp/bcm2835/Modules
@@ -1,18 +1,31 @@
 # vim:set ft=make:
 
 SUBSYSTEMS              += LIBUART
-OBJECTS_LIBUART         += uart_pl011.o
-PREPROCESS_PARTS        += libuart generic_tickless_idle
+OBJECTS_LIBUART         += $(if $(CONFIG_PF_BCM283X_RPI3),uart_16550.o,uart_pl011.o)
+PREPROCESS_PARTS        += libuart generic_tickless_idle arm_single_ipi_irq
+PREPROCESS_PARTS        += $(if $(CONFIG_ARM_V7PLUS),arm_generic_timer)
+PREPROCESS_PARTS        += $(if $(CONFIG_PF_BCM283X_RPI3),16550)
+INTERFACES_KERNEL       += $(if $(CONFIG_ARM_V7PLUS),generic_timer)
+INTERFACES_KERNEL       += arm_control irq_handler
 RAM_PHYS_BASE           := 0
 
-
-uart_IMPL             += uart-arm-bcm2835
+ifeq ($(CONFIG_PF_BCM283X_RPI3),y)
+  uart_IMPL              = uart uart-16550
+  kernel_uart_IMPL      += kernel_uart-libuart
+else
+  uart_IMPL             += uart-arm-bcm2835
+  kernel_uart_IMPL      += kernel_uart-arm-bcm2835
+endif
+arm_control_IMPL      += arm_control-arm-bcm283x
 config_IMPL           += config-arm-bcm2835
 mem_layout_IMPL       += mem_layout-arm-bcm2835
 pic_IMPL              += pic-arm-bcm2835
 bootstrap_IMPL        += bootstrap-arm-bcm2835
 timer_IMPL            += timer-arm-bcm2835
-timer_tick_IMPL       += timer_tick-single-vector
-kernel_uart_IMPL      += kernel_uart-arm-bcm2835
+timer_IMPL            += $(if $(CONFIG_ARM_V7PLUS),timer-arm-generic)
+timer_tick_IMPL       += $(if $(CONFIG_ARM_V7PLUS),timer_tick-arm-bcm2835, timer_tick-single-vector)
 reset_IMPL            += reset-arm-bcm2835
 clock_IMPL            += clock-generic
+ipi_IMPL              += ipi-arm-bcm283x
+platform_control_IMPL += platform_control-arm-bcm283x
+irq_handler_IMPL       = irq_handler-arm-bcm2835
diff --git a/src/kern/arm/bsp/bcm2835/arm_control-arm-bcm283x.cpp b/src/kern/arm/bsp/bcm2835/arm_control-arm-bcm283x.cpp
new file mode 100644
index 0000000..71868e6
--- /dev/null
+++ b/src/kern/arm/bsp/bcm2835/arm_control-arm-bcm283x.cpp
@@ -0,0 +1,112 @@
+INTERFACE [pf_bcm283x_rpi2 || pf_bcm283x_rpi3]: // ------------------------
+
+#include "assert.h"
+#include "kmem.h"
+#include "mmio_register_block.h"
+
+class Arm_control
+{
+public:
+  enum
+  {
+    nCNTPSIRQ       = 0,
+    nCNTPNSIRQ      = 1,
+    nCNTHPIRQ       = 2,
+    nCNTVIRQ        = 3,
+    Local_timer_irq = nCNTVIRQ,
+
+    Control                  = 0x00,
+    Prescaler                = 0x08,
+    Timer_irq_base           = 0x40,
+    Mailbox_irq_control_base = 0x50,
+    Irq_pending_base         = 0x60,
+    Fiq_pending_base         = 0x70,
+    Mailbox_set_base         = 0x80,
+    Mailbox_rd_clr_base      = 0xc0,
+  };
+
+  Arm_control()
+  : r(Kmem::mmio_remap(0x40000000))
+  {
+    r.r<32>(Control) = 0;
+    r.r<32>(Prescaler) =  1 << 31;
+  }
+
+private:
+  Mmio_register_block r;
+
+  static unsigned cpu_off(Cpu_phys_id cpu)
+  { return cxx::int_value<Cpu_phys_id>(cpu) * 4; }
+
+public:
+  void timer_mask(unsigned timer, Cpu_phys_id cpu = Proc::cpu_id())
+  {
+    r.r<32>(Timer_irq_base + cpu_off(cpu)).clear(1 << timer);
+  }
+
+  void timer_unmask(unsigned timer, Cpu_phys_id cpu = Proc::cpu_id())
+  {
+    r.r<32>(Timer_irq_base + cpu_off(cpu)).set(1 << timer);
+  }
+
+  void mailbox_mask(unsigned mbox, Cpu_phys_id cpu = Proc::cpu_id())
+  {
+    assert(mbox < 4);
+    r.r<32>(Mailbox_irq_control_base + cpu_off(cpu)).clear(1 << mbox);
+  }
+
+  void mailbox_unmask(unsigned mbox, Cpu_phys_id cpu = Proc::cpu_id())
+  {
+    assert(mbox < 4);
+    r.r<32>(Mailbox_irq_control_base + cpu_off(cpu)).set(1 << mbox);
+  }
+
+  Unsigned32 irqs_pending(Cpu_phys_id cpu = Proc::cpu_id())
+  { return r.r<32>(Irq_pending_base + cpu_off(cpu)); }
+
+  void send_ipi(unsigned ipi_msg, Cpu_phys_id to_cpu)
+  {
+    Mem::dsb();
+    unsigned cpu_num = cxx::int_value<Cpu_phys_id>(to_cpu);
+    r.r<32>(Mailbox_set_base + 16 * cpu_num) = 1 << ipi_msg;
+  }
+
+  unsigned ipi_pending()
+  {
+    unsigned cpu_num = cxx::int_value<Cpu_phys_id>(Proc::cpu_id());
+    unsigned mbox0_rdclk = Mailbox_rd_clr_base + 16 * cpu_num;
+
+    Unsigned32 v = r.r<32>(mbox0_rdclk);
+    unsigned m = 31 - __builtin_clz(v);
+    r.r<32>(mbox0_rdclk) = 1 << m;
+    return m;
+  }
+
+  static void init()
+  { _arm_control.construct(); };
+
+  static Arm_control *o() { return _arm_control.get(); }
+
+private:
+  static Static_object<Arm_control> _arm_control;
+};
+
+// ------------------------------------------------------------------------
+IMPLEMENTATION [pf_bcm283x_rpi2 || pf_bcm283x_rpi3]:
+
+Static_object<Arm_control> Arm_control::_arm_control;
+
+PRIVATE
+void
+Arm_control::do_boot_cpu(Cpu_phys_id phys_cpu, Address paddr)
+{
+  unsigned cpu_num = cxx::int_value<Cpu_phys_id>(phys_cpu);
+  unsigned mbox3_offset = 16 * cpu_num + 0xc;
+  Mem::dsb();
+  r.r<32>(Mailbox_set_base + mbox3_offset) = paddr;
+}
+
+PUBLIC static
+void
+Arm_control::boot_cpu(Cpu_phys_id phys_cpu, Address paddr)
+{ _arm_control->do_boot_cpu(phys_cpu, paddr); }
diff --git a/src/kern/arm/bsp/bcm2835/bootstrap-arm-bcm2835.cpp b/src/kern/arm/bsp/bcm2835/bootstrap-arm-bcm2835.cpp
index 2a6168f..51784a7 100644
--- a/src/kern/arm/bsp/bcm2835/bootstrap-arm-bcm2835.cpp
+++ b/src/kern/arm/bsp/bcm2835/bootstrap-arm-bcm2835.cpp
@@ -1,4 +1,4 @@
-INTERFACE [arm && pf_bcm2835]:
+INTERFACE [arm && pf_bcm283x]:
 
 EXTENSION class Bootstrap
 {
diff --git a/src/kern/arm/bsp/bcm2835/config-arm-bcm2835.cpp b/src/kern/arm/bsp/bcm2835/config-arm-bcm2835.cpp
index bffad73..46962c5 100644
--- a/src/kern/arm/bsp/bcm2835/config-arm-bcm2835.cpp
+++ b/src/kern/arm/bsp/bcm2835/config-arm-bcm2835.cpp
@@ -1,3 +1,11 @@
-INTERFACE [arm && pf_bcm2835]:
+INTERFACE [arm && pf_bcm283x && pf_bcm283x_rpi1]:
 
 #define TARGET_NAME "Broadcom 2835"
+
+INTERFACE [arm && pf_bcm283x && pf_bcm283x_rpi2]:
+
+#define TARGET_NAME "Broadcom 2836"
+
+INTERFACE [arm && pf_bcm283x && pf_bcm283x_rpi3]:
+
+#define TARGET_NAME "Broadcom 2837"
diff --git a/src/kern/arm/bsp/bcm2835/ipi-arm-bcm283x.cpp b/src/kern/arm/bsp/bcm2835/ipi-arm-bcm283x.cpp
new file mode 100644
index 0000000..49d2dfa
--- /dev/null
+++ b/src/kern/arm/bsp/bcm2835/ipi-arm-bcm283x.cpp
@@ -0,0 +1,63 @@
+INTERFACE [arm && pf_bcm283x && mp]: // -----------------------------------
+
+EXTENSION class Ipi
+{
+public:
+  enum Message { Global_request, Request, Debug, Timer };
+
+  static Message pending();
+
+private:
+  Cpu_phys_id _phys_id;
+};
+
+IMPLEMENTATION [arm && pf_bcm283x && mp]: // ------------------------------
+
+#include "arm_control.h"
+#include "cpu.h"
+
+IMPLEMENT
+void
+Ipi::init(Cpu_number cpu)
+{
+  _ipi.cpu(cpu)._phys_id = Proc::cpu_id();
+  Arm_control::o()->mailbox_unmask(0, Proc::cpu_id());
+}
+
+PUBLIC static
+void
+Ipi::send(Message m, Cpu_number from_cpu, Cpu_number to_cpu)
+{
+  Arm_control::o()->send_ipi(m, _ipi.cpu(to_cpu)._phys_id);
+  stat_sent(from_cpu);
+}
+
+PUBLIC static
+void
+Ipi::send(Message m, Cpu_number from_cpu, Cpu_phys_id to_cpu)
+{
+  Arm_control::o()->send_ipi(m, to_cpu);
+  stat_sent(from_cpu);
+}
+
+PUBLIC static
+void
+Ipi::bcast(Message m, Cpu_number from_cpu)
+{
+  for (Cpu_number n = Cpu_number::first(); n < Config::max_num_cpus(); ++n)
+    if (Cpu::online(n) && n != from_cpu)
+      send(m, from_cpu, n);
+}
+
+PUBLIC static inline
+void Ipi::eoi(Message, Cpu_number on_cpu)
+{
+  stat_received(on_cpu);
+}
+
+IMPLEMENT
+Ipi::Message
+Ipi::pending()
+{
+  return (Ipi::Message)Arm_control::o()->ipi_pending();
+}
diff --git a/src/kern/arm/bsp/bcm2835/irq_handler-arm-bcm2835.cpp b/src/kern/arm/bsp/bcm2835/irq_handler-arm-bcm2835.cpp
new file mode 100644
index 0000000..4ee0f38
--- /dev/null
+++ b/src/kern/arm/bsp/bcm2835/irq_handler-arm-bcm2835.cpp
@@ -0,0 +1,55 @@
+IMPLEMENTATION [arm && pf_bcm283x && pf_bcm283x_rpi1]:
+
+#include "pic.h"
+
+extern "C"
+void irq_handler()
+{ Pic::handle_irq(); }
+
+// ------------------------------------------------------------------------
+IMPLEMENTATION [arm && mp && (pf_bcm283x_rpi2 || pf_bcm283x_rpi3)]:
+
+#include "ipi.h"
+#include "thread.h"
+
+inline NEEDS["ipi.h", "thread.h"]
+void handle_ipis()
+{
+  Ipi::Message m = Ipi::pending();
+  switch (m)
+    {
+    case Ipi::Request: Thread::handle_remote_requests_irq(); break;
+    case Ipi::Global_request: Thread::handle_global_remote_requests_irq(); break;
+    case Ipi::Debug: Thread::handle_debug_remote_requests_irq(); break;
+    case Ipi::Timer: Thread::handle_timer_remote_requests_irq(0); break;
+    };
+}
+
+// ------------------------------------------------------------------------
+IMPLEMENTATION [arm && !mp && (pf_bcm283x_rpi2 || pf_bcm283x_rpi3)]:
+
+inline void handle_ipis() {}
+
+// ------------------------------------------------------------------------
+IMPLEMENTATION [arm && (pf_bcm283x_rpi2 || pf_bcm283x_rpi3)]:
+
+#include "pic.h"
+#include "timer_tick.h"
+#include "arm_control.h"
+
+extern "C"
+void irq_handler()
+{
+  while (Unsigned32 pending = Arm_control::o()->irqs_pending())
+    {
+      if (pending & (1 << 4)) // mailbox 0
+        handle_ipis();
+
+      if (pending & (1 << Timer::irq()))
+        Timer_tick::handler_all(0, 0);
+
+      if (pending & 0x100)
+        Pic::handle_irq();
+    }
+}
+
diff --git a/src/kern/arm/bsp/bcm2835/kernel_uart-arm-bcm2835.cpp b/src/kern/arm/bsp/bcm2835/kernel_uart-arm-bcm2835.cpp
index 3f6f9c3..82b23cc 100644
--- a/src/kern/arm/bsp/bcm2835/kernel_uart-arm-bcm2835.cpp
+++ b/src/kern/arm/bsp/bcm2835/kernel_uart-arm-bcm2835.cpp
@@ -1,9 +1,9 @@
-INTERFACE:
+INTERFACE [arm && pf_bcm283x && serial]:
 
 // On ARM the MMIO for the uart is accessible before the MMU is fully up
 EXTENSION class Kernel_uart { enum { Bsp_init_mode = Init_before_mmu }; };
 
-IMPLEMENTATION [arm && pf_bcm2835 && serial]:
+IMPLEMENTATION [arm && pf_bcm283x && serial]:
 
 IMPLEMENT
 bool Kernel_uart::startup(unsigned, int)
diff --git a/src/kern/arm/bsp/bcm2835/mem_layout-arm-bcm2835.cpp b/src/kern/arm/bsp/bcm2835/mem_layout-arm-bcm2835.cpp
index 8985b20..28a549b 100644
--- a/src/kern/arm/bsp/bcm2835/mem_layout-arm-bcm2835.cpp
+++ b/src/kern/arm/bsp/bcm2835/mem_layout-arm-bcm2835.cpp
@@ -1,12 +1,33 @@
-INTERFACE [arm && pf_bcm2835]: //---------------------------------------------
+INTERFACE [arm && pf_bcm283x_rpi1]: //-------------------------------------
 
 EXTENSION class Mem_layout
 {
 public:
   enum Phys_layout_bcm2835 : Address {
-    Timer_phys_base      = 0x20003000,
-    Pic_phys_base        = 0x2000b200,
-    Watchdog_phys_base   = 0x20100000,
-    Uart_phys_base       = 0x20201000,
+    Bcm283x_base = 0x20000000,
   };
 };
+
+INTERFACE [arm && (pf_bcm283x_rpi2 || pf_bcm283x_rpi3)]: //----------------
+
+EXTENSION class Mem_layout
+{
+public:
+  enum Phys_layout_bcm2836_7 : Address {
+    Bcm283x_base = 0x3f000000,
+  };
+};
+
+INTERFACE [arm && pf_bcm283x]: //------------------------------------------
+
+EXTENSION class Mem_layout
+{
+public:
+  enum Phys_layout_bcm283x : Address {
+    Pic_phys_base        = Bcm283x_base + 0x0000b200,
+    Timer_phys_base      = Bcm283x_base + 0x00003000,
+    Watchdog_phys_base   = Bcm283x_base + 0x00100000,
+    Uart_phys_base       = Bcm283x_base + 0x00201000,
+  };
+};
+
diff --git a/src/kern/arm/bsp/bcm2835/pic-arm-bcm2835.cpp b/src/kern/arm/bsp/bcm2835/pic-arm-bcm2835.cpp
index 2136c6a..e3b0c54 100644
--- a/src/kern/arm/bsp/bcm2835/pic-arm-bcm2835.cpp
+++ b/src/kern/arm/bsp/bcm2835/pic-arm-bcm2835.cpp
@@ -1,12 +1,12 @@
-INTERFACE [arm && pf_bcm2835]:
+INTERFACE [arm && pf_bcm283x]:
 
 #include "initcalls.h"
+#include "irq_chip_generic.h"
 
 // ---------------------------------------------------------------------
-IMPLEMENTATION [arm && pf_bcm2835]:
+IMPLEMENTATION [arm && pf_bcm283x]:
 
 #include "assert.h"
-#include "irq_chip_generic.h"
 #include "irq_mgr.h"
 #include "mmio_register_block.h"
 #include "kmem.h"
@@ -39,9 +39,9 @@ Irq_chip_bcm::Irq_chip_bcm()
 : Irq_chip_gen(96),
   Mmio_register_block(Kmem::mmio_remap(Mem_layout::Pic_phys_base))
 {
-  write<Mword>(~0UL, Disable_Basic_IRQs);
-  write<Mword>(~0UL, Disable_IRQs_1);
-  write<Mword>(~0UL, Disable_IRQs_2);
+  write<Unsigned32>(~0UL, Disable_Basic_IRQs);
+  write<Unsigned32>(~0UL, Disable_IRQs_1);
+  write<Unsigned32>(~0UL, Disable_IRQs_2);
 }
 
 PUBLIC
@@ -49,7 +49,7 @@ void
 Irq_chip_bcm::mask(Mword irq)
 {
   assert(cpu_lock.test());
-  write<Mword>(1 << (irq & 0x1f), Disable_IRQs_1 + ((irq & 0x60) >> 3));
+  write<Unsigned32>(1 << (irq & 0x1f), Disable_IRQs_1 + ((irq & 0x60) >> 3));
 }
 
 PUBLIC
@@ -65,35 +65,30 @@ void
 Irq_chip_bcm::unmask(Mword irq)
 {
   assert(cpu_lock.test());
-  write<Mword>(1 << (irq & 0x1f), Enable_IRQs_1 + ((irq & 0x60) >> 3));
+  write<Unsigned32>(1 << (irq & 0x1f), Enable_IRQs_1 + ((irq & 0x60) >> 3));
 }
 
 static Static_object<Irq_mgr_single_chip<Irq_chip_bcm> > mgr;
 
-PUBLIC static FIASCO_INIT
-void Pic::init()
-{
-  Irq_mgr::mgr = mgr.construct();
-}
 
 PUBLIC
 void
 Irq_chip_bcm::irq_handler()
 {
-  while (1)
+  for (;;)
     {
       unsigned b = 64;
-      Mword p = read<Mword>(Irq_basic_pending);
+      Unsigned32 p = read<Unsigned32>(Irq_basic_pending);
 
       if (p & 0x100)
         {
           b = 0;
-          p = read<Mword>(Irq_pending_1);
+          p = read<Unsigned32>(Irq_pending_1);
         }
       else if (p & 0x200)
         {
           b = 32;
-          p = read<Mword>(Irq_pending_2);
+          p = read<Unsigned32>(Irq_pending_2);
         }
       else if (p)
         {
@@ -115,12 +110,44 @@ Irq_chip_bcm::irq_handler()
     }
 }
 
-extern "C"
-void irq_handler()
-{ mgr->c.irq_handler(); }
+PUBLIC static
+void
+Pic::handle_irq()
+{
+  mgr->c.irq_handler();
+}
+
+// ------------------------------------------------------------------------
+IMPLEMENTATION [arm && pf_bcm283x && pf_bcm283x_rpi1]:
+
+PUBLIC static FIASCO_INIT
+void Pic::init()
+{
+  Irq_mgr::mgr = mgr.construct();
+}
+
+// ------------------------------------------------------------------------
+IMPLEMENTATION [arm && (pf_bcm283x_rpi2 || pf_bcm283x_rpi3)]:
+
+#include "arm_control.h"
+
+PUBLIC static FIASCO_INIT
+void Pic::init()
+{
+  Irq_mgr::mgr = mgr.construct();
+  Arm_control::init();
+}
+
+// ------------------------------------------------------------------------
+IMPLEMENTATION [arm && pf_bcm283x && mp]:
+
+PUBLIC static
+void
+Pic::init_ap(Cpu_number, bool)
+{}
 
 // ------------------------------------------------------------------------
-IMPLEMENTATION [arm && pf_bcm2835 && arm_em_tz]:
+IMPLEMENTATION [arm && pf_bcm283x && arm_em_tz]:
 
 #include <cstdio>
 
@@ -132,7 +159,7 @@ Pic::set_pending_irq(unsigned group32num, Unsigned32 val)
 }
 
 //---------------------------------------------------------------------------
-IMPLEMENTATION [debug && pf_bcm2835]:
+IMPLEMENTATION [debug && pf_bcm283x]:
 
 PUBLIC
 char const *
diff --git a/src/kern/arm/bsp/bcm2835/platform_control-arm-bcm283x.cpp b/src/kern/arm/bsp/bcm2835/platform_control-arm-bcm283x.cpp
new file mode 100644
index 0000000..d131a28
--- /dev/null
+++ b/src/kern/arm/bsp/bcm2835/platform_control-arm-bcm283x.cpp
@@ -0,0 +1,14 @@
+IMPLEMENTATION [arm && mp && pf_bcm283x]: // ------------------------------
+
+#include "arm_control.h"
+#include "cpu.h"
+
+PUBLIC static
+void
+Platform_control::boot_ap_cpus(Address phys_tramp_mp_addr)
+{
+  Cpu_phys_id myid = Proc::cpu_id();
+  for (unsigned i = 0; i < 4; ++i)
+    if (myid != Cpu_phys_id(i))
+      Arm_control::boot_cpu(Cpu_phys_id(i), phys_tramp_mp_addr);
+}
diff --git a/src/kern/arm/bsp/bcm2835/reset-arm-bcm2835.cpp b/src/kern/arm/bsp/bcm2835/reset-arm-bcm2835.cpp
index 39cb0d8..7e1180b 100644
--- a/src/kern/arm/bsp/bcm2835/reset-arm-bcm2835.cpp
+++ b/src/kern/arm/bsp/bcm2835/reset-arm-bcm2835.cpp
@@ -1,4 +1,4 @@
-IMPLEMENTATION [arm && pf_bcm2835]:
+IMPLEMENTATION [arm && pf_bcm283x]:
 
 #include "io.h"
 #include "kmem.h"
diff --git a/src/kern/arm/bsp/bcm2835/timer-arm-bcm2835.cpp b/src/kern/arm/bsp/bcm2835/timer-arm-bcm2835.cpp
index 53b7ab9..cc23305 100644
--- a/src/kern/arm/bsp/bcm2835/timer-arm-bcm2835.cpp
+++ b/src/kern/arm/bsp/bcm2835/timer-arm-bcm2835.cpp
@@ -1,5 +1,7 @@
 // --------------------------------------------------------------------------
-INTERFACE [arm && pf_bcm2835]:
+INTERFACE [arm && pf_bcm283x && pf_bcm283x_rpi1]:
+
+// HINT: This is drivers/clocksource/bcm2835_timer.c
 
 #include "mmio_register_block.h"
 
@@ -9,24 +11,56 @@ public:
   static unsigned irq() { return 3; }
 
 private:
-  enum {
-      CS  = 0,
-      CLO = 4,
-      CHI = 8,
-      C0  = 0xc,
-      C1  = 0x10,
-      C2  = 0x14,
-      C3  = 0x18,
-
-      Timer_nr = 3,
-      Interval = 1000,
+  enum
+  {
+    CS  = 0,
+    CLO = 4,
+    CHI = 8,
+    C0  = 0xc,
+    C1  = 0x10,
+    C2  = 0x14,
+    C3  = 0x18,
+
+    Timer_nr = 3,
+    Interval = 1000,
   };
 
   static Static_object<Timer> _timer;
 };
 
+// --------------------------------------------------------------------------
+INTERFACE [arm && pf_bcm283x && arm_generic_timer]:
+
+#include "per_cpu_data.h"
+
+EXTENSION class Timer
+{
+private:
+  static Per_cpu<Unsigned64> _initial_hi_val;
+};
+
+// --------------------------------------------------------------------------
+IMPLEMENTATION [arm && pf_bcm283x && arm_generic_timer]:
+
+IMPLEMENT inline
+void Timer::bsp_init(Cpu_number)
+{
+  // should probably read the hi val here?
+}
+
+PUBLIC static inline
+unsigned Timer::irq()
+{
+  switch (Gtimer::Type)
+    {
+    case Generic_timer::Physical: return 1; // use the non-secure IRQ
+    case Generic_timer::Virtual:  return 3;
+    case Generic_timer::Hyp:      return 2;
+    };
+}
+
 // ----------------------------------------------------------------------
-IMPLEMENTATION [arm && pf_bcm2835]:
+IMPLEMENTATION [arm && pf_bcm283x && pf_bcm283x_rpi1]:
 
 #include "config.h"
 #include "kip.h"
diff --git a/src/kern/arm/bsp/bcm2835/timer_tick-arm-bcm2835.cpp b/src/kern/arm/bsp/bcm2835/timer_tick-arm-bcm2835.cpp
new file mode 100644
index 0000000..b5d41b8
--- /dev/null
+++ b/src/kern/arm/bsp/bcm2835/timer_tick-arm-bcm2835.cpp
@@ -0,0 +1,32 @@
+IMPLEMENTATION [arm && (pf_bcm283x_rpi2 || pf_bcm283x_rpi3)]:
+
+#include "timer.h"
+#include "arm_control.h"
+
+IMPLEMENT
+void
+Timer_tick::setup(Cpu_number)
+{}
+
+IMPLEMENT
+void
+Timer_tick::enable(Cpu_number)
+{
+  Arm_control::o()->timer_unmask(Timer::irq());
+  Timer::enable();
+}
+
+IMPLEMENT
+void
+Timer_tick::disable(Cpu_number)
+{
+  Arm_control::o()->timer_mask(Timer::irq());
+}
+
+PUBLIC static inline
+void
+Timer_tick::ack()
+{
+  Timer::acknowledge();
+}
+
diff --git a/src/kern/arm/bsp/bcm2835/uart-arm-bcm2835.cpp b/src/kern/arm/bsp/bcm2835/uart-arm-bcm2835.cpp
index f78d0e6..b599c42 100644
--- a/src/kern/arm/bsp/bcm2835/uart-arm-bcm2835.cpp
+++ b/src/kern/arm/bsp/bcm2835/uart-arm-bcm2835.cpp
@@ -1,4 +1,4 @@
-IMPLEMENTATION [pf_bcm2835]:
+IMPLEMENTATION [pf_bcm283x && !pf_bcm283x_rpi3]:
 
 #include "uart_pl011.h"
 #include "mem_layout.h"
diff --git a/src/kern/arm/thread-arm.cpp b/src/kern/arm/thread-arm.cpp
index 793bc35..ed87514 100644
--- a/src/kern/arm/thread-arm.cpp
+++ b/src/kern/arm/thread-arm.cpp
@@ -536,6 +536,22 @@ public:
   static void kern_kdebug_ipi_entry() asm("kern_kdebug_ipi_entry");
 };
 
+PUBLIC static inline
+void
+Thread::handle_debug_remote_requests_irq()
+{
+  Ipi::eoi(Ipi::Debug, current_cpu());
+  Thread::kern_kdebug_ipi_entry();
+}
+
+PUBLIC static inline
+void
+Thread::handle_timer_remote_requests_irq(Upstream_irq const *ui)
+{
+  ui->ack();
+  current_thread()->handle_timer_interrupt();
+}
+
 class Thread_remote_rq_irq : public Irq_base
 {
 public:
@@ -573,10 +589,7 @@ class Thread_debug_ipi : public Irq_base
 public:
   // we assume IPIs to be top level, no upstream IRQ chips
   void handle(Upstream_irq const *)
-  {
-    Ipi::eoi(Ipi::Debug, current_cpu());
-    Thread::kern_kdebug_ipi_entry();
-  }
+  { Thread::handle_debug_remote_requests_irq(); }
 
   Thread_debug_ipi()
   {
@@ -591,13 +604,7 @@ class Thread_timer_tick_ipi : public Irq_base
 {
 public:
   void handle(Upstream_irq const *ui)
-  {
-    //Timer_tick *self = nonull_static_cast<Timer_tick *>(_s);
-    //self->ack();
-    ui->ack();
-    //self->log_timer();
-    current_thread()->handle_timer_interrupt();
-  }
+  { Thread::handle_timer_remote_requests_irq(ui); }
 
   Thread_timer_tick_ipi()
   { set_hit(&handler_wrapper<Thread_timer_tick_ipi>); }
@@ -607,7 +614,7 @@ public:
 
 
 //-----------------------------------------------------------------------------
-IMPLEMENTATION [mp && !irregular_gic]:
+IMPLEMENTATION [mp && !arm_single_ipi_irq && !irregular_gic]:
 
 class Arm_ipis
 {