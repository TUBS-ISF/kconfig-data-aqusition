"2018-02-09 09:07:50 +0100"
diff --git a/src/kern/mips/bsp/ci40/Kconfig b/src/kern/mips/bsp/ci40/Kconfig
new file mode 100644
index 0000000..facd8e6
--- /dev/null
+++ b/src/kern/mips/bsp/ci40/Kconfig
@@ -0,0 +1,7 @@
+# PF: CI40
+# PFDESCR: MIPS Creator Ci40
+# PFDEPENDS: MIPS
+# PFSELECT: SYS_HAS_CPU_MIPS32_R2
+# PFSELECT: HAS_MP_OPTION
+# PFSELECT: HAS_LIGHTWEIGHT_BARRIERS_OPTION
+# PFSELECT: DEFAULT_LIGHTWEIGHT_BARRIERS
diff --git a/src/kern/mips/bsp/ci40/Modules b/src/kern/mips/bsp/ci40/Modules
new file mode 100644
index 0000000..9eeac8a
--- /dev/null
+++ b/src/kern/mips/bsp/ci40/Modules
@@ -0,0 +1,14 @@
+# vim:set ft=make:
+
+RAM_PHYS_BASE      := 0x0
+PREPROCESS_PARTS   += ci40 libuart
+SUBSYSTEMS         += LIBUART
+OBJECTS_LIBUART    += uart_16550.o uart_16550_dw.o
+INTERFACES_KERNEL  += irq_mgr_flex mips_bsp_irqs gic cascade_irq
+
+mips_bsp_irqs_IMPL := mips_bsp_irqs-ci40
+clock_IMPL         += clock-generic
+uart_IMPL          += uart-16550-ci40
+kernel_uart_IMPL   += kernel_uart-libuart
+reset_IMPL         += reset-mips-ci40
+timer_tick_IMPL    += timer_tick-single-vector timer_tick-mips-cp0
diff --git a/src/kern/mips/bsp/ci40/mips_bsp_irqs-ci40.cpp b/src/kern/mips/bsp/ci40/mips_bsp_irqs-ci40.cpp
new file mode 100644
index 0000000..8c2b5cd
--- /dev/null
+++ b/src/kern/mips/bsp/ci40/mips_bsp_irqs-ci40.cpp
@@ -0,0 +1,56 @@
+INTERFACE:
+
+#include "types.h"
+
+class Mips_bsp_irqs {};
+
+IMPLEMENTATION:
+
+#include "irq_mgr_flex.h"
+#include "boot_alloc.h"
+#include "assert.h"
+#include "cascade_irq.h"
+#include "mips_cpu_irqs.h"
+#include "gic.h"
+#include "kmem.h"
+#include "cm.h"
+
+static void gic_hit(Irq_base *_self, Upstream_irq const *u)
+{
+  Cascade_irq *self = nonull_static_cast<Cascade_irq *>(_self);
+  Gic *i = nonull_static_cast<Gic *>(self->child());
+  Upstream_irq ui(self, u);
+  unsigned irq = i->pending();
+
+  if (EXPECT_TRUE(irq != ~0u))
+    i->handle_irq<Gic>(irq, &ui);
+}
+
+PUBLIC static
+void
+Mips_bsp_irqs::init(Cpu_number cpu)
+{
+  if (cpu != Cpu_number::boot_cpu())
+    return;
+
+  auto *m =  new Boot_object<Irq_mgr_flex<10> >();
+  Irq_mgr::mgr = m;
+
+  Address my_gic_base = 0x1bdc0000;
+  Cm::cm->set_gic_base_and_enable(my_gic_base);
+
+  auto *gic = new Boot_object<Gic>(Kmem::mmio_remap(my_gic_base), 2);
+  auto *c = new Boot_object<Cascade_irq>(gic, gic_hit);
+  Mips_cpu_irqs::chip->alloc(c, 2);
+  c->unmask();
+  m->add_chip(gic, 0); // expose GIC IRQs starting from IRQ 0
+
+  m->print_infos();
+}
+
+PUBLIC static
+void
+Mips_bsp_irqs::init_ap(Cpu_number)
+{
+  Mips_cpu_irqs::chip->unmask(2); // GIC
+}
diff --git a/src/kern/mips/bsp/ci40/reset-mips-ci40.cpp b/src/kern/mips/bsp/ci40/reset-mips-ci40.cpp
new file mode 100644
index 0000000..d02fa4a
--- /dev/null
+++ b/src/kern/mips/bsp/ci40/reset-mips-ci40.cpp
@@ -0,0 +1,14 @@
+IMPLEMENTATION [mips && ci40]:
+
+#include "kmem.h"
+#include "mmio_register_block.h"
+
+void __attribute__ ((noreturn))
+platform_reset(void)
+{
+  Register_block<32> wdg(Kmem::mmio_remap(0x18102100));
+  wdg[0] = 1;
+
+  for (;;)
+    ;
+}
diff --git a/src/kern/mips/bsp/ci40/uart-16550-ci40.cpp b/src/kern/mips/bsp/ci40/uart-16550-ci40.cpp
new file mode 100644
index 0000000..70aeb5a
--- /dev/null
+++ b/src/kern/mips/bsp/ci40/uart-16550-ci40.cpp
@@ -0,0 +1,31 @@
+IMPLEMENTATION [ci40]:
+
+// TODO: Use generic 16550_dw tag for all uart_16550_dw users
+
+#include "koptions.h"
+#include "uart_16550_dw.h"
+
+IMPLEMENT Address Uart::base() const
+{ return Koptions::o()->uart.base_address; }
+
+IMPLEMENT int Uart::irq() const
+{ return Koptions::o()->uart.irqno; }
+
+IMPLEMENT L4::Uart *Uart::uart()
+{
+  static L4::Uart_16550_dw uart(Koptions::o()->uart.base_baud);
+  return &uart;
+}
+
+IMPLEMENT
+Uart::Uart() : Console(DISABLED) {}
+
+PUBLIC bool
+Uart::startup(L4::Io_register_block const *r, int, Unsigned32)
+{
+  if (!uart()->startup(r))
+    return false;
+
+  add_state(ENABLED);
+  return true;
+}