"2018-02-09 09:07:52 +0100"
diff --git a/src/kern/arm/bsp/zynqmp/Kconfig b/src/kern/arm/bsp/zynqmp/Kconfig
new file mode 100644
index 0000000..246222a
--- /dev/null
+++ b/src/kern/arm/bsp/zynqmp/Kconfig
@@ -0,0 +1,5 @@
+# PF: ZYNQMP
+# PFDESCR: Xilinx Zynq UltraSCALE+ MPSoC
+# PFSELECT: CAN_ARM_CPU_CORTEX_A53 HAS_ARM_PSCI
+# PFSELECT: ARM_PSCI
+# PFDEPENDS: ARM
diff --git a/src/kern/arm/bsp/zynqmp/Modules b/src/kern/arm/bsp/zynqmp/Modules
new file mode 100644
index 0000000..076d401
--- /dev/null
+++ b/src/kern/arm/bsp/zynqmp/Modules
@@ -0,0 +1,19 @@
+# vim:set ft=make:
+
+SUBSYSTEMS            += LIBUART
+OBJECTS_LIBUART       += uart_cadence.o
+PREPROCESS_PARTS      += libuart generic_tickless_idle \
+                         arm_generic_timer pic_gic psci
+INTERFACES_KERNEL     += gic generic_timer
+RAM_PHYS_BASE         := 0x0
+
+uart_IMPL             += uart-arm-zynqmp
+config_IMPL           += config-arm-zynqmp
+mem_layout_IMPL       += mem_layout-arm-zynqmp
+pic_IMPL              += pic-gic pic-arm-zynqmp
+timer_IMPL            += timer-arm-generic timer-arm-generic-zynqmp
+timer_tick_IMPL       += timer_tick-single-vector
+kernel_uart_IMPL      += kernel_uart-arm-zynqmp
+reset_IMPL            += reset-arm-zynqmp
+clock_IMPL            += clock-generic
+platform_control_IMPL += platform_control-arm-zynqmp
diff --git a/src/kern/arm/bsp/zynqmp/config-arm-zynqmp.cpp b/src/kern/arm/bsp/zynqmp/config-arm-zynqmp.cpp
new file mode 100644
index 0000000..c11492c
--- /dev/null
+++ b/src/kern/arm/bsp/zynqmp/config-arm-zynqmp.cpp
@@ -0,0 +1,3 @@
+INTERFACE [arm && pf_zynqmp]:
+
+#define TARGET_NAME "Xilinx Zynq UltraSCALE+ MPSoC"
diff --git a/src/kern/arm/bsp/zynqmp/kernel_uart-arm-zynqmp.cpp b/src/kern/arm/bsp/zynqmp/kernel_uart-arm-zynqmp.cpp
new file mode 100644
index 0000000..480b713
--- /dev/null
+++ b/src/kern/arm/bsp/zynqmp/kernel_uart-arm-zynqmp.cpp
@@ -0,0 +1,12 @@
+INTERFACE [arm && pf_zynqmp]:
+
+// On ARM the MMIO for the uart is accessible before the MMU is fully up
+EXTENSION class Kernel_uart { enum { Bsp_init_mode = Init_before_mmu }; };
+
+IMPLEMENTATION [arm && serial && pf_zynqmp]:
+
+IMPLEMENT
+bool Kernel_uart::startup(unsigned, int)
+{
+  return Uart::startup();
+}
diff --git a/src/kern/arm/bsp/zynqmp/mem_layout-arm-zynqmp.cpp b/src/kern/arm/bsp/zynqmp/mem_layout-arm-zynqmp.cpp
new file mode 100644
index 0000000..921e54f
--- /dev/null
+++ b/src/kern/arm/bsp/zynqmp/mem_layout-arm-zynqmp.cpp
@@ -0,0 +1,12 @@
+INTERFACE [arm && pf_zynqmp]: //-------------------------------------------
+
+EXTENSION class Mem_layout
+{
+public:
+  enum Phys_layout_zynqmp: Address {
+    Gic_cpu_phys_base    = 0xf9020000,
+    Gic_dist_phys_base   = 0xf9010000,
+    Gic_h_phys_base      = 0xf9040000,
+    Gic_v_phys_base      = 0xf9060000,
+  };
+};
diff --git a/src/kern/arm/bsp/zynqmp/pic-arm-zynqmp.cpp b/src/kern/arm/bsp/zynqmp/pic-arm-zynqmp.cpp
new file mode 100644
index 0000000..675d37a
--- /dev/null
+++ b/src/kern/arm/bsp/zynqmp/pic-arm-zynqmp.cpp
@@ -0,0 +1,34 @@
+INTERFACE [arm && pic_gic && pf_zynqmp]:
+
+#include "gic.h"
+#include "initcalls.h"
+
+// ------------------------------------------------------------------------
+IMPLEMENTATION [arm && pic_gic && pf_zynqmp]:
+
+#include "irq_mgr_multi_chip.h"
+#include "kmem.h"
+
+PUBLIC static FIASCO_INIT
+void
+Pic::init()
+{
+  typedef Irq_mgr_multi_chip<9> M;
+
+  M *m = new Boot_object<M>(1);
+
+  gic.construct(Kmem::mmio_remap(Mem_layout::Gic_cpu_phys_base),
+                Kmem::mmio_remap(Mem_layout::Gic_dist_phys_base));
+  m->add_chip(0, gic, gic->nr_irqs());
+
+  Irq_mgr::mgr = m;
+}
+
+// ------------------------------------------------------------------------
+IMPLEMENTATION [arm && pic_gic && mp && pf_zynqmp]:
+
+PUBLIC static
+void Pic::init_ap(Cpu_number, bool resume)
+{
+  gic->init_ap(resume);
+}
diff --git a/src/kern/arm/bsp/zynqmp/platform_control-arm-zynqmp.cpp b/src/kern/arm/bsp/zynqmp/platform_control-arm-zynqmp.cpp
new file mode 100644
index 0000000..004fdaf
--- /dev/null
+++ b/src/kern/arm/bsp/zynqmp/platform_control-arm-zynqmp.cpp
@@ -0,0 +1,34 @@
+IMPLEMENTATION [arm && mp && pf_zynqmp]:
+
+#include "cpu.h"
+#include "mem.h"
+#include "mmio_register_block.h"
+#include "kmem.h"
+
+#include <cstdio>
+
+PUBLIC static
+void
+Platform_control::boot_ap_cpus(Address phys_tramp_mp_addr)
+{
+  for (int i = 0; i < 4; ++i)
+    {
+      unsigned coreid[4] = { 0x0, 0x1, 0x2, 0x3 };
+      int r = cpu_on(coreid[i], phys_tramp_mp_addr);
+      if (r)
+        {
+          if (r != Psci_already_on)
+            printf("CPU%d boot-up error: %d\n", i, r);
+          continue;
+        }
+
+      // The Zynq-MP firmware will not boot all CPUs if we fire CPU_ON
+      // events too fast, thus wait for each CPU to appear so that we do not
+      // overburden the firmware.
+      while (!Cpu::online(Cpu_number(i)))
+        {
+          Mem::barrier();
+          Proc::pause();
+        }
+    }
+}
diff --git a/src/kern/arm/bsp/zynqmp/reset-arm-zynqmp.cpp b/src/kern/arm/bsp/zynqmp/reset-arm-zynqmp.cpp
new file mode 100644
index 0000000..cc08b9d
--- /dev/null
+++ b/src/kern/arm/bsp/zynqmp/reset-arm-zynqmp.cpp
@@ -0,0 +1,11 @@
+IMPLEMENTATION [arm && pf_zynqmp]:
+
+#include "platform_control.h"
+
+void __attribute__ ((noreturn))
+platform_reset(void)
+{
+  Platform_control::system_reset();
+  for (;;)
+    ;
+}
diff --git a/src/kern/arm/bsp/zynqmp/timer-arm-generic-zynqmp.cpp b/src/kern/arm/bsp/zynqmp/timer-arm-generic-zynqmp.cpp
new file mode 100644
index 0000000..bdb85a4
--- /dev/null
+++ b/src/kern/arm/bsp/zynqmp/timer-arm-generic-zynqmp.cpp
@@ -0,0 +1,18 @@
+IMPLEMENTATION [arm_generic_timer && pf_zynqmp]:
+
+#include "mem_layout.h"
+
+PUBLIC static
+unsigned Timer::irq()
+{
+  switch (Gtimer::Type)
+    {
+    case Generic_timer::Physical: return 29;
+    case Generic_timer::Virtual:  return 27;
+    case Generic_timer::Hyp:      return 26;
+    };
+}
+
+IMPLEMENT
+void Timer::bsp_init(Cpu_number)
+{}
diff --git a/src/kern/arm/bsp/zynqmp/uart-arm-zynqmp.cpp b/src/kern/arm/bsp/zynqmp/uart-arm-zynqmp.cpp
new file mode 100644
index 0000000..9f694ea
--- /dev/null
+++ b/src/kern/arm/bsp/zynqmp/uart-arm-zynqmp.cpp
@@ -0,0 +1,16 @@
+IMPLEMENTATION [arm && pf_zynqmp]:
+
+#include "koptions.h"
+#include "uart_cadence.h"
+
+IMPLEMENT Address Uart::base() const
+{ return Koptions::o()->uart.base_address; }
+
+IMPLEMENT int Uart::irq() const
+{ return Koptions::o()->uart.irqno; }
+
+IMPLEMENT L4::Uart *Uart::uart()
+{
+  static L4::Uart_cadence uart(Koptions::o()->uart.base_baud);
+  return &uart;
+}
diff --git a/src/templates/globalconfig.out.arm64-zynqmp b/src/templates/globalconfig.out.arm64-zynqmp
new file mode 100644
index 0000000..3334aa7
--- /dev/null
+++ b/src/templates/globalconfig.out.arm64-zynqmp
@@ -0,0 +1,4 @@
+CONFIG_ARM=y
+CONFIG_PF_ZYNQMP=y
+CONFIG_CPU_VIRT=y
+CONFIG_MP=y