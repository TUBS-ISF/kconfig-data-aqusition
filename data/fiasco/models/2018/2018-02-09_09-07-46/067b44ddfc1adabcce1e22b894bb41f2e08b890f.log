"2018-02-09 09:07:46 +0100"
diff --git a/src/Modules.arm b/src/Modules.arm
index f24dba5..b24e7af 100644
--- a/src/Modules.arm
+++ b/src/Modules.arm
@@ -55,6 +55,7 @@ PREPROCESS_PARTS-$(CONFIG_SCHED_FP_WFQ)      += sched_fp_wfq
 PREPROCESS_PARTS-$(CONFIG_ARM_LPAE)          += arm_lpae
 PREPROCESS_PARTS-$(CONFIG_CPU_VIRT)                 += hyp vgic arm_esr_traps
 PREPROCESS_PARTS-y$(CONFIG_CPU_VIRT)$(CONFIG_BIT64) += noncont_mem
+PREPROCESS_PARTS-$(CONFIG_ARM_PSCI)                 += psci
 
 
 #
@@ -199,6 +200,7 @@ outer_cache_IMPL	:= outer_cache outer_cache-l2cxx0
 paging_IMPL	  	:= paging-arm paging-arm-$(BITS) paging
 perf_cnt_IMPL		:= perf_cnt perf_cnt-arm perf_cnt-arm-$(BITS)
 pic_IMPL		:= pic
+platform_control_IMPL	+= platform_control-arm-psci
 sched_context_IMPL	:= sched_context-wfq sched_context-fixed_prio \
 			   sched_context-fp_wfq sched_context
 scu_IMPL                := scu
diff --git a/src/kern/arm/Kconfig b/src/kern/arm/Kconfig
index c696196..eee746b 100644
--- a/src/kern/arm/Kconfig
+++ b/src/kern/arm/Kconfig
@@ -243,6 +243,16 @@ config ARM_LPAE
         help
           Use the extended page table format (LPAE).
 
+config HAS_ARM_PSCI
+        bool
+
+config ARM_PSCI
+        bool "Use PSCI"
+        depends on HAS_ARM_PSCI
+        help
+          Use the "Power State Coordination Interface" (PSCI) for system
+          functions such as booting CPUs.
+
 config ARM_1176_CACHE_ALIAS_FIX
 	bool "Use cache restriction to supress aliasing issue on ARM1176"
 	depends on ARM_1176
diff --git a/src/kern/arm/bsp/ls1021a/Kconfig b/src/kern/arm/bsp/ls1021a/Kconfig
index 1733293..8b0cf80 100644
--- a/src/kern/arm/bsp/ls1021a/Kconfig
+++ b/src/kern/arm/bsp/ls1021a/Kconfig
@@ -1,4 +1,4 @@
 # PF: LS1021A
 # PFDESCR: NXP/Freescale Layerscape LS1021A
-# PFSELECT: CAN_ARM_CPU_CORTEX_A7 HAS_CPU_VIRT
+# PFSELECT: CAN_ARM_CPU_CORTEX_A7 HAS_CPU_VIRT HAS_ARM_PSCI
 # PFDEPENDS: ARM
diff --git a/src/kern/arm/bsp/ls1021a/platform_control-arm-ls1021a.cpp b/src/kern/arm/bsp/ls1021a/platform_control-arm-ls1021a.cpp
index 20808d5..7254324 100644
--- a/src/kern/arm/bsp/ls1021a/platform_control-arm-ls1021a.cpp
+++ b/src/kern/arm/bsp/ls1021a/platform_control-arm-ls1021a.cpp
@@ -1,4 +1,4 @@
-IMPLEMENTATION [arm && mp && ls1021a]: // ---------------------------------
+IMPLEMENTATION [arm && mp && ls1021a && !psci]: // ------------------------
 
 #include "ipi.h"
 #include "mem.h"
@@ -15,3 +15,13 @@ Platform_control::boot_ap_cpus(Address phys_tramp_mp_addr)
   Mem::mp_wmb();
   Ipi::bcast(Ipi::Global_request, Cpu_number::boot_cpu());
 }
+
+IMPLEMENTATION [arm && mp && ls1021a && psci]: // -------------------------
+
+PUBLIC static
+void
+Platform_control::boot_ap_cpus(Address phys_tramp_mp_addr)
+{
+  if (cpu_on(0xf01, phys_tramp_mp_addr))
+    printf("KERNEL: PSCI CPU_ON failed\n");
+}
diff --git a/src/kern/arm/platform_control-arm-psci.cpp b/src/kern/arm/platform_control-arm-psci.cpp
new file mode 100644
index 0000000..4133ca4
--- /dev/null
+++ b/src/kern/arm/platform_control-arm-psci.cpp
@@ -0,0 +1,143 @@
+INTERFACE [arm && psci]:
+
+#include <types.h>
+
+EXTENSION class Platform_control
+{
+public:
+  struct Psci_result
+  {
+    Mword res[4];
+  };
+
+
+private:
+  enum Psci_error_codes
+  {
+    Psci_success       =  0,
+    Psci_not_supported = -1,
+  };
+
+  enum Psci_functions
+  {
+    Psci_base_smc32          = 0x84000000,
+    Psci_base_smc64          = 0xC4000000,
+
+    Psci_version             = 0,
+    Psci_cpu_suspend         = 1,
+    Psci_cpu_off             = 2,
+    Psci_cpu_on              = 3,
+    Psci_affinity_info       = 4,
+    Psci_migrate             = 5,
+    Psci_migrate_info_type   = 6,
+    Psci_migrate_info_up_cpu = 7,
+    Psci_system_off          = 8,
+    Psci_system_reset        = 9,
+    Psci_features            = 10,
+    Psci_cpu_freeze          = 11,
+    Psci_cpu_default_suspend = 12,
+    Psci_node_hw_state       = 13,
+    Psci_system_suspend      = 14,
+    Psci_set_suspend_mode    = 15,
+    Psci_stat_residency      = 16,
+    Psci_stat_count          = 17,
+  };
+
+  static bool psci_is_v1;
+};
+
+IMPLEMENTATION [arm && psci]:
+
+#include "mem.h"
+#include "mmio_register_block.h"
+#include "kmem.h"
+
+#include <cstdio>
+
+bool Platform_control::psci_is_v1;
+
+PRIVATE static
+unsigned long
+Platform_control::psci_fn(unsigned fn)
+{
+  switch (fn)
+    {
+    case Psci_version:
+    case Psci_cpu_off:
+    case Psci_migrate_info_type:
+    case Psci_system_off:
+    case Psci_system_reset:
+    case Psci_features:
+    case Psci_cpu_freeze:
+    case Psci_set_suspend_mode:
+      return Psci_base_smc32 + fn;
+    default:
+      return (sizeof(long) == 8 ? Psci_base_smc64 : Psci_base_smc32) + fn;
+    };
+}
+
+PUBLIC static inline
+Platform_control::Psci_result
+Platform_control::psci_call(Mword fn_id,
+                            Mword a0 = 0, Mword a1 = 0,
+                            Mword a2 = 0, Mword a3 = 0,
+                            Mword a4 = 0, Mword a5 = 0,
+                            Mword a6 = 0)
+{
+  register Mword r0 asm("r0") = psci_fn(fn_id);
+  register Mword r1 asm("r1") = a0;
+  register Mword r2 asm("r2") = a1;
+  register Mword r3 asm("r3") = a2;
+  register Mword r4 asm("r4") = a3;
+  register Mword r5 asm("r5") = a4;
+  register Mword r6 asm("r6") = a5;
+  register Mword r7 asm("r7") = a6;
+
+  asm volatile("smc #0"
+              : "=r" (r0), "=r" (r1), "=r" (r2), "=r" (r3)
+              : "0" (r0), "1" (r1), "2" (r2), "3" (r3),
+                "r" (r4), "r" (r5), "r" (r6), "r" (r7)
+              : "memory");
+
+  return { r0, r1, r2, r3 };
+}
+
+IMPLEMENT_OVERRIDE
+void
+Platform_control::init(Cpu_number cpu)
+{
+  if (cpu != Cpu_number::boot_cpu())
+    return;
+
+  Psci_result r = psci_call(Psci_version);
+  printf("Detected PSCI v%ld.%ld\n", r.res[0] >> 16, r.res[0] & 0xffff);
+
+  psci_is_v1 = (r.res[0] >> 16) >= 1;
+
+  if (psci_is_v1)
+    {
+      r = psci_call(Psci_features, psci_fn(Psci_cpu_suspend));
+      if (r.res[0] & (1UL << 31))
+        printf("PSCI: CPU_Suspend not supported (%d)\n", (int)r.res[0]);
+      else
+        printf("PSCI: CPU_SUSPEND format %s, %ssupports OS initiated mode\n",
+               r.res[0] & 2 ? "extended" : "original v0.2",
+               r.res[0] & 1 ? "" : "not ");
+    }
+
+  r = psci_call(Psci_migrate_info_type);
+
+  if (r.res[0] == 0 || r.res[0] == 1)
+    printf("PSCI: TOS: single core, %smigration capable.\n",
+           r.res[0] ? "not " : "");
+  else
+    printf("PSCI: TOS: Not present or not required.\n");
+}
+
+PUBLIC static
+int
+Platform_control::cpu_on(unsigned long target, Address phys_tramp_mp_addr)
+{
+  Psci_result r = psci_call(Psci_cpu_on, target, phys_tramp_mp_addr);
+  return r.res[0];
+}