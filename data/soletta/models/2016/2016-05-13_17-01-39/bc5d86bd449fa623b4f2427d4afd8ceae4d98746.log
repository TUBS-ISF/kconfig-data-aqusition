"2016-05-13 17:01:39 -0300"
diff --git a/doc/js-spec/oic.md b/doc/js-spec/oic.md
index f2cc5cbc..e1faa038 100644
--- a/doc/js-spec/oic.md
+++ b/doc/js-spec/oic.md
@@ -55,7 +55,7 @@ Resource representation properties shall not be created and deleted one by one.
 **Resource discovery** is based on the existence of resources (directories) set up for discovery. It can be achieved in 3 ways:
 - direct discovery through peer inquiry (unicast or multicast)
 - indirect discovery based on a 3rd party directory (a server for resource discovery)
-- presence advertisment: the resource enabling discovery is local to the initiator, and it is maintained by presence notifications.
+- presence advertisement: the resource enabling discovery is local to the initiator, and it is maintained by presence notifications.
 
 Implementations should encapsulate the resource discovery type, and should map the DiscoveryOptions values to the best suited protocol request(s).
 
diff --git a/src/lib/common/Kconfig b/src/lib/common/Kconfig
index 08318c51..762af462 100644
--- a/src/lib/common/Kconfig
+++ b/src/lib/common/Kconfig
@@ -174,7 +174,7 @@ choice
 	default MAINLOOP_ZEPHYR if ZEPHYR
 	help
             The main loop is used to provide uniform event delivering
-            accross multiple operating systems.
+            across multiple operating systems.
 
             Some operating systems will deliver events from an
             userspace handle (ie: Linux does so via file descriptors),
diff --git a/src/lib/common/include/sol-types.h b/src/lib/common/include/sol-types.h
index b0a59925..d701939e 100644
--- a/src/lib/common/include/sol-types.h
+++ b/src/lib/common/include/sol-types.h
@@ -573,7 +573,7 @@ void sol_blob_set_parent(struct sol_blob *blob, struct sol_blob *parent);
  * @param mem memory that blob will duplicate and refers to
  * @param size size of memory block
  *
- * @return new sol_blob on sucess. @c NULL on failure
+ * @return new sol_blob on success. @c NULL on failure
  */
 static inline struct sol_blob *
 sol_blob_new_dup(const void *mem, size_t size)
@@ -612,7 +612,7 @@ fail:
  *
  * @param str string to be duplicated in a blob.
  *
- * @return new sol_blob on sucess. @c NULL on failure
+ * @return new sol_blob on success. @c NULL on failure
  */
 static inline struct sol_blob *
 sol_blob_new_dup_str(const char *str)
diff --git a/src/lib/comms/include/sol-oic-server.h b/src/lib/comms/include/sol-oic-server.h
index a7e3dd97..7b1da7bc 100644
--- a/src/lib/comms/include/sol-oic-server.h
+++ b/src/lib/comms/include/sol-oic-server.h
@@ -211,7 +211,7 @@ int sol_oic_server_send_notification_to_observers(struct sol_oic_response *notif
 struct sol_oic_response *sol_oic_server_notification_new(struct sol_oic_server_resource *resource);
 
 /**
- * @brief Send a reponse as a reply to a request.
+ * @brief Send a response as a reply to a request.
  *
  * After sending the response, response and request elements memory are released
  * even on errors.
diff --git a/src/lib/io/include/sol-ipm.h b/src/lib/io/include/sol-ipm.h
index ab23ca10..54cbdb06 100644
--- a/src/lib/io/include/sol-ipm.h
+++ b/src/lib/io/include/sol-ipm.h
@@ -70,7 +70,7 @@ extern "C" {
  *
  * @note One can not override a current receiver callback. To change current
  * callback for a given id, one must first set callback to @c NULL. This is so
- * to avoid accidentaly changing callback.
+ * to avoid accidentally changing callback.
  *
  * @attention Soletta reserves id 0 - do not use it.
  */
@@ -114,7 +114,7 @@ int sol_ipm_send(uint32_t id, struct sol_blob *message);
  *
  * @note One can not override a current consumed callback. To change current
  * callback for a given id, one must first set callback to @c NULL. This is so
- * to avoid accidentaly changing callback.
+ * to avoid accidentally changing callback.
  *
  * @attention Soletta reserves id 0 - do not use it.
  */
diff --git a/src/modules/flow/boolean/boolean.json b/src/modules/flow/boolean/boolean.json
index 0216ed28..4b2a8375 100644
--- a/src/modules/flow/boolean/boolean.json
+++ b/src/modules/flow/boolean/boolean.json
@@ -264,7 +264,7 @@
           {
             "data_type": "boolean",
             "default": false,
-            "description": "If enabled, it will work just like a circular buffer, so after samples ammount is reached it will send a new packet every time a new value is received, reusing last received values. If set to false, after a packet is sent it needs to wait for all samples again (or timeout) since it resets the buffer when samples ammount is reached.",
+            "description": "If enabled, it will work just like a circular buffer, so after samples amount is reached it will send a new packet every time a new value is received, reusing last received values. If set to false, after a packet is sent it needs to wait for all samples again (or timeout) since it resets the buffer when samples amount is reached.",
             "name": "circular"
           }
         ],
diff --git a/src/modules/flow/float/float.json b/src/modules/flow/float/float.json
index c9c25e4d..fef5a366 100644
--- a/src/modules/flow/float/float.json
+++ b/src/modules/flow/float/float.json
@@ -47,7 +47,7 @@
       "in_ports": [
         {
           "data_type": "float",
-          "description": "Recieves dividend value.",
+          "description": "Receives dividend value.",
           "methods": {
             "process": "operator_process"
           },
diff --git a/src/modules/flow/int/int.json b/src/modules/flow/int/int.json
index 4e364f85..d7ee46ae 100644
--- a/src/modules/flow/int/int.json
+++ b/src/modules/flow/int/int.json
@@ -592,7 +592,7 @@
           {
             "data_type": "boolean",
             "default": false,
-            "description": "If enabled, it will work just like a circular buffer, so after samples ammount is reached it will send a new packet every time a new value is received, reusing last received values. If set to false, after a packet is sent it needs to wait for all samples again (or timeout) since it resets the buffer when samples ammount is reached.",
+            "description": "If enabled, it will work just like a circular buffer, so after samples amount is reached it will send a new packet every time a new value is received, reusing last received values. If set to false, after a packet is sent it needs to wait for all samples again (or timeout) since it resets the buffer when samples amount is reached.",
             "name": "circular"
           }
         ],
diff --git a/src/modules/flow/string/Kconfig b/src/modules/flow/string/Kconfig
index dd9d5110..e6f0e156 100644
--- a/src/modules/flow/string/Kconfig
+++ b/src/modules/flow/string/Kconfig
@@ -12,7 +12,7 @@ config FLOW_NODE_TYPE_STRING
 		 - check if a string is empty
 		 - compare/concatenate two strings
 		 - replace a substring in a string
-		 - measure the lenght of the string
+		 - measure the length of the string
 		 - change a string to lower/uppercase
 		 - check whether a string stards/ends with another
 
diff --git a/src/modules/flow/update/update.json b/src/modules/flow/update/update.json
index 30dc3116..bd11191b 100644
--- a/src/modules/flow/update/update.json
+++ b/src/modules/flow/update/update.json
@@ -119,7 +119,7 @@
       "out_ports": [
         {
           "data_type": "boolean",
-          "description": "If FETCH was successfuly completed",
+          "description": "If FETCH was successfully completed",
           "name": "SUCCESS"
         },
         {
@@ -175,7 +175,7 @@
       "out_ports": [
         {
           "data_type": "boolean",
-          "description": "If install completed successfuly, sends true, false otherwise. Note that errors packet may be sent in case of failure",
+          "description": "If install completed successfully, sends true, false otherwise. Note that errors packet may be sent in case of failure",
           "name": "SUCCESS"
         },
         {
diff --git a/src/samples/flow/c-api/simplectype.c b/src/samples/flow/c-api/simplectype.c
index a8ab696c..188abc14 100644
--- a/src/samples/flow/c-api/simplectype.c
+++ b/src/samples/flow/c-api/simplectype.c
@@ -76,7 +76,7 @@ isodd(struct sol_flow_node *node, const struct sol_flow_simplectype_event *ev, v
  * It will take options at node open, keep context and handle all
  * events.
  *
- * It stores an integer and a boolean, initially set throught options
+ * It stores an integer and a boolean, initially set through options
  * and then modified via input ports, then from time to time (every
  * 500ms) it will create a string with both values and send on its
  * output port.
diff --git a/src/samples/flow/js/attendee.fbp b/src/samples/flow/js/attendee.fbp
index 53a99431..9def4455 100755
--- a/src/samples/flow/js/attendee.fbp
+++ b/src/samples/flow/js/attendee.fbp
@@ -19,7 +19,7 @@
 # This is a sample where you have the attendee (that will call the next in line)
 # and two different lines, common and preferential (that has higher priority).
 #
-# Everytime the a line button is pressed (common or preferential) it generates
+# Every time the a line button is pressed (common or preferential) it generates
 # a new number to be called, preferential numbers are 1-99 and common are 101-999.
 #
 # In order to do so we created our custom JS node type, MyAttendee from attendee.js
diff --git a/src/samples/flow/js/attendee.js b/src/samples/flow/js/attendee.js
index b6be350f..637d4e8e 100644
--- a/src/samples/flow/js/attendee.js
+++ b/src/samples/flow/js/attendee.js
@@ -22,10 +22,10 @@
  * This node has three in/out ports representing common line, preferential line
  * and attendee.
  *
- * Everytime we receive a number from 'IN_COMMON' or 'IN_PREFERENTIAL' we'll append
+ * Every time we receive a number from 'IN_COMMON' or 'IN_PREFERENTIAL' we'll append
  * to the respective vector (representing the line).
  *
- * Everytime we receive a boolean from 'IN_ATTENDEE' we'll return the next in line
+ * Every time we receive a boolean from 'IN_ATTENDEE' we'll return the next in line
  * (considering that preferential line has higher priority).
  */
 
diff --git a/src/samples/flow/js/mycounter.js b/src/samples/flow/js/mycounter.js
index d3d5ba01..16290172 100644
--- a/src/samples/flow/js/mycounter.js
+++ b/src/samples/flow/js/mycounter.js
@@ -19,7 +19,7 @@
 /*
  * This is our custom JS node type in order to be used in the mycounter.fbp sample.
  *
- * Everytime we receive a boolean from 'IN' we'll add or subtract from this value
+ * Every time we receive a boolean from 'IN' we'll add or subtract from this value
  * depending on boolean value, TRUE will add 1 and FALSE will subtract 1, after we'll
  * send this value to 'OUT' port.
  */
diff --git a/src/samples/flow/unix-socket/README b/src/samples/flow/unix-socket/README
index d46a6ed1..243ba4e5 100644
--- a/src/samples/flow/unix-socket/README
+++ b/src/samples/flow/unix-socket/README
@@ -8,7 +8,7 @@ it (if a writer). Servers should always be started before clients, as
 they will create the socket to accept connections.  By default writer
 nodes are server, unless defined as a node option.
 
-As both processes are local, no endianess conversion is done and the
+As both processes are local, no endianness conversion is done and the
 packets are considered to be of exact sizes, otherwise the peer may
 close the connection if it could not read or write the required
 amount.
diff --git a/src/test-fbp/converter-int-direction-vector.fbp b/src/test-fbp/converter-int-direction-vector.fbp
index af48feac..494077ce 100644
--- a/src/test-fbp/converter-int-direction-vector.fbp
+++ b/src/test-fbp/converter-int-direction-vector.fbp
@@ -23,14 +23,14 @@ XInt OUT -> X int_to_direction_vector
 YInt OUT -> Y int_to_direction_vector
 ZInt OUT -> Z int_to_direction_vector
 
-fourty(constant/int:value=40)
+forty(constant/int:value=40)
 eighty(constant/int:value=80)
 one_hundred_and_fourty(constant/int:value=140)
 
 int_to_direction_vector OUT -> IN direction_vector_to_int(converter/direction-vector-to-int)
 
 direction_vector_to_int X -> IN[0] eq_fourty(int/equal)
-fourty OUT -> IN[1] eq_fourty OUT -> RESULT x(test/result)
+forty OUT -> IN[1] eq_fourty OUT -> RESULT x(test/result)
 
 direction_vector_to_int Y -> IN[0] eq_eighty(int/equal)
 eighty OUT -> IN[1] eq_eighty OUT -> RESULT y(test/result)
diff --git a/src/test/test-str-slice.c b/src/test/test-str-slice.c
index e4968844..024b77b8 100644
--- a/src/test/test-str-slice.c
+++ b/src/test/test-str-slice.c
@@ -264,7 +264,7 @@ test_str_slice_to_string(void)
             "whose only purpose is to test if a long slice can yeld to a"
             "correct string. But why not? Maybe allocation problems, however, "
             "are allocations problems something to be concerned at? If we "
-            "have no more memory available, a slice that can't be coverted "
+            "have no more memory available, a slice that can't be converted "
             "to raw C string, the infamous array of char, is not application "
             "main concern. I think that it's long enought, but maybe not. "
             "In hindsight, I believed that I've should used some lorem ipsum "