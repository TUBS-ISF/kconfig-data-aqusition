"2016-05-03 17:52:25 -0300"
diff --git a/src/lib/flow/Kconfig b/src/lib/flow/Kconfig
index 48e1bd47..11c5f764 100644
--- a/src/lib/flow/Kconfig
+++ b/src/lib/flow/Kconfig
@@ -15,6 +15,18 @@ config RESOLVER_CONFFILE
 	bool "Resolver conffile"
 	depends on NODE_DESCRIPTION && FEATURE_FILESYSTEM
 	default y
+	help
+            For the sol-fbp-runner tool, have the ability to parse
+            configuration files declaring node types. This is a way to
+            parametrize flows for different platforms/situations and
+            still keep a single flow logic. If you know you won't be
+            using this feature on the runner tool and want to save
+            some space, say N.
+
+            NB.: The sol-fbp-generator tool will always be able to
+            resolve from configuration files.
+
+            If unsure, say Y.
 
 config INSPECTOR
 	bool "Inspector"
diff --git a/src/lib/flow/sol-flow-resolver.c b/src/lib/flow/sol-flow-resolver.c
index 6e4bd0ec..6762bdc7 100644
--- a/src/lib/flow/sol-flow-resolver.c
+++ b/src/lib/flow/sol-flow-resolver.c
@@ -18,6 +18,7 @@
 
 #include <stddef.h>
 
+#include "sol-conffile.h"
 #include "sol-flow-resolver.h"
 #include "sol-flow-internal.h"
 #include "sol-flow-buildopts.h"
@@ -82,9 +83,10 @@ sol_flow_resolve(
     const struct sol_flow_node_type **type,
     struct sol_flow_node_named_options *named_opts)
 {
+    int err;
+    const char *type_name;
     const struct sol_flow_node_type *tmp_type;
     struct sol_flow_node_named_options tmp_named_opts = {};
-    int err;
 
     SOL_NULL_CHECK(id, -EINVAL);
     SOL_NULL_CHECK(type, -EINVAL);
@@ -105,9 +107,20 @@ sol_flow_resolve(
 
     err = resolver->resolve(resolver->data, id, &tmp_type, &tmp_named_opts);
     if (err < 0) {
-        SOL_DBG("could not resolve module for id='%s' using resolver=%s",
-            id, resolver->name);
-        return -ENOENT;
+        type_name = sol_conffile_resolve_alias(sol_str_slice_from_str(id));
+        if (!type_name) {
+            SOL_DBG("Could not resolve module nor alias for id='%s'"
+                " using resolver=%s", id, resolver->name);
+            return -ENOENT;
+        }
+        err = resolver->resolve(resolver->data, type_name, &tmp_type,
+            &tmp_named_opts);
+        if (err < 0) {
+            SOL_DBG("Could not resolve module for id='%s' (type='%s')"
+                " using resolver=%s: %s", id, type_name, resolver->name,
+                sol_util_strerrora(-err));
+            return -ENOENT;
+        }
     } else
         SOL_DBG("module for id='%s' resolved using resolver=%s",
             id, resolver->name);
diff --git a/src/shared/sol-conffile.c b/src/shared/sol-conffile.c
index e4e688c3..1102d8cd 100644
--- a/src/shared/sol-conffile.c
+++ b/src/shared/sol-conffile.c
@@ -37,9 +37,21 @@
 #include "sol-memmap-storage.h"
 #endif
 
+/**
+ * Internal routines for parsing flow conf files (node type
+ * declarations) and node aliases
+ */
+
+struct sol_alias_ctx {
+    char *type_name;
+    struct sol_vector aliases;
+    unsigned long precedence;
+};
+
 static struct sol_ptr_vector _conffile_entry_vector; /* entries created by conffiles */
 static struct sol_ptr_vector _conffiles_loaded; /* paths of the currently loaded conffiles */
 static struct sol_arena *str_arena;
+static struct sol_vector node_aliases_map = SOL_VECTOR_INIT(struct sol_alias_ctx);
 
 #ifdef USE_MEMMAP
 static struct sol_ptr_vector _memory_maps;
@@ -697,6 +709,18 @@ exit:
     return config_file_contents;
 }
 
+static void
+clear_aliases(void)
+{
+    uint16_t i;
+    struct sol_alias_ctx *ctx;
+
+    SOL_VECTOR_FOREACH_IDX (&node_aliases_map, ctx, i)
+        sol_vector_clear(&ctx->aliases);
+
+    sol_vector_clear(&node_aliases_map);
+}
+
 static void
 _clear_data(void)
 {
@@ -718,6 +742,8 @@ _clear_data(void)
 
     sol_arena_del(str_arena);
 
+    clear_aliases();
+
 #ifdef USE_MEMMAP
     _clear_memory_maps();
 #endif
@@ -916,10 +942,186 @@ _load_vector_defaults(void)
     free(name_str);
 }
 
+static enum sol_util_iterate_dir_reason
+iterate_dir_cb(void *data, const char *dir_path, struct dirent *en)
+{
+    struct sol_vector aliases = SOL_VECTOR_INIT(struct sol_str_slice);
+    char path[PATH_MAX], *sep, *endptr = NULL;
+    struct sol_buffer *file_contents = data;
+    enum sol_json_loop_reason end_reason;
+    struct sol_json_scanner scanner;
+    unsigned long precedence = 0;
+    struct sol_json_token value;
+    struct sol_str_slice *slice;
+    uint16_t i;
+    int r;
+
+    SOL_BUFFER_DECLARE_STATIC(node_name, 128);
+
+    if (!strendswith(en->d_name, ".json"))
+        return SOL_UTIL_ITERATE_DIR_CONTINUE;
+
+    sep = strchr(en->d_name, '-');
+
+    if (sep) {
+        precedence = sol_util_strtoul
+                (en->d_name, &endptr, sep - en->d_name, 10);
+        if (endptr == en->d_name || errno != 0)
+            SOL_INF("Could not parse the precedence for file '%s' - "
+                "Using 0 as precedence", en->d_name);
+    } else
+        SOL_INF("Could not find the separator '-' in the file name '%s'."
+            " Using 0 as precedence ", en->d_name);
+
+    r = snprintf(path, sizeof(path), "%s/%s", dir_path, en->d_name);
+    SOL_INT_CHECK(r, < 0, -EINVAL);
+    SOL_INT_CHECK(r, >= (int)sizeof(path), -ENOMEM);
+
+    SOL_DBG("Reading alias file '%s' with precedence equals to %lu",
+        path, precedence);
+
+    r = sol_util_load_file_buffer(path, file_contents);
+    SOL_INT_CHECK(r, < 0, r);
+
+    sol_json_scanner_init(&scanner, file_contents->data, file_contents->used);
+
+    SOL_JSON_SCANNER_ARRAY_LOOP (&scanner, &value, SOL_JSON_TYPE_OBJECT_START,
+        end_reason) {
+        struct sol_alias_ctx *alias_ctx;
+        struct sol_json_token obj_key, obj_value;
+
+        SOL_JSON_SCANNER_OBJECT_LOOP_NEST (&scanner, &value, &obj_key,
+            &obj_value, end_reason) {
+            struct sol_json_scanner array_scanner;
+            struct sol_json_token array_token;
+
+            if (SOL_JSON_TOKEN_STR_LITERAL_EQ(&obj_key, "aliases")) {
+                sol_json_scanner_init_from_token(&array_scanner, &obj_value);
+
+                SOL_JSON_SCANNER_ARRAY_LOOP (&array_scanner, &array_token,
+                    SOL_JSON_TYPE_STRING, end_reason) {
+                    struct sol_buffer buf;
+
+                    r = sol_json_token_get_unescaped_string(&array_token, &buf);
+                    SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+
+                    slice = sol_vector_append(&aliases);
+                    if (!slice) {
+                        r = -ENOMEM;
+                        sol_buffer_fini(&buf);
+                        goto err_exit;
+                    }
+
+                    r = sol_arena_slice_dup(str_arena, slice,
+                        sol_buffer_get_slice(&buf));
+                    sol_buffer_fini(&buf);
+                    SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+                }
+
+                if (end_reason != SOL_JSON_LOOP_REASON_OK) {
+                    SOL_WRN("Error: Invalid Json.");
+                    r = -EINVAL;
+                    goto err_exit;
+                }
+            } else if (SOL_JSON_TOKEN_STR_LITERAL_EQ(&obj_key, "name")) {
+                r = sol_json_token_get_unescaped_string(&obj_value, &node_name);
+                SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+            }
+        }
+
+        if (end_reason != SOL_JSON_LOOP_REASON_OK) {
+            SOL_WRN("Error: Invalid Json.");
+            r = -EINVAL;
+            goto err_exit;
+        }
+
+        r = -EINVAL;
+        SOL_INT_CHECK_GOTO(node_name.used, == 0, err_exit);
+
+        alias_ctx = sol_vector_append(&node_aliases_map);
+        SOL_NULL_CHECK_GOTO(alias_ctx, err_exit);
+
+        alias_ctx->type_name = sol_arena_strdup_slice(str_arena,
+            sol_buffer_get_slice(&node_name));
+        SOL_NULL_CHECK_GOTO(alias_ctx->type_name, err_exit);
+
+        alias_ctx->precedence = precedence;
+        memcpy(&alias_ctx->aliases, &aliases, sizeof(struct sol_vector));
+
+        aliases.data = NULL;
+        aliases.len = 0;
+        node_name.used = 0;
+    }
+
+    if (end_reason != SOL_JSON_LOOP_REASON_OK) {
+        SOL_WRN("Invalid JSON file: %s", path);
+        return -EINVAL;
+    }
+
+    file_contents->used = 0;
+    return SOL_UTIL_ITERATE_DIR_CONTINUE;
+
+err_exit:
+    SOL_VECTOR_FOREACH_IDX (&aliases, slice, i)
+        free(slice);
+    sol_vector_clear(&aliases);
+    return r;
+}
+
+
+static int
+alias_compare(const void *v1, const void *v2)
+{
+    const struct sol_alias_ctx *ctx1, *ctx2;
+
+    ctx1 = v1;
+    ctx2 = v2;
+
+    if (ctx1->precedence == ctx2->precedence)
+        return 0;
+    //desc order
+    if (ctx1->precedence > ctx2->precedence)
+        return -1;
+    return 1;
+}
+
+
+static int
+load_aliases(void)
+{
+    struct sol_buffer file_contents = SOL_BUFFER_INIT_EMPTY;
+    char path[PATH_MAX], install_rootdir[PATH_MAX] = {};
+    int r;
+
+    r = sol_util_get_rootdir(install_rootdir, sizeof(install_rootdir));
+    SOL_INT_CHECK(r, >= (int)sizeof(install_rootdir), false);
+
+    r = snprintf(path, sizeof(path), "%s%s", install_rootdir, FLOWALIASESDIR);
+    SOL_INT_CHECK(r, >= (int)sizeof(path), -EINVAL);
+    SOL_INT_CHECK(r, < 0, -EINVAL);
+
+    SOL_DBG("Looking for aliases at: %s", path);
+    r = sol_util_iterate_dir(path, iterate_dir_cb, &file_contents);
+    sol_buffer_fini(&file_contents);
+    if (r == -ENOENT)
+        return 0;
+    SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+
+    qsort(node_aliases_map.data, node_aliases_map.len,
+        node_aliases_map.elem_size, alias_compare);
+
+    return 0;
+
+err_exit:
+    clear_aliases();
+    return r;
+}
+
 static int
 _init(void)
 {
-    static int first_call = true;
+    static bool first_call = true;
+    int r;
 
     if (first_call) {
         str_arena = sol_arena_new();
@@ -933,11 +1135,19 @@ _init(void)
 #ifdef USE_MEMMAP
         sol_ptr_vector_init(&_memory_maps);
 #endif
+        r = load_aliases();
+        SOL_INT_CHECK_GOTO(r, < 0, err_aliases);
+
         atexit(_clear_data);
+        first_call = false;
     }
-    first_call = false;
 
     return 0;
+
+err_aliases:
+    sol_arena_del(str_arena);
+    str_arena = NULL;
+    return r;
 }
 
 static int
@@ -949,7 +1159,7 @@ _bsearch_entry_cb(const void *data1, const void *data2)
 }
 
 static int
-_resolve_config(const char *id, const char **type, const char ***opts)
+_resolve_config_do(const char *id, const char **type, const char ***opts)
 {
     struct sol_conffile_entry key;
     struct sol_conffile_entry *entry;
@@ -989,6 +1199,58 @@ _resolve_config(const char *id, const char **type, const char ***opts)
     return 0;
 }
 
+const char *
+sol_conffile_resolve_alias(const struct sol_str_slice alias)
+{
+    int r;
+    uint16_t i;
+    struct sol_alias_ctx *ctx;
+
+    r = _init();
+    SOL_INT_CHECK(r, < 0, NULL);
+
+    SOL_VECTOR_FOREACH_IDX (&node_aliases_map, ctx, i) {
+        struct sol_str_slice *aux_alias;
+        uint16_t j;
+
+        SOL_VECTOR_FOREACH_IDX (&ctx->aliases, aux_alias, j) {
+            if (sol_str_slice_eq(*aux_alias, alias))
+                return ctx->type_name;
+        }
+    }
+
+    return NULL;
+}
+
+static int
+_resolve_config(const char *id, const char **type, const char ***opts)
+{
+    int r;
+    const char *real_type;
+
+    r = _resolve_config_do(id, type, opts);
+    if (r == 0) {
+        /* the resolved type may be an alias, try to resolve it */
+        real_type = sol_conffile_resolve_alias(sol_str_slice_from_str(*type));
+        if (real_type)
+            *type = real_type;
+        return r;
+    }
+
+    /* no entry in conf files, try resolving the ID to an alias
+     * directly, then */
+    real_type = sol_conffile_resolve_alias(sol_str_slice_from_str(id));
+    if (!real_type)
+        return -ENOENT;
+
+    *type = real_type;
+    r = _resolve_config_do(id, type, opts);
+    if (r != -ENOENT)
+        return r;
+
+    return 0;
+}
+
 int
 sol_conffile_resolve(const char *id, const char **type, const char ***opts)
 {
diff --git a/src/shared/sol-conffile.h b/src/shared/sol-conffile.h
index e5f87e59..3b877987 100644
--- a/src/shared/sol-conffile.h
+++ b/src/shared/sol-conffile.h
@@ -19,6 +19,7 @@
 #pragma once
 
 #include "sol-vector.h"
+#include "sol-str-slice.h"
 
 /* This conffile resolve is used on resolver-conffile and sol-fbp-generator */
 
@@ -29,3 +30,5 @@ int sol_conffile_resolve_path(const char *id, const char **type, const char ***o
 int sol_conffile_resolve_memmap(struct sol_ptr_vector **memmaps);
 
 int sol_conffile_resolve_memmap_path(struct sol_ptr_vector **memmaps, const char *path);
+
+const char *sol_conffile_resolve_alias(const struct sol_str_slice alias);
diff --git a/src/shared/sol-util-internal.h b/src/shared/sol-util-internal.h
index a2da47b3..8358bf69 100644
--- a/src/shared/sol-util-internal.h
+++ b/src/shared/sol-util-internal.h
@@ -59,6 +59,7 @@
 #define streq(a, b) (strcmp((a), (b)) == 0)
 #define streqn(a, b, n) (strncmp((a), (b), (n)) == 0)
 #define strstartswith(a, b) streqn((a), (b), strlen(b))
+#define strendswith(a, b) (strlen(b) < strlen(a) && streq(a + strlen(a) - strlen(b), b))
 
 #define STATIC_ASSERT_LITERAL(_s) ("" _s)
 
diff --git a/tools/build/Makefile.vars b/tools/build/Makefile.vars
index 1f687ba5..a00b1e31 100644
--- a/tools/build/Makefile.vars
+++ b/tools/build/Makefile.vars
@@ -107,6 +107,7 @@ export PINMUXDIR := $(MODULESDIR)/pin-mux/
 export LINUXMICROMODULESDIR := $(MODULESDIR)/linux-micro/
 export FLOWMETATYPEMODULESDIR := $(MODULESDIR)/flow-metatype/
 export UPDATEMODULESDIR := $(MODULESDIR)/update/
+export FLOWALIASESDIR := $(SOL_FLOW_DATADIR)/aliases/
 
 # _RELATIVE variants replaces $(PREFIX) with `${prefix}', $(LIBDIR) with `${libdir}' and so on, to be used in shell scripts and ".pc" files
 export LIBDIR_RELATIVE := $(subst $(patsubst %/,%,$(PREFIX)),$${prefix},$(LIBDIR))
@@ -307,7 +308,8 @@ COMMON_CFLAGS += \
 	-DPINMUXDIR="\"$(PINMUXDIR)\"" \
 	-DLINUXMICROMODULESDIR="\"$(LINUXMICROMODULESDIR)\"" \
 	-DFLOWMETATYPEMODULESDIR="\"$(FLOWMETATYPEMODULESDIR)\"" \
-	-DUPDATEMODULESDIR="\"$(UPDATEMODULESDIR)\""
+	-DUPDATEMODULESDIR="\"$(UPDATEMODULESDIR)\"" \
+	-DFLOWALIASESDIR="\"$(FLOWALIASESDIR)\""
 
 COMMON_CFLAGS += -include $(abspath $(MISSING_H))
 COMMON_CFLAGS += $(addprefix -I,$(HEADERDIRS))