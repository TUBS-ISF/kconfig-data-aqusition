"2016-06-07 14:12:02 -0300"
diff --git a/src/bin/sol-fbp-generator/main.c b/src/bin/sol-fbp-generator/main.c
index d223ece9..3f947945 100644
--- a/src/bin/sol-fbp-generator/main.c
+++ b/src/bin/sol-fbp-generator/main.c
@@ -1679,7 +1679,8 @@ generate(struct sol_vector *fbp_data_vector)
     if (memmap_elems) {
         out("\n");
         for (i = 0; i < memmap_elems; i++)
-            out("    sol_memmap_add_map(&_memmap%d);\n", i);
+            out("    if (sol_memmap_add_map(&_memmap%d) < 0)\n"
+                "        return false;\n", i);
     }
     out(
         "    return true;\n"
diff --git a/src/lib/datatypes/include/sol-str-table.h b/src/lib/datatypes/include/sol-str-table.h
index 4c077afc..a43d1adf 100644
--- a/src/lib/datatypes/include/sol-str-table.h
+++ b/src/lib/datatypes/include/sol-str-table.h
@@ -72,17 +72,36 @@ struct sol_str_table {
 #define SOL_STR_TABLE_ITEM(_key, _val) \
     { .key = SOL_STR_STATIC_ASSERT_LITERAL(_key), .len = sizeof(_key) - 1, .val = _val }
 
+/**
+ * @brief Retrieves the table entry associated with a given key from
+ * the string/integer table.
+ *
+ * Searches @a table for @c key string and returns its table entry
+ * pointer. If @c key isn't found (or a bad @a table argument is
+ * passed), @c NULL is returned and @c errno is set (either to @c
+ * EINVAL or to @c ENOENT).
+ *
+ * @param table String/integer table
+ * @param key Key to search
+ *
+ * @return If @c key is found, it returns its table entry, otherwise
+ *         @c NULL is returned and errno is set to @c ENOENT if the
+ *         item was not found or to @c EINVAL if parameters were
+ *         invalid.
+ */
+const struct sol_str_table *sol_str_table_entry_lookup(const struct sol_str_table *table, const struct sol_str_slice key);
+
 /**
  * @brief Retrieves the value associated with a given key from the string table.
  *
- * Searches the string table for @c key and return its value, if @c key isn't found,
- * the value of @c fallback is returned.
+ * Searches the string table for @c key and returns its value. If @c
+ * key isn't found, @c fallback is returned.
  *
  * @param table String table
  * @param key Key to search
  * @param fallback Fallback value
  *
- * @return If @c key is found, return it's value, otherwise @c
+ * @return If @c key is found, return its value, otherwise @c
  *         fallback is returned and errno is set to @c ENOENT if item
  *         is not found of @c EINVAL if parameters were invalid.
  */
@@ -164,15 +183,15 @@ struct sol_str_table_ptr {
 /**
  * @brief Retrieves the value associated with a given key from the string/pointer table.
  *
- * Searches the table table for @c key string and return its pointer, if @c key isn't found,
- * the pointer @c fallback is returned.
+ * Searches @a table for @c key string and returns its pointer. If @c
+ * key isn't found, @c fallback is returned.
  *
  * @param table_ptr String/pointer table
  * @param key Key to search
  * @param fallback Fallback pointer
  *
- * @return If @c key is found, return it's value, otherwise @c
- *         fallback is returned is returned and errno is set to @c
+ * @return If @c key is found, return its value, otherwise @c
+ *         fallback is returned and errno is set to @c
  *         ENOENT if item is not found of @c EINVAL if parameters were
  *         invalid.
  */
@@ -180,6 +199,25 @@ const void *sol_str_table_ptr_lookup_fallback(const struct sol_str_table_ptr *ta
     const struct sol_str_slice key,
     const void *fallback) SOL_ATTR_NON_NULL(1);
 
+/**
+ * @brief Retrieves the table entry associated with a given key from
+ * the string/pointer table.
+ *
+ * Searches @a table for @c key string and returns its table entry
+ * pointer. If @c key isn't found (or a bad @a table argument is
+ * passed), @c NULL is returned and @c errno is set (either to @c
+ * EINVAL or to @c ENOENT).
+ *
+ * @param table String/pointer table
+ * @param key Key to search
+ *
+ * @return If @c key is found, it returns its table entry, otherwise
+ *         @c NULL is returned and errno is set to @c ENOENT if the
+ *         item was not found or to @c EINVAL if parameters were
+ *         invalid.
+ */
+const struct sol_str_table_ptr *sol_str_table_ptr_entry_lookup(const struct sol_str_table_ptr *table, const struct sol_str_slice key);
+
 /**
  * @def sol_str_table_ptr_lookup(_table_ptr, _key, _pval)
  *
@@ -249,17 +287,36 @@ struct sol_str_table_int64 {
       .len = sizeof(_key) - 1, \
       .val = _val }
 
+/**
+ * @brief Retrieves the table entry associated with a given key from
+ * the string/pointer table.
+ *
+ * Searches @a table for @c key string and returns its table entry
+ * pointer. If @c key isn't found (or a bad @a table argument is
+ * passed), @c NULL is returned and @c errno is set (either to @c
+ * EINVAL or to @c ENOENT).
+ *
+ * @param table String/pointer table
+ * @param key Key to search
+ *
+ * @return If @c key is found, it returns its table entry, otherwise
+ *         @c NULL is returned and errno is set to @c ENOENT if the
+ *         item was not found or to @c EINVAL if parameters were
+ *         invalid.
+ */
+const struct sol_str_table_int64 *sol_str_table_int64_entry_lookup(const struct sol_str_table_int64 *table, const struct sol_str_slice key);
+
 /**
  * @brief Retrieves the value associated with a given key from the string/int64_t table.
  *
- * Searches the table table for @c key string and return its int64_t, if @c key isn't found,
- * the int64_t @c fallback is returned.
+ * Searches @a table for @c key string and returns its int64_t value.
+ * If @c key isn't found, @c fallback is returned.
  *
  * @param table_int64 String/int64_t table
  * @param key Key to search
  * @param fallback Fallback int64_t
  *
- * @return If @c key is found, return it's value, otherwise @c
+ * @return If @c key is found, return its value, otherwise @c
  *         fallback is returned and errno is set to @c ENOENT if item
  *         is not found of @c EINVAL if parameters were invalid.
  */
diff --git a/src/lib/datatypes/sol-str-table.c b/src/lib/datatypes/sol-str-table.c
index f516852d..709eacb5 100644
--- a/src/lib/datatypes/sol-str-table.c
+++ b/src/lib/datatypes/sol-str-table.c
@@ -23,33 +23,65 @@
 #include "sol-str-table.h"
 #include "sol-util-internal.h"
 
+SOL_API const struct sol_str_table *
+sol_str_table_entry_lookup(const struct sol_str_table *table,
+    const struct sol_str_slice key)
+{
+    const struct sol_str_table *iter;
+
+    errno = EINVAL;
+    SOL_NULL_CHECK(table, NULL);
+
+    for (iter = table; iter->key; iter++) {
+        if (iter->len == key.len && memcmp(iter->key, key.data, key.len) == 0) {
+            errno = 0;
+            return iter;
+        }
+    }
+
+    errno = ENOENT;
+    return NULL;
+}
+
 SOL_API int16_t
 sol_str_table_lookup_fallback(const struct sol_str_table *table,
     const struct sol_str_slice key,
     int16_t fallback)
 {
-    const struct sol_str_table *iter;
-    uint16_t len;
-
-    errno = EINVAL;
-    SOL_NULL_CHECK(table, fallback);
+    const struct sol_str_table *entry;
 
     if (SOL_UNLIKELY(key.len > INT16_MAX)) {
         errno = EINVAL;
         return fallback;
     }
 
-    len = (uint16_t)key.len;
+    entry = sol_str_table_entry_lookup(table, key);
+    if (!entry) return fallback;
+
+    errno = EINVAL;
+    SOL_NULL_CHECK(table, fallback);
+
+    return entry->val;
+}
+
+SOL_API const struct sol_str_table_ptr *
+sol_str_table_ptr_entry_lookup(const struct sol_str_table_ptr *table,
+    const struct sol_str_slice key)
+{
+    const struct sol_str_table_ptr *iter;
+
+    errno = EINVAL;
+    SOL_NULL_CHECK(table, NULL);
 
     for (iter = table; iter->key; iter++) {
-        if (iter->len == len && memcmp(iter->key, key.data, len) == 0) {
+        if (iter->len == key.len && memcmp(iter->key, key.data, key.len) == 0) {
             errno = 0;
-            return iter->val;
+            return iter;
         }
     }
 
     errno = ENOENT;
-    return fallback;
+    return NULL;
 }
 
 SOL_API const void *
@@ -57,20 +89,32 @@ sol_str_table_ptr_lookup_fallback(const struct sol_str_table_ptr *table,
     const struct sol_str_slice key,
     const void *fallback)
 {
-    const struct sol_str_table_ptr *iter;
+    const struct sol_str_table_ptr *entry;
+
+    entry = sol_str_table_ptr_entry_lookup(table, key);
+    if (!entry) return fallback;
+
+    return entry->val;
+}
+
+SOL_API const struct sol_str_table_int64 *
+sol_str_table_int64_entry_lookup(const struct sol_str_table_int64 *table,
+    const struct sol_str_slice key)
+{
+    const struct sol_str_table_int64 *iter;
 
     errno = EINVAL;
-    SOL_NULL_CHECK(table, fallback);
+    SOL_NULL_CHECK(table, NULL);
 
     for (iter = table; iter->key; iter++) {
         if (iter->len == key.len && memcmp(iter->key, key.data, key.len) == 0) {
             errno = 0;
-            return iter->val;
+            return iter;
         }
     }
 
     errno = ENOENT;
-    return fallback;
+    return NULL;
 }
 
 SOL_API int64_t
@@ -78,18 +122,10 @@ sol_str_table_int64_lookup_fallback(const struct sol_str_table_int64 *table,
     const struct sol_str_slice key,
     int64_t fallback)
 {
-    const struct sol_str_table_int64 *iter;
+    const struct sol_str_table_int64 *entry;
 
-    errno = EINVAL;
-    SOL_NULL_CHECK(table, fallback);
+    entry = sol_str_table_int64_entry_lookup(table, key);
+    if (!entry) return fallback;
 
-    for (iter = table; iter->key; iter++) {
-        if (iter->len == key.len && memcmp(iter->key, key.data, key.len) == 0) {
-            errno = 0;
-            return iter->val;
-        }
-    }
-
-    errno = ENOENT;
-    return fallback;
+    return entry->val;
 }
diff --git a/src/lib/io/Kconfig b/src/lib/io/Kconfig
index 0594a903..d44d426a 100644
--- a/src/lib/io/Kconfig
+++ b/src/lib/io/Kconfig
@@ -64,28 +64,28 @@ endif
 
 menuconfig USE_STORAGE
     bool "Persistence Storage Support"
-    depends on LINUX
+    depends on FEATURE_FILESYSTEM || FEATURE_EFI || FEATURE_FLASH_MEM
     default y
 
 config USE_FILESYSTEM
     bool "File system persistence storage"
-    depends on USE_STORAGE
+    depends on USE_STORAGE && FEATURE_FILESYSTEM
     default y
 
 config USE_EFIVARS
     bool "EFI vars persistence storage"
-    depends on USE_STORAGE
+    depends on USE_STORAGE && FEATURE_EFI
     default y
 
 config USE_MEMMAP
     bool "Memory map persistence storage"
-    depends on USE_STORAGE
+    depends on USE_STORAGE && (FEATURE_FILESYSTEM || FEATURE_FLASH_MEM)
     default y
     help
-        Provide persistence storage based on memory maps.
-        Users must provide a mapping - for instance, using a JSON
-        file - that will be used to define where on memory
-        entries will be saved. Examples of memory are NVRAM or EEPROM.
+        Provide persistence storage based on memory maps. Users must
+        provide a mapping - for instance, using a JSON file - that
+        will be used to define where on memory entries will be saved.
+        Examples of memory are NVRAM or EEPROM or even a file.
 
 config USE_IPM
     bool "Inter-processor messaging"
diff --git a/src/lib/io/Makefile b/src/lib/io/Makefile
index 36a320a2..ec29fc6f 100644
--- a/src/lib/io/Makefile
+++ b/src/lib/io/Makefile
@@ -94,6 +94,8 @@ obj-io-storage-$(USE_EFIVARS) += \
     sol-efivarfs-storage.o
 obj-io-storage-$(USE_MEMMAP) += \
     sol-memmap-storage.o
+obj-io-storage-$(LINUX) += \
+    sol-memmap-storage-impl-linux.o
 
 obj-io-ipm-$(USE_IPM) += \
     sol-ipm.o
diff --git a/src/lib/io/include/sol-memmap-storage.h b/src/lib/io/include/sol-memmap-storage.h
index b5c03aa9..d1777881 100644
--- a/src/lib/io/include/sol-memmap-storage.h
+++ b/src/lib/io/include/sol-memmap-storage.h
@@ -22,7 +22,6 @@
 #include <stdint.h>
 
 #include "sol-buffer.h"
-#include "sol-log.h"
 #include "sol-str-table.h"
 #include "sol-types.h"
 
@@ -88,13 +87,22 @@ extern "C" {
 
 struct sol_memmap_map {
     uint8_t version; /**< Version of map. Functions will refuse to read/write on storage if this version and the one storad differs */
-    const char *path; /**< Where to find the storage. Under Linux, it is the file mapping the storage, like @c /dev/nvram.
-                       * Optionally, it can also be of form <tt> create,\<bus_type\>,\<rel_path\>,\<devnumber\>,\<devname\> </tt>, where:
-                       * @arg @a bus_type is the bus type, supported values are: i2c
-                       * @arg @a rel_path is the relative path for device on '/sys/devices',
-                       * like 'platform/80860F41:05'
-                       * @arg @a devnumber is device number on bus, like 0x50
-                       * @arg @a devname is device name, the one recognized by its driver
+    const char *path; /**< Where to find the storage. On Linux, it is
+                       * the file mapping the storage, like @c
+                       * /dev/nvram. Optionally, it can also be in the
+                       * form
+                       * <tt>create,\<bus_type\>,\<rel_path\>,\<devnumber\>,\<devname\></tt>,
+                       * where: @arg @a bus_type is the bus type
+                       * (supported values are: @c i2c), @arg @a
+                       * rel_path is the relative path for the device
+                       * on @c /sys/devices, like @c
+                       * platform/80860F41:05, @arg @a devnumber is
+                       * the device number on the bus, like @c 0x50,
+                       * and @arg @a devname is the device name, the
+                       * one recognized by its driver. On small OSes
+                       * this field might be ignored, since the
+                       * storage will depend on the port (and SoC it
+                       * targets).
                        */
     uint32_t timeout; /**< Timeout, in milliseconds, of writing operations. After a write is requested, a timer will run and group all
                        * writing operations until it expires, when real writing will be performed */
diff --git a/src/lib/io/sol-efivarfs-storage.c b/src/lib/io/sol-efivarfs-storage.c
index c679339f..3571f06f 100644
--- a/src/lib/io/sol-efivarfs-storage.c
+++ b/src/lib/io/sol-efivarfs-storage.c
@@ -214,11 +214,7 @@ sol_efivars_read_raw(const char *name, struct sol_buffer *buffer)
         goto end;
     }
 
-    if (buffer->capacity) {
-        r = sol_util_fill_buffer_exactly(fd, buffer, buffer->capacity);
-    } else {
-        r = sol_util_load_file_fd_buffer(fd, buffer);
-    }
+    r = sol_util_load_file_fd_buffer(fd, buffer);
 
 end:
     close(fd);
diff --git a/src/lib/io/sol-fs-storage.c b/src/lib/io/sol-fs-storage.c
index c53360bc..7eb3589c 100644
--- a/src/lib/io/sol-fs-storage.c
+++ b/src/lib/io/sol-fs-storage.c
@@ -172,11 +172,7 @@ sol_fs_read_raw(const char *name, struct sol_buffer *buffer)
         return -errno;
     }
 
-    if (buffer->capacity) {
-        r = sol_util_fill_buffer_exactly(fd, buffer, buffer->capacity);
-    } else {
-        r = sol_util_load_file_fd_buffer(fd, buffer);
-    }
+    r = sol_util_load_file_fd_buffer(fd, buffer);
 
     close(fd);
 
diff --git a/src/lib/io/sol-memmap-storage-impl-linux.c b/src/lib/io/sol-memmap-storage-impl-linux.c
new file mode 100644
index 00000000..d4d87a50
--- /dev/null
+++ b/src/lib/io/sol-memmap-storage-impl-linux.c
@@ -0,0 +1,401 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "sol-memmap-storage-impl.h"
+
+#include "sol-buffer.h"
+#include "sol-mainloop.h"
+#include "sol-str-slice.h"
+#include "sol-str-table.h"
+#include "sol-util-file.h"
+#include "sol-util-internal.h"
+#include "sol-vector.h"
+
+#ifdef USE_I2C
+#include <sol-i2c.h>
+#endif
+
+struct map_internal_linux {
+    struct map_internal base;
+    char *resolved_path;
+    FILE *file;
+};
+
+int
+sol_memmap_impl_read_raw(struct map_internal *map,
+    const struct sol_memmap_entry *entry,
+    uint64_t mask,
+    struct sol_buffer *buffer)
+{
+    struct map_internal_linux *map_internal = (struct map_internal_linux *)map;
+    uint64_t value = 0;
+    int fd = 0, ret = 0;
+
+    /* entry->size may be bigger than the overall useful data on bit
+     * mask cases, but we have to read the whole area anyway */
+    ret = sol_buffer_ensure(buffer, entry->size);
+    SOL_INT_CHECK_GOTO(ret, < 0, error);
+
+    ret = 0;
+    fd = open(map_internal->resolved_path, O_RDWR | O_CLOEXEC);
+    if (fd < 0) {
+        SOL_WRN("Could not open memory file [%s]: %s",
+            map_internal->resolved_path, sol_util_strerrora(errno));
+        goto error;
+    }
+
+    if (lseek(fd, entry->offset, SEEK_SET) < 0)
+        goto error;
+
+    if ((ret = sol_util_fill_buffer_exactly(fd, buffer, entry->size)) < 0)
+        goto error;
+
+    if (mask)
+        fill_buffer_using_mask(value, mask, entry, buffer);
+
+    if (close(fd) < 0) {
+        fd = ret = 0;
+        goto error;
+    }
+
+    return 0;
+
+error:
+    sol_buffer_fini(buffer);
+    SOL_WRN("Flash read failed");
+    if (!ret)
+        ret = -errno;
+    if (fd > 0)
+        close(fd);
+
+    return ret;
+}
+
+int
+sol_memmap_impl_write_raw(struct map_internal *map,
+    const char *name,
+    const struct sol_memmap_entry *entry,
+    uint64_t mask,
+    struct sol_blob *blob,
+    void (*cb)(void *data, const char *name, struct sol_blob *blob, int status),
+    const void *data)
+{
+    struct map_internal_linux *map_internal = (struct map_internal_linux *)map;
+    FILE *file = NULL;
+    int ret = 0;
+
+    if (!sol_blob_ref(blob))
+        return -ENOMEM;
+
+    if (map_internal->file) {
+        file = map_internal->file;
+    } else {
+        file = fopen(map_internal->resolved_path, "r+e");
+        if (!file) {
+            SOL_WRN("Could not open memory file [%s]: %s",
+                map_internal->resolved_path, sol_util_strerrora(errno));
+            goto error;
+        }
+    }
+
+    if (fseek(file, entry->offset, SEEK_SET) < 0)
+        goto error;
+
+    if (mask) {
+        uint64_t value = 0, old_value;
+        uint32_t i, j;
+
+        /* entry->size > 8 implies that no mask should be used */
+        assert(entry->size <= 8);
+
+        for (i = 0, j = 0; i < entry->size; i++, j += 8)
+            value |= (uint64_t)((uint8_t *)blob->mem)[i] << j;
+
+        ret = fread(&old_value, entry->size, 1, file);
+        if (!ret || ferror(file) || feof(file)) {
+            errno = EIO;
+            goto error;
+        }
+
+        /* We just read from file, let's rewind */
+        if (fseek(file, entry->offset, SEEK_SET) < 0)
+            goto error;
+
+        value <<= entry->bit_offset;
+        value &= mask;
+        value |= (old_value & ~mask);
+        fwrite(&value, entry->size, 1, file);
+    } else {
+        fwrite(blob->mem, sol_util_min(entry->size, blob->size), 1, file);
+    }
+
+    if (ferror(file)) {
+        errno = EIO;
+        goto error;
+    }
+
+    errno = 0;
+    if (!map_internal->file)
+        fclose(file);
+
+    if (cb)
+        cb((void *)data, name, blob, -errno);
+
+    sol_blob_unref(blob);
+
+    return -errno;
+
+error:
+    SOL_DBG("Error writing to file [%s]: %s", map_internal->resolved_path,
+        sol_util_strerrora(errno));
+    ret = -errno;
+    if (file && !map_internal->file)
+        fclose(file);
+
+    if (cb)
+        cb((void *)data, name, blob, ret);
+
+    sol_blob_unref(blob);
+
+    return ret;
+}
+
+bool
+sol_memmap_impl_perform_pending_writes(void *data)
+{
+    struct map_internal_linux *map_internal = data;
+    struct pending_write_data *pending;
+    struct sol_vector tmp_vector;
+    int i, r;
+
+    //sol-memmap-storage.c only checks the pointer to know what to do
+    //on the next round
+    map_internal->base.timeout = NULL;
+
+    map_internal->file = fopen(map_internal->resolved_path, "r+e");
+    if (!map_internal->file) {
+        SOL_WRN("Error opening file [%s]: %s",
+            map_internal->resolved_path, sol_util_strerrora(errno));
+        return false;
+    }
+
+    tmp_vector = map_internal->base.pending_writes;
+    sol_vector_init(&map_internal->base.pending_writes,
+        sizeof(struct pending_write_data));
+
+    SOL_VECTOR_FOREACH_IDX (&tmp_vector, pending, i) {
+        sol_memmap_impl_write_raw((struct map_internal *)map_internal,
+            pending->name, pending->entry, pending->mask, pending->blob,
+            pending->cb, pending->data);
+        sol_blob_unref(pending->blob);
+    }
+    sol_vector_clear(&tmp_vector);
+
+    r = fclose(map_internal->file);
+    if (r == EOF)
+        SOL_WRN("Error closing file [%s]: %s",
+            map_internal->resolved_path, sol_util_strerrora(errno));
+
+    map_internal->file = NULL;
+    SOL_DBG("Performed pending writes on [%s]",
+        map_internal->resolved_path);
+
+    return false;
+}
+
+#ifdef USE_I2C
+static int
+resolve_i2c_path(const char *path, char **resolved_path)
+{
+    char *rel_path = NULL, *dev_number_s = NULL, *dev_name = NULL, *end_ptr;
+    struct sol_buffer result_path = SOL_BUFFER_INIT_EMPTY;
+    unsigned int dev_number;
+    int ret = -EINVAL, n;
+
+    ret = sscanf(path, " %m[^,]%n", &rel_path, &n);
+    SOL_INT_CHECK_GOTO(ret, < 0, err_parse);
+    path += n + 1;
+
+    ret = sscanf(path, " %m[^,]%n", &dev_number_s, &n);
+    SOL_INT_CHECK_GOTO(ret, < 0, err_parse);
+    path += n + 1;
+
+    errno = 0;
+    dev_number = strtoul(dev_number_s, &end_ptr, 0);
+    if (errno) {
+        ret = -errno;
+        goto err_parse;
+    }
+    if (*end_ptr != '\0') {
+        for (const char *p = end_ptr; *p; p++) {
+            if (!isspace((uint8_t)*p))
+                goto err_parse;
+        }
+    }
+
+    ret = sscanf(path, "%ms", &dev_name);
+    SOL_INT_CHECK_GOTO(ret, < 0, err_parse);
+
+    ret = sol_i2c_create_device(rel_path, dev_name, dev_number,
+        &result_path);
+
+    if (ret >= 0 || ret == -EEXIST) {
+        const struct sol_str_slice ending = SOL_STR_SLICE_LITERAL("/eeprom");
+
+        ret = sol_buffer_append_slice(&result_path, ending);
+        if (ret < 0)
+            goto err_parse;
+
+        *resolved_path = sol_buffer_steal(&result_path, NULL);
+
+        ret = 0;
+        /* Let's wait up to one second for it to be created */
+        if (!sol_util_busy_wait_file(*resolved_path, SOL_UTIL_NSEC_PER_SEC)) {
+            ret = -ENODEV;
+            free(*resolved_path);
+            goto err_parse;
+        }
+    }
+
+    free(rel_path);
+    free(dev_number_s);
+    free(dev_name);
+    return ret;
+
+err_parse:
+    free(rel_path);
+    free(dev_number_s);
+    free(dev_name);
+    SOL_WRN("Invalid create device path. Expected 'create,i2c,<rel_path>,"
+        "<devnumber>,<devname>'");
+    return ret;
+
+}
+#endif
+
+static int
+check_i2c_path(const char *path)
+{
+    static const char CREATE[] = "create";
+    static const char I2C[] = "i2c";
+
+    const char *create = strstr(path, CREATE);
+    const char *i2c = strstr(path, I2C);
+    bool comma = false;
+    const char *p;
+    int ret = 0;
+
+    if (!create || !i2c)
+        return -EINVAL;
+
+    for (p = i2c - 1; p >= create + sizeof(CREATE) - 1; p--) {
+        if (*p == ',') {
+            if (comma)
+                return -EINVAL;
+            comma = true;
+        } else if (!isspace((uint8_t)*p))
+            return -EINVAL;
+    }
+    if (!comma)
+        return -EINVAL;
+
+    p = strchr(i2c, ',');
+    if (!p)
+        return -EINVAL;
+
+    ret = p - path + 1;
+
+    for (p--; p >= i2c + sizeof(I2C) - 1; p--) {
+        if (!isspace((uint8_t)*p))
+            return -EINVAL;
+    }
+
+    return ret;
+}
+
+static char *
+resolve_map_path(const struct sol_memmap_map *map)
+{
+    int r;
+
+#ifdef USE_I2C
+    char *resolved_path = NULL;
+
+    r = check_i2c_path(map->path);
+    if (r > 0) {
+        r = resolve_i2c_path(map->path + r, &resolved_path);
+        if (r < 0) {
+            SOL_WRN("Could not create i2c EEPROM device using command [%s]",
+                map->path);
+            errno = -r;
+            goto error;
+        }
+
+        return resolved_path;
+    }
+
+    return strdup(map->path);
+
+error:
+    return NULL;
+#else
+    return strdup(map->path);
+#endif
+}
+
+int
+sol_memmap_impl_init(void)
+{
+    return 0;
+}
+
+struct map_internal *
+sol_memmap_impl_map_new(const struct sol_memmap_map *map)
+{
+    struct map_internal_linux *map_internal;
+
+    SOL_NULL_CHECK_ERRNO(map, EINVAL, NULL);
+
+    map_internal = calloc(1, sizeof(*map_internal));
+    SOL_NULL_CHECK_ERRNO(map, ENOMEM, NULL);
+
+    map_internal->base.map = map;
+    map_internal->resolved_path = resolve_map_path(map_internal->base.map);
+    if (!map_internal->resolved_path) {
+        free(map_internal);
+        return NULL;
+    }
+
+    return (struct map_internal *)map_internal;
+}
+
+void
+sol_memmap_impl_map_del(struct map_internal *map)
+{
+    struct map_internal_linux *map_internal = (struct map_internal_linux *)map;
+
+    SOL_NULL_CHECK(map_internal);
+    free(map_internal->resolved_path);
+    free(map_internal);
+}
diff --git a/src/lib/io/sol-memmap-storage-impl.h b/src/lib/io/sol-memmap-storage-impl.h
new file mode 100644
index 00000000..5f0780d1
--- /dev/null
+++ b/src/lib/io/sol-memmap-storage-impl.h
@@ -0,0 +1,53 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <stdbool.h>
+
+#define SOL_LOG_DOMAIN &_sol_memmap_storage_log_domain
+extern struct sol_log_domain _sol_memmap_storage_log_domain;
+#include "sol-log-internal.h"
+#include "sol-memmap-storage.h"
+
+struct pending_write_data {
+    const char *name;
+    struct sol_blob *blob;
+    const struct sol_memmap_entry *entry;
+    void (*cb)(void *data, const char *name, struct sol_blob *blob, int status);
+    const void *data;
+    uint64_t mask;
+};
+
+struct map_internal {
+    const struct sol_memmap_map *map;
+    struct sol_timeout *timeout;
+    struct sol_vector pending_writes;
+    bool checked;
+};
+
+int sol_memmap_impl_read_raw(struct map_internal *map_internal, const struct sol_memmap_entry *entry, uint64_t mask, struct sol_buffer *buffer);
+
+int sol_memmap_impl_write_raw(struct map_internal *map_internal, const char *name, const struct sol_memmap_entry *entry, uint64_t mask, struct sol_blob *blob, void (*cb)(void *data, const char *name, struct sol_blob *blob, int status), const void *data);
+
+bool sol_memmap_impl_perform_pending_writes(void *data);
+int sol_memmap_impl_init(void);
+struct map_internal *sol_memmap_impl_map_new(const struct sol_memmap_map *map);
+void sol_memmap_impl_map_del(struct map_internal *map_internal);
+
+void fill_buffer_using_mask(uint32_t value, uint64_t mask, const struct sol_memmap_entry *entry, struct sol_buffer *buffer);
diff --git a/src/lib/io/sol-memmap-storage.c b/src/lib/io/sol-memmap-storage.c
index 7d45149a..c36fdf81 100644
--- a/src/lib/io/sol-memmap-storage.c
+++ b/src/lib/io/sol-memmap-storage.c
@@ -16,58 +16,37 @@
  * limitations under the License.
  */
 
-#include "sol-memmap-storage.h"
+#include "sol-util-internal.h"
+
+#include "sol-memmap-storage-impl.h"
 
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <sys/stat.h>
-#include <unistd.h>
+struct sol_log_domain _sol_memmap_storage_log_domain;
 
 #include "sol-buffer.h"
-#include "sol-log.h"
 #include "sol-mainloop.h"
-#include "sol-str-slice.h"
-#include "sol-str-table.h"
-#include "sol-util-file.h"
 #include "sol-vector.h"
-#include "sol-util-internal.h"
-
-#ifdef USE_I2C
-#include <sol-i2c.h>
-#endif
-
-#define REL_PATH_IDX 2
-#define DEV_NUMBER_IDX 3
-#define DEV_NAME_IDX 4
-
-struct pending_write_data {
-    char *name;
-    struct sol_blob *blob;
-    const struct sol_memmap_entry *entry;
-    void (*cb)(void *data, const char *name, struct sol_blob *blob, int status);
-    const void *data;
-    uint64_t mask;
-};
-
-struct map_internal {
-    const struct sol_memmap_map *map;
-    struct sol_timeout *timeout;
-    char *resolved_path;
-    struct sol_vector pending_writes;
-    bool checked;
-};
 
-static struct sol_vector memory_maps = SOL_VECTOR_INIT(struct map_internal);
+static struct sol_ptr_vector memory_maps = SOL_PTR_VECTOR_INIT;
+static bool initialised = false;
 
 static bool
-get_entry_metadata_on_map(const char *name, const struct sol_memmap_map *map, const struct sol_memmap_entry **entry, uint64_t *mask)
+get_entry_metadata_on_map(const char *name,
+    const char **out_name,
+    const struct sol_memmap_map *map,
+    const struct sol_memmap_entry **entry,
+    uint64_t *mask)
 {
     uint32_t bit_size;
+    const struct sol_str_table_ptr *table_entry = sol_str_table_ptr_entry_lookup
+            (map->entries, sol_str_slice_from_str(name));
 
-    if (sol_str_table_ptr_lookup(map->entries, sol_str_slice_from_str(name), entry)) {
+    if (table_entry) {
+        *entry = table_entry->val;
+        if (out_name)
+            *out_name = table_entry->key;
         bit_size = (*entry)->bit_size;
-        /* No mask if bit_size equal or greater than 64. Such data should not be read as an int */
+        /* No mask if bit_size equal or greater than 64. Such data
+         * should not be read as an int */
         if (bit_size && (bit_size != (*entry)->size * 8) && bit_size < 64)
             *mask = (((uint64_t)1 << bit_size) - 1) << (*entry)->bit_offset;
         else
@@ -80,149 +59,28 @@ get_entry_metadata_on_map(const char *name, const struct sol_memmap_map *map, co
 }
 
 static bool
-get_entry_metadata(const char *name, struct map_internal **map_internal, const struct sol_memmap_entry **entry, uint64_t *mask)
+get_entry_metadata(const char *name,
+    const char **out_name,
+    struct map_internal **map_internal,
+    const struct sol_memmap_entry **entry,
+    uint64_t *mask)
 {
     int i;
 
-    SOL_VECTOR_FOREACH_IDX (&memory_maps, *map_internal, i) {
-        if (get_entry_metadata_on_map(name, (*map_internal)->map, entry, mask))
+    SOL_PTR_VECTOR_FOREACH_IDX (&memory_maps, *map_internal, i) {
+        if (get_entry_metadata_on_map(name, out_name, (*map_internal)->map,
+            entry, mask))
             return true;
     }
 
     *entry = NULL;
     *map_internal = NULL;
+    if (out_name)
+        *out_name = NULL;
 
     return false;
 }
 
-static int
-sol_memmap_read_raw_do(const char *path, const struct sol_memmap_entry *entry, uint64_t mask, struct sol_buffer *buffer)
-{
-    int fd, ret = 0;
-    uint64_t value = 0;
-    uint32_t i, j;
-
-    fd = open(path, O_RDWR | O_CLOEXEC);
-    if (fd < 0) {
-        SOL_WRN("Could not open memory file [%s]: %s", path,
-            sol_util_strerrora(errno));
-        return -errno;
-    }
-
-    if (lseek(fd, entry->offset, SEEK_SET) < 0)
-        goto error;
-
-    if ((ret = sol_util_fill_buffer_exactly(fd, buffer, entry->size)) < 0)
-        goto error;
-
-    if (mask) {
-        for (i = 0, j = 0; i < entry->size; i++, j += 8)
-            value |= (uint64_t)((uint8_t *)buffer->data)[i] << j;
-
-        value &= mask;
-        value >>= entry->bit_offset;
-
-        memset(buffer->data, 0, buffer->capacity);
-        for (i = 0; i < entry->size; i++, value >>= 8)
-            ((uint8_t *)buffer->data)[i] = value & 0xff;
-    }
-
-    if (close(fd) < 0)
-        return -errno;
-
-    return 0;
-
-error:
-    if (!ret)
-        ret = -errno;
-    close(fd);
-
-    return ret;
-}
-
-static int
-sol_memmap_write_raw_do(const char *path, const char *name, const struct sol_memmap_entry *entry, uint64_t mask, struct sol_blob *blob,
-    void (*cb)(void *data, const char *name, struct sol_blob *blob, int status),
-    const void *data, FILE *reuse_file)
-{
-    FILE *file = NULL;
-    int ret = 0;
-
-    if (!sol_blob_ref(blob))
-        return -ENOMEM;
-
-    if (reuse_file) {
-        file = reuse_file;
-    } else {
-        file = fopen(path, "r+e");
-        if (!file) {
-            SOL_WRN("Could not open memory file [%s]: %s", path,
-                sol_util_strerrora(errno));
-            goto error;
-        }
-    }
-
-    if (fseek(file, entry->offset, SEEK_SET) < 0)
-        goto error;
-
-    if (mask) {
-        uint64_t value = 0, old_value;
-        uint32_t i, j;
-
-        /* entry->size > 8 implies that no mask should be used */
-        assert(entry->size <= 8);
-
-        for (i = 0, j = 0; i < entry->size; i++, j += 8)
-            value |= (uint64_t)((uint8_t *)blob->mem)[i] << j;
-
-        ret = fread(&old_value, entry->size, 1, file);
-        if (!ret || ferror(file) || feof(file)) {
-            errno = EIO;
-            goto error;
-        }
-
-        /* We just read from file, let's rewind */
-        if (fseek(file, entry->offset, SEEK_SET) < 0)
-            goto error;
-
-        value <<= entry->bit_offset;
-        value &= mask;
-        value |= (old_value & ~mask);
-        fwrite(&value, entry->size, 1, file);
-    } else {
-        fwrite(blob->mem, sol_util_min(entry->size, blob->size), 1, file);
-    }
-
-    if (ferror(file)) {
-        errno = EIO;
-        goto error;
-    }
-
-    errno = 0;
-    if (!reuse_file)
-        fclose(file);
-
-    if (cb)
-        cb((void *)data, name, blob, -errno);
-
-    sol_blob_unref(blob);
-
-    return -errno;
-
-error:
-    SOL_DBG("Error writing to file [%s]: %s", path, sol_util_strerrora(errno));
-    ret = -errno;
-    if (file && !reuse_file)
-        fclose(file);
-
-    if (cb)
-        cb((void *)data, name, blob, ret);
-
-    sol_blob_unref(blob);
-
-    return ret;
-}
-
 static void
 version_write_cb(void *data, const char *name, struct sol_blob *blob, int status)
 {
@@ -251,31 +109,33 @@ check_version(struct map_internal *map_internal)
         return false;
     }
 
-    if (!get_entry_metadata_on_map(MEMMAP_VERSION_ENTRY, map_internal->map, &entry,
+    if (!get_entry_metadata_on_map
+            (MEMMAP_VERSION_ENTRY, NULL, map_internal->map, &entry,
         &mask)) {
 
         SOL_WRN("No entry on memory map to property [%s]", MEMMAP_VERSION_ENTRY);
         return false;
     }
 
-    ret = sol_memmap_read_raw_do(map_internal->resolved_path, entry, mask, &buf);
-    if (ret >= 0 && (version == 0 || version == UINT8_MAX)) {
-        blob = sol_blob_new(&SOL_BLOB_TYPE_NO_FREE_DATA, NULL, &map_internal->map->version, sizeof(uint8_t));
+    ret = sol_memmap_impl_read_raw(map_internal, entry, mask, &buf);
+    if (ret >= 0 && (version == 0 || version == 255)) {
+        blob = sol_blob_new(&SOL_BLOB_TYPE_NO_FREE_DATA, NULL, &map_internal->map->version, sizeof(uint16_t));
         SOL_NULL_CHECK(blob, false);
 
         /* No version on file, we should be initialising it */
         version = map_internal->map->version;
-        if ((ret = sol_memmap_write_raw_do(map_internal->resolved_path, MEMMAP_VERSION_ENTRY, entry, mask, blob, version_write_cb, NULL, NULL)) < 0) {
-            SOL_WRN("Could not write current map version to file [%s]: %s",
-                map_internal->resolved_path,
-                sol_util_strerrora(-ret));
+        if ((ret = sol_memmap_impl_write_raw(map_internal,
+                MEMMAP_VERSION_ENTRY, entry, mask, blob, version_write_cb,
+                NULL)) < 0) {
+            SOL_WRN("Could not write current map version (path is %s): %s",
+                map_internal->map->path, sol_util_strerrora(-ret));
             sol_blob_unref(blob);
             return false;
         }
+        sol_blob_unref(blob);
     } else if (ret < 0) {
-        SOL_WRN("Could not read current map version from file [%s]: %s",
-            map_internal->resolved_path,
-            sol_util_strerrora(-ret));
+        SOL_WRN("Could not read current map version (path is %s): %s",
+            map_internal->map->path, sol_util_strerrora(-ret));
         return false;
     }
 
@@ -289,45 +149,6 @@ check_version(struct map_internal *map_internal)
     return true;
 }
 
-static bool
-perform_pending_writes(void *data)
-{
-    int i, r;
-    struct pending_write_data *pending;
-    FILE *file = NULL;
-    struct map_internal *map_internal = data;
-    struct sol_vector tmp_vector;
-
-    map_internal->timeout = NULL;
-
-    file = fopen(map_internal->resolved_path, "r+e");
-    if (!file) {
-        SOL_WRN("Error opening file [%s]: %s", map_internal->resolved_path,
-            sol_util_strerrora(errno));
-        return false;
-    }
-
-    tmp_vector = map_internal->pending_writes;
-    sol_vector_init(&map_internal->pending_writes, sizeof(struct pending_write_data));
-
-    SOL_VECTOR_FOREACH_IDX (&tmp_vector, pending, i) {
-        sol_memmap_write_raw_do(map_internal->map->path, pending->name, pending->entry,
-            pending->mask, pending->blob, pending->cb, pending->data, file);
-        free(pending->name);
-        sol_blob_unref(pending->blob);
-    }
-    sol_vector_clear(&tmp_vector);
-
-    r = fclose(file);
-    if (r)
-        SOL_WRN("Error closing file [%s]: %s", map_internal->resolved_path,
-            sol_util_strerrora(errno));
-
-    SOL_DBG("Performed pending writes on [%s]", map_internal->resolved_path);
-
-    return false;
-}
-
 static bool
 replace_pending_write(struct sol_vector *pending_writes, const char *name,
     const struct sol_memmap_entry *entry, uint64_t mask, struct sol_blob *blob,
@@ -347,7 +168,6 @@ replace_pending_write(struct sol_vector *pending_writes, const char *name,
             if (!pending->blob) {
                 /* If we couldn't ref, let's delete this entry and let
                  * the caller re-add this write */
-                free(pending->name);
                 sol_vector_del(pending_writes, i);
                 return false;
             }
@@ -370,9 +190,7 @@ fill_pending_write(struct pending_write_data *pending, const char *name,
     pending->blob = sol_blob_ref(blob);
     SOL_NULL_CHECK(pending->blob, -ENOMEM);
 
-    pending->name = strdup(name);
-    SOL_NULL_CHECK(name, -ENOMEM);
-
+    pending->name = name;
     pending->entry = entry;
     pending->mask = mask;
     pending->cb = cb;
@@ -402,7 +220,7 @@ add_write(struct map_internal *map_internal, const char *name,
 
     if (!map_internal->timeout)
         map_internal->timeout = sol_timeout_add(map_internal->map->timeout,
-            perform_pending_writes, map_internal);
+            sol_memmap_impl_perform_pending_writes, map_internal);
 
     SOL_NULL_CHECK(map_internal->timeout, -ENOMEM);
 
@@ -414,14 +232,15 @@ sol_memmap_write_raw(const char *name, struct sol_blob *blob,
     void (*cb)(void *data, const char *name, struct sol_blob *blob, int status),
     const void *data)
 {
-    struct map_internal *map_internal;
     const struct sol_memmap_entry *entry;
+    struct map_internal *map_internal;
+    const char *entry_name;
     uint64_t mask;
 
     SOL_NULL_CHECK(name, -EINVAL);
     SOL_NULL_CHECK(blob, -EINVAL);
 
-    if (!get_entry_metadata(name, &map_internal, &entry, &mask)) {
+    if (!get_entry_metadata(name, &entry_name, &map_internal, &entry, &mask)) {
         SOL_WRN("No entry on memory map to property [%s]", name);
         return -ENOENT;
     }
@@ -433,7 +252,7 @@ sol_memmap_write_raw(const char *name, struct sol_blob *blob,
         SOL_INF("Mapped size for [%s] is %zd, smaller than buffer contents: %zd",
             name, entry->size, blob->size);
 
-    return add_write(map_internal, name, entry, mask, blob, cb, data);
+    return add_write(map_internal, entry_name, entry, mask, blob, cb, data);
 }
 
 static bool
@@ -443,7 +262,7 @@ read_from_pending(const char *name, struct sol_buffer *buffer)
     struct map_internal *map_internal;
     int i, j;
 
-    SOL_VECTOR_FOREACH_IDX (&memory_maps, map_internal, i) {
+    SOL_PTR_VECTOR_FOREACH_IDX (&memory_maps, map_internal, i) {
         if (!map_internal->pending_writes.len)
             continue;
 
@@ -474,7 +293,7 @@ sol_memmap_read_raw(const char *name, struct sol_buffer *buffer)
     SOL_NULL_CHECK(name, -EINVAL);
     SOL_NULL_CHECK(buffer, -EINVAL);
 
-    if (!get_entry_metadata(name, &map_internal, &entry, &mask)) {
+    if (!get_entry_metadata(name, NULL, &map_internal, &entry, &mask)) {
         SOL_WRN("No entry on memory map to property [%s]", name);
         return -ENOENT;
     }
@@ -485,7 +304,7 @@ sol_memmap_read_raw(const char *name, struct sol_buffer *buffer)
     if (read_from_pending(name, buffer))
         return 0;
 
-    return sol_memmap_read_raw_do(map_internal->resolved_path, entry, mask, buffer);
+    return sol_memmap_impl_read_raw(map_internal, entry, mask, buffer);
 }
 
 static bool
@@ -516,12 +335,12 @@ check_entry(const struct sol_memmap_map *map,
     return true;
 }
 
-static bool
+static int
 check_map(const struct sol_memmap_map *map)
 {
     const struct sol_str_table_ptr *iter;
-    const char *failed_entry;
     struct sol_memmap_entry *entry;
+    const char *failed_entry;
     uint32_t last_offset = 0;
 
     SOL_DBG("Checking memory map whose path is [%s]", map->path);
@@ -530,9 +349,9 @@ check_map(const struct sol_memmap_map *map)
     for (iter = map->entries; iter->key; iter++) {
         entry = (void *)iter->val;
         if (entry->bit_offset > 7) {
-            SOL_WRN("Entry [%s] bit_offset greater than 7, found: %d",
+            SOL_WRN("Entry [%s] with bit_offset greater than 7 found: %d",
                 iter->key, entry->bit_offset);
-            return false;
+            return -EINVAL;
         }
         if (!entry->offset)
             entry->offset = last_offset;
@@ -547,129 +366,45 @@ check_map(const struct sol_memmap_map *map)
         if (!check_entry(map, iter->val, &failed_entry)) {
             SOL_WRN("Entry [%s] overlaps entry [%s] on map", iter->key,
                 failed_entry);
-            return false;
-        }
-    }
-
-    return true;
-}
-
-#ifdef USE_I2C
-static int
-resolve_i2c_path(const char *path, char **resolved_path)
-{
-    char *rel_path = NULL, *dev_number_s = NULL, *dev_name = NULL, *end_ptr;
-    unsigned int dev_number;
-    struct sol_vector instructions;
-    struct sol_buffer result_path = SOL_BUFFER_INIT_EMPTY;
-    struct sol_str_slice command = sol_str_slice_from_str(path);
-    int ret = -EINVAL;
-
-    instructions = sol_str_slice_split(command, ",", 5);
-    if (instructions.len < 5) {
-        SOL_WRN("Invalid create device path. Expected 'create,i2c,<rel_path>,"
-            "<devnumber>,<devname>'");
-        goto end;
-    }
-
-    rel_path = sol_str_slice_to_str(
-        *(const struct sol_str_slice *)sol_vector_get(&instructions, REL_PATH_IDX));
-    SOL_NULL_CHECK_GOTO(rel_path, end);
-
-    dev_number_s = sol_str_slice_to_str(
-        *(const struct sol_str_slice *)sol_vector_get(&instructions, DEV_NUMBER_IDX));
-    SOL_NULL_CHECK_GOTO(dev_number_s, end);
-
-    errno = 0;
-    dev_number = strtoul(dev_number_s, &end_ptr, 0);
-    if (errno || *end_ptr != '\0')
-        goto end;
-
-    dev_name = sol_str_slice_to_str(
-        *(const struct sol_str_slice *)sol_vector_get(&instructions, DEV_NAME_IDX));
-    SOL_NULL_CHECK_GOTO(dev_name, end);
-
-    ret = sol_i2c_create_device(rel_path, dev_name, dev_number,
-        &result_path);
-
-    if (ret >= 0 || ret == -EEXIST) {
-        const struct sol_str_slice ending = SOL_STR_SLICE_LITERAL("/eeprom");
-
-        ret = sol_buffer_append_slice(&result_path, ending);
-        if (ret < 0)
-            goto end;
-
-        *resolved_path = sol_buffer_steal(&result_path, NULL);
-
-        ret = 0;
-        /* Let's wait up to one second */
-        if (!sol_util_busy_wait_file(*resolved_path, SOL_UTIL_NSEC_PER_SEC)) {
-            ret = -ENODEV;
-            free(*resolved_path);
-            goto end;
-        }
-    }
-
-end:
-    free(rel_path);
-    free(dev_number_s);
-    free(dev_name);
-    sol_vector_clear(&instructions);
-
-    return ret;
-}
-#endif
-
-static char *
-resolve_map_path(const struct sol_memmap_map *map)
-{
-#ifdef USE_I2C
-    char *resolved_path;
-
-    if (strstartswith(map->path, "create,i2c,")) {
-        if (resolve_i2c_path(map->path, &resolved_path) < 0) {
-            SOL_WRN("Could not create i2c EEPROM device using command [%s]", map->path);
-            goto error;
+            return -EINVAL;
         }
-
-        return resolved_path;
     }
 
-    return strdup(map->path);
-
-error:
-    return NULL;
-#else
-    return strdup(map->path);
-#endif
+    return 0;
 }
 
 SOL_API int
 sol_memmap_add_map(const struct sol_memmap_map *map)
 {
     struct map_internal *map_internal;
+    int r;
 
     SOL_NULL_CHECK(map, -EINVAL);
 
-    if (!check_map(map)) {
+    if (!initialised) {
+        r = sol_memmap_impl_init();
+        SOL_INT_CHECK(r, != 0, r);
+    }
+
+    r = check_map(map);
+    if (r < 0) {
         SOL_WRN("Invalid memory map. Map->path: [%s]", map->path);
-        return -EINVAL;
+        return r;
     }
 
-    map_internal = sol_vector_append(&memory_maps);
-    SOL_NULL_CHECK(map_internal, -ENOMEM);
+    map_internal = sol_memmap_impl_map_new(map);
+    SOL_NULL_CHECK(map_internal, -errno);
 
-    map_internal->map = map;
-    map_internal->resolved_path = resolve_map_path(map);
-    SOL_NULL_CHECK_GOTO(map_internal, error);
+    r = sol_ptr_vector_append(&memory_maps, map_internal);
+    SOL_INT_CHECK_GOTO(r, < 0, error);
 
     sol_vector_init(&map_internal->pending_writes, sizeof(struct pending_write_data));
 
     return 0;
 
 error:
-    sol_vector_del_last(&memory_maps);
-    return -ENOMEM;
+    sol_memmap_impl_map_del(map_internal);
+    return r;
 }
 
 SOL_API int
@@ -680,14 +415,14 @@ sol_memmap_remove_map(const struct sol_memmap_map *map)
 
     SOL_NULL_CHECK(map, -EINVAL);
 
-    SOL_VECTOR_FOREACH_IDX (&memory_maps, map_internal, i) {
+    SOL_PTR_VECTOR_FOREACH_IDX (&memory_maps, map_internal, i) {
         if (map_internal->map == map) {
             if (map_internal->timeout) {
                 sol_timeout_del(map_internal->timeout);
-                perform_pending_writes(map_internal);
+                sol_memmap_impl_perform_pending_writes(map_internal);
             }
-            free(map_internal->resolved_path);
-            return sol_vector_del(&memory_maps, i);
+            sol_memmap_impl_map_del(map_internal);
+            return sol_ptr_vector_del(&memory_maps, i);
         }
     }
 
@@ -704,7 +439,7 @@ sol_memmap_set_timeout(struct sol_memmap_map *map, uint32_t timeout)
 
     /* Rememeber, as we may have a copy of map (due to device resolving),
      * we need to update our proper copy */
-    SOL_VECTOR_FOREACH_IDX (&memory_maps, map_internal, i) {
+    SOL_PTR_VECTOR_FOREACH_IDX (&memory_maps, map_internal, i) {
         if (map_internal->map == map) {
             map->timeout = timeout;
             return true;
@@ -726,7 +461,7 @@ sol_memmap_get_timeout(const struct sol_memmap_map *map)
 
     /* Rememeber, as we may have a copy of map (due to device resolving),
      * we need to check our proper copy */
-    SOL_VECTOR_FOREACH_IDX (&memory_maps, map_internal, i) {
+    SOL_PTR_VECTOR_FOREACH_IDX (&memory_maps, map_internal, i) {
         if (map_internal->map == map) {
             return map->timeout;
         }
@@ -736,3 +471,22 @@ sol_memmap_get_timeout(const struct sol_memmap_map *map)
         map);
     return 0;
 }
+
+void
+fill_buffer_using_mask(uint32_t value,
+    uint64_t mask,
+    const struct sol_memmap_entry *entry,
+    struct sol_buffer *buffer)
+{
+    uint32_t i, j;
+
+    for (i = 0, j = 0; i < entry->size; i++, j += 8)
+        value |= (uint64_t)((uint8_t *)buffer->data)[i] << j;
+
+    value &= mask;
+    value >>= entry->bit_offset;
+
+    memset(buffer->data, 0, buffer->capacity);
+    for (i = 0; i < entry->size; i++, value >>= 8)
+        ((uint8_t *)buffer->data)[i] = value & 0xff;
+}
diff --git a/src/modules/flow/persistence/persistence.c b/src/modules/flow/persistence/persistence.c
index 7cc6a2e1..8edde7f4 100644
--- a/src/modules/flow/persistence/persistence.c
+++ b/src/modules/flow/persistence/persistence.c
@@ -297,10 +297,11 @@ persist_open(struct sol_flow_node *node,
     const char *storage,
     const char *name)
 {
-    struct persist_data *mdata = data;
+    struct sol_buffer buf = SOL_BUFFER_INIT_EMPTY;
+    const struct persistence_node_type *type;
     struct sol_str_slice storage_slice;
+    struct persist_data *mdata = data;
     int r;
-    const struct persistence_node_type *type;
 
     type = (const struct persistence_node_type *)
         sol_flow_node_get_type(node);
@@ -320,23 +321,31 @@ persist_open(struct sol_flow_node *node,
     SOL_NULL_CHECK(mdata->name, -ENOMEM);
 
     /* a zero packet_data_size means dynamic size content */
+    r = storage_read(mdata, &buf);
     if (mdata->packet_data_size) {
-        struct sol_buffer buf = SOL_BUFFER_INIT_FLAGS(mdata->value_ptr,
-            mdata->packet_data_size,
-            SOL_BUFFER_FLAGS_MEMORY_NOT_OWNED | SOL_BUFFER_FLAGS_NO_NUL_BYTE);
-
-        r = storage_read(mdata, &buf);
+        if (r >= 0) {
+            /* entry's total size may be bigger that actual
+             * packet_data_size (think bit fields). the useful data
+             * with be the leading bytes, on all cases */
+            r = sol_buffer_remove_data(&buf, mdata->packet_data_size,
+                buf.used - mdata->packet_data_size);
+            if (r >= 0)
+                mdata->value_ptr = sol_buffer_steal(&buf, NULL);
+        }
     } else {
-        struct sol_buffer buf = SOL_BUFFER_INIT_EMPTY;
-
-        r = storage_read(mdata, &buf);
-        if (r >= 0)
-            mdata->value_ptr = sol_buffer_steal(&buf, NULL);
-        else
-            sol_buffer_fini(&buf);
+        if (r >= 0) {
+            /* avoid reads of malformed strings */
+            if (!memchr(buf.data, '\0', buf.used))
+                r = -EINVAL;
+            else
+                mdata->value_ptr = sol_buffer_steal(&buf, NULL);
+        }
     }
-    if (r == -ENOENT) {
-        /* No file. Send default value */
+    sol_buffer_fini(&buf);
+
+    if (r < 0) {
+        SOL_WRN("Error reading previous storage (%s). Sending default value "
+            "on output port.", sol_util_strerrora(-r));
         r = persist_reset(mdata, node);
         SOL_INT_CHECK_GOTO(r, < 0, err);
         return r;
diff --git a/src/test/test-persistence-memmap.c b/src/test/test-persistence-memmap.c
index 4652beb6..488eb0e4 100644
--- a/src/test/test-persistence-memmap.c
+++ b/src/test/test-persistence-memmap.c
@@ -17,6 +17,7 @@
  */
 
 #include "sol-mainloop.h"
+#include "sol-log.h"
 #include "sol-memmap-storage.h"
 
 #include "test.h"
diff --git a/tools/build/Kconfig.contiki b/tools/build/Kconfig.contiki
index 56be37ee..c34eb294 100644
--- a/tools/build/Kconfig.contiki
+++ b/tools/build/Kconfig.contiki
@@ -1,10 +1,11 @@
 config CONTIKI
     def_bool y
-    select FEATURE_FLOW
-    select FEATURE_NETWORK
     select FEATURE_COAP
+    select FEATURE_FLOW
+    select FEATURE_HW_GPIO
     select FEATURE_HW_GPIO if HAVE_QMSI
-    select FEATURE_HW_PWM if HAVE_QMSI
     select FEATURE_HW_I2C if HAVE_QMSI
+    select FEATURE_HW_PWM if HAVE_QMSI
     select FEATURE_HW_SPI if HAVE_QMSI
+    select FEATURE_NETWORK
     select FEATURE_PIN_MUX if HAVE_QMSI
diff --git a/tools/build/Kconfig.features b/tools/build/Kconfig.features
index 81a6bb84..26e2f788 100644
--- a/tools/build/Kconfig.features
+++ b/tools/build/Kconfig.features
@@ -1,25 +1,28 @@
-config FEATURE_DYNAMIC_LINKER
+config FEATURE_BLUETOOTH
     bool
 
-config FEATURE_RUNNABLE_PROGRAMS
+config FEATURE_CC_SANITIZE
     bool
 
-config FEATURE_WORKER_THREADS
+config FEATURE_COAP
     bool
 
-config FEATURE_UNIX_SOCKETS
+config FEATURE_CRYPTO_MESSAGE_DIGEST
     bool
 
-config FEATURE_CRYPTO_MESSAGE_DIGEST
+config FEATURE_DYNAMIC_LINKER
     bool
 
-config FEATURE_NETWORK
+config FEATURE_EFI
     bool
 
-config FEATURE_COAP
+config FEATURE_FILESYSTEM
     bool
 
-config FEATURE_BLUETOOTH
+config FEATURE_FLASH_MEM
+    bool
+
+config FEATURE_FLOW
     bool
 
 config FEATURE_HTTP_CLIENT
@@ -31,34 +34,37 @@ config FEATURE_HTTP_SERVER
 config FEATURE_HW_AIO
     bool
 
-config FEATURE_HW_PWM
+config FEATURE_HW_GPIO
     bool
 
-config FEATURE_HW_GPIO
+config FEATURE_HW_I2C
     bool
 
-config FEATURE_HW_UART
+config FEATURE_HW_IPM
+    bool
+
+config FEATURE_HW_PWM
     bool
 
 config FEATURE_HW_SPI
     bool
 
-config FEATURE_HW_I2C
+config FEATURE_HW_UART
     bool
 
-config FEATURE_HW_IPM
+config FEATURE_NETWORK
     bool
 
-config FEATURE_FLOW
+config FEATURE_OIC
     bool
 
-config FEATURE_FILESYSTEM
+config FEATURE_RUNNABLE_PROGRAMS
     bool
 
-config FEATURE_CC_SANITIZE
+config FEATURE_UNIX_SOCKETS
     bool
 
-config FEATURE_OIC
+config FEATURE_WORKER_THREADS
     bool
 
 config FEATURE_PIN_MUX
diff --git a/tools/build/Kconfig.linux b/tools/build/Kconfig.linux
index 87a33e41..267a0935 100644
--- a/tools/build/Kconfig.linux
+++ b/tools/build/Kconfig.linux
@@ -1,23 +1,25 @@
 config LINUX
     def_bool y
+    select FEATURE_BLUETOOTH if HAVE_SYSTEMD
+    select FEATURE_CC_SANITIZE
+    select FEATURE_COAP
+    select FEATURE_CRYPTO_MESSAGE_DIGEST
     select FEATURE_DYNAMIC_LINKER
+    select FEATURE_EFI
+    select FEATURE_FILESYSTEM
+    select FEATURE_FLASH_MEM
+    select FEATURE_FLOW
+    select FEATURE_HTTP_CLIENT if HAVE_LIBCURL
+    select FEATURE_HTTP_SERVER if HAVE_LIBMICROHTTPD
     select FEATURE_HW_AIO
+    select FEATURE_HW_GPIO
+    select FEATURE_HW_I2C
     select FEATURE_HW_PWM
     select FEATURE_HW_SPI
-    select FEATURE_HW_GPIO
     select FEATURE_HW_UART
-    select FEATURE_HW_I2C
-    select FEATURE_RUNNABLE_PROGRAMS
-    select FEATURE_WORKER_THREADS
-    select FEATURE_UNIX_SOCKETS
-    select FEATURE_CRYPTO_MESSAGE_DIGEST
     select FEATURE_NETWORK
-    select FEATURE_COAP
-    select FEATURE_HTTP_CLIENT if HAVE_LIBCURL
-    select FEATURE_HTTP_SERVER if HAVE_LIBMICROHTTPD
-    select FEATURE_BLUETOOTH if HAVE_SYSTEMD
-    select FEATURE_FLOW
-    select FEATURE_FILESYSTEM
-    select FEATURE_CC_SANITIZE
     select FEATURE_OIC
     select FEATURE_PIN_MUX
+    select FEATURE_RUNNABLE_PROGRAMS
+    select FEATURE_UNIX_SOCKETS
+    select FEATURE_WORKER_THREADS
diff --git a/tools/build/Kconfig.riot b/tools/build/Kconfig.riot
index 5e660b2e..b563e8c7 100644
--- a/tools/build/Kconfig.riot
+++ b/tools/build/Kconfig.riot
@@ -1,14 +1,14 @@
 config RIOT
     def_bool y
+    select FEATURE_COAP
+    select FEATURE_CRYPTO_MESSAGE_DIGEST
+    select FEATURE_FLOW
     select FEATURE_HW_AIO
+    select FEATURE_HW_GPIO
+    select FEATURE_HW_I2C
     select FEATURE_HW_PWM
     select FEATURE_HW_SPI
-    select FEATURE_HW_GPIO
     select FEATURE_HW_UART
-    select FEATURE_HW_I2C
-    select FEATURE_WORKER_THREADS
     select FEATURE_NETWORK
-    select FEATURE_COAP
     select FEATURE_OIC
-    select FEATURE_FLOW
-    select FEATURE_CRYPTO_MESSAGE_DIGEST
+    select FEATURE_WORKER_THREADS