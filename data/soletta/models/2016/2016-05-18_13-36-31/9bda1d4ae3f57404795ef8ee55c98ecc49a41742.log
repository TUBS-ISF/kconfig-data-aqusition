"2016-05-18 13:36:31 -0300"
diff --git a/Kconfig b/Kconfig
index 971674db..aab7122d 100644
--- a/Kconfig
+++ b/Kconfig
@@ -226,6 +226,7 @@ source "src/samples/flow/http-oauth/Kconfig"
 source "src/samples/flow/am2315/Kconfig"
 source "src/samples/flow/js/Kconfig"
 source "src/samples/flow/mqtt/Kconfig"
+source "src/samples/design_patterns/Kconfig"
 
 endmenu
 
diff --git a/src/lib/common/include/sol-mainloop.h b/src/lib/common/include/sol-mainloop.h
index 4d0c6116..2f7812b9 100644
--- a/src/lib/common/include/sol-mainloop.h
+++ b/src/lib/common/include/sol-mainloop.h
@@ -64,12 +64,155 @@ extern "C" {
  * @li @ref Update
  * @li @ref Utils
  * @li @ref WorkerThread
+ * @li @ref patterns
  *
  * Also a lot of examples may be found at @ref examples page.
  *
  * Please see the @ref authors page for contact details.
  */
 
+/**
+ * @page patterns Design Patterns
+ * @tableofcontents
+ *
+ * This page will explain the common design patterns employed by Soletta.
+ *
+ * @section streams IO Streams
+ *
+ * Soletta has its own pattern for dealing with input/output streams. This
+ * section will describe how the soletta pattern is implemented and how to use it.
+ *
+ * The aim of this section is to guide the developer to provide a unified API for all kind of streams, making
+ * it easier for a third party developer to migrate its application to any stream related IO, if necessary.
+ *
+ * The pattern is divided in three categories: The stream configuration, the write API and the read API.
+ *
+ * @subsection config Configuration
+ *
+ * The stream should be configured using a struct during its creation, this struct should provide the following fields.
+ *
+ * <ul>
+ * <li> @c feed_size: The write buffer size - If @c 0 means that there is no limit (Data for this buffer is not necessary allocated).
+ * <li> @c data_buffer_size: The read buffer size. This buffer is always allocated and the @c on_data may be called with at most @c data_buffer_size bytes - If @c 0 means that there is not limit.
+ * <li> @c on_feed_done: The write callback - It will be called when data was fully written.
+ *    <ul>
+ *    <li> Respecting the interface:
+ *    @code{.c}
+ *    void (*on_feed_done)(void *user_data, my_stream_api_handle *handle, struct sol_blob *blob, int status);
+ *    @endcode
+ *    </ul>
+ * <li> @c on_data: The read callback - It will be called when there's data available to read.
+ *    <ul>
+ *    <li> Respecting the interface:
+ *    @code{.c}
+ *    ssize_t (*on_data)(void *user_data, my_stream_api_handle *handle, const struct sol_buffer *buf);
+ *    @endcode
+ *    </ul>
+ * <li> @c user_data: Data to @c on_data and @c on_feed_done.
+ * </ul>
+ *
+ * Below there's a example of a configuration struct.
+ * @snippet design_patterns/stream_sample.c stream config
+ *
+ * @subsection write Writing
+ *
+ * Write operations must be async and the data that will be transfered must be
+ * provided as a pointer to @ref sol_blob. One should follow the API below:
+ * @snippet design_patterns/stream_sample.c stream write api
+ *
+ * Every blob requested to be written, must be queued in order to be sent. If there's no more space
+ * to queue more blobs (sum of all queued blobs >= @c feed_size) the function write should return @c -ENOSPC.
+ *
+ * Everytime a blob is fully written the @c on_feed_done must be called in order to inform the user that
+ * the write operation was completed. The @c on_feed_done should have the following signature:
+ *
+ * @code{.c}
+ * void (*on_feed_done)(void *user_data, my_stream_api_handle *handle, struct sol_blob *blob, int status);
+ * @endcode
+ *
+ * One should warn the user that it's not necessary to use @ref sol_blob_unref(), because the stream
+ * API will already do that. The @c status variable should be 0 on success and @c -errno on error.
+ * The user should be able to cancel the stream operation from the @c on_feed_done.
+ *
+ * Below there's an example of a stream device write implementation.
+ *
+ * @snippet design_patterns/stream_sample.c stream handle
+ * @snippet design_patterns/stream_sample.c stream write
+ *
+ * @subsection read Reading
+ *
+ * Since this is a stream, there's no direct way for a third party developer to request a read operation.
+ * In order to be able to read from the stream, the third party developer must provide the @c on_data duration the
+ * stream configuration/creation. The @c on_data is provided during the stream creation, one must inform the user every time
+ * data is avaible to read.
+ * The @c on_data has the following signature:
+ *
+ * @code{.c}
+ * ssize_t (*on_data)(void *user_data, my_stream_api_handle *handle, const struct sol_buffer *buf);
+ * @endcode
+ *
+ * Note that the @c on_data returns a @c ssize_t, the returned value must be @c -errno if an error happened or the number
+ * of bytes consumed from @c buf (0 is valid). The consumed bytes will be removed from the @c buf.
+ * It's important to note that the @c buf should not be modified and any references to its data should not be kept
+ * after @c on_data returns.
+ * Also just like @c on_feed_done, the user should be able to close/delete the stream handle inside @c on_data. Extra care
+ * must be taken in order to do not crash.
+ *
+ * Below there's an example of the stream device read implementation.
+ *
+ * @snippet design_patterns/stream_sample.c stream read
+ *
+ * @subsection usage Usage Example
+ *
+ * In the following example, it will be demonstrated how one can correctly use a stream API.
+ * The example is consists in an UART producer producing more data than an UART consumer can read.
+ * By doing so, it will be demonstrated how flow control can be employed.
+ *
+ * First we start configuring the streams and creating the streams.
+ * @snippet common/uart.c uart configure
+ *
+ * The producer will create its data every 10 ms ticks and try to send it.
+ * Since the producer buffer is limited sol_uart_feed() will start to return -ENOSPC,
+ * because the sum of all blobs are limited to @c feed_size.
+ *
+ * Below we can see how the data is produced and sent.
+ * @snippet common/uart.c uart write
+ *
+ * It's important to note that every time sol_uart_feed() returns @c -ENOSPC the
+ * data production is ceased and the blob that could not be sent is stored at the
+ * @c pending_blob variable.
+ *
+ * Every time a blob is completely written, the @c on_feed_done is called, in this case
+ * @c producer_data_written function. In this function the @c pending_blob variable
+ * is checked to see if it's not @c NULL. In case it's not NULL, we try to send it.
+ *
+ * @snippet common/uart.c uart write completed
+ *
+ * By stopping the data production when sol_uart_feed() returns @c -ENOSPC we control
+ * the data input flow. After sol_uart_feed() starts to accept blobs, the data
+ * production can start once again.
+ *
+ * Now it's time to take a look at our consumer. It's a very naive consumer, it will
+ * just print the data to @c stdout every time the nul byte is found.
+ * In addiction it will close the UART input if it receives the "close" string.
+ * Note that is completely safe to close the UART from the @c on_data (the same applies to @c on_feed_done!)
+ *
+ * @snippet common/uart.c uart read
+ *
+ * Now that you have the stream usage basics, you can start coding your apps!
+ *
+ * @subsection implementations Implementations
+ *
+ * Soletta currently implements streams for the following modules:
+ * <ul>
+ * <li> @ref UART
+ *    <ul>
+ *    <li> sol_uart_feed()
+ *    <li> struct sol_uart_config
+ *    </ul>
+ * </ul>
+ */
+
 /**
  * @page authors Authors
  *
diff --git a/src/lib/io/include/sol-uart.h b/src/lib/io/include/sol-uart.h
index cf4653fe..9e5b2d9b 100644
--- a/src/lib/io/include/sol-uart.h
+++ b/src/lib/io/include/sol-uart.h
@@ -99,6 +99,7 @@ enum sol_uart_stop_bits {
  * @brief A configuration struct used to set the UART paramenters.
  *
  * @see sol_uart_open()
+ * @note UART follows the Soletta stream design pattern, which can be found here: @ref streams
  */
 struct sol_uart_config {
 #ifndef SOL_NO_API_VERSION
@@ -289,6 +290,7 @@ void sol_uart_close(struct sol_uart *uart);
  * @param blob The blob to be written
  * @return 0 on success, @c -ENOSPC if sol_uart_config::feed_size is not zero and there's no more space left or negative errno on error
  * @see sol_uart_config::on_feed_done()
+ * @note UART follows the Soletta stream design pattern, which can be found here: @ref streams
  *
  */
 int sol_uart_feed(struct sol_uart *uart, struct sol_blob *blob);
diff --git a/src/samples/design_patterns/Kconfig b/src/samples/design_patterns/Kconfig
new file mode 100644
index 00000000..0513caba
--- /dev/null
+++ b/src/samples/design_patterns/Kconfig
@@ -0,0 +1,3 @@
+config DESIGN_PATTERN_SAMPLES
+	bool "Design patterns samples"
+	default y
diff --git a/src/samples/design_patterns/Makefile b/src/samples/design_patterns/Makefile
new file mode 100644
index 00000000..7cda7fb5
--- /dev/null
+++ b/src/samples/design_patterns/Makefile
@@ -0,0 +1,2 @@
+sample-$(DESIGN_PATTERN_SAMPLES) += stream_sample
+sample-stream_sample-$(DESIGN_PATTERN_SAMPLES) := stream_sample.c
diff --git a/src/samples/design_patterns/stream_sample.c b/src/samples/design_patterns/stream_sample.c
new file mode 100644
index 00000000..65cae38b
--- /dev/null
+++ b/src/samples/design_patterns/stream_sample.c
@@ -0,0 +1,431 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <sol-log.h>
+#include <sol-mainloop.h>
+#include <sol-types.h>
+#include <sol-buffer.h>
+#include <sol-util.h>
+#include <soletta.h>
+#include <unistd.h>
+#include <stdio.h>
+
+#define my_stream_device_write write
+#define my_stream_device_read read
+#define my_stream_device_add_io_monitor sol_fd_add
+#define my_stream_device_remove_io_monitor sol_fd_del
+#define my_stream_device_monitor_handle struct sol_fd
+
+struct my_stream_api_handle;
+
+//! [stream config]
+struct my_stream_api_config {
+    const void *user_data;
+    void (*on_feed_done)(void *user_data, struct my_stream_api_handle *handle, struct sol_blob *blob, int status);
+    ssize_t (*on_data)(void *user_data, struct my_stream_api_handle *handle, const struct sol_buffer *buf);
+    size_t feed_size;
+    size_t data_buffer_size;
+};
+
+struct my_stream_api_handle *my_stream_api_new(const struct my_stream_api_config *config, int dev);
+//! [stream config]
+
+//! [stream handle]
+struct my_stream_api_handle {
+    const void *user_data;
+    void (*on_feed_done)(void *user_data, struct my_stream_api_handle *handle, struct sol_blob *blob, int status);
+    ssize_t (*on_data)(void *user_data, struct my_stream_api_handle *handle, const struct sol_buffer *buf);
+    struct sol_timeout *read_timeout;
+    struct sol_buffer rx;
+    struct sol_ptr_vector pending_blobs;
+    my_stream_device_monitor_handle *read_monitor;
+    my_stream_device_monitor_handle *write_monitor;
+    size_t feed_size;
+    size_t pending_bytes;
+    size_t written;
+    int dev;
+    bool in_use;
+    bool delete_me;
+};
+//! [stream handle]
+
+static void api_close(struct my_stream_api_handle *handle);
+
+#define DEFAULT_BUFFER_SIZE (4096)
+
+//! [stream write api]
+int my_stream_api_feed(struct my_stream_api_handle *handle, struct sol_blob *blob);
+//! [stream write api]
+void my_stream_api_close(struct my_stream_api_handle *handle);
+
+//! [stream write]
+
+//The write operation itself
+static bool
+_can_write(void *data, int fd, uint32_t active_flags)
+{
+    struct my_stream_api_handle *handle = data;
+    struct sol_blob *blob;
+    ssize_t status;
+    bool r = true;
+
+    //Write the blob
+    blob = sol_ptr_vector_get(&handle->pending_blobs, 0);
+
+    //Write into the stream
+    status = my_stream_device_write(handle->dev, (char *)blob->mem + handle->written, blob->size);
+
+    if (status < 0) {
+        if (status == EAGAIN || status == EINTR)
+            return true;
+        else {
+            SOL_WRN("Could not write to the stream device!");
+            handle->write_monitor = NULL;
+            return false;
+        }
+    }
+
+    //Update how many bytes have been written
+    handle->written += status;
+    handle->pending_bytes -= status;
+
+    //Blob was completly written. Inform the user.
+    if (handle->written == blob->size) {
+        //Do we still have more data ?
+        sol_ptr_vector_del(&handle->pending_blobs, 0);
+        if (!sol_ptr_vector_get_len(&handle->pending_blobs)) {
+            r = false;
+            handle->write_monitor = NULL;
+        }
+        //Reset the written counter
+        handle->written = 0;
+
+        /*
+           Inform the user.
+           Since it's completly safe to call my_stream_api_close() inside on_feed_done().
+           Informing the user should be the last thing to do.
+         */
+        if (handle->on_feed_done)
+            handle->on_feed_done((void *)handle->user_data, handle, blob, status);
+        sol_blob_unref(blob); //NOTE: that we unref the blob, not the user!
+    }
+
+    return r;
+}
+
+int
+my_stream_api_feed(struct my_stream_api_handle *handle, struct sol_blob *blob)
+{
+    size_t total;
+    int r;
+
+    SOL_NULL_CHECK(handle, -EINVAL);
+    SOL_NULL_CHECK(blob, -EINVAL);
+    //Do not try to write with the uart is going to be closed
+    SOL_EXP_CHECK(handle->delete_me, -EINVAL);
+
+    total = handle->pending_bytes + blob->size;
+
+    //feed_size was set and the total must not exceed feed_size
+    if (handle->feed_size && total >= handle->feed_size)
+        return -ENOSPC; //Try again later
+
+    //Store the blob and ref it, since it will written later.
+    r = sol_ptr_vector_append(&handle->pending_blobs, blob);
+    SOL_INT_CHECK(r, < 0, r);
+    sol_blob_ref(blob);
+    handle->pending_bytes = total;
+
+    //Schedule the write operation
+    if (!handle->write_monitor) {
+        handle->write_monitor = my_stream_device_add_io_monitor(handle->dev,
+            SOL_FD_FLAGS_OUT, _can_write, handle);
+        SOL_NULL_CHECK_GOTO(handle->write_monitor, err_monitor);
+    }
+
+    return 0;
+
+err_monitor:
+    sol_ptr_vector_del_element(&handle->pending_blobs, blob);
+    sol_blob_unref(blob);
+    return -ENOMEM;
+}
+
+//! [stream write]
+
+//! [stream read]
+//Delivery the data to the user
+static bool
+_inform_user(void *data)
+{
+    struct my_stream_api_handle *handle = data;
+    ssize_t r;
+
+    //Flag that we're using the handle, then if the user tries to delete us from the on_data we do not crash.
+    handle->in_use = true;
+
+    //Inform the user
+    r = handle->on_data((void *)handle->user_data, handle, &handle->rx);
+
+    handle->in_use = false;
+    //The user asked for deletion. Do it now.
+    if (handle->delete_me) {
+        api_close(handle);
+        return false;
+    }
+
+    //Remove the data.
+    if (r < 0)
+        SOL_ERR("Something wrong happened %zd", r);
+    else
+        sol_buffer_remove_data(&handle->rx, 0, r);
+
+    //Still need to callback the user with remaining data, keep the timer running
+    if (handle->rx.used)
+        return true;
+    handle->read_timeout = NULL;
+    return false;
+}
+
+//Actually read from the device
+static bool
+_can_read(void *data, int fd, uint32_t active_flags)
+{
+    struct my_stream_api_handle *handle = data;
+    size_t remaining = handle->rx.capacity - handle->rx.used;
+    ssize_t status;
+
+    //The rx buffer is full. Try to expand it in order to store more data.
+    if (!remaining && !(handle->rx.flags & SOL_BUFFER_FLAGS_FIXED_CAPACITY)) {
+        int err;
+
+        err = sol_buffer_expand(&handle->rx, DEFAULT_BUFFER_SIZE);
+        SOL_INT_CHECK(err, < 0, true);
+        remaining = DEFAULT_BUFFER_SIZE;
+    }
+
+    if (remaining > 0) {
+        //Append data to the buffer
+        status = my_stream_device_read(handle->dev, sol_buffer_at_end(&handle->rx), remaining);
+        if (status < 0) {
+            if (status == EAGAIN || status == EINTR)
+                return true;
+            else {
+                SOL_WRN("Could not read to the stream device!");
+                handle->read_monitor = NULL;
+                return false;
+            }
+        }
+        handle->rx.used += status;
+    }
+
+    if (!handle->read_timeout)
+        handle->read_timeout = sol_timeout_add(0, _inform_user, handle);
+
+    return true;
+}
+
+//Stream creation, where on_data is configured
+struct my_stream_api_handle *
+my_stream_api_new(const struct my_stream_api_config *config, int dev)
+{
+    struct my_stream_api_handle *handle;
+    size_t data_buffer_size;
+    void *buf = NULL;
+    //By default the rx buffer will not be limited
+    enum sol_buffer_flags flags = SOL_BUFFER_FLAGS_NO_NUL_BYTE | SOL_BUFFER_FLAGS_DEFAULT;
+
+    handle = calloc(1, sizeof(struct my_stream_api_handle));
+    SOL_NULL_CHECK(handle, NULL);
+
+    handle->on_feed_done = config->on_feed_done;
+    handle->feed_size = config->feed_size;
+    handle->user_data = config->user_data;
+
+    //The user does not want to read from the stream, ignore rx configuration.
+    if (config->on_data) {
+        handle->on_data = config->on_data;
+        data_buffer_size = config->data_buffer_size;
+
+        //The rx buffer has a fixed size and we should respect that.
+        if (data_buffer_size) {
+            buf = malloc(data_buffer_size);
+            SOL_NULL_CHECK_GOTO(buf, err_buf);
+            flags |= SOL_BUFFER_FLAGS_FIXED_CAPACITY;
+        } //else - The user is informing that the rx buffer should be unlimited
+
+        //Setup input monitor
+        handle->read_monitor = my_stream_device_add_io_monitor(handle->dev, SOL_FD_FLAGS_IN, _can_read, handle);
+        SOL_NULL_CHECK_GOTO(handle->read_monitor, err_monitor);
+    }
+
+    sol_buffer_init_flags(&handle->rx, buf, data_buffer_size, flags);
+    sol_ptr_vector_init(&handle->pending_blobs);
+    handle->dev = dev;
+
+    return handle;
+
+err_monitor:
+    free(buf);
+err_buf:
+    free(handle);
+    return NULL;
+}
+
+static void
+api_close(struct my_stream_api_handle *handle)
+{
+    uint16_t i;
+    struct sol_blob *blob;
+
+    handle->in_use = handle->delete_me = true;
+    //Inform that some blobs where not sent
+    SOL_PTR_VECTOR_FOREACH_IDX (&handle->pending_blobs, blob, i) {
+        if (handle->on_feed_done)
+            handle->on_feed_done((void *)handle->user_data, handle, blob, -ECANCELED);
+        sol_blob_unref(blob);
+    }
+
+    //Last chance to consume the rx buffer
+    if (handle->rx.used)
+        handle->on_data((void *)handle->user_data, handle, &handle->rx);
+
+    sol_ptr_vector_clear(&handle->pending_blobs);
+    sol_buffer_fini(&handle->rx);
+    free(handle);
+}
+
+void
+my_stream_api_close(struct my_stream_api_handle *handle)
+{
+    SOL_NULL_CHECK(handle);
+    SOL_EXP_CHECK(handle->delete_me);
+
+    if (handle->read_timeout) {
+        sol_timeout_del(handle->read_timeout);
+        handle->read_timeout = NULL;
+    }
+
+    if (handle->read_monitor) {
+        my_stream_device_remove_io_monitor(handle->read_monitor);
+        handle->read_monitor = NULL;
+    }
+
+    if (handle->write_monitor) {
+        my_stream_device_remove_io_monitor(handle->write_monitor);
+        handle->write_monitor = NULL;
+    }
+
+    //The user is trying to delete the handle from the on_data, do not delete it now.
+    if (handle->in_use) {
+        handle->delete_me = true;
+        return;
+    }
+    api_close(handle);
+}
+
+//! [stream read]
+
+static void
+on_feed_done(void *data, struct my_stream_api_handle *handle, struct sol_blob *blob, int status)
+{
+    struct sol_str_slice slice = sol_str_slice_from_blob(blob);
+
+    if (status  < 0)
+        fprintf(stderr, "Could not send the blob data: %.*s. Reason: %s",
+            SOL_STR_SLICE_PRINT(slice), sol_util_strerrora(-status));
+    else
+        printf("\n'%.*s' Sent to stdout\n", SOL_STR_SLICE_PRINT(slice));
+}
+
+static struct my_stream_api_handle *out_handle;
+
+static ssize_t
+on_data(void *user_data, struct my_stream_api_handle *handle, const struct sol_buffer *buf)
+{
+    struct sol_str_slice slice = sol_buffer_get_slice(buf);
+    struct sol_blob *blob;
+    char *sep;
+
+    sep = memchr(slice.data, '\n', slice.len);
+
+    if (!sep)
+        return 0;
+
+    slice.len = sep - slice.data;
+
+    printf("Received data '%.*s'. Sending to stdout.\n", SOL_STR_SLICE_PRINT(slice));
+
+    if (sol_str_slice_str_eq(slice, "Bye")) {
+        my_stream_api_close(handle);
+        printf("Closing the input stream\n");
+        sol_quit();
+    }
+
+    blob = sol_blob_new(&SOL_BLOB_TYPE_NO_FREE_DATA, NULL, slice.data, slice.len);
+    if (!blob) {
+        fprintf(stderr, "Could not create a blob to send to stdout");
+        return -ENOMEM;
+    }
+    my_stream_api_feed(out_handle, blob);
+    sol_blob_unref(blob);
+
+
+    return slice.len + 1;
+}
+
+static void
+startup(void)
+{
+    struct my_stream_api_handle *in_handle;
+    static const struct my_stream_api_config in_config = {
+        .on_data = on_data,
+    };
+    static const struct my_stream_api_config out_config = {
+        .on_feed_done = on_feed_done,
+    };
+
+    in_handle = my_stream_api_new(&in_config, STDIN_FILENO);
+
+    if (!in_handle) {
+        fprintf(stderr, "Could not create the input stream\n");
+        goto err_in;
+    }
+
+    out_handle = my_stream_api_new(&out_config, STDOUT_FILENO);
+    if (!out_handle) {
+        fprintf(stderr, "Could not create the output stream\n");
+        goto err_out;
+    }
+
+    printf("Type some text and press enter.\n");
+
+    return;
+err_out:
+    my_stream_api_close(in_handle);
+err_in:
+    sol_quit_with_code(EXIT_FAILURE);
+}
+
+static void
+shutdown(void)
+{
+}
+
+
+SOL_MAIN_DEFAULT(startup, shutdown);