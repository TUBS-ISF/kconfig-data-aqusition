"2016-02-23 14:28:02 -0300"
diff --git a/src/samples/coap/Kconfig b/src/samples/coap/Kconfig
index fd83c7c0..6958a905 100644
--- a/src/samples/coap/Kconfig
+++ b/src/samples/coap/Kconfig
@@ -11,3 +11,8 @@ config OIC_SAMPLES
 	bool "OIC samples"
 	depends on OIC && COAP_SAMPLES
 	default y
+
+config LWM2M_SAMPLES
+       bool "LWM2M samples"
+       depends on COAP && COAP_SAMPLES
+       default y
diff --git a/src/samples/coap/Makefile b/src/samples/coap/Makefile
index 869f332d..a7ea6b1b 100644
--- a/src/samples/coap/Makefile
+++ b/src/samples/coap/Makefile
@@ -6,3 +6,7 @@ sample-$(OIC_SAMPLES) += oic-sample-client oic-sample-server iotivity-test-clien
 sample-oic-sample-client-$(OIC_SAMPLES) := oic-client.c
 sample-oic-sample-server-$(OIC_SAMPLES) := oic-server.c
 sample-iotivity-test-client-$(OIC_SAMPLES) := iotivity-test-client.c
+
+sample-$(LWM2M_SAMPLES) += lwm2m-sample-server lwm2m-sample-client
+sample-lwm2m-sample-server-$(LWM2M_SAMPLES) := lwm2m-server.c
+sample-lwm2m-sample-client-$(LWM2M_SAMPLES) := lwm2m-client.c
diff --git a/src/samples/coap/lwm2m-client.c b/src/samples/coap/lwm2m-client.c
new file mode 100644
index 00000000..84f6ad7a
--- /dev/null
+++ b/src/samples/coap/lwm2m-client.c
@@ -0,0 +1,436 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+   To run: ./lwm2m-sample-client [client name]
+   This LWM2M client sample will try to connect to a LWM2M server @ locahost:5683.
+   If a location object is created by the LWM2M server, it will report its location
+   every one second.
+ */
+
+#include "sol-lwm2m.h"
+#include "sol-mainloop.h"
+#include "sol-vector.h"
+#include "sol-util.h"
+
+#include <stdio.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <time.h>
+
+#define LOCATION_OBJ_ID (6)
+#define LOCATION_OBJ_LATITUDE_RES_ID (0)
+#define LOCATION_OBJ_LONGITUDE_RES_ID (1)
+#define LOCATION_OBJ_TIMESTAMP_RES_ID (5)
+
+#define ONE_SECOND (1000)
+#define LIFETIME (60)
+
+#define SERVER_OBJ_ID (1)
+#define SERVER_OBJ_SHORT_RES_ID (0)
+#define SERVER_OBJ_LIFETIME_RES_ID (1)
+#define SERVER_OBJ_BINDING_RES_ID (7)
+#define SERVER_OBJ_REGISTRATION_UPDATE_RES_ID (8)
+
+#define SECURITY_SERVER_OBJ_ID (0)
+#define SECURITY_SERVER_SERVER_URI_RES_ID (0)
+#define SECURITY_SERVER_IS_BOOTSTRAP_RES_ID (1)
+#define SECURITY_SERVER_SERVER_ID_RES_ID (10)
+
+struct location_obj_instance_ctx {
+    struct sol_timeout *timeout;
+    struct sol_lwm2m_client *client;
+    char *latitude;
+    char *longitude;
+    int64_t timestamp;
+};
+
+static char *
+generate_new_coord(void)
+{
+    char *p;
+    int r;
+    double v = ((double)rand() / (double)RAND_MAX);
+
+    r = asprintf(&p, "%g", v);
+    if (r < 0)
+        return NULL;
+    return p;
+}
+
+static bool
+change_location(void *data)
+{
+    struct location_obj_instance_ctx *instance_ctx = data;
+    char *latitude, *longitude;
+    int r = 0;
+    static const char *paths[] = { "/6/0/0",
+                                   "/6/0/1", "/6/0/5", NULL };
+
+    latitude = longitude = NULL;
+
+    latitude = generate_new_coord();
+
+    if (!latitude) {
+        fprintf(stderr, "Could not generate a new latitude\n");
+        return true;
+    }
+
+    longitude = generate_new_coord();
+    if (!longitude) {
+        fprintf(stderr, "Could not generate a new longitude\n");
+        free(latitude);
+        return true;
+    }
+
+    free(instance_ctx->latitude);
+    free(instance_ctx->longitude);
+    instance_ctx->latitude = latitude;
+    instance_ctx->longitude = longitude;
+
+    instance_ctx->timestamp = (int64_t)time(NULL);
+
+    printf("New latitude: %s - New longitude: %s\n", instance_ctx->latitude,
+        instance_ctx->longitude);
+
+    r = sol_lwm2m_notify_observers(instance_ctx->client, paths);
+
+    if (r < 0) {
+        fprintf(stderr, "Could not notify the observers\n");
+    } else
+        printf("Sending new location coordinates to the observers\n");
+
+    return true;
+}
+
+static int
+create_location_obj(void *user_data, struct sol_lwm2m_client *client,
+    uint16_t instance_id, void **instance_data,
+    enum sol_lwm2m_content_type content_type,
+    const struct sol_str_slice content)
+{
+    struct location_obj_instance_ctx *instance_ctx;
+    bool *has_location_instance = user_data;
+    struct sol_vector tlvs;
+    int r;
+    uint16_t i;
+    struct sol_lwm2m_tlv *tlv;
+
+    //Only one location object is allowed
+    if (*has_location_instance) {
+        fprintf(stderr, "Only one location object instance is allowed\n");
+        return -EINVAL;
+    }
+
+    if (content_type != SOL_LWM2M_CONTENT_TYPE_TLV) {
+        fprintf(stderr, "Content type is not in TLV format\n");
+        return -EINVAL;
+    }
+
+    instance_ctx = calloc(1, sizeof(struct location_obj_instance_ctx));
+    if (!instance_ctx) {
+        fprintf(stderr, "Could not alloc memory for location object context\n");
+        return -ENOMEM;
+    }
+
+    instance_ctx->timeout = sol_timeout_add(ONE_SECOND, change_location,
+        instance_ctx);
+    if (!instance_ctx->timeout) {
+        fprintf(stderr, "Could not create the client timer\n");
+        r = -ENOMEM;
+        goto err_free_instance;
+    }
+
+    r = sol_lwm2m_parse_tlv(content, &tlvs);
+    if (r < 0) {
+        fprintf(stderr, "Could not parse the TLV content\n");
+        goto err_free_timeout;
+    }
+
+    if (tlvs.len != 3) {
+        r = -EINVAL;
+        fprintf(stderr, "Missing mandatory fields.\n");
+        goto err_free_tlvs;
+    }
+
+    SOL_VECTOR_FOREACH_IDX (&tlvs, tlv, i) {
+        uint8_t *bytes;
+        uint16_t bytes_len;
+        char **prop = NULL;
+
+        bytes_len = 0;
+
+        if (tlv->id == LOCATION_OBJ_LATITUDE_RES_ID) {
+            r = sol_lwm2m_tlv_get_bytes(tlv, &bytes, &bytes_len);
+            prop = &instance_ctx->latitude;
+        } else if (tlv->id == LOCATION_OBJ_LONGITUDE_RES_ID) {
+            r = sol_lwm2m_tlv_get_bytes(tlv, &bytes, &bytes_len);
+            prop = &instance_ctx->longitude;
+        } else
+            r = sol_lwm2m_tlv_to_int(tlv, &instance_ctx->timestamp);
+
+        if (r < 0) {
+            fprintf(stderr, "Could not get the tlv value for resource %"
+                PRIu16 "\n", tlv->id);
+            goto err_free_tlvs;
+        }
+
+        if (bytes_len) {
+            *prop = strndup((const char *)bytes, bytes_len);
+            if (!*prop) {
+                r = -ENOMEM;
+                fprintf(stderr, "Could not copy the longitude/latitude"
+                    " property\n");
+                goto err_free_tlvs;
+            }
+        }
+    }
+
+    instance_ctx->client = client;
+    *instance_data = instance_ctx;
+    *has_location_instance = true;
+    sol_lwm2m_tlv_array_clear(&tlvs);
+    printf("Location object created\n");
+
+    return 0;
+
+err_free_tlvs:
+    sol_lwm2m_tlv_array_clear(&tlvs);
+err_free_timeout:
+    sol_timeout_del(instance_ctx->timeout);
+    free(instance_ctx->longitude);
+    free(instance_ctx->latitude);
+err_free_instance:
+    free(instance_ctx);
+    return r;
+}
+
+static int
+read_location_obj(void *instance_data, void *user_data,
+    struct sol_lwm2m_client *client, uint16_t instance_id,
+    uint16_t res_id, struct sol_lwm2m_resource *res)
+{
+    struct location_obj_instance_ctx *ctx = instance_data;
+    int r;
+
+    switch (res_id) {
+    case LOCATION_OBJ_LATITUDE_RES_ID:
+        SOL_LWM2M_RESOURCE_INIT(r, res, res_id, 1,
+            SOL_LWM2M_RESOURCE_DATA_TYPE_STRING,
+            sol_str_slice_from_str(ctx->latitude));
+        break;
+    case LOCATION_OBJ_LONGITUDE_RES_ID:
+        SOL_LWM2M_RESOURCE_INIT(r, res, res_id, 1,
+            SOL_LWM2M_RESOURCE_DATA_TYPE_STRING,
+            sol_str_slice_from_str(ctx->longitude));
+        break;
+    case LOCATION_OBJ_TIMESTAMP_RES_ID:
+        SOL_LWM2M_RESOURCE_INIT(r, res, res_id, 1,
+            SOL_LWM2M_RESOURCE_DATA_TYPE_TIME, ctx->timestamp);
+        break;
+    default:
+        if (res_id >= 2 && res_id <= 4)
+            r = -ENOENT;
+        else
+            r = -EBADRQC;
+    }
+
+    return r;
+}
+
+static int
+read_security_server_obj(void *instance_data, void *user_data,
+    struct sol_lwm2m_client *client,
+    uint16_t instance_id, uint16_t res_id, struct sol_lwm2m_resource *res)
+{
+    int r;
+
+    //It implements only the necassary info to connect to a LWM2M server Without encryption.
+    switch (res_id) {
+    case SECURITY_SERVER_SERVER_URI_RES_ID:
+        SOL_LWM2M_RESOURCE_INIT(r, res, 0, 1,
+            SOL_LWM2M_RESOURCE_DATA_TYPE_STRING,
+            sol_str_slice_from_str("coap://localhost:5683"));
+        break;
+    case SECURITY_SERVER_IS_BOOTSTRAP_RES_ID:
+        SOL_LWM2M_RESOURCE_INIT(r, res, 1, 1,
+            SOL_LWM2M_RESOURCE_DATA_TYPE_BOOLEAN, false);
+        break;
+    case SECURITY_SERVER_SERVER_ID_RES_ID:
+        SOL_LWM2M_RESOURCE_INIT(r, res, 10, 1,
+            SOL_LWM2M_RESOURCE_DATA_TYPE_INT, 101);
+        break;
+    default:
+        if (res_id >= 2 && res_id <= 11)
+            r = -ENOENT;
+        else
+            r = -EBADRQC;
+    }
+
+    return r;
+}
+
+static int
+read_server_obj(void *instance_data, void *user_data,
+    struct sol_lwm2m_client *client,
+    uint16_t instance_id, uint16_t res_id, struct sol_lwm2m_resource *res)
+{
+    int r;
+
+    //It implements only the necassary info to connect to a LWM2M server Without encryption.
+    switch (res_id) {
+    case SERVER_OBJ_SHORT_RES_ID:
+        SOL_LWM2M_RESOURCE_INIT(r, res, res_id, 1,
+            SOL_LWM2M_RESOURCE_DATA_TYPE_INT, 101);
+        break;
+    case SERVER_OBJ_LIFETIME_RES_ID:
+        SOL_LWM2M_RESOURCE_INIT(r, res, res_id, 1,
+            SOL_LWM2M_RESOURCE_DATA_TYPE_INT, LIFETIME);
+        break;
+    case SERVER_OBJ_BINDING_RES_ID:
+        SOL_LWM2M_RESOURCE_INIT(r, res, res_id, 1,
+            SOL_LWM2M_RESOURCE_DATA_TYPE_STRING,
+            sol_str_slice_from_str("U"));
+        break;
+    default:
+        if (res_id >= 2 && res_id <= 6)
+            r = -ENOENT;
+        else
+            r = -EBADRQC;
+    }
+
+    return r;
+}
+
+static int
+execute_server_obj(void *instance_data, void *user_data,
+    struct sol_lwm2m_client *client, uint16_t instance_id,
+    uint16_t res_id, const struct sol_str_slice args)
+{
+    if (res_id != SERVER_OBJ_REGISTRATION_UPDATE_RES_ID)
+        return -EBADRQC;
+
+    return sol_lwm2m_send_update(client);
+}
+
+static int
+del_location_obj(void *instance_data, void *user_data,
+    struct sol_lwm2m_client *client, uint16_t instance_id)
+{
+    struct location_obj_instance_ctx *instance_ctx = instance_data;
+    bool *has_location_instance = user_data;
+
+    if (instance_ctx->timeout)
+        sol_timeout_del(instance_ctx->timeout);
+    free(instance_ctx->latitude);
+    free(instance_ctx->longitude);
+    free(instance_ctx);
+    *has_location_instance = false;
+    return 0;
+}
+
+static const struct sol_lwm2m_object location_object = {
+    SOL_SET_API_VERSION(.api_version = SOL_LWM2M_OBJECT_API_VERSION, )
+    .id = LOCATION_OBJ_ID,
+    .create = create_location_obj,
+    .read = read_location_obj,
+    .del = del_location_obj,
+    .resources_count = 6
+};
+
+static const struct sol_lwm2m_object security_object = {
+    SOL_SET_API_VERSION(.api_version = SOL_LWM2M_OBJECT_API_VERSION, )
+    .id = SECURITY_SERVER_OBJ_ID,
+    .resources_count = 12,
+    .read = read_security_server_obj
+};
+
+static const struct sol_lwm2m_object server_object = {
+    SOL_SET_API_VERSION(.api_version = SOL_LWM2M_OBJECT_API_VERSION, )
+    .id = SERVER_OBJ_ID,
+    .resources_count = 9,
+    .read = read_server_obj,
+    .execute = execute_server_obj
+};
+
+int
+main(int argc, char *argv[])
+{
+    struct sol_lwm2m_client *client;
+    static const struct sol_lwm2m_object *objects[] =
+    { &security_object, &server_object, &location_object, NULL };
+    bool has_location_instance = false;
+    int r;
+
+    srand(time(NULL));
+    if (argc < 2) {
+        fprintf(stderr, "Usage: ./lwm2m-sample-client [client-name]\n");
+        return -1;
+    }
+
+    sol_init();
+
+    client = sol_lwm2m_client_new(argv[1], NULL, NULL, objects,
+        &has_location_instance);
+
+    if (!client) {
+        r = -1;
+        fprintf(stderr, "Could not the create the LWM2M client\n");
+        goto exit;
+    }
+
+    r = sol_lwm2m_add_object_instance(client, &server_object, NULL);
+    if (r < 0) {
+        fprintf(stderr, "Could not add a server object instance\n");
+        goto exit_del;
+    }
+
+    r = sol_lwm2m_add_object_instance(client, &security_object, NULL);
+
+    if (r < 0) {
+        fprintf(stderr, "Could not add a security object instance\n");
+        goto exit_del;
+    }
+
+    sol_lwm2m_client_start(client);
+
+    sol_run();
+    r = 0;
+
+    sol_lwm2m_client_stop(client);
+
+exit_del:
+    sol_lwm2m_client_del(client);
+exit:
+    sol_shutdown();
+    return r;
+}
diff --git a/src/samples/coap/lwm2m-server.c b/src/samples/coap/lwm2m-server.c
new file mode 100644
index 00000000..1715a52f
--- /dev/null
+++ b/src/samples/coap/lwm2m-server.c
@@ -0,0 +1,312 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+   To run: ./lwm2m-sample-server
+   For every LWM2M client that connects with the server, the server will
+   try to create an LWM2M location object if it does not exist.
+   After that, it will observe the location object.
+ */
+
+#include "sol-lwm2m.h"
+#include "sol-mainloop.h"
+#include "sol-vector.h"
+#include "sol-util.h"
+
+#include <stdio.h>
+#include <stdbool.h>
+#include <errno.h>
+
+#define LOCATION_OBJ_ID (6)
+#define LONGITUDE_ID (1)
+#define LATITUDE_ID (0)
+#define TIMESTAMP_ID (5)
+
+enum location_object_status {
+    LOCATION_OBJECT_NOT_FOUND,
+    LOCATION_OBJECT_WITH_NO_INSTANCES,
+    LOCATION_OBJECT_WITH_INSTANCES
+};
+
+static enum location_object_status
+get_location_object_status(const struct sol_lwm2m_client_info *cinfo)
+{
+    uint16_t i;
+    struct sol_lwm2m_client_object *object;
+    const struct sol_ptr_vector *objects =
+        sol_lwm2m_client_info_get_objects(cinfo);
+
+    SOL_PTR_VECTOR_FOREACH_IDX (objects, object, i) {
+        const struct sol_ptr_vector *instances;
+        uint16_t id;
+        int r;
+
+        r = sol_lwm2m_client_object_get_id(object, &id);
+        if (r < 0) {
+            fprintf(stderr, "Could not fetch the object id from %p\n", object);
+            return LOCATION_OBJECT_NOT_FOUND;
+        }
+
+        if (id != LOCATION_OBJ_ID)
+            continue;
+
+        instances = sol_lwm2m_client_object_get_instances(object);
+
+        if (sol_ptr_vector_get_len(instances))
+            return LOCATION_OBJECT_WITH_INSTANCES;
+        return LOCATION_OBJECT_WITH_NO_INSTANCES;
+    }
+
+    return LOCATION_OBJECT_NOT_FOUND;
+}
+
+static void
+location_changed_cb(void *data,
+    struct sol_lwm2m_server *server,
+    struct sol_lwm2m_client_info *cinfo,
+    const char *path,
+    sol_coap_responsecode_t response_code,
+    enum sol_lwm2m_content_type content_type,
+    struct sol_str_slice content)
+{
+    struct sol_vector tlvs;
+    const char *name = sol_lwm2m_client_info_get_name(cinfo);
+    int r;
+    uint16_t i;
+    struct sol_lwm2m_tlv *tlv;
+
+    if (response_code != SOL_COAP_RSPCODE_CHANGED &&
+        response_code != SOL_COAP_RSPCODE_CONTENT) {
+        fprintf(stderr, "Could not get the location object value from"
+            " client %s\n", name);
+        return;
+    }
+
+    if (content_type != SOL_LWM2M_CONTENT_TYPE_TLV) {
+        fprintf(stderr, "The location object content from client %s is not"
+            " in TLV format. Received format: %d\n", name, content_type);
+        return;
+    }
+
+    r = sol_lwm2m_parse_tlv(content, &tlvs);
+
+    if (r < 0) {
+        fprintf(stderr, "Could not parse the tlv from client: %s\n", name);
+        return;
+    }
+
+    SOL_VECTOR_FOREACH_IDX (&tlvs, tlv, i) {
+        const char *prop;
+        uint8_t *bytes;
+        uint16_t len;
+
+        if (tlv->id == LATITUDE_ID)
+            prop = "latitude";
+        else if (tlv->id == LONGITUDE_ID)
+            prop = "longitude";
+        else
+            continue;
+
+        r = sol_lwm2m_tlv_get_bytes(tlv, &bytes, &len);
+        if (r < 0) {
+            fprintf(stderr, "Could not the %s value from client %s\n",
+                prop, name);
+            break;
+        }
+
+        printf("Client %s %s is %.*s\n", name, prop, (int)len, bytes);
+    }
+
+    sol_lwm2m_tlv_array_clear(&tlvs);
+}
+
+static void
+observe_location(struct sol_lwm2m_server *server,
+    struct sol_lwm2m_client_info *cinfo)
+{
+    int r;
+
+    r = sol_lwm2m_server_add_observer(server, cinfo, "/6",
+        location_changed_cb, NULL);
+
+    if (r < 0)
+        fprintf(stderr, "Could not send an observe request to the location"
+            " object\n");
+    else
+        printf("Observe request to the location object sent\n");
+}
+
+static void
+create_cb(void *data,
+    struct sol_lwm2m_server *server,
+    struct sol_lwm2m_client_info *cinfo, const char *path,
+    sol_coap_responsecode_t response_code)
+{
+    const char *name = sol_lwm2m_client_info_get_name(cinfo);
+
+    if (response_code != SOL_COAP_RSPCODE_CREATED) {
+        fprintf(stderr, "The client %s could not create the location object.\n",
+            name);
+        return;
+    }
+
+    printf("The client %s created the location object."
+        " Observing it now.\n", name);
+    observe_location(server, cinfo);
+}
+
+static void
+create_location_obj(struct sol_lwm2m_server *server,
+    struct sol_lwm2m_client_info *cinfo)
+{
+    int r;
+    struct sol_lwm2m_resource res[3];
+    size_t i;
+
+    /*
+       Send a request the create a location object instance.
+       It sets only the mandatory fields.
+       The coordinates are the position of the Eiffel tower.
+     */
+    SOL_LWM2M_RESOURCE_INIT(r, &res[0], LATITUDE_ID, 1,
+        SOL_LWM2M_RESOURCE_DATA_TYPE_STRING,
+        sol_str_slice_from_str("48.858093"));
+
+    if (r < 0) {
+        fprintf(stderr, "Could init the latitude resource\n");
+        return;
+    }
+
+    SOL_LWM2M_RESOURCE_INIT(r, &res[1], LONGITUDE_ID, 1,
+        SOL_LWM2M_RESOURCE_DATA_TYPE_STRING,
+        sol_str_slice_from_str("2.294694"));
+
+    if (r < 0) {
+        fprintf(stderr, "Could not init the longitude resource\n");
+        return;
+    }
+
+    SOL_LWM2M_RESOURCE_INIT(r, &res[2], TIMESTAMP_ID, 1,
+        SOL_LWM2M_RESOURCE_DATA_TYPE_TIME,
+        (int64_t)time(NULL));
+
+    if (r < 0) {
+        fprintf(stderr, "Could not init the longitude resource\n");
+        return;
+    }
+
+    r = sol_lwm2m_server_management_create(server, cinfo, "/6", res,
+        SOL_UTIL_ARRAY_SIZE(res), create_cb, NULL);
+
+    for (i = 0; i < SOL_UTIL_ARRAY_SIZE(res); i++)
+        sol_lwm2m_resource_clear(&res[i]);
+
+    if (r < 0)
+        fprintf(stderr, "Could not send a request to create a"
+            " location object\n");
+    else
+        printf("Creation request sent\n");
+}
+
+static void
+registration_cb(void *data,
+    struct sol_lwm2m_server *server,
+    struct sol_lwm2m_client_info *cinfo,
+    enum sol_lwm2m_registration_event event)
+{
+    const char *name;
+    enum location_object_status status;
+
+    name = sol_lwm2m_client_info_get_name(cinfo);
+
+    if (event == SOL_LWM2M_REGISTRATION_EVENT_UPDATE) {
+        printf("Client %s updated\n", name);
+        return;
+    } else if (event == SOL_LWM2M_REGISTRATION_EVENT_UNREGISTER) {
+        printf("Client %s unregistered\n", name);
+        return;
+    } else if (event == SOL_LWM2M_REGISTRATION_EVENT_TIMEOUT) {
+        printf("Client %s timeout\n", name);
+        return;
+    }
+
+    printf("Client %s registered\n", name);
+    status = get_location_object_status(cinfo);
+
+    if (status == LOCATION_OBJECT_NOT_FOUND) {
+        fprintf(stderr,
+            "The client %s does not implement the location object!\n",
+            name);
+    } else if (status == LOCATION_OBJECT_WITH_NO_INSTANCES) {
+        printf("The client %s does not have an instance of the location"
+            " object. Creating one.\n", name);
+        create_location_obj(server, cinfo);
+    } else {
+        printf("The client %s have an location object instance,"
+            " observing\n", name);
+        observe_location(server, cinfo);
+    }
+}
+
+int
+main(int argc, char *argv[])
+{
+    struct sol_lwm2m_server *server;
+    uint16_t port = SOL_LWM2M_DEFAULT_SERVER_PORT;
+    int r;
+
+    printf("Using the default LWM2M port (%" PRIu16 ")\n", port);
+    sol_init();
+
+    server = sol_lwm2m_server_new(port);
+    if (!server) {
+        r = -1;
+        fprintf(stderr, "Could not create the LWM2M server\n");
+        goto exit;
+    }
+
+    r = sol_lwm2m_server_add_registration_monitor(server, registration_cb,
+        NULL);
+    if (r < 0) {
+        fprintf(stderr, "Could not add a registration monitor\n");
+        goto exit_del;
+    }
+
+    sol_run();
+
+    r = 0;
+exit_del:
+    sol_lwm2m_server_del(server);
+exit:
+    sol_shutdown();
+    return r;
+}