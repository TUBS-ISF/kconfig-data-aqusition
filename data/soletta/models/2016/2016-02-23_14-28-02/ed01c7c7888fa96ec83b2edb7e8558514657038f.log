"2016-02-23 14:28:02 -0300"
diff --git a/src/lib/comms/Kconfig b/src/lib/comms/Kconfig
index 06c4fa16..708ebe9f 100644
--- a/src/lib/comms/Kconfig
+++ b/src/lib/comms/Kconfig
@@ -115,3 +115,12 @@ config MAVLINK
             MAVLink or Micro Air Vehicle Link is a protocol for communicating with
             small unmanned vehicle. It is designed as a header-only message marshaling
             library.
+
+config LWM2M
+       bool "LWM2M"
+       default y
+       depends on COAP
+       help
+           LWM2M is a protocol for communication between IoT devices defined by OMA
+           (Open Mobile Alliance).
+           Both client and server sides are covered by this library.
diff --git a/src/lib/comms/Makefile b/src/lib/comms/Makefile
index ea193602..45a3a363 100644
--- a/src/lib/comms/Makefile
+++ b/src/lib/comms/Makefile
@@ -94,6 +94,9 @@ obj-networking-$(MAVLINK)-extra-cflags += \
 	-I$(MAVLINK_SRC_PATH)/ardupilotmega/ \
 	-Wno-declaration-after-statement
 
+obj-networking-$(LWM2M) += \
+	sol-lwm2m.o
+
 headers-$(NETWORK) += \
     include/sol-network.h
 
@@ -119,3 +122,6 @@ headers-$(MQTT) += \
 
 headers-$(MAVLINK) += \
 	include/sol-mavlink.h
+
+headers-$(LWM2M) += \
+    include/sol-lwm2m.h
diff --git a/src/lib/comms/include/sol-lwm2m.h b/src/lib/comms/include/sol-lwm2m.h
new file mode 100644
index 00000000..25931f7c
--- /dev/null
+++ b/src/lib/comms/include/sol-lwm2m.h
@@ -0,0 +1,355 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#pragma once
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "sol-coap.h"
+#include "sol-network.h"
+#include "sol-str-slice.h"
+#include "sol-vector.h"
+#include "sol-buffer.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @file
+ * @brief Routines that handle LWM2M protocol.
+ *
+ */
+
+/**
+ * @defgroup LWM2M LWM2M
+ * @ingroup Comms
+ *
+ * @brief Routines that handle LWM2M protocol.
+ *
+ * @{
+ */
+
+/**
+ * @brief Macro that defines the default port for a LWM2M server.
+ */
+#define SOL_LWM2M_DEFAULT_SERVER_PORT (5683)
+
+/**
+ * @struct sol_lwm2m_server
+ * @brief A handle to a LWM2M server.
+ * @see sol_lwm2m_server_new()
+ */
+struct sol_lwm2m_server;
+
+/**
+ * @struct sol_lwm2m_client_info
+ * @brief A handle that contains information about a registered LWM2M client.
+ * @see sol_lwm2m_server_get_clients()
+ */
+struct sol_lwm2m_client_info;
+
+/**
+ * @struct sol_lwm2m_client_object_instance
+ * @brief A handle that contains information about a client object instance.
+ */
+struct sol_lwm2m_client_object_instance;
+
+/**
+ * @struct sol_lwm2m_client_object
+ * @brief A handle of a client's object.
+ * @see sol_lwm2m_client_info_get_objects()
+ */
+struct sol_lwm2m_client_object;
+
+/**
+ * @brief LWM2M Client binding mode.
+ *
+ * A LWM2M server, may support multiple forms of binding.
+ * The binding mode is requested by a client during its registration.
+ *
+ * In Queue binding mode a client flags to the server that it
+ * may not be available for communication all the time, thus
+ * the server must wait until it receives a heartbeat from the
+ * client until it can send requests. The queue binding mode
+ * is usefull, because the client may enter in deep sleep
+ * and save battery and only wake up in certain times.
+ *
+ * @note The default binding mode is #SOL_LWM2M_BINDING_MODE_U and is the only one supported right know.
+ * @see sol_lwm2m_client_info_get_binding_mode()
+ */
+enum sol_lwm2m_binding_mode {
+    /**
+     * Indicates that the client is reacheable all the time
+     * and all the communication must be done using UDP.
+     */
+    SOL_LWM2M_BINDING_MODE_U,
+    /**
+     * Indicate that the client is using Queued UDP binding
+     * and all the communication must be done using UDP.
+     */
+    SOL_LWM2M_BINDING_MODE_UQ,
+    /**
+     * Indicates that the client is reacheable all the time
+     * and all the communication must be done using SMS.
+     */
+    SOL_LWM2M_BINDING_MODE_S,
+    /**
+     * Indicates that the client is using Queued SMS binding
+     * and all the communication must be done using SMS
+     */
+    SOL_LWM2M_BINDING_MODE_SQ,
+    /**
+     * Indicates that the client is using UDP and SMS binding.
+     * When the server sends an UDP request the client must
+     * send the response using UDP.
+     * When the server sends a SMS request the client must
+     * send the response using SMS.
+     */
+    SOL_LWM2M_BINDING_MODE_US,
+    /**
+     * Indicates that the client using Queued SMS and UDP binding.
+     * When the server sends an UDP request the client must
+     * send the response using UDP.
+     * When the server sends a SMS request the client must
+     * send the response using SMS.
+     */
+    SOL_LWM2M_BINDING_MODE_UQS,
+    /**
+     * It was not possible to determine the client binding.
+     */
+    SOL_LWM2M_BINDING_MODE_UNKNOWN = -1,
+};
+
+/**
+ * @brief Enum that express a LWM2M client lifecycle changes.
+ *
+ * @see sol_lwm2m_server_add_registration_monitor()
+ */
+enum sol_lwm2m_registration_event {
+    /**
+     * Indicates that a client was registered in the server.
+     */
+    SOL_LWM2M_REGISTRATION_EVENT_REGISTER,
+    /**
+     * Indicates that a client updated itself in the server.
+     */
+    SOL_LWM2M_REGISTRATION_EVENT_UPDATE,
+    /**
+     * Indicates that a client was unregistered.
+     */
+    SOL_LWM2M_REGISTRATION_EVENT_UNREGISTER,
+    /**
+     * Indicates that the server is discarting a client, since
+     * the server did not hear from it after some time.
+     */
+    SOL_LWM2M_REGISTRATION_EVENT_TIMEOUT
+};
+
+/**
+ * @brief Callback that is used to inform a LWM2M client registration event.
+ *
+ * @param server The LWM2M server.
+ * @param cinfo The client that generated the registration event.
+ * @param event The registration event itself.
+ * @param data User data.
+ * @see #sol_lwm2m_registration_event
+ * @see sol_lwm2m_server_add_registration_monitor()
+ */
+typedef void (*sol_lwm2m_server_registration_event_cb)(void *data,
+    struct sol_lwm2m_server *server,
+    struct sol_lwm2m_client_info *cinfo,
+    enum sol_lwm2m_registration_event event);
+
+/**
+ * @brief Creates a new LWM2M server.
+ *
+ * The server will be immediately operational and waiting for connections.
+ *
+ * @param port The UDP port to be used.
+ * @return The LWM2M server or @c NULL on error.
+ */
+struct sol_lwm2m_server *sol_lwm2m_server_new(uint16_t port);
+
+/**
+ * @brief Adds a registration monitor.
+ *
+ * This function register a monitor, making it easir to observe a LWM2M client's life cycle.
+ * This means that everytime a LWM2M client is registered, updated, deleted or timedout,
+ * @c cb will be called.
+ *
+ * @param server The LWM2M server.
+ * @param cb The previous registered callback.
+ * @param data The user data to @c cb.
+ * @return 0 on success, -errno on error.
+ * @see sol_lwm2m_server_add_registration_monitor()
+ * @see #sol_lwm2m_server_registration_event_cb
+ */
+int sol_lwm2m_server_add_registration_monitor(struct sol_lwm2m_server *server,
+    sol_lwm2m_server_registration_event_cb cb, const void *data);
+
+/**
+ * @brief Removes a registration monitor.
+ *
+ * @param server The LWM2M server.
+ * @param cb The previous registered callback.
+ * @param data The user data to @c cb.
+ * @return 0 on success, -errno on error.
+ * @see sol_lwm2m_server_add_registration_monitor()
+ */
+int sol_lwm2m_server_del_registration_monitor(struct sol_lwm2m_server *server,
+    sol_lwm2m_server_registration_event_cb cb, const void *data);
+
+/**
+ * @brief Gets all registerd clients.
+ *
+ * @param server The LWM2M Server.
+ * @return An vector of #sol_lwm2m_client_info or @c NULL on error.
+ * @note One must not add or remove elements from the returned vector.
+ * @see sol_lwm2m_server_add_registration_monitor()
+ */
+const struct sol_ptr_vector *sol_lwm2m_server_get_clients(const struct sol_lwm2m_server *server);
+
+/**
+ * @brief Deletes a server instance.
+ *
+ * Use this function to stop the LWM2M server and release its resources.
+ *
+ * @param server The LWM2M server to be deleted.
+ * @see sol_lwm2m_server_del()
+ */
+void sol_lwm2m_server_del(struct sol_lwm2m_server *server);
+
+/**
+ * @brief Gets the name of client.
+ *
+ * @param client The LWM2M cliento info.
+ * @return The @c client name or @c NULL on error.
+ */
+const char *sol_lwm2m_client_info_get_name(const struct sol_lwm2m_client_info *client);
+
+/**
+ * @brief Gets the client location path in the LWM2M server.
+ *
+ * This value is specified by the LWM2M server and it will be used by the client
+ * to identify itself.
+ *
+ * @param client The LWM2M client info.
+ * @return The @c client location path or @c NULL on error.
+ */
+const char *sol_lwm2m_client_info_get_location(const struct sol_lwm2m_client_info *client);
+
+/**
+ * @brief Gets the client SMS number.
+ *
+ * A client may specify an SMS number to be used for communication.
+ *
+ * @param client The LWM2M client info.
+ * @return The SMS number or @c NULL.
+ */
+const char *sol_lwm2m_client_info_get_sms(const struct sol_lwm2m_client_info *client);
+
+/**
+ * @brief Gets the client objects path.
+ *
+ * A LWM2M client may specify an alternate objects path.
+ *
+ * @param client The LWM2M client info.
+ * @return The objects path or @c NULL.
+ * @note The objects path may be @c NULL.
+ */
+const char *sol_lwm2m_client_info_get_objects_path(const struct sol_lwm2m_client_info *client);
+
+/**
+ * @brief Gets the client lifetime in seconds.
+ *
+ * @param client The LWM2M client info.
+ * @param lifetime The client lifetime to be set.
+ * @return 0 on success, -errno on error.
+ */
+int sol_lwm2m_client_info_get_lifetime(const struct sol_lwm2m_client_info *client, uint32_t *lifetime);
+
+/**
+ * @brief Gets the client binding mode.
+ *
+ * @param client The LWM2M client info.
+ * @return The client binding mode or #SOL_LWM2M_BINDING_MODE_UNKNOWN on error.
+ */
+enum sol_lwm2m_binding_mode sol_lwm2m_client_info_get_binding_mode(const struct sol_lwm2m_client_info *client);
+
+/**
+ * @brief Gets the client address.
+ *
+ * @param client The LWM2M client info.
+ * @return The @c client address or @c NULL on error.
+ */
+const struct sol_network_link_addr *sol_lwm2m_client_info_get_address(const struct sol_lwm2m_client_info *client);
+
+/**
+ * @brief Get client objects.
+ *
+ * @param client The LWM2M client info.
+ * @return A array of #sol_lwm2m_client_object or @c NULL on error.
+ * @note One must not add or remove elements from the returned vector.
+ * @note Be adviced that it's not recommended to store object
+ * pointers, because during the client's update method, all
+ * the objects are renewed.
+ * @see #sol_lwm2m_client_object
+ */
+const struct sol_ptr_vector *sol_lwm2m_client_info_get_objects(const struct sol_lwm2m_client_info *client);
+
+/**
+ * @brief Gets the object id.
+ *
+ * @param object The LWM2M object to get the id.
+ * @param id The object id to be filled.
+ * @return 0 success, negative errno on error.
+ */
+int sol_lwm2m_client_object_get_id(const struct sol_lwm2m_client_object *object, uint16_t *id);
+
+/**
+ * @brief Gets the instances of a given object.
+ *
+ * @param object The LWM2M object object to get the instances.
+ * @return An array of uint16_t or @c NULL on error.
+ * @note Be adviced that it's not recommended to store object
+ * instances pointers, because they might be deleted by other LWM2M servers,
+ * thus removed from the returned list.
+ */
+const struct sol_ptr_vector *sol_lwm2m_client_object_get_instances(const struct sol_lwm2m_client_object *object);
+
+/**
+ * @}
+ */
+#ifdef __cplusplus
+}
+#endif
diff --git a/src/lib/comms/sol-lwm2m.c b/src/lib/comms/sol-lwm2m.c
new file mode 100644
index 00000000..5671da19
--- /dev/null
+++ b/src/lib/comms/sol-lwm2m.c
@@ -0,0 +1,922 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <alloca.h>
+#include <errno.h>
+#include <float.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#define SOL_LOG_DOMAIN &_lwm2m_domain
+
+#include "sol-log-internal.h"
+#include "sol-util-internal.h"
+#include "sol-list.h"
+#include "sol-lwm2m.h"
+#include "sol-macros.h"
+#include "sol-mainloop.h"
+#include "sol-monitors.h"
+#include "sol-random.h"
+#include "sol-str-slice.h"
+#include "sol-str-table.h"
+#include "sol-util.h"
+
+SOL_LOG_INTERNAL_DECLARE_STATIC(_lwm2m_domain, "lwm2m");
+
+#define LWM2M_UPDATE_QUERY_PARAMS (4)
+#define LWM2M_REGISTER_QUERY_PARAMS (5)
+#define NUMBER_OF_PATH_SEGMENTS (3)
+#define DEFAULT_CLIENT_LIFETIME (86400)
+#define DEFAULT_BINDING_MODE (SOL_LWM2M_BINDING_MODE_U)
+#define DEFAULT_LOCATION_PATH_SIZE (10)
+
+struct sol_lwm2m_server {
+    struct sol_coap_server *coap;
+    struct sol_ptr_vector clients;
+    struct sol_ptr_vector clients_to_delete;
+    struct sol_monitors registration;
+    struct {
+        struct sol_timeout *timeout;
+        uint32_t lifetime;
+    } lifetime_ctx;
+};
+
+struct sol_lwm2m_client_object {
+    struct sol_ptr_vector instances;
+    uint16_t id;
+};
+
+struct sol_lwm2m_client_info {
+    struct sol_ptr_vector objects;
+    char *name;
+    char *location;
+    char *sms;
+    char *objects_path;
+    uint32_t lifetime;
+    time_t register_time;
+    struct sol_lwm2m_server *server;
+    struct sol_network_link_addr cliaddr;
+    enum sol_lwm2m_binding_mode binding;
+    struct sol_coap_resource resource;
+};
+
+static bool lifetime_timeout(void *data);
+
+static void
+dispatch_registration_event(struct sol_lwm2m_server *server,
+    struct sol_lwm2m_client_info *cinfo,
+    enum sol_lwm2m_registration_event event)
+{
+    uint16_t i;
+    struct sol_monitors_entry *m;
+
+    SOL_MONITORS_WALK (&server->registration, m, i)
+        ((sol_lwm2m_server_registration_event_cb)m->cb)((void *)m->data, server,
+            cinfo, event);
+}
+
+static void
+client_objects_clear(struct sol_ptr_vector *objects)
+{
+    uint16_t i, j, *id;
+    struct sol_lwm2m_client_object *object;
+
+    SOL_PTR_VECTOR_FOREACH_IDX (objects, object, i) {
+        SOL_PTR_VECTOR_FOREACH_IDX (&object->instances, id, j)
+            free(id);
+        sol_ptr_vector_clear(&object->instances);
+        free(object);
+    }
+
+    sol_ptr_vector_clear(objects);
+}
+
+static void
+client_info_del(struct sol_lwm2m_client_info *cinfo)
+{
+    free(cinfo->sms);
+    free(cinfo->location);
+    free(cinfo->name);
+    free(cinfo->objects_path);
+    client_objects_clear(&cinfo->objects);
+    free(cinfo);
+}
+
+static enum sol_lwm2m_binding_mode
+get_binding_mode_from_str(const struct sol_str_slice binding)
+{
+    static const struct sol_str_table map[] = {
+        SOL_STR_TABLE_PTR_ITEM("U", SOL_LWM2M_BINDING_MODE_U),
+        //TODO: The modes below are not supported for now.
+        SOL_STR_TABLE_PTR_ITEM("UQ", SOL_LWM2M_BINDING_MODE_UNKNOWN),
+        SOL_STR_TABLE_PTR_ITEM("S", SOL_LWM2M_BINDING_MODE_UNKNOWN),
+        SOL_STR_TABLE_PTR_ITEM("SQ", SOL_LWM2M_BINDING_MODE_UNKNOWN),
+        SOL_STR_TABLE_PTR_ITEM("US", SOL_LWM2M_BINDING_MODE_UNKNOWN),
+        SOL_STR_TABLE_PTR_ITEM("UQS", SOL_LWM2M_BINDING_MODE_UNKNOWN),
+        { }
+    };
+
+    return sol_str_table_lookup_fallback(map, binding,
+        SOL_LWM2M_BINDING_MODE_UNKNOWN);
+}
+
+static void
+clients_to_delete_clear(struct sol_ptr_vector *to_delete)
+{
+    uint16_t i;
+    struct sol_lwm2m_client_info *cinfo;
+
+    SOL_PTR_VECTOR_FOREACH_IDX (to_delete, cinfo, i)
+        client_info_del(cinfo);
+    sol_ptr_vector_clear(to_delete);
+}
+
+static void
+remove_client(struct sol_lwm2m_client_info *cinfo, bool del)
+{
+    int r = 0;
+
+    r = sol_ptr_vector_remove(&cinfo->server->clients, cinfo);
+    if (r < 0)
+        SOL_WRN("Could not remove the client %s from the clients list",
+            cinfo->name);
+    r = sol_coap_server_unregister_resource(cinfo->server->coap,
+        &cinfo->resource);
+    if (r < 0)
+        SOL_WRN("Could not unregister coap resource for the client: %s",
+            cinfo->name);
+    if (del)
+        client_info_del(cinfo);
+    else {
+        r = sol_ptr_vector_append(&cinfo->server->clients_to_delete, cinfo);
+        if (r < 0)
+            SOL_WRN("Could not add the client to pending clients list");
+    }
+}
+
+static struct sol_lwm2m_client_object *
+find_client_object_by_id(struct sol_ptr_vector *objects,
+    uint16_t id)
+{
+    uint16_t i;
+    struct sol_lwm2m_client_object *cobject;
+
+    SOL_PTR_VECTOR_FOREACH_IDX (objects, cobject, i) {
+        if (cobject->id == id)
+            return cobject;
+    }
+
+    return NULL;
+}
+
+static int
+fill_client_objects(struct sol_lwm2m_client_info *cinfo,
+    struct sol_coap_packet *req, bool update)
+{
+    uint8_t *buf;
+    uint16_t len, i;
+    int r;
+    bool has_content;
+    struct sol_vector objects;
+    struct sol_str_slice content, *object;
+    struct sol_lwm2m_client_object *cobject;
+    uint16_t *instance;
+
+#define TO_INT(_data, _endptr, _len, _i, _label) \
+    _i = sol_util_strtol(_data, &_endptr, _len, 10); \
+    if (_endptr == _data || errno != 0 ) { \
+        SOL_WRN("Could not convert object to int. (%.*s)", \
+            SOL_STR_SLICE_PRINT(*object)); \
+        r = -EINVAL; \
+        goto _label; \
+    }
+#define EXIT_IF_FAIL(_condition) \
+    if (_condition) { \
+        r = -EINVAL; \
+        SOL_WRN("Malformed object: %.*s", \
+            SOL_STR_SLICE_PRINT(*object)); \
+        goto err_exit; \
+    }
+
+    has_content = sol_coap_packet_has_payload(req);
+
+    if (!has_content && !update) {
+        SOL_WRN("The registration request has no payload!");
+        return -ENOENT;
+    } else if (!has_content)
+        return 0;
+
+    client_objects_clear(&cinfo->objects);
+
+    r = sol_coap_packet_get_payload(req, &buf, &len);
+    SOL_INT_CHECK(r, < 0, r);
+    content.data = (const char *)buf;
+    content.len = len;
+
+    SOL_DBG("Register payload content: %.*s", (int)len, buf);
+    objects = sol_str_slice_split(content, ",", 0);
+
+    if (!objects.len) {
+        SOL_WRN("The objects list is empty!");
+        return -EINVAL;
+    }
+
+    SOL_VECTOR_FOREACH_IDX (&objects, object, i) {
+        char *endptr;
+        uint16_t id;
+
+        *object = sol_str_slice_trim(*object);
+
+        EXIT_IF_FAIL(object->len < 4 || object->data[0] != '<');
+
+        /*
+           Object form: </ObjectId[/InstanceID]>
+           Where ObjectId is an integer (must be present)
+           InstanceId is an integer, may not be present and can not be UINT16_MAX
+           Alternate path: </a/path>[;rt="oma.lwm2m"][;ct=1058]
+         */
+        if (sol_str_slice_str_contains(*object, "rt=\"oma.lwm2m\"")) {
+            struct sol_str_slice path;
+            endptr = memrchr(object->data, '>', object->len);
+            EXIT_IF_FAIL(!endptr);
+            path.data = object->data + 1;
+            path.len = endptr - path.data;
+            r = sol_util_replace_str_from_slice_if_changed(&cinfo->objects_path,
+                path);
+            SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+            if (cinfo->objects_path && streq(cinfo->objects_path, "/")) {
+                free(cinfo->objects_path);
+                cinfo->objects_path = NULL;
+            }
+            continue;
+        } else if (sol_str_slice_str_contains(*object, "ct=")) {
+            //The content type value for json was not defined yet.
+            //TODO: Support JSON formats.
+            SOL_WRN("Only text format is supported for now");
+            r = -EINVAL;
+            goto err_exit;
+        }
+
+        EXIT_IF_FAIL(object->data[object->len - 1] != '>');
+
+        //Removing '<', '>' and '/'
+        object->data += 2;
+        object->len -= 3;
+
+        TO_INT(object->data, endptr, object->len, id, err_exit);
+
+        cobject = find_client_object_by_id(&cinfo->objects, id);
+
+        if (!cobject) {
+            cobject = malloc(sizeof(struct sol_lwm2m_client_object));
+            r = -ENOMEM;
+            SOL_NULL_CHECK_GOTO(cobject, err_exit);
+            r = sol_ptr_vector_append(&cinfo->objects, cobject);
+            if (r < 0) {
+                SOL_WRN("Could not append the object id:%" PRIu16
+                    " to the object array", id);
+                free(cobject);
+                goto err_exit;
+            }
+            sol_ptr_vector_init(&cobject->instances);
+            cobject->id = id;
+        }
+
+        //Advance to instance ID
+        object->len -= endptr - object->data;
+
+        //Instance ID not provided.
+        if (!object->len)
+            continue;
+
+        //Skip '/'
+        object->data = endptr + 1;
+        object->len--;
+
+        instance = malloc(sizeof(uint16_t));
+        r = -ENOMEM;
+        SOL_NULL_CHECK_GOTO(instance, err_exit);
+
+        TO_INT(object->data, endptr, object->len, *instance,
+            err_instance_to_int);
+
+        if (*instance == UINT16_MAX) {
+            SOL_WRN("The instance id value: %" PRIu16 " must not be used!",
+                UINT16_MAX);
+            r = -EPERM;
+            goto err_instance_to_int;
+        }
+
+        r = sol_ptr_vector_append(&cobject->instances, instance);
+        if (r < 0) {
+            SOL_WRN("Could not append the instance /%" PRIu16 "/%" PRIu16
+                " to the instance array", cobject->id, *instance);
+            goto err_instance_to_int;
+        }
+    }
+
+    sol_vector_clear(&objects);
+    return 0;
+
+err_instance_to_int:
+    free(instance);
+err_exit:
+    sol_vector_clear(&objects);
+    client_objects_clear(&cinfo->objects);
+    return r;
+
+#undef EXIT_IF_FAIL
+#undef TO_INT
+}
+
+static int
+fill_client_info(struct sol_lwm2m_client_info *cinfo,
+    struct sol_coap_packet *req, bool update)
+{
+    uint16_t i, count;
+    bool has_name = false;
+    struct sol_str_slice query[5];
+    int r;
+
+    r = sol_coap_find_options(req, SOL_COAP_OPTION_URI_QUERY, query,
+        update ? LWM2M_UPDATE_QUERY_PARAMS : LWM2M_REGISTER_QUERY_PARAMS);
+    SOL_INT_CHECK(r, < 0, r);
+    count = r;
+    cinfo->register_time = time(NULL);
+
+    for (i = 0; i < count; i++) {
+        struct sol_str_slice key, value;
+        const char *sep;
+
+        SOL_DBG("Query:%.*s", SOL_STR_SLICE_PRINT(query[i]));
+        sep = memchr(query[i].data, '=', query[i].len);
+
+        if (!sep) {
+            SOL_WRN("Could not find the separator '=' at: %.*s",
+                SOL_STR_SLICE_PRINT(query[i]));
+            break;
+        }
+
+        key.data = query[i].data;
+        key.len = sep - query[i].data;
+        value.data = sep + 1;
+        value.len = query[i].len - key.len - 1;
+
+        if (sol_str_slice_str_eq(key, "ep")) {
+            if (update) {
+                SOL_WRN("The lwm2m client can not update it's name"
+                    " during the update");
+                r = -EPERM;
+                goto err_cinfo_prop;
+            }
+            //Required info
+            has_name = true;
+            cinfo->name = sol_str_slice_to_string(value);
+            SOL_NULL_CHECK_GOTO(cinfo->name, err_cinfo_prop);
+        } else if (sol_str_slice_str_eq(key, "lt")) {
+            char *endptr;
+            cinfo->lifetime = sol_util_strtoul(value.data, &endptr,
+                value.len, 10);
+            if (endptr == value.data || errno != 0) {
+                SOL_WRN("Could not convert the lifetime to integer."
+                    " Lifetime: %.*s", SOL_STR_SLICE_PRINT(value));
+                r = -EINVAL;
+                goto err_cinfo_prop;
+            }
+        } else if (sol_str_slice_str_eq(key, "sms")) {
+            r = sol_util_replace_str_from_slice_if_changed(&cinfo->sms, value);
+            SOL_INT_CHECK_GOTO(r, < 0, err_cinfo_prop);
+        } else if (sol_str_slice_str_eq(key, "lwm2m") &&
+            !sol_str_slice_str_eq(value, "1.0")) {
+            r = -EINVAL;
+            SOL_WRN("LWM2M version not supported:%.*s",
+                SOL_STR_SLICE_PRINT(value));
+            goto err_cinfo_prop;
+        } else if (sol_str_slice_str_eq(key, "b")) {
+            cinfo->binding = get_binding_mode_from_str(value);
+            r = -EINVAL;
+            SOL_INT_CHECK_GOTO(cinfo->binding,
+                == SOL_LWM2M_BINDING_MODE_UNKNOWN, err_cinfo_prop);
+        }
+    }
+
+    if (has_name || update)
+        return fill_client_objects(cinfo, req, update);
+    else {
+        SOL_WRN("The client did not provide its name!");
+        return -EINVAL;
+    }
+
+err_cinfo_prop:
+    return r;
+}
+
+static int
+reschedule_timeout(struct sol_lwm2m_server *server)
+{
+    struct sol_lwm2m_client_info *cinfo;
+    uint32_t smallest_remaining, remaining, lf = 0;
+    time_t now;
+    uint16_t i;
+    int r;
+
+    clients_to_delete_clear(&server->clients_to_delete);
+
+    if (server->lifetime_ctx.timeout)
+        sol_timeout_del(server->lifetime_ctx.timeout);
+
+    if (!sol_ptr_vector_get_len(&server->clients)) {
+        server->lifetime_ctx.timeout = NULL;
+        server->lifetime_ctx.lifetime = 0;
+        return 0;
+    }
+
+    smallest_remaining = UINT32_MAX;
+    now = time(NULL);
+    SOL_PTR_VECTOR_FOREACH_IDX (&server->clients, cinfo, i) {
+        remaining = cinfo->lifetime - (now - cinfo->register_time);
+        if (remaining < smallest_remaining) {
+            smallest_remaining = remaining;
+            lf = cinfo->lifetime;
+        }
+    }
+
+    //Set to NULL in case we fail.
+    server->lifetime_ctx.timeout = NULL;
+    /*
+       When a client is registered, it tells the server what is its lifetime.
+       If the server's timeout is registered using the exactly same amount,
+       there's a high chance that the server will end up removing a client from
+       my list, because the message will take some time until it arrives
+       from the network. In order to reduce the change from happening,
+       the server will add 2 seconds to smallest_remaining.
+     */
+    r = sol_util_uint32_mul(smallest_remaining + 2, 1000, &smallest_remaining);
+    SOL_INT_CHECK(r, < 0, r);
+    server->lifetime_ctx.timeout = sol_timeout_add(smallest_remaining,
+        lifetime_timeout, server);
+    SOL_NULL_CHECK(server->lifetime_ctx.timeout, -ENOMEM);
+    server->lifetime_ctx.lifetime = lf;
+    return 0;
+}
+
+static bool
+lifetime_timeout(void *data)
+{
+    struct sol_ptr_vector to_delete = SOL_PTR_VECTOR_INIT;
+    struct sol_lwm2m_server *server = data;
+    struct sol_lwm2m_client_info *cinfo;
+    uint16_t i;
+    int r;
+
+    SOL_DBG("Lifetime timeout! (%" PRIu32 ")", server->lifetime_ctx.lifetime);
+
+    SOL_PTR_VECTOR_FOREACH_IDX (&server->clients, cinfo, i) {
+        if (server->lifetime_ctx.lifetime != cinfo->lifetime)
+            continue;
+        SOL_DBG("Deleting client %s for inactivity", cinfo->name);
+        r = sol_ptr_vector_append(&to_delete, cinfo);
+        SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+    }
+
+    SOL_PTR_VECTOR_FOREACH_IDX (&to_delete, cinfo, i) {
+        dispatch_registration_event(server, cinfo,
+            SOL_LWM2M_REGISTRATION_EVENT_TIMEOUT);
+        remove_client(cinfo, true);
+    }
+
+    sol_ptr_vector_clear(&to_delete);
+
+    r = reschedule_timeout(server);
+    if (r < 0)
+        SOL_WRN("Could not reschedule the lifetime timeout");
+    return false;
+
+err_exit:
+    sol_ptr_vector_clear(&to_delete);
+    return true;
+}
+
+static int
+update_client(struct sol_coap_server *coap,
+    const struct sol_coap_resource *resource,
+    struct sol_coap_packet *req,
+    const struct sol_network_link_addr *cliaddr, void *data)
+{
+    struct sol_lwm2m_client_info *cinfo = data;
+    struct sol_coap_packet *response;
+    int r;
+
+    SOL_DBG("Client update request (name: %s)", cinfo->name);
+
+    response = sol_coap_packet_new(req);
+    SOL_NULL_CHECK(response, -ENOMEM);
+
+    r = fill_client_info(cinfo, req, true);
+    SOL_INT_CHECK_GOTO(r, < 0, err_update);
+
+    r = reschedule_timeout(cinfo->server);
+    SOL_INT_CHECK_GOTO(r, < 0, err_update);
+
+    dispatch_registration_event(cinfo->server, cinfo,
+        SOL_LWM2M_REGISTRATION_EVENT_UPDATE);
+
+    sol_coap_header_set_code(response, SOL_COAP_RSPCODE_CHANGED);
+    return sol_coap_send_packet(coap, response, cliaddr);
+
+err_update:
+    sol_coap_header_set_code(response, SOL_COAP_RSPCODE_BAD_REQUEST);
+    (void)sol_coap_send_packet(coap, response, cliaddr);
+    return r;
+}
+
+static int
+delete_client(struct sol_coap_server *coap,
+    const struct sol_coap_resource *resource,
+    struct sol_coap_packet *req,
+    const struct sol_network_link_addr *cliaddr, void *data)
+{
+    struct sol_lwm2m_client_info *cinfo = data;
+    struct sol_coap_packet *response;
+
+    SOL_DBG("Client delete request (name: %s)", cinfo->name);
+
+    response = sol_coap_packet_new(req);
+    SOL_NULL_CHECK(response, -ENOMEM);
+
+    remove_client(cinfo, false);
+
+    if (!sol_ptr_vector_get_len(&cinfo->server->clients) &&
+        cinfo->server->lifetime_ctx.timeout) {
+        sol_timeout_del(cinfo->server->lifetime_ctx.timeout);
+        cinfo->server->lifetime_ctx.timeout = NULL;
+        cinfo->server->lifetime_ctx.lifetime = 0;
+        SOL_DBG("Client list is empty");
+    }
+
+    dispatch_registration_event(cinfo->server, cinfo,
+        SOL_LWM2M_REGISTRATION_EVENT_UNREGISTER);
+
+    sol_coap_header_set_code(response, SOL_COAP_RSPCODE_DELETED);
+    return sol_coap_send_packet(coap, response, cliaddr);
+}
+
+static int
+generate_location(char **location)
+{
+    int r;
+    char uuid[37];
+
+    r = sol_util_uuid_gen(false, false, uuid);
+    SOL_INT_CHECK(r, < 0, r);
+    *location = strndup(uuid, DEFAULT_LOCATION_PATH_SIZE);
+    SOL_NULL_CHECK(*location, -ENOMEM);
+    return 0;
+}
+
+static int
+new_client_info(struct sol_lwm2m_client_info **cinfo,
+    const struct sol_network_link_addr *cliaddr,
+    struct sol_lwm2m_server *server)
+{
+    int r;
+
+    *cinfo = calloc(1, sizeof(struct sol_lwm2m_client_info) +
+        (sizeof(struct sol_str_slice) * NUMBER_OF_PATH_SEGMENTS));
+    SOL_NULL_CHECK(cinfo, -ENOMEM);
+
+    (*cinfo)->lifetime = DEFAULT_CLIENT_LIFETIME;
+    (*cinfo)->binding = DEFAULT_BINDING_MODE;
+    r = generate_location(&(*cinfo)->location);
+    SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+
+    (*cinfo)->resource.flags = SOL_COAP_FLAGS_NONE;
+    (*cinfo)->resource.path[0] = sol_str_slice_from_str("rd");
+    (*cinfo)->resource.path[1] = sol_str_slice_from_str((*cinfo)->location);
+    (*cinfo)->resource.path[2] = sol_str_slice_from_str("");
+    (*cinfo)->resource.del = delete_client;
+    /*
+       Current spec says that the client update should be handled using
+       the post method, however some old clients still uses put.
+     */
+    (*cinfo)->resource.post = update_client;
+    (*cinfo)->resource.put = update_client;
+    (*cinfo)->server = server;
+    sol_ptr_vector_init(&(*cinfo)->objects);
+    memcpy(&(*cinfo)->cliaddr, cliaddr, sizeof(struct sol_network_link_addr));
+    SOL_SET_API_VERSION((*cinfo)->resource.api_version = SOL_COAP_RESOURCE_API_VERSION; )
+    return 0;
+err_exit:
+    free(*cinfo);
+    return r;
+}
+
+static struct sol_lwm2m_client_info *
+get_client_info_by_name(struct sol_ptr_vector *clients,
+    const char *name)
+{
+    struct sol_lwm2m_client_info *cinfo;
+    uint16_t i;
+
+    SOL_PTR_VECTOR_FOREACH_IDX (clients, cinfo, i) {
+        if (streq(name, cinfo->name))
+            return cinfo;
+    }
+
+    return NULL;
+}
+
+static int
+registration_request(struct sol_coap_server *coap,
+    const struct sol_coap_resource *resource,
+    struct sol_coap_packet *req,
+    const struct sol_network_link_addr *cliaddr, void *data)
+{
+    struct sol_lwm2m_client_info *cinfo, *old_cinfo;
+    struct sol_lwm2m_server *server = data;
+    struct sol_coap_packet *response;
+    int r;
+    bool b;
+
+    SOL_DBG("Client registration request");
+
+    response = sol_coap_packet_new(req);
+    SOL_NULL_CHECK(response, -ENOMEM);
+
+    r = new_client_info(&cinfo, cliaddr, server);
+    SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+
+    r = fill_client_info(cinfo, req, false);
+    SOL_INT_CHECK_GOTO(r, < 0, err_exit_del_client);
+
+    old_cinfo = get_client_info_by_name(&server->clients,
+        cinfo->name);
+    if (old_cinfo) {
+        SOL_DBG("Client %s already exists, replacing it.", old_cinfo->name);
+        remove_client(old_cinfo, true);
+    }
+
+    b = sol_coap_server_register_resource(server->coap, &cinfo->resource,
+        cinfo);
+    if (!b) {
+        SOL_WRN("Could not register the coap resource for client: %s",
+            cinfo->name);
+        goto err_exit_del_client;
+    }
+
+    r = sol_ptr_vector_append(&server->clients, cinfo);
+    SOL_INT_CHECK_GOTO(r, < 0, err_exit_unregister);
+
+    r = reschedule_timeout(server);
+    SOL_INT_CHECK_GOTO(r, < 0, err_exit_unregister);
+
+    r = sol_coap_add_option(response, SOL_COAP_OPTION_LOCATION_PATH,
+        "rd", strlen("rd"));
+    SOL_INT_CHECK_GOTO(r, < 0, err_exit_unregister);
+    r = sol_coap_add_option(response,
+        SOL_COAP_OPTION_LOCATION_PATH, cinfo->location, strlen(cinfo->location));
+    SOL_INT_CHECK_GOTO(r, < 0, err_exit_unregister);
+
+    sol_coap_header_set_code(response, SOL_COAP_RSPCODE_CREATED);
+
+    SOL_DBG("Client %s registered. Location: %s, SMS: %s, binding: %u,"
+        " lifetime: %" PRIu32 " objects paths: %s",
+        cinfo->name, cinfo->location, cinfo->sms,
+        cinfo->binding, cinfo->lifetime, cinfo->objects_path);
+    dispatch_registration_event(server, cinfo,
+        SOL_LWM2M_REGISTRATION_EVENT_REGISTER);
+
+    return sol_coap_send_packet(coap, response, cliaddr);
+
+err_exit_unregister:
+    if (sol_coap_server_unregister_resource(server->coap, &cinfo->resource) < 0)
+        SOL_WRN("Could not unregister resource for client: %s", cinfo->name);
+err_exit_del_client:
+    client_info_del(cinfo);
+err_exit:
+    sol_coap_header_set_code(response, SOL_COAP_RSPCODE_BAD_REQUEST);
+    (void)sol_coap_send_packet(coap, response, cliaddr);
+    return r;
+}
+
+static const struct sol_coap_resource registration_interface = {
+    SOL_SET_API_VERSION(.api_version = SOL_COAP_RESOURCE_API_VERSION, )
+    .post = registration_request,
+    .flags = SOL_COAP_FLAGS_NONE,
+    .path = {
+        SOL_STR_SLICE_LITERAL("rd"),
+        SOL_STR_SLICE_EMPTY
+    }
+};
+SOL_API struct sol_lwm2m_server *
+sol_lwm2m_server_new(uint16_t port)
+{
+    struct sol_lwm2m_server *server;
+    bool b;
+
+    SOL_LOG_INTERNAL_INIT_ONCE;
+
+    server = calloc(1, sizeof(struct sol_lwm2m_server));
+    SOL_NULL_CHECK(server, NULL);
+
+    server->coap = sol_coap_server_new(port);
+    SOL_NULL_CHECK_GOTO(server->coap, err_coap);
+
+    sol_ptr_vector_init(&server->clients);
+    sol_ptr_vector_init(&server->clients_to_delete);
+    sol_monitors_init(&server->registration, NULL);
+    b = sol_coap_server_register_resource(server->coap,
+        &registration_interface, server);
+    if (!b) {
+        SOL_WRN("Could not register the server resources");
+        goto err_register;
+    }
+
+    return server;
+
+err_register:
+    sol_coap_server_unref(server->coap);
+err_coap:
+    free(server);
+    return NULL;
+}
+
+SOL_API void
+sol_lwm2m_server_del(struct sol_lwm2m_server *server)
+{
+    uint16_t i;
+    struct sol_lwm2m_client_info *cinfo;
+
+    SOL_NULL_CHECK(server);
+
+    sol_coap_server_unref(server->coap);
+
+    SOL_PTR_VECTOR_FOREACH_IDX (&server->clients, cinfo, i)
+        client_info_del(cinfo);
+    if (server->lifetime_ctx.timeout)
+        sol_timeout_del(server->lifetime_ctx.timeout);
+
+    clients_to_delete_clear(&server->clients_to_delete);
+    sol_monitors_clear(&server->registration);
+    sol_ptr_vector_clear(&server->clients);
+    free(server);
+}
+
+SOL_API int
+sol_lwm2m_server_add_registration_monitor(struct sol_lwm2m_server *server,
+    sol_lwm2m_server_registration_event_cb cb, const void *data)
+{
+    struct sol_monitors_entry *m;
+
+    SOL_NULL_CHECK(cb, -EINVAL);
+    SOL_NULL_CHECK(server, -EINVAL);
+
+    m = sol_monitors_append(&server->registration,
+        (sol_monitors_cb_t)cb, data);
+    SOL_NULL_CHECK(m, -ENOMEM);
+    return 0;
+}
+
+SOL_API int
+sol_lwm2m_server_del_registration_monitor(struct sol_lwm2m_server *server,
+    sol_lwm2m_server_registration_event_cb cb, const void *data)
+{
+    int i;
+
+    SOL_NULL_CHECK(server, -EINVAL);
+    SOL_NULL_CHECK(cb, -EINVAL);
+
+    i = sol_monitors_find(&server->registration, (sol_monitors_cb_t)cb, data);
+    if (i < 0)
+        return i;
+
+    return sol_monitors_del(&server->registration, i);
+}
+
+SOL_API const struct sol_ptr_vector *
+sol_lwm2m_server_get_clients(const struct sol_lwm2m_server *server)
+{
+    SOL_NULL_CHECK(server, NULL);
+
+    return &server->clients;
+}
+
+SOL_API const char *
+sol_lwm2m_client_info_get_name(const struct sol_lwm2m_client_info *client)
+{
+    SOL_NULL_CHECK(client, NULL);
+
+    return client->name;
+}
+
+SOL_API const char *
+sol_lwm2m_client_info_get_location(const struct sol_lwm2m_client_info *client)
+{
+    SOL_NULL_CHECK(client, NULL);
+
+    return client->location;
+}
+
+SOL_API const char *
+sol_lwm2m_client_info_get_sms(const struct sol_lwm2m_client_info *client)
+{
+    SOL_NULL_CHECK(client, NULL);
+
+    return client->sms;
+}
+
+SOL_API const char *
+sol_lwm2m_client_info_get_objects_path(
+    const struct sol_lwm2m_client_info *client)
+{
+    SOL_NULL_CHECK(client, NULL);
+
+    return client->objects_path;
+}
+
+SOL_API int
+sol_lwm2m_client_info_get_lifetime(const struct sol_lwm2m_client_info *client,
+    uint32_t *lifetime)
+{
+    SOL_NULL_CHECK(client, -EINVAL);
+    SOL_NULL_CHECK(lifetime, -EINVAL);
+
+    *lifetime = client->lifetime;
+    return 0;
+}
+
+SOL_API enum sol_lwm2m_binding_mode
+sol_lwm2m_client_info_get_binding_mode(
+    const struct sol_lwm2m_client_info *client)
+{
+    SOL_NULL_CHECK(client, SOL_LWM2M_BINDING_MODE_UNKNOWN);
+
+    return client->binding;
+}
+
+SOL_API const struct sol_network_link_addr *
+sol_lwm2m_client_info_get_address(const struct sol_lwm2m_client_info *client)
+{
+    SOL_NULL_CHECK(client, NULL);
+
+    return &client->cliaddr;
+}
+
+SOL_API const struct sol_ptr_vector *
+sol_lwm2m_client_info_get_objects(const struct sol_lwm2m_client_info *client)
+{
+    SOL_NULL_CHECK(client, NULL);
+
+    return &client->objects;
+}
+
+SOL_API int
+sol_lwm2m_client_object_get_id(const struct sol_lwm2m_client_object *object,
+    uint16_t *id)
+{
+    SOL_NULL_CHECK(object, -EINVAL);
+    SOL_NULL_CHECK(id, -EINVAL);
+
+    *id = object->id;
+    return 0;
+}
+
+SOL_API const struct sol_ptr_vector *
+sol_lwm2m_client_object_get_instances(
+    const struct sol_lwm2m_client_object *object)
+{
+    SOL_NULL_CHECK(object, NULL);
+
+    return &object->instances;
+}
+