"2015-11-10 18:45:06 -0200"
diff --git a/src/lib/comms/include/sol-http.h b/src/lib/comms/include/sol-http.h
index 7f6fec9a..d7acb78d 100644
--- a/src/lib/comms/include/sol-http.h
+++ b/src/lib/comms/include/sol-http.h
@@ -135,7 +135,18 @@ struct sol_http_response {
     int response_code;
 };
 
-#define SOL_HTTP_RESPONSE_CHECK_API(response_, ...) \
+struct sol_http_url {
+    struct sol_str_slice scheme;
+    struct sol_str_slice user;
+    struct sol_str_slice password;
+    struct sol_str_slice host;
+    struct sol_str_slice path;
+    struct sol_str_slice query;
+    struct sol_str_slice fragment;
+    uint32_t port; //If == 0 ignore
+};
+
+#define SOL_HTTP_RESPONSE_CHECK_API(response_, ...)  \
     do { \
         if (unlikely(!response_)) { \
             SOL_WRN("Error while reaching service."); \
@@ -242,7 +253,107 @@ bool sol_http_param_add(struct sol_http_param *params,
 bool sol_http_param_add_copy(struct sol_http_param *params, struct sol_http_param_value value);
 void sol_http_param_free(struct sol_http_param *params);
 
-int sol_http_escape_string(char **escaped, const char *value);
+/**
+ * Encodes an URL string.
+ *
+ * If the string was not encoded this function will simple copy
+ * the slices content to the buffer and set @c SOL_BUFFER_FLAGS_MEMORY_NOT_OWNE.D
+ *
+ * @param buf The buffer that will hold the encoded string.
+ * @param value A slice to be encoded.
+ *
+ * @return 0 on success, negative number on error.
+ */
+int sol_http_encode_slice(struct sol_buffer *buf, const struct sol_str_slice value);
+
+/**
+ * Decodes an URL string.
+ *
+ * If the string was not decoded this function will simple copy
+ * the slices contents to the buffer and set @c SOL_BUFFER_FLAGS_MEMORY_NOT_OWNED.
+ *
+ * @param buf The buffer that will hold the decoded string.
+ * @param value A slice to be decoded.
+ *
+ * @return 0 on success, negative number on error.
+ */
+int sol_http_decode_slice(struct sol_buffer *buf, const struct sol_str_slice value);
+
+/**
+ *  Creates an URI based on struct sol_http_url and its params
+ *
+ * @param url_out The created URI - it should be freed using free().
+ * @param url The url parameters.
+ * @param params The query and cookies params.
+ *
+ * @return 0 on success, negative number on error.
+ */
+int sol_http_create_uri(char **uri_out, const struct sol_http_url url, const struct sol_http_param *params);
+
+/**
+ * A simpler version of sol_http_create_uri().
+ *
+ *
+ * @param uri The created URI - it should be freed using free().
+ * @param base_uri The base uri to be used.
+ * @param params The query and cookies params.
+ *
+ * @return 0 on success, negative number on error.
+ */
+int sol_http_create_simple_uri(char **uri, const struct sol_str_slice base_uri, const struct sol_http_param *params);
+
+/**
+ * Encodes http parameters of a given type.
+ *
+ * @param buf Where the encoded parameters will be stored as string.
+ * @param type The parameter that should be encoded.
+ * @param params The parameters to be encoded.
+ *
+ * @return 0 on success, negative number on error.
+ *
+ * @note The buf must be initialized in order to use this function.
+ */
+int sol_http_encode_params(struct sol_buffer *buf, enum sol_http_param_type type, const struct sol_http_param *params);
+
+/**
+ * Decodes http parameters of a given type.
+ *
+ * @param buf Where the decoded parameters will be stored as string.
+ * @param type The parameter that should be decoded.
+ * @param params The parameters to be decoded.
+ *
+ * @return 0 on success, negative number on error.
+ */
+int sol_http_decode_params(const struct sol_str_slice params_slice, enum sol_http_param_type type, struct sol_http_param *params);
+
+/**
+ * Split an URI.
+ *
+ * This function will receive a complete URI and split and store its values in the sol_http_url struct.
+ *
+ * @param full_uri An URI to be splitted.
+ * @param url Where the URL parts will be stored.
+ *
+ *
+ * @return 0 on success, negative number on error.
+ * @note This function will not decoded the URI.
+ */
+int sol_http_split_uri(const struct sol_str_slice full_uri, struct sol_http_url *url);
+
+/**
+ * An wrapper of over sol_http_create_simple_uri()
+ *
+ * @param uri The created URI - it should be freed using free().
+ * @param base_uri The base uri to be used.
+ * @param params The query and cookies params.
+ *
+ * @return 0 on success, negative number on error.
+ */
+static inline int
+sol_http_create_simple_uri_from_str(char **uri, const char *base_url, const struct sol_http_param *params)
+{
+    return sol_http_create_simple_uri(uri, sol_str_slice_from_str(base_url ? base_url : ""), params);
+}
 
 /**
  * @}
diff --git a/src/lib/comms/sol-http-client-impl-curl.c b/src/lib/comms/sol-http-client-impl-curl.c
index 8706bbcf..04b0ca64 100644
--- a/src/lib/comms/sol-http-client-impl-curl.c
+++ b/src/lib/comms/sol-http-client-impl-curl.c
@@ -543,101 +543,6 @@ free_buffer:
     return NULL;
 }
 
-static char *
-encode_key_values(CURL *curl, enum sol_http_param_type type,
-    const struct sol_http_param *params, char *initial_value)
-{
-    struct sol_http_param_value *iter;
-    uint16_t idx;
-    bool first = true;
-
-    if (type != SOL_HTTP_PARAM_QUERY_PARAM &&
-        type != SOL_HTTP_PARAM_POST_FIELD &&
-        type != SOL_HTTP_PARAM_COOKIE) {
-        free(initial_value);
-        errno = EINVAL;
-        return NULL;
-    }
-
-    SOL_VECTOR_FOREACH_IDX (&params->params, iter, idx) {
-        struct sol_str_slice key = iter->value.key_value.key;
-        struct sol_str_slice value = iter->value.key_value.value;
-        char *tmp, *encoded_key, *encoded_value;
-        int r;
-
-        if (iter->type != type)
-            continue;
-
-        encoded_key = curl_easy_escape(curl, key.data, key.len);
-        if (!encoded_key)
-            goto cleanup;
-        encoded_value = curl_easy_escape(curl, value.data, value.len);
-        if (!encoded_value) {
-            curl_free(encoded_key);
-            goto cleanup;
-        }
-
-        if (type == SOL_HTTP_PARAM_COOKIE) {
-            r = asprintf(&tmp, "%s%s%s=%s;", initial_value, first ? "" : " ",
-                encoded_key, encoded_value);
-        } else {
-            r = asprintf(&tmp, "%s%s%s=%s", initial_value, first ? "" : "&",
-                encoded_key, encoded_value);
-        }
-
-        curl_free(encoded_key);
-        curl_free(encoded_value);
-
-        if (r < 0)
-            goto cleanup;
-
-        free(initial_value);
-        initial_value = tmp;
-        first = false;
-    }
-
-    return initial_value;
-
-cleanup:
-    free(initial_value);
-    errno = ENOMEM;
-    return NULL;
-}
-
-static char *
-build_uri(CURL *curl, const char *base, const struct sol_http_param *params)
-{
-    char *initial_value;
-    char *built_uri;
-
-    if (asprintf(&initial_value, "%s?", base) < 0) {
-        errno = ENOMEM;
-        return NULL;
-    }
-
-    built_uri = encode_key_values(curl, SOL_HTTP_PARAM_QUERY_PARAM, params,
-        initial_value);
-    if (built_uri == initial_value) {
-        free(initial_value);
-        return strdup(base);
-    }
-
-    return built_uri;
-}
-
-static char *
-build_cookies(CURL *curl, const struct sol_http_param *params)
-{
-    return encode_key_values(curl, SOL_HTTP_PARAM_COOKIE, params, strdup(""));
-}
-
-static char *
-build_post_fields(CURL *curl, const struct sol_http_param *params)
-{
-    return encode_key_values(curl, SOL_HTTP_PARAM_POST_FIELD, params,
-        strdup(""));
-}
-
 static bool
 set_headers_from_params(CURL *curl, struct sol_arena *arena,
     const struct sol_http_param *params, struct curl_slist **headers)
@@ -743,23 +648,43 @@ set_string_option(CURL *curl, CURLoption option, struct sol_arena *arena,
 }
 
 static bool
-set_cookies_from_params(CURL *curl, struct sol_arena *arena,
-    const struct sol_http_param *params)
+set_string_slice_option(CURL *curl, CURLoption option, struct sol_arena *arena,
+    const struct sol_str_slice slice)
 {
-    char *cookies = build_cookies(curl, params);
+    char *tmp;
 
-    if (cookies && !*cookies) {
-        free(cookies);
+    if (!slice.len)
         return true;
-    }
-    return set_string_option(curl, CURLOPT_COOKIE, arena, cookies);
+    tmp = sol_arena_strdup_slice(arena, slice);
+    SOL_NULL_CHECK(tmp, false);
+    return curl_easy_setopt(curl, option, tmp) == CURLE_OK;
+}
+
+static bool
+set_cookies_from_params(CURL *curl, struct sol_arena *arena,
+    const struct sol_http_param *params)
+{
+    struct sol_buffer buf = SOL_BUFFER_INIT_EMPTY;
+    bool r;
+    int err;
+
+    err = sol_http_encode_params(&buf, SOL_HTTP_PARAM_COOKIE, params);
+    SOL_INT_CHECK(err, < 0, false);
+    r = set_string_slice_option(curl, CURLOPT_COOKIE, arena,
+        sol_buffer_get_slice(&buf));
+    sol_buffer_fini(&buf);
+    return r;
 }
 
 static bool
 set_uri_from_params(CURL *curl, struct sol_arena *arena, const char *base,
     const struct sol_http_param *params)
 {
-    char *full_uri = build_uri(curl, base, params);
+    char *full_uri;
+    int r;
+
+    r = sol_http_create_simple_uri_from_str(&full_uri, base, params);
+    SOL_INT_CHECK(r, < 0, false);
 
     return set_string_option(curl, CURLOPT_URL, arena, full_uri);
 }
@@ -768,9 +693,24 @@ static bool
 set_post_fields_from_params(CURL *curl, struct sol_arena *arena,
     const struct sol_http_param *params)
 {
-    char *post = build_post_fields(curl, params);
-
-    return set_string_option(curl, CURLOPT_POSTFIELDS, arena, post);
+    struct sol_buffer buf = SOL_BUFFER_INIT_EMPTY;
+    int err;
+    bool r;
+
+    err = sol_http_encode_params(&buf, SOL_HTTP_PARAM_POST_FIELD, params);
+    SOL_INT_CHECK(err, < 0, false);
+
+    if (!buf.used) {
+        if (curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, 0) != CURLE_OK ||
+            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, "") != CURLE_OK)
+            r = false;
+        else
+            r = true;
+    } else
+        r = set_string_slice_option(curl, CURLOPT_POSTFIELDS, arena,
+            sol_buffer_get_slice(&buf));
+    sol_buffer_fini(&buf);
+    return r;
 }
 
 static bool
@@ -781,14 +721,13 @@ set_post_data_from_params(CURL *curl, struct sol_arena *arena,
     struct sol_http_param_value *iter;
     uint16_t idx;
     char *tmp;
-    bool type_set = false;
+    bool type_set, has_post_fields, hast_post_data;
 
+    type_set = has_post_fields = hast_post_data = false;
     SOL_VECTOR_FOREACH_IDX (&params->params, iter, idx) {
         struct sol_str_slice value = SOL_STR_SLICE_EMPTY;
         if (iter->type == SOL_HTTP_PARAM_POST_FIELD) {
-            SOL_WRN("SOL_HTTP_PARAM_POST_FIELD and SOL_HTTP_PARAM_POST_DATA found in parameters."
-                " Only one can be used at a time");
-            return false;
+            has_post_fields = true;
         } else if (iter->type == SOL_HTTP_PARAM_HEADER) {
             struct sol_str_slice key = iter->value.key_value.key;
             type_set = type_set || sol_str_slice_str_caseeq(key, "content-type");
@@ -800,12 +739,22 @@ set_post_data_from_params(CURL *curl, struct sol_arena *arena,
             }
 
             data = value;
+            hast_post_data = true;
         }
     }
 
-    if (data.len == 0)
+    if (!hast_post_data)
+        return true;
+
+    if (hast_post_data && data.len == 0)
         return false;
 
+    if (has_post_fields && hast_post_data) {
+        SOL_WRN("SOL_HTTP_PARAM_POST_FIELD and SOL_HTTP_PARAM_POST_DATA found in parameters."
+            " Only one can be used at a time");
+        return false;
+    }
+
     if (!type_set)
         SOL_WRN("POST request has data but no content-type was set");
 
@@ -934,7 +883,7 @@ sol_http_client_request(enum sol_http_method method,
     }
 
     if (method == SOL_HTTP_METHOD_POST) {
-        if (!set_post_fields_from_params(curl, arena, params) &&
+        if (!set_post_fields_from_params(curl, arena, params) ||
             !set_post_data_from_params(curl, arena, params)) {
             SOL_WRN("Could not set POST fields or data from params");
             goto invalid_option;
diff --git a/src/lib/comms/sol-http-common.c b/src/lib/comms/sol-http-common.c
index 946768b4..c7375587 100644
--- a/src/lib/comms/sol-http-common.c
+++ b/src/lib/comms/sol-http-common.c
@@ -33,6 +33,7 @@
 #include <errno.h>
 #include <stdio.h>
 #include <string.h>
+#include <inttypes.h>
 
 #include "sol-http.h"
 #include "sol-log.h"
@@ -147,49 +148,624 @@ sol_http_param_free(struct sol_http_param *params)
 }
 
 SOL_API int
-sol_http_escape_string(char **escaped, const char *value)
+sol_http_encode_slice(struct sol_buffer *buf, const struct sol_str_slice value)
 {
     int r;
-    size_t value_len;
-    struct sol_buffer buf = SOL_BUFFER_INIT_EMPTY;
-
-    SOL_NULL_CHECK(value, -EINVAL);
-    SOL_NULL_CHECK(escaped, -EINVAL);
-
-    value_len = strlen(value);
-
-    while (value_len--) {
-        unsigned char c = *value;
-        switch (c) {
-        case '0': case '1': case '2': case '3': case '4':
-        case '5': case '6': case '7': case '8': case '9':
-        case 'a': case 'b': case 'c': case 'd': case 'e':
-        case 'f': case 'g': case 'h': case 'i': case 'j':
-        case 'k': case 'l': case 'm': case 'n': case 'o':
-        case 'p': case 'q': case 'r': case 's': case 't':
-        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':
-        case 'A': case 'B': case 'C': case 'D': case 'E':
-        case 'F': case 'G': case 'H': case 'I': case 'J':
-        case 'K': case 'L': case 'M': case 'N': case 'O':
-        case 'P': case 'Q': case 'R': case 'S': case 'T':
-        case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z':
-        case '_': case '~': case '.': case '-':
-            r = sol_buffer_append_char(&buf, c);
-            SOL_INT_CHECK_GOTO(r, < 0, end);
-            break;
-        default:
-            r = sol_buffer_append_printf(&buf, "%%%02X", c);
-            SOL_INT_CHECK_GOTO(r, < 0, end);
+    size_t i, last_append;
+
+    SOL_NULL_CHECK(buf, -EINVAL);
+
+    sol_buffer_init(buf);
+    last_append = 0;
+    for (i = 0; i < value.len; i++) {
+        unsigned char c = value.data[i];
+        if (!isalnum(c) && c != '_' && c != '~' && c != '.' && c != '-') {
+            r = sol_buffer_append_slice(buf,
+                SOL_STR_SLICE_STR(value.data + last_append, i - last_append));
+            SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+            last_append = i + 1;
+            r = sol_buffer_append_printf(buf, "%%%02X", c);
+            SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+        }
+    }
+
+    if (!last_append) {
+        sol_buffer_init_flags(buf, (char *)value.data, value.len,
+            SOL_BUFFER_FLAGS_MEMORY_NOT_OWNED);
+        buf->used = buf->capacity;
+    } else if (last_append != value.len) {
+        r = sol_buffer_append_slice(buf,
+            SOL_STR_SLICE_STR(value.data + last_append,
+            value.len - last_append));
+        SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+    }
+
+    return 0;
+
+err_exit:
+    sol_buffer_fini(buf);
+    return r;
+}
+
+SOL_API int
+sol_http_decode_slice(struct sol_buffer *buf,
+    const struct sol_str_slice value)
+{
+    size_t i, last_append;
+    int r;
+
+    SOL_NULL_CHECK(buf, -EINVAL);
+
+    sol_buffer_init(buf);
+    last_append = 0;
+
+    for (i = 0; i < value.len; i++) {
+        unsigned char c = value.data[i];
+        if (c == '%' && value.len - i > 2 && isxdigit(value.data[i + 1])
+            && isxdigit(value.data[i + 2])) {
+            struct sol_str_slice hex;
+            ssize_t err;
+            char chex;
+
+            hex.data = value.data + i + 1;
+            hex.len = 2;
+            err = sol_util_base16_decode(&chex, 1, hex,
+                SOL_DECODE_BOTH);
+            SOL_INT_CHECK_GOTO(err, < 0, err_exit);
+
+            r = sol_buffer_append_slice(buf,
+                SOL_STR_SLICE_STR(value.data + last_append, i - last_append));
+            SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+            i += 2;
+            last_append = i + 1;
+            r = sol_buffer_append_char(buf, chex);
+            SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+        }
+    }
+
+    if (!last_append) {
+        sol_buffer_init_flags(buf, (char *)value.data, value.len,
+            SOL_BUFFER_FLAGS_MEMORY_NOT_OWNED);
+        buf->used = buf->capacity;
+    } else if (last_append != value.len) {
+        r = sol_buffer_append_slice(buf,
+            SOL_STR_SLICE_STR(value.data + last_append,
+            value.len - last_append));
+        SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+    }
+
+    return 0;
+err_exit:
+    sol_buffer_fini(buf);
+    return r;
+}
+
+SOL_API int
+sol_http_encode_params(struct sol_buffer *buf, enum sol_http_param_type type,
+    const struct sol_http_param *params)
+{
+    const char *prefix, *suffix;
+    struct sol_buffer encoded_key, encoded_value;
+    struct sol_http_param_value *iter;
+    uint16_t idx;
+    bool first = true;
+    int r;
+
+    SOL_NULL_CHECK(buf, -EINVAL);
+    SOL_NULL_CHECK(params, -EINVAL);
+
+    if (type != SOL_HTTP_PARAM_QUERY_PARAM &&
+        type != SOL_HTTP_PARAM_POST_FIELD &&
+        type != SOL_HTTP_PARAM_COOKIE &&
+        type != SOL_HTTP_PARAM_HEADER) {
+        SOL_WRN("The type %u is not supported", type);
+        return -EINVAL;
+    }
+
+    if (type == SOL_HTTP_PARAM_COOKIE) {
+        prefix = " ";
+        suffix = ";";
+    } else {
+        prefix = "&";
+        suffix = "";
+    }
+
+    SOL_HTTP_PARAM_FOREACH_IDX (params, iter, idx) {
+        if (iter->type != type)
+            continue;
+
+        r = sol_http_encode_slice(&encoded_key, iter->value.key_value.key);
+        SOL_INT_CHECK_GOTO(r, < 0, clean_up);
+
+        r = sol_http_encode_slice(&encoded_value, iter->value.key_value.value);
+        SOL_INT_CHECK_GOTO(r, < 0, clean_up);
+
+        if (iter->value.key_value.value.len) {
+            r = sol_buffer_append_printf(buf, "%s%.*s=%.*s%s",
+                first ? "" : prefix,
+                SOL_STR_SLICE_PRINT(sol_buffer_get_slice(&encoded_key)),
+                SOL_STR_SLICE_PRINT(sol_buffer_get_slice(&encoded_value)),
+                suffix);
+        } else {
+            r = sol_buffer_append_printf(buf, "%s%.*s%s",
+                first ? "" : prefix,
+                SOL_STR_SLICE_PRINT(sol_buffer_get_slice(&encoded_key)),
+                suffix);
+        }
+
+        SOL_INT_CHECK_GOTO(r, < 0, clean_up);
+
+        first = false;
+        sol_buffer_fini(&encoded_key);
+        sol_buffer_fini(&encoded_value);
+    }
+
+    return 0;
+
+clean_up:
+    sol_buffer_fini(&encoded_key);
+    sol_buffer_fini(&encoded_value);
+    return r;
+}
+
+SOL_API int
+sol_http_decode_params(const struct sol_str_slice params_slice,
+    enum sol_http_param_type type, struct sol_http_param *params)
+{
+    struct sol_buffer decoded_key, decoded_value;
+    struct sol_str_slice *token;
+    struct sol_vector tokens;
+    const char *param_sep;
+    char *sep;
+    uint16_t i;
+    int r = 0;
+
+    SOL_NULL_CHECK(params, -EINVAL);
+
+    if (type != SOL_HTTP_PARAM_QUERY_PARAM &&
+        type != SOL_HTTP_PARAM_POST_FIELD &&
+        type != SOL_HTTP_PARAM_COOKIE &&
+        type != SOL_HTTP_PARAM_HEADER) {
+        SOL_WRN("The type %u is not supported", type);
+        return -EINVAL;
+    }
+
+    if (!params_slice.len)
+        return 0;
+
+    if (type == SOL_HTTP_PARAM_COOKIE)
+        param_sep = ";";
+    else
+        param_sep = "&";
+
+    tokens = sol_util_str_split(params_slice, param_sep, 0);
+    SOL_VECTOR_FOREACH_IDX (&tokens, token, i) {
+        struct sol_http_param_value param;
+        sep = memchr(token->data, '=', token->len);
+
+        param.value.key_value.key.data = token->data;
+        if (sep) {
+            param.value.key_value.key.len = sep - token->data;
+
+            param.value.key_value.value.data = sep + 1;
+            param.value.key_value.value.len = token->len -
+                param.value.key_value.key.len - 1;
+        } else {
+            param.value.key_value.key.len = token->len;
+            param.value.key_value.value.data = NULL;
+            param.value.key_value.value.len = 0;
+        }
+
+        r = sol_http_decode_slice(&decoded_key, param.value.key_value.key);
+        SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+        r = sol_http_decode_slice(&decoded_value, param.value.key_value.value);
+        SOL_INT_CHECK_GOTO(r, < 0, err_exit);
+
+        param.value.key_value.key = sol_buffer_get_slice(&decoded_key);
+        param.value.key_value.value = sol_buffer_get_slice(&decoded_value);
+        SOL_DBG("Query key: %.*s Query value: %.*s",
+            SOL_STR_SLICE_PRINT(param.value.key_value.key),
+            SOL_STR_SLICE_PRINT(param.value.key_value.value));
+
+        param.type = type;
+
+        if (!sol_http_param_add_copy(params, param)) {
+            SOL_WRN("Could not alloc the param %.*s : %.*s",
+                SOL_STR_SLICE_PRINT(param.value.key_value.key),
+                SOL_STR_SLICE_PRINT(param.value.key_value.value));
+            r = -ENOMEM;
+            goto err_exit;
+        }
+
+        sol_buffer_fini(&decoded_key);
+        sol_buffer_fini(&decoded_value);
+    }
+
+    sol_vector_clear(&tokens);
+    return r;
+
+err_exit:
+    sol_buffer_fini(&decoded_key);
+    sol_buffer_fini(&decoded_value);
+    sol_vector_clear(&tokens);
+    return r;
+}
+
+SOL_API int
+sol_http_create_uri(char **uri_out, const struct sol_http_url url,
+    const struct sol_http_param *params)
+{
+    struct sol_str_slice scheme;
+    struct sol_buffer buf, buf_encoded;
+    int r;
+
+    SOL_NULL_CHECK(uri_out, -EINVAL);
+
+    sol_buffer_init(&buf);
+
+    if (url.scheme.len)
+        scheme = url.scheme;
+    else
+        scheme = sol_str_slice_from_str("http");
+
+    r = sol_buffer_append_slice(&buf, scheme);
+    SOL_INT_CHECK_GOTO(r, < 0, exit);
+
+    r = sol_buffer_append_char(&buf, ':');
+    SOL_INT_CHECK_GOTO(r, < 0, exit);
+
+    if (url.host.len > 0) {
+        r = sol_buffer_append_slice(&buf, sol_str_slice_from_str("//"));
+        SOL_INT_CHECK_GOTO(r, < 0, exit);
+
+        if (url.user.len > 0) {
+            r = sol_http_encode_slice(&buf_encoded, url.user);
+            SOL_INT_CHECK_GOTO(r, < 0, exit);
+            r = sol_buffer_append_slice(&buf,
+                sol_buffer_get_slice(&buf_encoded));
+            sol_buffer_fini(&buf_encoded);
+            SOL_INT_CHECK_GOTO(r, < 0, exit);
+            if (url.password.len > 0) {
+                r = sol_buffer_append_char(&buf, ':');
+                SOL_INT_CHECK_GOTO(r, < 0, exit);
+                r = sol_http_encode_slice(&buf_encoded, url.password);
+                SOL_INT_CHECK_GOTO(r, < 0, exit);
+                r = sol_buffer_append_slice(&buf,
+                    sol_buffer_get_slice(&buf_encoded));
+                sol_buffer_fini(&buf_encoded);
+                SOL_INT_CHECK_GOTO(r, < 0, exit);
+            }
+            r = sol_buffer_append_char(&buf, '@');
+            SOL_INT_CHECK_GOTO(r, < 0, exit);
+        }
+
+        r = sol_buffer_append_slice(&buf, url.host);
+        SOL_INT_CHECK_GOTO(r, < 0, exit);
+
+        if (url.port > 0) {
+            r = sol_buffer_append_printf(&buf, ":%" PRIu32, url.port);
+            SOL_INT_CHECK_GOTO(r, < 0, exit);
+        }
+    }
+
+    r = sol_buffer_append_slice(&buf, url.path);
+    SOL_INT_CHECK_GOTO(r, < 0, exit);
+
+    if (params && params->params.len) {
+        size_t used;
+        r = sol_buffer_append_char(&buf, '?');
+        SOL_INT_CHECK_GOTO(r, < 0, exit);
+        used = buf.used;
+        r = sol_http_encode_params(&buf, SOL_HTTP_PARAM_QUERY_PARAM,
+            params);
+        SOL_INT_CHECK_GOTO(r, < 0, exit);
+        if (used == buf.used) {
+            sol_buffer_resize(&buf, used - 1);
+            SOL_INT_CHECK_GOTO(r, < 0, exit);
+        }
+    }
+
+    if (url.fragment.len) {
+        r = sol_buffer_append_char(&buf, '#');
+        SOL_INT_CHECK_GOTO(r, < 0, exit);
+        r = sol_buffer_append_slice(&buf, url.fragment);
+        SOL_INT_CHECK_GOTO(r, < 0, exit);
+    }
+
+    r = sol_buffer_ensure_nul_byte(&buf);
+    SOL_INT_CHECK_GOTO(r, < 0, exit);
+
+    *uri_out = sol_buffer_steal(&buf, NULL);
+
+    if (!*uri_out)
+        r = -ENOMEM;
+
+exit:
+    sol_buffer_fini(&buf);
+    return r;
+}
+
+SOL_API int
+sol_http_create_simple_uri(char **uri, const struct sol_str_slice base_uri,
+    const struct sol_http_param *params)
+{
+    struct sol_buffer buf;
+    int r;
+
+    SOL_NULL_CHECK(uri, -EINVAL);
+    if (base_uri.len == 0) {
+        SOL_WRN("base_url is empty!");
+        return -EINVAL;
+    }
+
+    sol_buffer_init(&buf);
+
+    r = sol_buffer_append_slice(&buf, base_uri);
+    SOL_INT_CHECK_GOTO(r, < 0, exit);
+
+    if (params && params->params.len) {
+        size_t used;
+        r = sol_buffer_append_char(&buf, '?');
+        SOL_INT_CHECK_GOTO(r, < 0, exit);
+        used = buf.used;
+        r = sol_http_encode_params(&buf, SOL_HTTP_PARAM_QUERY_PARAM,
+            params);
+        SOL_INT_CHECK_GOTO(r, < 0, exit);
+        if (used == buf.used) {
+            r = sol_buffer_resize(&buf, used - 1);
+            SOL_INT_CHECK_GOTO(r, < 0, exit);
         }
-        value++;
     }
 
     r = sol_buffer_ensure_nul_byte(&buf);
-    SOL_INT_CHECK_GOTO(r, < 0, end);
+    SOL_INT_CHECK_GOTO(r, < 0, exit);
+
+    *uri = sol_buffer_steal(&buf, NULL);
 
-    *escaped = sol_buffer_steal(&buf, NULL);
+    if (!*uri)
+        r = -ENOMEM;
 
-end:
+exit:
     sol_buffer_fini(&buf);
     return r;
 }
+
+static void
+_update_partial_uri(struct sol_str_slice *partial_uri, size_t offset)
+{
+    partial_uri->data = partial_uri->data + offset;
+    partial_uri->len = partial_uri->len - offset;
+}
+
+static int
+_get_scheme(const struct sol_str_slice uri,
+    struct sol_str_slice *next,
+    struct sol_str_slice *scheme)
+{
+    char *sep;
+
+    scheme->data = uri.data;
+
+    sep = memchr(uri.data, ':', uri.len);
+
+    if (!sep) {
+        SOL_WRN("Could not find the scheme seperator (:) at URI:%.*s",
+            SOL_STR_SLICE_PRINT(uri));
+        return -EINVAL;
+    }
+
+    scheme->len = sep - scheme->data;
+
+    if (!scheme->len) {
+        SOL_WRN("Empty scheme. URI: %.*s", SOL_STR_SLICE_PRINT(uri));
+        return -EINVAL;
+    }
+
+    SOL_DBG("URI Scheme: %.*s", SOL_STR_SLICE_PRINT(*scheme));
+    _update_partial_uri(next, scheme->len + 1);
+
+    return 0;
+}
+
+static int
+_get_authority(const struct sol_str_slice partial_uri,
+    const struct sol_str_slice full_uri,
+    struct sol_str_slice *next,
+    struct sol_str_slice *host,
+    struct sol_str_slice *user,
+    struct sol_str_slice *pass,
+    uint32_t *port)
+{
+    struct sol_str_slice auth, port_slice = SOL_STR_SLICE_EMPTY;
+    const char *itr, *itr_end;
+    size_t discarted = 2;
+    bool parsing_ipv6;
+
+    if (!partial_uri.len) {
+        SOL_WRN("Empty authority. URI: %.*s", SOL_STR_SLICE_PRINT(full_uri));
+        return -EINVAL;
+    }
+
+    //Not an URL
+    if (!sol_str_slice_str_starts_with(partial_uri, "//"))
+        return 0;
+    if (partial_uri.len == 2)
+        return -EINVAL;
+
+    auth = partial_uri;
+    auth.data += 2;
+    auth.len -= 2;
+    itr_end = auth.data + auth.len;
+    parsing_ipv6 = false;
+
+    for (itr = auth.data, host->data = auth.data; itr < itr_end; itr++) {
+        if (*itr == '[') {
+            host->data = itr;
+            parsing_ipv6 = true;
+        } else if (*itr == ']') {
+            parsing_ipv6 = false;
+            host->len = itr - host->data;
+        } else if (*itr == '@') {
+            *user = *host;
+            if (!user->len)
+                user->len = itr - user->data;
+            *pass = port_slice;
+            pass->len = itr > pass->data ? itr - pass->data : 0;
+            host->data = itr + 1;
+            host->len = 0;
+            port_slice.data = "";
+            port_slice.len = 0;
+            discarted++;
+        } else if (*itr == ':' && !parsing_ipv6) {
+            if (host->len > 0)
+                return -EINVAL;
+            host->len = itr - host->data;
+            port_slice.data = itr + 1;
+            discarted++;
+        } else if (*itr == '/' || *itr == '?' || *itr == '#')
+            break;
+    }
+
+    if (parsing_ipv6) {
+        SOL_WRN("Malformed IPV6 at URI: %.*s", SOL_STR_SLICE_PRINT(full_uri));
+        return -EINVAL;
+    }
+
+    if (!host->len)
+        host->len = itr - host->data;
+    else if (!port_slice.len) {
+        port_slice.len = itr - port_slice.data;
+        if (port_slice.len) {
+            char *endptr;
+            *port = sol_util_strtol(port_slice.data, &endptr,
+                port_slice.len, 10);
+            if (endptr == port_slice.data) {
+                SOL_WRN("Could not convert the host port to integer."
+                    " Port: %.*s", SOL_STR_SLICE_PRINT(port_slice));
+                return -EINVAL;
+            }
+        }
+    }
+
+    SOL_DBG("User:%.*s Host:%.*s Pass%.*s Port:%.*s",
+        SOL_STR_SLICE_PRINT(*user), SOL_STR_SLICE_PRINT(*host),
+        SOL_STR_SLICE_PRINT(*pass), SOL_STR_SLICE_PRINT(port_slice));
+
+    _update_partial_uri(next,
+        port_slice.len + host->len + pass->len + user->len + discarted);
+    return 0;
+}
+
+static int
+_get_path(const struct sol_str_slice partial_uri,
+    const struct sol_str_slice full_uri,
+    struct sol_str_slice *next,
+    struct sol_str_slice *path)
+{
+    const char *itr, *itr_end;
+
+    if (!partial_uri.len)
+        return 0;
+
+    if (partial_uri.data[0] == '#' || partial_uri.data[0] == '?')
+        return 0;
+
+    path->data = partial_uri.data;
+    itr_end = partial_uri.data + partial_uri.len;
+
+    for (itr = path->data; itr < itr_end; itr++) {
+        if (*itr == '?' || *itr == '#')
+            break;
+    }
+
+    path->len = itr - path->data;
+
+    _update_partial_uri(next, path->len);
+
+    SOL_DBG("URI Path: %.*s", SOL_STR_SLICE_PRINT(*path));
+    return 0;
+}
+
+static int
+_get_query(const struct sol_str_slice partial_uri,
+    const struct sol_str_slice full_uri,
+    struct sol_str_slice *next,
+    struct sol_str_slice *query)
+{
+    char *sep;
+
+    if (!partial_uri.len)
+        return 0;
+
+    if (partial_uri.data[0] != '?')
+        return 0;
+
+    query->data = partial_uri.data + 1;
+
+    sep = memchr(partial_uri.data, '#', partial_uri.len);
+
+    if (sep)
+        query->len = sep - query->data;
+    else
+        query->len = partial_uri.len - 1;
+
+    _update_partial_uri(next, query->len + 1);
+
+    SOL_DBG("Query params: %.*s", SOL_STR_SLICE_PRINT(*query));
+    return 0;
+}
+
+static int
+_get_fragment(const struct sol_str_slice partial_uri,
+    const struct sol_str_slice full_uri,
+    struct sol_str_slice *next,
+    struct sol_str_slice *fragment)
+{
+
+    if (!partial_uri.len)
+        return 0;
+
+    if (partial_uri.data[0] != '#') {
+        SOL_WRN("A \"#\" is required in order to identify the fragment."
+            "URI: %.*s", SOL_STR_SLICE_PRINT(full_uri));
+        return -EINVAL;
+    }
+
+    fragment->data = partial_uri.data + 1;
+    fragment->len = partial_uri.len - 1;
+
+    SOL_DBG("URI Fragment: %.*s", SOL_STR_SLICE_PRINT(*fragment));
+    return 0;
+}
+
+SOL_API int
+sol_http_split_uri(const struct sol_str_slice full_uri,
+    struct sol_http_url *url)
+{
+    struct sol_str_slice partial_uri;
+    int r;
+
+    SOL_NULL_CHECK(url, -EINVAL);
+
+    if (!full_uri.len) {
+        SOL_WRN("Empty URI");
+        return -EINVAL;
+    }
+
+    memset(url, 0, sizeof(struct sol_http_url));
+    SOL_DBG("Splitting URI: %.*s", SOL_STR_SLICE_PRINT(full_uri));
+
+    partial_uri = full_uri;
+    r = _get_scheme(partial_uri, &partial_uri, &url->scheme);
+    SOL_INT_CHECK(r, < 0, r);
+    r = _get_authority(partial_uri, full_uri, &partial_uri, &url->host,
+        &url->user, &url->password, &url->port);
+    SOL_INT_CHECK(r, < 0, r);
+    r = _get_path(partial_uri, full_uri, &partial_uri, &url->path);
+    SOL_INT_CHECK(r, < 0, r);
+    r = _get_query(partial_uri, full_uri, &partial_uri, &url->query);
+    SOL_INT_CHECK(r, < 0, r);
+    r = _get_fragment(partial_uri, full_uri, &partial_uri, &url->fragment);
+    SOL_INT_CHECK(r, < 0, r);
+    return 0;
+}
diff --git a/src/modules/flow/oauth/oauth.c b/src/modules/flow/oauth/oauth.c
index 64f31d82..4e8494d7 100644
--- a/src/modules/flow/oauth/oauth.c
+++ b/src/modules/flow/oauth/oauth.c
@@ -478,8 +478,9 @@ static int
 v1_request_start_cb(void *data, struct sol_http_request *request)
 {
     int r;
-    char *escaped_url, *signature, *params, *escaped_params, *escaped_callback;
+    char *signature, *params;
     struct sol_flow_node *node = data;
+    struct sol_buffer escaped_callback, escaped_params, escaped_url;
     struct v1_data *mdata = sol_flow_node_get_private_data(node);
     struct sol_message_digest *digest;
     struct sol_blob *blob;
@@ -511,27 +512,30 @@ v1_request_start_cb(void *data, struct sol_http_request *request)
     r = sol_ptr_vector_append(&mdata->pending_digests, digest);
     SOL_INT_CHECK_GOTO(r, < 0, err_append);
 
-    r = sol_http_escape_string(&escaped_callback, req_data->callback_url);
+    r = sol_http_encode_slice(&escaped_callback, sol_str_slice_from_str(req_data->callback_url));
     SOL_INT_CHECK_GOTO(r, < 0, err_escape_callback);
 
     r  = asprintf(&params,
-        "oauth_callback=%s"
+        "oauth_callback=%.*s"
         "&oauth_consumer_key=%s"
         "&oauth_nonce=%s"
         "&oauth_signature_method=HMAC-SHA1"
         "&oauth_timestamp=%s"
         "&oauth_version=1.0",
-        escaped_callback, mdata->consumer_key, req_data->nonce,
+        SOL_STR_SLICE_PRINT(sol_buffer_get_slice(&escaped_callback)),
+        mdata->consumer_key, req_data->nonce,
         req_data->timestamp);
     SOL_INT_CHECK_GOTO(r, < 0, err_params);
 
-    r = sol_http_escape_string(&escaped_params, params);
+    r = sol_http_encode_slice(&escaped_params, sol_str_slice_from_str(params));
     SOL_INT_CHECK_GOTO(r, < 0, err_escape_params);
 
-    r = sol_http_escape_string(&escaped_url, mdata->request_token_url);
+    r = sol_http_encode_slice(&escaped_url, sol_str_slice_from_str(mdata->request_token_url));
     SOL_INT_CHECK_GOTO(r, < 0, err_escape);
 
-    r = asprintf(&signature, "POST&%s&%s", escaped_url, escaped_params);
+    r = asprintf(&signature, "POST&%.*s&%.*s",
+        SOL_STR_SLICE_PRINT(sol_buffer_get_slice(&escaped_url)),
+        SOL_STR_SLICE_PRINT(sol_buffer_get_slice(&escaped_params)));
     SOL_INT_CHECK_GOTO(r, < 0, err_signature);
 
     blob = sol_blob_new(SOL_BLOB_TYPE_DEFAULT, NULL, signature, strlen(signature));
@@ -541,10 +545,10 @@ v1_request_start_cb(void *data, struct sol_http_request *request)
     SOL_INT_CHECK_GOTO(r, < 0, err_feed);
 
     sol_blob_unref(blob);
-    free(escaped_params);
-    free(escaped_callback);
+    sol_buffer_fini(&escaped_params);
+    sol_buffer_fini(&escaped_callback);
     free(params);
-    free(escaped_url);
+    sol_buffer_fini(&escaped_url);
 
     return 0;
 
@@ -553,13 +557,13 @@ err_feed:
 err_blob:
     free(signature);
 err_signature:
-    free(escaped_url);
+    sol_buffer_fini(&escaped_url);
 err_escape:
-    free(escaped_params);
+    sol_buffer_fini(&escaped_params);
 err_escape_params:
     free(params);
 err_params:
-    free(escaped_callback);
+    sol_buffer_fini(&escaped_callback);
 err_escape_callback:
     sol_ptr_vector_remove(&mdata->pending_digests, digest);
 err_append:
diff --git a/src/test/Kconfig b/src/test/Kconfig
index 8c28b528..3d7dcd11 100644
--- a/src/test/Kconfig
+++ b/src/test/Kconfig
@@ -105,3 +105,8 @@ config TEST_PERSISTENCE_MEMMAP
 	bool "Memmap persistence API"
 	depends on USE_MEMMAP
 	default y
+
+config TEST_HTTP
+       bool "http"
+       depends on NETWORK
+       default y
diff --git a/src/test/Makefile b/src/test/Makefile
index 2050e1d5..599eb023 100644
--- a/src/test/Makefile
+++ b/src/test/Makefile
@@ -77,3 +77,6 @@ test-test-message-digest-$(TEST_MESSAGE_DIGEST) := test.c test-message-digest.c
 
 test-$(TEST_PERSISTENCE_MEMMAP) += test-persistence-memmap
 test-test-persistence-memmap-$(TEST_PERSISTENCE_MEMMAP) := test.c test-persistence-memmap.c
+
+test-$(TEST_HTTP) += test-http
+test-test-http-$(TEST_HTTP) := test.c test-http.c
diff --git a/src/test/test-http.c b/src/test/test-http.c
new file mode 100644
index 00000000..6f3b3aca
--- /dev/null
+++ b/src/test/test-http.c
@@ -0,0 +1,122 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "test.h"
+#include "sol-util.h"
+#include "sol-http.h"
+#include "sol-vector.h"
+
+DEFINE_TEST(test_split_urls);
+
+static void
+test_split_urls(void)
+{
+#define SET_PARAMS(_url, _scheme, _user, _pass, _host, _path, _query, _fragment, _port, _result, _check_url) \
+    { SOL_STR_SLICE_LITERAL(_url), { SOL_STR_SLICE_LITERAL(_scheme), SOL_STR_SLICE_LITERAL(_user), SOL_STR_SLICE_LITERAL(_pass), \
+                                     SOL_STR_SLICE_LITERAL(_host), SOL_STR_SLICE_LITERAL(_path), \
+                                     SOL_STR_SLICE_LITERAL(_query), SOL_STR_SLICE_LITERAL(_fragment), _port }, _result, _check_url }
+    size_t i;
+    int r;
+    static const struct {
+        struct sol_str_slice url;
+        struct sol_http_url splitted_url;
+        int result;
+        bool check_url;
+    } test_split[] =  {
+        SET_PARAMS("http://2001:db8::1", "", "", "", "", "", "", "", 0, -EINVAL, false),
+        SET_PARAMS("http://[2001:db8::1", "", "", "", "", "", "", "", 0, -EINVAL, false),
+        SET_PARAMS("http://2001:db8::1]", "", "", "", "", "", "", "", 0, -EINVAL, false),
+        SET_PARAMS("www.intel.com.br", "", "", "", "", "", "", "", 0, -EINVAL, false),
+        SET_PARAMS(":www.intel.com", "", "", "", "", "", "", "", 0, -EINVAL, false),
+        SET_PARAMS("//www.intel.com", "", "", "", "", "", "", "", 0, -EINVAL, false),
+        SET_PARAMS("://www.intel.com", "", "", "", "", "", "", "", 0, -EINVAL, false),
+        SET_PARAMS("/a/b", "", "", "", "", "", "", "", 0, -EINVAL, false),
+        SET_PARAMS("//a/b", "", "", "", "", "", "", "", 0, -EINVAL, false),
+        SET_PARAMS("http://", "", "", "", "", "", "", "", 0, -EINVAL, false),
+        SET_PARAMS("http://www.intel.com:/", "http", "", "", "www.intel.com", "/", "", "", 0, 0, false),
+        SET_PARAMS("http://intel.com/?go=2", "http", "", "", "intel.com", "/", "go=2", "", 0, 0, true),
+        SET_PARAMS("http://www.intel.com:8080", "http", "", "", "www.intel.com", "", "", "", 8080, 0, true),
+        SET_PARAMS("http://www.intel.com:1234/", "http", "", "", "www.intel.com", "/", "", "", 1234, 0, true),
+        SET_PARAMS("http://www.intel.com/a/b/d?go=2#fragment", "http", "", "", "www.intel.com", "/a/b/d", "go=2", "fragment", 0, 0, true),
+        SET_PARAMS("foo://user:pass@server.com:123/a/b?p=1&c=2#/a/b", "foo", "user", "pass", "server.com", "/a/b", "p=1&c=2", "/a/b", 123, 0, true),
+        SET_PARAMS("foo://user@server.com:123/a/b?p=1&c=2#/a/b", "foo", "user", "", "server.com", "/a/b", "p=1&c=2", "/a/b", 123, 0, true),
+        /* Do not check the created url for this one, Altought the created one will be correct it will not match,
+           as the create url will be foo://user:@server.com:123/a/b?p=1&c=2#/a/b
+           This behaviour is acceptable, since ':' can be ommited if the password is not provided.
+         */
+        SET_PARAMS("foo://user:@server.com:123/a/b?p=1&c=2#/a/b", "foo", "user", "", "server.com", "/a/b", "p=1&c=2", "/a/b", 123, 0, false),
+        SET_PARAMS("foo://server.com:123/a/b?p=1&c=2#/a/b", "foo", "", "", "server.com", "/a/b", "p=1&c=2", "/a/b", 123, 0, true),
+        SET_PARAMS("foo://server.com/a/b?p=1&c=2#/a/b", "foo", "", "", "server.com", "/a/b", "p=1&c=2", "/a/b", 0, 0, true),
+        SET_PARAMS("foo://server.com/?p=1&c=2#/a/b", "foo", "", "", "server.com", "/", "p=1&c=2", "/a/b", 0, 0, true),
+        SET_PARAMS("foo://server.com/?p=1&c=2", "foo", "", "", "server.com", "/", "p=1&c=2", "", 0, 0, true),
+        SET_PARAMS("foo://server.com/#/a/b", "foo", "", "", "server.com", "/", "", "/a/b", 0, 0, true),
+        SET_PARAMS("foo://server.com?p=1&c=2", "foo", "", "", "server.com", "", "p=1&c=2", "", 0, 0, true),
+        SET_PARAMS("foo://server.com#/a/b", "foo", "", "", "server.com", "", "", "/a/b", 0, 0, true),
+        SET_PARAMS("foo://192.3.3.3:123/#/a/b", "foo", "", "", "192.3.3.3", "/", "", "/a/b", 123, 0, true),
+        SET_PARAMS("mailto:user@server.com", "mailto", "", "", "", "user@server.com", "", "", 0, 0, true),
+        SET_PARAMS("file://localhost/usr/home/user/hi.txt", "file", "", "", "localhost", "/usr/home/user/hi.txt", "", "", 0, 0, true),
+        SET_PARAMS("foo://localhost/?go", "foo", "", "", "localhost", "/", "go", "", 0, 0, true),
+    };
+
+    for (i = 0; i < ARRAY_SIZE(test_split); i++) {
+        struct sol_http_url splitted;
+        struct sol_http_param params;
+        char *out_uri;
+        r = sol_http_split_uri(test_split[i].url, &splitted);
+        ASSERT_INT_EQ(r, test_split[i].result);
+        if (test_split[i].result < 0)
+            continue;
+        ASSERT(sol_str_slice_eq(splitted.scheme, test_split[i].splitted_url.scheme));
+        ASSERT(sol_str_slice_eq(splitted.host, test_split[i].splitted_url.host));
+        ASSERT(sol_str_slice_eq(splitted.path, test_split[i].splitted_url.path));
+        ASSERT(sol_str_slice_eq(splitted.fragment, test_split[i].splitted_url.fragment));
+        ASSERT(sol_str_slice_eq(splitted.query, test_split[i].splitted_url.query));
+        ASSERT(sol_str_slice_eq(splitted.user, test_split[i].splitted_url.user));
+        ASSERT(sol_str_slice_eq(splitted.password, test_split[i].splitted_url.password));
+        ASSERT_INT_EQ(splitted.port, test_split[i].splitted_url.port);
+        if (!test_split[i].check_url)
+            continue;
+        sol_http_param_init(&params);
+        r = sol_http_decode_params(splitted.query, SOL_HTTP_PARAM_QUERY_PARAM, &params);
+        ASSERT_INT_EQ(r, 0);
+        r = sol_http_create_uri(&out_uri, splitted, &params);
+        ASSERT_INT_EQ(r, 0);
+        ASSERT(sol_str_slice_str_eq(test_split[i].url, out_uri));
+        sol_http_param_free(&params);
+        free(out_uri);
+    }
+
+#undef SET_PARAMS
+}
+
+
+TEST_MAIN();