"2015-08-21 13:54:55 -0300"
diff --git a/data/jsons/dependencies.json b/data/jsons/dependencies.json
index 59f3d295..3164c7c4 100644
--- a/data/jsons/dependencies.json
+++ b/data/jsons/dependencies.json
@@ -242,6 +242,12 @@
       "pkgname": "icu-uc icu-i18n",
       "atleast-version": "52.1"
     },
+    {
+      "dependency": "libpcre",
+      "type": "pkg-config",
+      "pkgname": "libpcre",
+      "atleast-version": "8.12"
+    },
     {
       "dependency": "isatty",
       "type": "ccode",
diff --git a/src/modules/flow/string/Kconfig b/src/modules/flow/string/Kconfig
index cc19303d..e5e21bf5 100644
--- a/src/modules/flow/string/Kconfig
+++ b/src/modules/flow/string/Kconfig
@@ -7,3 +7,27 @@ config USE_ICU
 config FLOW_NODE_TYPE_STRING
 	tristate "Node type: string"
 	default y
+	help
+		The string family of nodes provide string facilities
+		on your flow, acting on the strings contained in
+		string packets:
+
+		 - compare/concatenate two strings
+		 - split a string in others
+		 - replace a substring in a string
+		 - measure the lenght of the string
+		 - change the string to lower/uppercase
+		 - search for regular expression patterns in a string
+		 - replace regular expression patterns in a string
+
+		For the nodes dealing with regular expressions, only
+		one RE backend is supported: libpcre. If that
+		dependency is not present, those nodes will be built
+		but made useless -- they will always generate error
+		packets after any input ones.
+
+		For each of the remaining string nodes, there may be
+		two implementations (depending on the presence of the
+		ICU library or not). We strongly recommend that you
+		build Soletta with ICU, so that the full UTF-8 set of
+		characters is properly handled by the string nodes.
diff --git a/src/modules/flow/string/Makefile b/src/modules/flow/string/Makefile
index 58d317e7..8a5ed905 100644
--- a/src/modules/flow/string/Makefile
+++ b/src/modules/flow/string/Makefile
@@ -1,12 +1,34 @@
+#  The string node implementation is split in three files, namely:
+#  - string-{icu,ascii}.c
+#  - string-replace-{icu,ascii}.c
+#  - string-regexp.c
+#
+#  string-regexp.c contains the code for nodes dealing with regular
+#  expressions and only one RE backend is supported: libpcre. If that
+#  dependency is not present, the RE nodes will be built but made
+#  useless -- they will always generate error packets after any input
+#  ones.
+#
+#  For each of the remaining string nodes, there may be two
+#  implementations (depending on the presence of the ICU library or
+#  not), thus ICU or ASCII. We could have these remaining nodes put on
+#  a single file per implementation, but since the string replacing
+#  nodes have a different license than the others, we kept them split
+#  like that.
+
+ifeq (,$(HAVE_LIBPCRE))
+warning-msg := "You're building the string nodes module without Perl regular expressions support. That way, the string module will still be built, but the regular expression nodes will be made useless -- any input packet on them only issue an error output packet. Please re-configure after you have LIBPCRE development packages installed to get the intended string nodes behavior.\n\n"
+endif
+
 obj-$(FLOW_NODE_TYPE_STRING) += string.mod
-obj-string-$(FLOW_NODE_TYPE_STRING) := string.json
+obj-string-$(FLOW_NODE_TYPE_STRING) := string.json string-regexp.o
 
 ifeq (y,$(HAVE_ICU))
 obj-string-$(FLOW_NODE_TYPE_STRING) += string-icu.o string-replace-icu.o
 else
 obj-string-$(FLOW_NODE_TYPE_STRING) += string-ascii.o string-replace-ascii.o
-warning-msg := "You're building the string nodes module without i18n support -- some nodes will only act properly on pure ASCII input, not the intended utf-8 for Soletta. Please re-configure after you have ICU development packages installed to get the intended string nodes behavior."
+warning-msg += "You're building the string nodes module without i18n support. That way, some nodes will only act properly on pure ASCII input, not the intended UTF-8 for Soletta. Please re-configure after you have ICU development packages installed to get the intended string nodes behavior."
 endif
 
-obj-string-$(FLOW_NODE_TYPE_STRING)-extra-cflags += $(LOCALE_CFLAGS) $(ICU_CFLAGS)
-obj-string-$(FLOW_NODE_TYPE_STRING)-extra-ldflags += $(LOCALE_LDFLAGS) $(ICU_LDFLAGS)
+obj-string-$(FLOW_NODE_TYPE_STRING)-extra-cflags += $(LOCALE_CFLAGS) $(ICU_CFLAGS) $(LIBPCRE_CFLAGS)
+obj-string-$(FLOW_NODE_TYPE_STRING)-extra-ldflags += $(LOCALE_LDFLAGS) $(ICU_LDFLAGS) $(LIBPCRE_LDFLAGS)
diff --git a/src/modules/flow/string/string-ascii.c b/src/modules/flow/string/string-ascii.c
index a63e40db..f8745d85 100644
--- a/src/modules/flow/string/string-ascii.c
+++ b/src/modules/flow/string/string-ascii.c
@@ -41,6 +41,7 @@
 
 #include "string-gen.h"
 #include "string-ascii.h"
+#include "string-regexp.h"
 
 struct string_data {
     int32_t n;
diff --git a/src/modules/flow/string/string-icu.c b/src/modules/flow/string/string-icu.c
index b6dc3942..76b86589 100644
--- a/src/modules/flow/string/string-icu.c
+++ b/src/modules/flow/string/string-icu.c
@@ -33,13 +33,11 @@
 #include <ctype.h>
 #include <errno.h>
 
-#include <unicode/ustring.h>
-#include <unicode/utypes.h>
-
 #include "sol-flow-internal.h"
 
 #include "string-gen.h"
 #include "string-icu.h"
+#include "string-regexp.h"
 
 #define MIN(a, b) (((a) < (b)) ? (a) : (b))
 
@@ -443,18 +441,12 @@ string_split_open(struct sol_flow_node *node,
     return 0;
 }
 
-static void
-clear_substrings(struct string_split_data *mdata)
-{
-    sol_vector_clear(&mdata->substrings);
-}
-
 static void
 string_split_close(struct sol_flow_node *node, void *data)
 {
     struct string_split_data *mdata = data;
 
-    clear_substrings(mdata);
+    sol_vector_clear(&mdata->substrings);
     free(mdata->string);
     free(mdata->separator);
 }
@@ -478,6 +470,7 @@ icu_str_split(const struct sol_str_slice slice,
 
 #define CREATE_SLICE(_str, _len) \
     do { \
+        struct sol_str_slice *s; \
         s = sol_vector_append(&v); \
         if (!s) \
             goto err; \
@@ -486,7 +479,6 @@ icu_str_split(const struct sol_str_slice slice,
     } while (0)
 
     while (str && (v.len < max_split + 1)) {
-        struct sol_str_slice *s;
         UChar *token = u_strFindFirst(str, len, delim, dlen);
         if (!token) {
             CREATE_SLICE(str, len);
@@ -501,13 +493,13 @@ icu_str_split(const struct sol_str_slice slice,
         len -= (token - str) + dlen;
         str = token + dlen;
     }
-#undef CREATE_SLICE
 
     return v;
 
 err:
     sol_vector_clear(&v);
     return v;
+#undef CREATE_SLICE
 }
 
 static inline struct sol_str_slice
diff --git a/src/modules/flow/string/string-icu.h b/src/modules/flow/string/string-icu.h
index 15c1f934..e96ff0bb 100644
--- a/src/modules/flow/string/string-icu.h
+++ b/src/modules/flow/string/string-icu.h
@@ -33,6 +33,8 @@
 #pragma once
 
 #include <unicode/uchar.h>
+#include <unicode/ustring.h>
+#include <unicode/utypes.h>
 
 #include "sol-flow.h"
 
diff --git a/src/modules/flow/string/string-regexp.c b/src/modules/flow/string/string-regexp.c
new file mode 100644
index 00000000..b184dadb
--- /dev/null
+++ b/src/modules/flow/string/string-regexp.c
@@ -0,0 +1,364 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <ctype.h>
+#include <errno.h>
+
+#ifdef HAVE_LIBPCRE
+#include <pcre.h>
+#endif
+
+#include "sol-flow-internal.h"
+
+#include "string-gen.h"
+#include "string-regexp.h"
+
+#ifdef HAVE_LIBPCRE
+static struct sol_vector
+string_regexp_search_and_split(struct string_regexp_search_data *mdata)
+{
+    int r;
+    pcre *compiled_re;
+    int pcre_error_offset;
+    pcre_extra *pcre_extra;
+    size_t str_len, match_sz;
+    int *match_vector, sub_str_count;
+    const char *pcre_error_str = NULL;
+    struct sol_vector v = SOL_VECTOR_INIT(struct sol_str_slice);
+
+#define CREATE_SLICE(_str, _len) \
+    do { \
+        struct sol_str_slice *s; \
+        s = sol_vector_append(&v); \
+        if (!s) \
+            goto err; \
+        s->data = (const char *)_str; \
+        s->len = _len; \
+    } while (0)
+
+    //mdata->string should never be NULL
+    str_len = strlen(mdata->string);
+    if (!str_len)
+        return v;
+
+    compiled_re = pcre_compile(mdata->regexp, PCRE_UTF8,
+        &pcre_error_str, &pcre_error_offset, NULL);
+    if (!compiled_re) {
+        sol_flow_send_error_packet(mdata->node, EINVAL,
+            "Could not compile '%s': %s\n", mdata->regexp,
+            pcre_error_str);
+        return v;
+    }
+
+    r = pcre_fullinfo(compiled_re, NULL, PCRE_INFO_CAPTURECOUNT,
+        &sub_str_count);
+    if (r < 0) {
+        sol_flow_send_error_packet(mdata->node, EINVAL, "Could not"
+            "extract info from compiled regular expression %s",
+            mdata->regexp);
+        goto err_compile;
+    }
+
+    match_sz = (sub_str_count + 1) * 3;
+    match_vector = alloca(match_sz);
+
+    //A null pcre_extra is fine (no optimization possible), errors are
+    //reported on the last argument
+    pcre_extra = pcre_study(compiled_re, 0, &pcre_error_str);
+    if (pcre_error_str != NULL) {
+        sol_flow_send_error_packet(mdata->node, EINVAL,
+            "Error optimizing '%s': %s\n", mdata->regexp,
+            pcre_error_str);
+        goto err;
+    }
+
+    r = pcre_exec(compiled_re, pcre_extra, mdata->string, str_len,
+        0, 0, match_vector, match_sz);
+
+    if (r < 0) {
+        sol_flow_send_error_packet(mdata->node, EINVAL,
+            "Fail on matching regular expression '%s' on string %s\n",
+            mdata->regexp, mdata->string);
+        goto err;
+    } else {
+        int i;
+
+        /* The value returned by pcre_exec() is one more than the
+         * highest numbered pair that has been set. If the vector is
+         * too small to hold all the captured substring offsets, it is
+         * used as far as possible (up to two-thirds of its length),
+         * and the function returns a value of zero.
+         */
+        if (r == 0) { // should not happen, but let's treat the case
+            sol_flow_send_error_packet(mdata->node, EINVAL,
+                "A memory overflow happened while executing"
+                " regular expression '%s' on string %s\n",
+                mdata->regexp, mdata->string);
+            goto err;
+        }
+        for (i = 0; i < r; i++) {
+            CREATE_SLICE(mdata->string + match_vector[i * 2],
+                match_vector[i * 2 + 1] - match_vector[i * 2]);
+        }
+    }
+
+err:
+    if (pcre_extra != NULL)
+        pcre_free(pcre_extra);
+err_compile:
+    pcre_free(compiled_re);
+
+    return v;
+#undef CREATE_SLICE
+}
+
+static int
+calculate_regexp_substrings(struct string_regexp_search_data *mdata,
+    struct sol_flow_node *node)
+{
+    if (!(mdata->string && mdata->regexp))
+        return 0;
+
+    sol_vector_clear(&mdata->substrings);
+
+    mdata->substrings = string_regexp_search_and_split(mdata);
+
+    return sol_flow_send_irange_value_packet(node,
+        SOL_FLOW_NODE_TYPE_STRING_REGEXP_SEARCH__OUT__LENGTH,
+        mdata->substrings.len);
+}
+
+static int
+send_regexp_substring(struct string_regexp_search_data *mdata)
+{
+    struct sol_str_slice *sub_slice;
+    int len;
+
+    len = mdata->substrings.len;
+    if (!len)
+        return 0;
+
+    if (mdata->index >= len) {
+        SOL_WRN("Index (%d) greater than substrings "
+            "length (%d).", mdata->index, len);
+        return -EINVAL;
+    }
+
+    sub_slice = sol_vector_get(&mdata->substrings, mdata->index);
+
+    return sol_flow_send_string_slice_packet(mdata->node,
+        SOL_FLOW_NODE_TYPE_STRING_REGEXP_SEARCH__OUT__OUT, *sub_slice);
+}
+
+#endif
+
+int
+string_regexp_search_open(struct sol_flow_node *node,
+    void *data,
+    const struct sol_flow_node_options *options)
+{
+    struct string_regexp_search_data *mdata = data;
+    const struct sol_flow_node_type_string_regexp_search_options *opts;
+
+    SOL_FLOW_NODE_OPTIONS_SUB_API_CHECK
+        (options, SOL_FLOW_NODE_TYPE_STRING_REGEXP_SEARCH_OPTIONS_API_VERSION,
+        -EINVAL);
+    opts = (const struct sol_flow_node_type_string_regexp_search_options *)options;
+
+    if (opts->index.val < 0) {
+        SOL_WRN("Index (%" PRId32 ") must be a non-negative value",
+            opts->index.val);
+        return -EINVAL;
+    }
+    if (opts->max_regexp_search.val < 0) {
+        SOL_WRN("Max regexp matches (%" PRId32 ") must be"
+            " a non-negative value", opts->max_regexp_search.val);
+        return -EINVAL;
+    }
+    if (!opts->regexp || !strlen(opts->regexp)) {
+        SOL_WRN("A non-empty regular expression string must be provided");
+        return -EINVAL;
+    }
+
+    mdata->node = node;
+    mdata->index = opts->index.val;
+    mdata->max_regexp_search = opts->max_regexp_search.val > 0 ?
+        (size_t)opts->max_regexp_search.val : SIZE_MAX;
+    mdata->regexp = strdup(opts->regexp);
+
+    sol_vector_init(&mdata->substrings, sizeof(struct sol_str_slice));
+
+    return 0;
+}
+
+void
+string_regexp_search_close(struct sol_flow_node *node, void *data)
+{
+    struct string_regexp_search_data *mdata = data;
+
+    sol_vector_clear(&mdata->substrings);
+    free(mdata->string);
+    free(mdata->regexp);
+}
+
+int
+string_regexp_search(struct sol_flow_node *node,
+    void *data,
+    uint16_t port,
+    uint16_t conn_id,
+    const struct sol_flow_packet *packet)
+{
+#ifdef HAVE_LIBPCRE
+    struct string_regexp_search_data *mdata = data;
+    const char *in_value;
+    int r;
+
+    r = sol_flow_packet_get_string(packet, &in_value);
+    SOL_INT_CHECK(r, < 0, r);
+
+    free(mdata->string);
+    if (!in_value) {
+        mdata->string = NULL;
+        return 0;
+    } else
+        mdata->string = strdup(in_value);
+
+    r = calculate_regexp_substrings(mdata, node);
+    SOL_INT_CHECK(r, < 0, r);
+
+    return send_regexp_substring(mdata);
+#else
+    sol_flow_send_error_packet(node, ENOTSUP, "The string/regexp-search"
+        " can't work on this Soletta build -- libpcre dependency is needed "
+        "in order for this node to work");
+    return -EINVAL;
+#endif
+}
+
+int
+set_string_regexp_pattern(struct sol_flow_node *node,
+    void *data,
+    uint16_t port,
+    uint16_t conn_id,
+    const struct sol_flow_packet *packet)
+{
+#ifdef HAVE_LIBPCRE
+    struct string_regexp_search_data *mdata = data;
+    const char *in_value;
+    int r;
+
+    r = sol_flow_packet_get_string(packet, &in_value);
+    SOL_INT_CHECK(r, < 0, r);
+
+    free(mdata->regexp);
+    if (!in_value || !strlen(in_value)) {
+        sol_flow_send_error_packet(mdata->node, EINVAL, "The regular"
+            " expression must never be empty");
+        return -EINVAL;
+    } else
+        mdata->regexp = strdup(in_value);
+
+    r = calculate_regexp_substrings(mdata, node);
+    SOL_INT_CHECK(r, < 0, r);
+
+    return send_regexp_substring(mdata);
+#else
+    sol_flow_send_error_packet(node, ENOTSUP, "The string/regexp-search"
+        " can't work on this Soletta build -- libpcre dependency is needed "
+        "in order for this node to work");
+    return -EINVAL;
+#endif
+}
+
+int
+set_string_regexp_index(struct sol_flow_node *node,
+    void *data,
+    uint16_t port,
+    uint16_t conn_id,
+    const struct sol_flow_packet *packet)
+{
+#ifdef HAVE_LIBPCRE
+    struct string_regexp_search_data *mdata = data;
+    int32_t in_value;
+    int r;
+
+    r = sol_flow_packet_get_irange_value(packet, &in_value);
+    SOL_INT_CHECK(r, < 0, r);
+
+    if (in_value < 0) {
+        SOL_WRN("Index (%" PRId32 ") must be a non-negative value", in_value);
+        return -EINVAL;
+    }
+    mdata->index = in_value;
+
+    return send_regexp_substring(mdata);
+#else
+    sol_flow_send_error_packet(node, ENOTSUP, "The string/regexp-search"
+        " can't work on this Soletta build -- libpcre dependency is needed "
+        "in order for this node to work");
+    return -EINVAL;
+#endif
+}
+
+int
+set_string_regexp_max_match(struct sol_flow_node *node,
+    void *data,
+    uint16_t port,
+    uint16_t conn_id,
+    const struct sol_flow_packet *packet)
+{
+#ifdef HAVE_LIBPCRE
+    struct string_regexp_search_data *mdata = data;
+    int32_t in_value;
+    int r;
+
+    r = sol_flow_packet_get_irange_value(packet, &in_value);
+    SOL_INT_CHECK(r, < 0, r);
+
+    if (in_value < 0) {
+        SOL_WRN("Maximum regexp matches counter (%" PRId32 ") must "
+            "be a non-negative value", in_value);
+        return -EINVAL;
+    }
+    mdata->max_regexp_search = in_value;
+
+    r = calculate_regexp_substrings(mdata, node);
+    SOL_INT_CHECK(r, < 0, r);
+
+    return send_regexp_substring(mdata);
+#else
+    sol_flow_send_error_packet(node, ENOTSUP, "The string/regexp-search"
+        " can't work on this Soletta build -- libpcre dependency is needed "
+        "in order for this node to work");
+    return -EINVAL;
+#endif
+}
diff --git a/src/modules/flow/string/string-regexp.h b/src/modules/flow/string/string-regexp.h
new file mode 100644
index 00000000..b1665450
--- /dev/null
+++ b/src/modules/flow/string/string-regexp.h
@@ -0,0 +1,56 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#pragma once
+
+#include "sol-flow.h"
+
+int string_regexp_search_open(struct sol_flow_node *node, void *data, const struct sol_flow_node_options *options);
+
+void string_regexp_search_close(struct sol_flow_node *node, void *data);
+
+int string_regexp_search(struct sol_flow_node *node, void *data, uint16_t port, uint16_t conn_id, const struct sol_flow_packet *packet);
+
+int set_string_regexp_pattern(struct sol_flow_node *node, void *data, uint16_t port, uint16_t conn_id, const struct sol_flow_packet *packet);
+
+int set_string_regexp_index(struct sol_flow_node *node, void *data, uint16_t port, uint16_t conn_id, const struct sol_flow_packet *packet);
+
+int set_string_regexp_max_match(struct sol_flow_node *node, void *data, uint16_t port, uint16_t conn_id, const struct sol_flow_packet *packet);
+
+struct string_regexp_search_data {
+    struct sol_flow_node *node;
+    struct sol_vector substrings;
+    size_t max_regexp_search;
+    char *string;
+    char *regexp;
+    int index;
+};
diff --git a/src/modules/flow/string/string.json b/src/modules/flow/string/string.json
index 060f0b0a..b18ec783 100644
--- a/src/modules/flow/string/string.json
+++ b/src/modules/flow/string/string.json
@@ -341,6 +341,85 @@
       ],
       "private_data_type": "string_replace_data",
       "url": "http://solettaproject.org/doc/latest/node_types/string/replace.html"
+    },
+    {
+      "category": "string",
+      "description": "Search a given regular expression pattern on a given string. This node expects the same syntax and semantics as Perl 5 on regular expressions. When dealing the UTF-8 characters, remember to use the 'p{}' family of escape sequences (Unicode character properties).",
+      "in_ports": [
+        {
+          "data_type": "string",
+          "description": "String to be searched.",
+          "methods": {
+            "process": "string_regexp_search"
+          },
+          "name": "IN"
+        },
+        {
+          "data_type": "string",
+          "description": "Regular expression pattern to search the string received on 'IN' port with.",
+          "methods": {
+            "process": "set_string_regexp_pattern"
+          },
+          "name": "REGEXP"
+        },
+        {
+          "data_type": "int",
+          "description": "This value defines which substring match (by index, starting from 0) inside the one that was fed to the 'IN' port should be output in the 'OUT' port. It must be non-negative. The first substring will always identify the portion of the subject string matched by the entire pattern. The next one will be the first capturing subpattern, and so on.",
+          "methods": {
+            "process": "set_string_regexp_index"
+          },
+          "name": "INDEX"
+        },
+        {
+          "data_type": "int",
+          "description": "The regular expression matching against the input string can result in various substring matches. This value defines the maximum number of them to generate and make available for selection by the 'INDEX' port. It must be non-negative.",
+          "methods": {
+            "process": "set_string_regexp_max_match"
+          },
+          "name": "MAX_REGEXP_SEARCH"
+        }
+      ],
+      "methods": {
+        "close": "string_regexp_search_close",
+        "open": "string_regexp_search_open"
+      },
+      "name": "string/regexp-search",
+      "options": {
+        "members": [
+          {
+            "data_type": "int",
+            "default": 0,
+            "description": "This value defines which substring match (by index, starting from 0) inside the one that was fed to the 'IN' port should be output in the 'OUT' port. It must be non-negative. It can be overriden by values received on 'INDEX' port.",
+            "name": "index"
+          },
+          {
+            "data_type": "int",
+            "default": 0,
+            "description": "The regular expression matching against the input string can result in various substring matches. This value defines the maximum number of them to generate and make available for selection by the 'INDEX' port. This option can be overriden by values received on the 'MAX_REGEXP_SEARCH' port. The value of zero (default one) will be interpreted as to generate all possible matches.",
+            "name": "max_regexp_search"
+          },
+          {
+            "data_type": "string",
+            "description": "Regular expression pattern to search the string received on 'IN' port with. It can be overriden by values received on 'REGEXP' port.",
+            "name": "regexp"
+          }
+        ],
+        "version": 1
+      },
+      "out_ports": [
+        {
+          "data_type": "int",
+          "description": "Number of regular expression match substrings. The first substring will always identify the portion of the subject string matched by the entire pattern. The next one will be the first capturing subpattern, and so on.",
+          "name": "LENGTH"
+        },
+        {
+          "data_type": "string",
+          "description": "Outputs the regular expression match substring at the selected index. With regard to indeces, the first substring (index 0) will always identify the portion of the subject string matched by the entire pattern. The next one will be the first capturing subpattern, and so on.",
+          "name": "OUT"
+        }
+      ],
+      "private_data_type": "string_regexp_search_data",
+      "url": "http://solettaproject.org/doc/latest/node_types/string/regexp_search.html"
     }
   ]
 }
diff --git a/src/test-fbp/string-regexp-search.fbp b/src/test-fbp/string-regexp-search.fbp
new file mode 100644
index 00000000..b23e0dc9
--- /dev/null
+++ b/src/test-fbp/string-regexp-search.fbp
@@ -0,0 +1,86 @@
+# This file is part of the Soletta Project
+#
+# Copyright (C) 2015 Intel Corporation. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+#   * Redistributions of source code must retain the above copyright
+#     notice, this list of conditions and the following disclaimer.
+#   * Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in
+#     the documentation and/or other materials provided with the
+#     distribution.
+#   * Neither the name of Intel Corporation nor the names of its
+#     contributors may be used to endorse or promote products derived
+#     from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+str_hello_world(constant/string:value=" ")
+str_hello_hello(constant/string:value=" ")
+
+result_hello(constant/string:value="")
+result_world(constant/string:value="")
+result_hello_world(constant/string:value=" ")
+
+str_hello_world OUT -> IN regexp_search_01(string/regexp-search:regexp="",index=0)
+regexp_search_01 OUT -> IN[0] cmp_01(string/compare)
+result_world OUT -> IN[1] cmp_01
+cmp_01 EQUAL -> RESULT result_01(test/result)
+
+str_hello_world OUT -> IN regexp_search_02(string/regexp-search:regexp="...",index=0)
+regexp_search_02 OUT -> IN[0] cmp_02(string/compare)
+result_hello OUT -> IN[1] cmp_02
+cmp_02 EQUAL -> RESULT result_02(test/result)
+
+str_hello_world OUT -> IN regexp_search_03(string/regexp-search:regexp="$",index=0)
+regexp_search_03 OUT -> IN[0] cmp_03(string/compare)
+result_world OUT -> IN[1] cmp_03
+cmp_03 EQUAL -> RESULT result_03(test/result)
+
+str_hello_world OUT -> IN regexp_search_04(string/regexp-search:regexp="[d]$",index=0)
+regexp_search_04 OUT -> IN[0] cmp_04(string/compare)
+result_world OUT -> IN[1] cmp_04
+cmp_04 EQUAL -> RESULT result_04(test/result)
+
+str_hello_world OUT -> IN regexp_search_05(string/regexp-search:regexp="(\\p{L}+)\\s(\\p{L}+)",index=0)
+regexp_search_05 OUT -> IN[0] cmp_05(string/compare)
+result_hello_world OUT -> IN[1] cmp_05
+cmp_05 EQUAL -> RESULT result_05(test/result)
+
+str_hello_world OUT -> IN regexp_search_06(string/regexp-search:regexp="(\\p{L}+)\\s(\\p{L}+)",index=1)
+regexp_search_06 OUT -> IN[0] cmp_06(string/compare)
+result_hello OUT -> IN[1] cmp_06
+cmp_06 EQUAL -> RESULT result_06(test/result)
+
+str_hello_hello OUT -> IN regexp_search_07(string/regexp-search:regexp="(\\p{L}\\p{L}\\p{L}\\p{L}\\p{L})\\s\\g1",index=0)
+regexp_search_07 OUT -> IN[0] cmp_07(string/compare)
+str_hello_hello OUT -> IN[1] cmp_07
+cmp_07 EQUAL -> RESULT result_07(test/result)
+
+str_hello_hello OUT -> IN regexp_search_08(string/regexp-search:regexp="(\\p{L}\\p{L}\\p{L}\\p{L}\\p{L})\\s\\g{-1}",index=0)
+regexp_search_08 OUT -> IN[0] cmp_08(string/compare)
+str_hello_hello OUT -> IN[1] cmp_08
+cmp_08 EQUAL -> RESULT result_08(test/result)
+
+str_hello_hello OUT -> IN regexp_search_09(string/regexp-search:regexp="(?<hello>\\p{L}\\p{L}\\p{L}\\p{L}\\p{L})\\s\\g{hello}",index=0)
+regexp_search_09 OUT -> IN[0] cmp_09(string/compare)
+str_hello_hello OUT -> IN[1] cmp_09
+cmp_09 EQUAL -> RESULT result_09(test/result)
+
+str_hello_world OUT -> IN regexp_search_10(string/regexp-search:regexp="(\\p{L}{5})\\s(\\p{L}{5})",index=2)
+regexp_search_10 OUT -> IN[0] cmp_10(string/compare)
+result_world OUT -> IN[1] cmp_10
+cmp_10 EQUAL -> RESULT result_10(test/result)