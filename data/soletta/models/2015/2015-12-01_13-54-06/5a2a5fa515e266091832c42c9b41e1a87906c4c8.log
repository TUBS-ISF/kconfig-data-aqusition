"2015-12-01 13:54:06 -0200"
diff --git a/src/lib/flow/Kconfig b/src/lib/flow/Kconfig
index 11946c6d..bc76e33b 100644
--- a/src/lib/flow/Kconfig
+++ b/src/lib/flow/Kconfig
@@ -82,5 +82,6 @@ source "src/modules/flow/timestamp/Kconfig"
 source "src/modules/flow/trigonometry/Kconfig"
 source "src/modules/flow/udev/Kconfig"
 source "src/modules/flow/unix-socket/Kconfig"
+source "src/modules/flow/update/Kconfig"
 source "src/modules/flow/wallclock/Kconfig"
 endmenu
diff --git a/src/modules/flow/update/Kconfig b/src/modules/flow/update/Kconfig
new file mode 100644
index 00000000..0279bdd0
--- /dev/null
+++ b/src/modules/flow/update/Kconfig
@@ -0,0 +1,9 @@
+config FLOW_NODE_TYPE_UPDATE
+	tristate "Node type: update"
+	depends on USE_UPDATE
+	default m
+    help
+        Provides nodes to update a Soletta application. It allows checking
+        for updates, fetch the file and install it. Operations
+        will be performed by underlying update module, defined via
+        SOL_UPDATE_MODULE environment variable.
diff --git a/src/modules/flow/update/Makefile b/src/modules/flow/update/Makefile
new file mode 100644
index 00000000..cf997610
--- /dev/null
+++ b/src/modules/flow/update/Makefile
@@ -0,0 +1,4 @@
+obj-$(FLOW_NODE_TYPE_UPDATE) += update.mod
+obj-update-$(FLOW_NODE_TYPE_UPDATE) := update.json \
+	update.o
+obj-update-$(FLOW_NODE_TYPE_UPDATE)-type := flow
diff --git a/src/modules/flow/update/update.c b/src/modules/flow/update/update.c
new file mode 100644
index 00000000..758970f9
--- /dev/null
+++ b/src/modules/flow/update/update.c
@@ -0,0 +1,292 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "sol-buffer.h"
+#include "sol-flow/update.h"
+#include "sol-flow-internal.h"
+#include "sol-json.h"
+#include "sol-str-slice.h"
+#include "sol-types.h"
+#include "sol-update.h"
+
+#include <sol-util.h>
+#include <errno.h>
+
+struct update_data {
+    struct sol_update_handle *handle;
+};
+
+struct update_node_type {
+    struct sol_flow_node_type base;
+    uint16_t progress_port;
+};
+
+static int
+check_open(struct sol_flow_node *node, void *data, const struct sol_flow_node_options *options)
+{
+    struct update_node_type *type;
+
+    type = (struct update_node_type *)sol_flow_node_get_type(node);
+    type->progress_port = SOL_FLOW_NODE_TYPE_UPDATE_CHECK__OUT__PROGRESS;
+
+    return 0;
+}
+
+static int
+cancel_check_process(struct sol_flow_node *node, void *data, uint16_t port, uint16_t conn_id, const struct sol_flow_packet *packet)
+{
+    struct update_data *mdata = data;
+
+    if (mdata->handle) {
+        if (!sol_update_cancel(mdata->handle))
+            sol_flow_send_error_packet(node, EINVAL,
+                "Could not cancel check process");
+        else
+            mdata->handle = NULL;
+    } else {
+        SOL_WRN("No current check in process, ignoring request to cancel");
+    }
+
+    return 0;
+}
+
+static void
+check_cb(void *data, int status, const struct sol_update_info *response)
+{
+    struct sol_flow_node *node = data;
+    struct update_data *mdata = sol_flow_node_get_private_data(node);
+
+    if (status < 0) {
+        sol_flow_send_error_packet(node, -status,
+            "Error while checking for updates: %s", sol_util_strerrora(-status));
+        goto end;
+    }
+
+    sol_flow_send_string_packet(node,
+        SOL_FLOW_NODE_TYPE_UPDATE_CHECK__OUT__VERSION, response->version);
+    sol_flow_send_irange_value_packet(node,
+        SOL_FLOW_NODE_TYPE_UPDATE_CHECK__OUT__SIZE, response->size);
+
+end:
+    mdata->handle = NULL;
+}
+
+static int
+check_process(struct sol_flow_node *node, void *data, uint16_t port, uint16_t conn_id, const struct sol_flow_packet *packet)
+{
+    struct update_data *mdata = data;
+
+    if (mdata->handle) {
+        SOL_DBG("Check already in progress. Ignoring packet");
+        return 0;
+    }
+
+    mdata->handle = sol_update_check(check_cb, node);
+    if (!mdata->handle) {
+        sol_flow_send_error_packet(node, EINVAL,
+            "Could not check for updates");
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int
+fetch_open(struct sol_flow_node *node, void *data, const struct sol_flow_node_options *options)
+{
+    struct update_node_type *type;
+
+    type = (struct update_node_type *)sol_flow_node_get_type(node);
+    type->progress_port = SOL_FLOW_NODE_TYPE_UPDATE_FETCH__OUT__PROGRESS;
+
+    return 0;
+}
+
+static void
+common_close(struct sol_flow_node *node, void *data)
+{
+    struct update_data *mdata = data;
+
+    if (mdata->handle) {
+        if (!sol_update_cancel(mdata->handle))
+            SOL_WRN("Could not cancel ongoing task: %p", mdata->handle);
+    }
+}
+
+static int
+cancel_fetch_process(struct sol_flow_node *node, void *data, uint16_t port, uint16_t conn_id, const struct sol_flow_packet *packet)
+{
+    struct update_data *mdata = data;
+
+    if (mdata->handle) {
+        if (!sol_update_cancel(mdata->handle))
+            sol_flow_send_error_packet(node, EINVAL,
+                "Could not cancel fetch process");
+        else
+            mdata->handle = NULL;
+    } else {
+        SOL_WRN("No current fetch in process, ignoring request to cancel");
+    }
+
+    return 0;
+}
+
+static void
+fetch_cb(void *data, int status)
+{
+    struct sol_flow_node *node = data;
+    struct update_data *mdata = sol_flow_node_get_private_data(node);
+
+    if (status < 0) {
+        sol_flow_send_error_packet(node, -status,
+            "Error while fetching update file: %s",
+            sol_util_strerrora(-status));
+    }
+
+    sol_flow_send_boolean_packet(node,
+        SOL_FLOW_NODE_TYPE_UPDATE_FETCH__OUT__SUCCESS, status == 0);
+
+    mdata->handle = NULL;
+}
+
+static int
+fetch_process(struct sol_flow_node *node, void *data, uint16_t port, uint16_t conn_id, const struct sol_flow_packet *packet)
+{
+    struct update_data *mdata = data;
+
+    if (mdata->handle) {
+        SOL_DBG("Fetch already in progress. Ignoring packet");
+        return 0;
+    }
+
+    mdata->handle = sol_update_fetch(fetch_cb, node, true);
+    if (!mdata->handle) {
+        sol_flow_send_error_packet(node, EINVAL, "Could not fetch update file");
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int
+install_open(struct sol_flow_node *node, void *data, const struct sol_flow_node_options *options)
+{
+    struct update_node_type *type;
+
+    type = (struct update_node_type *)sol_flow_node_get_type(node);
+    type->progress_port = SOL_FLOW_NODE_TYPE_UPDATE_INSTALL__OUT__PROGRESS;
+
+    return 0;
+}
+
+static int
+cancel_install_process(struct sol_flow_node *node, void *data, uint16_t port, uint16_t conn_id, const struct sol_flow_packet *packet)
+{
+    struct update_data *mdata = data;
+
+    if (mdata->handle) {
+        if (!sol_update_cancel(mdata->handle))
+            sol_flow_send_error_packet(node, EINVAL,
+                "Could not cancel install process");
+        else
+            mdata->handle = NULL;
+    } else {
+        SOL_WRN("No current install in process, ignoring request to cancel");
+    }
+
+    return 0;
+}
+
+static void
+install_cb(void *data, int status)
+{
+    struct sol_flow_node *node = data;
+    struct update_data *mdata = sol_flow_node_get_private_data(node);
+
+    if (status < 0) {
+        sol_flow_send_error_packet(node, -status,
+            "Error while installing update: %s", sol_util_strerrora(-status));
+    }
+
+    sol_flow_send_boolean_packet(node,
+        SOL_FLOW_NODE_TYPE_UPDATE_INSTALL__OUT__SUCCESS, status == 0);
+
+    mdata->handle = NULL;
+}
+
+static int
+install_process(struct sol_flow_node *node, void *data, uint16_t port, uint16_t conn_id, const struct sol_flow_packet *packet)
+{
+    struct update_data *mdata = data;
+
+    if (mdata->handle) {
+        SOL_DBG("Install already in progress. Ignoring packet");
+        return 0;
+    }
+
+    mdata->handle = sol_update_install(install_cb, node);
+    if (!mdata->handle) {
+        sol_flow_send_error_packet(node, EINVAL, "Could not install update file");
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int
+common_get_progress(struct sol_flow_node *node, void *data, uint16_t port, uint16_t conn_id, const struct sol_flow_packet *packet)
+{
+    struct update_data *mdata = data;
+    struct update_node_type *type;
+    struct sol_irange irange = {
+        .step = 1,
+        .min = 0,
+        .max = 100
+    };
+
+    type = (struct update_node_type *)sol_flow_node_get_type(node);
+
+    if (mdata->handle) {
+        irange.val = sol_update_get_progress(mdata->handle);
+        if (irange.val >= 0 && irange.val <= 100)
+            sol_flow_send_irange_packet(node, type->progress_port, &irange);
+        else
+            sol_flow_send_error_packet(node, EINVAL,
+                "Could not get progress of task");
+    } else {
+        SOL_DBG("No current operation in process, ignoring request to get progress");
+    }
+
+    return 0;
+}
+
+#include "update-gen.c"
diff --git a/src/modules/flow/update/update.json b/src/modules/flow/update/update.json
new file mode 100644
index 00000000..0ecb2e0a
--- /dev/null
+++ b/src/modules/flow/update/update.json
@@ -0,0 +1,178 @@
+{
+  "$schema": "http://solettaproject.github.io/soletta/schemas/node-type-genspec.schema",
+  "name": "update",
+  "meta": {
+    "author": "Intel Corporation",
+    "license": "BSD-3-Clause",
+    "version": "1"
+  },
+  "types": [
+    {
+      "category": "system/update",
+      "description": "Check if there's update available. How check is performed depends on current update module implementation. Outputs update file version and its size.",
+      "in_ports": [
+        {
+          "data_type": "any",
+          "description": "Start a check on current URL to see if update is available.",
+          "name": "CHECK",
+          "methods": {
+            "process": "check_process"
+          }
+        },
+        {
+          "data_type": "any",
+          "description": "Cancel an ongoing check operation. No output packets shall be sent, unless a new CHECK is issued",
+          "name": "CANCEL",
+          "methods": {
+            "process": "cancel_check_process"
+          }
+        },
+        {
+          "data_type": "any",
+          "description": "Causes task current progress to be sent to PROGRESS port",
+          "name": "GET_PROGRESS",
+          "methods": {
+            "process": "common_get_progress"
+          }
+        }
+      ],
+      "methods": {
+        "close": "common_close",
+        "open": "check_open"
+      },
+      "node_type": {
+        "access": [
+          "base"
+        ],
+        "data_type": "struct update_node_type"
+      },
+      "name": "update/check",
+      "out_ports": [
+        {
+          "data_type": "string",
+          "description": "Update version.",
+          "name": "VERSION"
+        },
+        {
+          "data_type": "int",
+          "description": "Update size, in bytes.",
+          "name": "SIZE"
+        },
+        {
+          "data_type": "int",
+          "description": "Current progress of task, a number between 0 and 100. An output of -1 indicates that current progress is not available",
+          "name": "PROGRESS"
+        }
+      ],
+      "private_data_type": "update_data"
+    },
+    {
+      "category": "system/update",
+      "description": "Fetch an update. If eveything goes well, it should output true on port SUCCESS.",
+      "in_ports": [
+        {
+          "data_type": "any",
+          "description": "Start fetching update.",
+          "name": "FETCH",
+          "methods": {
+            "process": "fetch_process"
+          }
+        },
+        {
+          "data_type": "any",
+          "description": "Cancel an ongoing fetch operation. No output packets shall be sent, unless a new FETCH is issued",
+          "name": "CANCEL",
+          "methods": {
+            "process": "cancel_fetch_process"
+          }
+        },
+        {
+          "data_type": "any",
+          "description": "Causes task current progress to be sent to PROGRESS port",
+          "name": "GET_PROGRESS",
+          "methods": {
+            "process": "common_get_progress"
+          }
+        }
+      ],
+      "methods": {
+        "close": "common_close",
+        "open": "fetch_open"
+      },
+      "node_type": {
+        "access": [
+          "base"
+        ],
+        "data_type": "struct update_node_type"
+      },
+      "name": "update/fetch",
+      "out_ports": [
+        {
+          "data_type": "boolean",
+          "description": "If FETCH was successfuly completed",
+          "name": "SUCCESS"
+        },
+        {
+          "data_type": "int",
+          "description": "Current progress of task, a number between 0 and 100. An output of -1 indicates that current progress is not available",
+          "name": "PROGRESS"
+        }
+      ],
+      "private_data_type": "update_data"
+    },
+    {
+      "category": "system/update",
+      "description": "Install update. Process of installing update depends on current underlying update module.",
+      "in_ports": [
+        {
+          "data_type": "any",
+          "description": "Cancel an ongoing install operation. Note that this is dependent on current underlying update module and may not be possible.",
+          "name": "CANCEL",
+          "methods": {
+            "process": "cancel_install_process"
+          }
+        },
+        {
+          "data_type": "any",
+          "description": "Causes task current progress to be sent to PROGRESS port",
+          "name": "GET_PROGRESS",
+          "methods": {
+            "process": "common_get_progress"
+          }
+        },
+        {
+          "data_type": "any",
+          "description": "Install update file.",
+          "name": "INSTALL",
+          "methods": {
+            "process": "install_process"
+          }
+        }
+      ],
+      "methods": {
+        "close": "common_close",
+        "open": "install_open"
+      },
+      "node_type": {
+        "access": [
+          "base"
+        ],
+        "data_type": "struct update_node_type"
+      },
+      "name": "update/install",
+      "out_ports": [
+        {
+          "data_type": "boolean",
+          "description": "If install completed successfuly, sends true, false otherwise. Note that errors packet may be sent in case of failure",
+          "name": "SUCCESS"
+        },
+        {
+          "data_type": "int",
+          "description": "Current progress of task, a number between 0 and 100. An output of -1 indicates that current progress is not available",
+          "name": "PROGRESS"
+        }
+      ],
+      "private_data_type": "update_data"
+    }
+  ]
+}