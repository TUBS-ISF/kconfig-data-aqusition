"2015-12-01 13:54:06 -0200"
diff --git a/src/lib/common/Kconfig b/src/lib/common/Kconfig
index 92b6448f..7265a147 100644
--- a/src/lib/common/Kconfig
+++ b/src/lib/common/Kconfig
@@ -343,3 +343,5 @@ endchoice
 menu "Hardware Options"
 source "src/lib/io/Kconfig"
 endmenu
+
+source "src/modules/update/Kconfig"
diff --git a/src/lib/common/Makefile b/src/lib/common/Makefile
index f159c69b..62df9713 100644
--- a/src/lib/common/Makefile
+++ b/src/lib/common/Makefile
@@ -85,6 +85,9 @@ obj-core-$(USE_PIN_MUX) += \
 obj-core-$(PLATFORM_LINUX) += \
 	sol-certificate-impl-linux.o
 
+obj-core-$(USE_UPDATE) += \
+    sol-update.o
+
 requires-private-$(MAINLOOP_GLIB) += \
     $(GLIB_REQUIRES_PRIVATE)
 
@@ -118,3 +121,7 @@ headers-$(WORKER_THREAD) += \
 
 headers-$(MAINLOOP_CONTIKI) += \
     include/sol-mainloop-contiki.h
+
+headers-$(USE_UPDATE) += \
+    include/sol-update.h \
+    include/sol-update-modules.h
diff --git a/src/lib/common/include/sol-mainloop.h b/src/lib/common/include/sol-mainloop.h
index d86905d9..eb5e9988 100644
--- a/src/lib/common/include/sol-mainloop.h
+++ b/src/lib/common/include/sol-mainloop.h
@@ -73,6 +73,7 @@ extern "C" {
  * @li @ref Platform
  * @li @ref PowerSupply
  * @li @ref Types
+ * @li @ref Update
  * @li @ref WorkerThread
  *
  * Please see the @ref authors page for contact details.
diff --git a/src/lib/common/include/sol-update-modules.h b/src/lib/common/include/sol-update-modules.h
new file mode 100644
index 00000000..c136166f
--- /dev/null
+++ b/src/lib/common/include/sol-update-modules.h
@@ -0,0 +1,150 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#pragma once
+
+#include <stdint.h>
+
+#include "sol-update.h"
+
+#include "sol-macros.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @file
+ * @brief Defines API that Soletta update modules need to implement.
+ */
+
+/**
+ * @defgroup UpdateModules Update modules
+ * @ingroup Update
+ *
+ * @{
+ */
+
+/**
+ * @brief Structure containing function that need to be implemented by Soletta
+ * update modules.
+ */
+struct sol_update {
+#ifndef SOL_NO_API_VERSION
+#define SOL_UPDATE_API_VERSION (1)
+    uint16_t api_version; /**< @brief API version */
+#endif
+
+    /**
+     * @brief Checks for updates.
+     *
+     * @see sol_update_check
+     */
+    struct sol_update_handle * (*check)(
+        void (*cb)(void *data, int status, const struct sol_update_info *response),
+        const void *data);
+
+    /**
+     * @brief Fetch updates.
+     *
+     * @see sol_update_fetch
+     */
+    struct sol_update_handle * (*fetch)(
+        void (*cb)(void *data, int status),
+        const void *data, bool resume);
+
+    /**
+     * @brief Cancel ongoing update tasks.
+     *
+     * @see sol_update_cancel
+     */
+    bool (*cancel)(struct sol_update_handle *handle);
+
+    /**
+     * @brief Get update task progress
+     *
+     * @see sol_update_get_progress
+     */
+    int (*get_progress)(struct sol_update_handle *handle);
+
+    /**
+     * @brief Install updates.
+     *
+     * @see sol_update_install
+     */
+    struct sol_update_handle * (*install)(void (*cb)(void *data, int status),
+        const void *data);
+
+    /**
+     * @brief Function called when module is loaded.
+     *
+     * An oportunity to do setup tasks, like checking if an update completed
+     * successfuly.
+     *
+     * Must return 0 on success, and a negative number on failure.
+     */
+    int (*init)(void);
+
+    /**
+     * @brief Function called when module is unloaded.
+     *
+     * Cleanup tasks can be performed when this function is called.
+     */
+    void (*shutdown)(void);
+};
+
+/**
+ * @def SOL_UPDATE_DECLARE(_NAME, decl ...)
+ * @brief Helper macro to declare a Soletta update module, so it can
+ * be found correctly
+ */
+#ifdef SOL_UPDATE_MODULE_EXTERNAL
+#define SOL_UPDATE_DECLARE(_NAME, decl ...) \
+    SOL_API const struct sol_update *SOL_UPDATE = \
+        &((const struct sol_update) { \
+            SOL_SET_API_VERSION(.api_version = SOL_UPDATE_API_VERSION, ) \
+            decl \
+        })
+#else
+#define SOL_UPDATE_DECLARE(_NAME, decl ...) \
+    SOL_API const struct sol_update SOL_UPDATE_ ## _NAME = { \
+        SOL_SET_API_VERSION(.api_version = SOL_UPDATE_API_VERSION, ) \
+        decl \
+    }
+#endif
+
+/**
+ * @}
+ */
+#ifdef __cplusplus
+}
+#endif
diff --git a/src/lib/common/include/sol-update.h b/src/lib/common/include/sol-update.h
new file mode 100644
index 00000000..fc35ad14
--- /dev/null
+++ b/src/lib/common/include/sol-update.h
@@ -0,0 +1,183 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#pragma once
+
+#include "sol-str-slice.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @file
+ * @brief Routines to update a Soletta app. Provide way to check, fetch and
+ * install updates
+ */
+
+/**
+ * @defgroup Update Update
+ *
+ * Updating a Soletta based app may vary depending on Soletta environment and
+ * configuration. For instance, updating a static Linux Micro (PID 1) Soletta
+ * based app is only a matter of replacing app file, but when using shared libs,
+ * may involve update/install newer versions of used libs. So, Soletta provides
+ * different update modules to update Soletta based apps on different scenarios.
+ * Soletta will try to use the first module it can use, but if having different
+ * modules to be loaded, environment variable SOL_UPDATE_MODULE can be used to
+ * define a specific one, like SOL_UPDATE_MODULE=linux-micro-efi-update.
+ *
+ * When Soletta update module cheks for update, it should get version
+ * and size of new file to fill @c sol_update_info.
+ *
+ * Each update module is free to decide how to check, fetch and install the
+ * update. Check update module documentation to understand how it works.
+ * Note also that comparing obtained version with app current version and
+ * deciding to fetch update file is up to user/developer.
+ *
+ * @{
+ */
+
+/**
+ * @struct sol_update_handle
+ *
+ * @brief Handle returned by some sol_update* calls, so they can be cancelled
+ * appropriately.
+ */
+struct sol_update_handle;
+
+/**
+ * @brief Contains update info got via @c sol_update_check call.
+ *
+ * @see sol_update_check
+ */
+struct sol_update_info {
+    const char *version; /**< @brief Current version of update file */
+    uint64_t size; /**< @brief Size of update file. Useful to warn user about big downloads. */
+};
+
+/**
+ * @brief Check if there's an update to get.
+ *
+ * Module must return a @c sol_update_info containing update size and version.
+ *
+ * @param cb callback that will be called to return update information.
+ * If status < 0, then something went wrong with check and @c response
+ * is undefined. If status == 0, check went OK and @c response argument
+ * shall contain obtained update information.
+ * @param data user defined data to be sent to callback @a cb
+ *
+ * @return handle of this update task, or NULL if couldn't start the task.
+ * Note that handle will be invalid after @a cb is called, or if it was cancelled.
+ *
+ * @see sol_update_cancel
+ */
+struct sol_update_handle *sol_update_check(
+    void (*cb)(void *data, int status, const struct sol_update_info *response),
+    const void *data);
+
+/**
+ * @brief Fetch update, so it can be installed later wit @c sol_update_install.
+ *
+ * Fetch will get the update. Update module should check its hash and
+ * signature before informing that task was completed successfuly.
+ * If everything is OK, callback @a cb will be called with status == 0.
+ *
+ * @param cb callback called to inform fetch completion or failure. If
+ * status < 0, then something went wrong. If status == 0, fetch went OK
+ * and @c sol_update_install can be used to install the update.
+ *
+ * @param data user specified data to be sent to callback @a cb
+ * @param resume NOT IMPLEMENTED. If false, any previous data downloaded
+ * shall be discarded. Otherwise, will resume a previous cancelled fetch.
+ *
+ * @return handle of this update task, or NULL if couldn't start the task.
+ * Note that handle will be invalid after @a cb is called, or if it was cancelled.
+ *
+ * @see sol_update_cancel
+ */
+struct sol_update_handle *sol_update_fetch(void (*cb)(void *data, int status),
+    const void *data, bool resume);
+
+/**
+ * @brief Install update.
+ *
+ * Install process vary depending on update module being used, but
+ * all shall give feedback of success or not on @a cb callback.
+ *
+ * @param cb callback called to inform installation success or failure.
+ * If status < 0, then something went wrong. If status == 0, installation
+ * completed successfuly.
+ * @param data user defined data to be passed to callback @a cb
+ *
+ * @return handle of this update task, or NULL if couldn't start the task.
+ * Note that handle will be invalid after @a cb is called, or if it was cancelled.
+ *
+ * @see sol_update_cancel
+ */
+struct sol_update_handle *sol_update_install(void (*cb)(void *data, int status),
+    const void *data);
+
+/**
+ * @brief Cancel an ongoing check, fetch or install task.
+ *
+ * Note that cancelling the task may not be possible at any moment, depending
+ * on update module being used.
+ *
+ * @param handle handle of update task to be cancelled.
+ *
+ * @return true if current task was successfuly cancelled.
+ *
+ * @note If cancel was successful, then @a handle becomes invalid. If not,
+ * task callback shall still be called.
+ */
+bool sol_update_cancel(struct sol_update_handle *handle);
+
+/**
+ * @brief Get progress of given update task.
+ *
+ * Note that getting the progress may not work for all tasks, depending
+ * on update module being used.
+ *
+ * @param handle handle of update task to get current progress.
+ *
+ * @return current progress of task between 0 and 100, or -1 if
+ * couldn't get progress.
+ */
+int sol_update_get_progress(struct sol_update_handle *handle);
+
+/**
+ * @}
+ */
+#ifdef __cplusplus
+}
+#endif
diff --git a/src/lib/common/sol-mainloop.c b/src/lib/common/sol-mainloop.c
index d8ae44a2..0fb1bf34 100644
--- a/src/lib/common/sol-mainloop.c
+++ b/src/lib/common/sol-mainloop.c
@@ -85,6 +85,10 @@ extern void sol_flow_shutdown(void);
 extern int sol_comms_init(void);
 extern void sol_comms_shutdown(void);
 #endif
+#ifdef USE_UPDATE
+extern int sol_update_init(void);
+extern void sol_update_shutdown(void);
+#endif
 
 static int _init_count;
 static bool mainloop_running;
@@ -139,12 +143,21 @@ sol_init(void)
         goto comms_error;
 #endif
 
+#ifdef USE_UPDATE
+    r = sol_update_init();
+    if (r < 0)
+        goto update_error;
+#endif
+
     SOL_DBG("Soletta %s on %s-%s initialized",
         sol_platform_get_sw_version(), BASE_OS,
         sol_platform_get_os_version());
 
     return 0;
 
+#ifdef USE_UPDATE
+update_error:
+#endif
 #ifdef NETWORK
 comms_error:
 #endif
@@ -234,6 +247,10 @@ sol_shutdown(void)
     sol_platform_shutdown();
     sol_mainloop_impl_shutdown();
     sol_modules_clear_cache();
+#ifdef USE_UPDATE
+    sol_update_shutdown();
+#endif
+
     sol_log_shutdown();
 }
 
diff --git a/src/lib/common/sol-update-builtins-gen.h.in b/src/lib/common/sol-update-builtins-gen.h.in
new file mode 100644
index 00000000..6d9e7744
--- /dev/null
+++ b/src/lib/common/sol-update-builtins-gen.h.in
@@ -0,0 +1,9 @@
+{{
+st.include("../../../data/templates/builtins-common.tpl")
+
+array = "static const struct sol_update *SOL_UPDATE_BUILTINS_ALL[]"
+count = "SOL_UPDATE_BUILTIN_COUNT"
+decl = "const struct sol_update SOL_UPDATE_@NAME@"
+item = "&SOL_UPDATE_@NAME@"
+gen_builtins(decl, item, array, count, "builtins-update")
+}}
diff --git a/src/lib/common/sol-update.c b/src/lib/common/sol-update.c
new file mode 100644
index 00000000..41780b77
--- /dev/null
+++ b/src/lib/common/sol-update.c
@@ -0,0 +1,239 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <dirent.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+
+#include "sol-log-internal.h"
+
+#include "sol-lib-loader.h"
+#include "sol-update.h"
+#include "sol-update-modules.h"
+#include "sol-update-builtins-gen.h"
+#include "sol-util.h"
+#include "sol-util-file.h"
+
+SOL_LOG_INTERNAL_DECLARE(_sol_update_log_domain, "update");
+
+static struct sol_lib_loader *update_module_loader;
+static const struct sol_update *update_module;
+
+int sol_update_init(void);
+void sol_update_shutdown(void);
+
+#if (SOL_UPDATE_BUILTIN_COUNT == 0) && defined ENABLE_DYNAMIC_MODULES
+static bool
+check_module(const char *path, const char *symbol_name, void *symbol)
+{
+    const struct sol_update **p_update;
+
+    p_update = symbol;
+
+    SOL_NULL_CHECK_MSG(*p_update, false, "Symbol [%s] in module [%s] is NULL",
+        symbol_name, path);
+
+#ifndef SOL_NO_API_VERSION
+    if ((*p_update)->api_version != SOL_UPDATE_API_VERSION) {
+        SOL_WRN("Module [%s] has incorrect api_version: %u expected %u", path,
+            (*p_update)->api_version, SOL_UPDATE_API_VERSION);
+        return false;
+    }
+#endif
+
+    return true;
+}
+
+static bool
+iterate_dir_cb(void *data, const char *dir_path, struct dirent *ent)
+{
+    size_t len;
+    char **result = data;
+
+    len = strlen(ent->d_name);
+
+    /* Return anything that finishes in '.so'*/
+    if (len > 3) {
+        if (streq((ent->d_name + (len - 3)), ".so")) {
+            *result = strndup(ent->d_name, len - 3);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+static char *
+get_first_module_on_dir(const char *dir_name)
+{
+    char *result;
+    char path[PATH_MAX], install_rootdir[PATH_MAX];
+    struct stat st;
+    int r;
+
+    r = sol_util_get_rootdir(install_rootdir, sizeof(install_rootdir));
+    SOL_INT_CHECK(r, >= (int)sizeof(install_rootdir), NULL);
+    SOL_INT_CHECK(r, < 0, NULL);
+
+    r = snprintf(path, sizeof(path), "%s%s", install_rootdir, dir_name);
+    SOL_INT_CHECK(r, >= (int)sizeof(path), NULL);
+    SOL_INT_CHECK(r, < 0, NULL);
+
+    if (stat(path, &st) || !S_ISDIR(st.st_mode)) {
+        SOL_DBG("Invalid update module dir: %s", path);
+        return NULL;
+    }
+
+    if (!sol_util_iterate_dir(path, iterate_dir_cb, &result))
+        return NULL;
+
+    return result;
+}
+#endif
+
+static bool
+load_update_module(void)
+{
+#if (SOL_UPDATE_BUILTIN_COUNT > 0)
+    update_module = SOL_UPDATE_BUILTINS_ALL[0];
+#elif defined ENABLE_DYNAMIC_MODULES
+    void *symbol;
+    const char *update_module_name = getenv("SOL_UPDATE_MODULE");
+    char *name_to_free = NULL;
+
+    if (!update_module_loader) {
+        update_module_loader = sol_lib_loader_new_in_rootdir(
+            UPDATEMODULESDIR, "SOL_UPDATE", check_module);
+        SOL_NULL_CHECK(update_module_loader, false);
+    }
+
+    if (!update_module_name || strlen(update_module_name) == 0) {
+        name_to_free = get_first_module_on_dir(UPDATEMODULESDIR);
+        update_module_name = name_to_free;
+    }
+    if (!update_module_name) {
+        SOL_DBG("No update module to load");
+        return true; /* Not having an update module is not an error */
+    }
+
+    symbol = sol_lib_load(update_module_loader, update_module_name);
+    free(name_to_free);
+    if (!symbol) {
+        SOL_DBG("No update module found");
+        return true; /* Not having an update module is not an error */
+    }
+
+    update_module = *(const struct sol_update **)symbol;
+    if (!update_module)
+        return false;
+#endif
+    return true;
+}
+
+int
+sol_update_init(void)
+{
+    sol_log_domain_init_level(SOL_LOG_DOMAIN);
+
+    if (!load_update_module()) {
+        SOL_WRN("Could not initialise update module");
+        return -1;
+    }
+
+    if (update_module && update_module->init)
+        return update_module->init();
+
+    return 0;
+}
+
+void
+sol_update_shutdown(void)
+{
+    SOL_DBG("Update shutdown");
+
+    if (update_module && update_module->shutdown)
+        update_module->shutdown();
+
+    sol_lib_loader_del(update_module_loader);
+}
+
+SOL_API struct sol_update_handle *
+sol_update_check(
+    void (*cb)(void *data, int status, const struct sol_update_info *response),
+    const void *data)
+{
+    SOL_NULL_CHECK_MSG(update_module, NULL, "No update module found");
+    SOL_NULL_CHECK_MSG(update_module->check, NULL, "No check function on update module");
+
+    return update_module->check(cb, data);
+}
+
+SOL_API struct sol_update_handle *
+sol_update_fetch(void (*cb)(void *data, int status),
+    const void *data, bool resume)
+{
+    SOL_NULL_CHECK_MSG(update_module, NULL, "No update module found");
+    SOL_NULL_CHECK_MSG(update_module->fetch, NULL, "No fetch function on update module");
+
+    return update_module->fetch(cb, data, resume);
+}
+
+/* TODO should a cancel remove downloaded stuff? Shall we have a pause?
+ * Shall we allow cancelling of 'install'? */
+SOL_API bool
+sol_update_cancel(struct sol_update_handle *handle)
+{
+    SOL_NULL_CHECK_MSG(update_module, false, "No update module found");
+    SOL_NULL_CHECK_MSG(update_module->cancel, false, "No cancel function on update module");
+
+    return update_module->cancel(handle);
+}
+
+SOL_API int
+sol_update_get_progress(struct sol_update_handle *handle)
+{
+    SOL_NULL_CHECK_MSG(update_module, -EINVAL, "No update module found");
+    SOL_NULL_CHECK_MSG(update_module->get_progress, -ENOTSUP, "No progress function on update module");
+
+    return update_module->get_progress(handle);
+}
+
+SOL_API struct sol_update_handle *
+sol_update_install(void (*cb)(void *data, int status), const void *data)
+{
+    SOL_NULL_CHECK_MSG(update_module, NULL, "No update module found");
+    SOL_NULL_CHECK_MSG(update_module->install, NULL, "No install function on update module");
+
+    return update_module->install(cb, data);
+}
diff --git a/src/modules/update/Kconfig b/src/modules/update/Kconfig
new file mode 100644
index 00000000..eeb90201
--- /dev/null
+++ b/src/modules/update/Kconfig
@@ -0,0 +1,11 @@
+menuconfig USE_UPDATE
+    bool "Update Options"
+    default y
+    help
+        Allow Soletta built apps to be updated automatically.
+
+        Soletta can check if there is an update available and update itself.
+        Different update modules are provided for different Soletta
+        app scenarios.
+
+source "src/modules/update/linux-micro-efi/Kconfig"
diff --git a/src/modules/update/linux-micro-efi/Kconfig b/src/modules/update/linux-micro-efi/Kconfig
new file mode 100644
index 00000000..2fedeb20
--- /dev/null
+++ b/src/modules/update/linux-micro-efi/Kconfig
@@ -0,0 +1,48 @@
+config LINUX_MICRO_EFI_UPDATE
+    tristate "Soletta Linux Micro EFI Update"
+    depends on USE_UPDATE && PLATFORM_LINUX_MICRO && HTTP_CLIENT && CRYPTO_MESSAGE_DIGEST
+    default m if MODULES=y
+    help
+        Allows Soletta auto update when it is running as static PID 1 (Linux
+        Micro) on EFI systems. To completely use this module to update Soletta,
+        it's necessary that device boots via EFI script startup.nsh.
+        This script should also check the existence of an 'updating' file
+        on boot partition (usually 'fs0:'), that update module will write there
+        to indicate that an update happened. It's up to this script to decide
+        if update was successful or not. If not, it shall start old Soletta app,
+        usually '/usr/bin/soletta_old'.
+        An example of such script is provided on samples/flow/update/startup.nsh.
+
+
+config LINUX_MICRO_EFI_UPDATE_META_URL
+    string "Linux Micro EFI Update Metadata URL"
+    depends on LINUX_MICRO_EFI_UPDATE
+    default "http://localhost/update-meta"
+    help
+        URL to get update information. It must return a JSON containing the
+        fields "version", "hash", "hash-algorithm" and "size", like:
+        {
+            "version": "0.1.2",
+            "hash": "402c09cded5f597c94f90d1b77c04422628678f69f6f56786053c8c59450c1da"
+            "hash-algorithm": sha256,
+            "size": 369874
+        }
+
+config LINUX_MICRO_EFI_UPDATE_FETCH_URL
+    string "Linux Micro EFI Update Fetch URL"
+    depends on LINUX_MICRO_EFI_UPDATE
+    default "http://localhost:8000/file"
+    help
+        URL to fetch update file. Version name will be appended to it, so
+        the real query would look like "http://localhost:8000/file/0.1.2".
+
+config LINUX_MICRO_EFI_UPDATE_APP_PATH
+    string "Path where application is located"
+    depends on LINUX_MICRO_EFI_UPDATE
+    default "/usr/bin/soletta"
+    help
+        Path where application is located. Update module will install new
+        version by overwriting this location with new file - but before, it
+        will create an "LINUX_MICRO_EFI_UPDATE_APP_PATH-old" backup file.
+        Note that 'startup.nsh' needs to agree where application file is
+        located.
diff --git a/src/modules/update/linux-micro-efi/Makefile b/src/modules/update/linux-micro-efi/Makefile
new file mode 100644
index 00000000..0e0d5edb
--- /dev/null
+++ b/src/modules/update/linux-micro-efi/Makefile
@@ -0,0 +1,11 @@
+obj-$(LINUX_MICRO_EFI_UPDATE) += linux-micro-efi-update.mod
+
+obj-linux-micro-efi-update-$(LINUX_MICRO_EFI_UPDATE) += \
+	../update-common/http.o \
+	../update-common/file.o \
+	linux-micro-efi-update.o
+
+obj-linux-micro-efi-update-$(LINUX_MICRO_EFI_UPDATE)-extra-cflags += \
+	-I$(top_srcdir)src/modules/update
+
+obj-linux-micro-efi-update-$(LINUX_MICRO_EFI_UPDATE)-type := update
diff --git a/src/modules/update/linux-micro-efi/linux-micro-efi-update.c b/src/modules/update/linux-micro-efi/linux-micro-efi-update.c
new file mode 100644
index 00000000..05d0da35
--- /dev/null
+++ b/src/modules/update/linux-micro-efi/linux-micro-efi-update.c
@@ -0,0 +1,575 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define SOL_LOG_DOMAIN &_log_domain
+#include "sol-log-internal.h"
+SOL_LOG_INTERNAL_DECLARE_STATIC(_log_domain, "linux-micro-efi-update");
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "update-common/file.h"
+#include "update-common/http.h"
+
+#include "sol-buffer.h"
+#include "sol-http.h"
+#include "sol-json.h"
+#include "sol-mainloop.h"
+#include "sol-update.h"
+#include "sol-update-modules.h"
+#include "sol-util.h"
+#include "sol-vector.h"
+
+#define SOL_UPDATE_FILE_NAME "sol-update-file"
+#define BACKUP_SUFFIX "_old"
+
+enum task {
+    TASK_CHECK,
+    TASK_FETCH,
+    TASK_UPDATE
+};
+
+enum fetch_task {
+    FETCH_DOWNLOAD = 0,
+    FETCH_CHECK_HASH = 50
+};
+
+struct sol_update_handle {
+    enum task task;
+    enum fetch_task fetch_task;
+    struct update_http_handle *http_handle;
+    struct update_check_hash_handle *check_hash_handle;
+    FILE *file;
+    struct sol_timeout *timeout;
+    char *hash;
+    char *hash_algorithm;
+
+    union {
+        void (*cb_check)(void *data, int status, const struct sol_update_info *response);
+        void (*cb_fetch)(void *data, int status);
+        void (*cb_install)(void *data, int status);
+    };
+    const void *user_data;
+
+    size_t size;
+
+    bool on_callback : 1;
+    bool resume : 1;
+};
+
+static char *update_fetch_url;
+static char *update_meta_url;
+static char *soletta_exec_file_path;
+
+static struct sol_ptr_vector handles = SOL_PTR_VECTOR_INIT;
+
+static void
+delete_handle(struct sol_update_handle *handle)
+{
+    free(handle->hash);
+    free(handle->hash_algorithm);
+    if (handle->http_handle)
+        http_cancel(handle->http_handle);
+    sol_ptr_vector_remove(&handles, handle);
+    free(handle);
+}
+
+static bool
+install_timeout(void *data)
+{
+    struct sol_update_handle *handle = data;
+    struct st;
+    char *backup_path = NULL;
+    int r;
+
+    handle->timeout = NULL;
+    handle->on_callback = true;
+
+    r = asprintf(&backup_path, "%s%s", soletta_exec_file_path, BACKUP_SUFFIX);
+    if (r < 0) {
+        SOL_WRN("Could not create backup file name: %s",
+            sol_util_strerrora(errno));
+        backup_path = NULL;
+        goto end;
+    }
+
+    r = rename(soletta_exec_file_path, backup_path);
+    if (r < 0) {
+        /* If there's no current file - i.e., a failed update happened before
+         * Let's just write a new one. */
+        if (errno != ENOENT) {
+            SOL_WRN("Could not create backup file: %s", sol_util_strerrora(errno));
+            goto end;
+        }
+    }
+
+    /* We create an 'updating' file on /boot, so EFI startup.nsh knows that
+     * we are updating. It will then create 'check_update' file there, and
+     * remove 'updating'.
+     * Once we restart soletta, we erase 'check-update' if we are not
+     * 'SOLETTA_EXEC_FILE_OLD', which means that update failed */
+    if (sol_util_write_file("/boot/updating", "1") < 0) {
+        SOL_WRN("Could not create '/boot/updating' guard file");
+        goto end;
+    }
+
+    r = sol_util_move_file(SOL_UPDATE_FILE_NAME, soletta_exec_file_path,
+        S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH | S_IXUSR | S_IXGRP | S_IXOTH);
+    if (r < 0) {
+        SOL_WRN("Could not install update file: %s", sol_util_strerrora(errno));
+        goto end;
+    }
+
+    errno = 0;
+
+end:
+    handle->cb_install((void *)handle->user_data, -errno);
+    delete_handle(handle);
+    free(backup_path);
+
+    return false;
+}
+
+static struct sol_update_handle *
+install(void (*cb)(void *data, int status), const void *data)
+{
+    struct sol_update_handle *handle;
+
+    SOL_NULL_CHECK(cb, NULL);
+
+    handle = calloc(1, sizeof(struct sol_update_handle));
+    SOL_NULL_CHECK(handle, NULL);
+
+    handle->task = TASK_UPDATE;
+    handle->cb_install = cb;
+    handle->user_data = data;
+
+    handle->timeout = sol_timeout_add(0, install_timeout, handle);
+    SOL_NULL_CHECK_MSG_GOTO(handle->timeout, err, "Could not create timeout");
+
+    return handle;
+
+err:
+    free(handle);
+
+    return NULL;
+}
+
+static void
+check_post_install(void)
+{
+    char *cmdline = NULL, *backup_path = NULL;
+    int r;
+
+    r = asprintf(&backup_path, "%s%s", soletta_exec_file_path, BACKUP_SUFFIX);
+    SOL_INT_CHECK(r, <= 0);
+
+    r = sol_util_read_file("/proc/self/cmdline", "%ms", &cmdline);
+    SOL_INT_CHECK_GOTO(r, <= 0, end);
+
+    if (strstartswith(cmdline, backup_path)) {
+        SOL_WRN("Running backuped Soletta. Failed update?");
+        goto end;
+    }
+
+    unlink("/boot/check-update");
+
+end:
+    free(cmdline);
+    free(backup_path);
+}
+
+static void
+check_hash_cb(void *data, int status)
+{
+    struct sol_update_handle *handle = data;
+
+    handle->check_hash_handle = NULL;
+
+    handle->cb_fetch((void *)handle->user_data, status);
+
+    fclose(handle->file);
+    delete_handle(handle);
+}
+
+static void
+fetch_end_cb(void *data, int status)
+{
+    struct sol_update_handle *handle = data;
+    int fd;
+
+    handle->http_handle = NULL;
+    handle->on_callback = true;
+
+    if (status != SOL_HTTP_STATUS_OK) {
+        SOL_WRN("Failure getting update file, connection returned: %d", status);
+        errno = EINVAL;
+        goto err;
+    }
+
+    if (fflush(handle->file) != 0) {
+        SOL_WRN("Could not write temporary file: %s", sol_util_strerrora(errno));
+        goto err;
+    }
+
+    /* Sync file contents to storage */
+    fd = fileno(handle->file);
+
+    if (fsync(fd) < 0) {
+        SOL_WRN("Could not ensure temporary file is synced to storage: %s",
+            sol_util_strerrora(errno));
+        goto err;
+    }
+
+    /* Check hash */
+    handle->fetch_task = FETCH_CHECK_HASH;
+    handle->check_hash_handle = check_file_hash(handle->file, handle->hash,
+        handle->hash_algorithm, check_hash_cb, handle);
+    SOL_NULL_CHECK_MSG_GOTO(handle->check_hash_handle, err,
+        "Could not check hash of downloaded file");
+
+    /* TODO fetch should also verify a file signature, to be sure that we
+     * downloaded the file from a trusted source */
+
+    handle->on_callback = false;
+
+    return;
+
+err:
+    fclose(handle->file);
+    handle->cb_fetch((void *)handle->user_data, -errno);
+    delete_handle(handle);
+}
+
+static void
+fetch_recv_cb(void *data, struct sol_buffer *buffer)
+{
+    struct sol_update_handle *handle = data;
+    int fd;
+
+    if (!handle->file) {
+        fd = open(SOL_UPDATE_FILE_NAME, O_CREAT | O_RDWR | O_CLOEXEC,
+            S_IRUSR | S_IWUSR);
+        if (fd < 0) {
+            SOL_WRN("Could not create temporary file: %s",
+                sol_util_strerrora(errno));
+            goto err_create;
+        }
+        /* Don't care about errors, as this is more 'nice to have' than a must */
+        /* TODO should I care about EINTR, though? */
+        ftruncate(fd, handle->size);
+        handle->file = fdopen(fd, "w+e");
+        if (!handle->file) {
+            SOL_WRN("Could not create temporary file: %s",
+                sol_util_strerrora(errno));
+            close(fd);
+            goto err_create;
+        }
+    }
+
+    fwrite(buffer->data, 1, buffer->used, handle->file);
+    if (ferror(handle->file)) {
+        SOL_WRN("Could not write temporary file");
+        goto err_write;
+    }
+
+    return;
+
+err_write:
+    fclose(handle->file);
+err_create:
+    handle->on_callback = true;
+    handle->cb_fetch((void *)handle->user_data, -EINVAL);
+    delete_handle(handle);
+}
+
+static void
+meta_cb(void *data, int status, const struct sol_buffer *meta)
+{
+    struct sol_update_handle *handle = data;
+    struct sol_json_scanner scanner;
+    struct sol_json_token token, key, value;
+    enum sol_json_loop_reason reason;
+    char *fetch_url = NULL, *version = NULL;
+    int r;
+
+    handle->http_handle = NULL;
+
+    SOL_NULL_CHECK_MSG_GOTO(meta, err,
+        "Could not get meta information about update");
+
+    sol_json_scanner_init(&scanner, meta->data, meta->used);
+    SOL_JSON_SCANNER_OBJECT_LOOP (&scanner, &token, &key, &value, reason) {
+        if (SOL_JSON_TOKEN_STR_LITERAL_EQ(&key, "hash"))
+            handle->hash = sol_json_token_get_unescaped_string_copy(&value);
+        else if (SOL_JSON_TOKEN_STR_LITERAL_EQ(&key, "hash-algorithm"))
+            handle->hash_algorithm = sol_json_token_get_unescaped_string_copy(&value);
+        else if (SOL_JSON_TOKEN_STR_LITERAL_EQ(&key, "version"))
+            version = sol_json_token_get_unescaped_string_copy(&value);
+        else if (SOL_JSON_TOKEN_STR_LITERAL_EQ(&key, "size")) {
+            if (sol_json_token_get_uint64(&value, &handle->size) != 0)
+                SOL_WRN("Could not get size of update file");
+        } else
+            SOL_WRN("Unknown response member: %.*s",
+                SOL_STR_SLICE_PRINT(sol_json_token_to_slice(&token)));
+    }
+
+    if (!handle->hash || !handle->hash_algorithm || !version) {
+        SOL_WRN("Malformed response of meta information");
+        goto err;
+    }
+
+    r = asprintf(&fetch_url, "%s/%s", update_fetch_url, version);
+    SOL_INT_CHECK_GOTO(r, < 0, err);
+
+    handle->http_handle = http_fetch(fetch_url, fetch_recv_cb,
+        fetch_end_cb, handle, handle->resume);
+    SOL_NULL_CHECK_MSG_GOTO(handle->http_handle, err,
+        "Could not create HTTP connection to fetch update");
+
+    free(version);
+    free(fetch_url);
+
+    return;
+
+err:
+    handle->cb_fetch((void *)handle->user_data, -EINVAL);
+    delete_handle(handle);
+    free(version);
+    free(fetch_url);
+}
+
+static struct sol_update_handle *
+fetch(void (*cb)(void *data, int status), const void *data, bool resume)
+{
+    struct sol_update_handle *handle;
+
+    handle = calloc(1, sizeof(struct sol_update_handle));
+    SOL_NULL_CHECK(handle, NULL);
+    handle->cb_fetch = cb;
+    handle->user_data = data;
+    handle->resume = resume;
+    handle->task = TASK_FETCH;
+    handle->fetch_task = FETCH_DOWNLOAD;
+
+    if (sol_ptr_vector_append(&handles, handle))
+        goto err_append;
+
+    /* First, let's get hash and hash-algorithm */
+    handle->http_handle = http_get_metadata(update_meta_url, meta_cb, handle);
+    SOL_NULL_CHECK_MSG_GOTO(handle->http_handle, err_http,
+        "Could not create HTTP connection to get information about update");
+
+    return handle;
+
+err_http:
+    sol_ptr_vector_del_last(&handles);
+err_append:
+    free(handle);
+    return NULL;
+}
+
+static void
+check_cb(void *data, int status, const struct sol_buffer *meta)
+{
+    struct sol_update_handle *handle = data;
+    struct sol_update_info response = { };
+
+    handle->on_callback = true;
+    handle->http_handle = NULL;
+
+    if (status < 0) {
+        handle->cb_check((void *)handle->user_data, status, NULL);
+    } else {
+        if (!metadata_to_update_info(meta, &response))
+            handle->cb_check((void *)handle->user_data, -EINVAL, NULL);
+        else
+            handle->cb_check((void *)handle->user_data, 0, &response);
+    }
+
+    free((char *)response.version);
+
+    delete_handle(handle);
+}
+
+static struct sol_update_handle *
+check(void (*cb)(void *data, int status, const struct sol_update_info *response),
+    const void *data)
+{
+    struct sol_update_handle *handle;
+
+    handle = calloc(1, sizeof(struct sol_update_handle));
+    SOL_NULL_CHECK(handle, NULL);
+    handle->cb_check = cb;
+    handle->user_data = data;
+    handle->task = TASK_CHECK;
+
+    if (sol_ptr_vector_append(&handles, handle))
+        goto err_append;
+
+    handle->http_handle = http_get_metadata(update_meta_url, check_cb, handle);
+    SOL_NULL_CHECK_MSG_GOTO(handle->http_handle, err_http,
+        "Could not create HTTP connection to check for update");
+
+    return handle;
+
+err_http:
+    sol_ptr_vector_del_last(&handles);
+err_append:
+    free(handle);
+    return NULL;
+}
+
+static bool
+cancel(struct sol_update_handle *handle)
+{
+    bool b = false;
+
+    if (handle->http_handle)
+        b = http_cancel(handle->http_handle);
+    else if (handle->check_hash_handle)
+        b = cancel_check_file_hash(handle->check_hash_handle);
+
+    if (b)
+        delete_handle(handle);
+
+    return b;
+}
+
+static int
+get_progress(struct sol_update_handle *handle)
+{
+    if (handle->task == TASK_FETCH) {
+        /* Divide task into two subtasks, so progress can account for
+         * download and check. */
+        if (handle->size && handle->file) {
+            long position = ftell(handle->file) / 2;
+            float progress = (float)position / (float)handle->size;
+            return (int)(progress * 100.0) + handle->fetch_task;
+        }
+        return 0;
+    }
+    return -1;
+}
+
+static int
+init(void)
+{
+    SOL_LOG_INTERNAL_INIT_ONCE;
+
+    update_fetch_url = getenv("SOL_UPDATE_FETCH_URL");
+    if (update_fetch_url)
+        update_fetch_url = strdup(update_fetch_url);
+
+#ifdef LINUX_MICRO_EFI_UPDATE_FETCH_URL
+    if (!update_fetch_url && strlen(LINUX_MICRO_EFI_UPDATE_FETCH_URL))
+        update_fetch_url = strdup(LINUX_MICRO_EFI_UPDATE_FETCH_URL);
+#endif
+
+    update_meta_url = getenv("SOL_UPDATE_META_URL");
+    if (update_meta_url)
+        update_meta_url = strdup(update_meta_url);
+
+#ifdef LINUX_MICRO_EFI_UPDATE_META_URL
+    if (!update_meta_url && strlen(LINUX_MICRO_EFI_UPDATE_META_URL))
+        update_meta_url = strdup(LINUX_MICRO_EFI_UPDATE_META_URL);
+#endif
+
+    soletta_exec_file_path = getenv("SOL_APP_FILE_PATH");
+    if (soletta_exec_file_path)
+        soletta_exec_file_path = strdup(soletta_exec_file_path);
+
+#ifdef LINUX_MICRO_EFI_UPDATE_APP_PATH
+    if (!soletta_exec_file_path && strlen(LINUX_MICRO_EFI_UPDATE_APP_PATH))
+        soletta_exec_file_path = strdup(LINUX_MICRO_EFI_UPDATE_APP_PATH);
+#endif
+    SOL_NULL_CHECK_MSG_GOTO(update_meta_url, err,
+        "No valid URL to get update metadata. Missing build config or "
+        "export SOL_UPDATE_META_URL='URL'?");
+
+    SOL_NULL_CHECK_MSG_GOTO(update_fetch_url, err,
+        "No valid URL to fetch updates. Missing build config or "
+        "export SOL_UPDATE_FETCH_URL='URL'?");
+
+    SOL_NULL_CHECK_MSG_GOTO(soletta_exec_file_path, err,
+        "No path of Soletta application. Missing build config or "
+        "export SOL_APP_FILE_PATH='PATH'?");
+
+    SOL_DBG("Using followings URLs to get update:\n"
+        "Application path: %s\n"
+        "Meta URL: %s\n"
+        "Fetch URL: %s",
+        soletta_exec_file_path, update_meta_url, update_fetch_url);
+
+    check_post_install();
+
+    return 0;
+
+err:
+    free(update_meta_url);
+    free(update_fetch_url);
+    free(soletta_exec_file_path);
+
+    return -EINVAL;
+}
+
+static void
+shutdown(void)
+{
+    struct sol_update_handle *handle;
+    int i;
+
+    SOL_PTR_VECTOR_FOREACH_IDX (&handles, handle, i) {
+        /* Try to cancel pending tasks, if fail, free handles. */
+        if (!sol_update_cancel(handle))
+            delete_handle(handle);
+    }
+    sol_ptr_vector_clear(&handles);
+
+    free(update_meta_url);
+    free(update_fetch_url);
+    free(soletta_exec_file_path);
+}
+
+SOL_UPDATE_DECLARE(LINUX_MICRO_EFI_UPDATE,
+    .check = check,
+    .fetch = fetch,
+    .cancel = cancel,
+    .get_progress = get_progress,
+    .install = install,
+    .init = init,
+    .shutdown = shutdown
+    );
diff --git a/src/modules/update/update-common/file.c b/src/modules/update/update-common/file.c
new file mode 100644
index 00000000..085bfbe8
--- /dev/null
+++ b/src/modules/update/update-common/file.c
@@ -0,0 +1,199 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "file.h"
+
+#include "sol-buffer.h"
+#include "sol-log.h"
+#include "sol-message-digest.h"
+#include "sol-util.h"
+#include "sol-util-file.h"
+
+struct update_check_hash_handle {
+    struct sol_message_digest *md;
+    FILE *file;
+    char *hash;
+    char *hash_algorithm;
+    void (*cb)(void *data, int status);
+    const void *user_data;
+};
+
+static void
+delete_handle(struct update_check_hash_handle *handle)
+{
+    free(handle->hash);
+    free(handle->hash_algorithm);
+    free(handle);
+}
+
+static void
+on_digest_ready_cb(void *data, struct sol_message_digest *md, struct sol_blob *output)
+{
+    struct update_check_hash_handle *handle = data;
+    struct sol_buffer buffer = SOL_BUFFER_INIT_EMPTY;
+    struct sol_str_slice slice = sol_str_slice_from_blob(output);
+    int r = 0;
+
+    r = sol_buffer_append_as_base16(&buffer, slice, false);
+    SOL_INT_CHECK_GOTO(r, < 0, end);
+
+    if (!streq(buffer.data, handle->hash)) {
+
+        r = -EINVAL;
+        SOL_WRN("Expected hash differs of file hash, expected [%s], found [%.*s]",
+            handle->hash, (int)buffer.used, (char *)buffer.data);
+    }
+
+end:
+    handle->cb((void *)handle->user_data, r);
+    sol_message_digest_del(md);
+    sol_buffer_fini(&buffer);
+    delete_handle(handle);
+}
+
+static void
+on_feed_done_cb(void *data, struct sol_message_digest *md, struct sol_blob *input)
+{
+    struct update_check_hash_handle *handle = data;
+    char buf[CHUNK_SIZE], *blob_backend = NULL;
+    struct sol_blob *blob = NULL;
+    size_t size;
+    bool last;
+    int r;
+
+    size = fread(buf, 1, sizeof(buf), handle->file);
+    if (ferror(handle->file)) {
+        SOL_WRN("Could not read file for feed hash algorithm");
+        goto err;
+    }
+
+    last = feof(handle->file);
+
+    /* TODO Maybe this is a bug on sol_message_digest? Keeps calling on_feed_done
+     * after send last chunk */
+    if (!size && last && input) {
+        SOL_WRN("Nothing more to feed hash algorithm, ignoring on_feed_done request");
+        return;
+    }
+
+    blob_backend = malloc(size);
+    SOL_NULL_CHECK_GOTO(blob_backend, err);
+
+    blob = sol_blob_new(SOL_BLOB_TYPE_DEFAULT, NULL, blob_backend, size);
+    SOL_NULL_CHECK_GOTO(blob, err);
+
+    memcpy(blob_backend, buf, size);
+
+    r = sol_message_digest_feed(md, blob, last);
+    SOL_INT_CHECK_GOTO(r, < 0, err);
+
+    sol_blob_unref(blob);
+    return;
+
+err:
+    SOL_WRN("Could not feed data to check update file hash");
+    free(blob_backend);
+    sol_blob_unref(blob);
+    sol_message_digest_del(md);
+    handle->cb((void *)handle->user_data, -EINVAL);
+    delete_handle(handle);
+}
+
+struct update_check_hash_handle *
+check_file_hash(FILE *file, const char *hash, const char *hash_algorithm,
+    void (*cb)(void *data, int status), const void *data)
+{
+    struct sol_message_digest_config cfg = {
+        SOL_SET_API_VERSION(.api_version = SOL_MESSAGE_DIGEST_CONFIG_API_VERSION, )
+        .algorithm = hash_algorithm,
+        .on_digest_ready = on_digest_ready_cb,
+        .on_feed_done = on_feed_done_cb,
+    };
+    struct sol_message_digest *md;
+    struct update_check_hash_handle *handle;
+
+    SOL_NULL_CHECK(file, NULL);
+    SOL_NULL_CHECK(hash, NULL);
+    SOL_NULL_CHECK(hash_algorithm, NULL);
+    SOL_NULL_CHECK(cb, NULL);
+
+    handle = calloc(1, sizeof(struct update_check_hash_handle));
+    SOL_NULL_CHECK(handle, NULL);
+    cfg.data = handle;
+
+    handle->file = file;
+
+    handle->hash = strdup(hash);
+    SOL_NULL_CHECK_GOTO(handle->hash, err);
+    handle->hash_algorithm = strdup(hash_algorithm);
+    SOL_NULL_CHECK_GOTO(handle->hash_algorithm, err);
+    handle->user_data = data;
+
+    md = sol_message_digest_new(&cfg);
+    SOL_NULL_CHECK_GOTO(md, err);
+
+    handle->md = md;
+
+    rewind(file);
+    handle->cb = cb;
+
+    /* Start feeding */
+    on_feed_done_cb(handle, md, NULL);
+
+    return handle;
+
+err:
+    free(handle->hash);
+    free(handle->hash_algorithm);
+    free(handle);
+
+    return NULL;
+}
+
+bool
+cancel_check_file_hash(struct update_check_hash_handle *handle)
+{
+    if (handle->md)
+        sol_message_digest_del(handle->md);
+
+    delete_handle(handle);
+
+    return true;
+}
diff --git a/src/modules/update/update-common/file.h b/src/modules/update/update-common/file.h
new file mode 100644
index 00000000..5c0c61eb
--- /dev/null
+++ b/src/modules/update/update-common/file.h
@@ -0,0 +1,75 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @file
+ * @brief Helper HTTP functions to update modules.
+ */
+
+/**
+ * @struct update_check_hash_handle
+ *
+ * @brief Handle to cancel check hash operation
+ */
+struct update_check_hash_handle;
+
+/**
+ * @brief Check file hash
+ *
+ * @param file FILE stream to have its hash checked.
+ * @param hash hash to compare with file hash
+ * @param hash_algorithm algorithm of hash to be used
+ * @param cb callback that will be called to inform check result. If status < 0,
+ * hash check failed. If status == 0, hash has been validate successfuly.
+ *
+ * @return handle of operation if could start checking. NULL otherwise
+ */
+struct update_check_hash_handle *check_file_hash(FILE *file, const char *hash,
+    const char *hash_algorithm, void (*cb)(void *data, int status),
+    const void *data);
+
+/**
+ * @brief Cancel ongoing file hash checking operation
+ *
+ * @return always true
+ */
+bool cancel_check_file_hash(struct update_check_hash_handle *handle);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
diff --git a/src/modules/update/update-common/http.c b/src/modules/update/update-common/http.c
new file mode 100644
index 00000000..52919d8d
--- /dev/null
+++ b/src/modules/update/update-common/http.c
@@ -0,0 +1,288 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "http.h"
+
+#include "sol-http-client.h"
+#include "sol-json.h"
+#include "sol-log.h"
+#include "sol-update.h"
+#include "sol-util.h"
+
+struct update_http_handle {
+    struct sol_http_client_connection *conn;
+    char *url;
+    union {
+        void (*cb_get_metadata)(void *data, int status, const struct sol_buffer *metadata);
+        struct {
+            void (*cb_fetch_recv)(void *data, struct sol_buffer *buffer);
+            void (*cb_fetch_end)(void *data, int status);
+        };
+    };
+    const void *user_data;
+    bool on_callback : 1;
+    bool cancel : 1;
+    bool cancelled : 1;
+};
+
+static void
+delete_handle(struct update_http_handle *handle)
+{
+    free(handle->url);
+    if (handle->conn)
+        sol_http_client_connection_cancel(handle->conn);
+    free(handle);
+}
+
+bool
+metadata_to_update_info(const struct sol_buffer *metadata,
+    struct sol_update_info *response)
+{
+    struct sol_json_scanner scanner;
+    struct sol_json_token token, key, value;
+    enum sol_json_loop_reason reason;
+
+    response->version = NULL;
+
+    sol_json_scanner_init(&scanner, metadata->data, metadata->used);
+    SOL_JSON_SCANNER_OBJECT_LOOP (&scanner, &token, &key, &value, reason) {
+        if (SOL_JSON_TOKEN_STR_LITERAL_EQ(&key, "size")) {
+            if (sol_json_token_get_uint64(&value, &response->size) != 0) {
+                SOL_WRN("Could not get size of update file");
+                goto err_size;
+            }
+        } else if (SOL_JSON_TOKEN_STR_LITERAL_EQ(&key, "version"))
+            response->version = sol_json_token_get_unescaped_string_copy(&value);
+        else
+            SOL_DBG("Unknown response member: %.*s",
+                SOL_STR_SLICE_PRINT(sol_json_token_to_slice(&token)));
+    }
+
+    if (!response->version) {
+        SOL_WRN("Malformed check response");
+        return false;
+    }
+
+    return true;
+
+err_size:
+    free((char *)response->version);
+    return false;
+}
+
+static void
+task_get_metadata_response(void *data, const struct sol_http_client_connection *conn,
+    struct sol_http_response *http_response)
+{
+    struct update_http_handle *handle = data;
+
+    handle->conn = NULL;
+    handle->on_callback = true;
+
+    if (http_response->response_code != SOL_HTTP_STATUS_OK) {
+        SOL_WRN("Invalid response code from [%s] when checking for update: %d",
+            handle->url, http_response->response_code);
+        handle->cb_get_metadata((void *)handle->user_data, -http_response->response_code, NULL);
+        delete_handle(handle);
+        return;
+    }
+
+    if (!streq(http_response->content_type, "application/json")) {
+        SOL_WRN("Invalid content type of response: [%s] expected [application/json]",
+            http_response->content_type);
+        handle->cb_get_metadata((void *)handle->user_data, -EINVAL, NULL);
+        delete_handle(handle);
+        return;
+    }
+
+    if (!http_response->content.used) {
+        SOL_WRN("Empty response for version check");
+        handle->cb_get_metadata((void *)handle->user_data, -EINVAL, NULL);
+        delete_handle(handle);
+        return;
+    }
+
+    handle->cb_get_metadata((void *)handle->user_data, 0, &http_response->content);
+    delete_handle(handle);
+
+    return;
+}
+
+struct update_http_handle *
+http_get_metadata(const char *url,
+    void (*cb)(void *data, int status, const struct sol_buffer *metadata),
+    const void *data)
+{
+    struct sol_http_params params;
+    struct update_http_handle *handle;
+
+    SOL_NULL_CHECK(url, NULL);
+    SOL_NULL_CHECK(cb, NULL);
+
+    handle = calloc(1, sizeof(struct update_http_handle));
+    SOL_NULL_CHECK(handle, NULL);
+
+    handle->cb_get_metadata = cb;
+    handle->user_data = data;
+    handle->url = strdup(url);
+    SOL_NULL_CHECK_GOTO(handle->url, err_url);
+
+    sol_http_params_init(&params);
+
+    if (!sol_http_param_add(&params,
+        SOL_HTTP_REQUEST_PARAM_HEADER("Accept", "application/json"))) {
+
+        SOL_WRN("Could not add query parameter");
+        goto err_param;
+    }
+
+    handle->conn = sol_http_client_request(SOL_HTTP_METHOD_GET, url, &params,
+        task_get_metadata_response, handle);
+    SOL_NULL_CHECK_GOTO(handle->conn, err_conn);
+
+    sol_http_params_clear(&params);
+
+    return handle;
+
+err_conn:
+    sol_http_params_clear(&params);
+err_param:
+    free(handle->url);
+err_url:
+    free(handle);
+
+    return NULL;
+}
+
+static void
+task_fetch_response(void *data, const struct sol_http_client_connection *conn,
+    struct sol_http_response *http_response)
+{
+    struct update_http_handle *handle = data;
+
+    /* We still get response even after cancelling connection. Here, we ignore it */
+    if (handle->cancelled) {
+        delete_handle(handle);
+        return;
+    }
+
+    handle->conn = NULL;
+    handle->on_callback = true;
+
+    if (http_response->response_code != SOL_HTTP_STATUS_OK) {
+        SOL_WRN("Invalid response code from [%s] when fetching update: %d",
+            handle->url, http_response->response_code);
+        handle->cb_fetch_end((void *)handle->user_data, -http_response->response_code);
+        delete_handle(handle);
+        return;
+    }
+
+    handle->cb_fetch_end((void *)handle->user_data, http_response->response_code);
+    delete_handle(handle);
+
+    return;
+}
+
+static ssize_t
+task_fetch_recv(void *data, const struct sol_http_client_connection *conn,
+    struct sol_buffer *buffer)
+{
+    struct update_http_handle *handle = data;
+
+    handle->on_callback = true;
+
+    handle->cb_fetch_recv((void *)handle->user_data, buffer);
+
+    /* Cancelled task in middle of this callback */
+    if (handle->cancel) {
+        handle->cancelled = true;
+        return -1; /* Cancel sol_http_client_connection */
+    }
+
+    handle->on_callback = false;
+
+    return buffer->used;
+}
+
+struct update_http_handle *
+http_fetch(const char *url,
+    void (*recv_cb)(void *data, struct sol_buffer *buffer),
+    void (*end_cb)(void *data, int status),
+    const void *data, bool resume)
+{
+    struct update_http_handle *handle;
+    struct sol_http_request_interface iface = {
+        SOL_SET_API_VERSION(.api_version = SOL_HTTP_REQUEST_INTERFACE_API_VERSION, )
+        .recv_cb = task_fetch_recv,
+        .response_cb = task_fetch_response
+    };
+
+    /* TODO handle resume stuff */
+
+    SOL_NULL_CHECK(url, NULL);
+    SOL_NULL_CHECK(recv_cb, NULL);
+    SOL_NULL_CHECK(end_cb, NULL);
+
+    handle = calloc(1, sizeof(struct update_http_handle));
+    SOL_NULL_CHECK(handle, NULL);
+
+    handle->cb_fetch_recv = recv_cb;
+    handle->cb_fetch_end = end_cb;
+    handle->user_data = data;
+    handle->url = strdup(url);
+    SOL_NULL_CHECK_GOTO(handle->url, err);
+
+    /* TODO use chunked stuff when available */
+    handle->conn = sol_http_client_request_with_interface(SOL_HTTP_METHOD_GET,
+        handle->url, NULL, &iface, handle);
+    SOL_NULL_CHECK_GOTO(handle->conn, err);
+
+    return handle;
+
+err:
+    free(handle->url);
+    free(handle);
+
+    return NULL;
+}
+
+bool
+http_cancel(struct update_http_handle *handle)
+{
+    if (!handle->on_callback)
+        delete_handle(handle);
+    else
+        handle->cancel = true;
+
+    return true;
+}
diff --git a/src/modules/update/update-common/http.h b/src/modules/update/update-common/http.h
new file mode 100644
index 00000000..a5693c25
--- /dev/null
+++ b/src/modules/update/update-common/http.h
@@ -0,0 +1,121 @@
+/*
+ * This file is part of the Soletta Project
+ *
+ * Copyright (C) 2015 Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#pragma once
+
+#include "sol-buffer.h"
+#include "sol-update.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @file
+ * @brief Helper HTTP functions to update modules.
+ */
+
+/**
+ * @brief Handle of http tasks 'fetch' and 'get_metadata'
+ */
+struct update_http_handle;
+
+/**
+ * @brief Get metadata from given URL
+ *
+ * An example of metadata is a JSON containing useful information
+ * of update
+ *
+ * @ param url url to get data
+ * @param cb callback that will be called with data. If @c status < 0,
+ * something went wrong. Callback @c metadata param contain the metadata.
+ * @param data user data that will be passed to callback @a cb
+ *
+ * @return handle of this task. It can be cancelled via @c http_cancel.
+ *
+ * @see http_cancel
+ */
+struct update_http_handle *http_get_metadata(const char *url,
+    void (*cb)(void *data, int status, const struct sol_buffer *metadata),
+    const void *data);
+
+/**
+ * @brief Download a file
+ *
+ * @param url url to download file
+ * @param recv_cb callback that receives download content so far, on
+ * its @c buffer param. This callback may be called multiple times to deliver
+ * chunks of download file.
+ * @param end_cb callback called at end of transfer. Status is the HTTP status
+ * of the transfer. So, SOL_HTTP_STATUS_OK means success.
+ * @param data user data that will be passed to both callbacks
+ * @param resume *NOT IMPLEMENTED* allows resume an interrupted transfer
+ *
+ * @return handle of this task. It can be cancelled via @c http_cancel.
+ *
+ * @see http_cancel
+ */
+struct update_http_handle *http_fetch(const char *url,
+    void (*recv_cb)(void *data, struct sol_buffer *buffer),
+    void (*end_cb)(void *data, int status),
+    const void *data, bool resume);
+
+/**
+ * @brief Cancel an http ongoing task.
+ *
+ * After this call, no callbacks of task shall be called. It is safe
+ * to call it inside callbacks.
+ *
+ * @param handle to be cancelled
+ *
+ * @return true if could cancel task.
+ */
+bool http_cancel(struct update_http_handle *handle);
+
+/**
+ * @brief Fills a @c sol_update_info from a JSON buffer.
+ *
+ * Convenient function that fills a @c sol_update_info from a buffer
+ * containing a JSON structured data. This JSON must contain at least the
+ * fields "version" and "size".
+ *
+ * @param metadata from where to get information
+ * @param response @c sol_update_info that will be filled with information
+ *
+ * @return true on success.
+ */
+bool metadata_to_update_info(const struct sol_buffer *metadata,
+    struct sol_update_info *response);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/tools/build/Makefile.rules b/tools/build/Makefile.rules
index 3a8914da..10ed9755 100644
--- a/tools/build/Makefile.rules
+++ b/tools/build/Makefile.rules
@@ -96,7 +96,7 @@ parse-mod-output = \
 	$(eval mod-so     += $(3)) \
 
 external-module-flags := -DSOL_FLOW_NODE_TYPE_MODULE_EXTERNAL=1 -DSOL_PLATFORM_LINUX_MICRO_MODULE_EXTERNAL=1 \
-		-DSOL_PIN_MUX_MODULE_EXTERNAL=1 -DSOL_FLOW_METATYPE_MODULE_EXTERNAL=1
+		-DSOL_PIN_MUX_MODULE_EXTERNAL=1 -DSOL_FLOW_METATYPE_MODULE_EXTERNAL=1 -DSOL_UPDATE_MODULE_EXTERNAL=1
 
 parse-mod-module = \
 	$(call parse-common-module,$(1),$(2),m,$(3),curr-mod-type) \
diff --git a/tools/build/Makefile.vars b/tools/build/Makefile.vars
index 2fd77e7d..79897c47 100644
--- a/tools/build/Makefile.vars
+++ b/tools/build/Makefile.vars
@@ -97,6 +97,7 @@ export FLOWMODULESDIR := $(MODULESDIR)/flow/
 export PINMUXDIR := $(MODULESDIR)/pin-mux/
 export LINUXMICROMODULESDIR := $(MODULESDIR)/linux-micro/
 export FLOWMETATYPEMODULESDIR := $(MODULESDIR)/flow-metatype/
+export UPDATEMODULESDIR := $(MODULESDIR)/update/
 
 # build dirs
 ## BUILDDIR is the user provided option
@@ -279,7 +280,8 @@ COMMON_CFLAGS += \
 	-DFLOWMODULESDIR="\"$(FLOWMODULESDIR)\"" \
 	-DPINMUXDIR="\"$(PINMUXDIR)\"" \
 	-DLINUXMICROMODULESDIR="\"$(LINUXMICROMODULESDIR)\"" \
-	-DFLOWMETATYPEMODULESDIR="\"$(FLOWMETATYPEMODULESDIR)\""
+	-DFLOWMETATYPEMODULESDIR="\"$(FLOWMETATYPEMODULESDIR)\"" \
+	-DUPDATEMODULESDIR="\"$(UPDATEMODULESDIR)\""
 
 COMMON_CFLAGS += -include $(abspath $(MISSING_H))
 COMMON_CFLAGS += $(addprefix -I,$(HEADERDIRS))
@@ -328,6 +330,9 @@ $(call add-template,$(FLOW_BUILTINS_H_IN),$(FLOW_BUILTINS_H))
 PIN_MUX_BUILTINS_H_IN := $(top_srcdir)src/lib/common/sol-pin-mux-builtins-gen.h.in
 PIN_MUX_BUILTINS_H := $(build_stagedir)lib/common/sol-pin-mux-builtins-gen.h
 
+UPDATE_BUILTINS_H_IN := $(top_srcdir)src/lib/common/sol-update-builtins-gen.h.in
+UPDATE_BUILTINS_H := $(build_stagedir)lib/common/sol-update-builtins-gen.h
+
 FLOW_METATYPE_BUILTINS_H_IN := $(top_srcdir)src/lib/flow/sol-flow-metatype-builtins-gen.h.in
 FLOW_METATYPE_BUILTINS_H := $(build_stagedir)lib/flow/sol-flow-metatype-builtins-gen.h
 
@@ -368,6 +373,12 @@ HEADER_GEN += $(PIN_MUX_BUILTINS_H)
 $(call add-template,$(PIN_MUX_BUILTINS_H_IN),$(PIN_MUX_BUILTINS_H))
 endif
 
+ifeq (y,$(USE_UPDATE))
+HEADER_GEN += $(UPDATE_BUILTINS_H)
+
+$(call add-template,$(UPDATE_BUILTINS_H_IN),$(UPDATE_BUILTINS_H))
+endif
+
 HEADER_GEN += $(FLOW_BUILTINS_H)
 HEADER_GEN += $(FLOW_METATYPE_BUILTINS_H)
 