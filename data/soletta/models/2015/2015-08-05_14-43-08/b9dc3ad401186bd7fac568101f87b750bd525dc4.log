"2015-08-05 14:43:08 -0300"
diff --git a/data/jsons/dependencies.json b/data/jsons/dependencies.json
index 91fee0a6..4fa9a279 100644
--- a/data/jsons/dependencies.json
+++ b/data/jsons/dependencies.json
@@ -282,6 +282,14 @@
 	    ],
 	    "fragment": "int v = IFLA_INET6_ADDR_GEN_MODE;"
 	},
+	{
+	    "dependency": "strtod_l",
+	    "type": "ccode",
+	    "headers": [
+		"<stdlib.h>"
+	    ],
+	    "fragment": "strtod_l(0, 0, 0);"
+	},
 	{
 	    "dependency": "valgrind",
 	    "type": "exec",
diff --git a/src/lib/parsers/include/sol-json.h b/src/lib/parsers/include/sol-json.h
index 257a623d..453f3abe 100644
--- a/src/lib/parsers/include/sol-json.h
+++ b/src/lib/parsers/include/sol-json.h
@@ -37,6 +37,8 @@
 #include <stdbool.h>
 #include <stddef.h>
 #include <string.h>
+#include <errno.h>
+#include <stdint.h>
 #include <sol-macros.h>
 
 #ifdef __cplusplus
@@ -191,6 +193,120 @@ sol_json_token_str_eq(const struct sol_json_token *token, const char *str, unsig
 #define SOL_JSON_TOKEN_STR_LITERAL_EQ(token_, str_) \
     sol_json_token_str_eq(token_, str_, sizeof(str_) - 1)
 
+/**
+ * Get the numeric value of the given token as an 64 bits unsigned integer.
+ *
+ * @param token the token to convert to number.
+ * @param value where to return the converted number.
+ *
+ * @return 0 on success, -errno on failure (@c EINVAL or @c
+ * ERANGE). On errors @a value will be set to a best-match, such as 0
+ * if @c EINVAL or @c UINT64_MAX if @c ERANGE.
+ *
+ * @see sol_json_token_get_int64()
+ * @see sol_json_token_get_uint32()
+ * @see sol_json_token_get_double()
+ */
+int sol_json_token_get_uint64(const struct sol_json_token *token, uint64_t *value) SOL_ATTR_WARN_UNUSED_RESULT SOL_ATTR_NONNULL(1, 2);
+
+/**
+ * Get the numeric value of the given token as an 64 bits signed integer.
+ *
+ * @param token the token to convert to number.
+ * @param value where to return the converted number.
+ *
+ * @return 0 on success, -errno on failure (@c EINVAL or @c
+ * ERANGE). On errors @a value will be set to a best-match, such as 0
+ * if @c EINVAL, @c INT64_MAX or @c INT64_MIN if @c ERANGE.
+ *
+ * @see sol_json_token_get_uint64()
+ * @see sol_json_token_get_int32()
+ * @see sol_json_token_get_double()
+ */
+int sol_json_token_get_int64(const struct sol_json_token *token, int64_t *value) SOL_ATTR_WARN_UNUSED_RESULT SOL_ATTR_NONNULL(1, 2);
+
+/**
+ * Get the numeric value of the given token as an 32 bits unsigned integer.
+ *
+ * @param token the token to convert to number.
+ * @param value where to return the converted number.
+ *
+ * @return 0 on success, -errno on failure (@c EINVAL or @c
+ * ERANGE). On errors @a value will be set to a best-match, such as 0
+ * if @c EINVAL or @c UINT32_MAX if @c ERANGE.
+ *
+ * @see sol_json_token_get_uint64()
+ * @see sol_json_token_get_int32()
+ * @see sol_json_token_get_double()
+ */
+static inline int
+sol_json_token_get_uint32(const struct sol_json_token *token, uint32_t *value)
+{
+    uint64_t tmp;
+    int r = sol_json_token_get_uint64(token, &tmp);
+
+    if (tmp > UINT32_MAX) {
+        tmp = UINT32_MAX;
+        if (r == 0)
+            r = -ERANGE;
+    }
+
+    *value = tmp;
+    return r;
+}
+
+/**
+ * Get the numeric value of the given token as an 32 bits signed integer.
+ *
+ * @param token the token to convert to number.
+ * @param value where to return the converted number.
+ *
+ * @return 0 on success, -errno on failure (@c EINVAL or @c
+ * ERANGE). On errors @a value will be set to a best-match, such as 0
+ * if @c EINVAL, @c INT32_MAX or @c INT32_MIN if @c ERANGE.
+ *
+ * @see sol_json_token_get_uint64()
+ * @see sol_json_token_get_int32()
+ * @see sol_json_token_get_double()
+ */
+static inline int
+sol_json_token_get_int32(const struct sol_json_token *token, int32_t *value)
+{
+    int64_t tmp;
+    int r = sol_json_token_get_int64(token, &tmp);
+
+    if (tmp > INT32_MAX) {
+        tmp = INT32_MAX;
+        if (r == 0)
+            r = -ERANGE;
+    } else if (tmp < INT32_MIN) {
+        tmp = INT32_MIN;
+        if (r == 0)
+            r = -ERANGE;
+    }
+
+    *value = tmp;
+    return r;
+}
+
+/**
+ * Get the numeric value of the given token as double-precision floating point.
+ *
+ * @param token the token to convert to number.
+ * @param value where to return the converted number.
+ *
+ * @return 0 on success, -errno on failure (@c EINVAL or @c
+ * ERANGE). On errors @a value will be set to a best-match, such as 0.0
+ * if @c EINVAL, @c DBL_MAX or @c -DBL_MAX if @c ERANGE.
+ *
+ * @see sol_json_token_get_uint64()
+ * @see sol_json_token_get_int64()
+ * @see sol_json_token_get_uint32()
+ * @see sol_json_token_get_int32()
+ */
+int sol_json_token_get_double(const struct sol_json_token *token, double *value) SOL_ATTR_WARN_UNUSED_RESULT SOL_ATTR_NONNULL(1, 2);
+
+
 bool sol_json_scanner_next(struct sol_json_scanner *scanner,
     struct sol_json_token *token)
 SOL_ATTR_WARN_UNUSED_RESULT
diff --git a/src/lib/parsers/sol-json.c b/src/lib/parsers/sol-json.c
index 061b55d0..79999f57 100644
--- a/src/lib/parsers/sol-json.c
+++ b/src/lib/parsers/sol-json.c
@@ -38,6 +38,8 @@
 #include "sol-json.h"
 #include "sol-log.h"
 #include "sol-util.h"
+#include <float.h>
+#include <math.h>
 
 static bool
 check_symbol(struct sol_json_scanner *scanner, struct sol_json_token *token,
@@ -138,6 +140,179 @@ check_number(struct sol_json_scanner *scanner, struct sol_json_token *token)
     return true;
 }
 
+static int
+token_get_uint64(const struct sol_json_token *token, uint64_t *value)
+{
+    const char *itr = token->start;
+    uint64_t tmpvar = 0;
+
+    if (*itr == '+')
+        itr++;
+
+    for (; itr < token->end; itr++) {
+        const char c = *itr;
+        if (c >= '0' && c <= '9') {
+            int r;
+
+            r = sol_util_uint64_mul(tmpvar, 10, &tmpvar);
+            if (r < 0)
+                goto overflow;
+
+            r = sol_util_uint64_add(tmpvar, c - '0', &tmpvar);
+            if (r < 0)
+                goto overflow;
+            continue;
+        }
+        *value = tmpvar; /* best effort */
+        SOL_DBG("unexpected char '%c' at position %u of integer token %.*s",
+            c, (unsigned)(itr - token->start),
+            sol_json_token_get_size(token), token->start);
+        return -EINVAL;
+
+overflow:
+        *value = UINT64_MAX; /* best effort */
+        SOL_DBG("number is too large at position %u of integer token %.*s",
+            (unsigned)(itr - token->start),
+            sol_json_token_get_size(token), token->start);
+        return -ERANGE;
+    }
+
+    *value = tmpvar;
+    return 0;
+}
+
+static int
+token_get_int64(const struct sol_json_token *token, int64_t *value)
+{
+    struct sol_json_token inttoken = *token;
+    int r, sign = 1;
+    uint64_t tmpvar;
+
+    if (*inttoken.start == '-') {
+        sign = -1;
+        inttoken.start++;
+    }
+
+    r = token_get_uint64(&inttoken, &tmpvar);
+    if (r == 0) {
+        if (sign > 0 && tmpvar > INT64_MAX) {
+            *value = INT64_MAX;
+            return -ERANGE;
+        } else if (sign < 0 && tmpvar > ((uint64_t)INT64_MAX + 1)) {
+            *value = INT64_MIN;
+            return -ERANGE;
+        }
+        *value = sign * tmpvar;
+        return 0;
+    } else {
+        /* best effort to help users ignoring return false */
+        if (r == -ERANGE) {
+            if (sign > 0)
+                *value = INT64_MAX;
+            else
+                *value = INT64_MIN;
+        } else {
+            if (sign > 0 && tmpvar > INT64_MAX)
+                *value = INT64_MAX;
+            else if (sign < 0 && tmpvar > ((uint64_t)INT64_MAX + 1))
+                *value = INT64_MIN;
+            else
+                *value = sign * tmpvar;
+        }
+        return r;
+    }
+}
+
+SOL_API int
+sol_json_token_get_uint64(const struct sol_json_token *token, uint64_t *value)
+{
+    *value = 0;
+    SOL_NULL_CHECK(token, -EINVAL);
+    SOL_NULL_CHECK(value, -EINVAL);
+    if (token->start >= token->end) {
+        SOL_WRN("invalid token: start=%p, end=%p",
+            token->start, token->end);
+        return -EINVAL;
+    }
+    if (sol_json_token_get_type(token) != SOL_JSON_TYPE_NUMBER) {
+        SOL_WRN("expected number, got token type '%c' for token \"%.*s\"",
+            sol_json_token_get_type(token),
+            sol_json_token_get_size(token), token->start);
+        return -EINVAL;
+    }
+    if (*token->start == '-') {
+        SOL_DBG("%.*s: negative number where unsigned is expected",
+            sol_json_token_get_size(token), token->start);
+        return -ERANGE;
+    }
+
+    return token_get_uint64(token, value);
+}
+
+SOL_API int
+sol_json_token_get_int64(const struct sol_json_token *token, int64_t *value)
+{
+    *value = 0;
+    SOL_NULL_CHECK(token, -EINVAL);
+    SOL_NULL_CHECK(value, -EINVAL);
+    if (token->start >= token->end) {
+        SOL_WRN("invalid token: start=%p, end=%p",
+            token->start, token->end);
+        return -EINVAL;
+    }
+    if (sol_json_token_get_type(token) != SOL_JSON_TYPE_NUMBER) {
+        SOL_WRN("expected number, got token type '%c' for token \"%.*s\"",
+            sol_json_token_get_type(token),
+            sol_json_token_get_size(token), token->start);
+        return -EINVAL;
+    }
+
+    return token_get_int64(token, value);
+}
+
+SOL_API int
+sol_json_token_get_double(const struct sol_json_token *token, double *value)
+{
+    char *endptr;
+    int r;
+
+    /* NOTE: Using a copy to ensure trailing \0 and strtod() so we
+     * properly parse numbers with large precision.
+     *
+     * Splitting the integer, fractional and exponent parts and doing
+     * the math using double numbers will result in rounding errors
+     * when parsing DBL_MAX using "%.64g" formatting.
+     *
+     * Since parsing it is complex (ie:
+     * http://www.netlib.org/fp/dtoa.c), we take the short path to
+     * call our helper around libc's strtod() that limits the amount
+     * of bytes.
+     */
+
+    *value = sol_util_strtodn(token->start, &endptr,
+        sol_json_token_get_size(token), false);
+
+    r = -errno;
+    if (endptr == token->start)
+        r = -EINVAL;
+    else if (isinf(*value)) {
+        SOL_DBG("token '%.*s' is infinite",
+            sol_json_token_get_size(token), token->start);
+        if (*value < 0)
+            *value = -DBL_MAX;
+        else
+            *value = DBL_MAX;
+        r = -ERANGE;
+    } else if (isnan(*value)) {
+        SOL_DBG("token '%.*s' is not a number",
+            sol_json_token_get_size(token), token->start);
+        *value = 0;
+        r = -EINVAL;
+    }
+
+    return r;
+}
+
 SOL_API bool
 sol_json_scanner_next(struct sol_json_scanner *scanner, struct sol_json_token *token)
 {
diff --git a/src/shared/sol-util.c b/src/shared/sol-util.c
index ae339ec0..a25aa9c7 100644
--- a/src/shared/sol-util.c
+++ b/src/shared/sol-util.c
@@ -37,10 +37,38 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/types.h>
+#ifdef HAVE_LOCALE
+#include <locale.h>
+#endif
 
 #include "sol-util.h"
+#include "sol-log.h"
 #include "sol-str-slice.h"
 
+#ifdef HAVE_LOCALE
+static locale_t c_locale;
+static void
+clear_c_locale(void)
+{
+    freelocale(c_locale);
+    c_locale = NULL;
+}
+
+static bool
+init_c_locale(void)
+{
+    if (c_locale)
+        return true;
+
+    c_locale = newlocale(LC_ALL_MASK, "C", NULL);
+    if (!c_locale)
+        return false;
+
+    atexit(clear_c_locale);
+    return true;
+}
+#endif
+
 void *
 sol_util_memdup(const void *data, size_t len)
 {
@@ -52,6 +80,104 @@ sol_util_memdup(const void *data, size_t len)
     return ptr;
 }
 
+double
+sol_util_strtodn(const char *nptr, char **endptr, size_t len, bool use_locale)
+{
+    char *tmpbuf, *tmpbuf_endptr;
+    double value;
+
+#if defined(HAVE_LOCALE) && defined(HAVE_STRTOD_L)
+    if (!use_locale) {
+        if (!init_c_locale()) {
+            /* not great, but a best effort to convert something */
+            use_locale = false;
+            SOL_WRN("could not create locale 'C', use current locale.");
+        }
+    }
+#endif
+
+    /* NOTE: Using a copy to ensure trailing \0 and strtod() so we
+     * properly parse numbers with large precision.
+     *
+     * Since parsing it is complex (ie:
+     * http://www.netlib.org/fp/dtoa.c), we take the short path to
+     * call libc.
+     */
+    tmpbuf = strndupa(nptr, len);
+
+    errno = 0;
+#ifdef HAVE_LOCALE
+    if (!use_locale) {
+#ifdef HAVE_STRTOD_L
+        value = strtod_l(tmpbuf, &tmpbuf_endptr, c_locale);
+#else
+        /* fallback to query locale's decimal point and if it's
+         * different than '.' we replace JSON's '.' with locale's
+         * decimal point if the given number contains a '.'.
+         *
+         * We also replace any existing locale decimal_point with '.'
+         * so it will return correct endptr.
+         *
+         * Extra care since decimal point may be multi-byte.
+         */
+        struct lconv *lc = localeconv();
+        if (lc && lc->decimal_point && !streq(lc->decimal_point, ".")) {
+            if (strchr(tmpbuf, '.') || strstr(tmpbuf, lc->decimal_point)) {
+                int dplen = strlen(lc->decimal_point);
+                const char *src, *src_end = tmpbuf + len;
+                char *dst;
+                if (dplen == 1) {
+                    for (src = tmpbuf, dst = tmpbuf; src < src_end; src++, dst++) {
+                        if (*src == '.')
+                            *dst = *lc->decimal_point;
+                        else if (*src == *lc->decimal_point)
+                            *dst = '.';
+                    }
+                } else {
+                    char *transl;
+                    unsigned count = 0;
+
+                    for (src = tmpbuf; src < src_end; src++) {
+                        if (*src == '.')
+                            count++;
+                    }
+
+                    transl = alloca(len + (count * dplen) + 1);
+                    for (src = tmpbuf, dst = transl; src < src_end;) {
+                        if (*src == '.') {
+                            memcpy(dst, lc->decimal_point, dplen);
+                            dst += dplen;
+                            src++;
+                        } else if ((src_end - src) >= dplen &&
+                            streqn(src, lc->decimal_point, dplen)) {
+                            *dst = '.';
+                            dst++;
+                            src += dplen;
+                        } else {
+                            *dst = *src;
+                            dst++;
+                            src++;
+                        }
+                    }
+                    *dst = '\0';
+                    tmpbuf = transl;
+                }
+            }
+        }
+        value = strtod(tmpbuf, &tmpbuf_endptr);
+#endif
+    } else
+#endif
+    {
+        value = strtod(tmpbuf, &tmpbuf_endptr);
+    }
+
+    if (endptr)
+        *endptr = (char *)nptr + (tmpbuf_endptr - tmpbuf);
+
+    return value;
+}
+
 #ifdef SOL_PLATFORM_CONTIKI
 #include <contiki.h>
 
diff --git a/src/shared/sol-util.h b/src/shared/sol-util.h
index 69fcdc24..55b72457 100644
--- a/src/shared/sol-util.h
+++ b/src/shared/sol-util.h
@@ -51,6 +51,36 @@
 #define streqn(a, b, n) (strncmp((a), (b), (n)) == 0)
 #define strstartswith(a, b) streqn((a), (b), strlen(b))
 
+/**
+ * Wrapper over strtod() that consumes up to @c len bytes and may not
+ * use a locale.
+ *
+ * This variation of strtod() will work with buffers that are not
+ * null-terminated.
+ *
+ * It also offers a way to skip the currently set locale, forcing
+ * plain "C". This is required to parse numbers in formats that
+ * require '.' as the decimal point while the current locale may use
+ * ',' such as in pt_BR.
+ *
+ * All the formats accepted by strtod() are accepted and the behavior
+ * should be the same, including using information from @c LC_NUMERIC
+ * if locale is configured and @a use_locale is true.
+ *
+ * @param nptr the string containing the number to convert.
+ * @param endptr if non-NULL, it will contain the last character used
+ *        in the conversion. If no conversion was done, endptr is @a nptr.
+ * @param use_locale if true, then current locale is used, if false
+ *        then "C" locale is forced.
+ *
+ * @param len use at most this amount of bytes of @a nptr.
+ *
+ * @return the converted value, if any. The converted value may be @c
+ *         NAN, @c INF (positive or negative). See the strtod(3)
+ *         documentation for the details.
+ */
+double sol_util_strtodn(const char *nptr, char **endptr, size_t len, bool use_locale);
+
 #define STATIC_ASSERT_LITERAL(_s) ("" _s)
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
 
diff --git a/src/test/Kconfig b/src/test/Kconfig
index 1edfd10d..ad80fa54 100644
--- a/src/test/Kconfig
+++ b/src/test/Kconfig
@@ -81,3 +81,7 @@ config TEST_VECTOR
 config TEST_JSON
 	bool "json"
 	default y
+
+config TEST_UTIL
+	bool "util"
+	default y
diff --git a/src/test/Makefile b/src/test/Makefile
index 842a59a4..29cf5db0 100644
--- a/src/test/Makefile
+++ b/src/test/Makefile
@@ -57,3 +57,6 @@ test-test-buffer-$(TEST_BUFFER) := test.c test-buffer.c
 
 test-$(TEST_JSON) += test-json
 test-test-json-$(TEST_JSON) := test.c test-json.c
+
+test-$(TEST_UTIL) += test-util
+test-test-util-$(TEST_UTIL) := test.c test-util.c
diff --git a/src/test/test-json.c b/src/test/test-json.c
index 24d9d956..e3f6b6b3 100644
--- a/src/test/test-json.c
+++ b/src/test/test-json.c
@@ -34,6 +34,8 @@
 #include "sol-json.h"
 #include "sol-util.h"
 #include "sol-log.h"
+#include "sol-types.h"
+#include <float.h>
 
 #define TOKENS (const enum sol_json_type[])
 struct test_entry {
@@ -167,4 +169,416 @@ test_json(void)
     }
 }
 
+DEFINE_TEST(test_json_token_get_uint64);
+
+static void
+test_json_token_get_uint64(void)
+{
+    const struct test_u64 {
+        const char *str;
+        uint64_t reference;
+        int expected_return;
+    } *itr, tests[] = {
+        { "0", 0, 0 },
+        { "123", 123, 0 },
+        { "18446744073709551615", UINT64_MAX, 0 },
+        { "0000123", 123, 0 },
+        { "-132", 0, -ERANGE },
+        { "184467440737095516150", UINT64_MAX, -ERANGE }, /* mul overflow */
+        { "18446744073709551616", UINT64_MAX, -ERANGE }, /* add overflow */
+        { "1.0", 1, -EINVAL },
+        { "123.456", 123, -EINVAL },
+        { "345e+12", 345, -EINVAL },
+        { "x", 0, -EINVAL },
+        { "", 0, -EINVAL },
+        {}
+    };
+
+    for (itr = tests; itr->str != NULL; itr++) {
+        uint64_t value;
+        char buf[512];
+        struct sol_json_token token;
+        int retval;
+
+        snprintf(buf, sizeof(buf), "%s123garbage", itr->str);
+        token.start = buf;
+        token.end = buf + strlen(itr->str);
+        retval = sol_json_token_get_uint64(&token, &value);
+        if (itr->expected_return == 0 && retval == 0) {
+            if (itr->reference == value) {
+                SOL_DBG("OK: parsed '%s' as %" PRIu64, itr->str, value);
+            } else {
+                SOL_WRN("FAILED: parsed '%s' as %" PRIu64 " where %" PRIu64
+                    " was expected", itr->str, value, itr->reference);
+                FAIL();
+            }
+        } else if (itr->expected_return == 0 && retval < 0) {
+            SOL_WRN("FAILED: parsing '%s' failed with errno = %d (%s)",
+                itr->str, retval, sol_util_strerrora(-retval));
+            FAIL();
+        } else if (itr->expected_return != 0 && retval == 0) {
+            SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                ", but got success with errno = %d (%s), value = %" PRIu64,
+                itr->str,
+                itr->expected_return, sol_util_strerrora(-itr->expected_return),
+                retval, sol_util_strerrora(-retval), value);
+            FAIL();
+        } else if (itr->expected_return != 0 && retval < 0) {
+            if (itr->expected_return != retval) {
+                SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                    ", but got errno = %d (%s), value = %" PRIu64,
+                    itr->str,
+                    itr->expected_return, sol_util_strerrora(-itr->expected_return),
+                    retval, sol_util_strerrora(-retval), value);
+                FAIL();
+            } else if (itr->reference != value) {
+                SOL_WRN("FAILED: parsing '%s' should result in %" PRIu64
+                    ", but got %" PRIu64, itr->str, itr->reference, value);
+                FAIL();
+            } else {
+                SOL_DBG("OK: parsed '%s' as %" PRIu64
+                    ", setting errno = %d (%s)",
+                    itr->str, value, retval, sol_util_strerrora(-retval));
+            }
+        }
+    }
+
+}
+
+DEFINE_TEST(test_json_token_get_uint32);
+
+static void
+test_json_token_get_uint32(void)
+{
+    const struct test_u32 {
+        const char *str;
+        uint32_t reference;
+        int expected_return;
+    } *itr, tests[] = {
+        { "0", 0, 0 },
+        { "123", 123, 0 },
+        { "4294967295", UINT32_MAX, 0 },
+        { "0000123", 123, 0 },
+        { "-132", 0, -ERANGE },
+        { "184467440737095516150", UINT32_MAX, -ERANGE },
+        { "1.0", 1, -EINVAL },
+        { "123.456", 123, -EINVAL },
+        { "345e+12", 345, -EINVAL },
+        { "x", 0, -EINVAL },
+        { "", 0, -EINVAL },
+        {}
+    };
+
+    for (itr = tests; itr->str != NULL; itr++) {
+        uint32_t value;
+        char buf[512];
+        struct sol_json_token token;
+        int retval;
+
+        snprintf(buf, sizeof(buf), "%s123garbage", itr->str);
+        token.start = buf;
+        token.end = buf + strlen(itr->str);
+        retval = sol_json_token_get_uint32(&token, &value);
+        if (itr->expected_return == 0 && retval == 0) {
+            if (itr->reference == value) {
+                SOL_DBG("OK: parsed '%s' as %" PRIu32, itr->str, value);
+            } else {
+                SOL_WRN("FAILED: parsed '%s' as %" PRIu32 " where %" PRIu32
+                    " was expected", itr->str, value, itr->reference);
+                FAIL();
+            }
+        } else if (itr->expected_return == 0 && retval < 0) {
+            SOL_WRN("FAILED: parsing '%s' failed with errno = %d (%s)",
+                itr->str, retval, sol_util_strerrora(-retval));
+            FAIL();
+        } else if (itr->expected_return != 0 && retval == 0) {
+            SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                ", but got success with errno = %d (%s), value = %" PRIu32,
+                itr->str,
+                itr->expected_return, sol_util_strerrora(-itr->expected_return),
+                retval, sol_util_strerrora(-retval), value);
+            FAIL();
+        } else if (itr->expected_return != 0 && retval < 0) {
+            if (itr->expected_return != retval) {
+                SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                    ", but got errno = %d (%s), value = %" PRIu32,
+                    itr->str,
+                    itr->expected_return, sol_util_strerrora(-itr->expected_return),
+                    retval, sol_util_strerrora(-retval), value);
+                FAIL();
+            } else if (itr->reference != value) {
+                SOL_WRN("FAILED: parsing '%s' should result in %" PRIu32
+                    ", but got %" PRIu32, itr->str, itr->reference, value);
+                FAIL();
+            } else {
+                SOL_DBG("OK: parsed '%s' as %" PRIu32
+                    ", setting errno = %d (%s)",
+                    itr->str, value, retval, sol_util_strerrora(-retval));
+            }
+        }
+    }
+
+}
+
+DEFINE_TEST(test_json_token_get_int64);
+
+static void
+test_json_token_get_int64(void)
+{
+    const struct test_i64 {
+        const char *str;
+        int64_t reference;
+        int expected_return;
+    } *itr, tests[] = {
+        { "0", 0, 0 },
+        { "123", 123, 0 },
+        { "9223372036854775807", INT64_MAX, 0 },
+        { "-9223372036854775808", INT64_MIN, 0 },
+        { "0000123", 123, 0 },
+        { "-132", -132, 0 },
+        { "-0000345", -345, 0 },
+        { "92233720368547758070", INT64_MAX, -ERANGE },
+        { "-92233720368547758080", INT64_MIN, -ERANGE },
+        { "9223372036854775808", INT64_MAX, -ERANGE },
+        { "-9223372036854775809", INT64_MIN, -ERANGE },
+        { "1.0", 1, -EINVAL },
+        { "123.456", 123, -EINVAL },
+        { "345e+12", 345, -EINVAL },
+        { "-1.0", -1, -EINVAL },
+        { "-123.456", -123, -EINVAL },
+        { "-345e+12", -345, -EINVAL },
+        { "x", 0, -EINVAL },
+        { "", 0, -EINVAL },
+        {}
+    };
+
+    for (itr = tests; itr->str != NULL; itr++) {
+        int64_t value;
+        char buf[512];
+        struct sol_json_token token;
+        int retval;
+
+        snprintf(buf, sizeof(buf), "%s123garbage", itr->str);
+        token.start = buf;
+        token.end = buf + strlen(itr->str);
+        retval = sol_json_token_get_int64(&token, &value);
+        if (itr->expected_return == 0 && retval == 0) {
+            if (itr->reference == value) {
+                SOL_DBG("OK: parsed '%s' as %" PRIi64, itr->str, value);
+            } else {
+                SOL_WRN("FAILED: parsed '%s' as %" PRIi64 " where %" PRIi64
+                    " was expected", itr->str, value, itr->reference);
+                FAIL();
+            }
+        } else if (itr->expected_return == 0 && retval < 0) {
+            SOL_WRN("FAILED: parsing '%s' failed with errno = %d (%s)",
+                itr->str, retval, sol_util_strerrora(-retval));
+            FAIL();
+        } else if (itr->expected_return != 0 && retval == 0) {
+            SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                ", but got success with errno = %d (%s), value = %" PRIi64,
+                itr->str,
+                itr->expected_return, sol_util_strerrora(-itr->expected_return),
+                retval, sol_util_strerrora(-retval), value);
+            FAIL();
+        } else if (itr->expected_return != 0 && retval < 0) {
+            if (itr->expected_return != retval) {
+                SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                    ", but got errno = %d (%s), value = %" PRIi64,
+                    itr->str,
+                    itr->expected_return, sol_util_strerrora(-itr->expected_return),
+                    retval, sol_util_strerrora(-retval), value);
+                FAIL();
+            } else if (itr->reference != value) {
+                SOL_WRN("FAILED: parsing '%s' should result in %" PRIi64
+                    ", but got %" PRIi64, itr->str, itr->reference, value);
+                FAIL();
+            } else {
+                SOL_DBG("OK: parsed '%s' as %" PRIi64
+                    ", setting errno = %d (%s)",
+                    itr->str, value, retval, sol_util_strerrora(-retval));
+            }
+        }
+    }
+
+}
+
+DEFINE_TEST(test_json_token_get_int32);
+
+static void
+test_json_token_get_int32(void)
+{
+    const struct test_i32 {
+        const char *str;
+        int32_t reference;
+        int expected_return;
+    } *itr, tests[] = {
+        { "0", 0, 0 },
+        { "123", 123, 0 },
+        { "2147483647", INT32_MAX, 0 },
+        { "-2147483648", INT32_MIN, 0 },
+        { "0000123", 123, 0 },
+        { "-132", -132, 0 },
+        { "-0000345", -345, 0 },
+        { "21474836470", INT32_MAX, -ERANGE },
+        { "-21474836480", INT32_MIN, -ERANGE },
+        { "2147483648", INT32_MAX, -ERANGE },
+        { "-2147483649", INT32_MIN, -ERANGE },
+        { "1.0", 1, -EINVAL },
+        { "123.456", 123, -EINVAL },
+        { "345e+12", 345, -EINVAL },
+        { "-1.0", -1, -EINVAL },
+        { "-123.456", -123, -EINVAL },
+        { "-345e+12", -345, -EINVAL },
+        { "x", 0, -EINVAL },
+        { "", 0, -EINVAL },
+        {}
+    };
+
+    for (itr = tests; itr->str != NULL; itr++) {
+        int32_t value;
+        char buf[512];
+        struct sol_json_token token;
+        int retval;
+
+        snprintf(buf, sizeof(buf), "%s123garbage", itr->str);
+        token.start = buf;
+        token.end = buf + strlen(itr->str);
+        retval = sol_json_token_get_int32(&token, &value);
+        if (itr->expected_return == 0 && retval == 0) {
+            if (itr->reference == value) {
+                SOL_DBG("OK: parsed '%s' as %" PRIi32, itr->str, value);
+            } else {
+                SOL_WRN("FAILED: parsed '%s' as %" PRIi32 " where %" PRIi32
+                    " was expected", itr->str, value, itr->reference);
+                FAIL();
+            }
+        } else if (itr->expected_return == 0 && retval < 0) {
+            SOL_WRN("FAILED: parsing '%s' failed with errno = %d (%s)",
+                itr->str, retval, sol_util_strerrora(-retval));
+            FAIL();
+        } else if (itr->expected_return != 0 && retval == 0) {
+            SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                ", but got success with errno = %d (%s), value = %" PRIi32,
+                itr->str,
+                itr->expected_return, sol_util_strerrora(-itr->expected_return),
+                retval, sol_util_strerrora(-retval), value);
+            FAIL();
+        } else if (itr->expected_return != 0 && retval < 0) {
+            if (itr->expected_return != retval) {
+                SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                    ", but got errno = %d (%s), value = %" PRIi32,
+                    itr->str,
+                    itr->expected_return, sol_util_strerrora(-itr->expected_return),
+                    retval, sol_util_strerrora(-retval), value);
+                FAIL();
+            } else if (itr->reference != value) {
+                SOL_WRN("FAILED: parsing '%s' should result in %" PRIi32
+                    ", but got %" PRIi32, itr->str, itr->reference, value);
+                FAIL();
+            } else {
+                SOL_DBG("OK: parsed '%s' as %" PRIi32
+                    ", setting errno = %d (%s)",
+                    itr->str, value, retval, sol_util_strerrora(-retval));
+            }
+        }
+    }
+
+}
+
+DEFINE_TEST(test_json_token_get_double);
+
+static void
+test_json_token_get_double(void)
+{
+    char dbl_max_str[256], neg_dbl_max_str[256];
+    char dbl_max_str_overflow[256], neg_dbl_max_str_overflow[256];
+    const struct test_double {
+        const char *str;
+        double reference;
+        int expected_return;
+    } *itr, tests[] = {
+        { "0", 0.0, 0 },
+        { "123", 123.0, 0 },
+        { "1.0", 1.0, 0 },
+        { "123.456", 123.456, 0 },
+        { "345e+12", 345e12, 0 },
+        { "345e-12", 345e-12, 0 },
+        { "345E+12", 345e12, 0 },
+        { "345E-12", 345e-12, 0 },
+        { "-1.0", -1.0, 0 },
+        { "-123.456", -123.456, 0 },
+        { "-345e+12", -345e12, 0 },
+        { "-345e-12", -345e-12, 0 },
+        { "-345E+12", -345e12, 0 },
+        { "-345E-12", -345e-12, 0 },
+        { "-345.678e+12", -345.678e12, 0 },
+        { "-345.678e-12", -345.678e-12, 0 },
+        { "-345.678E+12", -345.678e12, 0 },
+        { "-345.678E-12", -345.678e-12, 0 },
+        { dbl_max_str, DBL_MAX, 0 },
+        { neg_dbl_max_str, -DBL_MAX, 0 },
+        { dbl_max_str_overflow, DBL_MAX, -ERANGE },
+        { neg_dbl_max_str_overflow, -DBL_MAX, -ERANGE },
+        { "x", 0, -EINVAL },
+        { "", 0, -EINVAL },
+        {}
+    };
+
+    snprintf(dbl_max_str, sizeof(dbl_max_str), "%.64g", DBL_MAX);
+    snprintf(neg_dbl_max_str, sizeof(neg_dbl_max_str), "%.64g", -DBL_MAX);
+    snprintf(dbl_max_str_overflow, sizeof(dbl_max_str_overflow), "%.64g0", DBL_MAX);
+    snprintf(neg_dbl_max_str_overflow, sizeof(neg_dbl_max_str_overflow), "%.64g0", -DBL_MAX);
+
+    for (itr = tests; itr->str != NULL; itr++) {
+        double value;
+        char buf[512];
+        struct sol_json_token token;
+        int retval;
+
+        snprintf(buf, sizeof(buf), "%s123garbage", itr->str);
+        token.start = buf;
+        token.end = buf + strlen(itr->str);
+        retval = sol_json_token_get_double(&token, &value);
+        if (itr->expected_return == 0 && retval == 0) {
+            if (sol_drange_val_equal(itr->reference, value)) {
+                SOL_DBG("OK: parsed '%s' as %g", itr->str, value);
+            } else {
+                SOL_WRN("FAILED: parsed '%s' as %.64g where %.64g was expected"
+                    " (difference = %g)",
+                    itr->str, value, itr->reference, itr->reference - value);
+                FAIL();
+            }
+        } else if (itr->expected_return == 0 && retval < 0) {
+            SOL_WRN("FAILED: parsing '%s' failed with errno = %d (%s)",
+                itr->str, retval, sol_util_strerrora(-retval));
+            FAIL();
+        } else if (itr->expected_return != 0 && retval == 0) {
+            SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                ", but got success with errno = %d (%s), value = %g",
+                itr->str,
+                itr->expected_return, sol_util_strerrora(-itr->expected_return),
+                retval, sol_util_strerrora(-retval), value);
+            FAIL();
+        } else if (itr->expected_return != 0 && retval < 0) {
+            if (itr->expected_return != retval) {
+                SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                    ", but got errno = %d (%s), value = %g",
+                    itr->str,
+                    itr->expected_return, sol_util_strerrora(-itr->expected_return),
+                    retval, sol_util_strerrora(-retval), value);
+                FAIL();
+            } else if (!sol_drange_val_equal(itr->reference, value)) {
+                SOL_WRN("FAILED: parsing '%s' should result in %.64g"
+                    ", but got %.64g (difference = %g)",
+                    itr->str, itr->reference, value, itr->reference - value);
+                FAIL();
+            } else {
+                SOL_DBG("OK: parsed '%s' as %g, setting errno = %d (%s)",
+                    itr->str, value, retval, sol_util_strerrora(-retval));
+            }
+        }
+    }
+}
+
 TEST_MAIN();
diff --git a/src/test/test-util.c b/src/test/test-util.c
index 4f332041..dd80c88e 100644
--- a/src/test/test-util.c
+++ b/src/test/test-util.c
@@ -33,11 +33,17 @@
 #include <errno.h>
 #include <limits.h>
 #include <stdbool.h>
+#include <float.h>
+#ifdef HAVE_LOCALE
+#include <locale.h>
+#endif
 
 #include "sol-util.h"
+#include "sol-log.h"
 
 #include "test.h"
 
+
 DEFINE_TEST(test_align_power2);
 
 static void
@@ -82,13 +88,195 @@ static void
 test_size_mul(void)
 {
     const size_t half_size = SIZE_MAX / 2;
+    const size_t half_double_size = (SIZE_MAX % 2) ? (SIZE_MAX - 1) : SIZE_MAX;
     size_t out;
 
     ASSERT(sol_util_size_mul(half_size, 2, &out) == 0);
-    ASSERT_INT_EQ(out, SIZE_MAX);
+    ASSERT_INT_EQ(out, half_double_size);
 
     ASSERT_INT_EQ(sol_util_size_mul(half_size, 4, &out), -EOVERFLOW);
 }
 
+DEFINE_TEST(test_strtodn);
+
+static void
+test_strtodn(void)
+{
+#ifdef HAVE_LOCALE
+    char *oldloc;
+    const char *comma_locales[] = {
+        "pt", "pt_BR", "de", "it", "ru", NULL
+    };
+    const char *comma_locale;
+#endif
+    char dbl_max_str[256], neg_dbl_max_str[256];
+    char dbl_max_str_overflow[256], neg_dbl_max_str_overflow[256];
+    const struct test {
+        const char *str;
+        double reference;
+        int expected_errno;
+        bool use_locale;
+        int endptr_offset;
+    } *itr, tests[] = {
+        { "0", 0.0, 0, false, -1 },
+        { "123", 123.0, 0, false, -1 },
+        { "1.0", 1.0, 0, false, -1 },
+        { "123.456", 123.456, 0, false, -1 },
+        { "345e+12", 345e12, 0, false, -1 },
+        { "345e-12", 345e-12, 0, false, -1 },
+        { "345E+12", 345e12, 0, false, -1 },
+        { "345E-12", 345e-12, 0, false, -1 },
+        { "-1.0", -1.0, 0, false, -1 },
+        { "-123.456", -123.456, 0, false, -1 },
+        { "-345e+12", -345e12, 0, false, -1 },
+        { "-345e-12", -345e-12, 0, false, -1 },
+        { "-345E+12", -345e12, 0, false, -1 },
+        { "-345E-12", -345e-12, 0, false, -1 },
+        { "-345.678e+12", -345.678e12, 0, false, -1 },
+        { "-345.678e-12", -345.678e-12, 0, false, -1 },
+        { "-345.678E+12", -345.678e12, 0, false, -1 },
+        { "-345.678E-12", -345.678e-12, 0, false, -1 },
+        { dbl_max_str, DBL_MAX, 0, false, -1 },
+        { neg_dbl_max_str, -DBL_MAX, 0, false, -1 },
+        { dbl_max_str_overflow, DBL_MAX, ERANGE, false, -1 },
+        { neg_dbl_max_str_overflow, -DBL_MAX, ERANGE, false, -1 },
+        { "x", 0, 0, false, 0 },
+        { "1x", 1.0, 0, false, 1 },
+        { "12,3", 12.0, 0, false, 2 },
+        { "", 0, 0, false, 0 },
+#ifdef HAVE_LOCALE
+        /* commas as decimal separators */
+        { "1,0", 1.0, 0, true, -1 },
+        { "123,456", 123.456, 0, true, -1 },
+        { "345e+12", 345e12, 0, true, -1 },
+        { "345e-12", 345e-12, 0, true, -1 },
+        { "345E+12", 345e12, 0, true, -1 },
+        { "345E-12", 345e-12, 0, true, -1 },
+        { "-1,0", -1.0, 0, true, -1 },
+        { "-123,456", -123.456, 0, true, -1 },
+        { "-345e+12", -345e12, 0, true, -1 },
+        { "-345e-12", -345e-12, 0, true, -1 },
+        { "-345E+12", -345e12, 0, true, -1 },
+        { "-345E-12", -345e-12, 0, true, -1 },
+        { "-345,678e+12", -345.678e12, 0, true, -1 },
+        { "-345,678e-12", -345.678e-12, 0, true, -1 },
+        { "-345,678E+12", -345.678e12, 0, true, -1 },
+        { "-345,678E-12", -345.678e-12, 0, true, -1 },
+        { "12.3", 12.0, 0, true, 2 },
+#endif
+        {}
+    };
+
+#ifdef HAVE_LOCALE
+    oldloc = setlocale(LC_ALL, NULL);
+    if (oldloc)
+        oldloc = strdupa(oldloc);
+    setlocale(LC_ALL, "C");
+#endif
+
+    snprintf(dbl_max_str, sizeof(dbl_max_str), "%.64g", DBL_MAX);
+    snprintf(neg_dbl_max_str, sizeof(neg_dbl_max_str), "%.64g", -DBL_MAX);
+    snprintf(dbl_max_str_overflow, sizeof(dbl_max_str_overflow), "%.64g0", DBL_MAX);
+    snprintf(neg_dbl_max_str_overflow, sizeof(neg_dbl_max_str_overflow), "%.64g0", -DBL_MAX);
+
+#ifdef HAVE_LOCALE
+    {
+        const char **loc;
+        comma_locale = NULL;
+        for (loc = comma_locales; *loc != NULL; loc++) {
+            if (setlocale(LC_ALL, *loc)) {
+                setlocale(LC_ALL, oldloc);
+                SOL_DBG("Using locale '%s' to produce commas as "
+                    "decimal separator. Ex: %0.2f", *loc, 1.23);
+                comma_locale = *loc;
+                break;
+            }
+        }
+        if (!comma_locale) {
+            setlocale(LC_ALL, oldloc);
+            SOL_WRN("Couldn't find a locale with decimal commas");
+        }
+    }
+#endif
+
+    for (itr = tests; itr->str != NULL; itr++) {
+        double value;
+        char buf[512];
+        char *endptr;
+        size_t slen = strlen(itr->str);
+        int endptr_offset, wanted_endptr_offset;
+        int reterr;
+
+        snprintf(buf, sizeof(buf), "%s123garbage", itr->str);
+
+        if (comma_locale)
+            setlocale(LC_ALL, comma_locale);
+        else if (itr->use_locale) {
+            SOL_DBG("SKIP (no comma locale): '%s'", itr->str);
+            continue;
+        }
+
+        value = sol_util_strtodn(buf, &endptr, slen, itr->use_locale);
+        reterr = errno;
+
+        endptr_offset = endptr - buf;
+
+        if (comma_locale)
+            setlocale(LC_ALL, oldloc);
+
+        wanted_endptr_offset = itr->endptr_offset;
+        if (wanted_endptr_offset < 0)
+            wanted_endptr_offset = slen;
+
+        if (itr->expected_errno == 0 && reterr == 0) {
+            if (sol_drange_val_equal(itr->reference, value)) {
+                SOL_DBG("OK: parsed '%s' as %g (locale:%u)", itr->str, value,
+                    itr->use_locale);
+            } else {
+                SOL_WRN("FAILED: parsed '%s' as %.64g where %.64g was expected"
+                    " (difference = %g) (locale:%u)",
+                    itr->str, value, itr->reference, itr->reference - value,
+                    itr->use_locale);
+                FAIL();
+            }
+        } else if (itr->expected_errno == 0 && reterr < 0) {
+            SOL_WRN("FAILED: parsing '%s' failed with errno = %d (%s) (locale:%u)",
+                itr->str, reterr, sol_util_strerrora(reterr), itr->use_locale);
+            FAIL();
+        } else if (itr->expected_errno != 0 && reterr == 0) {
+            SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                ", but got success with errno = %d (%s), value = %g (locale:%u)",
+                itr->str,
+                itr->expected_errno, sol_util_strerrora(itr->expected_errno),
+                reterr, sol_util_strerrora(reterr), value, itr->use_locale);
+            FAIL();
+        } else if (itr->expected_errno != 0 && reterr < 0) {
+            if (itr->expected_errno != reterr) {
+                SOL_WRN("FAILED: parsing '%s' should fail with errno = %d (%s)"
+                    ", but got errno = %d (%s), value = %g (locale:%u)",
+                    itr->str,
+                    itr->expected_errno, sol_util_strerrora(itr->expected_errno),
+                    reterr, sol_util_strerrora(reterr), value, itr->use_locale);
+                FAIL();
+            } else if (!sol_drange_val_equal(itr->reference, value)) {
+                SOL_WRN("FAILED: parsing '%s' should result in %.64g"
+                    ", but got %.64g (difference = %g) (locale:%u)",
+                    itr->str, itr->reference, value, itr->reference - value,
+                    itr->use_locale);
+                FAIL();
+            } else {
+                SOL_DBG("OK: parsed '%s' as %g, setting errno = %d (%s) (locale:%u)",
+                    itr->str, value, reterr, sol_util_strerrora(reterr), itr->use_locale);
+            }
+        }
+
+        if (wanted_endptr_offset != endptr_offset) {
+            SOL_WRN("FAILED: parsing '%s' should stop at offset %d, but got %d  (locale:%u)",
+                itr->str, wanted_endptr_offset, endptr_offset, itr->use_locale);
+            FAIL();
+        }
+    }
+}
+
 
 TEST_MAIN();