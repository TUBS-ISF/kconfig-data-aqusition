"2003-08-05 02:18:25 +0000"
diff --git a/scripts/config/conf.c b/scripts/config/conf.c
index 884175e54..013a679dd 100644
--- a/scripts/config/conf.c
+++ b/scripts/config/conf.c
@@ -35,50 +35,12 @@ static struct menu *rootEntry;
 
 static char nohelp_text[] = "Sorry, no help available for this option yet.\n";
 
-#if 0
-static void printc(int ch)
-{
-	static int sep = 0;
-
-	if (!sep) {
-		putchar('[');
-		sep = 1;
-	} else if (ch)
-		putchar('/');
-	if (!ch) {
-		putchar(']');
-		putchar(' ');
-		sep = 0;
-	} else
-		putchar(ch);
-}
-#endif
-
-static void printo(const char *o)
-{
-	static int sep = 0;
-
-	if (!sep) {
-		putchar('(');
-		sep = 1;
-	} else if (o) {
-		putchar(',');
-		putchar(' ');
-	}
-	if (!o) {
-		putchar(')');
-		putchar(' ');
-		sep = 0;
-	} else
-		printf("%s", o);
-}
-
 static void strip(char *str)
 {
 	char *p = str;
 	int l;
 
-	while ((isspace((int)*p)))
+	while ((isspace(*p)))
 		p++;
 	l = strlen(p);
 	if (p != str)
@@ -86,10 +48,20 @@ static void strip(char *str)
 	if (!l)
 		return;
 	p = str + l - 1;
-	while ((isspace((int)*p)))
+	while ((isspace(*p)))
 		*p-- = 0;
 }
 
+static void check_stdin(void)
+{
+	if (!valid_stdin && input_mode == ask_silent) {
+		printf("aborted!\n\n");
+		printf("Console input/output is redirected. ");
+		printf("Run 'make oldconfig' to update configuration.\n\n");
+		exit(1);
+	}
+}
+
 static void conf_askvalue(struct symbol *sym, const char *def)
 {
 	enum symbol_type type = sym_get_type(sym);
@@ -101,6 +73,13 @@ static void conf_askvalue(struct symbol *sym, const char *def)
 	line[0] = '\n';
 	line[1] = 0;
 
+	if (!sym_is_changable(sym)) {
+		printf("%s\n", def);
+		line[0] = '\n';
+		line[1] = 0;
+		return;
+	}
+
 	switch (input_mode) {
 	case ask_new:
 	case ask_silent:
@@ -108,12 +87,7 @@ static void conf_askvalue(struct symbol *sym, const char *def)
 			printf("%s\n", def);
 			return;
 		}
-		if (!valid_stdin && input_mode == ask_silent) {
-			printf("aborted!\n\n");
-			printf("Console input/output is redirected. ");
-			printf("Run 'make oldconfig' to update configuration.\n\n");
-			exit(1);
-		}
+		check_stdin();
 	case ask_all:
 		fflush(stdout);
 		fgets(line, 128, stdin);
@@ -294,9 +268,8 @@ help:
 static int conf_choice(struct menu *menu)
 {
 	struct symbol *sym, *def_sym;
-	struct menu *cmenu, *def_menu;
-	const char *help;
-	int type, len;
+	struct menu *child;
+	int type;
 	bool is_new;
 
 	sym = menu->sym;
@@ -314,72 +287,111 @@ static int conf_choice(struct menu *menu)
 			break;
 		}
 	} else {
-		sym->def = sym->curr;
-		if (S_TRI(sym->curr) == mod) {
+		switch (sym_get_tristate_value(sym)) {
+		case no:
+			return 1;
+		case mod:
 			printf("%*s%s\n", indent - 1, "", menu_get_prompt(menu));
 			return 0;
+		case yes:
+			break;
 		}
 	}
 
 	while (1) {
-		printf("%*s%s ", indent - 1, "", menu_get_prompt(menu));
+		int cnt, def;
+
+		printf("%*s%s\n", indent - 1, "", menu_get_prompt(menu));
 		def_sym = sym_get_choice_value(sym);
-		def_menu = NULL;
-		for (cmenu = menu->list; cmenu; cmenu = cmenu->next) {
-			if (!menu_is_visible(cmenu))
+		cnt = def = 0;
+		line[0] = '0';
+		line[1] = 0;
+		for (child = menu->list; child; child = child->next) {
+			if (!menu_is_visible(child))
 				continue;
-			printo(menu_get_prompt(cmenu));
-			if (cmenu->sym == def_sym)
-				def_menu = cmenu;
-		}
-		printo(NULL);
-		if (def_menu)
-			printf("[%s] ", menu_get_prompt(def_menu));
-		else {
+			if (!child->sym) {
+				printf("%*c %s\n", indent, '*', menu_get_prompt(child));
+				continue;
+			}
+			cnt++;
+			if (child->sym == def_sym) {
+				def = cnt;
+				printf("%*c", indent, '>');
+			} else
+				printf("%*c", indent, ' ');
+			printf(" %d. %s", cnt, menu_get_prompt(child));
+			if (child->sym->name)
+				printf(" (%s)", child->sym->name);
+			if (!sym_has_value(child->sym))
+				printf(" (NEW)");
 			printf("\n");
-			return 1;
 		}
+		printf("%*schoice", indent - 1, "");
+		if (cnt == 1) {
+			printf("[1]: 1\n");
+			goto conf_childs;
+		}
+		printf("[1-%d", cnt);
+		if (sym->help)
+			printf("?");
+		printf("]: ");
 		switch (input_mode) {
 		case ask_new:
 		case ask_silent:
+			if (!is_new) {
+				cnt = def;
+				printf("%d\n", cnt);
+				break;
+			}
+			check_stdin();
 		case ask_all:
-			conf_askvalue(sym, menu_get_prompt(def_menu));
+			fflush(stdout);
+			fgets(line, 128, stdin);
 			strip(line);
+			if (line[0] == '?') {
+				printf("\n%s\n", menu->sym->help ?
+					menu->sym->help : nohelp_text);
+				continue;
+			}
+			if (!line[0])
+				cnt = def;
+			else if (isdigit(line[0]))
+				cnt = atoi(line);
+			else
+				continue;
+			break;
+		case set_random:
+			def = (random() % cnt) + 1;
+		case set_default:
+		case set_yes:
+		case set_mod:
+		case set_no:
+			cnt = def;
+			printf("%d\n", cnt);
 			break;
-		default:
-			line[0] = 0;
-			printf("\n");
 		}
-		if (line[0] == '?' && !line[1]) {
-			help = nohelp_text;
-			if (menu->sym->help)
-				help = menu->sym->help;
-			printf("\n%s\n", help);
-			continue;
+
+	conf_childs:
+		for (child = menu->list; child; child = child->next) {
+			if (!child->sym || !menu_is_visible(child))
+				continue;
+			if (!--cnt)
+				break;
 		}
-		if (line[0]) {
-			len = strlen(line);
-			line[len] = 0;
-
-			def_menu = NULL;
-			for (cmenu = menu->list; cmenu; cmenu = cmenu->next) {
-				if (!cmenu->sym || !menu_is_visible(cmenu))
-					continue;
-				if (!strncasecmp(line, menu_get_prompt(cmenu), len)) {
-					def_menu = cmenu;
-					break;
-				}
-			}
+		if (!child)
+			continue;
+		if (line[strlen(line) - 1] == '?') {
+			printf("\n%s\n", child->sym->help ?
+				child->sym->help : nohelp_text);
+			continue;
 		}
-		if (def_menu) {
-			sym_set_choice_value(sym, def_menu->sym);
-			if (def_menu->list) {
-				indent += 2;
-				conf(def_menu->list);
-				indent -= 2;
-			}
-			return 1;
+		sym_set_choice_value(sym, child->sym);
+		if (child->list) {
+			indent += 2;
+			conf(child->list);
+			indent -= 2;
 		}
+		return 1;
 	}
 }
 
@@ -420,7 +432,7 @@ static void conf(struct menu *menu)
 
 	if (sym_is_choice(sym)) {
 		conf_choice(menu);
-		if (S_TRI(sym->curr) != mod)
+		if (sym->curr.tri != mod)
 			return;
 		goto conf_childs;
 	}
@@ -454,29 +466,17 @@ static void check_conf(struct menu *menu)
 		return;
 
 	sym = menu->sym;
-	if (!sym)
-		goto conf_childs;
-
-	if (sym_is_choice(sym)) {
-		if (!sym_has_value(sym)) {
+	if (sym) {
+		if (sym_is_changable(sym) && !sym_has_value(sym)) {
 			if (!conf_cnt++)
 				printf("*\n* Restart config...\n*\n");
 			rootEntry = menu_get_parent_menu(menu);
 			conf(rootEntry);
 		}
-		if (sym_get_tristate_value(sym) != mod)
+		if (sym_is_choice(sym) && sym_get_tristate_value(sym) != mod)
 			return;
-		goto conf_childs;
 	}
 
-	if (!sym_has_value(sym)) {
-		if (!conf_cnt++)
-			printf("*\n* Restart config...\n*\n");
-		rootEntry = menu_get_parent_menu(menu);
-		conf(rootEntry);
-	}
-
-conf_childs:
 	for (child = menu->list; child; child = child->next)
 		check_conf(child);
 }
@@ -536,8 +536,8 @@ int main(int ac, char **av)
 			printf("***\n"
 				"*** You have not yet configured BusyBox!\n"
 				"***\n"
-				"*** Please run some configurator (e.g. \"make oldconfig\"\n"
-				"*** or \"make menuconfig\").\n"
+				"*** Please run some configurator (e.g. \"make config\" or\n"
+				"*** \"make oldconfig\" or \"make menuconfig\").\n"
 				"***\n");
 			exit(1);
 		}
diff --git a/scripts/config/confdata.c b/scripts/config/confdata.c
index 0d24ac52f..c6a2864dc 100644
--- a/scripts/config/confdata.c
+++ b/scripts/config/confdata.c
@@ -1,11 +1,9 @@
 /*
  * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
  * Released under the terms of the GNU GPL v2.0.
- *
- * Allow 'n' as a symbol value.
- * 2002-11-05 Petr Baudis <pasky@ucw.cz>
  */
 
+#include <sys/stat.h>
 #include <ctype.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -38,7 +36,7 @@ static char *conf_expand_value(const char *in)
 		strncat(res_value, in, src - in);
 		src++;
 		dst = name;
-		while (isalnum((int)*src) || *src == '_')
+		while (isalnum(*src) || *src == '_')
 			*dst++ = *src++;
 		*dst = 0;
 		sym = sym_lookup(name, 0);
@@ -53,7 +51,18 @@ static char *conf_expand_value(const char *in)
 
 char *conf_get_default_confname(void)
 {
-	return conf_expand_value(conf_defname);
+	struct stat buf;
+	static char fullname[4096+1];
+	char *env, *name;
+
+	name = conf_expand_value(conf_defname);
+	env = getenv(SRCTREE);
+	if (env) {
+		sprintf(fullname, "%s/%s", env, name);
+		if (!stat(fullname, &buf))
+			return fullname;
+	}
+	return name;
 }
 
 int conf_read(const char *name)
@@ -68,12 +77,12 @@ int conf_read(const char *name)
 	int i;
 
 	if (name) {
-		in = fopen(name, "r");
+		in = zconf_fopen(name);
 	} else {
 		const char **names = conf_confnames;
 		while ((name = *names++)) {
 			name = conf_expand_value(name);
-			in = fopen(name, "r");
+			in = zconf_fopen(name);
 			if (in) {
 				printf("#\n"
 				       "# using defaults found in %s\n"
@@ -93,44 +102,43 @@ int conf_read(const char *name)
 		case S_INT:
 		case S_HEX:
 		case S_STRING:
-			if (S_VAL(sym->def))
-				free(S_VAL(sym->def));
+			if (sym->user.val)
+				free(sym->user.val);
 		default:
-			S_VAL(sym->def) = NULL;
-			S_TRI(sym->def) = no;
-			;
+			sym->user.val = NULL;
+			sym->user.tri = no;
 		}
 	}
 
 	while (fgets(line, sizeof(line), in)) {
 		lineno++;
+		sym = NULL;
 		switch (line[0]) {
-		case '\n':
-			break;
-		case ' ':
-			break;
 		case '#':
-			p = strchr(line, ' ');
-			if (!p)
+			if (line[1]!=' ')
 				continue;
-			*p++ = 0;
-			p = strchr(p, ' ');
+			p = strchr(line + 2, ' ');
 			if (!p)
 				continue;
 			*p++ = 0;
 			if (strncmp(p, "is not set", 10))
 				continue;
-			sym = sym_lookup(line+2, 0);
+			sym = sym_find(line + 2);
+			if (!sym) {
+				fprintf(stderr, "%s:%d: trying to assign nonexistent symbol %s\n", name, lineno, line + 2);
+				break;
+			}
 			switch (sym->type) {
 			case S_BOOLEAN:
 			case S_TRISTATE:
-				sym->def = symbol_no.curr;
+				sym->user.tri = no;
 				sym->flags &= ~SYMBOL_NEW;
 				break;
 			default:
 				;
 			}
 			break;
+
 		case 'A' ... 'Z':
 			p = strchr(line, '=');
 			if (!p)
@@ -145,24 +153,24 @@ int conf_read(const char *name)
 				break;
 			}
 			switch (sym->type) {
-  			case S_TRISTATE:
+			case S_TRISTATE:
 				if (p[0] == 'm') {
-					S_TRI(sym->def) = mod;
+					sym->user.tri = mod;
 					sym->flags &= ~SYMBOL_NEW;
 					break;
 				}
 			case S_BOOLEAN:
 				if (p[0] == 'y') {
-					S_TRI(sym->def) = yes;
+					sym->user.tri = yes;
 					sym->flags &= ~SYMBOL_NEW;
 					break;
 				}
 				if (p[0] == 'n') {
-					S_TRI(sym->def) = no;
+					sym->user.tri = no;
 					sym->flags &= ~SYMBOL_NEW;
 					break;
 				}
-  				break;
+				break;
 			case S_STRING:
 				if (*p++ != '"')
 					break;
@@ -173,48 +181,71 @@ int conf_read(const char *name)
 					}
 					memmove(p2, p2 + 1, strlen(p2));
 				}
+				if (!p2) {
+					fprintf(stderr, "%s:%d: invalid string found\n", name, lineno);
+					exit(1);
+				}
 			case S_INT:
 			case S_HEX:
 				if (sym_string_valid(sym, p)) {
-					S_VAL(sym->def) = strdup(p);
+					sym->user.val = strdup(p);
 					sym->flags &= ~SYMBOL_NEW;
-				} else
-					fprintf(stderr, "%s:%d:symbol value '%s' invalid for %s\n", name, lineno, p, sym->name);
+				} else {
+					fprintf(stderr, "%s:%d: symbol value '%s' invalid for %s\n", name, lineno, p, sym->name);
+					exit(1);
+				}
 				break;
 			default:
 				;
 			}
-			if (sym_is_choice_value(sym)) {
-				prop = sym_get_choice_prop(sym);
-				switch (S_TRI(sym->def)) {
-				case mod:
-					if (S_TRI(prop->def->def) == yes)
-						/* warn? */;
-					break;
-				case yes:
-					if (S_TRI(prop->def->def) != no)
-						/* warn? */;
-					S_VAL(prop->def->def) = sym;
-					break;
-				case no:
-					break;
-				}
-				S_TRI(prop->def->def) = S_TRI(sym->def);
-			}
+			break;
+		case '\n':
 			break;
 		default:
 			continue;
 		}
+		if (sym && sym_is_choice_value(sym)) {
+			struct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));
+			switch (sym->user.tri) {
+			case no:
+				break;
+			case mod:
+				if (cs->user.tri == yes)
+					/* warn? */;
+				break;
+			case yes:
+				if (cs->user.tri != no)
+					/* warn? */;
+				cs->user.val = sym;
+				break;
+			}
+			cs->user.tri = E_OR(cs->user.tri, sym->user.tri);
+			cs->flags &= ~SYMBOL_NEW;
+		}
 	}
 	fclose(in);
 
 	for_all_symbols(i, sym) {
+		sym_calc_value(sym);
+		if (sym_has_value(sym) && !sym_is_choice_value(sym)) {
+			if (sym->visible == no)
+				sym->flags |= SYMBOL_NEW;
+			switch (sym->type) {
+			case S_STRING:
+			case S_INT:
+			case S_HEX:
+				if (!sym_string_within_range(sym, sym->user.val))
+					sym->flags |= SYMBOL_NEW;
+			default:
+				break;
+			}
+		}
 		if (!sym_is_choice(sym))
 			continue;
 		prop = sym_get_choice_prop(sym);
-		for (e = prop->dep; e; e = e->left.expr)
-			sym->flags |= e->right.sym->flags & SYMBOL_NEW;
-		sym->flags &= ~SYMBOL_NEW;
+		for (e = prop->expr; e; e = e->left.expr)
+			if (e->right.sym->visible != no)
+				sym->flags |= e->right.sym->flags & SYMBOL_NEW;
 	}
 
 	sym_change_count = 1;
@@ -227,29 +258,50 @@ int conf_write(const char *name)
 	FILE *out, *out_h;
 	struct symbol *sym;
 	struct menu *menu;
-	char oldname[128];
+	const char *basename;
+	char dirname[128], tmpname[128], newname[128];
 	int type, l;
 	const char *str;
 
-	out = fopen(".tmpconfig", "w");
+	dirname[0] = 0;
+	if (name && name[0]) {
+		char *slash = strrchr(name, '/');
+		if (slash) {
+			int size = slash - name + 1;
+			memcpy(dirname, name, size);
+			dirname[size] = 0;
+			if (slash[1])
+				basename = slash + 1;
+			else
+				basename = conf_def_filename;
+		} else
+			basename = name;
+	} else
+		basename = conf_def_filename;
+
+	sprintf(newname, "%s.tmpconfig.%d", dirname, getpid());
+	out = fopen(newname, "w");
 	if (!out)
 		return 1;
-	out_h = fopen(".tmpconfig.h", "w");
-	if (!out_h)
-		return 1;
+	out_h = NULL;
+	if (!name) {
+		out_h = fopen(".tmpconfig.h", "w");
+		if (!out_h)
+			return 1;
+	}
 	fprintf(out, "#\n"
 		     "# Automatically generated make config: don't edit\n"
 		     "#\n");
-	fprintf(out_h, "/*\n"
-		       " * Automatically generated header file: don't edit\n"
-		       " */\n\n"
-		       "#define AUTOCONF_INCLUDED\n\n"
-		       "/* Version Number */\n"
-		       "#define BB_VER \"%s\"\n"
-		       "#define BB_BT \"%s\"\n\n",
-		       getenv("VERSION"),
-		       getenv("BUILDTIME")
-       );
+	if (out_h)
+		fprintf(out_h, "/*\n"
+			     " * Automatically generated header file: don't edit\n"
+			     " */\n\n"
+			     "#define AUTOCONF_INCLUDED\n\n"
+			     "/* Version Number */\n"
+			     "#define BB_VER \"%s\"\n"
+			     "#define BB_BT \"%s\"\n\n",
+			     getenv("VERSION"),
+			     getenv("BUILDTIME"));
 
 	if (!sym_change_count)
 		sym_clear_all_valid();
@@ -265,10 +317,11 @@ int conf_write(const char *name)
 				     "#\n"
 				     "# %s\n"
 				     "#\n", str);
-			fprintf(out_h, "\n"
-				       "/*\n"
-				       " * %s\n"
-				       " */\n", str);
+			if (out_h)
+				fprintf(out_h, "\n"
+					       "/*\n"
+					       " * %s\n"
+					       " */\n", str);
 		} else if (!(sym->flags & SYMBOL_CHOICE)) {
 			sym_calc_value(sym);
 			if (!(sym->flags & SYMBOL_WRITE))
@@ -277,7 +330,7 @@ int conf_write(const char *name)
 			type = sym->type;
 			if (type == S_TRISTATE) {
 				sym_calc_value(modules_sym);
-				if (S_TRI(modules_sym->curr) == no)
+				if (modules_sym->curr.tri == no)
 					type = S_BOOLEAN;
 			}
 			switch (type) {
@@ -286,17 +339,20 @@ int conf_write(const char *name)
 				switch (sym_get_tristate_value(sym)) {
 				case no:
 					fprintf(out, "# %s is not set\n", sym->name);
-					fprintf(out_h, "#undef %s\n", sym->name);
+					if (out_h)
+						fprintf(out_h, "#undef %s\n", sym->name);
 					break;
-				case mod:
 #if 0
+				case mod:
 					fprintf(out, "%s=m\n", sym->name);
-					fprintf(out_h, "#define __%s__MODULE 1\n", sym->name);
-#endif
+					if (out_h)
+						fprintf(out_h, "#define %s_MODULE 1\n", sym->name);
 					break;
+#endif
 				case yes:
 					fprintf(out, "%s=y\n", sym->name);
-					fprintf(out_h, "#define %s 1\n", sym->name);
+					if (out_h)
+						fprintf(out_h, "#define %s 1\n", sym->name);
 					break;
 				}
 				break;
@@ -304,34 +360,40 @@ int conf_write(const char *name)
 				// fix me
 				str = sym_get_string_value(sym);
 				fprintf(out, "%s=\"", sym->name);
-				fprintf(out_h, "#define %s \"", sym->name);
+				if (out_h)
+					fprintf(out_h, "#define %s \"", sym->name);
 				do {
 					l = strcspn(str, "\"\\");
 					if (l) {
 						fwrite(str, l, 1, out);
-						fwrite(str, l, 1, out_h);
+						if (out_h)
+							fwrite(str, l, 1, out_h);
 					}
 					str += l;
 					while (*str == '\\' || *str == '"') {
 						fprintf(out, "\\%c", *str);
-						fprintf(out_h, "\\%c", *str);
+						if (out_h)
+							fprintf(out_h, "\\%c", *str);
 						str++;
 					}
 				} while (*str);
 				fputs("\"\n", out);
-				fputs("\"\n", out_h);
+				if (out_h)
+					fputs("\"\n", out_h);
 				break;
 			case S_HEX:
 				str = sym_get_string_value(sym);
 				if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
 					fprintf(out, "%s=%s\n", sym->name, str);
-					fprintf(out_h, "#define %s 0x%s\n", sym->name, str);
+					if (out_h)
+						fprintf(out_h, "#define %s 0x%s\n", sym->name, str);
 					break;
 				}
 			case S_INT:
 				str = sym_get_string_value(sym);
 				fprintf(out, "%s=%s\n", sym->name, str);
-				fprintf(out_h, "#define %s %s\n", sym->name, str);
+				if (out_h)
+					fprintf(out_h, "#define %s %s\n", sym->name, str);
 				break;
 			}
 		}
@@ -351,18 +413,19 @@ int conf_write(const char *name)
 		}
 	}
 	fclose(out);
-	fclose(out_h);
-
-	if (!name) {
+	if (out_h) {
+		fclose(out_h);
 		rename(".tmpconfig.h", "include/config.h");
-		name = conf_def_filename;
 		file_write_dep(NULL);
-	} else
-		unlink(".tmpconfig.h");
-
-	sprintf(oldname, "%s.old", name);
-	rename(name, oldname);
-	if (rename(".tmpconfig", name))
+	}
+	if (!name || basename != conf_def_filename) {
+		if (!name)
+			name = conf_def_filename;
+		sprintf(tmpname, "%s.old", name);
+		rename(name, tmpname);
+	}
+	sprintf(tmpname, "%s%s", dirname, basename);
+	if (rename(newname, tmpname))
 		return 1;
 
 	sym_change_count = 0;
diff --git a/scripts/config/expr.c b/scripts/config/expr.c
index d1af2a581..3f15ae859 100644
--- a/scripts/config/expr.c
+++ b/scripts/config/expr.c
@@ -55,6 +55,13 @@ struct expr *expr_alloc_and(struct expr *e1, struct expr *e2)
 	return e2 ? expr_alloc_two(E_AND, e1, e2) : e1;
 }
 
+struct expr *expr_alloc_or(struct expr *e1, struct expr *e2)
+{
+	if (!e1)
+		return e2;
+	return e2 ? expr_alloc_two(E_OR, e1, e2) : e1;
+}
+
 struct expr *expr_copy(struct expr *org)
 {
 	struct expr *e;
@@ -158,9 +165,22 @@ static void __expr_eliminate_eq(enum expr_type type, struct expr **ep1, struct e
 
 void expr_eliminate_eq(struct expr **ep1, struct expr **ep2)
 {
-	if (!e1 || !e2 || e1->type != e2->type)
+	if (!e1 || !e2)
 		return;
-	__expr_eliminate_eq(e1->type, ep1, ep2);
+	switch (e1->type) {
+	case E_OR:
+	case E_AND:
+		__expr_eliminate_eq(e1->type, ep1, ep2);
+	default:
+		;
+	}
+	if (e1->type != e2->type) switch (e2->type) {
+	case E_OR:
+	case E_AND:
+		__expr_eliminate_eq(e2->type, ep1, ep2);
+	default:
+		;
+	}
 	e1 = expr_eliminate_yn(e1);
 	e2 = expr_eliminate_yn(e2);
 }
@@ -195,6 +215,7 @@ int expr_eq(struct expr *e1, struct expr *e2)
 		trans_count = old_count;
 		return res;
 	case E_CHOICE:
+	case E_RANGE:
 	case E_NONE:
 		/* panic */;
 	}
@@ -897,6 +918,7 @@ struct expr *expr_trans_compare(struct expr *e, enum expr_type type, struct symb
 	case E_SYMBOL:
 		return expr_alloc_comp(type, e->left.sym, sym);
 	case E_CHOICE:
+	case E_RANGE:
 	case E_NONE:
 		/* panic */;
 	}
@@ -914,7 +936,7 @@ tristate expr_calc_value(struct expr *e)
 	switch (e->type) {
 	case E_SYMBOL:
 		sym_calc_value(e->left.sym);
-		return S_TRI(e->left.sym->curr);
+		return e->left.sym->curr.tri;
 	case E_AND:
 		val1 = expr_calc_value(e->left.expr);
 		val2 = expr_calc_value(e->right.expr);
@@ -1017,11 +1039,18 @@ void expr_print(struct expr *e, void (*fn)(void *, const char *), void *data, in
 		expr_print(e->right.expr, fn, data, E_AND);
 		break;
 	case E_CHOICE:
+		fn(data, e->right.sym->name);
 		if (e->left.expr) {
-			expr_print(e->left.expr, fn, data, E_CHOICE);
 			fn(data, " ^ ");
+			expr_print(e->left.expr, fn, data, E_CHOICE);
 		}
+		break;
+	case E_RANGE:
+		fn(data, "[");
+		fn(data, e->left.sym->name);
+		fn(data, " ");
 		fn(data, e->right.sym->name);
+		fn(data, "]");
 		break;
 	default:
 	  {
diff --git a/scripts/config/expr.h b/scripts/config/expr.h
index e96d03b5a..cc616f1f8 100644
--- a/scripts/config/expr.h
+++ b/scripts/config/expr.h
@@ -18,10 +18,6 @@ extern "C" {
 struct file {
 	struct file *next;
 	struct file *parent;
-#ifdef CML1
-	struct statement *stmt;
-	struct statement *last_stmt;
-#endif
 	char *name;
 	int lineno;
 	int flags;
@@ -36,7 +32,7 @@ typedef enum tristate {
 } tristate;
 
 enum expr_type {
-	E_NONE, E_OR, E_AND, E_NOT, E_EQUAL, E_UNEQUAL, E_CHOICE, E_SYMBOL
+	E_NONE, E_OR, E_AND, E_NOT, E_EQUAL, E_UNEQUAL, E_CHOICE, E_SYMBOL, E_RANGE
 };
 
 union expr_data {
@@ -45,18 +41,10 @@ union expr_data {
 };
 
 struct expr {
-#ifdef CML1
-	int token;
-#else
 	enum expr_type type;
-#endif
 	union expr_data left, right;
 };
 
-#define E_TRI(ev)	((ev).tri)
-#define E_EXPR(ev)	((ev).expr)
-#define E_CALC(ev)	(E_TRI(ev) = expr_calc_value(E_EXPR(ev)))
-
 #define E_OR(dep1, dep2)	(((dep1)>(dep2))?(dep1):(dep2))
 #define E_AND(dep1, dep2)	(((dep1)<(dep2))?(dep1):(dep2))
 #define E_NOT(dep)		(2-(dep))
@@ -66,12 +54,8 @@ struct expr_value {
 	tristate tri;
 };
 
-#define S_VAL(sv)	((sv).value)
-#define S_TRI(sv)	((sv).tri)
-#define S_EQ(sv1, sv2)	(S_VAL(sv1) == S_VAL(sv2) || !strcmp(S_VAL(sv1), S_VAL(sv2)))
-
 struct symbol_value {
-	void *value;
+	void *val;
 	tristate tri;
 };
 
@@ -83,31 +67,17 @@ struct symbol {
 	struct symbol *next;
 	char *name;
 	char *help;
-#ifdef CML1
-	int type;
-#else
 	enum symbol_type type;
-#endif
-	struct symbol_value curr, def;
+	struct symbol_value curr, user;
 	tristate visible;
 	int flags;
 	struct property *prop;
 	struct expr *dep, *dep2;
-	struct menu *menu;
+	struct expr_value rev_dep;
 };
 
 #define for_all_symbols(i, sym) for (i = 0; i < 257; i++) for (sym = symbol_hash[i]; sym; sym = sym->next) if (sym->type != S_OTHER)
 
-#ifdef CML1
-#define SYMBOL_UNKNOWN		S_UNKNOWN
-#define SYMBOL_BOOLEAN		S_BOOLEAN
-#define SYMBOL_TRISTATE		S_TRISTATE
-#define SYMBOL_INT		S_INT
-#define SYMBOL_HEX		S_HEX
-#define SYMBOL_STRING		S_STRING
-#define SYMBOL_OTHER		S_OTHER
-#endif
-
 #define SYMBOL_YES		0x0001
 #define SYMBOL_MOD		0x0002
 #define SYMBOL_NO		0x0004
@@ -122,42 +92,38 @@ struct symbol {
 #define SYMBOL_CHANGED		0x0400
 #define SYMBOL_NEW		0x0800
 #define SYMBOL_AUTO		0x1000
+#define SYMBOL_CHECKED		0x2000
+#define SYMBOL_CHECK_DONE	0x4000
+#define SYMBOL_WARNED		0x8000
 
 #define SYMBOL_MAXLENGTH	256
 #define SYMBOL_HASHSIZE		257
 #define SYMBOL_HASHMASK		0xff
 
 enum prop_type {
-	P_UNKNOWN, P_PROMPT, P_COMMENT, P_MENU, P_ROOTMENU, P_DEFAULT, P_CHOICE
+	P_UNKNOWN, P_PROMPT, P_COMMENT, P_MENU, P_DEFAULT, P_CHOICE, P_SELECT, P_RANGE
 };
 
 struct property {
 	struct property *next;
 	struct symbol *sym;
-#ifdef CML1
-	int token;
-#else
 	enum prop_type type;
-#endif
 	const char *text;
-	struct symbol *def;
 	struct expr_value visible;
-	struct expr *dep;
-	struct expr *dep2;
+	struct expr *expr;
 	struct menu *menu;
 	struct file *file;
 	int lineno;
-#ifdef CML1
-	struct property *next_pos;
-#endif
 };
 
 #define for_all_properties(sym, st, tok) \
 	for (st = sym->prop; st; st = st->next) \
 		if (st->type == (tok))
-#define for_all_prompts(sym, st) for_all_properties(sym, st, P_PROMPT)
 #define for_all_defaults(sym, st) for_all_properties(sym, st, P_DEFAULT)
 #define for_all_choices(sym, st) for_all_properties(sym, st, P_CHOICE)
+#define for_all_prompts(sym, st) \
+	for (st = sym->prop; st; st = st->next) \
+		if (st->text)
 
 struct menu {
 	struct menu *next;
@@ -166,12 +132,16 @@ struct menu {
 	struct symbol *sym;
 	struct property *prompt;
 	struct expr *dep;
+	unsigned int flags;
 	//char *help;
 	struct file *file;
 	int lineno;
 	void *data;
 };
 
+#define MENU_CHANGED		0x0001
+#define MENU_ROOT		0x0002
+
 #ifndef SWIG
 
 extern struct file *file_list;
@@ -181,18 +151,12 @@ struct file *lookup_file(const char *name);
 extern struct symbol symbol_yes, symbol_no, symbol_mod;
 extern struct symbol *modules_sym;
 extern int cdebug;
-extern int print_type;
 struct expr *expr_alloc_symbol(struct symbol *sym);
-#ifdef CML1
-struct expr *expr_alloc_one(int token, struct expr *ce);
-struct expr *expr_alloc_two(int token, struct expr *e1, struct expr *e2);
-struct expr *expr_alloc_comp(int token, struct symbol *s1, struct symbol *s2);
-#else
 struct expr *expr_alloc_one(enum expr_type type, struct expr *ce);
 struct expr *expr_alloc_two(enum expr_type type, struct expr *e1, struct expr *e2);
 struct expr *expr_alloc_comp(enum expr_type type, struct symbol *s1, struct symbol *s2);
-#endif
 struct expr *expr_alloc_and(struct expr *e1, struct expr *e2);
+struct expr *expr_alloc_or(struct expr *e1, struct expr *e2);
 struct expr *expr_copy(struct expr *org);
 void expr_free(struct expr *e);
 int expr_eq(struct expr *e1, struct expr *e2);
@@ -212,17 +176,6 @@ struct expr *expr_trans_compare(struct expr *e, enum expr_type type, struct symb
 void expr_fprint(struct expr *e, FILE *out);
 void print_expr(int mask, struct expr *e, int prevtoken);
 
-#ifdef CML1
-static inline int expr_is_yes(struct expr *e)
-{
-	return !e || (e->token == WORD && e->left.sym == &symbol_yes);
-}
-
-static inline int expr_is_no(struct expr *e)
-{
-	return e && (e->token == WORD && e->left.sym == &symbol_no);
-}
-#else
 static inline int expr_is_yes(struct expr *e)
 {
 	return !e || (e->type == E_SYMBOL && e->left.sym == &symbol_yes);
@@ -233,7 +186,6 @@ static inline int expr_is_no(struct expr *e)
 	return e && (e->type == E_SYMBOL && e->left.sym == &symbol_no);
 }
 #endif
-#endif
 
 #ifdef __cplusplus
 }
diff --git a/scripts/config/lex.zconf.c_shipped b/scripts/config/lex.zconf.c_shipped
index df102812f..22dda11f7 100644
--- a/scripts/config/lex.zconf.c_shipped
+++ b/scripts/config/lex.zconf.c_shipped
@@ -1,50 +1,84 @@
-#define yy_create_buffer zconf_create_buffer
-#define yy_delete_buffer zconf_delete_buffer
-#define yy_scan_buffer zconf_scan_buffer
-#define yy_scan_string zconf_scan_string
-#define yy_scan_bytes zconf_scan_bytes
-#define yy_flex_debug zconf_flex_debug
-#define yy_init_buffer zconf_init_buffer
-#define yy_flush_buffer zconf_flush_buffer
-#define yy_load_buffer_state zconf_load_buffer_state
-#define yy_switch_to_buffer zconf_switch_to_buffer
-#define yyin zconfin
-#define yyleng zconfleng
-#define yylex zconflex
-#define yyout zconfout
-#define yyrestart zconfrestart
-#define yytext zconftext
 
-/* A lexical scanner generated by flex */
+#line 3 "lex.zconf.c"
 
-/* Scanner skeleton version:
- * $Header: /var/cvs/busybox/scripts/config/lex.zconf.c_shipped,v 1.1 2002/12/05 08:41:07 andersen Exp $
- */
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
 
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 31
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
 
+/* begin standard C headers. */
 #include <stdio.h>
+#include <string.h>
 #include <errno.h>
+#include <stdlib.h>
 
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
-#endif
+/* end standard C headers. */
 
+/* flex integer type definitions */
 
-#ifdef __cplusplus
+#ifndef FLEXINT_H
+#define FLEXINT_H
 
-#include <stdlib.h>
-#ifndef _WIN32
-#include <unistd.h>
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
 #endif
 
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
 
 /* The "const" storage-class-modifier is valid. */
 #define YY_USE_CONST
@@ -53,34 +87,17 @@
 
 #if __STDC__
 
-#define YY_USE_PROTOS
 #define YY_USE_CONST
 
 #endif	/* __STDC__ */
 #endif	/* ! __cplusplus */
 
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
 #ifdef YY_USE_CONST
 #define yyconst const
 #else
 #define yyconst
 #endif
 
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
 /* Returned upon end-of-file. */
 #define YY_NULL 0
 
@@ -95,71 +112,71 @@
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
  */
-#define BEGIN yy_start = 1 + 2 *
+#define BEGIN (yy_start) = 1 + 2 *
 
 /* Translate the current start state into a value that can be later handed
  * to BEGIN to return to the state.  The YYSTATE alias is for lex
  * compatibility.
  */
-#define YY_START ((yy_start - 1) / 2)
+#define YY_START (((yy_start) - 1) / 2)
 #define YYSTATE YY_START
 
 /* Action number for EOF rule of a given start state. */
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
 
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
+#define YY_NEW_FILE zconfrestart(zconfin  )
 
 #define YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
 #define YY_BUF_SIZE 16384
+#endif
 
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
 
-extern int yyleng;
-extern FILE *yyin, *yyout;
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
 
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
 		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
 		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
 		} \
 	while ( 0 )
 
-#define unput(c) yyunput( c, yytext_ptr )
+#define unput(c) yyunput( c, (yytext_ptr)  )
 
 /* The following is because we cannot portably get our hands on size_t
  * (without autoconf's help, which isn't available because we want
  * flex-generated scanners to compile on their own).
  */
-typedef unsigned int yy_size_t;
 
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
 
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
 struct yy_buffer_state
 	{
 	FILE *yy_input_file;
@@ -196,12 +213,16 @@ struct yy_buffer_state
 	 */
 	int yy_at_bol;
 
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
 	int yy_fill_buffer;
 
 	int yy_buffer_status;
+
 #define YY_BUFFER_NEW 0
 #define YY_BUFFER_NORMAL 1
 	/* When an EOF's been seen but there's still some text to process
@@ -211,97 +232,126 @@ struct yy_buffer_state
 	 * possible backing-up.
 	 *
 	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
 	 */
 #define YY_BUFFER_EOF_PENDING 2
+
 	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
 
-static YY_BUFFER_STATE yy_current_buffer = 0;
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
  * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
  */
-#define YY_CURRENT_BUFFER yy_current_buffer
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
 
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
-/* yy_hold_char holds the character lost when yytext is formed. */
+/* yy_hold_char holds the character lost when zconftext is formed. */
 static char yy_hold_char;
-
 static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
+int zconfleng;
 
 /* Points to current character in buffer. */
 static char *yy_c_buf_p = (char *) 0;
 static int yy_init = 1;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
  */
 static int yy_did_buffer_switch_on_eof;
 
-void yyrestart YY_PROTO(( FILE *input_file ));
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
 
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
 
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
 
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
 
-#define yy_new_buffer yy_create_buffer
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
 
 #define yy_set_interactive(is_interactive) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
 
 #define yy_set_bol(at_bol) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
 
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
 
+/* Begin user sect3 */
 
-#define yywrap() 1
+#define zconfwrap(n) 1
 #define YY_SKIP_YYWRAP
+
 typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
 typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-static yyconst short yy_nxt[][37] =
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][38] =
     {
     {
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0
+        0,    0,    0,    0,    0,    0,    0,    0
     },
 
     {
        11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
        12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
        12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
-       12,   12,   12,   12,   12,   12,   12
+       12,   12,   12,   12,   12,   12,   12,   12
     },
 
     {
@@ -309,21 +359,21 @@ static yyconst short yy_nxt[][37] =
        12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
 
        12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
-       12,   12,   12,   12,   12,   12,   12
+       12,   12,   12,   12,   12,   12,   12,   12
     },
 
     {
        11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
-       16,   16,   16,   18,   16,   16,   18,   19,   20,   21,
-       22,   18,   18,   23,   24,   18,   25,   18,   26,   27,
-       18,   28,   29,   30,   18,   18,   16
+       16,   16,   16,   18,   16,   16,   18,   18,   19,   20,
+       21,   22,   18,   18,   23,   24,   18,   25,   18,   26,
+       27,   18,   28,   29,   30,   18,   18,   16
     },
 
     {
        11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
-       16,   16,   16,   18,   16,   16,   18,   19,   20,   21,
-       22,   18,   18,   23,   24,   18,   25,   18,   26,   27,
-       18,   28,   29,   30,   18,   18,   16
+       16,   16,   16,   18,   16,   16,   18,   18,   19,   20,
+       21,   22,   18,   18,   23,   24,   18,   25,   18,   26,
+       27,   18,   28,   29,   30,   18,   18,   16
 
     },
 
@@ -331,14 +381,14 @@ static yyconst short yy_nxt[][37] =
        11,   31,   32,   33,   31,   31,   31,   31,   31,   31,
        31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
        31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
-       31,   31,   31,   31,   31,   31,   31
+       31,   31,   31,   31,   31,   31,   31,   31
     },
 
     {
        11,   31,   32,   33,   31,   31,   31,   31,   31,   31,
        31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
        31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
-       31,   31,   31,   31,   31,   31,   31
+       31,   31,   31,   31,   31,   31,   31,   31
     },
 
     {
@@ -346,36 +396,36 @@ static yyconst short yy_nxt[][37] =
        34,   34,   34,   34,   34,   37,   34,   34,   34,   34,
 
        34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,   34
+       34,   34,   34,   34,   34,   34,   34,   34
     },
 
     {
        11,   34,   34,   35,   34,   36,   34,   34,   36,   34,
        34,   34,   34,   34,   34,   37,   34,   34,   34,   34,
        34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,   34
+       34,   34,   34,   34,   34,   34,   34,   34
     },
 
     {
-       11,   38,   38,   39,   40,   41,   38,   42,   41,   43,
-       44,   45,   46,   46,   47,   38,   46,   46,   46,   46,
-       46,   46,   46,   46,   48,   46,   46,   46,   49,   46,
-       46,   46,   46,   46,   46,   46,   50
+       11,   38,   38,   39,   40,   41,   42,   43,   41,   44,
+       45,   46,   47,   47,   48,   49,   47,   47,   47,   47,
+       47,   47,   47,   47,   47,   50,   47,   47,   47,   51,
+       47,   47,   47,   47,   47,   47,   47,   52
 
     },
 
     {
-       11,   38,   38,   39,   40,   41,   38,   42,   41,   43,
-       44,   45,   46,   46,   47,   38,   46,   46,   46,   46,
-       46,   46,   46,   46,   48,   46,   46,   46,   49,   46,
-       46,   46,   46,   46,   46,   46,   50
+       11,   38,   38,   39,   40,   41,   42,   43,   41,   44,
+       45,   46,   47,   47,   48,   49,   47,   47,   47,   47,
+       47,   47,   47,   47,   47,   50,   47,   47,   47,   51,
+       47,   47,   47,   47,   47,   47,   47,   52
     },
 
     {
       -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
       -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
       -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
-      -11,  -11,  -11,  -11,  -11,  -11,  -11
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11
     },
 
     {
@@ -383,36 +433,36 @@ static yyconst short yy_nxt[][37] =
       -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
 
       -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
-      -12,  -12,  -12,  -12,  -12,  -12,  -12
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12
     },
 
     {
-       11,  -13,   51,   52,  -13,  -13,   53,  -13,  -13,  -13,
+       11,  -13,   53,   54,  -13,  -13,   55,  -13,  -13,  -13,
       -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
       -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
-      -13,  -13,  -13,  -13,  -13,  -13,  -13
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13
     },
 
     {
        11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
       -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
       -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
-      -14,  -14,  -14,  -14,  -14,  -14,  -14
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14
 
     },
 
     {
-       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
-       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
-       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
-       54,   54,   54,   54,   54,   54,   54
+       11,   56,   56,   57,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56
     },
 
     {
        11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
       -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
       -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
-      -16,  -16,  -16,  -16,  -16,  -16,  -16
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16
     },
 
     {
@@ -420,132 +470,132 @@ static yyconst short yy_nxt[][37] =
       -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
 
       -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
-      -17,  -17,  -17,  -17,  -17,  -17,  -17
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17
     },
 
     {
        11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
-      -18,  -18,  -18,   56,  -18,  -18,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -18
+      -18,  -18,  -18,   58,  -18,  -18,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -18
     },
 
     {
        11,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
-      -19,  -19,  -19,   56,  -19,  -19,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   57,   56,
-       56,   56,   56,   56,   56,   56,  -19
+      -19,  -19,  -19,   58,  -19,  -19,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   59,
+       58,   58,   58,   58,   58,   58,   58,  -19
 
     },
 
     {
        11,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
-      -20,  -20,  -20,   56,  -20,  -20,   56,   56,   56,   56,
-       56,   56,   56,   58,   56,   56,   56,   56,   59,   56,
-       56,   56,   56,   56,   56,   56,  -20
+      -20,  -20,  -20,   58,  -20,  -20,   58,   58,   58,   58,
+       58,   58,   58,   58,   60,   58,   58,   58,   58,   61,
+       58,   58,   58,   58,   58,   58,   58,  -20
     },
 
     {
        11,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
-      -21,  -21,  -21,   56,  -21,  -21,   56,   56,   56,   56,
-       60,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -21
+      -21,  -21,  -21,   58,  -21,  -21,   58,   58,   58,   58,
+       58,   62,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -21
     },
 
     {
        11,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
-      -22,  -22,  -22,   56,  -22,  -22,   56,   56,   56,   56,
+      -22,  -22,  -22,   58,  -22,  -22,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   61,   56,   56,
-       56,   56,   56,   56,   56,   56,  -22
+       58,   58,   58,   58,   58,   58,   58,   58,   63,   58,
+       58,   58,   58,   58,   58,   58,   58,  -22
     },
 
     {
        11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
-      -23,  -23,  -23,   56,  -23,  -23,   56,   56,   56,   56,
-       62,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -23
+      -23,  -23,  -23,   58,  -23,  -23,   58,   58,   58,   58,
+       58,   64,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -23
     },
 
     {
        11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
-      -24,  -24,  -24,   56,  -24,  -24,   56,   56,   56,   56,
-       56,   63,   56,   56,   56,   56,   56,   64,   56,   56,
-       56,   56,   56,   56,   56,   56,  -24
+      -24,  -24,  -24,   58,  -24,  -24,   58,   58,   58,   58,
+       58,   58,   65,   58,   58,   58,   58,   58,   66,   58,
+       58,   58,   58,   58,   58,   58,   58,  -24
 
     },
 
     {
        11,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
-      -25,  -25,  -25,   56,  -25,  -25,   65,   56,   56,   56,
-       66,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -25
+      -25,  -25,  -25,   58,  -25,  -25,   58,   67,   58,   58,
+       58,   68,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -25
     },
 
     {
        11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
-      -26,  -26,  -26,   56,  -26,  -26,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   67,
-       56,   56,   56,   56,   56,   56,  -26
+      -26,  -26,  -26,   58,  -26,  -26,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       69,   58,   58,   58,   58,   58,   58,  -26
     },
 
     {
        11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
-      -27,  -27,  -27,   56,  -27,  -27,   56,   56,   56,   56,
+      -27,  -27,  -27,   58,  -27,  -27,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   68,   56,   56,   56,   56,  -27
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   70,   58,   58,   58,   58,  -27
     },
 
     {
        11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
-      -28,  -28,  -28,   56,  -28,  -28,   56,   56,   56,   56,
-       69,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -28
+      -28,  -28,  -28,   58,  -28,  -28,   58,   71,   58,   58,
+       58,   72,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -28
     },
 
     {
        11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
-      -29,  -29,  -29,   56,  -29,  -29,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   70,   56,
-       56,   56,   56,   71,   56,   56,  -29
+      -29,  -29,  -29,   58,  -29,  -29,   58,   58,   58,   58,
+       58,   73,   58,   58,   58,   58,   58,   58,   58,   74,
+       58,   58,   58,   58,   75,   58,   58,  -29
 
     },
 
     {
        11,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
-      -30,  -30,  -30,   56,  -30,  -30,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   72,   56,   56,   56,   56,  -30
+      -30,  -30,  -30,   58,  -30,  -30,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   76,   58,   58,   58,   58,  -30
     },
 
     {
-       11,   73,   73,  -31,   73,   73,   73,   73,   73,   73,
-       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
-       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
-       73,   73,   73,   73,   73,   73,   73
+       11,   77,   77,  -31,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77,   77
     },
 
     {
-       11,  -32,   74,   75,  -32,  -32,  -32,  -32,  -32,  -32,
+       11,  -32,   78,   79,  -32,  -32,  -32,  -32,  -32,  -32,
       -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
 
       -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
-      -32,  -32,  -32,  -32,  -32,  -32,  -32
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32
     },
 
     {
-       11,   76,  -33,  -33,   76,   76,   76,   76,   76,   76,
-       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
-       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
-       76,   76,   76,   76,   76,   76,   76
+       11,   80,  -33,  -33,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80
     },
 
     {
-       11,   77,   77,   78,   77,  -34,   77,   77,  -34,   77,
-       77,   77,   77,   77,   77,  -34,   77,   77,   77,   77,
-       77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
-       77,   77,   77,   77,   77,   77,   77
+       11,   81,   81,   82,   81,  -34,   81,   81,  -34,   81,
+       81,   81,   81,   81,   81,  -34,   81,   81,   81,   81,
+       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
+       81,   81,   81,   81,   81,   81,   81,   81
 
     },
 
@@ -553,125 +603,125 @@ static yyconst short yy_nxt[][37] =
        11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
       -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
-      -35,  -35,  -35,  -35,  -35,  -35,  -35
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35
     },
 
     {
        11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
       -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
       -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
-      -36,  -36,  -36,  -36,  -36,  -36,  -36
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36
     },
 
     {
-       11,   79,   79,   80,   79,   79,   79,   79,   79,   79,
-       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
+       11,   83,   83,   84,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
 
-       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
-       79,   79,   79,   79,   79,   79,   79
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83
     },
 
     {
        11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
       -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
       -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
-      -38,  -38,  -38,  -38,  -38,  -38,  -38
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38
     },
 
     {
        11,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
       -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
       -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
-      -39,  -39,  -39,  -39,  -39,  -39,  -39
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39
 
     },
 
     {
        11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
-      -40,  -40,  -40,  -40,   81,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,   85,  -40,  -40,  -40,  -40,  -40,
       -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
-      -40,  -40,  -40,  -40,  -40,  -40,  -40
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40
     },
 
     {
        11,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
       -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
       -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
-      -41,  -41,  -41,  -41,  -41,  -41,  -41
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41
     },
 
     {
-       11,  -42,  -42,  -42,  -42,  -42,  -42,   82,  -42,  -42,
-      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+       11,   86,   86,  -42,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
 
-      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
-      -42,  -42,  -42,  -42,  -42,  -42,  -42
+       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   86,   86,   86,   86
     },
 
     {
-       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+       11,  -43,  -43,  -43,  -43,  -43,  -43,   87,  -43,  -43,
       -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
       -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
-      -43,  -43,  -43,  -43,  -43,  -43,  -43
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43
     },
 
     {
        11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
       -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
       -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
-      -44,  -44,  -44,  -44,  -44,  -44,  -44
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44
 
     },
 
     {
        11,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
-      -45,   83,   84,   84,  -45,  -45,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,  -45
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45
     },
 
     {
        11,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
-      -46,   84,   84,   84,  -46,  -46,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,  -46
+      -46,   88,   89,   89,  -46,  -46,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,  -46
     },
 
     {
        11,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
-      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,   89,   89,   89,  -47,  -47,   89,   89,   89,   89,
 
-      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
-      -47,  -47,  -47,  -47,  -47,  -47,  -47
+       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,  -47
     },
 
     {
        11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
-      -48,   84,   84,   84,  -48,  -48,   84,   84,   84,   84,
-       84,   85,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,  -48
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48
     },
 
     {
-       11,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
-      -49,   84,   84,   84,  -49,  -49,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   86,   84,   84,
-       84,   84,   84,   84,   84,   84,  -49
+       11,  -49,  -49,   90,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49
 
     },
 
     {
        11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
-      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
-      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
-      -50,  -50,  -50,  -50,  -50,  -50,   87
+      -50,   89,   89,   89,  -50,  -50,   89,   89,   89,   89,
+       89,   89,   91,   89,   89,   89,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,  -50
     },
 
     {
-       11,  -51,   51,   52,  -51,  -51,   53,  -51,  -51,  -51,
-      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
-      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
-      -51,  -51,  -51,  -51,  -51,  -51,  -51
+       11,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,   89,   89,   89,  -51,  -51,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,   89,   92,   89,
+       89,   89,   89,   89,   89,   89,   89,  -51
     },
 
     {
@@ -679,206 +729,206 @@ static yyconst short yy_nxt[][37] =
       -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
 
       -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
-      -52,  -52,  -52,  -52,  -52,  -52,  -52
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,   93
     },
 
     {
-       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
-       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
-       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
-       54,   54,   54,   54,   54,   54,   54
+       11,  -53,   53,   54,  -53,  -53,   55,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53
     },
 
     {
-       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
-       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
-       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
-       54,   54,   54,   54,   54,   54,   54
+       11,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,
+      -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,
+      -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54,
+      -54,  -54,  -54,  -54,  -54,  -54,  -54,  -54
 
     },
 
     {
-       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
-      -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
-      -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
-      -55,  -55,  -55,  -55,  -55,  -55,  -55
+       11,   56,   56,   57,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56
     },
 
     {
-       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
-      -56,  -56,  -56,   56,  -56,  -56,   56,   56,   56,   56,
+       11,   56,   56,   57,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
        56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -56
+       56,   56,   56,   56,   56,   56,   56,   56
     },
 
     {
        11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
-      -57,  -57,  -57,   56,  -57,  -57,   56,   56,   56,   56,
+      -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   88,   56,
-       56,   56,   56,   56,   56,   56,  -57
+      -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57
     },
 
     {
        11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
-      -58,  -58,  -58,   56,  -58,  -58,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   89,   56,
-       56,   56,   56,   56,   56,   56,  -58
+      -58,  -58,  -58,   58,  -58,  -58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -58
     },
 
     {
        11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
-      -59,  -59,  -59,   56,  -59,  -59,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   90,   91,   56,   56,
-       56,   56,   56,   56,   56,   56,  -59
+      -59,  -59,  -59,   58,  -59,  -59,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   94,
+       58,   58,   58,   58,   58,   58,   58,  -59
 
     },
 
     {
        11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
-      -60,  -60,  -60,   56,  -60,  -60,   56,   56,   56,   56,
-       56,   92,   56,   56,   56,   56,   56,   56,   56,   93,
-       56,   56,   56,   56,   56,   56,  -60
+      -60,  -60,  -60,   58,  -60,  -60,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   95,
+       58,   58,   58,   58,   58,   58,   58,  -60
     },
 
     {
        11,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
-      -61,  -61,  -61,   56,  -61,  -61,   56,   56,   56,   94,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -61
+      -61,  -61,  -61,   58,  -61,  -61,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   96,   97,   58,
+       58,   58,   58,   58,   58,   58,   58,  -61
     },
 
     {
        11,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
-      -62,  -62,  -62,   56,  -62,  -62,   56,   56,   56,   56,
+      -62,  -62,  -62,   58,  -62,  -62,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   95,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   96,  -62
+       58,   58,   98,   58,   58,   58,   58,   58,   58,   58,
+       99,   58,   58,   58,   58,   58,   58,  -62
     },
 
     {
        11,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,
-      -63,  -63,  -63,   56,  -63,  -63,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -63
+      -63,  -63,  -63,   58,  -63,  -63,   58,  100,   58,   58,
+      101,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -63
     },
 
     {
        11,  -64,  -64,  -64,  -64,  -64,  -64,  -64,  -64,  -64,
-      -64,  -64,  -64,   56,  -64,  -64,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   97,   56,   56,  -64
+      -64,  -64,  -64,   58,  -64,  -64,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  102,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  103,  -64
 
     },
 
     {
        11,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,
-      -65,  -65,  -65,   56,  -65,  -65,   56,   56,   56,   56,
-       56,   56,   56,   56,   98,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -65
+      -65,  -65,  -65,   58,  -65,  -65,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -65
     },
 
     {
        11,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
-      -66,  -66,  -66,   56,  -66,  -66,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   99,   56,   56,
-       56,   56,   56,   56,   56,   56,  -66
+      -66,  -66,  -66,   58,  -66,  -66,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  104,   58,   58,  -66
     },
 
     {
        11,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
-      -67,  -67,  -67,   56,  -67,  -67,   56,   56,   56,   56,
+      -67,  -67,  -67,   58,  -67,  -67,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,  100,   56,   56,  -67
+       58,   58,   58,   58,   58,  105,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -67
     },
 
     {
        11,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,
-      -68,  -68,  -68,   56,  -68,  -68,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,  101,   56,
-       56,   56,   56,   56,   56,   56,  -68
+      -68,  -68,  -68,   58,  -68,  -68,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  106,   58,
+       58,   58,   58,   58,   58,   58,   58,  -68
     },
 
     {
        11,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
-      -69,  -69,  -69,   56,  -69,  -69,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-      102,   56,   56,   56,   56,   56,  -69
+      -69,  -69,  -69,   58,  -69,  -69,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  107,   58,   58,  -69
 
     },
 
     {
        11,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,
-      -70,  -70,  -70,   56,  -70,  -70,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,  103,   56,  -70
+      -70,  -70,  -70,   58,  -70,  -70,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  108,
+       58,   58,   58,   58,   58,   58,   58,  -70
     },
 
     {
        11,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,
-      -71,  -71,  -71,   56,  -71,  -71,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,  104,   56,   56,   56,   56,  -71
+      -71,  -71,  -71,   58,  -71,  -71,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  109,   58,
+       58,   58,   58,   58,   58,   58,   58,  -71
     },
 
     {
        11,  -72,  -72,  -72,  -72,  -72,  -72,  -72,  -72,  -72,
-      -72,  -72,  -72,   56,  -72,  -72,   56,   56,   56,   56,
+      -72,  -72,  -72,   58,  -72,  -72,   58,   58,   58,   58,
 
-       56,   56,   56,   56,  105,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -72
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,  110,   58,   58,   58,   58,   58,  -72
     },
 
     {
-       11,   73,   73,  -73,   73,   73,   73,   73,   73,   73,
-       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
-       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
-       73,   73,   73,   73,   73,   73,   73
+       11,  -73,  -73,  -73,  -73,  -73,  -73,  -73,  -73,  -73,
+      -73,  -73,  -73,   58,  -73,  -73,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  111,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -73
     },
 
     {
-       11,  -74,   74,   75,  -74,  -74,  -74,  -74,  -74,  -74,
-      -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,
-      -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,
-      -74,  -74,  -74,  -74,  -74,  -74,  -74
+       11,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,   58,  -74,  -74,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  112,   58,  -74
 
     },
 
     {
        11,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
-      -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
-      -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
-      -75,  -75,  -75,  -75,  -75,  -75,  -75
+      -75,  -75,  -75,   58,  -75,  -75,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,  113,   58,   58,   58,   58,  -75
     },
 
     {
        11,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
-      -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
-      -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
-      -76,  -76,  -76,  -76,  -76,  -76,  -76
+      -76,  -76,  -76,   58,  -76,  -76,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  114,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -76
     },
 
     {
-       11,   77,   77,   78,   77,  -77,   77,   77,  -77,   77,
-       77,   77,   77,   77,   77,  -77,   77,   77,   77,   77,
+       11,   77,   77,  -77,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
 
        77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
-       77,   77,   77,   77,   77,   77,   77
+       77,   77,   77,   77,   77,   77,   77,   77
     },
 
     {
-       11,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
+       11,  -78,   78,   79,  -78,  -78,  -78,  -78,  -78,  -78,
       -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
       -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
-      -78,  -78,  -78,  -78,  -78,  -78,  -78
+      -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78
     },
 
     {
-       11,  -79,  -79,   80,  -79,  -79,  -79,  -79,  -79,  -79,
-      -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,
-      -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,
-      -79,  -79,  -79,  -79,  -79,  -79,  -79
+       11,   80,  -79,  -79,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
+       80,   80,   80,   80,   80,   80,   80,   80
 
     },
 
@@ -886,14 +936,14 @@ static yyconst short yy_nxt[][37] =
        11,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
       -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
-      -80,  -80,  -80,  -80,  -80,  -80,  -80
+      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80
     },
 
     {
-       11,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
-      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
-      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
-      -81,  -81,  -81,  -81,  -81,  -81,  -81
+       11,   81,   81,   82,   81,  -81,   81,   81,  -81,   81,
+       81,   81,   81,   81,   81,  -81,   81,   81,   81,   81,
+       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
+       81,   81,   81,   81,   81,   81,   81,   81
     },
 
     {
@@ -901,36 +951,36 @@ static yyconst short yy_nxt[][37] =
       -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
 
       -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
-      -82,  -82,  -82,  -82,  -82,  -82,  -82
+      -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82
     },
 
     {
-       11,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
-      -83,  106,   84,   84,  -83,  -83,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,  -83
+       11,  -83,  -83,   84,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83
     },
 
     {
        11,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
-      -84,   84,   84,   84,  -84,  -84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,  -84
+      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84
 
     },
 
     {
        11,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
-      -85,   84,   84,   84,  -85,  -85,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,  -85
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85
     },
 
     {
-       11,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
-      -86,   84,   84,   84,  -86,  -86,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,  -86
+       11,   86,   86,  -86,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
+       86,   86,   86,   86,   86,   86,   86,   86
     },
 
     {
@@ -938,850 +988,1124 @@ static yyconst short yy_nxt[][37] =
       -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
 
       -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
-      -87,  -87,  -87,  -87,  -87,  -87,  -87
+      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87
     },
 
     {
        11,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,
-      -88,  -88,  -88,   56,  -88,  -88,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,  107,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -88
+      -88,  115,   89,   89,  -88,  -88,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,  -88
     },
 
     {
        11,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,
-      -89,  -89,  -89,   56,  -89,  -89,   56,   56,   56,   56,
-       56,   56,   56,   56,  108,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -89
+      -89,   89,   89,   89,  -89,  -89,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,  -89
 
     },
 
     {
        11,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
-      -90,  -90,  -90,   56,  -90,  -90,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  109,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -90
+      -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90
     },
 
     {
        11,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,
-      -91,  -91,  -91,   56,  -91,  -91,   56,   56,   56,   56,
-       56,  110,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -91
+      -91,   89,   89,   89,  -91,  -91,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,  -91
     },
 
     {
        11,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,
-      -92,  -92,  -92,   56,  -92,  -92,  111,   56,   56,   56,
+      -92,   89,   89,   89,  -92,  -92,   89,   89,   89,   89,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -92
+       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,  -92
     },
 
     {
        11,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
-      -93,  -93,  -93,   56,  -93,  -93,   56,   56,   56,   56,
-      112,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -93
+      -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93
     },
 
     {
        11,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,
-      -94,  -94,  -94,   56,  -94,  -94,   56,   56,  113,   56,
-       56,   56,   56,   56,  114,   56,  115,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -94
+      -94,  -94,  -94,   58,  -94,  -94,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  116,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -94
 
     },
 
     {
        11,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,
-      -95,  -95,  -95,   56,  -95,  -95,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,  116,
-       56,   56,   56,   56,   56,   56,  -95
+      -95,  -95,  -95,   58,  -95,  -95,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  117,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -95
     },
 
     {
        11,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,
-      -96,  -96,  -96,   56,  -96,  -96,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -96
+      -96,  -96,  -96,   58,  -96,  -96,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  118,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -96
     },
 
     {
        11,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,
-      -97,  -97,  -97,   56,  -97,  -97,   56,   56,   56,   56,
+      -97,  -97,  -97,   58,  -97,  -97,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  -97
+       58,   58,  119,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -97
     },
 
     {
        11,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,
-      -98,  -98,  -98,   56,  -98,  -98,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,  117,   56,   56,
-       56,   56,   56,   56,   56,   56,  -98
+      -98,  -98,  -98,   58,  -98,  -98,  120,  121,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -98
     },
 
     {
        11,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
-      -99,  -99,  -99,   56,  -99,  -99,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,  118,   56,  -99
+      -99,  -99,  -99,   58,  -99,  -99,   58,   58,   58,   58,
+       58,  122,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  -99
 
     },
 
     {
        11, -100, -100, -100, -100, -100, -100, -100, -100, -100,
-     -100, -100, -100,   56, -100, -100,   56,   56,   56,   56,
-       56,   56,   56,   56,  119,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -100
+     -100, -100, -100,   58, -100, -100,   58,   58,  123,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -100
     },
 
     {
        11, -101, -101, -101, -101, -101, -101, -101, -101, -101,
-     -101, -101, -101,   56, -101, -101,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,  120,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -101
+     -101, -101, -101,   58, -101, -101,   58,   58,   58,  124,
+       58,   58,   58,   58,   58,  125,   58,  126,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -101
     },
 
     {
        11, -102, -102, -102, -102, -102, -102, -102, -102, -102,
-     -102, -102, -102,   56, -102, -102,   56,   56,   56,   56,
+     -102, -102, -102,   58, -102, -102,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,  121,   56, -102
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+      127,   58,   58,   58,   58,   58,   58, -102
     },
 
     {
        11, -103, -103, -103, -103, -103, -103, -103, -103, -103,
-     -103, -103, -103,   56, -103, -103,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,  122,   56,   56,   56,   56, -103
+     -103, -103, -103,   58, -103, -103,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -103
     },
 
     {
        11, -104, -104, -104, -104, -104, -104, -104, -104, -104,
-     -104, -104, -104,   56, -104, -104,   56,   56,   56,   56,
-       56,   56,   56,   56,  123,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -104
+     -104, -104, -104,   58, -104, -104,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -104
 
     },
 
     {
        11, -105, -105, -105, -105, -105, -105, -105, -105, -105,
-     -105, -105, -105,   56, -105, -105,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,  124,   56,   56,   56, -105
+     -105, -105, -105,   58, -105, -105,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  128,   58,
+       58,   58,   58,   58,   58,   58,   58, -105
     },
 
     {
        11, -106, -106, -106, -106, -106, -106, -106, -106, -106,
-     -106,   84,   84,   84, -106, -106,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       84,   84,   84,   84,   84,   84, -106
+     -106, -106, -106,   58, -106, -106,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  129,   58, -106
     },
 
     {
        11, -107, -107, -107, -107, -107, -107, -107, -107, -107,
-     -107, -107, -107,   56, -107, -107,   56,   56,   56,   56,
+     -107, -107, -107,   58, -107, -107,   58,   58,   58,   58,
 
-      125,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -107
+       58,   58,   58,   58,   58,  130,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -107
     },
 
     {
        11, -108, -108, -108, -108, -108, -108, -108, -108, -108,
-     -108, -108, -108,   56, -108, -108,   56,   56,  126,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -108
+     -108, -108, -108,   58, -108, -108,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  131,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -108
     },
 
     {
        11, -109, -109, -109, -109, -109, -109, -109, -109, -109,
-     -109, -109, -109,   56, -109, -109,   56,   56,   56,   56,
-      127,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -109
+     -109, -109, -109,   58, -109, -109,   58,   58,   58,   58,
+       58,   58,   58,  132,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -109
 
     },
 
     {
        11, -110, -110, -110, -110, -110, -110, -110, -110, -110,
-     -110, -110, -110,   56, -110, -110,   56,   56,   56,   56,
-       56,   56,   56,   56,  128,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -110
+     -110, -110, -110,   58, -110, -110,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  133,   58, -110
     },
 
     {
        11, -111, -111, -111, -111, -111, -111, -111, -111, -111,
-     -111, -111, -111,   56, -111, -111,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,  129,   56, -111
+     -111, -111, -111,   58, -111, -111,   58,   58,   58,   58,
+       58,  134,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -111
     },
 
     {
        11, -112, -112, -112, -112, -112, -112, -112, -112, -112,
-     -112, -112, -112,   56, -112, -112,   56,   56,   56,   56,
+     -112, -112, -112,   58, -112, -112,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,  130,   56,   56,
-       56,   56,   56,   56,   56,   56, -112
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,  135,   58,   58,   58,   58, -112
     },
 
     {
        11, -113, -113, -113, -113, -113, -113, -113, -113, -113,
-     -113, -113, -113,   56, -113, -113,   56,   56,   56,   56,
-       56,   56,   56,  131,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -113
+     -113, -113, -113,   58, -113, -113,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  136,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -113
     },
 
     {
        11, -114, -114, -114, -114, -114, -114, -114, -114, -114,
-     -114, -114, -114,   56, -114, -114,   56,   56,   56,   56,
-       56,  132,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -114
+     -114, -114, -114,   58, -114, -114,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,  137,   58,   58,   58, -114
 
     },
 
     {
        11, -115, -115, -115, -115, -115, -115, -115, -115, -115,
-     -115, -115, -115,   56, -115, -115,   56,   56,   56,   56,
-      133,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -115
+     -115,   89,   89,   89, -115, -115,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
+       89,   89,   89,   89,   89,   89,   89, -115
     },
 
     {
        11, -116, -116, -116, -116, -116, -116, -116, -116, -116,
-     -116, -116, -116,   56, -116, -116,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -116
+     -116, -116, -116,   58, -116, -116,   58,   58,   58,   58,
+       58,  138,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -116
     },
 
     {
        11, -117, -117, -117, -117, -117, -117, -117, -117, -117,
-     -117, -117, -117,   56, -117, -117,   56,   56,   56,   56,
+     -117, -117, -117,   58, -117, -117,   58,   58,   58,  139,
 
-       56,   56,   56,   56,   56,   56,  134,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -117
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -117
     },
 
     {
        11, -118, -118, -118, -118, -118, -118, -118, -118, -118,
-     -118, -118, -118,   56, -118, -118,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -118
+     -118, -118, -118,   58, -118, -118,   58,   58,   58,   58,
+       58,  140,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -118
     },
 
     {
        11, -119, -119, -119, -119, -119, -119, -119, -119, -119,
-     -119, -119, -119,   56, -119, -119,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,  135,   56,
-       56,   56,   56,   56,   56,   56, -119
+     -119, -119, -119,   58, -119, -119,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  141,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -119
 
     },
 
     {
        11, -120, -120, -120, -120, -120, -120, -120, -120, -120,
-     -120, -120, -120,   56, -120, -120,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,  136,
-       56,   56,   56,   56,   56,   56, -120
+     -120, -120, -120,   58, -120, -120,   58,   58,  142,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  143,   58,   58, -120
     },
 
     {
        11, -121, -121, -121, -121, -121, -121, -121, -121, -121,
-     -121, -121, -121,   56, -121, -121,   56,   56,   56,   56,
-       56,   56,   56,   56,  137,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -121
+     -121, -121, -121,   58, -121, -121,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  144,   58, -121
     },
 
     {
        11, -122, -122, -122, -122, -122, -122, -122, -122, -122,
-     -122, -122, -122,   56, -122, -122,   56,   56,  138,   56,
+     -122, -122, -122,   58, -122, -122,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -122
+       58,   58,   58,   58,   58,   58,   58,   58,  145,   58,
+       58,   58,   58,   58,   58,   58,   58, -122
     },
 
     {
        11, -123, -123, -123, -123, -123, -123, -123, -123, -123,
-     -123, -123, -123,   56, -123, -123,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,  139,   56,   56,
-       56,   56,   56,   56,   56,   56, -123
+     -123, -123, -123,   58, -123, -123,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  146,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -123
     },
 
     {
        11, -124, -124, -124, -124, -124, -124, -124, -124, -124,
-     -124, -124, -124,   56, -124, -124,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,  140,   56,   56, -124
+     -124, -124, -124,   58, -124, -124,   58,   58,   58,   58,
+       58,   58,   58,   58,  147,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -124
 
     },
 
     {
        11, -125, -125, -125, -125, -125, -125, -125, -125, -125,
-     -125, -125, -125,   56, -125, -125,  141,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -125
+     -125, -125, -125,   58, -125, -125,   58,   58,   58,   58,
+       58,   58,  148,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -125
     },
 
     {
        11, -126, -126, -126, -126, -126, -126, -126, -126, -126,
-     -126, -126, -126,   56, -126, -126,   56,   56,   56,   56,
-      142,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -126
+     -126, -126, -126,   58, -126, -126,   58,   58,   58,   58,
+       58,  149,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -126
     },
 
     {
        11, -127, -127, -127, -127, -127, -127, -127, -127, -127,
-     -127, -127, -127,   56, -127, -127,   56,   56,   56,   56,
+     -127, -127, -127,   58, -127, -127,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,  143,   56,   56,
-       56,   56,   56,   56,   56,   56, -127
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -127
     },
 
     {
        11, -128, -128, -128, -128, -128, -128, -128, -128, -128,
-     -128, -128, -128,   56, -128, -128,   56,   56,   56,   56,
-       56,   56,  144,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -128
+     -128, -128, -128,   58, -128, -128,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,  150,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -128
     },
 
     {
        11, -129, -129, -129, -129, -129, -129, -129, -129, -129,
-     -129, -129, -129,   56, -129, -129,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,  145,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -129
+     -129, -129, -129,   58, -129, -129,   58,   58,   58,  151,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -129
 
     },
 
     {
        11, -130, -130, -130, -130, -130, -130, -130, -130, -130,
-     -130, -130, -130,   56, -130, -130,   56,   56,   56,  146,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -130
+     -130, -130, -130,   58, -130, -130,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  152,
+       58,   58,   58,   58,   58,   58,   58, -130
     },
 
     {
        11, -131, -131, -131, -131, -131, -131, -131, -131, -131,
-     -131, -131, -131,   56, -131, -131,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,  147,   56,
-       56,   56,   56,   56,   56,   56, -131
+     -131, -131, -131,   58, -131, -131,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+      153,   58,   58,   58,   58,   58,   58, -131
     },
 
     {
        11, -132, -132, -132, -132, -132, -132, -132, -132, -132,
-     -132, -132, -132,   56, -132, -132,   56,   56,   56,   56,
+     -132, -132, -132,   58, -132, -132,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -132
+       58,  154,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -132
     },
 
     {
        11, -133, -133, -133, -133, -133, -133, -133, -133, -133,
-     -133, -133, -133,   56, -133, -133,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,  148,   56,   56,
-       56,   56,   56,   56,   56,   56, -133
+     -133, -133, -133,   58, -133, -133,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  155,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -133
     },
 
     {
        11, -134, -134, -134, -134, -134, -134, -134, -134, -134,
-     -134, -134, -134,   56, -134, -134,   56,   56,   56,   56,
-      149,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -134
+     -134, -134, -134,   58, -134, -134,   58,   58,   58,  156,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -134
 
     },
 
     {
        11, -135, -135, -135, -135, -135, -135, -135, -135, -135,
-     -135, -135, -135,   56, -135, -135,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,  150,   56,   56,
-       56,   56,   56,   56,   56,   56, -135
+     -135, -135, -135,   58, -135, -135,   58,   58,   58,  157,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -135
     },
 
     {
        11, -136, -136, -136, -136, -136, -136, -136, -136, -136,
-     -136, -136, -136,   56, -136, -136,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,  151,   56,   56, -136
+     -136, -136, -136,   58, -136, -136,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  158,   58,
+       58,   58,   58,   58,   58,   58,   58, -136
     },
 
     {
        11, -137, -137, -137, -137, -137, -137, -137, -137, -137,
-     -137, -137, -137,   56, -137, -137,   56,   56,   56,   56,
+     -137, -137, -137,   58, -137, -137,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,  152,   56,   56,   56,   56, -137
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  159,   58,   58, -137
     },
 
     {
        11, -138, -138, -138, -138, -138, -138, -138, -138, -138,
-     -138, -138, -138,   56, -138, -138,   56,   56,   56,   56,
-      153,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -138
+     -138, -138, -138,   58, -138, -138,   58,  160,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -138
     },
 
     {
        11, -139, -139, -139, -139, -139, -139, -139, -139, -139,
-     -139, -139, -139,   56, -139, -139,   56,   56,   56,   56,
-       56,   56,  154,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -139
+     -139, -139, -139,   58, -139, -139,   58,   58,   58,   58,
+       58,  161,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -139
 
     },
 
     {
        11, -140, -140, -140, -140, -140, -140, -140, -140, -140,
-     -140, -140, -140,   56, -140, -140,  155,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -140
+     -140, -140, -140,   58, -140, -140,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  162,   58,
+       58,   58,   58,   58,   58,   58,   58, -140
     },
 
     {
        11, -141, -141, -141, -141, -141, -141, -141, -141, -141,
-     -141, -141, -141,   56, -141, -141,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,  156,   56,   56,
-       56,   56,   56,   56,   56,   56, -141
+     -141, -141, -141,   58, -141, -141,   58,   58,   58,   58,
+       58,   58,   58,  163,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -141
     },
 
     {
        11, -142, -142, -142, -142, -142, -142, -142, -142, -142,
-     -142, -142, -142,   56, -142, -142,   56,   56,   56,   56,
+     -142, -142, -142,   58, -142, -142,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -142
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  164,
+       58,   58,   58,   58,   58,   58,   58, -142
     },
 
     {
        11, -143, -143, -143, -143, -143, -143, -143, -143, -143,
-     -143, -143, -143,   56, -143, -143,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,  157,   56,   56, -143
+     -143, -143, -143,   58, -143, -143,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,  165,   58,   58,   58,   58, -143
     },
 
     {
        11, -144, -144, -144, -144, -144, -144, -144, -144, -144,
-     -144, -144, -144,   56, -144, -144,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -144
+     -144, -144, -144,   58, -144, -144,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  166,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -144
 
     },
 
     {
        11, -145, -145, -145, -145, -145, -145, -145, -145, -145,
-     -145, -145, -145,   56, -145, -145,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,  158,   56,   56, -145
+     -145, -145, -145,   58, -145, -145,   58,   58,   58,   58,
+      167,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -145
     },
 
     {
        11, -146, -146, -146, -146, -146, -146, -146, -146, -146,
-     -146, -146, -146,   56, -146, -146,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,  159,   56,   56,   56, -146
+     -146, -146, -146,   58, -146, -146,   58,   58,   58,   58,
+       58,  168,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -146
     },
 
     {
        11, -147, -147, -147, -147, -147, -147, -147, -147, -147,
-     -147, -147, -147,   56, -147, -147,   56,   56,   56,   56,
+     -147, -147, -147,   58, -147, -147,   58,   58,   58,   58,
 
-       56,   56,   56,   56,  160,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -147
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  169,
+       58,   58,   58,   58,   58,   58,   58, -147
     },
 
     {
        11, -148, -148, -148, -148, -148, -148, -148, -148, -148,
-     -148, -148, -148,   56, -148, -148,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,  161,   56, -148
+     -148, -148, -148,   58, -148, -148,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -148
     },
 
     {
        11, -149, -149, -149, -149, -149, -149, -149, -149, -149,
-     -149, -149, -149,   56, -149, -149,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,  162,   56,   56,
-       56,   56,   56,   56,   56,   56, -149
+     -149, -149, -149,   58, -149, -149,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  170,   58,
+       58,   58,   58,   58,   58,   58,   58, -149
 
     },
 
     {
        11, -150, -150, -150, -150, -150, -150, -150, -150, -150,
-     -150, -150, -150,   56, -150, -150,  163,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -150
+     -150, -150, -150,   58, -150, -150,   58,   58,   58,   58,
+       58,  171,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -150
     },
 
     {
        11, -151, -151, -151, -151, -151, -151, -151, -151, -151,
-     -151, -151, -151,   56, -151, -151,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -151
+     -151, -151, -151,   58, -151, -151,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  172,
+       58,   58,   58,   58,   58,   58,   58, -151
     },
 
     {
        11, -152, -152, -152, -152, -152, -152, -152, -152, -152,
-     -152, -152, -152,   56, -152, -152,   56,   56,   56,   56,
+     -152, -152, -152,   58, -152, -152,   58,   58,   58,   58,
 
-      164,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -152
+       58,   58,   58,   58,   58,   58,   58,   58,  173,   58,
+       58,   58,   58,   58,   58,   58,   58, -152
     },
 
     {
        11, -153, -153, -153, -153, -153, -153, -153, -153, -153,
-     -153, -153, -153,   56, -153, -153,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -153
+     -153, -153, -153,   58, -153, -153,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  174,   58,   58, -153
     },
 
     {
        11, -154, -154, -154, -154, -154, -154, -154, -154, -154,
-     -154, -154, -154,   56, -154, -154,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -154
+     -154, -154, -154,   58, -154, -154,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -154
 
     },
 
     {
        11, -155, -155, -155, -155, -155, -155, -155, -155, -155,
-     -155, -155, -155,   56, -155, -155,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,  165,   56,   56, -155
+     -155, -155, -155,   58, -155, -155,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,  175,   58,   58,   58,   58, -155
     },
 
     {
        11, -156, -156, -156, -156, -156, -156, -156, -156, -156,
-     -156, -156, -156,   56, -156, -156,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -156
+     -156, -156, -156,   58, -156, -156,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  176,   58,   58, -156
     },
 
     {
        11, -157, -157, -157, -157, -157, -157, -157, -157, -157,
-     -157, -157, -157,   56, -157, -157,   56,   56,   56,   56,
+     -157, -157, -157,   58, -157, -157,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -157
+       58,  177,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -157
     },
 
     {
        11, -158, -158, -158, -158, -158, -158, -158, -158, -158,
-     -158, -158, -158,   56, -158, -158,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -158
+     -158, -158, -158,   58, -158, -158,   58,   58,   58,   58,
+       58,   58,   58,  178,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -158
     },
 
     {
        11, -159, -159, -159, -159, -159, -159, -159, -159, -159,
-     -159, -159, -159,   56, -159, -159,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -159
+     -159, -159, -159,   58, -159, -159,   58,  179,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -159
 
     },
 
     {
        11, -160, -160, -160, -160, -160, -160, -160, -160, -160,
-     -160, -160, -160,   56, -160, -160,   56,   56,  166,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -160
+     -160, -160, -160,   58, -160, -160,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  180,   58,
+       58,   58,   58,   58,   58,   58,   58, -160
     },
 
     {
        11, -161, -161, -161, -161, -161, -161, -161, -161, -161,
-     -161, -161, -161,   56, -161, -161,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -161
+     -161, -161, -161,   58, -161, -161,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -161
     },
 
     {
        11, -162, -162, -162, -162, -162, -162, -162, -162, -162,
-     -162, -162, -162,   56, -162, -162,   56,   56,   56,   56,
+     -162, -162, -162,   58, -162, -162,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,  167,   56, -162
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  181,   58,   58, -162
     },
 
     {
        11, -163, -163, -163, -163, -163, -163, -163, -163, -163,
-     -163, -163, -163,   56, -163, -163,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,  168,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -163
+     -163, -163, -163,   58, -163, -163,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -163
     },
 
     {
        11, -164, -164, -164, -164, -164, -164, -164, -164, -164,
-     -164, -164, -164,   56, -164, -164,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,  169,   56,   56,   56, -164
+     -164, -164, -164,   58, -164, -164,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,  182,
+       58,   58,   58,   58,   58,   58,   58, -164
 
     },
 
     {
        11, -165, -165, -165, -165, -165, -165, -165, -165, -165,
-     -165, -165, -165,   56, -165, -165,   56,   56,   56,   56,
-      170,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -165
+     -165, -165, -165,   58, -165, -165,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  183,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -165
     },
 
     {
        11, -166, -166, -166, -166, -166, -166, -166, -166, -166,
-     -166, -166, -166,   56, -166, -166,   56,   56,   56,   56,
-      171,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -166
+     -166, -166, -166,   58, -166, -166,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  184,   58,   58, -166
     },
 
     {
        11, -167, -167, -167, -167, -167, -167, -167, -167, -167,
-     -167, -167, -167,   56, -167, -167,   56,   56,   56,   56,
+     -167, -167, -167,   58, -167, -167,   58,   58,   58,   58,
 
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -167
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,  185,   58,   58,   58, -167
     },
 
     {
        11, -168, -168, -168, -168, -168, -168, -168, -168, -168,
-     -168, -168, -168,   56, -168, -168,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -168
+     -168, -168, -168,   58, -168, -168,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -168
     },
 
     {
        11, -169, -169, -169, -169, -169, -169, -169, -169, -169,
-     -169, -169, -169,   56, -169, -169,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -169
+     -169, -169, -169,   58, -169, -169,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  186,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -169
 
     },
 
     {
        11, -170, -170, -170, -170, -170, -170, -170, -170, -170,
-     -170, -170, -170,   56, -170, -170,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -170
+     -170, -170, -170,   58, -170, -170,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  187,   58, -170
     },
 
     {
        11, -171, -171, -171, -171, -171, -171, -171, -171, -171,
-     -171, -171, -171,   56, -171, -171,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
-       56,   56,   56,   56,   56,   56, -171
+     -171, -171, -171,   58, -171, -171,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  188,   58,
+       58,   58,   58,   58,   58,   58,   58, -171
     },
 
-    } ;
-
+    {
+       11, -172, -172, -172, -172, -172, -172, -172, -172, -172,
+     -172, -172, -172,   58, -172, -172,   58,   58,   58,   58,
 
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+       58,   58,   58,   58,   58,   58,   58,   58,  189,   58,
+       58,   58,   58,   58,   58,   58,   58, -172
+    },
 
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
-	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
+    {
+       11, -173, -173, -173, -173, -173, -173, -173, -173, -173,
+     -173, -173, -173,   58, -173, -173,   58,  190,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -173
+    },
 
-#define YY_NUM_RULES 55
-#define YY_END_OF_BUFFER 56
-static yyconst short int yy_accept[172] =
-    {   0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-       56,    5,    4,    3,    2,   29,   30,   28,   28,   28,
-       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
-       54,   51,   53,   46,   50,   49,   48,   44,   41,   35,
-       40,   44,   33,   34,   43,   43,   36,   43,   43,   44,
-        4,    3,    2,    2,    1,   28,   28,   28,   28,   28,
-       28,   28,   15,   28,   28,   28,   28,   28,   28,   28,
-       28,   28,   54,   51,   53,   52,   46,   45,   48,   47,
-       37,   31,   43,   43,   38,   39,   32,   28,   28,   28,
-       28,   28,   28,   28,   28,   26,   25,   28,   28,   28,
-
-       28,   28,   28,   28,   28,   42,   23,   28,   28,   28,
-       28,   28,   28,   28,   28,   14,   28,    7,   28,   28,
-       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
-       28,   16,   28,   28,   28,   28,   28,   28,   28,   28,
-       28,   10,   28,   13,   28,   28,   28,   28,   28,   28,
-       21,   28,    9,   27,   28,   24,   12,   20,   17,   28,
-        8,   28,   28,   28,   28,   28,    6,   19,   18,   22,
-       11
-    } ;
+    {
+       11, -174, -174, -174, -174, -174, -174, -174, -174, -174,
+     -174, -174, -174,   58, -174, -174,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -174
 
-static yyconst int yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
-       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
-       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
-       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
-       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
-       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
-        1,   15,    1,    1,   13,    1,   16,   17,   18,   19,
+    },
 
-       20,   21,   22,   23,   24,   13,   13,   25,   26,   27,
-       28,   29,   30,   31,   32,   33,   34,   13,   13,   35,
-       13,   13,    1,   36,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    {
+       11, -175, -175, -175, -175, -175, -175, -175, -175, -175,
+     -175, -175, -175,   58, -175, -175,   58,   58,   58,   58,
+       58,  191,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -175
+    },
 
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
+    {
+       11, -176, -176, -176, -176, -176, -176, -176, -176, -176,
+     -176, -176, -176,   58, -176, -176,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -176
+    },
 
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "zconf.l"
-#define INITIAL 0
-#define YY_NEVER_INTERACTIVE 1
-#define COMMAND 1
-#define HELP 2
-#define STRING 3
-#define PARAM 4
+    {
+       11, -177, -177, -177, -177, -177, -177, -177, -177, -177,
+     -177, -177, -177,   58, -177, -177,   58,   58,   58,   58,
 
-#line 5 "zconf.l"
-/*
- * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
- * Released under the terms of the GNU GPL v2.0.
- */
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -177
+    },
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
+    {
+       11, -178, -178, -178, -178, -178, -178, -178, -178, -178,
+     -178, -178, -178,   58, -178, -178,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -178
+    },
 
-#define LKC_DIRECT_LINK
-#include "lkc.h"
-#include "zconf.tab.h"
+    {
+       11, -179, -179, -179, -179, -179, -179, -179, -179, -179,
+     -179, -179, -179,   58, -179, -179,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  192,   58,   58, -179
 
-#define START_STRSIZE	16
+    },
 
-char *text;
-static char *text_ptr;
-static int text_size, text_asize;
+    {
+       11, -180, -180, -180, -180, -180, -180, -180, -180, -180,
+     -180, -180, -180,   58, -180, -180,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -180
+    },
 
-struct buffer {
-        struct buffer *parent;
-        YY_BUFFER_STATE state;
-};
+    {
+       11, -181, -181, -181, -181, -181, -181, -181, -181, -181,
+     -181, -181, -181,   58, -181, -181,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -181
+    },
 
-struct buffer *current_buf;
+    {
+       11, -182, -182, -182, -182, -182, -182, -182, -182, -182,
+     -182, -182, -182,   58, -182, -182,   58,   58,   58,   58,
 
-static int last_ts, first_ts;
+       58,   58,   58,   58,   58,   58,  193,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -182
+    },
 
-static void zconf_endhelp(void);
-static struct buffer *zconf_endfile(void);
+    {
+       11, -183, -183, -183, -183, -183, -183, -183, -183, -183,
+     -183, -183, -183,   58, -183, -183,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,  194,   58,   58,   58, -183
+    },
 
-void new_string(void)
-{
-	text = malloc(START_STRSIZE);
-	text_asize = START_STRSIZE;
-	text_ptr = text;
-	text_size = 0;
-	*text_ptr = 0;
-}
+    {
+       11, -184, -184, -184, -184, -184, -184, -184, -184, -184,
+     -184, -184, -184,   58, -184, -184,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -184
 
-void append_string(const char *str, int size)
-{
-	int new_size = text_size + size + 1;
-	if (new_size > text_asize) {
-		text = realloc(text, new_size);
-		text_asize = new_size;
-		text_ptr = text + text_size;
-	}
-	memcpy(text_ptr, str, size);
-	text_ptr += size;
-	text_size += size;
-	*text_ptr = 0;
-}
+    },
 
-void alloc_string(const char *str, int size)
-{
-	text = malloc(size + 1);
-	memcpy(text, str, size);
-	text[size] = 0;
-}
-#line 1719 "lex.zconf.c"
+    {
+       11, -185, -185, -185, -185, -185, -185, -185, -185, -185,
+     -185, -185, -185,   58, -185, -185,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -185
+    },
 
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
+    {
+       11, -186, -186, -186, -186, -186, -186, -186, -186, -186,
+     -186, -186, -186,   58, -186, -186,   58,   58,   58,  195,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -186
+    },
 
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
-#else
-extern int yywrap YY_PROTO(( void ));
-#endif
-#endif
+    {
+       11, -187, -187, -187, -187, -187, -187, -187, -187, -187,
+     -187, -187, -187,   58, -187, -187,   58,   58,   58,   58,
 
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -187
+    },
 
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
-#endif
+    {
+       11, -188, -188, -188, -188, -188, -188, -188, -188, -188,
+     -188, -188, -188,   58, -188, -188,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,  196,   58, -188
+    },
 
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+    {
+       11, -189, -189, -189, -189, -189, -189, -189, -189, -189,
+     -189, -189, -189,   58, -189, -189,   58,   58,   58,   58,
+       58,   58,  197,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -189
+
+    },
+
+    {
+       11, -190, -190, -190, -190, -190, -190, -190, -190, -190,
+     -190, -190, -190,   58, -190, -190,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,  198,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -190
+    },
+
+    {
+       11, -191, -191, -191, -191, -191, -191, -191, -191, -191,
+     -191, -191, -191,   58, -191, -191,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,  199,   58,   58,   58, -191
+    },
+
+    {
+       11, -192, -192, -192, -192, -192, -192, -192, -192, -192,
+     -192, -192, -192,   58, -192, -192,   58,   58,   58,   58,
+
+       58,  200,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -192
+    },
+
+    {
+       11, -193, -193, -193, -193, -193, -193, -193, -193, -193,
+     -193, -193, -193,   58, -193, -193,   58,   58,   58,   58,
+       58,  201,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -193
+    },
+
+    {
+       11, -194, -194, -194, -194, -194, -194, -194, -194, -194,
+     -194, -194, -194,   58, -194, -194,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  202,   58,   58, -194
+
+    },
+
+    {
+       11, -195, -195, -195, -195, -195, -195, -195, -195, -195,
+     -195, -195, -195,   58, -195, -195,   58,   58,   58,   58,
+       58,  203,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -195
+    },
+
+    {
+       11, -196, -196, -196, -196, -196, -196, -196, -196, -196,
+     -196, -196, -196,   58, -196, -196,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -196
+    },
+
+    {
+       11, -197, -197, -197, -197, -197, -197, -197, -197, -197,
+     -197, -197, -197,   58, -197, -197,   58,   58,   58,   58,
+
+       58,   58,   58,   58,   58,  204,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -197
+    },
+
+    {
+       11, -198, -198, -198, -198, -198, -198, -198, -198, -198,
+     -198, -198, -198,   58, -198, -198,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -198
+    },
+
+    {
+       11, -199, -199, -199, -199, -199, -199, -199, -199, -199,
+     -199, -199, -199,   58, -199, -199,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -199
+
+    },
+
+    {
+       11, -200, -200, -200, -200, -200, -200, -200, -200, -200,
+     -200, -200, -200,   58, -200, -200,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -200
+    },
+
+    {
+       11, -201, -201, -201, -201, -201, -201, -201, -201, -201,
+     -201, -201, -201,   58, -201, -201,   58,  205,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -201
+    },
+
+    {
+       11, -202, -202, -202, -202, -202, -202, -202, -202, -202,
+     -202, -202, -202,   58, -202, -202,   58,  206,   58,   58,
+
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -202
+    },
+
+    {
+       11, -203, -203, -203, -203, -203, -203, -203, -203, -203,
+     -203, -203, -203,   58, -203, -203,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -203
+    },
+
+    {
+       11, -204, -204, -204, -204, -204, -204, -204, -204, -204,
+     -204, -204, -204,   58, -204, -204,   58,   58,   58,   58,
+       58,   58,   58,  207,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -204
+
+    },
+
+    {
+       11, -205, -205, -205, -205, -205, -205, -205, -205, -205,
+     -205, -205, -205,   58, -205, -205,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,  208,   58,
+       58,   58,   58,   58,   58,   58,   58, -205
+    },
+
+    {
+       11, -206, -206, -206, -206, -206, -206, -206, -206, -206,
+     -206, -206, -206,   58, -206, -206,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,  209,   58,   58, -206
+    },
+
+    {
+       11, -207, -207, -207, -207, -207, -207, -207, -207, -207,
+     -207, -207, -207,   58, -207, -207,   58,   58,   58,   58,
+
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -207
+    },
+
+    {
+       11, -208, -208, -208, -208, -208, -208, -208, -208, -208,
+     -208, -208, -208,   58, -208, -208,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -208
+    },
+
+    {
+       11, -209, -209, -209, -209, -209, -209, -209, -209, -209,
+     -209, -209, -209,   58, -209, -209,   58,   58,   58,   58,
+       58,  210,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -209
+
+    },
+
+    {
+       11, -210, -210, -210, -210, -210, -210, -210, -210, -210,
+     -210, -210, -210,   58, -210, -210,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58, -210
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 64
+#define YY_END_OF_BUFFER 65
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[211] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       65,    5,    4,    3,    2,   36,   37,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       63,   60,   62,   55,   59,   58,   57,   53,   48,   42,
+       47,   51,   53,   40,   41,   50,   50,   43,   53,   50,
+       50,   53,    4,    3,    2,    2,    1,   35,   35,   35,
+       35,   35,   35,   35,   16,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   63,   60,   62,   61,
+       55,   54,   57,   56,   44,   51,   38,   50,   50,   52,
+       45,   46,   39,   35,   35,   35,   35,   35,   35,   35,
+
+       35,   35,   30,   29,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   49,   25,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   15,   35,    7,   35,
+       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+       35,   35,   35,   35,   35,   35,   35,   17,   35,   35,
+       35,   35,   35,   34,   35,   35,   35,   35,   35,   35,
+       10,   35,   13,   35,   35,   35,   35,   33,   35,   35,
+       35,   35,   35,   22,   35,   32,    9,   31,   35,   26,
+       12,   35,   35,   21,   18,   35,    8,   35,   35,   35,
+       35,   35,   27,   35,   35,    6,   35,   20,   19,   23,
+
+       35,   35,   11,   35,   35,   35,   14,   28,   35,   24
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   16,    1,   17,   18,   19,   20,
+
+       21,   22,   23,   24,   25,   13,   13,   26,   27,   28,
+       29,   30,   31,   32,   33,   34,   35,   13,   13,   36,
+       13,   13,    1,   37,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+char *text;
+static char *text_ptr;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static struct buffer *zconf_endfile(void);
+
+void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_ptr = text;
+	text_size = 0;
+	*text_ptr = 0;
+}
+
+void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		text = realloc(text, new_size);
+		text_asize = new_size;
+		text_ptr = text + text_size;
+	}
+	memcpy(text_ptr, str, size);
+	text_ptr += size;
+	text_size += size;
+	*text_ptr = 0;
+}
+
+void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
 #endif
 
-#ifndef YY_NO_INPUT
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
 #ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
+extern "C" int zconfwrap (void );
 #else
-static int input YY_PROTO(( void ));
+extern int zconfwrap (void );
 #endif
 #endif
 
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
 
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
 #endif
 
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
 #else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
+static int input (void );
 #endif
+
 #endif
 
 /* Amount of stuff to slurp up with each read. */
@@ -1790,12 +2114,11 @@ YY_MALLOC_DECL
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
-
 #ifndef ECHO
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define ECHO (void) fwrite( zconftext, zconfleng, 1, zconfout )
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -1804,7 +2127,7 @@ YY_MALLOC_DECL
 #ifndef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
 	errno=0; \
-	while ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
 	{ \
 		if( errno != EINTR) \
 		{ \
@@ -1812,8 +2135,10 @@ YY_MALLOC_DECL
 			break; \
 		} \
 		errno=0; \
-		clearerr(yyin); \
-	}
+		clearerr(zconfin); \
+	}\
+\
+
 #endif
 
 /* No semi-colon after return; correct usage is to write "yyterminate();" -
@@ -1834,14 +2159,20 @@ YY_MALLOC_DECL
 #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
 #endif
 
+/* end tables serialization structures and prototypes */
+
 /* Default declaration of generated scanner - a define so the user can
  * easily add parameters.
  */
 #ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
+#define YY_DECL_IS_OURS 1
 
-/* Code executed at the beginning of each rule, after yytext and yyleng
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
  * have been set up.
  */
 #ifndef YY_USER_ACTION
@@ -1856,58 +2187,58 @@ YY_MALLOC_DECL
 #define YY_RULE_SETUP \
 	YY_USER_ACTION
 
+/** The main scanner function which does all the work.
+ */
 YY_DECL
-	{
+{
 	register yy_state_type yy_current_state;
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
-
-#line 71 "zconf.l"
-
+    
 	int str = 0;
 	int ts, i;
 
-#line 1871 "lex.zconf.c"
-
-	if ( yy_init )
+	if ( (yy_init) )
 		{
-		yy_init = 0;
+		(yy_init) = 0;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
 #endif
 
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
 
-		if ( ! yyin )
-			yyin = stdin;
+		if ( ! zconfin )
+			zconfin = stdin;
 
-		if ( ! yyout )
-			yyout = stdout;
+		if ( ! zconfout )
+			zconfout = stdout;
 
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
 
-		yy_load_buffer_state();
+		zconf_load_buffer_state( );
 		}
 
 	while ( 1 )		/* loops until end-of-file is reached */
 		{
-		yy_cp = yy_c_buf_p;
+		yy_cp = (yy_c_buf_p);
 
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
 
 		/* yy_bp points to the position in yy_ch_buf of the start of
 		 * the current run.
 		 */
 		yy_bp = yy_cp;
 
-		yy_current_state = yy_start;
+		yy_current_state = (yy_start);
 yy_match:
-		while ( (yy_current_state = yy_nxt[yy_current_state][yy_ec[YY_SC_TO_UI(*yy_cp)]]) > 0 )
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
 			++yy_cp;
 
 		yy_current_state = -yy_current_state;
@@ -1917,334 +2248,321 @@ yy_find_action:
 
 		YY_DO_BEFORE_ACTION;
 
-
 do_action:	/* This label is used only to access EOF actions. */
 
-
 		switch ( yy_act )
 	{ /* beginning of action switch */
 case 1:
+/* rule 1 can match eol */
 YY_RULE_SETUP
-#line 75 "zconf.l"
 current_file->lineno++;
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 76 "zconf.l"
 
 	YY_BREAK
 case 3:
+/* rule 3 can match eol */
 YY_RULE_SETUP
-#line 78 "zconf.l"
 current_file->lineno++; return T_EOL;
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 80 "zconf.l"
 {
 	BEGIN(COMMAND);
 }
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 84 "zconf.l"
 {
-	unput(yytext[0]);
+	unput(zconftext[0]);
 	BEGIN(COMMAND);
 }
 	YY_BREAK
 
 case 6:
 YY_RULE_SETUP
-#line 91 "zconf.l"
 BEGIN(PARAM); return T_MAINMENU;
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 92 "zconf.l"
 BEGIN(PARAM); return T_MENU;
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 93 "zconf.l"
 BEGIN(PARAM); return T_ENDMENU;
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 94 "zconf.l"
 BEGIN(PARAM); return T_SOURCE;
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 95 "zconf.l"
 BEGIN(PARAM); return T_CHOICE;
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 96 "zconf.l"
 BEGIN(PARAM); return T_ENDCHOICE;
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 97 "zconf.l"
 BEGIN(PARAM); return T_COMMENT;
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 98 "zconf.l"
 BEGIN(PARAM); return T_CONFIG;
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 99 "zconf.l"
-BEGIN(PARAM); return T_HELP;
+BEGIN(PARAM); return T_MENUCONFIG;
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 100 "zconf.l"
-BEGIN(PARAM); return T_IF;
+BEGIN(PARAM); return T_HELP;
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 101 "zconf.l"
-BEGIN(PARAM); return T_ENDIF;
+BEGIN(PARAM); return T_IF;
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 102 "zconf.l"
-BEGIN(PARAM); return T_DEPENDS;
+BEGIN(PARAM); return T_ENDIF;
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 103 "zconf.l"
-BEGIN(PARAM); return T_REQUIRES;
+BEGIN(PARAM); return T_DEPENDS;
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 104 "zconf.l"
-BEGIN(PARAM); return T_OPTIONAL;
+BEGIN(PARAM); return T_REQUIRES;
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 105 "zconf.l"
-BEGIN(PARAM); return T_DEFAULT;
+BEGIN(PARAM); return T_OPTIONAL;
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 106 "zconf.l"
-BEGIN(PARAM); return T_PROMPT;
+BEGIN(PARAM); return T_DEFAULT;
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 107 "zconf.l"
-BEGIN(PARAM); return T_TRISTATE;
+BEGIN(PARAM); return T_PROMPT;
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 108 "zconf.l"
-BEGIN(PARAM); return T_BOOLEAN;
+BEGIN(PARAM); return T_TRISTATE;
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 109 "zconf.l"
-BEGIN(PARAM); return T_BOOLEAN;
+BEGIN(PARAM); return T_DEF_TRISTATE;
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 110 "zconf.l"
-BEGIN(PARAM); return T_INT;
+BEGIN(PARAM); return T_BOOLEAN;
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 111 "zconf.l"
-BEGIN(PARAM); return T_HEX;
+BEGIN(PARAM); return T_BOOLEAN;
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 112 "zconf.l"
-BEGIN(PARAM); return T_STRING;
+BEGIN(PARAM); return T_DEF_BOOLEAN;
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 113 "zconf.l"
+BEGIN(PARAM); return T_DEF_BOOLEAN;
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+BEGIN(PARAM); return T_INT;
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+BEGIN(PARAM); return T_HEX;
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+BEGIN(PARAM); return T_STRING;
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+BEGIN(PARAM); return T_SELECT;
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+BEGIN(PARAM); return T_SELECT;
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+BEGIN(PARAM); return T_RANGE;
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
 {
-		alloc_string(yytext, yyleng);
+		alloc_string(zconftext, zconfleng);
 		zconflval.string = text;
 		return T_WORD;
 	}
 	YY_BREAK
-case 29:
+case 36:
 YY_RULE_SETUP
-#line 118 "zconf.l"
 
 	YY_BREAK
-case 30:
+case 37:
+/* rule 37 can match eol */
 YY_RULE_SETUP
-#line 119 "zconf.l"
 current_file->lineno++; BEGIN(INITIAL);
 	YY_BREAK
 
-
-case 31:
+case 38:
 YY_RULE_SETUP
-#line 123 "zconf.l"
 return T_AND;
 	YY_BREAK
-case 32:
+case 39:
 YY_RULE_SETUP
-#line 124 "zconf.l"
 return T_OR;
 	YY_BREAK
-case 33:
+case 40:
 YY_RULE_SETUP
-#line 125 "zconf.l"
 return T_OPEN_PAREN;
 	YY_BREAK
-case 34:
+case 41:
 YY_RULE_SETUP
-#line 126 "zconf.l"
 return T_CLOSE_PAREN;
 	YY_BREAK
-case 35:
+case 42:
 YY_RULE_SETUP
-#line 127 "zconf.l"
 return T_NOT;
 	YY_BREAK
-case 36:
+case 43:
 YY_RULE_SETUP
-#line 128 "zconf.l"
 return T_EQUAL;
 	YY_BREAK
-case 37:
+case 44:
 YY_RULE_SETUP
-#line 129 "zconf.l"
 return T_UNEQUAL;
 	YY_BREAK
-case 38:
+case 45:
 YY_RULE_SETUP
-#line 130 "zconf.l"
 return T_IF;
 	YY_BREAK
-case 39:
+case 46:
 YY_RULE_SETUP
-#line 131 "zconf.l"
 return T_ON;
 	YY_BREAK
-case 40:
+case 47:
 YY_RULE_SETUP
-#line 132 "zconf.l"
 {
-		str = yytext[0];
+		str = zconftext[0];
 		new_string();
 		BEGIN(STRING);
 	}
 	YY_BREAK
-case 41:
+case 48:
+/* rule 48 can match eol */
 YY_RULE_SETUP
-#line 137 "zconf.l"
 BEGIN(INITIAL); current_file->lineno++; return T_EOL;
 	YY_BREAK
-case 42:
+case 49:
 YY_RULE_SETUP
-#line 138 "zconf.l"
 /* ignore */
 	YY_BREAK
-case 43:
+case 50:
 YY_RULE_SETUP
-#line 139 "zconf.l"
 {
-		alloc_string(yytext, yyleng);
+		alloc_string(zconftext, zconfleng);
 		zconflval.string = text;
 		return T_WORD;
 	}
 	YY_BREAK
-case 44:
+case 51:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 52:
+/* rule 52 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 53:
 YY_RULE_SETUP
-#line 144 "zconf.l"
 
 	YY_BREAK
 case YY_STATE_EOF(PARAM):
-#line 145 "zconf.l"
 {
 		BEGIN(INITIAL);
 	}
 	YY_BREAK
 
-
-case 45:
-*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
-yy_c_buf_p = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
+case 54:
+/* rule 54 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
 YY_RULE_SETUP
-#line 151 "zconf.l"
 {
-		append_string(yytext, yyleng);
+		append_string(zconftext, zconfleng);
 		zconflval.string = text;
-		return T_STRING;
+		return T_WORD_QUOTE;
 	}
 	YY_BREAK
-case 46:
+case 55:
 YY_RULE_SETUP
-#line 156 "zconf.l"
 {
-		append_string(yytext, yyleng);
+		append_string(zconftext, zconfleng);
 	}
 	YY_BREAK
-case 47:
-*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
-yy_c_buf_p = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
+case 56:
+/* rule 56 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
 YY_RULE_SETUP
-#line 159 "zconf.l"
 {
-		append_string(yytext+1, yyleng);
+		append_string(zconftext + 1, zconfleng - 1);
 		zconflval.string = text;
-		return T_STRING;
+		return T_WORD_QUOTE;
 	}
 	YY_BREAK
-case 48:
+case 57:
 YY_RULE_SETUP
-#line 164 "zconf.l"
 {
-		append_string(yytext+1, yyleng - 1);
+		append_string(zconftext + 1, zconfleng - 1);
 	}
 	YY_BREAK
-case 49:
+case 58:
 YY_RULE_SETUP
-#line 167 "zconf.l"
 {
-		if (str == yytext[0]) {
+		if (str == zconftext[0]) {
 			BEGIN(PARAM);
 			zconflval.string = text;
-			return T_STRING;
+			return T_WORD_QUOTE;
 		} else
-			append_string(yytext, 1);
+			append_string(zconftext, 1);
 	}
 	YY_BREAK
-case 50:
+case 59:
+/* rule 59 can match eol */
 YY_RULE_SETUP
-#line 175 "zconf.l"
 {
 		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
 		BEGIN(INITIAL);
 		return T_EOL;
 	}
 	YY_BREAK
 case YY_STATE_EOF(STRING):
-#line 180 "zconf.l"
 {
 		BEGIN(INITIAL);
 	}
 	YY_BREAK
 
-
-case 51:
+case 60:
 YY_RULE_SETUP
-#line 186 "zconf.l"
 {
 		ts = 0;
-		for (i = 0; i < yyleng; i++) {
-			if (yytext[i] == '\t')
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
 				ts = (ts & ~7) + 8;
 			else
 				ts++;
@@ -2262,40 +2580,37 @@ YY_RULE_SETUP
 			}
 			append_string("        ", ts);
 		}
-		
 	}
 	YY_BREAK
-case 52:
-*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
-yy_c_buf_p = yy_cp = yy_bp + 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
+case 61:
+/* rule 61 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
 YY_RULE_SETUP
-#line 209 "zconf.l"
 {
 		current_file->lineno++;
 		zconf_endhelp();
 		return T_HELPTEXT;
 	}
 	YY_BREAK
-case 53:
+case 62:
+/* rule 62 can match eol */
 YY_RULE_SETUP
-#line 214 "zconf.l"
 {
 		current_file->lineno++;
 		append_string("\n", 1);
 	}
 	YY_BREAK
-case 54:
+case 63:
 YY_RULE_SETUP
-#line 218 "zconf.l"
 {
-		append_string(yytext, yyleng);
+		append_string(zconftext, zconfleng);
 		if (!first_ts)
 			first_ts = last_ts;
 	}
 	YY_BREAK
 case YY_STATE_EOF(HELP):
-#line 223 "zconf.l"
 {
 		zconf_endhelp();
 		return T_HELPTEXT;
@@ -2304,46 +2619,43 @@ case YY_STATE_EOF(HELP):
 
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(COMMAND):
-#line 229 "zconf.l"
 {
 	if (current_buf) {
 		zconf_endfile();
 		return T_EOF;
 	}
-	fclose(yyin);
+	fclose(zconfin);
 	yyterminate();
 }
 	YY_BREAK
-case 55:
+case 64:
 YY_RULE_SETUP
-#line 238 "zconf.l"
 YY_FATAL_ERROR( "flex scanner jammed" );
 	YY_BREAK
-#line 2323 "lex.zconf.c"
 
 	case YY_END_OF_BUFFER:
 		{
 		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
 
 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
+		*yy_cp = (yy_hold_char);
 		YY_RESTORE_YY_MORE_OFFSET
 
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
 			{
 			/* We're scanning a new file or input source.  It's
 			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
 			 * globals.  Here is the right place to do so, because
 			 * this is the first action (other than possibly a
 			 * back-up) that will match for the new input source.
 			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
 			}
 
 		/* Note that here we test for yy_c_buf_p "<=" to the position
@@ -2353,13 +2665,13 @@ YY_FATAL_ERROR( "flex scanner jammed" );
 		 * end-of-buffer state).  Contrast this with the test
 		 * in input().
 		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			{ /* This was really a NUL. */
 			yy_state_type yy_next_state;
 
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
 
-			yy_current_state = yy_get_previous_state();
+			yy_current_state = yy_get_previous_state(  );
 
 			/* Okay, we're now positioned to make the NUL
 			 * transition.  We couldn't have
@@ -2372,41 +2684,41 @@ YY_FATAL_ERROR( "flex scanner jammed" );
 
 			yy_next_state = yy_try_NUL_trans( yy_current_state );
 
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 
 			if ( yy_next_state )
 				{
 				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
+				yy_cp = ++(yy_c_buf_p);
 				yy_current_state = yy_next_state;
 				goto yy_match;
 				}
 
 			else
 				{
-				yy_cp = yy_c_buf_p;
+				yy_cp = (yy_c_buf_p);
 				goto yy_find_action;
 				}
 			}
 
-		else switch ( yy_get_next_buffer() )
+		else switch ( yy_get_next_buffer(  ) )
 			{
 			case EOB_ACT_END_OF_FILE:
 				{
-				yy_did_buffer_switch_on_eof = 0;
+				(yy_did_buffer_switch_on_eof) = 0;
 
-				if ( yywrap() )
+				if ( zconfwrap( ) )
 					{
 					/* Note: because we've taken care in
 					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
+					 * zconftext, we can now set up
 					 * yy_c_buf_p so that if some total
 					 * hoser (like flex itself) wants to
 					 * call the scanner after we return the
 					 * YY_NULL, it'll still work - another
 					 * YY_NULL will get returned.
 					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
 
 					yy_act = YY_STATE_EOF(YY_START);
 					goto do_action;
@@ -2414,30 +2726,30 @@ YY_FATAL_ERROR( "flex scanner jammed" );
 
 				else
 					{
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 					}
 				break;
 				}
 
 			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_match;
 
 			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_find_action;
 			}
 		break;
@@ -2448,8 +2760,7 @@ YY_FATAL_ERROR( "flex scanner jammed" );
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
-	} /* end of yylex */
-
+} /* end of zconflex */
 
 /* yy_get_next_buffer - try to read in a new buffer
  *
@@ -2458,21 +2769,20 @@ YY_FATAL_ERROR( "flex scanner jammed" );
  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
  *	EOB_ACT_END_OF_FILE - end of file
  */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
 	register int number_to_move, i;
 	int ret_val;
 
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
 		YY_FATAL_ERROR(
 		"fatal flex scanner internal error--end of buffer missed" );
 
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
 		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
 			{
 			/* We matched a single character, the EOB, so
 			 * treat this as a final EOF.
@@ -2492,34 +2802,30 @@ static int yy_get_next_buffer()
 	/* Try to read more data. */
 
 	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
 
 	for ( i = 0; i < number_to_move; ++i )
 		*(dest++) = *(source++);
 
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
 		/* don't do the read, it's not guaranteed to return an EOF,
 		 * just force an EOF
 		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
 
 	else
 		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
+			size_t num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
 			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
 
 			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
 
 			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
 
 			if ( b->yy_is_our_buffer )
 				{
@@ -2532,8 +2838,7 @@ static int yy_get_next_buffer()
 
 				b->yy_ch_buf = (char *)
 					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
 				}
 			else
 				/* Can't grow it, we don't own it. */
@@ -2543,35 +2848,35 @@ static int yy_get_next_buffer()
 				YY_FATAL_ERROR(
 				"fatal error - scanner input buffer overflow" );
 
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
 
-			num_to_read = yy_current_buffer->yy_buf_size -
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
 						number_to_move - 1;
-#endif
+
 			}
 
 		if ( num_to_read > YY_READ_BUF_SIZE )
 			num_to_read = YY_READ_BUF_SIZE;
 
 		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
 
-		yy_current_buffer->yy_n_chars = yy_n_chars;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	if ( yy_n_chars == 0 )
+	if ( (yy_n_chars) == 0 )
 		{
 		if ( number_to_move == YY_MORE_ADJ )
 			{
 			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
+			zconfrestart(zconfin  );
 			}
 
 		else
 			{
 			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
 				YY_BUFFER_EOF_PENDING;
 			}
 		}
@@ -2579,127 +2884,112 @@ static int yy_get_next_buffer()
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
 
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
 
 	return ret_val;
-	}
-
+}
 
 /* yy_get_previous_state - get the state just before the EOB char was reached */
 
-static yy_state_type yy_get_previous_state()
-	{
+    static yy_state_type yy_get_previous_state (void)
+{
 	register yy_state_type yy_current_state;
 	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
 
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
 		{
 		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
 		}
 
 	return yy_current_state;
-	}
-
+}
 
 /* yy_try_NUL_trans - try to make a transition on the NUL character
  *
  * synopsis
  *	next_state = yy_try_NUL_trans( current_state );
  */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
 	register int yy_is_jam;
-
+    
 	yy_current_state = yy_nxt[yy_current_state][1];
 	yy_is_jam = (yy_current_state <= 0);
 
 	return yy_is_jam ? 0 : yy_current_state;
-	}
-
+}
 
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
 
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
 
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 		{ /* need to shift things up to make room */
 		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
 		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
 
-		while ( source > yy_current_buffer->yy_ch_buf )
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
 			*--dest = *--source;
 
 		yy_cp += (int) (dest - source);
 		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
 
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
 		}
 
 	*--yy_cp = (char) c;
 
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
 
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
+#ifndef YY_NO_INPUT
 #ifdef __cplusplus
-static int yyinput()
+    static int yyinput (void)
 #else
-static int input()
+    static int input  (void)
 #endif
-	{
-	int c;
 
-	*yy_c_buf_p = yy_hold_char;
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
 
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
 		{
 		/* yy_c_buf_p now points to the character we want to return.
 		 * If this occurs *before* the EOB characters, then it's a
 		 * valid NUL; if not, then we've hit the end of the buffer.
 		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
+			*(yy_c_buf_p) = '\0';
 
 		else
 			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
 
-			switch ( yy_get_next_buffer() )
+			switch ( yy_get_next_buffer(  ) )
 				{
 				case EOB_ACT_LAST_MATCH:
 					/* This happens because yy_g_n_b()
@@ -2713,16 +3003,16 @@ static int input()
 					 */
 
 					/* Reset buffer status. */
-					yyrestart( yyin );
+					zconfrestart(zconfin );
 
-					/* fall through */
+					/*FALLTHROUGH*/
 
 				case EOB_ACT_END_OF_FILE:
 					{
-					if ( yywrap() )
+					if ( zconfwrap( ) )
 						return EOF;
 
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 #ifdef __cplusplus
 					return yyinput();
@@ -2732,176 +3022,165 @@ static int input()
 					}
 
 				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
+					(yy_c_buf_p) = (yytext_ptr) + offset;
 					break;
 				}
 			}
 		}
 
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
 
 	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+}
+#endif	/* ifndef YY_NO_INPUT */
 
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
 	}
 
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
 
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
 		return;
 
-	if ( yy_current_buffer )
+	if ( YY_CURRENT_BUFFER )
 		{
 		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
 
 	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
 	 * to go ahead and always set it.
 	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
+	(yy_did_buffer_switch_on_eof) = 1;
+}
 
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
 
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
 	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
 
 	b->yy_buf_size = size;
 
 	/* yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
 	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
 	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
 
 	b->yy_is_our_buffer = 1;
 
-	yy_init_buffer( b, file );
+	zconf_init_buffer(b,file );
 
 	return b;
-	}
-
+}
 
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
 	if ( ! b )
 		return;
 
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
 
 	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
-
-#ifndef _WIN32
-#include <unistd.h>
-#else
-#ifndef YY_ALWAYS_INTERACTIVE
-#ifndef YY_NEVER_INTERACTIVE
-extern int isatty YY_PROTO(( int ));
-#endif
-#endif
-#endif
+		zconffree((void *) b->yy_ch_buf  );
 
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
+	zconffree((void *) b  );
+}
 
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
 
-	{
-	yy_flush_buffer( b );
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
 
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
 
-	{
-	if ( ! b )
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
 		return;
 
 	b->yy_n_chars = 0;
@@ -2918,31 +3197,123 @@ YY_BUFFER_STATE b;
 	b->yy_at_bol = 1;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
 	}
 
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
 
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
 
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
 	if ( size < 2 ||
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
 		/* They forgot to leave room for the EOB's. */
 		return 0;
 
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
 
 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
 	b->yy_buf_pos = b->yy_ch_buf = base;
@@ -2954,58 +3325,53 @@ yy_size_t size;
 	b->yy_fill_buffer = 0;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	yy_switch_to_buffer( b );
+	zconf_switch_to_buffer(b  );
 
 	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
+}
 
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param str a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * str )
+{
+    
+	return zconf_scan_bytes(str,strlen(str) );
+}
 
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * bytes, int  len )
+{
 	YY_BUFFER_STATE b;
 	char *buf;
 	yy_size_t n;
 	int i;
-
+    
 	/* Get memory for full buffer, including space for trailing EOB's. */
 	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
+	buf = (char *) zconfalloc(n  );
 	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
 
 	for ( i = 0; i < len; ++i )
 		buf[i] = bytes[i];
 
 	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
 
-	b = yy_scan_buffer( buf, n );
+	b = zconf_scan_buffer(buf,n );
 	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
 
 	/* It's okay to grow etc. this buffer, and we should throw it
 	 * away when we're done.
@@ -3013,148 +3379,164 @@ int len;
 	b->yy_is_our_buffer = 1;
 
 	return b;
-	}
-#endif
-
+}
 
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
 #endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
 
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
 
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
+/* Redefine yyless() so it works in section 3 code. */
 
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
 
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
+/* Accessor  methods (get/set functions) to struct members. */
 
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
 
-	BEGIN(new_state);
-	}
-#endif
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
 
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
 
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
 
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
+/** Get the current token.
+ * 
+ */
 
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
 
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
 
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
 
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
 
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
 
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
 
-/* Redefine yyless() so it works in section 3 code. */
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
 
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
 
+    return 0;
+}
 
-/* Internal utility routines. */
+/*
+ * Internal utility routines.
+ */
 
 #ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
 	register int i;
-	for ( i = 0; i < n; ++i )
+    	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
-	}
+}
 #endif
 
 #ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
+static int yy_flex_strlen (yyconst char * s )
+{
 	register int n;
-	for ( n = 0; s[n]; ++n )
+    	for ( n = 0; s[n]; ++n )
 		;
 
 	return n;
-	}
+}
 #endif
 
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
+void *zconfalloc (yy_size_t  size )
+{
 	return (void *) malloc( size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
 	 * that use void* generic pointers.  It works with the latter
@@ -3163,26 +3545,27 @@ yy_size_t size;
 	 * as though doing an assignment.
 	 */
 	return (void *) realloc( (char *) ptr, size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
 
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
+#define YYTABLES_NAME "yytables"
+
+#undef YY_NEW_FILE
+#undef YY_FLUSH_BUFFER
+#undef yy_set_bol
+#undef yy_new_buffer
+#undef yy_set_interactive
+#undef yytext_ptr
+#undef YY_DO_BEFORE_ACTION
+
+#ifdef YY_DECL_IS_OURS
+#undef YY_DECL_IS_OURS
+#undef YY_DECL
 #endif
-#line 238 "zconf.l"
 
 void zconf_starthelp(void)
 {
@@ -3194,13 +3577,37 @@ void zconf_starthelp(void)
 static void zconf_endhelp(void)
 {
 	zconflval.string = text;
-	BEGIN(INITIAL); 
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
 }
 
 void zconf_initscan(const char *name)
 {
-	yyin = fopen(name, "r");
-	if (!yyin) {
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
 		printf("can't find file %s\n", name);
 		exit(1);
 	}
@@ -3220,12 +3627,12 @@ void zconf_nextfile(const char *name)
 	memset(buf, 0, sizeof(*buf));
 
 	current_buf->state = YY_CURRENT_BUFFER;
-	yyin = fopen(name, "r");
-	if (!yyin) {
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
 		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
 		exit(1);
 	}
-	yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
 	buf->parent = current_buf;
 	current_buf = buf;
 
@@ -3253,9 +3660,9 @@ static struct buffer *zconf_endfile(void)
 
 	parent = current_buf->parent;
 	if (parent) {
-		fclose(yyin);
-		yy_delete_buffer(YY_CURRENT_BUFFER);
-		yy_switch_to_buffer(parent->state);
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
 	}
 	free(current_buf);
 	current_buf = parent;
@@ -3266,7 +3673,7 @@ static struct buffer *zconf_endfile(void)
 int zconf_lineno(void)
 {
 	if (current_buf)
-		return current_file->lineno;
+		return current_file->lineno - 1;
 	else
 		return 0;
 }
@@ -3278,3 +3685,4 @@ char *zconf_curname(void)
 	else
 		return "<none>";
 }
+
diff --git a/scripts/config/lkc.h b/scripts/config/lkc.h
index 688945b87..dd040f7a8 100644
--- a/scripts/config/lkc.h
+++ b/scripts/config/lkc.h
@@ -21,12 +21,14 @@ extern "C" {
 #include "lkc_proto.h"
 #undef P
 
-void symbol_end(char *help);
+#define SRCTREE "srctree"
+
 int zconfparse(void);
 void zconfdump(FILE *out);
 
 extern int zconfdebug;
 void zconf_starthelp(void);
+FILE *zconf_fopen(const char *name);
 void zconf_initscan(const char *name);
 void zconf_nextfile(const char *name);
 int zconf_lineno(void);
@@ -47,9 +49,11 @@ void menu_add_menu(void);
 void menu_end_menu(void);
 void menu_add_entry(struct symbol *sym);
 void menu_end_entry(void);
-struct property *create_prop(enum prop_type type);
 void menu_add_dep(struct expr *dep);
-struct property *menu_add_prop(int token, char *prompt, struct symbol *def, struct expr *dep);
+struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *expr, struct expr *dep);
+void menu_add_prompt(enum prop_type type, char *prompt, struct expr *dep);
+void menu_add_expr(enum prop_type type, struct expr *expr, struct expr *dep);
+void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep);
 void menu_finalize(struct menu *parent);
 void menu_set_type(int type);
 struct file *file_lookup(const char *name);
@@ -61,16 +65,20 @@ extern struct menu *current_menu;
 /* symbol.c */
 void sym_init(void);
 void sym_clear_all_valid(void);
+void sym_set_changed(struct symbol *sym);
+struct symbol *sym_check_deps(struct symbol *sym);
+struct property *prop_alloc(enum prop_type type, struct symbol *sym);
+struct symbol *prop_get_symbol(struct property *prop);
 
 static inline tristate sym_get_tristate_value(struct symbol *sym)
 {
-	return S_TRI(sym->curr);
+	return sym->curr.tri;
 }
 
 
 static inline struct symbol *sym_get_choice_value(struct symbol *sym)
 {
-	return (struct symbol *)S_VAL(sym->curr);
+	return (struct symbol *)sym->curr.val;
 }
 
 static inline bool sym_set_choice_value(struct symbol *ch, struct symbol *chval)
@@ -95,7 +103,6 @@ static inline bool sym_is_optional(struct symbol *sym)
 
 static inline bool sym_has_value(struct symbol *sym)
 {
-	//return S_VAL(sym->def) != NULL;
 	return sym->flags & SYMBOL_NEW ? false : true;
 }
 
diff --git a/scripts/config/lkc_proto.h b/scripts/config/lkc_proto.h
index 47e9c6db3..97c79178e 100644
--- a/scripts/config/lkc_proto.h
+++ b/scripts/config/lkc_proto.h
@@ -5,7 +5,7 @@ P(conf_read,int,(const char *name));
 P(conf_write,int,(const char *name));
 
 /* menu.c */
-extern struct menu rootmenu;
+P(rootmenu,struct menu,);
 
 P(menu_is_visible,bool,(struct menu *menu));
 P(menu_get_prompt,const char *,(struct menu *menu));
@@ -14,17 +14,18 @@ P(menu_get_parent_menu,struct menu *,(struct menu *menu));
 
 /* symbol.c */
 P(symbol_hash,struct symbol *,[SYMBOL_HASHSIZE]);
-extern int sym_change_count;
+P(sym_change_count,int,);
 
 P(sym_lookup,struct symbol *,(const char *name, int isconst));
 P(sym_find,struct symbol *,(const char *name));
-P(sym_type_name,const char *,(int type));
+P(sym_type_name,const char *,(enum symbol_type type));
 P(sym_calc_value,void,(struct symbol *sym));
-P(sym_get_type,int,(struct symbol *sym));
+P(sym_get_type,enum symbol_type,(struct symbol *sym));
 P(sym_tristate_within_range,bool,(struct symbol *sym,tristate tri));
 P(sym_set_tristate_value,bool,(struct symbol *sym,tristate tri));
 P(sym_toggle_tristate_value,tristate,(struct symbol *sym));
 P(sym_string_valid,bool,(struct symbol *sym, const char *newval));
+P(sym_string_within_range,bool,(struct symbol *sym, const char *str));
 P(sym_set_string_value,bool,(struct symbol *sym, const char *newval));
 P(sym_is_changable,bool,(struct symbol *sym));
 P(sym_get_choice_prop,struct property *,(struct symbol *sym));
diff --git a/scripts/config/mconf.c b/scripts/config/mconf.c
index 1ea512eff..739b3b480 100644
--- a/scripts/config/mconf.c
+++ b/scripts/config/mconf.c
@@ -28,6 +28,7 @@
 #define LKC_DIRECT_LINK
 #include "lkc.h"
 
+static char menu_backtitle[128];
 static const char menu_instructions[] =
 	"Arrow keys navigate the menu.  "
 	"<Enter> selects submenus --->.  "
@@ -65,7 +66,7 @@ load_config_help[] =
 	"configurations available on a single machine.\n"
 	"\n"
 	"If you have saved a previous configuration in a file other than the\n"
-	"BusyBox default, entering the name of the file here will allow you\n"
+	"BusyBox's default, entering the name of the file here will allow you\n"
 	"to modify that configuration.\n"
 	"\n"
 	"If you are uncertain, then you have probably never used alternate\n"
@@ -120,6 +121,7 @@ static void show_readme(void);
 static void init_wsize(void)
 {
 	struct winsize ws;
+	char *env;
 
 	if (ioctl(1, TIOCGWINSZ, &ws) == -1) {
 		rows = 24;
@@ -127,6 +129,20 @@ static void init_wsize(void)
 	} else {
 		rows = ws.ws_row;
 		cols = ws.ws_col;
+		if (!rows) {
+			env = getenv("LINES");
+			if (env)
+				rows = atoi(env);
+			if (!rows)
+				rows = 24;
+		}
+		if (!cols) {
+			env = getenv("COLUMNS");
+			if (env)
+				cols = atoi(env);
+			if (!cols)
+				cols = 80;
+		}
 	}
 
 	if (rows < 19 || cols < 80) {
@@ -226,9 +242,7 @@ static void build_conf(struct menu *menu)
 						menu->data ? "-->" : "++>",
 						indent + 1, ' ', prompt);
 				} else {
-					if (menu->parent != &rootmenu)
-						cprint_name("   %*c", indent + 1, ' ');
-					cprint_name("%s  --->", prompt);
+					cprint_name("   %*c%s  --->", indent + 1, ' ', prompt);
 				}
 
 				if (single_menu_mode && menu->data)
@@ -303,7 +317,10 @@ static void build_conf(struct menu *menu)
 			switch (type) {
 			case S_BOOLEAN:
 				cprint_tag("t%p", menu);
-				cprint_name("[%c]", val == no ? ' ' : '*');
+				if (sym_is_changable(sym))
+					cprint_name("[%c]", val == no ? ' ' : '*');
+				else
+					cprint_name("---");
 				break;
 			case S_TRISTATE:
 				cprint_tag("t%p", menu);
@@ -312,7 +329,10 @@ static void build_conf(struct menu *menu)
 				case mod: ch = 'M'; break;
 				default:  ch = ' '; break;
 				}
-				cprint_name("<%c>", ch);
+				if (sym_is_changable(sym))
+					cprint_name("<%c>", ch);
+				else
+					cprint_name("---");
 				break;
 			default:
 				cprint_tag("s%p", menu);
@@ -321,12 +341,18 @@ static void build_conf(struct menu *menu)
 				if (tmp < 0)
 					tmp = 0;
 				cprint_name("%*c%s%s", tmp, ' ', menu_get_prompt(menu),
-					sym_has_value(sym) ? "" : " (NEW)");
+					(sym_has_value(sym) || !sym_is_changable(sym)) ?
+					"" : " (NEW)");
 				goto conf_childs;
 			}
 		}
 		cprint_name("%*c%s%s", indent + 1, ' ', menu_get_prompt(menu),
-			sym_has_value(sym) ? "" : " (NEW)");
+			(sym_has_value(sym) || !sym_is_changable(sym)) ?
+			"" : " (NEW)");
+		if (menu->prompt->type == P_MENU) {
+			cprint_name("  --->");
+			return;
+		}
 	}
 
 conf_childs:
@@ -390,13 +416,15 @@ static void conf(struct menu *menu)
 			switch (type) {
 			case 'm':
 				if (single_menu_mode)
-					submenu->data = (submenu->data)? NULL : (void *)1;
+					submenu->data = (void *) (long) !submenu->data;
 				else
 					conf(submenu);
 				break;
 			case 't':
 				if (sym_is_choice(sym) && sym_get_tristate_value(sym) == yes)
 					conf_choice(submenu);
+				else if (submenu->prompt->type == P_MENU)
+					conf(submenu);
 				break;
 			case 's':
 				conf_string(submenu);
@@ -602,7 +630,6 @@ static void conf_cleanup(void)
 {
 	tcsetattr(1, TCSAFLUSH, &ios_org);
 	unlink(".help.tmp");
-	unlink("lxdialog.scrltmp");
 }
 
 static void winch_handler(int sig)
@@ -638,10 +665,9 @@ int main(int ac, char **av)
 	conf_parse(av[1]);
 	conf_read(NULL);
 
-	backtitle = malloc(128);
 	sym = sym_lookup("VERSION", 0);
 	sym_calc_value(sym);
-	snprintf(backtitle, 128, "BusyBox v%s Configuration",
+	snprintf(menu_backtitle, 128, "BusyBox v%s Configuration",
 		sym_get_string_value(sym));
 
 	mode = getenv("MENUCONFIG_MODE");
diff --git a/scripts/config/menu.c b/scripts/config/menu.c
index 3d3b4d19c..6e075f80b 100644
--- a/scripts/config/menu.c
+++ b/scripts/config/menu.c
@@ -54,9 +54,34 @@ void menu_end_menu(void)
 	current_menu = current_menu->parent;
 }
 
+struct expr *menu_check_dep(struct expr *e)
+{
+	if (!e)
+		return e;
+
+	switch (e->type) {
+	case E_NOT:
+		e->left.expr = menu_check_dep(e->left.expr);
+		break;
+	case E_OR:
+	case E_AND:
+		e->left.expr = menu_check_dep(e->left.expr);
+		e->right.expr = menu_check_dep(e->right.expr);
+		break;
+	case E_SYMBOL:
+		/* change 'm' into 'm' && MODULES */
+		if (e->left.sym == &symbol_mod)
+			return expr_alloc_and(e, expr_alloc_symbol(modules_sym));
+		break;
+	default:
+		break;
+	}
+	return e;
+}
+
 void menu_add_dep(struct expr *dep)
 {
-	current_entry->dep = expr_alloc_and(current_entry->dep, dep);
+	current_entry->dep = expr_alloc_and(current_entry->dep, menu_check_dep(dep));
 }
 
 void menu_set_type(int type)
@@ -69,56 +94,43 @@ void menu_set_type(int type)
 		sym->type = type;
 		return;
 	}
-	fprintf(stderr, "%s:%d: type of '%s' redefined from '%s' to '%s'\n",
+	fprintf(stderr, "%s:%d:warning: type of '%s' redefined from '%s' to '%s'\n",
 		current_entry->file->name, current_entry->lineno,
 		sym->name ? sym->name : "<choice>", sym_type_name(sym->type), sym_type_name(type));
 }
 
-struct property *create_prop(enum prop_type type)
-{
-	struct property *prop;
-
-	prop = malloc(sizeof(*prop));
-	memset(prop, 0, sizeof(*prop));
-	prop->type = type;
-	prop->file = current_file;
-	prop->lineno = zconf_lineno();
-
-	return prop;
-}
-
-struct property *menu_add_prop(int token, char *prompt, struct symbol *def, struct expr *dep)
+struct property *menu_add_prop(enum prop_type type, char *prompt, struct expr *expr, struct expr *dep)
 {
-	struct property *prop = create_prop(token);
-	struct property **propp;
+	struct property *prop = prop_alloc(type, current_entry->sym);
 
-	prop->sym = current_entry->sym;
 	prop->menu = current_entry;
 	prop->text = prompt;
-	prop->def = def;
-	E_EXPR(prop->visible) = dep;
+	prop->expr = expr;
+	prop->visible.expr = menu_check_dep(dep);
 
-	if (prompt)
+	if (prompt) {
+		if (current_entry->prompt)
+			fprintf(stderr, "%s:%d: prompt redefined\n",
+				current_entry->file->name, current_entry->lineno);
 		current_entry->prompt = prop;
-
-	/* append property to the prop list of symbol */
-	if (prop->sym) {
-		for (propp = &prop->sym->prop; *propp; propp = &(*propp)->next)
-			;
-		*propp = prop;
 	}
 
 	return prop;
 }
 
-void menu_add_prompt(int token, char *prompt, struct expr *dep)
+void menu_add_prompt(enum prop_type type, char *prompt, struct expr *dep)
 {
-	current_entry->prompt = menu_add_prop(token, prompt, NULL, dep);
+	menu_add_prop(type, prompt, NULL, dep);
 }
 
-void menu_add_default(int token, struct symbol *def, struct expr *dep)
+void menu_add_expr(enum prop_type type, struct expr *expr, struct expr *dep)
 {
-	current_entry->prompt = menu_add_prop(token, NULL, def, dep);
+	menu_add_prop(type, NULL, expr, dep);
+}
+
+void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)
+{
+	menu_add_prop(type, NULL, expr_alloc_symbol(sym), dep);
 }
 
 void menu_finalize(struct menu *parent)
@@ -126,7 +138,7 @@ void menu_finalize(struct menu *parent)
 	struct menu *menu, *last_menu;
 	struct symbol *sym;
 	struct property *prop;
-	struct expr *parentdep, *basedep, *dep, *dep2;
+	struct expr *parentdep, *basedep, *dep, *dep2, **ep;
 
 	sym = parent->sym;
 	if (parent->list) {
@@ -143,7 +155,7 @@ void menu_finalize(struct menu *parent)
 			}
 			parentdep = expr_alloc_symbol(sym);
 		} else if (parent->prompt)
-			parentdep = E_EXPR(parent->prompt->visible);
+			parentdep = parent->prompt->visible.expr;
 		else
 			parentdep = parent->dep;
 
@@ -159,23 +171,28 @@ void menu_finalize(struct menu *parent)
 			for (; prop; prop = prop->next) {
 				if (prop->menu != menu)
 					continue;
-				dep = expr_transform(E_EXPR(prop->visible));
+				dep = expr_transform(prop->visible.expr);
 				dep = expr_alloc_and(expr_copy(basedep), dep);
 				dep = expr_eliminate_dups(dep);
 				if (menu->sym && menu->sym->type != S_TRISTATE)
 					dep = expr_trans_bool(dep);
-				E_EXPR(prop->visible) = dep;
+				prop->visible.expr = dep;
+				if (prop->type == P_SELECT) {
+					struct symbol *es = prop_get_symbol(prop);
+					es->rev_dep.expr = expr_alloc_or(es->rev_dep.expr,
+							expr_alloc_and(expr_alloc_symbol(menu->sym), expr_copy(dep)));
+				}
 			}
 		}
 		for (menu = parent->list; menu; menu = menu->next)
 			menu_finalize(menu);
-	} else if (sym && parent->prompt) {
-		basedep = E_EXPR(parent->prompt->visible);
+	} else if (sym) {
+		basedep = parent->prompt ? parent->prompt->visible.expr : NULL;
 		basedep = expr_trans_compare(basedep, E_UNEQUAL, &symbol_no);
 		basedep = expr_eliminate_dups(expr_transform(basedep));
 		last_menu = NULL;
 		for (menu = parent->next; menu; menu = menu->next) {
-			dep = menu->prompt ? E_EXPR(menu->prompt->visible) : menu->dep;
+			dep = menu->prompt ? menu->prompt->visible.expr : menu->dep;
 			if (!expr_contains_symbol(dep, sym))
 				break;
 			if (expr_depends_symbol(dep, sym))
@@ -204,14 +221,27 @@ void menu_finalize(struct menu *parent)
 	for (menu = parent->list; menu; menu = menu->next) {
 		if (sym && sym_is_choice(sym) && menu->sym) {
 			menu->sym->flags |= SYMBOL_CHOICEVAL;
+			if (!menu->prompt)
+				fprintf(stderr, "%s:%d:warning: choice value must have a prompt\n",
+					menu->file->name, menu->lineno);
+			for (prop = menu->sym->prop; prop; prop = prop->next) {
+				if (prop->type == P_PROMPT && prop->menu != menu) {
+					fprintf(stderr, "%s:%d:warning: choice values currently only support a single prompt\n",
+						prop->file->name, prop->lineno);
+					
+				}
+				if (prop->type == P_DEFAULT)
+					fprintf(stderr, "%s:%d:warning: defaults for choice values not supported\n",
+						prop->file->name, prop->lineno);
+			}
 			current_entry = menu;
 			menu_set_type(sym->type);
-			menu_add_prop(P_CHOICE, NULL, parent->sym, NULL);
-			prop = sym_get_choice_prop(parent->sym);
-			//dep = expr_alloc_one(E_CHOICE, dep);
-			//dep->right.sym = menu->sym;
-			prop->dep = expr_alloc_one(E_CHOICE, prop->dep);
-			prop->dep->right.sym = menu->sym;
+			menu_add_symbol(P_CHOICE, sym, NULL);
+			prop = sym_get_choice_prop(sym);
+			for (ep = &prop->expr; *ep; ep = &(*ep)->left.expr)
+				;
+			*ep = expr_alloc_one(E_CHOICE, NULL);
+			(*ep)->right.sym = menu->sym;
 		}
 		if (menu->list && (!menu->prompt || !menu->prompt->text)) {
 			for (last_menu = menu->list; ; last_menu = last_menu->next) {
@@ -224,20 +254,79 @@ void menu_finalize(struct menu *parent)
 			menu->list = NULL;
 		}
 	}
+
+	if (sym && !(sym->flags & SYMBOL_WARNED)) {
+		struct symbol *sym2;
+		if (sym->type == S_UNKNOWN)
+			fprintf(stderr, "%s:%d:warning: config symbol defined without type\n",
+				parent->file->name, parent->lineno);
+
+		if (sym_is_choice(sym) && !parent->prompt)
+			fprintf(stderr, "%s:%d:warning: choice must have a prompt\n",
+				parent->file->name, parent->lineno);
+
+		for (prop = sym->prop; prop; prop = prop->next) {
+			switch (prop->type) {
+			case P_DEFAULT:
+				if ((sym->type == S_STRING || sym->type == S_INT || sym->type == S_HEX) &&
+				    prop->expr->type != E_SYMBOL)
+					fprintf(stderr, "%s:%d:warning: default must be a single symbol\n",
+						prop->file->name, prop->lineno);
+				break;
+			case P_SELECT:
+				sym2 = prop_get_symbol(prop);
+				if ((sym->type != S_BOOLEAN && sym->type != S_TRISTATE) ||
+				    (sym2->type != S_BOOLEAN && sym2->type != S_TRISTATE))
+					fprintf(stderr, "%s:%d:warning: enable is only allowed with boolean and tristate symbols\n",
+						prop->file->name, prop->lineno);
+				break;
+			case P_RANGE:
+				if (sym->type != S_INT && sym->type != S_HEX)
+					fprintf(stderr, "%s:%d:warning: range is only allowed for int or hex symbols\n",
+						prop->file->name, prop->lineno);
+				if (!sym_string_valid(sym, prop->expr->left.sym->name) ||
+				    !sym_string_valid(sym, prop->expr->right.sym->name))
+					fprintf(stderr, "%s:%d:warning: range is invalid\n",
+						prop->file->name, prop->lineno);
+				break;
+			default:
+				;
+			}
+		}
+		sym->flags |= SYMBOL_WARNED;
+	}
+
+	if (sym && !sym_is_optional(sym) && parent->prompt) {
+		sym->rev_dep.expr = expr_alloc_or(sym->rev_dep.expr,
+				expr_alloc_and(parent->prompt->visible.expr,
+					expr_alloc_symbol(&symbol_mod)));
+	}
 }
 
 bool menu_is_visible(struct menu *menu)
 {
+	struct menu *child;
+	struct symbol *sym;
 	tristate visible;
 
 	if (!menu->prompt)
 		return false;
-	if (menu->sym) {
-		sym_calc_value(menu->sym);
-		visible = E_TRI(menu->prompt->visible);
+	sym = menu->sym;
+	if (sym) {
+		sym_calc_value(sym);
+		visible = menu->prompt->visible.tri;
 	} else
-		visible = E_CALC(menu->prompt->visible);
-	return visible != no;
+		visible = menu->prompt->visible.tri = expr_calc_value(menu->prompt->visible.expr);
+
+	if (visible != no)
+		return true;
+	if (!sym || sym_get_tristate_value(menu->sym) == no)
+		return false;
+
+	for (child = menu->list; child; child = child->next)
+		if (menu_is_visible(child))
+			return true;
+	return false;
 }
 
 const char *menu_get_prompt(struct menu *menu)
@@ -258,10 +347,9 @@ struct menu *menu_get_parent_menu(struct menu *menu)
 {
 	enum prop_type type;
 
-	while (menu != &rootmenu) {
-		menu = menu->parent;
+	for (; menu != &rootmenu; menu = menu->parent) {
 		type = menu->prompt ? menu->prompt->type : 0;
-		if (type == P_MENU || type == P_ROOTMENU)
+		if (type == P_MENU)
 			break;
 	}
 	return menu;
diff --git a/scripts/config/symbol.c b/scripts/config/symbol.c
index f2d0015de..29d8d3e0b 100644
--- a/scripts/config/symbol.c
+++ b/scripts/config/symbol.c
@@ -34,24 +34,14 @@ struct symbol *modules_sym;
 
 void sym_add_default(struct symbol *sym, const char *def)
 {
-	struct property *prop = create_prop(P_DEFAULT);
-	struct property **propp;
-
-	prop->sym = sym;
-	prop->def = sym_lookup(def, 1);
+	struct property *prop = prop_alloc(P_DEFAULT, sym);
 
-	/* append property to the prop list of symbol */
-	if (prop->sym) {
-		for (propp = &prop->sym->prop; *propp; propp = &(*propp)->next)
-			;
-		*propp = prop;
-	}
+	prop->expr = expr_alloc_symbol(sym_lookup(def, 1));
 }
 
 void sym_init(void)
 {
 	struct symbol *sym;
-	struct utsname uts;
 	char *p;
 	static bool inited = false;
 
@@ -59,17 +49,6 @@ void sym_init(void)
 		return;
 	inited = true;
 
-	uname(&uts);
-
-#if 0
-	sym = sym_lookup("ARCH", 0);
-	sym->type = S_STRING;
-	sym->flags |= SYMBOL_AUTO;
-	p = getenv("ARCH");
-	if (p)
-		sym_add_default(sym, p);
-#endif
-
 	sym = sym_lookup("VERSION", 0);
 	sym->type = S_STRING;
 	sym->flags |= SYMBOL_AUTO;
@@ -77,37 +56,32 @@ void sym_init(void)
 	if (p)
 		sym_add_default(sym, p);
 
-#if 0
-	sym = sym_lookup("UNAME_RELEASE", 0);
-	sym->type = S_STRING;
-	sym->flags |= SYMBOL_AUTO;
-	sym_add_default(sym, uts.release);
-#endif
-
 	sym = sym_lookup("TARGET_ARCH", 0);
 	sym->type = S_STRING;
 	sym->flags |= SYMBOL_AUTO;
 	p = getenv("TARGET_ARCH");
 	if (p)
 		sym_add_default(sym, p);
+
 }
 
-int sym_get_type(struct symbol *sym)
+enum symbol_type sym_get_type(struct symbol *sym)
 {
-	int type = sym->type;
+	enum symbol_type type = sym->type;
+
 	if (type == S_TRISTATE) {
 		if (sym_is_choice_value(sym) && sym->visible == yes)
 			type = S_BOOLEAN;
 		else {
 			sym_calc_value(modules_sym);
-			if (S_TRI(modules_sym->curr) == no)
+			if (modules_sym->curr.tri == no)
 				type = S_BOOLEAN;
 		}
 	}
 	return type;
 }
 
-const char *sym_type_name(int type)
+const char *sym_type_name(enum symbol_type type)
 {
 	switch (type) {
 	case S_BOOLEAN:
@@ -122,6 +96,8 @@ const char *sym_type_name(int type)
 		return "string";
 	case S_UNKNOWN:
 		return "unknown";
+	case S_OTHER:
+		break;
 	}
 	return "???";
 }
@@ -138,41 +114,104 @@ struct property *sym_get_choice_prop(struct symbol *sym)
 struct property *sym_get_default_prop(struct symbol *sym)
 {
 	struct property *prop;
-	tristate visible;
 
 	for_all_defaults(sym, prop) {
-		visible = E_CALC(prop->visible);
-		if (visible != no)
+		prop->visible.tri = expr_calc_value(prop->visible.expr);
+		if (prop->visible.tri != no)
+			return prop;
+	}
+	return NULL;
+}
+
+struct property *sym_get_range_prop(struct symbol *sym)
+{
+	struct property *prop;
+
+	for_all_properties(sym, prop, P_RANGE) {
+		prop->visible.tri = expr_calc_value(prop->visible.expr);
+		if (prop->visible.tri != no)
 			return prop;
 	}
 	return NULL;
 }
 
-void sym_calc_visibility(struct symbol *sym)
+static void sym_calc_visibility(struct symbol *sym)
 {
 	struct property *prop;
-	tristate visible, oldvisible;
+	tristate tri;
 
 	/* any prompt visible? */
-	oldvisible = sym->visible;
-	visible = no;
-	for_all_prompts(sym, prop)
-		visible = E_OR(visible, E_CALC(prop->visible));
-	if (oldvisible != visible) {
-		sym->visible = visible;
-		sym->flags |= SYMBOL_CHANGED;
+	tri = no;
+	for_all_prompts(sym, prop) {
+		prop->visible.tri = expr_calc_value(prop->visible.expr);
+		tri = E_OR(tri, prop->visible.tri);
+	}
+	if (sym->visible != tri) {
+		sym->visible = tri;
+		sym_set_changed(sym);
+	}
+	if (sym_is_choice_value(sym))
+		return;
+	tri = no;
+	if (sym->rev_dep.expr)
+		tri = expr_calc_value(sym->rev_dep.expr);
+	if (sym->rev_dep.tri != tri) {
+		sym->rev_dep.tri = tri;
+		sym_set_changed(sym);
+	}
+}
+
+static struct symbol *sym_calc_choice(struct symbol *sym)
+{
+	struct symbol *def_sym;
+	struct property *prop;
+	struct expr *e;
+
+	/* is the user choice visible? */
+	def_sym = sym->user.val;
+	if (def_sym) {
+		sym_calc_visibility(def_sym);
+		if (def_sym->visible != no)
+			return def_sym;
 	}
+
+	/* any of the defaults visible? */
+	for_all_defaults(sym, prop) {
+		prop->visible.tri = expr_calc_value(prop->visible.expr);
+		if (prop->visible.tri == no)
+			continue;
+		def_sym = prop_get_symbol(prop);
+		sym_calc_visibility(def_sym);
+		if (def_sym->visible != no)
+			return def_sym;
+	}
+
+	/* just get the first visible value */
+	prop = sym_get_choice_prop(sym);
+	for (e = prop->expr; e; e = e->left.expr) {
+		def_sym = e->right.sym;
+		sym_calc_visibility(def_sym);
+		if (def_sym->visible != no)
+			return def_sym;
+	}
+
+	/* no choice? reset tristate value */
+	sym->curr.tri = no;
+	return NULL;
 }
 
 void sym_calc_value(struct symbol *sym)
 {
 	struct symbol_value newval, oldval;
-	struct property *prop, *def_prop;
-	struct symbol *def_sym;
+	struct property *prop;
 	struct expr *e;
 
+	if (!sym)
+		return;
+
 	if (sym->flags & SYMBOL_VALID)
 		return;
+	sym->flags |= SYMBOL_VALID;
 
 	oldval = sym->curr;
 
@@ -187,17 +226,10 @@ void sym_calc_value(struct symbol *sym)
 		newval = symbol_no.curr;
 		break;
 	default:
-		S_VAL(newval) = sym->name;
-		S_TRI(newval) = no;
-		if (sym->flags & SYMBOL_CONST) {
-			goto out;
-		}
-		//newval = symbol_empty.curr;
-		// generate warning somewhere here later
-		//S_TRI(newval) = yes;
-		goto out;
+		sym->curr.val = sym->name;
+		sym->curr.tri = no;
+		return;
 	}
-	sym->flags |= SYMBOL_VALID;
 	if (!sym_is_choice_value(sym))
 		sym->flags &= ~SYMBOL_WRITE;
 
@@ -206,95 +238,77 @@ void sym_calc_value(struct symbol *sym)
 	/* set default if recursively called */
 	sym->curr = newval;
 
-	if (sym->visible != no) {
-		sym->flags |= SYMBOL_WRITE;
-		if (!sym_has_value(sym)) {
-			if (!sym_is_choice(sym)) {
-				prop = sym_get_default_prop(sym);
-				if (prop) {
-					sym_calc_value(prop->def);
-					newval = prop->def->curr;
-				}
-			}
-		} else
-			newval = sym->def;
-
-		S_TRI(newval) = E_AND(S_TRI(newval), sym->visible);
-		/* if the symbol is visible and not optionial,
-		 * possibly ignore old user choice. */
-		if (!sym_is_optional(sym) && S_TRI(newval) == no)
-			S_TRI(newval) = sym->visible;
+	switch (sym_get_type(sym)) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
 		if (sym_is_choice_value(sym) && sym->visible == yes) {
 			prop = sym_get_choice_prop(sym);
-			S_TRI(newval) = (S_VAL(prop->def->curr) == sym) ? yes : no;
-		}
-	} else {
-		prop = sym_get_default_prop(sym);
-		if (prop) {
+			newval.tri = (prop_get_symbol(prop)->curr.val == sym) ? yes : no;
+		} else if (E_OR(sym->visible, sym->rev_dep.tri) != no) {
 			sym->flags |= SYMBOL_WRITE;
-			sym_calc_value(prop->def);
-			newval = prop->def->curr;
+			if (sym_has_value(sym))
+				newval.tri = sym->user.tri;
+			else if (!sym_is_choice(sym)) {
+				prop = sym_get_default_prop(sym);
+				if (prop)
+					newval.tri = expr_calc_value(prop->expr);
+			}
+			newval.tri = E_OR(E_AND(newval.tri, sym->visible), sym->rev_dep.tri);
+		} else if (!sym_is_choice(sym)) {
+			prop = sym_get_default_prop(sym);
+			if (prop) {
+				sym->flags |= SYMBOL_WRITE;
+				newval.tri = expr_calc_value(prop->expr);
+			}
 		}
-	}
-
-	switch (sym_get_type(sym)) {
-	case S_TRISTATE:
-		if (S_TRI(newval) != mod)
-			break;
-		sym_calc_value(modules_sym);
-		if (S_TRI(modules_sym->curr) == no)
-			S_TRI(newval) = yes;
-		break;
-	case S_BOOLEAN:
-		if (S_TRI(newval) == mod)
-			S_TRI(newval) = yes;
-	}
-
-out:
-	sym->curr = newval;
-
-	if (sym_is_choice(sym) && S_TRI(newval) == yes) {
-		def_sym = S_VAL(sym->def);
-		if (def_sym) {
-			sym_calc_visibility(def_sym);
-			if (def_sym->visible == no)
-				def_sym = NULL;
+		if (sym_get_type(sym) == S_BOOLEAN) {
+			if (newval.tri == mod)
+				newval.tri = yes;
+			if (sym->visible == mod)
+				sym->visible = yes;
+			if (sym->rev_dep.tri == mod)
+				sym->rev_dep.tri = yes;
 		}
-		if (!def_sym) {
-			for_all_defaults(sym, def_prop) {
-				if (E_CALC(def_prop->visible) == no)
-					continue;
-				sym_calc_visibility(def_prop->def);
-				if (def_prop->def->visible != no) {
-					def_sym = def_prop->def;
-					break;
-				}
+		break;
+	case S_STRING:
+	case S_HEX:
+	case S_INT:
+		if (sym->visible != no) {
+			sym->flags |= SYMBOL_WRITE;
+			if (sym_has_value(sym)) {
+				newval.val = sym->user.val;
+				break;
 			}
 		}
-
-		if (!def_sym) {
-			prop = sym_get_choice_prop(sym);
-			for (e = prop->dep; e; e = e->left.expr) {
-				sym_calc_visibility(e->right.sym);
-				if (e->right.sym->visible != no) {
-					def_sym = e->right.sym;
-					break;
-				}
+		prop = sym_get_default_prop(sym);
+		if (prop) {
+			struct symbol *ds = prop_get_symbol(prop);
+			if (ds) {
+				sym->flags |= SYMBOL_WRITE;
+				sym_calc_value(ds);
+				newval.val = ds->curr.val;
 			}
 		}
-
-		S_VAL(newval) = def_sym;
+		break;
+	default:
+		;
 	}
 
-	if (memcmp(&oldval, &newval, sizeof(newval)))
-		sym->flags |= SYMBOL_CHANGED;
 	sym->curr = newval;
+	if (sym_is_choice(sym) && newval.tri == yes)
+		sym->curr.val = sym_calc_choice(sym);
+
+	if (memcmp(&oldval, &sym->curr, sizeof(oldval)))
+		sym_set_changed(sym);
 
 	if (sym_is_choice(sym)) {
 		int flags = sym->flags & (SYMBOL_CHANGED | SYMBOL_WRITE);
 		prop = sym_get_choice_prop(sym);
-		for (e = prop->dep; e; e = e->left.expr)
+		for (e = prop->expr; e; e = e->left.expr) {
 			e->right.sym->flags |= flags;
+			if (flags & SYMBOL_CHANGED)
+				sym_set_changed(e->right.sym);
+		}
 	}
 }
 
@@ -308,13 +322,24 @@ void sym_clear_all_valid(void)
 	sym_change_count++;
 }
 
+void sym_set_changed(struct symbol *sym)
+{
+	struct property *prop;
+
+	sym->flags |= SYMBOL_CHANGED;
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu)
+			prop->menu->flags |= MENU_CHANGED;
+	}
+}
+
 void sym_set_all_changed(void)
 {
 	struct symbol *sym;
 	int i;
 
 	for_all_symbols(i, sym)
-		sym->flags |= SYMBOL_CHANGED;
+		sym_set_changed(sym);
 }
 
 bool sym_tristate_within_range(struct symbol *sym, tristate val)
@@ -327,19 +352,13 @@ bool sym_tristate_within_range(struct symbol *sym, tristate val)
 	if (type != S_BOOLEAN && type != S_TRISTATE)
 		return false;
 
-	switch (val) {
-	case no:
-		if (sym_is_choice_value(sym) && sym->visible == yes)
-			return false;
-		return sym_is_optional(sym);
-	case mod:
-		if (sym_is_choice_value(sym) && sym->visible == yes)
-			return false;
-		return type == S_TRISTATE;
-	case yes:
-		return type == S_BOOLEAN || sym->visible == yes;
-	}
-	return false;
+	if (type == S_BOOLEAN && val == mod)
+		return false;
+	if (sym->visible <= sym->rev_dep.tri)
+		return false;
+	if (sym_is_choice_value(sym) && sym->visible == yes)
+		return val == yes;
+	return val >= sym->rev_dep.tri && val <= sym->visible;
 }
 
 bool sym_set_tristate_value(struct symbol *sym, tristate val)
@@ -351,16 +370,16 @@ bool sym_set_tristate_value(struct symbol *sym, tristate val)
 
 	if (sym->flags & SYMBOL_NEW) {
 		sym->flags &= ~SYMBOL_NEW;
-		sym->flags |= SYMBOL_CHANGED;
+		sym_set_changed(sym);
 	}
 	if (sym_is_choice_value(sym) && val == yes) {
-		struct property *prop = sym_get_choice_prop(sym);
+		struct symbol *cs = prop_get_symbol(sym_get_choice_prop(sym));
 
-		S_VAL(prop->def->def) = sym;
-		prop->def->flags &= ~SYMBOL_NEW;
+		cs->user.val = sym;
+		cs->flags &= ~SYMBOL_NEW;
 	}
 
-	S_TRI(sym->def) = val;
+	sym->user.tri = val;
 	if (oldval != val) {
 		sym_clear_all_valid();
 		if (sym == modules_sym)
@@ -404,12 +423,12 @@ bool sym_string_valid(struct symbol *sym, const char *str)
 		ch = *str++;
 		if (ch == '-')
 			ch = *str++;
-		if (!isdigit((int)ch))
+		if (!isdigit(ch))
 			return false;
 		if (ch == '0' && *str != 0)
 			return false;
 		while ((ch = *str++)) {
-			if (!isdigit((int)ch))
+			if (!isdigit(ch))
 				return false;
 		}
 		return true;
@@ -418,21 +437,58 @@ bool sym_string_valid(struct symbol *sym, const char *str)
 			str += 2;
 		ch = *str++;
 		do {
-			if (!isxdigit((int)ch))
+			if (!isxdigit(ch))
 				return false;
 		} while ((ch = *str++));
 		return true;
 	case S_BOOLEAN:
 	case S_TRISTATE:
 		switch (str[0]) {
-		case 'y':
-		case 'Y':
+		case 'y': case 'Y':
+		case 'm': case 'M':
+		case 'n': case 'N':
+			return true;
+		}
+		return false;
+	default:
+		return false;
+	}
+}
+
+bool sym_string_within_range(struct symbol *sym, const char *str)
+{
+	struct property *prop;
+	int val;
+
+	switch (sym->type) {
+	case S_STRING:
+		return sym_string_valid(sym, str);
+	case S_INT:
+		if (!sym_string_valid(sym, str))
+			return false;
+		prop = sym_get_range_prop(sym);
+		if (!prop)
+			return true;
+		val = strtol(str, NULL, 10);
+		return val >= strtol(prop->expr->left.sym->name, NULL, 10) &&
+		       val <= strtol(prop->expr->right.sym->name, NULL, 10);
+	case S_HEX:
+		if (!sym_string_valid(sym, str))
+			return false;
+		prop = sym_get_range_prop(sym);
+		if (!prop)
+			return true;
+		val = strtol(str, NULL, 16);
+		return val >= strtol(prop->expr->left.sym->name, NULL, 16) &&
+		       val <= strtol(prop->expr->right.sym->name, NULL, 16);
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		switch (str[0]) {
+		case 'y': case 'Y':
 			return sym_tristate_within_range(sym, yes);
-		case 'm':
-		case 'M':
+		case 'm': case 'M':
 			return sym_tristate_within_range(sym, mod);
-		case 'n':
-		case 'N':
+		case 'n': case 'N':
 			return sym_tristate_within_range(sym, no);
 		}
 		return false;
@@ -451,14 +507,11 @@ bool sym_set_string_value(struct symbol *sym, const char *newval)
 	case S_BOOLEAN:
 	case S_TRISTATE:
 		switch (newval[0]) {
-		case 'y':
-		case 'Y':
+		case 'y': case 'Y':
 			return sym_set_tristate_value(sym, yes);
-		case 'm':
-		case 'M':
+		case 'm': case 'M':
 			return sym_set_tristate_value(sym, mod);
-		case 'n':
-		case 'N':
+		case 'n': case 'N':
 			return sym_set_tristate_value(sym, no);
 		}
 		return false;
@@ -466,23 +519,23 @@ bool sym_set_string_value(struct symbol *sym, const char *newval)
 		;
 	}
 
-	if (!sym_string_valid(sym, newval))
+	if (!sym_string_within_range(sym, newval))
 		return false;
 
 	if (sym->flags & SYMBOL_NEW) {
 		sym->flags &= ~SYMBOL_NEW;
-		sym->flags |= SYMBOL_CHANGED;
+		sym_set_changed(sym);
 	}
 
-	oldval = S_VAL(sym->def);
+	oldval = sym->user.val;
 	size = strlen(newval) + 1;
 	if (sym->type == S_HEX && (newval[0] != '0' || (newval[1] != 'x' && newval[1] != 'X'))) {
 		size += 2;
-		S_VAL(sym->def) = val = malloc(size);
+		sym->user.val = val = malloc(size);
 		*val++ = '0';
 		*val++ = 'x';
 	} else if (!oldval || strcmp(oldval, newval))
-		S_VAL(sym->def) = val = malloc(size);
+		sym->user.val = val = malloc(size);
 	else
 		return true;
 
@@ -513,20 +566,12 @@ const char *sym_get_string_value(struct symbol *sym)
 	default:
 		;
 	}
-	return (const char *)S_VAL(sym->curr);
+	return (const char *)sym->curr.val;
 }
 
 bool sym_is_changable(struct symbol *sym)
 {
-	if (sym->visible == no)
-		return false;
-	/* at least 'n' and 'y'/'m' is selectable */
-	if (sym_is_optional(sym))
-		return true;
-	/* no 'n', so 'y' and 'm' must be selectable */
-	if (sym_get_type(sym) == S_TRISTATE && sym->visible == yes)
-		return true;
-	return false;
+	return sym->visible > sym->rev_dep.tri;
 }
 
 struct symbol *sym_lookup(const char *name, int isconst)
@@ -536,7 +581,6 @@ struct symbol *sym_lookup(const char *name, int isconst)
 	char *new_name;
 	int hash = 0;
 
-	//printf("lookup: %s -> ", name);
 	if (name) {
 		if (name[0] && !name[1]) {
 			switch (name[0]) {
@@ -552,10 +596,8 @@ struct symbol *sym_lookup(const char *name, int isconst)
 		for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
 			if (!strcmp(symbol->name, name)) {
 				if ((isconst && symbol->flags & SYMBOL_CONST) ||
-				    (!isconst && !(symbol->flags & SYMBOL_CONST))) {
-					//printf("h:%p\n", symbol);
+				    (!isconst && !(symbol->flags & SYMBOL_CONST)))
 					return symbol;
-				}
 			}
 		}
 		new_name = strdup(name);
@@ -575,7 +617,6 @@ struct symbol *sym_lookup(const char *name, int isconst)
 	symbol->next = symbol_hash[hash];
 	symbol_hash[hash] = symbol;
 
-	//printf("n:%p\n", symbol);
 	return symbol;
 }
 
@@ -608,6 +649,104 @@ struct symbol *sym_find(const char *name)
 	return symbol;
 }
 
+struct symbol *sym_check_deps(struct symbol *sym);
+
+static struct symbol *sym_check_expr_deps(struct expr *e)
+{
+	struct symbol *sym;
+
+	if (!e)
+		return NULL;
+	switch (e->type) {
+	case E_OR:
+	case E_AND:
+		sym = sym_check_expr_deps(e->left.expr);
+		if (sym)
+			return sym;
+		return sym_check_expr_deps(e->right.expr);
+	case E_NOT:
+		return sym_check_expr_deps(e->left.expr);
+	case E_EQUAL:
+	case E_UNEQUAL:
+		sym = sym_check_deps(e->left.sym);
+		if (sym)
+			return sym;
+		return sym_check_deps(e->right.sym);
+	case E_SYMBOL:
+		return sym_check_deps(e->left.sym);
+	default:
+		break;
+	}
+	printf("Oops! How to check %d?\n", e->type);
+	return NULL;
+}
+
+struct symbol *sym_check_deps(struct symbol *sym)
+{
+	struct symbol *sym2;
+	struct property *prop;
+
+	if (sym->flags & SYMBOL_CHECK_DONE)
+		return NULL;
+	if (sym->flags & SYMBOL_CHECK) {
+		printf("Warning! Found recursive dependency: %s", sym->name);
+		return sym;
+	}
+
+	sym->flags |= (SYMBOL_CHECK | SYMBOL_CHECKED);
+	sym2 = sym_check_expr_deps(sym->rev_dep.expr);
+	if (sym2)
+		goto out;
+
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->type == P_CHOICE)
+			continue;
+		sym2 = sym_check_expr_deps(prop->visible.expr);
+		if (sym2)
+			goto out;
+		if (prop->type != P_DEFAULT || sym_is_choice(sym))
+			continue;
+		sym2 = sym_check_expr_deps(prop->expr);
+		if (sym2)
+			goto out;
+	}
+out:
+	if (sym2)
+		printf(" %s", sym->name);
+	sym->flags &= ~SYMBOL_CHECK;
+	return sym2;
+}
+
+struct property *prop_alloc(enum prop_type type, struct symbol *sym)
+{
+	struct property *prop;
+	struct property **propp;
+
+	prop = malloc(sizeof(*prop));
+	memset(prop, 0, sizeof(*prop));
+	prop->type = type;
+	prop->sym = sym;
+	prop->file = current_file;
+	prop->lineno = zconf_lineno();
+
+	/* append property to the prop list of symbol */
+	if (sym) {
+		for (propp = &sym->prop; *propp; propp = &(*propp)->next)
+			;
+		*propp = prop;
+	}
+
+	return prop;
+}
+
+struct symbol *prop_get_symbol(struct property *prop)
+{
+	if (prop->expr && (prop->expr->type == E_SYMBOL ||
+			   prop->expr->type == E_CHOICE))
+		return prop->expr->left.sym;
+	return NULL;
+}
+
 const char *prop_get_type_name(enum prop_type type)
 {
 	switch (type) {
@@ -617,13 +756,16 @@ const char *prop_get_type_name(enum prop_type type)
 		return "comment";
 	case P_MENU:
 		return "menu";
-	case P_ROOTMENU:
-		return "rootmenu";
 	case P_DEFAULT:
 		return "default";
 	case P_CHOICE:
 		return "choice";
-	default:
-		return "unknown";
+	case P_SELECT:
+		return "select";
+	case P_RANGE:
+		return "range";
+	case P_UNKNOWN:
+		break;
 	}
+	return "unknown";
 }
diff --git a/scripts/config/zconf.l b/scripts/config/zconf.l
index a412bf411..55517b287 100644
--- a/scripts/config/zconf.l
+++ b/scripts/config/zconf.l
@@ -7,6 +7,7 @@
  * Released under the terms of the GNU GPL v2.0.
  */
 
+#include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -14,7 +15,6 @@
 
 #define LKC_DIRECT_LINK
 #include "lkc.h"
-#include "zconf.tab.h"
 
 #define START_STRSIZE	16
 
@@ -96,6 +96,7 @@ n	[A-Za-z0-9_]
 	"endchoice"		BEGIN(PARAM); return T_ENDCHOICE;
 	"comment"		BEGIN(PARAM); return T_COMMENT;
 	"config"		BEGIN(PARAM); return T_CONFIG;
+	"menuconfig"		BEGIN(PARAM); return T_MENUCONFIG;
 	"help"			BEGIN(PARAM); return T_HELP;
 	"if"			BEGIN(PARAM); return T_IF;
 	"endif"			BEGIN(PARAM); return T_ENDIF;
@@ -105,11 +106,17 @@ n	[A-Za-z0-9_]
 	"default"		BEGIN(PARAM); return T_DEFAULT;
 	"prompt"		BEGIN(PARAM); return T_PROMPT;
 	"tristate"		BEGIN(PARAM); return T_TRISTATE;
+	"def_tristate"		BEGIN(PARAM); return T_DEF_TRISTATE;
 	"bool"			BEGIN(PARAM); return T_BOOLEAN;
 	"boolean"		BEGIN(PARAM); return T_BOOLEAN;
+	"def_bool"		BEGIN(PARAM); return T_DEF_BOOLEAN;
+	"def_boolean"		BEGIN(PARAM); return T_DEF_BOOLEAN;
 	"int"			BEGIN(PARAM); return T_INT;
 	"hex"			BEGIN(PARAM); return T_HEX;
 	"string"		BEGIN(PARAM); return T_STRING;
+	"select"		BEGIN(PARAM); return T_SELECT;
+	"enable"		BEGIN(PARAM); return T_SELECT;
+	"range"			BEGIN(PARAM); return T_RANGE;
 	{n}+	{
 		alloc_string(yytext, yyleng);
 		zconflval.string = text;
@@ -141,6 +148,8 @@ n	[A-Za-z0-9_]
 		zconflval.string = text;
 		return T_WORD;
 	}
+	#.*	/* comment */
+	\\\n	current_file->lineno++;
 	.
 	<<EOF>> {
 		BEGIN(INITIAL);
@@ -151,29 +160,30 @@ n	[A-Za-z0-9_]
 	[^'"\\\n]+/\n	{
 		append_string(yytext, yyleng);
 		zconflval.string = text;
-		return T_STRING;
+		return T_WORD_QUOTE;
 	}
 	[^'"\\\n]+	{
 		append_string(yytext, yyleng);
 	}
 	\\.?/\n	{
-		append_string(yytext+1, yyleng);
+		append_string(yytext + 1, yyleng - 1);
 		zconflval.string = text;
-		return T_STRING;
+		return T_WORD_QUOTE;
 	}
 	\\.?	{
-		append_string(yytext+1, yyleng);
+		append_string(yytext + 1, yyleng - 1);
 	}
 	\'|\"	{
 		if (str == yytext[0]) {
 			BEGIN(PARAM);
 			zconflval.string = text;
-			return T_STRING;
+			return T_WORD_QUOTE;
 		} else
 			append_string(yytext, 1);
 	}
 	\n	{
 		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
 		BEGIN(INITIAL);
 		return T_EOL;
 	}
@@ -204,9 +214,8 @@ n	[A-Za-z0-9_]
 			}
 			append_string("        ", ts);
 		}
-		
 	}
-	\n/[^ \t\n] {
+	[ \t]*\n/[^ \t\n] {
 		current_file->lineno++;
 		zconf_endhelp();
 		return T_HELPTEXT;
@@ -246,12 +255,37 @@ void zconf_starthelp(void)
 static void zconf_endhelp(void)
 {
 	zconflval.string = text;
-	BEGIN(INITIAL); 
+	BEGIN(INITIAL);
+}
+
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
 }
 
 void zconf_initscan(const char *name)
 {
-	yyin = fopen(name, "r");
+	yyin = zconf_fopen(name);
 	if (!yyin) {
 		printf("can't find file %s\n", name);
 		exit(1);
@@ -272,7 +306,7 @@ void zconf_nextfile(const char *name)
 	memset(buf, 0, sizeof(*buf));
 
 	current_buf->state = YY_CURRENT_BUFFER;
-	yyin = fopen(name, "r");
+	yyin = zconf_fopen(name);
 	if (!yyin) {
 		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
 		exit(1);
@@ -318,7 +352,7 @@ static struct buffer *zconf_endfile(void)
 int zconf_lineno(void)
 {
 	if (current_buf)
-		return current_file->lineno;
+		return current_file->lineno - 1;
 	else
 		return 0;
 }
diff --git a/scripts/config/zconf.tab.c_shipped b/scripts/config/zconf.tab.c_shipped
index 33b2b6f84..c9bfdb451 100644
--- a/scripts/config/zconf.tab.c_shipped
+++ b/scripts/config/zconf.tab.c_shipped
@@ -1,7 +1,7 @@
-/* A Bison parser, made from zconf.y, by GNU bison 1.75.  */
+/* A Bison parser, made by GNU Bison 1.875a.  */
 
 /* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -34,10 +34,13 @@
    USER NAME SPACE" below.  */
 
 /* Identify Bison output.  */
-#define YYBISON	1
+#define YYBISON 1
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
 
 /* Pure parsers.  */
-#define YYPURE	0
+#define YYPURE 0
 
 /* Using locations.  */
 #define YYLSP_NEEDED 0
@@ -67,31 +70,37 @@
      T_ENDCHOICE = 263,
      T_COMMENT = 264,
      T_CONFIG = 265,
-     T_HELP = 266,
-     T_HELPTEXT = 267,
-     T_IF = 268,
-     T_ENDIF = 269,
-     T_DEPENDS = 270,
-     T_REQUIRES = 271,
-     T_OPTIONAL = 272,
-     T_PROMPT = 273,
-     T_DEFAULT = 274,
-     T_TRISTATE = 275,
-     T_BOOLEAN = 276,
-     T_INT = 277,
-     T_HEX = 278,
-     T_WORD = 279,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_REQUIRES = 272,
+     T_OPTIONAL = 273,
+     T_PROMPT = 274,
+     T_DEFAULT = 275,
+     T_TRISTATE = 276,
+     T_DEF_TRISTATE = 277,
+     T_BOOLEAN = 278,
+     T_DEF_BOOLEAN = 279,
      T_STRING = 280,
-     T_UNEQUAL = 281,
-     T_EOF = 282,
-     T_EOL = 283,
-     T_CLOSE_PAREN = 284,
-     T_OPEN_PAREN = 285,
-     T_ON = 286,
-     T_OR = 287,
-     T_AND = 288,
-     T_EQUAL = 289,
-     T_NOT = 290
+     T_INT = 281,
+     T_HEX = 282,
+     T_WORD = 283,
+     T_WORD_QUOTE = 284,
+     T_UNEQUAL = 285,
+     T_EOF = 286,
+     T_EOL = 287,
+     T_CLOSE_PAREN = 288,
+     T_OPEN_PAREN = 289,
+     T_ON = 290,
+     T_SELECT = 291,
+     T_RANGE = 292,
+     T_OR = 293,
+     T_AND = 294,
+     T_EQUAL = 295,
+     T_NOT = 296
    };
 #endif
 #define T_MAINMENU 258
@@ -102,37 +111,43 @@
 #define T_ENDCHOICE 263
 #define T_COMMENT 264
 #define T_CONFIG 265
-#define T_HELP 266
-#define T_HELPTEXT 267
-#define T_IF 268
-#define T_ENDIF 269
-#define T_DEPENDS 270
-#define T_REQUIRES 271
-#define T_OPTIONAL 272
-#define T_PROMPT 273
-#define T_DEFAULT 274
-#define T_TRISTATE 275
-#define T_BOOLEAN 276
-#define T_INT 277
-#define T_HEX 278
-#define T_WORD 279
+#define T_MENUCONFIG 266
+#define T_HELP 267
+#define T_HELPTEXT 268
+#define T_IF 269
+#define T_ENDIF 270
+#define T_DEPENDS 271
+#define T_REQUIRES 272
+#define T_OPTIONAL 273
+#define T_PROMPT 274
+#define T_DEFAULT 275
+#define T_TRISTATE 276
+#define T_DEF_TRISTATE 277
+#define T_BOOLEAN 278
+#define T_DEF_BOOLEAN 279
 #define T_STRING 280
-#define T_UNEQUAL 281
-#define T_EOF 282
-#define T_EOL 283
-#define T_CLOSE_PAREN 284
-#define T_OPEN_PAREN 285
-#define T_ON 286
-#define T_OR 287
-#define T_AND 288
-#define T_EQUAL 289
-#define T_NOT 290
+#define T_INT 281
+#define T_HEX 282
+#define T_WORD 283
+#define T_WORD_QUOTE 284
+#define T_UNEQUAL 285
+#define T_EOF 286
+#define T_EOL 287
+#define T_CLOSE_PAREN 288
+#define T_OPEN_PAREN 289
+#define T_ON 290
+#define T_SELECT 291
+#define T_RANGE 292
+#define T_OR 293
+#define T_AND 294
+#define T_EQUAL 295
+#define T_NOT 296
 
 
 
 
 /* Copy the first part of user declarations.  */
-#line 1 "zconf.y"
+
 
 /*
  * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
@@ -165,7 +180,7 @@ struct symbol *symbol_hash[257];
 
 /* Enabling traces.  */
 #ifndef YYDEBUG
-# define YYDEBUG 1
+# define YYDEBUG 0
 #endif
 
 /* Enabling verbose error messages.  */
@@ -176,42 +191,33 @@ struct symbol *symbol_hash[257];
 # define YYERROR_VERBOSE 0
 #endif
 
-#ifndef YYSTYPE
-#line 33 "zconf.y"
-typedef union {
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+
+typedef union YYSTYPE {
 	int token;
 	char *string;
 	struct symbol *symbol;
 	struct expr *expr;
 	struct menu *menu;
-} yystype;
-/* Line 193 of /usr/share/bison/yacc.c.  */
-#line 190 "zconf.tab.c"
-# define YYSTYPE yystype
+} YYSTYPE;
+/* Line 191 of yacc.c.  */
+
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
 #endif
 
-#ifndef YYLTYPE
-typedef struct yyltype
-{
-  int first_line;
-  int first_column;
-  int last_line;
-  int last_column;
-} yyltype;
-# define YYLTYPE yyltype
-# define YYLTYPE_IS_TRIVIAL 1
-#endif
+
 
 /* Copy the second part of user declarations.  */
-#line 83 "zconf.y"
+
 
 #define LKC_DIRECT_LINK
 #include "lkc.h"
 
 
-/* Line 213 of /usr/share/bison/yacc.c.  */
-#line 215 "zconf.tab.c"
+/* Line 214 of yacc.c.  */
+
 
 #if ! defined (yyoverflow) || YYERROR_VERBOSE
 
@@ -247,7 +253,7 @@ typedef struct yyltype
 
 #if (! defined (yyoverflow) \
      && (! defined (__cplusplus) \
-	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+	 || (YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
@@ -257,13 +263,13 @@ union yyalloc
   };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
 
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
      ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAX)
+      + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
@@ -277,7 +283,7 @@ union yyalloc
 	{					\
 	  register YYSIZE_T yyi;		\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];	\
+	    (To)[yyi] = (From)[yyi];		\
 	}					\
       while (0)
 #  endif
@@ -294,7 +300,7 @@ union yyalloc
 	YYSIZE_T yynewbytes;						\
 	YYCOPY (&yyptr->Stack, Stack, yysize);				\
 	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
     while (0)
@@ -309,23 +315,24 @@ union yyalloc
 
 /* YYFINAL -- State number of the termination state. */
 #define YYFINAL  2
-#define YYLAST   151
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   201
 
 /* YYNTOKENS -- Number of terminals. */
-#define YYNTOKENS  36
+#define YYNTOKENS  42
 /* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  39
+#define YYNNTS  41
 /* YYNRULES -- Number of rules. */
-#define YYNRULES  96
+#define YYNRULES  104
 /* YYNRULES -- Number of states. */
-#define YYNSTATES  145
+#define YYNSTATES  182
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
-#define YYMAXUTOK   290
+#define YYMAXUTOK   296
 
-#define YYTRANSLATE(X) \
-  ((unsigned)(X) <= YYMAXUTOK ? yytranslate[X] : YYUNDEFTOK)
+#define YYTRANSLATE(YYX) 						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
 static const unsigned char yytranslate[] =
@@ -359,7 +366,7 @@ static const unsigned char yytranslate[] =
        5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
       15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
       25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      35
+      35,    36,    37,    38,    39,    40,    41
 };
 
 #if YYDEBUG
@@ -368,63 +375,69 @@ static const unsigned char yytranslate[] =
 static const unsigned short yyprhs[] =
 {
        0,     0,     3,     4,     7,     9,    11,    13,    17,    19,
-      21,    23,    26,    28,    30,    32,    34,    36,    39,    43,
-      44,    48,    52,    55,    58,    61,    64,    67,    70,    73,
-      77,    81,    83,    87,    89,    94,    97,    98,   102,   106,
-     109,   112,   116,   118,   121,   122,   125,   128,   130,   136,
-     140,   141,   144,   147,   150,   153,   157,   159,   164,   167,
-     168,   171,   174,   177,   181,   184,   187,   190,   194,   197,
-     200,   201,   205,   208,   212,   215,   218,   219,   221,   225,
-     227,   229,   231,   233,   235,   237,   239,   240,   243,   245,
-     249,   253,   257,   260,   264,   268,   270
+      21,    23,    26,    28,    30,    32,    34,    36,    38,    42,
+      45,    49,    52,    53,    56,    59,    62,    65,    69,    74,
+      78,    83,    87,    91,    95,   100,   105,   110,   116,   119,
+     122,   124,   128,   131,   132,   135,   138,   141,   144,   149,
+     153,   157,   160,   165,   166,   169,   173,   175,   179,   182,
+     183,   186,   189,   192,   196,   199,   201,   205,   208,   209,
+     212,   215,   218,   222,   226,   228,   232,   235,   238,   241,
+     242,   245,   248,   253,   257,   261,   262,   265,   267,   269,
+     272,   275,   278,   280,   282,   283,   286,   288,   292,   296,
+     300,   303,   307,   311,   313
 };
 
 /* YYRHS -- A `-1'-separated list of the rules' RHS. */
 static const yysigned_char yyrhs[] =
 {
-      37,     0,    -1,    -1,    37,    38,    -1,    39,    -1,    47,
-      -1,    58,    -1,     3,    69,    71,    -1,     5,    -1,    14,
-      -1,     8,    -1,     1,    71,    -1,    53,    -1,    63,    -1,
-      41,    -1,    61,    -1,    71,    -1,    10,    24,    -1,    40,
-      28,    42,    -1,    -1,    42,    43,    28,    -1,    42,    67,
-      28,    -1,    42,    65,    -1,    42,    28,    -1,    20,    68,
-      -1,    21,    68,    -1,    22,    68,    -1,    23,    68,    -1,
-      25,    68,    -1,    18,    69,    72,    -1,    19,    74,    72,
-      -1,     7,    -1,    44,    28,    48,    -1,    70,    -1,    45,
-      50,    46,    28,    -1,    45,    50,    -1,    -1,    48,    49,
-      28,    -1,    48,    67,    28,    -1,    48,    65,    -1,    48,
-      28,    -1,    18,    69,    72,    -1,    17,    -1,    19,    74,
-      -1,    -1,    50,    39,    -1,    13,    73,    -1,    70,    -1,
-      51,    28,    54,    52,    28,    -1,    51,    28,    54,    -1,
-      -1,    54,    39,    -1,    54,    58,    -1,    54,    47,    -1,
-       4,    69,    -1,    55,    28,    66,    -1,    70,    -1,    56,
-      59,    57,    28,    -1,    56,    59,    -1,    -1,    59,    39,
-      -1,    59,    58,    -1,    59,    47,    -1,    59,     1,    28,
-      -1,     6,    69,    -1,    60,    28,    -1,     9,    69,    -1,
-      62,    28,    66,    -1,    11,    28,    -1,    64,    12,    -1,
-      -1,    66,    67,    28,    -1,    66,    28,    -1,    15,    31,
-      73,    -1,    15,    73,    -1,    16,    73,    -1,    -1,    69,
-      -1,    69,    13,    73,    -1,    24,    -1,    25,    -1,     5,
-      -1,     8,    -1,    14,    -1,    28,    -1,    27,    -1,    -1,
-      13,    73,    -1,    74,    -1,    74,    34,    74,    -1,    74,
-      26,    74,    -1,    30,    73,    29,    -1,    35,    73,    -1,
-      73,    32,    73,    -1,    73,    33,    73,    -1,    24,    -1,
-      25,    -1
+      43,     0,    -1,    -1,    43,    44,    -1,    45,    -1,    55,
+      -1,    66,    -1,     3,    77,    79,    -1,     5,    -1,    15,
+      -1,     8,    -1,     1,    79,    -1,    61,    -1,    71,    -1,
+      47,    -1,    49,    -1,    69,    -1,    79,    -1,    10,    28,
+      32,    -1,    46,    50,    -1,    11,    28,    32,    -1,    48,
+      50,    -1,    -1,    50,    51,    -1,    50,    75,    -1,    50,
+      73,    -1,    50,    32,    -1,    21,    76,    32,    -1,    22,
+      81,    80,    32,    -1,    23,    76,    32,    -1,    24,    81,
+      80,    32,    -1,    26,    76,    32,    -1,    27,    76,    32,
+      -1,    25,    76,    32,    -1,    19,    77,    80,    32,    -1,
+      20,    81,    80,    32,    -1,    36,    28,    80,    32,    -1,
+      37,    82,    82,    80,    32,    -1,     7,    32,    -1,    52,
+      56,    -1,    78,    -1,    53,    58,    54,    -1,    53,    58,
+      -1,    -1,    56,    57,    -1,    56,    75,    -1,    56,    73,
+      -1,    56,    32,    -1,    19,    77,    80,    32,    -1,    21,
+      76,    32,    -1,    23,    76,    32,    -1,    18,    32,    -1,
+      20,    28,    80,    32,    -1,    -1,    58,    45,    -1,    14,
+      81,    32,    -1,    78,    -1,    59,    62,    60,    -1,    59,
+      62,    -1,    -1,    62,    45,    -1,    62,    66,    -1,    62,
+      55,    -1,     4,    77,    32,    -1,    63,    74,    -1,    78,
+      -1,    64,    67,    65,    -1,    64,    67,    -1,    -1,    67,
+      45,    -1,    67,    66,    -1,    67,    55,    -1,    67,     1,
+      32,    -1,     6,    77,    32,    -1,    68,    -1,     9,    77,
+      32,    -1,    70,    74,    -1,    12,    32,    -1,    72,    13,
+      -1,    -1,    74,    75,    -1,    74,    32,    -1,    16,    35,
+      81,    32,    -1,    16,    81,    32,    -1,    17,    81,    32,
+      -1,    -1,    77,    80,    -1,    28,    -1,    29,    -1,     5,
+      79,    -1,     8,    79,    -1,    15,    79,    -1,    32,    -1,
+      31,    -1,    -1,    14,    81,    -1,    82,    -1,    82,    40,
+      82,    -1,    82,    30,    82,    -1,    34,    81,    33,    -1,
+      41,    81,    -1,    81,    38,    81,    -1,    81,    39,    81,
+      -1,    28,    -1,    29,    -1
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
 static const unsigned short yyrline[] =
 {
-       0,    88,    88,    89,    92,    93,    94,    95,    96,    97,
-      98,    99,   102,   104,   105,   106,   107,   113,   121,   127,
-     129,   130,   131,   132,   135,   141,   147,   153,   159,   165,
-     171,   179,   188,   194,   202,   204,   210,   212,   213,   214,
-     215,   218,   224,   230,   237,   239,   244,   254,   262,   264,
-     270,   272,   273,   274,   279,   286,   292,   300,   302,   308,
-     310,   311,   312,   313,   316,   322,   329,   336,   343,   349,
-     356,   357,   358,   361,   366,   371,   379,   381,   385,   390,
-     391,   394,   395,   396,   399,   400,   402,   403,   406,   407,
-     408,   409,   410,   411,   412,   415,   416
+       0,    94,    94,    95,    98,    99,   100,   101,   102,   103,
+     104,   105,   109,   110,   111,   112,   113,   114,   120,   128,
+     134,   142,   152,   154,   155,   156,   157,   160,   166,   173,
+     179,   186,   192,   198,   204,   210,   216,   222,   230,   239,
+     245,   254,   255,   261,   263,   264,   265,   266,   269,   275,
+     281,   287,   293,   299,   301,   306,   315,   324,   325,   331,
+     333,   334,   335,   340,   347,   353,   362,   363,   369,   371,
+     372,   373,   374,   377,   383,   390,   397,   404,   410,   417,
+     418,   419,   422,   427,   432,   440,   442,   447,   448,   451,
+     452,   453,   457,   457,   459,   460,   463,   464,   465,   466,
+     467,   468,   469,   472,   473
 };
 #endif
 
@@ -435,12 +448,14 @@ static const char *const yytname[] =
 {
   "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU", 
   "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG", 
-  "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS", "T_REQUIRES", 
-  "T_OPTIONAL", "T_PROMPT", "T_DEFAULT", "T_TRISTATE", "T_BOOLEAN", 
-  "T_INT", "T_HEX", "T_WORD", "T_STRING", "T_UNEQUAL", "T_EOF", "T_EOL", 
-  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_ON", "T_OR", "T_AND", "T_EQUAL", 
-  "T_NOT", "$accept", "input", "block", "common_block", 
-  "config_entry_start", "config_stmt", "config_option_list", 
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS", 
+  "T_REQUIRES", "T_OPTIONAL", "T_PROMPT", "T_DEFAULT", "T_TRISTATE", 
+  "T_DEF_TRISTATE", "T_BOOLEAN", "T_DEF_BOOLEAN", "T_STRING", "T_INT", 
+  "T_HEX", "T_WORD", "T_WORD_QUOTE", "T_UNEQUAL", "T_EOF", "T_EOL", 
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_ON", "T_SELECT", "T_RANGE", "T_OR", 
+  "T_AND", "T_EQUAL", "T_NOT", "$accept", "input", "block", 
+  "common_block", "config_entry_start", "config_stmt", 
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list", 
   "config_option", "choice", "choice_entry", "choice_end", "choice_stmt", 
   "choice_option_list", "choice_option", "choice_block", "if", "if_end", 
   "if_stmt", "if_block", "menu", "menu_entry", "menu_end", "menu_stmt", 
@@ -458,38 +473,41 @@ static const unsigned short yytoknum[] =
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
      275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296
 };
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
 static const unsigned char yyr1[] =
 {
-       0,    36,    37,    37,    38,    38,    38,    38,    38,    38,
-      38,    38,    39,    39,    39,    39,    39,    40,    41,    42,
-      42,    42,    42,    42,    43,    43,    43,    43,    43,    43,
-      43,    44,    45,    46,    47,    47,    48,    48,    48,    48,
-      48,    49,    49,    49,    50,    50,    51,    52,    53,    53,
-      54,    54,    54,    54,    55,    56,    57,    58,    58,    59,
-      59,    59,    59,    59,    60,    61,    62,    63,    64,    65,
-      66,    66,    66,    67,    67,    67,    68,    68,    68,    69,
-      69,    70,    70,    70,    71,    71,    72,    72,    73,    73,
-      73,    73,    73,    73,    73,    74,    74
+       0,    42,    43,    43,    44,    44,    44,    44,    44,    44,
+      44,    44,    45,    45,    45,    45,    45,    45,    46,    47,
+      48,    49,    50,    50,    50,    50,    50,    51,    51,    51,
+      51,    51,    51,    51,    51,    51,    51,    51,    52,    53,
+      54,    55,    55,    56,    56,    56,    56,    56,    57,    57,
+      57,    57,    57,    58,    58,    59,    60,    61,    61,    62,
+      62,    62,    62,    63,    64,    65,    66,    66,    67,    67,
+      67,    67,    67,    68,    69,    70,    71,    72,    73,    74,
+      74,    74,    75,    75,    75,    76,    76,    77,    77,    78,
+      78,    78,    79,    79,    80,    80,    81,    81,    81,    81,
+      81,    81,    81,    82,    82
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
 static const unsigned char yyr2[] =
 {
        0,     2,     0,     2,     1,     1,     1,     3,     1,     1,
-       1,     2,     1,     1,     1,     1,     1,     2,     3,     0,
-       3,     3,     2,     2,     2,     2,     2,     2,     2,     3,
-       3,     1,     3,     1,     4,     2,     0,     3,     3,     2,
-       2,     3,     1,     2,     0,     2,     2,     1,     5,     3,
-       0,     2,     2,     2,     2,     3,     1,     4,     2,     0,
-       2,     2,     2,     3,     2,     2,     2,     3,     2,     2,
-       0,     3,     2,     3,     2,     2,     0,     1,     3,     1,
-       1,     1,     1,     1,     1,     1,     0,     2,     1,     3,
-       3,     3,     2,     3,     3,     1,     1
+       1,     2,     1,     1,     1,     1,     1,     1,     3,     2,
+       3,     2,     0,     2,     2,     2,     2,     3,     4,     3,
+       4,     3,     3,     3,     4,     4,     4,     5,     2,     2,
+       1,     3,     2,     0,     2,     2,     2,     2,     4,     3,
+       3,     2,     4,     0,     2,     3,     1,     3,     2,     0,
+       2,     2,     2,     3,     2,     1,     3,     2,     0,     2,
+       2,     2,     3,     3,     1,     3,     2,     2,     2,     0,
+       2,     2,     4,     3,     3,     0,     2,     1,     1,     2,
+       2,     2,     1,     1,     0,     2,     1,     3,     3,     3,
+       2,     3,     3,     1,     1
 };
 
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
@@ -497,127 +515,151 @@ static const unsigned char yyr2[] =
    means the default is an error.  */
 static const unsigned char yydefact[] =
 {
-       2,     0,     1,     0,     0,     0,     8,     0,    31,    10,
-       0,     0,     0,     9,    85,    84,     3,     4,     0,    14,
-       0,    44,     5,     0,    12,     0,    59,     6,     0,    15,
-       0,    13,    16,    11,    79,    80,     0,    54,    64,    66,
-      17,    95,    96,     0,     0,    46,    88,    19,    36,    35,
-      50,    70,     0,    65,    70,     7,     0,    92,     0,     0,
-       0,     0,    18,    32,    81,    82,    83,    45,     0,    33,
-      49,    55,     0,    60,    62,     0,    61,    56,    67,    91,
-      93,    94,    90,    89,     0,     0,     0,     0,     0,    76,
-      76,    76,    76,    76,    23,     0,     0,    22,     0,    42,
-       0,     0,    40,     0,    39,     0,    34,    51,    53,     0,
-      52,    47,    72,     0,    63,    57,    68,     0,    74,    75,
-      86,    86,    24,    77,    25,    26,    27,    28,    20,    69,
-      21,    86,    43,    37,    38,    48,    71,    73,     0,    29,
-      30,     0,    41,    87,    78
+       2,     0,     1,     0,     0,     0,     8,     0,     0,    10,
+       0,     0,     0,     0,     9,    93,    92,     3,     4,    22,
+      14,    22,    15,    43,    53,     5,    59,    12,    79,    68,
+       6,    74,    16,    79,    13,    17,    11,    87,    88,     0,
+       0,     0,    38,     0,     0,     0,   103,   104,     0,     0,
+       0,    96,    19,    21,    39,    42,    58,    64,     0,    76,
+       7,    63,    73,    75,    18,    20,     0,   100,    55,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    85,     0,
+      85,     0,    85,    85,    85,    26,     0,     0,    23,     0,
+      25,    24,     0,     0,     0,    85,    85,    47,    44,    46,
+      45,     0,     0,     0,    54,    41,    40,    60,    62,    57,
+      61,    56,    81,    80,     0,    69,    71,    66,    70,    65,
+      99,   101,   102,    98,    97,    77,     0,     0,     0,    94,
+      94,     0,    94,    94,     0,    94,     0,     0,     0,    94,
+       0,    78,    51,    94,    94,     0,     0,    89,    90,    91,
+      72,     0,    83,    84,     0,     0,     0,    27,    86,     0,
+      29,     0,    33,    31,    32,     0,    94,     0,     0,    49,
+      50,    82,    95,    34,    35,    28,    30,    36,     0,    48,
+      52,    37
 };
 
 /* YYDEFGOTO[NTERM-NUM]. */
 static const short yydefgoto[] =
 {
-      -1,     1,    16,    17,    18,    19,    62,    95,    20,    21,
-      68,    22,    63,   103,    49,    23,   109,    24,    70,    25,
-      26,    75,    27,    52,    28,    29,    30,    31,    96,    97,
-      71,   113,   122,   123,    69,    32,   139,    45,    46
+      -1,     1,    17,    18,    19,    20,    21,    22,    52,    88,
+      23,    24,   105,    25,    54,    98,    55,    26,   109,    27,
+      56,    28,    29,   117,    30,    58,    31,    32,    33,    34,
+      89,    90,    57,    91,   131,   132,   106,    35,   155,    50,
+      51
 };
 
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
-#define YYPACT_NINF -120
+#define YYPACT_NINF -99
 static const short yypact[] =
 {
-    -120,    17,  -120,    41,    48,    48,  -120,    48,  -120,  -120,
-      48,   -11,    40,  -120,  -120,  -120,  -120,  -120,    13,  -120,
-      23,  -120,  -120,    66,  -120,    72,  -120,  -120,    77,  -120,
-      81,  -120,  -120,  -120,  -120,  -120,    41,  -120,  -120,  -120,
-    -120,  -120,  -120,    40,    40,    57,    59,  -120,  -120,    98,
-    -120,  -120,    49,  -120,  -120,  -120,     7,  -120,    40,    40,
-      67,    67,    99,   117,  -120,  -120,  -120,  -120,    85,  -120,
-      74,    18,    88,  -120,  -120,    95,  -120,  -120,    18,  -120,
-      96,  -120,  -120,  -120,   102,    36,    40,    48,    67,    48,
-      48,    48,    48,    48,  -120,   103,   129,  -120,   114,  -120,
-      48,    67,  -120,   115,  -120,   116,  -120,  -120,  -120,   118,
-    -120,  -120,  -120,   119,  -120,  -120,  -120,    40,    57,    57,
-     135,   135,  -120,   136,  -120,  -120,  -120,  -120,  -120,  -120,
-    -120,   135,  -120,  -120,  -120,  -120,  -120,    57,    40,  -120,
-    -120,    40,  -120,    57,    57
+     -99,    48,   -99,    38,    46,    46,   -99,    46,   -29,   -99,
+      46,   -17,    -3,   -11,   -99,   -99,   -99,   -99,   -99,   -99,
+     -99,   -99,   -99,   -99,   -99,   -99,   -99,   -99,   -99,   -99,
+     -99,   -99,   -99,   -99,   -99,   -99,   -99,   -99,   -99,    38,
+      12,    15,   -99,    18,    51,    62,   -99,   -99,   -11,   -11,
+       4,   -24,   138,   138,   160,   121,   110,    -4,    81,    -4,
+     -99,   -99,   -99,   -99,   -99,   -99,   -19,   -99,   -99,   -11,
+     -11,    70,    70,    73,    32,   -11,    46,   -11,    46,   -11,
+      46,   -11,    46,    46,    46,   -99,    36,    70,   -99,    95,
+     -99,   -99,    96,    46,   106,    46,    46,   -99,   -99,   -99,
+     -99,    38,    38,    38,   -99,   -99,   -99,   -99,   -99,   -99,
+     -99,   -99,   -99,   -99,   112,   -99,   -99,   -99,   -99,   -99,
+     -99,   117,   -99,   -99,   -99,   -99,   -11,    33,    65,   131,
+       1,   119,   131,     1,   136,     1,   153,   154,   155,   131,
+      70,   -99,   -99,   131,   131,   156,   157,   -99,   -99,   -99,
+     -99,   101,   -99,   -99,   -11,   158,   159,   -99,   -99,   161,
+     -99,   162,   -99,   -99,   -99,   163,   131,   164,   165,   -99,
+     -99,   -99,    99,   -99,   -99,   -99,   -99,   -99,   166,   -99,
+     -99,   -99
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
+static const short yypgoto[] =
 {
-    -120,  -120,  -120,   -38,  -120,  -120,  -120,  -120,  -120,  -120,
-    -120,   -42,  -120,  -120,  -120,  -120,  -120,  -120,  -120,  -120,
-    -120,  -120,   -33,  -120,  -120,  -120,  -120,  -120,  -120,    87,
-      97,    34,    47,    -1,   -23,     2,  -119,   -43,   -53
+     -99,   -99,   -99,   111,   -99,   -99,   -99,   -99,   178,   -99,
+     -99,   -99,   -99,    91,   -99,   -99,   -99,   -99,   -99,   -99,
+     -99,   -99,   -99,   -99,   115,   -99,   -99,   -99,   -99,   -99,
+     -99,   146,   168,    89,    27,     0,   126,    -1,   -98,   -48,
+     -63
 };
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
    number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, parse error.  */
-#define YYTABLE_NINF -59
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -68
 static const short yytable[] =
 {
-      56,    57,   140,    36,    37,    33,    38,    82,    83,    39,
-      74,    67,   142,    40,    73,    80,    81,     2,     3,    76,
-       4,     5,     6,     7,     8,     9,    10,    11,   108,    77,
-      12,    13,   107,    85,    86,   121,    79,   110,    55,    58,
-      59,    47,   118,   119,    14,    15,   112,   111,   132,   -58,
-      72,    48,   -58,     5,    64,     7,     8,    65,    10,    11,
-      41,    42,    12,    66,    41,    42,    43,   117,    14,    15,
-      43,    44,    34,    35,   137,    44,    14,    15,     5,    64,
-       7,     8,    65,    10,    11,    60,   120,    12,    66,    58,
-      59,    41,    42,    61,    50,   143,    98,   105,   144,   131,
-      51,    14,    15,    64,     7,    53,    65,    10,    11,    54,
-      84,    12,    66,   106,    85,    86,   114,    87,    88,    89,
-      90,    91,    92,   115,    93,    14,    15,    94,    84,    59,
-     116,   128,    85,    86,    99,   100,   101,   124,   125,   126,
-     127,   129,   130,   133,   134,   102,   135,   136,   138,   141,
-     104,    78
+      66,    67,    36,    42,    39,    40,    71,    41,   123,   124,
+      43,    44,    74,    75,   120,   154,    72,    46,    47,    69,
+      70,   121,   122,    48,   140,    45,   127,   128,   112,   130,
+      49,   133,   156,   135,   158,   159,    68,   161,    60,    69,
+      70,   165,    69,    70,    61,   167,   168,    62,     2,     3,
+      63,     4,     5,     6,     7,     8,     9,    10,    11,    12,
+      46,    47,    13,    14,   139,   152,    48,   126,   178,    15,
+      16,    69,    70,    49,    37,    38,   129,   166,   151,    15,
+      16,   -67,   114,    64,   -67,     5,   101,     7,     8,   102,
+      10,    11,    12,   143,    65,    13,   103,   153,    46,    47,
+     147,   148,   149,    69,    70,   125,   172,   134,   141,   136,
+     137,   138,    15,    16,     5,   101,     7,     8,   102,    10,
+      11,    12,   145,   146,    13,   103,   101,     7,   142,   102,
+      10,    11,    12,   171,   144,    13,   103,    69,    70,    69,
+      70,    15,    16,   100,   150,   154,   113,   108,   113,   116,
+      73,   157,    15,    16,    74,    75,    70,    76,    77,    78,
+      79,    80,    81,    82,    83,    84,   104,   107,   160,   115,
+      85,   110,    73,   118,    86,    87,    74,    75,    92,    93,
+      94,    95,   111,    96,   119,   162,   163,   164,   169,   170,
+     173,   174,    97,   175,   176,   177,   179,   180,   181,    53,
+      99,    59
 };
 
 static const unsigned char yycheck[] =
 {
-      43,    44,   121,     4,     5,     3,     7,    60,    61,    10,
-      52,    49,   131,    24,    52,    58,    59,     0,     1,    52,
-       3,     4,     5,     6,     7,     8,     9,    10,    70,    52,
-      13,    14,    70,    15,    16,    88,    29,    70,    36,    32,
-      33,    28,    85,    86,    27,    28,    28,    70,   101,     0,
-       1,    28,     3,     4,     5,     6,     7,     8,     9,    10,
-      24,    25,    13,    14,    24,    25,    30,    31,    27,    28,
-      30,    35,    24,    25,   117,    35,    27,    28,     4,     5,
-       6,     7,     8,     9,    10,    26,    87,    13,    14,    32,
-      33,    24,    25,    34,    28,   138,    62,    63,   141,   100,
-      28,    27,    28,     5,     6,    28,     8,     9,    10,    28,
-      11,    13,    14,    28,    15,    16,    28,    18,    19,    20,
-      21,    22,    23,    28,    25,    27,    28,    28,    11,    33,
-      28,    28,    15,    16,    17,    18,    19,    90,    91,    92,
-      93,    12,    28,    28,    28,    28,    28,    28,    13,    13,
-      63,    54
+      48,    49,     3,    32,     4,     5,    30,     7,    71,    72,
+      10,    28,    16,    17,    33,    14,    40,    28,    29,    38,
+      39,    69,    70,    34,    87,    28,    74,    75,    32,    77,
+      41,    79,   130,    81,   132,   133,    32,   135,    39,    38,
+      39,   139,    38,    39,    32,   143,   144,    32,     0,     1,
+      32,     3,     4,     5,     6,     7,     8,     9,    10,    11,
+      28,    29,    14,    15,    28,    32,    34,    35,   166,    31,
+      32,    38,    39,    41,    28,    29,    76,   140,   126,    31,
+      32,     0,     1,    32,     3,     4,     5,     6,     7,     8,
+       9,    10,    11,    93,    32,    14,    15,    32,    28,    29,
+     101,   102,   103,    38,    39,    32,   154,    80,    13,    82,
+      83,    84,    31,    32,     4,     5,     6,     7,     8,     9,
+      10,    11,    95,    96,    14,    15,     5,     6,    32,     8,
+       9,    10,    11,    32,    28,    14,    15,    38,    39,    38,
+      39,    31,    32,    54,    32,    14,    57,    56,    59,    58,
+      12,    32,    31,    32,    16,    17,    39,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    55,    56,    32,    58,
+      32,    56,    12,    58,    36,    37,    16,    17,    18,    19,
+      20,    21,    56,    23,    58,    32,    32,    32,    32,    32,
+      32,    32,    32,    32,    32,    32,    32,    32,    32,    21,
+      54,    33
 };
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
 static const unsigned char yystos[] =
 {
-       0,    37,     0,     1,     3,     4,     5,     6,     7,     8,
-       9,    10,    13,    14,    27,    28,    38,    39,    40,    41,
-      44,    45,    47,    51,    53,    55,    56,    58,    60,    61,
-      62,    63,    71,    71,    24,    25,    69,    69,    69,    69,
-      24,    24,    25,    30,    35,    73,    74,    28,    28,    50,
-      28,    28,    59,    28,    28,    71,    73,    73,    32,    33,
-      26,    34,    42,    48,     5,     8,    14,    39,    46,    70,
-      54,    66,     1,    39,    47,    57,    58,    70,    66,    29,
-      73,    73,    74,    74,    11,    15,    16,    18,    19,    20,
-      21,    22,    23,    25,    28,    43,    64,    65,    67,    17,
-      18,    19,    28,    49,    65,    67,    28,    39,    47,    52,
-      58,    70,    28,    67,    28,    28,    28,    31,    73,    73,
-      69,    74,    68,    69,    68,    68,    68,    68,    28,    12,
-      28,    69,    74,    28,    28,    28,    28,    73,    13,    72,
-      72,    13,    72,    73,    73
+       0,    43,     0,     1,     3,     4,     5,     6,     7,     8,
+       9,    10,    11,    14,    15,    31,    32,    44,    45,    46,
+      47,    48,    49,    52,    53,    55,    59,    61,    63,    64,
+      66,    68,    69,    70,    71,    79,    79,    28,    29,    77,
+      77,    77,    32,    77,    28,    28,    28,    29,    34,    41,
+      81,    82,    50,    50,    56,    58,    62,    74,    67,    74,
+      79,    32,    32,    32,    32,    32,    81,    81,    32,    38,
+      39,    30,    40,    12,    16,    17,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    32,    36,    37,    51,    72,
+      73,    75,    18,    19,    20,    21,    23,    32,    57,    73,
+      75,     5,     8,    15,    45,    54,    78,    45,    55,    60,
+      66,    78,    32,    75,     1,    45,    55,    65,    66,    78,
+      33,    81,    81,    82,    82,    32,    35,    81,    81,    77,
+      81,    76,    77,    81,    76,    81,    76,    76,    76,    28,
+      82,    13,    32,    77,    28,    76,    76,    79,    79,    79,
+      32,    81,    32,    32,    14,    80,    80,    32,    80,    80,
+      32,    80,    32,    32,    32,    80,    82,    80,    80,    32,
+      32,    32,    81,    32,    32,    32,    32,    32,    80,    32,
+      32,    32
 };
 
 #if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
@@ -638,13 +680,14 @@ static const unsigned char yystos[] =
 
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
+#define YYEMPTY		(-2)
 #define YYEOF		0
 
 #define YYACCEPT	goto yyacceptlab
 #define YYABORT		goto yyabortlab
 #define YYERROR		goto yyerrlab1
 
+
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
    Once GCC version 2 has supplanted version 1, this can go.  */
@@ -659,13 +702,13 @@ do								\
     {								\
       yychar = (Token);						\
       yylval = (Value);						\
-      yychar1 = YYTRANSLATE (yychar);				\
+      yytoken = YYTRANSLATE (yychar);				\
       YYPOPSTACK;						\
       goto yybackup;						\
     }								\
   else								\
     { 								\
-      yyerror ("syntax error: cannot back up");			\
+      yyerror ("syntax error: cannot back up");\
       YYERROR;							\
     }								\
 while (0)
@@ -677,7 +720,7 @@ while (0)
    are run).  */
 
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)           \
+# define YYLLOC_DEFAULT(Current, Rhs, N)         \
   Current.first_line   = Rhs[1].first_line;      \
   Current.first_column = Rhs[1].first_column;    \
   Current.last_line    = Rhs[N].last_line;       \
@@ -686,7 +729,11 @@ while (0)
 
 /* YYLEX -- calling `yylex' with the right arguments.  */
 
-#define YYLEX	yylex ()
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
 
 /* Enable debugging if requested.  */
 #if YYDEBUG
@@ -701,19 +748,93 @@ do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
 } while (0)
+
 # define YYDSYMPRINT(Args)			\
 do {						\
   if (yydebug)					\
     yysymprint Args;				\
 } while (0)
+
+# define YYDSYMPRINTF(Title, Token, Value, Location)		\
+do {								\
+  if (yydebug)							\
+    {								\
+      YYFPRINTF (stderr, "%s ", Title);				\
+      yysymprint (stderr, 					\
+                  Token, Value);	\
+      YYFPRINTF (stderr, "\n");					\
+    }								\
+} while (0)
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (cinluded).                                                   |
+`------------------------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_stack_print (short *bottom, short *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    short *bottom;
+    short *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (/* Nothing. */; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_reduce_print (int yyrule)
+#else
+static void
+yy_reduce_print (yyrule)
+    int yyrule;
+#endif
+{
+  int yyi;
+  unsigned int yylineno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
+             yyrule - 1, yylineno);
+  /* Print the symbols being reduced, and their result.  */
+  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
+    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
+  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (Rule);		\
+} while (0)
+
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
 # define YYDSYMPRINT(Args)
+# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
 
+
 /* YYINITDEPTH -- initial size of the parser's stacks.  */
 #ifndef	YYINITDEPTH
 # define YYINITDEPTH 200
@@ -792,95 +913,85 @@ yystpcpy (yydest, yysrc)
 
 
 #if YYDEBUG
-/*-----------------------------.
-| Print this symbol on YYOUT.  |
-`-----------------------------*/
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
 
-static void
 #if defined (__STDC__) || defined (__cplusplus)
-yysymprint (FILE* yyout, int yytype, YYSTYPE yyvalue)
+static void
+yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
 #else
-yysymprint (yyout, yytype, yyvalue)
-    FILE* yyout;
+static void
+yysymprint (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
     int yytype;
-    YYSTYPE yyvalue;
+    YYSTYPE *yyvaluep;
 #endif
 {
   /* Pacify ``unused variable'' warnings.  */
-  (void) yyvalue;
+  (void) yyvaluep;
 
   if (yytype < YYNTOKENS)
     {
-      YYFPRINTF (yyout, "token %s (", yytname[yytype]);
+      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
 # ifdef YYPRINT
-      YYPRINT (yyout, yytoknum[yytype], yyvalue);
+      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
 # endif
     }
   else
-    YYFPRINTF (yyout, "nterm %s (", yytname[yytype]);
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
 
   switch (yytype)
     {
       default:
         break;
     }
-  YYFPRINTF (yyout, ")");
+  YYFPRINTF (yyoutput, ")");
 }
-#endif /* YYDEBUG. */
-
 
+#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-static void
 #if defined (__STDC__) || defined (__cplusplus)
-yydestruct (int yytype, YYSTYPE yyvalue)
+static void
+yydestruct (int yytype, YYSTYPE *yyvaluep)
 #else
-yydestruct (yytype, yyvalue)
+static void
+yydestruct (yytype, yyvaluep)
     int yytype;
-    YYSTYPE yyvalue;
+    YYSTYPE *yyvaluep;
 #endif
 {
   /* Pacify ``unused variable'' warnings.  */
-  (void) yyvalue;
+  (void) yyvaluep;
 
   switch (yytype)
     {
+
       default:
         break;
     }
 }
-
 
 
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
+/* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
 # if defined (__STDC__) || defined (__cplusplus)
-#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL
+int yyparse (void *YYPARSE_PARAM);
 # else
-#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+int yyparse ();
 # endif
-#else /* !YYPARSE_PARAM */
-# define YYPARSE_PARAM_ARG
-# define YYPARSE_PARAM_DECL
-#endif /* !YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-# ifdef YYPARSE_PARAM
-int yyparse (void *);
-# else
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
 int yyparse (void);
-# endif
+#else
+int yyparse ();
 #endif
+#endif /* ! YYPARSE_PARAM */
+
 
 
 /* The lookahead symbol.  */
@@ -889,13 +1000,32 @@ int yychar;
 /* The semantic value of the lookahead symbol.  */
 YYSTYPE yylval;
 
-/* Number of parse errors so far.  */
+/* Number of syntax errors so far.  */
 int yynerrs;
 
 
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM)
+# else
+int yyparse (YYPARSE_PARAM)
+  void *YYPARSE_PARAM;
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
 int
-yyparse (YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
 {
   
   register int yystate;
@@ -904,7 +1034,7 @@ yyparse (YYPARSE_PARAM_ARG)
   /* Number of tokens to shift before error messages enabled.  */
   int yyerrstatus;
   /* Lookahead token as an internal (translated) token number.  */
-  int yychar1 = 0;
+  int yytoken = 0;
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -968,7 +1098,7 @@ yyparse (YYPARSE_PARAM_ARG)
  yysetstate:
   *yyssp = yystate;
 
-  if (yyssp >= yyss + yystacksize - 1)
+  if (yyss + yystacksize - 1 <= yyssp)
     {
       /* Get the current used size of the three stacks, in elements.  */
       YYSIZE_T yysize = yyssp - yyss + 1;
@@ -1000,10 +1130,10 @@ yyparse (YYPARSE_PARAM_ARG)
       goto yyoverflowlab;
 # else
       /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
+      if (YYMAXDEPTH <= yystacksize)
 	goto yyoverflowlab;
       yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
+      if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
@@ -1029,7 +1159,7 @@ yyparse (YYPARSE_PARAM_ARG)
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
-      if (yyssp >= yyss + yystacksize - 1)
+      if (yyss + yystacksize - 1 <= yyssp)
 	YYABORT;
     }
 
@@ -1054,39 +1184,28 @@ yybackup:
 
   /* Not known => get a lookahead token if don't already have one.  */
 
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
       yychar = YYLEX;
     }
 
-  /* Convert token to internal form (in yychar1) for indexing tables with.  */
-
-  if (yychar <= 0)		/* This means end of input.  */
+  if (yychar <= YYEOF)
     {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more.  */
-
+      yychar = yytoken = YYEOF;
       YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
   else
     {
-      yychar1 = YYTRANSLATE (yychar);
-
-      /* We have to keep this `#if YYDEBUG', since we use variables
-	 which are defined only if `YYDEBUG' is set.  */
-      YYDPRINTF ((stderr, "Next token is "));
-      YYDSYMPRINT ((stderr, yychar1, yylval));
-      YYDPRINTF ((stderr, "\n"));
+      yytoken = YYTRANSLATE (yychar);
+      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
     }
 
-  /* If the proper action on seeing token YYCHAR1 is to reduce or to
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
      detect an error, take that action.  */
-  yyn += yychar1;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yychar1)
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
   yyn = yytable[yyn];
   if (yyn <= 0)
@@ -1101,8 +1220,7 @@ yybackup:
     YYACCEPT;
 
   /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
-	      yychar, yytname[yychar1]));
+  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
 
   /* Discard the token being shifted unless it is eof.  */
   if (yychar != YYEOF)
@@ -1148,435 +1266,463 @@ yyreduce:
   yyval = yyvsp[1-yylen];
 
 
-
-#if YYDEBUG
-  /* We have to keep this `#if YYDEBUG', since we use variables which
-     are defined only if `YYDEBUG' is set.  */
-  if (yydebug)
-    {
-      int yyi;
-
-      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
-		 yyn - 1, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (yyi = yyprhs[yyn]; yyrhs[yyi] >= 0; yyi++)
-	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
-      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
+  YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
         case 8:
-#line 96 "zconf.y"
-    { zconfprint("unexpected 'endmenu' statement"); }
+
+    { zconfprint("unexpected 'endmenu' statement"); ;}
     break;
 
   case 9:
-#line 97 "zconf.y"
-    { zconfprint("unexpected 'endif' statement"); }
+
+    { zconfprint("unexpected 'endif' statement"); ;}
     break;
 
   case 10:
-#line 98 "zconf.y"
-    { zconfprint("unexpected 'endchoice' statement"); }
+
+    { zconfprint("unexpected 'endchoice' statement"); ;}
     break;
 
   case 11:
-#line 99 "zconf.y"
-    { zconfprint("syntax error"); yyerrok; }
+
+    { zconfprint("syntax error"); yyerrok; ;}
     break;
 
-  case 17:
-#line 114 "zconf.y"
+  case 18:
+
     {
-	struct symbol *sym = sym_lookup(yyvsp[0].string, 0);
+	struct symbol *sym = sym_lookup(yyvsp[-1].string, 0);
 	sym->flags |= SYMBOL_OPTIONAL;
 	menu_add_entry(sym);
-	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), yyvsp[0].string);
-}
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), yyvsp[-1].string);
+;}
     break;
 
-  case 18:
-#line 122 "zconf.y"
+  case 19:
+
     {
 	menu_end_entry();
 	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
-}
+;}
+    break;
+
+  case 20:
+
+    {
+	struct symbol *sym = sym_lookup(yyvsp[-1].string, 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), yyvsp[-1].string);
+;}
     break;
 
-  case 23:
-#line 133 "zconf.y"
-    { }
+  case 21:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
     break;
 
-  case 24:
-#line 136 "zconf.y"
+  case 27:
+
     {
 	menu_set_type(S_TRISTATE);
 	printd(DEBUG_PARSE, "%s:%d:tristate\n", zconf_curname(), zconf_lineno());
-}
+;}
+    break;
+
+  case 28:
+
+    {
+	menu_add_expr(P_DEFAULT, yyvsp[-2].expr, yyvsp[-1].expr);
+	menu_set_type(S_TRISTATE);
+	printd(DEBUG_PARSE, "%s:%d:def_boolean\n", zconf_curname(), zconf_lineno());
+;}
     break;
 
-  case 25:
-#line 142 "zconf.y"
+  case 29:
+
     {
 	menu_set_type(S_BOOLEAN);
 	printd(DEBUG_PARSE, "%s:%d:boolean\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 26:
-#line 148 "zconf.y"
+  case 30:
+
+    {
+	menu_add_expr(P_DEFAULT, yyvsp[-2].expr, yyvsp[-1].expr);
+	menu_set_type(S_BOOLEAN);
+	printd(DEBUG_PARSE, "%s:%d:def_boolean\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 31:
+
     {
 	menu_set_type(S_INT);
 	printd(DEBUG_PARSE, "%s:%d:int\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 27:
-#line 154 "zconf.y"
+  case 32:
+
     {
 	menu_set_type(S_HEX);
 	printd(DEBUG_PARSE, "%s:%d:hex\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 28:
-#line 160 "zconf.y"
+  case 33:
+
     {
 	menu_set_type(S_STRING);
 	printd(DEBUG_PARSE, "%s:%d:string\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 29:
-#line 166 "zconf.y"
+  case 34:
+
     {
-	menu_add_prop(P_PROMPT, yyvsp[-1].string, NULL, yyvsp[0].expr);
+	menu_add_prompt(P_PROMPT, yyvsp[-2].string, yyvsp[-1].expr);
 	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 30:
-#line 172 "zconf.y"
+  case 35:
+
     {
-	menu_add_prop(P_DEFAULT, NULL, yyvsp[-1].symbol, yyvsp[0].expr);
+	menu_add_expr(P_DEFAULT, yyvsp[-2].expr, yyvsp[-1].expr);
 	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 31:
-#line 180 "zconf.y"
+  case 36:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup(yyvsp[-2].string, 0), yyvsp[-1].expr);
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 37:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,yyvsp[-3].symbol, yyvsp[-2].symbol), yyvsp[-1].expr);
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 38:
+
     {
 	struct symbol *sym = sym_lookup(NULL, 0);
 	sym->flags |= SYMBOL_CHOICE;
 	menu_add_entry(sym);
-	menu_add_prop(P_CHOICE, NULL, NULL, NULL);
+	menu_add_expr(P_CHOICE, NULL, NULL);
 	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 32:
-#line 189 "zconf.y"
+  case 39:
+
     {
 	menu_end_entry();
 	menu_add_menu();
-}
+;}
     break;
 
-  case 33:
-#line 195 "zconf.y"
+  case 40:
+
     {
 	if (zconf_endtoken(yyvsp[0].token, T_CHOICE, T_ENDCHOICE)) {
 		menu_end_menu();
 		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
 	}
-}
+;}
     break;
 
-  case 35:
-#line 205 "zconf.y"
+  case 42:
+
     {
 	printf("%s:%d: missing 'endchoice' for this 'choice' statement\n", current_menu->file->name, current_menu->lineno);
 	zconfnerrs++;
-}
+;}
     break;
 
-  case 41:
-#line 219 "zconf.y"
+  case 48:
+
     {
-	menu_add_prop(P_PROMPT, yyvsp[-1].string, NULL, yyvsp[0].expr);
+	menu_add_prompt(P_PROMPT, yyvsp[-2].string, yyvsp[-1].expr);
 	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 42:
-#line 225 "zconf.y"
+  case 49:
+
+    {
+	menu_set_type(S_TRISTATE);
+	printd(DEBUG_PARSE, "%s:%d:tristate\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 50:
+
+    {
+	menu_set_type(S_BOOLEAN);
+	printd(DEBUG_PARSE, "%s:%d:boolean\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 51:
+
     {
 	current_entry->sym->flags |= SYMBOL_OPTIONAL;
 	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 43:
-#line 231 "zconf.y"
+  case 52:
+
     {
-	menu_add_prop(P_DEFAULT, NULL, yyvsp[0].symbol, NULL);
-	//current_choice->prop->def = ;
+	menu_add_symbol(P_DEFAULT, sym_lookup(yyvsp[-2].string, 0), yyvsp[-1].expr);
 	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 46:
-#line 245 "zconf.y"
+  case 55:
+
     {
 	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
 	menu_add_entry(NULL);
-	//current_entry->prompt = menu_add_prop(T_IF, NULL, NULL, );
-	menu_add_dep(yyvsp[0].expr);
+	menu_add_dep(yyvsp[-1].expr);
 	menu_end_entry();
 	menu_add_menu();
-}
+;}
     break;
 
-  case 47:
-#line 255 "zconf.y"
+  case 56:
+
     {
 	if (zconf_endtoken(yyvsp[0].token, T_IF, T_ENDIF)) {
 		menu_end_menu();
 		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
 	}
-}
+;}
     break;
 
-  case 49:
-#line 265 "zconf.y"
+  case 58:
+
     {
 	printf("%s:%d: missing 'endif' for this 'if' statement\n", current_menu->file->name, current_menu->lineno);
 	zconfnerrs++;
-}
+;}
     break;
 
-  case 54:
-#line 280 "zconf.y"
+  case 63:
+
     {
 	menu_add_entry(NULL);
-	menu_add_prop(P_MENU, yyvsp[0].string, NULL, NULL);
+	menu_add_prop(P_MENU, yyvsp[-1].string, NULL, NULL);
 	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 55:
-#line 287 "zconf.y"
+  case 64:
+
     {
 	menu_end_entry();
 	menu_add_menu();
-}
+;}
     break;
 
-  case 56:
-#line 293 "zconf.y"
+  case 65:
+
     {
 	if (zconf_endtoken(yyvsp[0].token, T_MENU, T_ENDMENU)) {
 		menu_end_menu();
 		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
 	}
-}
+;}
     break;
 
-  case 58:
-#line 303 "zconf.y"
+  case 67:
+
     {
 	printf("%s:%d: missing 'endmenu' for this 'menu' statement\n", current_menu->file->name, current_menu->lineno);
 	zconfnerrs++;
-}
+;}
     break;
 
-  case 63:
-#line 313 "zconf.y"
-    { zconfprint("invalid menu option"); yyerrok; }
+  case 72:
+
+    { zconfprint("invalid menu option"); yyerrok; ;}
     break;
 
-  case 64:
-#line 317 "zconf.y"
+  case 73:
+
     {
-	yyval.string = yyvsp[0].string;
-	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), yyvsp[0].string);
-}
+	yyval.string = yyvsp[-1].string;
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), yyvsp[-1].string);
+;}
     break;
 
-  case 65:
-#line 323 "zconf.y"
+  case 74:
+
     {
-	zconf_nextfile(yyvsp[-1].string);
-}
+	zconf_nextfile(yyvsp[0].string);
+;}
     break;
 
-  case 66:
-#line 330 "zconf.y"
+  case 75:
+
     {
 	menu_add_entry(NULL);
-	menu_add_prop(P_COMMENT, yyvsp[0].string, NULL, NULL);
+	menu_add_prop(P_COMMENT, yyvsp[-1].string, NULL, NULL);
 	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 67:
-#line 337 "zconf.y"
+  case 76:
+
     {
 	menu_end_entry();
-}
+;}
     break;
 
-  case 68:
-#line 344 "zconf.y"
+  case 77:
+
     {
 	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
 	zconf_starthelp();
-}
+;}
     break;
 
-  case 69:
-#line 350 "zconf.y"
+  case 78:
+
     {
 	current_entry->sym->help = yyvsp[0].string;
-}
+;}
     break;
 
-  case 72:
-#line 359 "zconf.y"
-    { }
-    break;
+  case 82:
 
-  case 73:
-#line 362 "zconf.y"
     {
-	menu_add_dep(yyvsp[0].expr);
+	menu_add_dep(yyvsp[-1].expr);
 	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 74:
-#line 367 "zconf.y"
+  case 83:
+
     {
-	menu_add_dep(yyvsp[0].expr);
+	menu_add_dep(yyvsp[-1].expr);
 	printd(DEBUG_PARSE, "%s:%d:depends\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 75:
-#line 372 "zconf.y"
+  case 84:
+
     {
-	menu_add_dep(yyvsp[0].expr);
+	menu_add_dep(yyvsp[-1].expr);
 	printd(DEBUG_PARSE, "%s:%d:requires\n", zconf_curname(), zconf_lineno());
-}
+;}
     break;
 
-  case 77:
-#line 382 "zconf.y"
-    {
-	menu_add_prop(P_PROMPT, yyvsp[0].string, NULL, NULL);
-}
-    break;
+  case 86:
 
-  case 78:
-#line 386 "zconf.y"
     {
-	menu_add_prop(P_PROMPT, yyvsp[-2].string, NULL, yyvsp[0].expr);
-}
+	menu_add_prop(P_PROMPT, yyvsp[-1].string, NULL, yyvsp[0].expr);
+;}
     break;
 
-  case 81:
-#line 394 "zconf.y"
-    { yyval.token = T_ENDMENU; }
+  case 89:
+
+    { yyval.token = T_ENDMENU; ;}
     break;
 
-  case 82:
-#line 395 "zconf.y"
-    { yyval.token = T_ENDCHOICE; }
+  case 90:
+
+    { yyval.token = T_ENDCHOICE; ;}
     break;
 
-  case 83:
-#line 396 "zconf.y"
-    { yyval.token = T_ENDIF; }
+  case 91:
+
+    { yyval.token = T_ENDIF; ;}
     break;
 
-  case 86:
-#line 402 "zconf.y"
-    { yyval.expr = NULL; }
+  case 94:
+
+    { yyval.expr = NULL; ;}
     break;
 
-  case 87:
-#line 403 "zconf.y"
-    { yyval.expr = yyvsp[0].expr; }
+  case 95:
+
+    { yyval.expr = yyvsp[0].expr; ;}
     break;
 
-  case 88:
-#line 406 "zconf.y"
-    { yyval.expr = expr_alloc_symbol(yyvsp[0].symbol); }
+  case 96:
+
+    { yyval.expr = expr_alloc_symbol(yyvsp[0].symbol); ;}
     break;
 
-  case 89:
-#line 407 "zconf.y"
-    { yyval.expr = expr_alloc_comp(E_EQUAL, yyvsp[-2].symbol, yyvsp[0].symbol); }
+  case 97:
+
+    { yyval.expr = expr_alloc_comp(E_EQUAL, yyvsp[-2].symbol, yyvsp[0].symbol); ;}
     break;
 
-  case 90:
-#line 408 "zconf.y"
-    { yyval.expr = expr_alloc_comp(E_UNEQUAL, yyvsp[-2].symbol, yyvsp[0].symbol); }
+  case 98:
+
+    { yyval.expr = expr_alloc_comp(E_UNEQUAL, yyvsp[-2].symbol, yyvsp[0].symbol); ;}
     break;
 
-  case 91:
-#line 409 "zconf.y"
-    { yyval.expr = yyvsp[-1].expr; }
+  case 99:
+
+    { yyval.expr = yyvsp[-1].expr; ;}
     break;
 
-  case 92:
-#line 410 "zconf.y"
-    { yyval.expr = expr_alloc_one(E_NOT, yyvsp[0].expr); }
+  case 100:
+
+    { yyval.expr = expr_alloc_one(E_NOT, yyvsp[0].expr); ;}
     break;
 
-  case 93:
-#line 411 "zconf.y"
-    { yyval.expr = expr_alloc_two(E_OR, yyvsp[-2].expr, yyvsp[0].expr); }
+  case 101:
+
+    { yyval.expr = expr_alloc_two(E_OR, yyvsp[-2].expr, yyvsp[0].expr); ;}
     break;
 
-  case 94:
-#line 412 "zconf.y"
-    { yyval.expr = expr_alloc_two(E_AND, yyvsp[-2].expr, yyvsp[0].expr); }
+  case 102:
+
+    { yyval.expr = expr_alloc_two(E_AND, yyvsp[-2].expr, yyvsp[0].expr); ;}
     break;
 
-  case 95:
-#line 415 "zconf.y"
-    { yyval.symbol = sym_lookup(yyvsp[0].string, 0); free(yyvsp[0].string); }
+  case 103:
+
+    { yyval.symbol = sym_lookup(yyvsp[0].string, 0); free(yyvsp[0].string); ;}
     break;
 
-  case 96:
-#line 416 "zconf.y"
-    { yyval.symbol = sym_lookup(yyvsp[0].string, 1); free(yyvsp[0].string); }
+  case 104:
+
+    { yyval.symbol = sym_lookup(yyvsp[0].string, 1); free(yyvsp[0].string); ;}
     break;
 
 
     }
 
-/* Line 1016 of /usr/share/bison/yacc.c.  */
-#line 1565 "zconf.tab.c"
+/* Line 999 of yacc.c.  */
+
 
   yyvsp -= yylen;
   yyssp -= yylen;
 
 
-#if YYDEBUG
-  if (yydebug)
-    {
-      short *yyssp1 = yyss - 1;
-      YYFPRINTF (stderr, "state stack now");
-      while (yyssp1 != yyssp)
-	YYFPRINTF (stderr, " %d", *++yyssp1);
-      YYFPRINTF (stderr, "\n");
-    }
-#endif
+  YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
 
@@ -1621,12 +1767,12 @@ yyerrlab:
 	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
 	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
 	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
-	  yysize += yystrlen ("parse error, unexpected ") + 1;
+	  yysize += yystrlen ("syntax error, unexpected ") + 1;
 	  yysize += yystrlen (yytname[yytype]);
 	  yymsg = (char *) YYSTACK_ALLOC (yysize);
 	  if (yymsg != 0)
 	    {
-	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
+	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
 	      yyp = yystpcpy (yyp, yytname[yytype]);
 
 	      if (yycount < 5)
@@ -1647,19 +1793,15 @@ yyerrlab:
 	      YYSTACK_FREE (yymsg);
 	    }
 	  else
-	    yyerror ("parse error; also virtual memory exhausted");
+	    yyerror ("syntax error; also virtual memory exhausted");
 	}
       else
 #endif /* YYERROR_VERBOSE */
-	yyerror ("parse error");
+	yyerror ("syntax error");
     }
-  goto yyerrlab1;
 
 
-/*----------------------------------------------------.
-| yyerrlab1 -- error raised explicitly by an action.  |
-`----------------------------------------------------*/
-yyerrlab1:
+
   if (yyerrstatus == 3)
     {
       /* If just tried and failed to reuse lookahead token after an
@@ -1671,28 +1813,30 @@ yyerrlab1:
 	  /* Pop the error token.  */
           YYPOPSTACK;
 	  /* Pop the rest of the stack.  */
-	  while (yyssp > yyss)
+	  while (yyss < yyssp)
 	    {
-	      YYDPRINTF ((stderr, "Error: popping "));
-	      YYDSYMPRINT ((stderr,
-			    yystos[*yyssp],
-			    *yyvsp));
-	      YYDPRINTF ((stderr, "\n"));
-	      yydestruct (yystos[*yyssp], *yyvsp);
+	      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
+	      yydestruct (yystos[*yyssp], yyvsp);
 	      YYPOPSTACK;
 	    }
 	  YYABORT;
         }
 
-      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
-		  yychar, yytname[yychar1]));
-      yydestruct (yychar1, yylval);
+      YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
+      yydestruct (yytoken, &yylval);
       yychar = YYEMPTY;
+
     }
 
   /* Else will try to reuse lookahead token after shifting the error
      token.  */
+  goto yyerrlab1;
 
+
+/*----------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action.  |
+`----------------------------------------------------*/
+yyerrlab1:
   yyerrstatus = 3;	/* Each real token shifted decrements this.  */
 
   for (;;)
@@ -1713,26 +1857,12 @@ yyerrlab1:
       if (yyssp == yyss)
 	YYABORT;
 
-      YYDPRINTF ((stderr, "Error: popping "));
-      YYDSYMPRINT ((stderr,
-		    yystos[*yyssp], *yyvsp));
-      YYDPRINTF ((stderr, "\n"));
-
-      yydestruct (yystos[yystate], *yyvsp);
+      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
+      yydestruct (yystos[yystate], yyvsp);
       yyvsp--;
       yystate = *--yyssp;
 
-
-#if YYDEBUG
-      if (yydebug)
-	{
-	  short *yyssp1 = yyss - 1;
-	  YYFPRINTF (stderr, "Error: state stack now");
-	  while (yyssp1 != yyssp)
-	    YYFPRINTF (stderr, " %d", *++yyssp1);
-	  YYFPRINTF (stderr, "\n");
-	}
-#endif
+      YY_STACK_PRINT (yyss, yyssp);
     }
 
   if (yyn == YYFINAL)
@@ -1780,24 +1910,32 @@ yyreturn:
 }
 
 
-#line 419 "zconf.y"
+
 
 
 void conf_parse(const char *name)
 {
+	struct symbol *sym;
+	int i;
+
 	zconf_initscan(name);
 
 	sym_init();
 	menu_init();
-	rootmenu.prompt = menu_add_prop(P_MENU, "BusyBox Configuration", NULL, NULL);
+	modules_sym = sym_lookup("MODULES", 0);
+	rootmenu.prompt = menu_add_prop(P_MENU, "Linux Kernel Configuration", NULL, NULL);
 
 	//zconfdebug = 1;
 	zconfparse();
 	if (zconfnerrs)
 		exit(1);
 	menu_finalize(&rootmenu);
-
-	modules_sym = sym_lookup("MODULES", 0);
+	for_all_symbols(i, sym) {
+                if (!(sym->flags & SYMBOL_CHECKED) && sym_check_deps(sym))
+                        printf("\n");
+		else
+			sym->flags |= SYMBOL_CHECK_DONE;
+        }
 
 	sym_change_count = 1;
 }
@@ -1813,7 +1951,7 @@ const char *zconf_tokenname(int token)
 	case T_ENDIF:		return "endif";
 	}
 	return "<token>";
-} 
+}
 
 static bool zconf_endtoken(int token, int starttoken, int endtoken)
 {
@@ -1835,7 +1973,7 @@ static void zconfprint(const char *err, ...)
 {
 	va_list ap;
 
-	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno() + 1);
 	va_start(ap, err);
 	vfprintf(stderr, err, ap);
 	va_end(ap);
@@ -1844,7 +1982,7 @@ static void zconfprint(const char *err, ...)
 
 static void zconferror(const char *err)
 {
-	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno(), err);
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
 }
 
 void print_quoted_string(FILE *out, const char *str)
@@ -1869,8 +2007,6 @@ void print_symbol(FILE *out, struct menu *menu)
 	struct symbol *sym = menu->sym;
 	struct property *prop;
 
-	//sym->flags |= SYMBOL_PRINTED;
-
 	if (sym_is_choice(sym))
 		fprintf(out, "choice\n");
 	else
@@ -1895,13 +2031,6 @@ void print_symbol(FILE *out, struct menu *menu)
 		fputs("  ???\n", out);
 		break;
 	}
-#if 0
-	if (!expr_is_yes(sym->dep)) {
-		fputs("  depends ", out);
-		expr_fprint(sym->dep, out);
-		fputc('\n', out);
-	}
-#endif
 	for (prop = sym->prop; prop; prop = prop->next) {
 		if (prop->menu != menu)
 			continue;
@@ -1909,25 +2038,18 @@ void print_symbol(FILE *out, struct menu *menu)
 		case P_PROMPT:
 			fputs("  prompt ", out);
 			print_quoted_string(out, prop->text);
-			if (prop->def) {
-				fputc(' ', out);
-				if (prop->def->flags & SYMBOL_CONST)
-					print_quoted_string(out, prop->def->name);
-				else
-					fputs(prop->def->name, out);
-			}
-			if (!expr_is_yes(E_EXPR(prop->visible))) {
+			if (!expr_is_yes(prop->visible.expr)) {
 				fputs(" if ", out);
-				expr_fprint(E_EXPR(prop->visible), out);
+				expr_fprint(prop->visible.expr, out);
 			}
 			fputc('\n', out);
 			break;
 		case P_DEFAULT:
 			fputs( "  default ", out);
-			print_quoted_string(out, prop->def->name);
-			if (!expr_is_yes(E_EXPR(prop->visible))) {
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
 				fputs(" if ", out);
-				expr_fprint(E_EXPR(prop->visible), out);
+				expr_fprint(prop->visible.expr, out);
 			}
 			fputc('\n', out);
 			break;
@@ -1950,7 +2072,6 @@ void print_symbol(FILE *out, struct menu *menu)
 
 void zconfdump(FILE *out)
 {
-	//struct file *file;
 	struct property *prop;
 	struct symbol *sym;
 	struct menu *menu;
@@ -1961,11 +2082,6 @@ void zconfdump(FILE *out)
 			print_symbol(out, menu);
 		else if ((prop = menu->prompt)) {
 			switch (prop->type) {
-			//case T_MAINMENU:
-			//	fputs("\nmainmenu ", out);
-			//	print_quoted_string(out, prop->text);
-			//	fputs("\n", out);
-			//	break;
 			case P_COMMENT:
 				fputs("\ncomment ", out);
 				print_quoted_string(out, prop->text);
@@ -1976,19 +2092,12 @@ void zconfdump(FILE *out)
 				print_quoted_string(out, prop->text);
 				fputs("\n", out);
 				break;
-			//case T_SOURCE:
-			//	fputs("\nsource ", out);
-			//	print_quoted_string(out, prop->text);
-			//	fputs("\n", out);
-			//	break;
-			//case T_IF:
-			//	fputs("\nif\n", out);
 			default:
 				;
 			}
-			if (!expr_is_yes(E_EXPR(prop->visible))) {
+			if (!expr_is_yes(prop->visible.expr)) {
 				fputs("  depends ", out);
-				expr_fprint(E_EXPR(prop->visible), out);
+				expr_fprint(prop->visible.expr, out);
 				fputc('\n', out);
 			}
 			fputs("\n", out);
@@ -2015,3 +2124,4 @@ void zconfdump(FILE *out)
 #include "symbol.c"
 #include "menu.c"
 
+
diff --git a/scripts/config/zconf.y b/scripts/config/zconf.y
index 301d7a896..459b69011 100644
--- a/scripts/config/zconf.y
+++ b/scripts/config/zconf.y
@@ -27,7 +27,7 @@ struct symbol *symbol_hash[257];
 
 #define YYERROR_VERBOSE
 %}
-%expect 36
+%expect 40
 
 %union
 {
@@ -46,6 +46,7 @@ struct symbol *symbol_hash[257];
 %token T_ENDCHOICE
 %token T_COMMENT
 %token T_CONFIG
+%token T_MENUCONFIG
 %token T_HELP
 %token <string> T_HELPTEXT
 %token T_IF
@@ -56,17 +57,22 @@ struct symbol *symbol_hash[257];
 %token T_PROMPT
 %token T_DEFAULT
 %token T_TRISTATE
+%token T_DEF_TRISTATE
 %token T_BOOLEAN
+%token T_DEF_BOOLEAN
+%token T_STRING
 %token T_INT
 %token T_HEX
 %token <string> T_WORD
-%token <string> T_STRING
+%token <string> T_WORD_QUOTE
 %token T_UNEQUAL
 %token T_EOF
 %token T_EOL
 %token T_CLOSE_PAREN
 %token T_OPEN_PAREN
 %token T_ON
+%token T_SELECT
+%token T_RANGE
 
 %left T_OR
 %left T_AND
@@ -103,14 +109,15 @@ common_block:
 	  if_stmt
 	| comment_stmt
 	| config_stmt
+	| menuconfig_stmt
 	| source_stmt
 	| nl_or_eof
 ;
 
 
-/* config entry */
+/* config/menuconfig entry */
 
-config_entry_start: T_CONFIG T_WORD
+config_entry_start: T_CONFIG T_WORD T_EOL
 {
 	struct symbol *sym = sym_lookup($2, 0);
 	sym->flags |= SYMBOL_OPTIONAL;
@@ -118,74 +125,118 @@ config_entry_start: T_CONFIG T_WORD
 	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), $2);
 };
 
-config_stmt: config_entry_start T_EOL config_option_list
+config_stmt: config_entry_start config_option_list
 {
 	menu_end_entry();
 	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
 };
 
+menuconfig_entry_start: T_MENUCONFIG T_WORD T_EOL
+{
+	struct symbol *sym = sym_lookup($2, 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), $2);
+};
+
+menuconfig_stmt: menuconfig_entry_start config_option_list
+{
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+};
+
 config_option_list:
 	  /* empty */
-	| config_option_list config_option T_EOL
-	| config_option_list depends T_EOL
+	| config_option_list config_option
+	| config_option_list depends
 	| config_option_list help
 	| config_option_list T_EOL
-{ };
+;
 
-config_option: T_TRISTATE prompt_stmt_opt
+config_option: T_TRISTATE prompt_stmt_opt T_EOL
 {
 	menu_set_type(S_TRISTATE);
 	printd(DEBUG_PARSE, "%s:%d:tristate\n", zconf_curname(), zconf_lineno());
 };
 
-config_option: T_BOOLEAN prompt_stmt_opt
+config_option: T_DEF_TRISTATE expr if_expr T_EOL
+{
+	menu_add_expr(P_DEFAULT, $2, $3);
+	menu_set_type(S_TRISTATE);
+	printd(DEBUG_PARSE, "%s:%d:def_boolean\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_BOOLEAN prompt_stmt_opt T_EOL
 {
 	menu_set_type(S_BOOLEAN);
 	printd(DEBUG_PARSE, "%s:%d:boolean\n", zconf_curname(), zconf_lineno());
 };
 
-config_option: T_INT prompt_stmt_opt
+config_option: T_DEF_BOOLEAN expr if_expr T_EOL
+{
+	menu_add_expr(P_DEFAULT, $2, $3);
+	menu_set_type(S_BOOLEAN);
+	printd(DEBUG_PARSE, "%s:%d:def_boolean\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_INT prompt_stmt_opt T_EOL
 {
 	menu_set_type(S_INT);
 	printd(DEBUG_PARSE, "%s:%d:int\n", zconf_curname(), zconf_lineno());
 };
 
-config_option: T_HEX prompt_stmt_opt
+config_option: T_HEX prompt_stmt_opt T_EOL
 {
 	menu_set_type(S_HEX);
 	printd(DEBUG_PARSE, "%s:%d:hex\n", zconf_curname(), zconf_lineno());
 };
 
-config_option: T_STRING prompt_stmt_opt
+config_option: T_STRING prompt_stmt_opt T_EOL
 {
 	menu_set_type(S_STRING);
 	printd(DEBUG_PARSE, "%s:%d:string\n", zconf_curname(), zconf_lineno());
 };
 
-config_option: T_PROMPT prompt if_expr
+config_option: T_PROMPT prompt if_expr T_EOL
 {
-	menu_add_prop(P_PROMPT, $2, NULL, $3);
+	menu_add_prompt(P_PROMPT, $2, $3);
 	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
 };
 
-config_option: T_DEFAULT symbol if_expr
+config_option: T_DEFAULT expr if_expr T_EOL
 {
-	menu_add_prop(P_DEFAULT, NULL, $2, $3);
+	menu_add_expr(P_DEFAULT, $2, $3);
 	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
 };
 
+config_option: T_SELECT T_WORD if_expr T_EOL
+{
+	menu_add_symbol(P_SELECT, sym_lookup($2, 0), $3);
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_RANGE symbol symbol if_expr T_EOL
+{
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,$2, $3), $4);
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+};
+
 /* choice entry */
 
-choice: T_CHOICE
+choice: T_CHOICE T_EOL
 {
 	struct symbol *sym = sym_lookup(NULL, 0);
 	sym->flags |= SYMBOL_CHOICE;
 	menu_add_entry(sym);
-	menu_add_prop(P_CHOICE, NULL, NULL, NULL);
+	menu_add_expr(P_CHOICE, NULL, NULL);
 	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
 };
 
-choice_entry: choice T_EOL choice_option_list
+choice_entry: choice choice_option_list
 {
 	menu_end_entry();
 	menu_add_menu();
@@ -200,7 +251,7 @@ choice_end: end
 };
 
 choice_stmt:
-	  choice_entry choice_block choice_end T_EOL
+	  choice_entry choice_block choice_end
 	| choice_entry choice_block
 {
 	printf("%s:%d: missing 'endchoice' for this 'choice' statement\n", current_menu->file->name, current_menu->lineno);
@@ -209,28 +260,39 @@ choice_stmt:
 
 choice_option_list:
 	  /* empty */
-	| choice_option_list choice_option T_EOL
-	| choice_option_list depends T_EOL
+	| choice_option_list choice_option
+	| choice_option_list depends
 	| choice_option_list help
 	| choice_option_list T_EOL
 ;
 
-choice_option: T_PROMPT prompt if_expr
+choice_option: T_PROMPT prompt if_expr T_EOL
 {
-	menu_add_prop(P_PROMPT, $2, NULL, $3);
+	menu_add_prompt(P_PROMPT, $2, $3);
 	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
 };
 
-choice_option: T_OPTIONAL
+choice_option: T_TRISTATE prompt_stmt_opt T_EOL
+{
+	menu_set_type(S_TRISTATE);
+	printd(DEBUG_PARSE, "%s:%d:tristate\n", zconf_curname(), zconf_lineno());
+};
+
+choice_option: T_BOOLEAN prompt_stmt_opt T_EOL
+{
+	menu_set_type(S_BOOLEAN);
+	printd(DEBUG_PARSE, "%s:%d:boolean\n", zconf_curname(), zconf_lineno());
+};
+
+choice_option: T_OPTIONAL T_EOL
 {
 	current_entry->sym->flags |= SYMBOL_OPTIONAL;
 	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
 };
 
-choice_option: T_DEFAULT symbol
+choice_option: T_DEFAULT T_WORD if_expr T_EOL
 {
-	menu_add_prop(P_DEFAULT, NULL, $2, NULL);
-	//current_choice->prop->def = $2;
+	menu_add_symbol(P_DEFAULT, sym_lookup($2, 0), $3);
 	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
 };
 
@@ -241,11 +303,10 @@ choice_block:
 
 /* if entry */
 
-if: T_IF expr
+if: T_IF expr T_EOL
 {
 	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
 	menu_add_entry(NULL);
-	//current_entry->prompt = menu_add_prop(T_IF, NULL, NULL, $2);
 	menu_add_dep($2);
 	menu_end_entry();
 	menu_add_menu();
@@ -260,8 +321,8 @@ if_end: end
 };
 
 if_stmt:
-	  if T_EOL if_block if_end T_EOL
-	| if T_EOL if_block
+	  if if_block if_end
+	| if if_block
 {
 	printf("%s:%d: missing 'endif' for this 'if' statement\n", current_menu->file->name, current_menu->lineno);
 	zconfnerrs++;
@@ -276,14 +337,14 @@ if_block:
 
 /* menu entry */
 
-menu: T_MENU prompt
+menu: T_MENU prompt T_EOL
 {
 	menu_add_entry(NULL);
 	menu_add_prop(P_MENU, $2, NULL, NULL);
 	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
 };
 
-menu_entry: menu T_EOL depends_list
+menu_entry: menu depends_list
 {
 	menu_end_entry();
 	menu_add_menu();
@@ -298,7 +359,7 @@ menu_end: end
 };
 
 menu_stmt:
-	  menu_entry menu_block menu_end T_EOL
+	  menu_entry menu_block menu_end
 	| menu_entry menu_block
 {
 	printf("%s:%d: missing 'endmenu' for this 'menu' statement\n", current_menu->file->name, current_menu->lineno);
@@ -313,27 +374,27 @@ menu_block:
 	| menu_block error T_EOL		{ zconfprint("invalid menu option"); yyerrok; }
 ;
 
-source: T_SOURCE prompt
+source: T_SOURCE prompt T_EOL
 {
 	$$ = $2;
 	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), $2);
 };
 
-source_stmt: source T_EOL
+source_stmt: source
 {
 	zconf_nextfile($1);
 };
 
 /* comment entry */
 
-comment: T_COMMENT prompt
+comment: T_COMMENT prompt T_EOL
 {
 	menu_add_entry(NULL);
 	menu_add_prop(P_COMMENT, $2, NULL, NULL);
 	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
 };
 
-comment_stmt: comment T_EOL depends_list
+comment_stmt: comment depends_list
 {
 	menu_end_entry();
 };
@@ -354,21 +415,21 @@ help: help_start T_HELPTEXT
 /* depends option */
 
 depends_list:	  /* empty */
-		| depends_list depends T_EOL
+		| depends_list depends
 		| depends_list T_EOL
-{ };
+;
 
-depends: T_DEPENDS T_ON expr
+depends: T_DEPENDS T_ON expr T_EOL
 {
 	menu_add_dep($3);
 	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
 }
-	| T_DEPENDS expr
+	| T_DEPENDS expr T_EOL
 {
 	menu_add_dep($2);
 	printd(DEBUG_PARSE, "%s:%d:depends\n", zconf_curname(), zconf_lineno());
 }
-	| T_REQUIRES expr
+	| T_REQUIRES expr T_EOL
 {
 	menu_add_dep($2);
 	printd(DEBUG_PARSE, "%s:%d:requires\n", zconf_curname(), zconf_lineno());
@@ -378,22 +439,18 @@ depends: T_DEPENDS T_ON expr
 
 prompt_stmt_opt:
 	  /* empty */
-	| prompt
-{
-	menu_add_prop(P_PROMPT, $1, NULL, NULL);
-}
-	| prompt T_IF expr
+	| prompt if_expr
 {
-	menu_add_prop(P_PROMPT, $1, NULL, $3);
+	menu_add_prop(P_PROMPT, $1, NULL, $2);
 };
 
 prompt:	  T_WORD
-	| T_STRING
+	| T_WORD_QUOTE
 ;
 
-end:	  T_ENDMENU		{ $$ = T_ENDMENU; }
-	| T_ENDCHOICE		{ $$ = T_ENDCHOICE; }
-	| T_ENDIF		{ $$ = T_ENDIF; }
+end:	  T_ENDMENU nl_or_eof	{ $$ = T_ENDMENU; }
+	| T_ENDCHOICE nl_or_eof	{ $$ = T_ENDCHOICE; }
+	| T_ENDIF nl_or_eof	{ $$ = T_ENDIF; }
 ;
 
 nl_or_eof:
@@ -413,26 +470,34 @@ expr:	  symbol				{ $$ = expr_alloc_symbol($1); }
 ;
 
 symbol:	  T_WORD	{ $$ = sym_lookup($1, 0); free($1); }
-	| T_STRING	{ $$ = sym_lookup($1, 1); free($1); }
+	| T_WORD_QUOTE	{ $$ = sym_lookup($1, 1); free($1); }
 ;
 
 %%
 
 void conf_parse(const char *name)
 {
+	struct symbol *sym;
+	int i;
+
 	zconf_initscan(name);
 
 	sym_init();
 	menu_init();
-	rootmenu.prompt = menu_add_prop(P_MENU, "BusyBox Configuration", NULL, NULL);
+	modules_sym = sym_lookup("MODULES", 0);
+	rootmenu.prompt = menu_add_prop(P_MENU, "Linux Kernel Configuration", NULL, NULL);
 
 	//zconfdebug = 1;
 	zconfparse();
 	if (zconfnerrs)
 		exit(1);
 	menu_finalize(&rootmenu);
-
-	modules_sym = sym_lookup("MODULES", 0);
+	for_all_symbols(i, sym) {
+                if (!(sym->flags & SYMBOL_CHECKED) && sym_check_deps(sym))
+                        printf("\n");
+		else
+			sym->flags |= SYMBOL_CHECK_DONE;
+        }
 
 	sym_change_count = 1;
 }
@@ -448,7 +513,7 @@ const char *zconf_tokenname(int token)
 	case T_ENDIF:		return "endif";
 	}
 	return "<token>";
-} 
+}
 
 static bool zconf_endtoken(int token, int starttoken, int endtoken)
 {
@@ -470,7 +535,7 @@ static void zconfprint(const char *err, ...)
 {
 	va_list ap;
 
-	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno() + 1);
 	va_start(ap, err);
 	vfprintf(stderr, err, ap);
 	va_end(ap);
@@ -479,7 +544,7 @@ static void zconfprint(const char *err, ...)
 
 static void zconferror(const char *err)
 {
-	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno(), err);
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
 }
 
 void print_quoted_string(FILE *out, const char *str)
@@ -504,8 +569,6 @@ void print_symbol(FILE *out, struct menu *menu)
 	struct symbol *sym = menu->sym;
 	struct property *prop;
 
-	//sym->flags |= SYMBOL_PRINTED;
-
 	if (sym_is_choice(sym))
 		fprintf(out, "choice\n");
 	else
@@ -530,13 +593,6 @@ void print_symbol(FILE *out, struct menu *menu)
 		fputs("  ???\n", out);
 		break;
 	}
-#if 0
-	if (!expr_is_yes(sym->dep)) {
-		fputs("  depends ", out);
-		expr_fprint(sym->dep, out);
-		fputc('\n', out);
-	}
-#endif
 	for (prop = sym->prop; prop; prop = prop->next) {
 		if (prop->menu != menu)
 			continue;
@@ -544,25 +600,18 @@ void print_symbol(FILE *out, struct menu *menu)
 		case P_PROMPT:
 			fputs("  prompt ", out);
 			print_quoted_string(out, prop->text);
-			if (prop->def) {
-				fputc(' ', out);
-				if (prop->def->flags & SYMBOL_CONST)
-					print_quoted_string(out, prop->def->name);
-				else
-					fputs(prop->def->name, out);
-			}
-			if (!expr_is_yes(E_EXPR(prop->visible))) {
+			if (!expr_is_yes(prop->visible.expr)) {
 				fputs(" if ", out);
-				expr_fprint(E_EXPR(prop->visible), out);
+				expr_fprint(prop->visible.expr, out);
 			}
 			fputc('\n', out);
 			break;
 		case P_DEFAULT:
 			fputs( "  default ", out);
-			print_quoted_string(out, prop->def->name);
-			if (!expr_is_yes(E_EXPR(prop->visible))) {
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
 				fputs(" if ", out);
-				expr_fprint(E_EXPR(prop->visible), out);
+				expr_fprint(prop->visible.expr, out);
 			}
 			fputc('\n', out);
 			break;
@@ -585,7 +634,6 @@ void print_symbol(FILE *out, struct menu *menu)
 
 void zconfdump(FILE *out)
 {
-	//struct file *file;
 	struct property *prop;
 	struct symbol *sym;
 	struct menu *menu;
@@ -596,11 +644,6 @@ void zconfdump(FILE *out)
 			print_symbol(out, menu);
 		else if ((prop = menu->prompt)) {
 			switch (prop->type) {
-			//case T_MAINMENU:
-			//	fputs("\nmainmenu ", out);
-			//	print_quoted_string(out, prop->text);
-			//	fputs("\n", out);
-			//	break;
 			case P_COMMENT:
 				fputs("\ncomment ", out);
 				print_quoted_string(out, prop->text);
@@ -611,19 +654,12 @@ void zconfdump(FILE *out)
 				print_quoted_string(out, prop->text);
 				fputs("\n", out);
 				break;
-			//case T_SOURCE:
-			//	fputs("\nsource ", out);
-			//	print_quoted_string(out, prop->text);
-			//	fputs("\n", out);
-			//	break;
-			//case T_IF:
-			//	fputs("\nif\n", out);
 			default:
 				;
 			}
-			if (!expr_is_yes(E_EXPR(prop->visible))) {
+			if (!expr_is_yes(prop->visible.expr)) {
 				fputs("  depends ", out);
-				expr_fprint(E_EXPR(prop->visible), out);
+				expr_fprint(prop->visible.expr, out);
 				fputc('\n', out);
 			}
 			fputs("\n", out);
diff --git a/shell/Config.in b/shell/Config.in
index c1e909944..6103ccfda 100644
--- a/shell/Config.in
+++ b/shell/Config.in
@@ -7,7 +7,7 @@ menu "Another Bourne-like Shell"
 
 choice
 	prompt "Choose your default shell"
-	default "none"
+	default CONFIG_FEATURE_SH_IS_NONE
 	help
 	  Choose a shell. The ash shell is the most bash compatible
 	  and full featured.
diff --git a/sysdeps/linux/Config.in b/sysdeps/linux/Config.in
index d5adee5d0..c3bca3363 100644
--- a/sysdeps/linux/Config.in
+++ b/sysdeps/linux/Config.in
@@ -13,7 +13,7 @@ menu "General Configuration"
 
 choice
 	prompt "Buffer allocation policy"
-	default "Allocate with Malloc"
+	default CONFIG_FEATURE_BUFFERS_USE_MALLOC
 	help
 	  There are 3 ways BusyBox can handle buffer allocations:
 	  - Use malloc. This costs code size for the call to xmalloc.