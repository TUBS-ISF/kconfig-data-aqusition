"2003-07-05 07:51:31 +0000"
diff --git a/include/applets.h b/include/applets.h
index cfb278123..5fe01de5f 100644
--- a/include/applets.h
+++ b/include/applets.h
@@ -193,6 +193,9 @@
 #ifdef CONFIG_FDFLUSH
 	APPLET(fdflush, fdflush_main, _BB_DIR_BIN, _BB_SUID_NEVER)
 #endif
+#ifdef CONFIG_FDFORMAT
+	APPLET(fdformat, fdformat_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
+#endif
 #ifdef CONFIG_FDISK
 	APPLET(fdisk, fdisk_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
 #endif
diff --git a/include/usage.h b/include/usage.h
index a570d3519..14f2e2859 100644
--- a/include/usage.h
+++ b/include/usage.h
@@ -571,6 +571,13 @@
 #define fdflush_full_usage \
 	"Forces floppy disk drive to detect disk change"
 
+#define fdformat_trivial_usage \
+	"[-n] DEVICE"
+#define fdformat_full_usage \
+	"Low-level formats a floppy disk\n\n" \
+	"Options:\n" \
+	"\t-n\tDon't verify after format"
+
 #define fdisk_trivial_usage \
 	"[-l] [-v] [-b SSZ] [-u] DISK"
 #define fdisk_full_usage \
diff --git a/util-linux/Config.in b/util-linux/Config.in
index d2e827213..ae17fe31b 100644
--- a/util-linux/Config.in
+++ b/util-linux/Config.in
@@ -59,6 +59,12 @@ config CONFIG_FDFLUSH
 	  you change a disk.  Most people have working hardware and can safely
 	  say leave this disabled.
 
+config CONFIG_FDFORMAT
+	bool "fdformat"
+	default n
+	help
+	  Fdformat is used to low-level format a floppy disk.
+
 config CONFIG_FDISK
 	bool "fdisk"
 	default n
diff --git a/util-linux/Makefile.in b/util-linux/Makefile.in
index 4e1871425..28757a336 100644
--- a/util-linux/Makefile.in
+++ b/util-linux/Makefile.in
@@ -26,6 +26,7 @@ UTILLINUX-:=
 UTILLINUX-$(CONFIG_DMESG)		+= dmesg.o
 UTILLINUX-$(CONFIG_FBSET)		+= fbset.o
 UTILLINUX-$(CONFIG_FDFLUSH)		+= fdflush.o
+UTILLINUX-$(CONFIG_FDFORMAT)		+= fdformat.o
 UTILLINUX-$(CONFIG_FDISK)               += fdisk.o
 UTILLINUX-$(CONFIG_FREERAMDISK)	+= freeramdisk.o
 UTILLINUX-$(CONFIG_FSCK_MINIX)	+= fsck_minix.o
diff --git a/util-linux/fdformat.c b/util-linux/fdformat.c
new file mode 100644
index 000000000..5b926467f
--- /dev/null
+++ b/util-linux/fdformat.c
@@ -0,0 +1,158 @@
+/* fdformat.c  -  Low-level formats a floppy disk - Werner Almesberger */
+
+/* 1999-02-22 Arkadiusz Mikiewicz <misiek@pld.ORG.PL>
+ * - added Native Language Support
+ * 1999-03-20 Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ * - more i18n/nls translatable strings marked
+ *
+ * 5 July 2003 -- modified for Busybox by Erik Andersen
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include "busybox.h"
+
+
+/* Stuff extracted from linux/fd.h */
+struct floppy_struct {
+	unsigned int	size,		/* nr of sectors total */
+			sect,		/* sectors per track */
+			head,		/* nr of heads */
+			track,		/* nr of tracks */
+			stretch;	/* !=0 means double track steps */
+#define FD_STRETCH 1
+#define FD_SWAPSIDES 2
+
+	unsigned char	gap,		/* gap1 size */
+
+			rate,		/* data rate. |= 0x40 for perpendicular */
+#define FD_2M 0x4
+#define FD_SIZECODEMASK 0x38
+#define FD_SIZECODE(floppy) (((((floppy)->rate&FD_SIZECODEMASK)>> 3)+ 2) %8)
+#define FD_SECTSIZE(floppy) ( (floppy)->rate & FD_2M ? \
+			     512 : 128 << FD_SIZECODE(floppy) )
+#define FD_PERP 0x40
+
+			spec1,		/* stepping rate, head unload time */
+			fmt_gap;	/* gap2 size */
+	const char	* name; /* used only for predefined formats */
+};
+struct format_descr {
+	unsigned int device,head,track;
+};
+#define FDFMTBEG _IO(2,0x47)
+#define	FDFMTTRK _IOW(2,0x48, struct format_descr)
+#define FDFMTEND _IO(2,0x49)
+#define FDGETPRM _IOR(2, 0x04, struct floppy_struct)
+#define FD_FILL_BYTE 0xF6 /* format fill byte. */
+
+
+
+static void format_disk(int ctrl, char *name, struct floppy_struct *param)
+{
+    struct format_descr descr;
+    int track;
+
+    printf("Formatting ... ");
+    fflush(stdout);
+    if (ioctl(ctrl,FDFMTBEG,NULL) < 0) {
+	bb_perror_msg_and_die("FDFMTBEG");
+    }
+    for (track = 0; track < param->track; track++) 
+    {
+	descr.track = track;
+	descr.head = 0;
+	if (ioctl(ctrl,FDFMTTRK,(long) &descr) < 0) {
+	    bb_perror_msg_and_die("FDFMTTRK");
+	}
+
+	printf("%3d\b\b\b",track);
+	fflush(stdout);
+	if (param->head == 2) {
+	    descr.head = 1;
+	    if (ioctl(ctrl,FDFMTTRK,(long) &descr) < 0) {
+		bb_perror_msg_and_die("FDFMTTRK");
+	    }
+	}
+    }
+    if (ioctl(ctrl,FDFMTEND,NULL) < 0) {
+	bb_perror_msg_and_die("FDFMTEND");
+    }
+    printf("done\n");
+}
+
+static void verify_disk(char *name, struct floppy_struct *param)
+{
+    unsigned char *data;
+    int fd,cyl_size,cyl,count,read_bytes;
+
+    cyl_size = param->sect*param->head*512;
+    data = xmalloc(cyl_size);
+    printf("Verifying ... ");
+    fflush(stdout);
+    fd = bb_xopen(name,O_RDONLY);
+    for (cyl = 0; cyl < param->track; cyl++) 
+    {
+	printf("%3d\b\b\b",cyl);
+	fflush(stdout);
+	read_bytes = safe_read(fd,data,cyl_size);
+	if(read_bytes != cyl_size) {
+	    if(read_bytes < 0) {
+		bb_perror_msg("Read: ");
+	    }
+	    bb_error_msg_and_die("Problem reading cylinder %d, "
+		    "expected %d, read %d", cyl, cyl_size, read_bytes);
+	}
+	for (count = 0; count < cyl_size; count++)
+	    if (data[count] != FD_FILL_BYTE) {
+		printf("bad data in cyl %d\nContinuing ... ",cyl);
+		fflush(stdout);
+		break;
+	    }
+    }
+    printf("done\n");
+    close(fd);
+}
+
+int fdformat_main(int argc,char **argv)
+{
+    int ctrl;
+    int verify;
+    struct stat st;
+    struct floppy_struct param;
+
+    if (argc < 2) {
+	bb_show_usage();
+    }
+    verify != bb_getopt_ulflags(argc, argv, "n");
+    argv += optind;
+
+    if (stat(*argv,&st) < 0 || access(*argv,W_OK) < 0) {
+	bb_perror_msg_and_die(*argv);
+    }
+    if (!S_ISBLK(st.st_mode)) {
+	bb_error_msg_and_die("%s: not a block device",*argv);
+	/* do not test major - perhaps this was an USB floppy */
+    }
+
+    ctrl = bb_xopen(*argv,O_WRONLY);
+    if (ioctl(ctrl,FDGETPRM,(long) &param) < 0) { 
+	bb_perror_msg_and_die("Could not determine current format type");
+    }
+    printf("%s-sided, %d tracks, %d sec/track. Total capacity %d kB.\n",
+	    (param.head == 2) ? "Double" : "Single",
+	    param.track, param.sect,param.size >> 1);
+    format_disk(ctrl, *argv, &param);
+    close(ctrl);
+
+    if (verify) {
+	verify_disk(*argv, &param);
+    }
+    return EXIT_SUCCESS;
+}