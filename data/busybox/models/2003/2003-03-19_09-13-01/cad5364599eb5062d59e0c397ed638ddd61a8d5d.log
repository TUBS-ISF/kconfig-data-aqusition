"2003-03-19 09:13:01 +0000"
diff --git a/Makefile b/Makefile
index 48911f77e..6be57b554 100644
--- a/Makefile
+++ b/Makefile
@@ -29,7 +29,7 @@ include Rules.mak
 DIRS:=applets archival archival/libunarchive coreutils console-tools \
 	debianutils editors findutils init miscutils modutils networking \
 	networking/libiproute networking/udhcp procps loginutils shell \
-	sysklogd util-linux libbb libpwdgrp
+	sysklogd util-linux libbb libpwdgrp coreutils/libcoreutils
 
 ifeq ($(strip $(HAVE_DOT_CONFIG)),y)
 
diff --git a/applets/applets.c b/applets/applets.c
index 9f69da185..1b69ade92 100644
--- a/applets/applets.c
+++ b/applets/applets.c
@@ -78,7 +78,7 @@ static struct BB_suid_config *suid_config;
 
 
 
-extern void show_usage(void)
+extern void bb_show_usage(void)
 {
 	const char *format_string;
 	const char *usage_string = usage_messages;
@@ -93,7 +93,7 @@ extern void show_usage(void)
 	format_string = "%s\n\nUsage: %s %s\n\n";
 	if(*usage_string == '\b')
 		format_string = "%s\n\nNo help available.\n\n";
-	fprintf(stderr, format_string, full_version, applet_using->name, usage_string);
+	fprintf(stderr, format_string, bb_msg_full_version, applet_using->name, usage_string);
 
 	exit(EXIT_FAILURE);
 }
@@ -127,7 +127,7 @@ void run_applet_by_name(const char *name, int argc, char **argv)
 	recurse_level++;
 	/* Do a binary search to find the applet entry given the name. */
 	if ((applet_using = find_applet_by_name(name)) != NULL) {
-		applet_name = applet_using->name;
+		bb_applet_name = applet_using->name;
 		if (argv[1] && strcmp(argv[1], "--help") == 0) {
 			if (strcmp(applet_using->name, "busybox")==0) {
 				if(argv[2])
@@ -136,7 +136,7 @@ void run_applet_by_name(const char *name, int argc, char **argv)
 				  applet_using = NULL;
 			}
 			if(applet_using)
-				show_usage();
+				bb_show_usage();
 			been_there_done_that=1;
 			busybox_main(0, NULL);
 		}
@@ -201,18 +201,18 @@ void check_suid ( struct BB_applet *applet )
 				m >>= 3;
 
 			if (!( m & S_IXOTH ))   /* is x bit not set ? */
-				error_msg_and_die ( "You have no permission to run this applet!" );
+				bb_error_msg_and_die ( "You have no permission to run this applet!" );
 
 			if (( sct-> m_mode & ( S_ISGID | S_IXGRP )) == ( S_ISGID | S_IXGRP )) { /* *both* have to be set for sgid */
 				if ( setegid ( sct-> m_gid ))
-					error_msg_and_die ( "BusyBox binary has insufficient rights to set proper GID for applet!" );
+					bb_error_msg_and_die ( "BusyBox binary has insufficient rights to set proper GID for applet!" );
 			}
 			else
 				setgid ( rgid ); /* no sgid -> drop */
 
 			if ( sct-> m_mode & S_ISUID ) {
 				if ( seteuid ( sct-> m_uid ))
-					error_msg_and_die ( "BusyBox binary has insufficient rights to set proper UID for applet!" );
+					bb_error_msg_and_die ( "BusyBox binary has insufficient rights to set proper UID for applet!" );
 			}	
 			else
 				setuid ( ruid ); /* no suid -> drop */
@@ -237,7 +237,7 @@ void check_suid ( struct BB_applet *applet )
 
 	if ( applet-> need_suid == _BB_SUID_ALWAYS ) {
 		if ( geteuid ( ) != 0 ) 
-			error_msg_and_die ( "This applet requires root priviledges!" );
+			bb_error_msg_and_die ( "This applet requires root priviledges!" );
 	} 
 	else if ( applet-> need_suid == _BB_SUID_NEVER ) {
 		setgid ( rgid ); /* drop all priviledges */
@@ -280,7 +280,7 @@ int parse_config_file ( void )
 					p = strchr ( buffer, '#' );
 					if ( p )
 						*p = 0;
-					p = buffer + xstrlen ( buffer );
+					p = buffer + bb_strlen ( buffer );
 					while (( p > buffer ) && isspace ( *--p ))
 						*p = 0;		
 
diff --git a/applets/busybox.c b/applets/busybox.c
index 4f1ef2661..457a85a68 100644
--- a/applets/busybox.c
+++ b/applets/busybox.c
@@ -10,7 +10,7 @@
 #endif
 
 int been_there_done_that = 0; /* Also used in applets.c */
-const char *applet_name;
+const char *bb_applet_name;
 
 #ifdef CONFIG_FEATURE_INSTALLER
 /* 
@@ -60,7 +60,7 @@ static void install_links(const char *busybox, int use_symbolic_links)
 			install_dir[applets[i].location], applets[i].name);
 		rc = Link(busybox, fpc);
 		if (rc!=0 && errno!=EEXIST) {
-			perror_msg("%s", fpc);
+			bb_perror_msg("%s", fpc);
 		}
 		free(fpc);
 	}
@@ -72,14 +72,14 @@ int main(int argc, char **argv)
 {
 	const char *s;
 
-	applet_name = argv[0];
+	bb_applet_name = argv[0];
 
-	if (applet_name[0] == '-')
-		applet_name++;
+	if (bb_applet_name[0] == '-')
+		bb_applet_name++;
 
-	for (s = applet_name; *s != '\0';) {
+	for (s = bb_applet_name; *s != '\0';) {
 		if (*s++ == '/')
-			applet_name = s;
+			bb_applet_name = s;
 	}
 
 #ifdef CONFIG_LOCALE_SUPPORT 
@@ -91,8 +91,8 @@ int main(int argc, char **argv)
 	}
 #endif
 
-	run_applet_by_name(applet_name, argc, argv);
-	error_msg_and_die("applet not found");
+	run_applet_by_name(bb_applet_name, argc, argv);
+	bb_error_msg_and_die("applet not found");
 }
 
 
@@ -143,7 +143,7 @@ int busybox_main(int argc, char **argv)
 				"\tutilities into a single executable.  Most people will create a\n"
 				"\tlink to busybox for each function they wish to use, and BusyBox\n"
 				"\twill act like whatever it was invoked as.\n" 
-				"\nCurrently defined functions:\n", full_version);
+				"\nCurrently defined functions:\n", bb_msg_full_version);
 
 		while (a->name != 0) {
 			col +=
diff --git a/archival/ar.c b/archival/ar.c
index 87968f7be..57ec92719 100644
--- a/archival/ar.c
+++ b/archival/ar.c
@@ -40,7 +40,7 @@
 
 static void header_verbose_list_ar(const file_header_t *file_header)
 {
-	const char *mode = mode_string(file_header->mode);
+	const char *mode = bb_mode_string(file_header->mode);
 	char *mtime;
 
 	mtime = ctime(&file_header->mtime);
@@ -58,7 +58,7 @@ static void data_extract_regular_file(archive_handle_t *archive_handle)
 	int dst_fd;
 
 	file_header = archive_handle->file_header;
-	dst_fd = xopen(file_header->name, O_WRONLY | O_CREAT);
+	dst_fd = bb_xopen(file_header->name, O_WRONLY | O_CREAT);
 	archive_copy_file(archive_handle, dst_fd);	
 	close(dst_fd);
 
@@ -110,16 +110,16 @@ extern int ar_main(int argc, char **argv)
 			archive_handle->action_header = header_verbose_list_ar;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
  
 	/* check the src filename was specified */
 	if (optind == argc) {
-		show_usage();
+		bb_show_usage();
 	}
 
-	archive_handle->src_fd = xopen(argv[optind++], O_RDONLY);
+	archive_handle->src_fd = bb_xopen(argv[optind++], O_RDONLY);
 
 	/* TODO: This is the same as in tar, seperate function ? */
 	while (optind < argc) {
@@ -133,7 +133,7 @@ extern int ar_main(int argc, char **argv)
 #else
 	archive_xread_all(archive_handle, magic, 7);
 	if (strncmp(magic, "!<arch>", 7) != 0) {
-		error_msg_and_die("Invalid ar magic");
+		bb_error_msg_and_die("Invalid ar magic");
 	}
 	archive_handle->offset += 7;
 
diff --git a/archival/bunzip2.c b/archival/bunzip2.c
index d5c06f4fd..eb5238cd4 100644
--- a/archival/bunzip2.c
+++ b/archival/bunzip2.c
@@ -41,7 +41,7 @@ int bunzip2_main(int argc, char **argv)
 	char *delete_name = NULL;
 
 	/* if called as bzcat */
-	if (strcmp(applet_name, "bzcat") == 0)
+	if (strcmp(bb_applet_name, "bzcat") == 0)
 		flags |= bunzip_to_stdout;
 
 	while ((opt = getopt(argc, argv, "cfh")) != -1) {
@@ -54,7 +54,7 @@ int bunzip2_main(int argc, char **argv)
 			break;
 		case 'h':
 		default:
-			show_usage(); /* exit's inside usage */
+			bb_show_usage(); /* exit's inside usage */
 		}
 	}
 
@@ -64,23 +64,23 @@ int bunzip2_main(int argc, char **argv)
 		src_fd = fileno(stdin);
 	} else {
 		/* Open input file */
-		src_fd = xopen(argv[optind], O_RDONLY);
+		src_fd = bb_xopen(argv[optind], O_RDONLY);
 
-		save_name = xstrdup(argv[optind]);
+		save_name = bb_xstrdup(argv[optind]);
 		if (strcmp(save_name + strlen(save_name) - 4, ".bz2") != 0)
-			error_msg_and_die("Invalid extension");
+			bb_error_msg_and_die("Invalid extension");
 		save_name[strlen(save_name) - 4] = '\0';
 	}
 
 	/* Check that the input is sane.  */
 	if (isatty(src_fd) && (flags & bunzip_force) == 0) {
-		error_msg_and_die("compressed data not read from terminal.  Use -f to force it.");
+		bb_error_msg_and_die("compressed data not read from terminal.  Use -f to force it.");
 	}
 
 	if (flags & bunzip_to_stdout) {
 		dst_fd = fileno(stdout);
 	} else {
-		dst_fd = xopen(save_name, O_WRONLY | O_CREAT);
+		dst_fd = bb_xopen(save_name, O_WRONLY | O_CREAT);
 	}
 
 	if (uncompressStream(src_fd, dst_fd)) {
@@ -96,7 +96,7 @@ int bunzip2_main(int argc, char **argv)
 	}
 
 	if ((delete_name) && (unlink(delete_name) < 0)) {
-		error_msg_and_die("Couldn't remove %s", delete_name);
+		bb_error_msg_and_die("Couldn't remove %s", delete_name);
 	}
 
 	return status;
diff --git a/archival/cpio.c b/archival/cpio.c
index 49f3f88e4..111807c43 100644
--- a/archival/cpio.c
+++ b/archival/cpio.c
@@ -63,11 +63,11 @@ extern int cpio_main(int argc, char **argv)
 			archive_handle->action_header = header_list;
 			break;
 		case 'F':
-			archive_handle->src_fd = xopen(optarg, O_RDONLY);
+			archive_handle->src_fd = bb_xopen(optarg, O_RDONLY);
 			archive_handle->seek = seek_by_jump;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
diff --git a/archival/dpkg.c b/archival/dpkg.c
index 692592268..3288f7e63 100644
--- a/archival/dpkg.c
+++ b/archival/dpkg.c
@@ -177,7 +177,7 @@ int search_name_hashtable(const char *key)
 			}
 		}
 	}
-	name_hashtable[probe_address] = xstrdup(key);
+	name_hashtable[probe_address] = bb_xstrdup(key);
 	return(probe_address);
 }
 
@@ -218,10 +218,10 @@ int version_compare_part(const char *version1, const char *version2)
 	int ret;
 
 	if (version1 == NULL) {
-		version1 = xstrdup("");
+		version1 = bb_xstrdup("");
 	}
 	if (version2 == NULL) {
-		version2 = xstrdup("");
+		version2 = bb_xstrdup("");
 	}
 	upstream_len1 = strlen(version1);
 	upstream_len2 = strlen(version2);
@@ -229,10 +229,10 @@ int version_compare_part(const char *version1, const char *version2)
 	while ((len1 < upstream_len1) || (len2 < upstream_len2)) {
 		/* Compare non-digit section */
 		tmp_int = strcspn(&version1[len1], "0123456789");
-		name1_char = xstrndup(&version1[len1], tmp_int);
+		name1_char = bb_xstrndup(&version1[len1], tmp_int);
 		len1 += tmp_int;
 		tmp_int = strcspn(&version2[len2], "0123456789");
-		name2_char = xstrndup(&version2[len2], tmp_int);
+		name2_char = bb_xstrndup(&version2[len2], tmp_int);
 		len2 += tmp_int;
 		tmp_int = strcmp(name1_char, name2_char);
 		free(name1_char);
@@ -244,10 +244,10 @@ int version_compare_part(const char *version1, const char *version2)
 
 		/* Compare digits */
 		tmp_int = strspn(&version1[len1], "0123456789");
-		name1_char = xstrndup(&version1[len1], tmp_int);
+		name1_char = bb_xstrndup(&version1[len1], tmp_int);
 		len1 += tmp_int;
 		tmp_int = strspn(&version2[len2], "0123456789");
-		name2_char = xstrndup(&version2[len2], tmp_int);
+		name2_char = bb_xstrndup(&version2[len2], tmp_int);
 		len2 += tmp_int;
 		ver_num1 = atoi(name1_char);
 		ver_num2 = atoi(name2_char);
@@ -306,8 +306,8 @@ int version_compare(const unsigned int ver1, const unsigned int ver2)
 	}
 
 	/* Compare upstream version */
-	upstream_ver1 = xstrdup(ver1_ptr);
-	upstream_ver2 = xstrdup(ver2_ptr);
+	upstream_ver1 = bb_xstrdup(ver1_ptr);
+	upstream_ver2 = bb_xstrdup(ver2_ptr);
 
 	/* Chop off debian version, and store for later use */
 	deb_ver1 = strrchr(upstream_ver1, '-');
@@ -397,7 +397,7 @@ int search_package_hashtable(const unsigned int name, const unsigned int version
  */
 void add_split_dependencies(common_node_t *parent_node, const char *whole_line, unsigned int edge_type)
 {
-	char *line = xstrdup(whole_line);
+	char *line = bb_xstrdup(whole_line);
 	char *line2;
 	char *line_ptr1 = NULL;
 	char *line_ptr2 = NULL;
@@ -410,7 +410,7 @@ void add_split_dependencies(common_node_t *parent_node, const char *whole_line,
 
 	field = strtok_r(line, ",", &line_ptr1);
 	do {
-		line2 = xstrdup(field);
+		line2 = bb_xstrdup(field);
 		field2 = strtok_r(line2, "|", &line_ptr2);
 		if ((edge_type == EDGE_DEPENDS) && (strcmp(field, field2) != 0)) {
 			type = EDGE_OR_DEPENDS;
@@ -457,7 +457,7 @@ void add_split_dependencies(common_node_t *parent_node, const char *whole_line,
 					else if (strncmp(version, ">=", offset_ch) == 0) {
 						edge->operator = VER_MORE_EQUAL;
 					} else {
-						error_msg_and_die("Illegal operator\n");
+						bb_error_msg_and_die("Illegal operator\n");
 					}
 				}
 				/* skip to start of version numbers */
@@ -588,7 +588,7 @@ unsigned int get_status(const unsigned int status_node, const int num)
 		status_string += strspn(status_string, " ");
 	}
 	len = strcspn(status_string, " \n\0");
-	state_sub_string = xstrndup(status_string, len);
+	state_sub_string = bb_xstrndup(status_string, len);
 	state_sub_num = search_name_hashtable(state_sub_string);
 	free(state_sub_string);
 	return(state_sub_num);
@@ -620,7 +620,7 @@ void set_status(const unsigned int status_node_num, const char *new_value, const
 			status_len = new_value_len;
 			break;
 		default:
-			error_msg_and_die("DEBUG ONLY: this shouldnt happen");
+			bb_error_msg_and_die("DEBUG ONLY: this shouldnt happen");
 	}
 
 	new_status = (char *) xmalloc(want_len + flag_len + status_len + 3);
@@ -638,7 +638,7 @@ void index_status_file(const char *filename)
 	status_node_t *status_node = NULL;
 	unsigned int status_num;
 
-	status_file = xfopen(filename, "r");
+	status_file = bb_xfopen(filename, "r");
 	while ((control_buffer = fgets_str(status_file, "\n\n")) != NULL) {
 		const unsigned int package_num = fill_package_struct(control_buffer);
 		if (package_num != -1) {
@@ -648,7 +648,7 @@ void index_status_file(const char *filename)
 			if (status_line != NULL) {
 				status_line += 7;
 				status_line += strspn(status_line, " \n\t");
-				status_line = xstrndup(status_line, strcspn(status_line, "\n\0"));
+				status_line = bb_xstrndup(status_line, strcspn(status_line, "\n\0"));
 				status_node->status = search_name_hashtable(status_line);
 				free(status_line);
 			}
@@ -754,8 +754,8 @@ void write_buffer_no_status(FILE *new_status_file, const char *control_buffer)
 /* This could do with a cleanup */
 void write_status_file(deb_file_t **deb_file)
 {
-	FILE *old_status_file = xfopen("/var/lib/dpkg/status", "r");
-	FILE *new_status_file = xfopen("/var/lib/dpkg/status.udeb", "w");
+	FILE *old_status_file = bb_xfopen("/var/lib/dpkg/status", "r");
+	FILE *new_status_file = bb_xfopen("/var/lib/dpkg/status.udeb", "w");
 	char *package_name;
 	char *status_from_file;
 	char *control_buffer = NULL;
@@ -773,14 +773,14 @@ void write_status_file(deb_file_t **deb_file)
 
 		tmp_string += 8;
  		tmp_string += strspn(tmp_string, " \n\t");
-		package_name = xstrndup(tmp_string, strcspn(tmp_string, "\n\0"));
+		package_name = bb_xstrndup(tmp_string, strcspn(tmp_string, "\n\0"));
 		write_flag = FALSE;
 		tmp_string = strstr(control_buffer, "Status:");
 		if (tmp_string != NULL) {
 			/* Seperate the status value from the control buffer */
 			tmp_string += 7;
 			tmp_string += strspn(tmp_string, " \n\t");
-			status_from_file = xstrndup(tmp_string, strcspn(tmp_string, "\n"));
+			status_from_file = bb_xstrndup(tmp_string, strcspn(tmp_string, "\n"));
 		} else {
 			status_from_file = NULL;
 		}
@@ -810,7 +810,7 @@ void write_status_file(deb_file_t **deb_file)
 					}
 					/* This is temperary, debugging only */
 					if (deb_file[i] == NULL) {
-						error_msg_and_die("ALERT: Couldnt find a control file, your status file may be broken, status may be incorrect for %s", package_name);
+						bb_error_msg_and_die("ALERT: Couldnt find a control file, your status file may be broken, status may be incorrect for %s", package_name);
 					}
 				}
 				else if (strcmp("not-installed", name_hashtable[state_status]) == 0) {
@@ -881,15 +881,15 @@ void write_status_file(deb_file_t **deb_file)
 	if (rename("/var/lib/dpkg/status", "/var/lib/dpkg/status.udeb.bak") == -1) {
 		struct stat stat_buf;	
 		if (stat("/var/lib/dpkg/status", &stat_buf) == 0) {
-			error_msg_and_die("Couldnt create backup status file");
+			bb_error_msg_and_die("Couldnt create backup status file");
 		}
 		/* Its ok if renaming the status file fails becasue status 
 		 * file doesnt exist, maybe we are starting from scratch */
-		error_msg("No status file found, creating new one");
+		bb_error_msg("No status file found, creating new one");
 	}
 
 	if (rename("/var/lib/dpkg/status.udeb", "/var/lib/dpkg/status") == -1) {
-		error_msg_and_die("DANGER: Couldnt create status file, you need to manually repair your status file");
+		bb_error_msg_and_die("DANGER: Couldnt create status file, you need to manually repair your status file");
 	}
 }
 
@@ -976,7 +976,7 @@ int check_deps(deb_file_t **deb_file, int deb_start, int dep_max_count)
 				}
 
 				if (result) {
-					error_msg_and_die("Package %s conflicts with %s",
+					bb_error_msg_and_die("Package %s conflicts with %s",
 						name_hashtable[package_node->name],
 						name_hashtable[package_edge->name]);
 				}
@@ -1021,7 +1021,7 @@ int check_deps(deb_file_t **deb_file, int deb_start, int dep_max_count)
 					}
 
 					if (result) {
-						error_msg_and_die("Package %s pre-depends on %s, but it is not installed",
+						bb_error_msg_and_die("Package %s pre-depends on %s, but it is not installed",
 							name_hashtable[package_node->name],
 							name_hashtable[package_edge->name]);
 					}
@@ -1038,7 +1038,7 @@ int check_deps(deb_file_t **deb_file, int deb_start, int dep_max_count)
 					}
 					/* It must be already installed, or to be installed */
 					if (result) {
-						error_msg_and_die("Package %s depends on %s, but it is not installed, or flaged to be installed",
+						bb_error_msg_and_die("Package %s depends on %s, but it is not installed, or flaged to be installed",
 							name_hashtable[package_node->name],
 							name_hashtable[package_edge->name]);
 					}
@@ -1065,9 +1065,8 @@ char **create_list(const char *filename)
 		return(NULL);
 	}
 
-	while ((line = get_line_from_file(list_stream)) != NULL) {
+	while ((line = bb_get_chomped_line_from_file(list_stream)) != NULL) {
 		file_list = xrealloc(file_list, sizeof(char *) * (count + 2));
-		chomp(line);
 		file_list[count] = line;
 		count++;
 	}
@@ -1228,7 +1227,7 @@ void remove_package(const unsigned int package_num)
 	/* run prerm script */
 	return_value = run_package_script(package_name, "prerm");
 	if (return_value == -1) {
-		error_msg_and_die("script failed, prerm failure");
+		bb_error_msg_and_die("script failed, prerm failure");
 	}
 
 	/* Create a list of files to remove, and a seperate list of those to keep */
@@ -1245,7 +1244,7 @@ void remove_package(const unsigned int package_num)
 
 	/* Create a list of files in /var/lib/dpkg/info/<package>.* to keep  */
 	exclude_files = xmalloc(sizeof(char*) * 3);
-	exclude_files[0] = xstrdup(conffile_name);
+	exclude_files[0] = bb_xstrdup(conffile_name);
 	exclude_files[1] = xmalloc(package_name_length + 27);
 	sprintf(exclude_files[1], "/var/lib/dpkg/info/%s.postrm", package_name);
 	exclude_files[2] = NULL;
@@ -1275,7 +1274,7 @@ void purge_package(const unsigned int package_num)
 
 	/* run prerm script */
 	if (run_package_script(package_name, "prerm") != 0) {
-		error_msg_and_die("script failed, prerm failure");
+		bb_error_msg_and_die("script failed, prerm failure");
 	}
 
 	/* Create a list of files to remove */
@@ -1297,7 +1296,7 @@ void purge_package(const unsigned int package_num)
 
 	/* run postrm script */
 	if (run_package_script(package_name, "postrm") == -1) {
-		error_msg_and_die("postrm fialure.. set status to what?");
+		bb_error_msg_and_die("postrm fialure.. set status to what?");
 	}
 
 	/* Change package status */
@@ -1312,7 +1311,7 @@ static archive_handle_t *init_archive_deb_ar(const char *filename)
 	/* Setup an ar archive handle that refers to the gzip sub archive */	
 	ar_handle = init_handle();
 	ar_handle->filter = filter_accept_list_reassign;
-	ar_handle->src_fd = xopen(filename, O_RDONLY);
+	ar_handle->src_fd = bb_xopen(filename, O_RDONLY);
 
 	return(ar_handle);	
 }
@@ -1420,7 +1419,7 @@ static void unpack_package(deb_file_t *deb_file)
 	/* Run the preinst prior to extracting */
 	if (run_package_script(package_name, "preinst") != 0) {
 		/* when preinst returns exit code != 0 then quit installation process */
-		error_msg_and_die("subprocess pre-installation script returned error.");
+		bb_error_msg_and_die("subprocess pre-installation script returned error.");
 	}	
 
 	/* Extract data.tar.gz to the root directory */
@@ -1430,7 +1429,7 @@ static void unpack_package(deb_file_t *deb_file)
 
 	/* Create the list file */
 	strcat(info_prefix, "list");
-	out_stream = xfopen(info_prefix, "w");			
+	out_stream = bb_xfopen(info_prefix, "w");			
 	while (archive_handle->passed) {
 		/* blindly skip over the leading '.' */
 		fputs(archive_handle->passed->data + 1, out_stream);
@@ -1457,7 +1456,7 @@ void configure_package(deb_file_t *deb_file)
 	/* Run the postinst script */
 	if (run_package_script(package_name, "postinst") != 0) {
 		/* TODO: handle failure gracefully */
-		error_msg_and_die("postrm failure.. set status to what?");
+		bb_error_msg_and_die("postrm failure.. set status to what?");
 	}
 	/* Change status to reflect success */
 	set_status(status_num, "install", 1);
@@ -1506,12 +1505,12 @@ int dpkg_main(int argc, char **argv)
 				dpkg_opt |= dpkg_opt_filename;
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 	/* check for non-otion argument if expected  */
 	if ((dpkg_opt == 0) || ((argc == optind) && !(dpkg_opt && dpkg_opt_list_installed))) {
-		show_usage();
+		bb_show_usage();
 	}
 
 /*	puts("(Reading database ... xxxxx files and directories installed.)"); */
@@ -1538,13 +1537,13 @@ int dpkg_main(int argc, char **argv)
 			init_archive_deb_control(archive_handle);
 			deb_file[deb_count]->control_file = deb_extract_control_file_to_buffer(archive_handle, control_list);
 			if (deb_file[deb_count]->control_file == NULL) {
-				error_msg_and_die("Couldnt extract control file");
+				bb_error_msg_and_die("Couldnt extract control file");
 			}
-			deb_file[deb_count]->filename = xstrdup(argv[optind]);
+			deb_file[deb_count]->filename = bb_xstrdup(argv[optind]);
 			package_num = fill_package_struct(deb_file[deb_count]->control_file);
 
 			if (package_num == -1) {
-				error_msg("Invalid control file in %s", argv[optind]);
+				bb_error_msg("Invalid control file in %s", argv[optind]);
 				continue;
 			}
 			deb_file[deb_count]->package = (unsigned int) package_num;
@@ -1574,7 +1573,7 @@ int dpkg_main(int argc, char **argv)
 				search_name_hashtable(argv[optind]),
 				search_name_hashtable("ANY"), VER_ANY);
 			if (package_hashtable[deb_file[deb_count]->package] == NULL) {
-				error_msg_and_die("Package %s is uninstalled or unknown\n", argv[optind]);
+				bb_error_msg_and_die("Package %s is uninstalled or unknown\n", argv[optind]);
 			}
 			state_status = get_status(search_status_hashtable(name_hashtable[package_hashtable[deb_file[deb_count]->package]->name]), 3);
 
@@ -1582,13 +1581,13 @@ int dpkg_main(int argc, char **argv)
 			if (dpkg_opt & dpkg_opt_remove) {
 				if ((strcmp(name_hashtable[state_status], "not-installed") == 0) ||
 					(strcmp(name_hashtable[state_status], "config-files") == 0)) {
-					error_msg_and_die("%s is already removed.", name_hashtable[package_hashtable[deb_file[deb_count]->package]->name]);
+					bb_error_msg_and_die("%s is already removed.", name_hashtable[package_hashtable[deb_file[deb_count]->package]->name]);
 				}
 			}
 			else if (dpkg_opt & dpkg_opt_purge) {
 				/* if package status is "conf-files" then its ok */
 				if (strcmp(name_hashtable[state_status], "not-installed") == 0) {
-					error_msg_and_die("%s is already purged.", name_hashtable[package_hashtable[deb_file[deb_count]->package]->name]);
+					bb_error_msg_and_die("%s is already purged.", name_hashtable[package_hashtable[deb_file[deb_count]->package]->name]);
 				}
 			}
 		}
@@ -1601,7 +1600,7 @@ int dpkg_main(int argc, char **argv)
 	/* TODO: check dependencies before removing */
 	if ((dpkg_opt & dpkg_opt_force_ignore_depends) != dpkg_opt_force_ignore_depends) {
 		if (!check_deps(deb_file, 0, deb_count)) {
-			error_msg_and_die("Dependency check failed");
+			bb_error_msg_and_die("Dependency check failed");
 		}
 	}
 
diff --git a/archival/dpkg_deb.c b/archival/dpkg_deb.c
index 2c338227c..2d7383fd7 100644
--- a/archival/dpkg_deb.c
+++ b/archival/dpkg_deb.c
@@ -82,15 +82,15 @@ extern int dpkg_deb_main(int argc, char **argv)
 				tar_archive->action_data = data_extract_all;
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
 	if (optind + 2 < argc)  {
-		show_usage();
+		bb_show_usage();
 	}
 
-	tar_archive->src_fd = ar_archive->src_fd = xopen(argv[optind++], O_RDONLY);
+	tar_archive->src_fd = ar_archive->src_fd = bb_xopen(argv[optind++], O_RDONLY);
 
 	/* Workout where to extract the files */
 	/* 2nd argument is a dir name */
diff --git a/archival/gunzip.c b/archival/gunzip.c
index e9963a8d2..3350da052 100644
--- a/archival/gunzip.c
+++ b/archival/gunzip.c
@@ -82,7 +82,7 @@ extern int gunzip_main(int argc, char **argv)
 	int opt;
 
 	/* if called as zcat */
-	if (strcmp(applet_name, "zcat") == 0) {
+	if (strcmp(bb_applet_name, "zcat") == 0) {
 		flags |= gunzip_to_stdout;
 	}
 
@@ -100,7 +100,7 @@ extern int gunzip_main(int argc, char **argv)
 		case 'd':		/* Used to convert gzip to gunzip. */
 			break;
 		default:
-			show_usage();	/* exit's inside usage */
+			bb_show_usage();	/* exit's inside usage */
 		}
 	}
 
@@ -118,29 +118,29 @@ extern int gunzip_main(int argc, char **argv)
 			src_fd = fileno(stdin);
 			flags |= gunzip_to_stdout;
 		} else {
-			src_fd = xopen(old_path, O_RDONLY);
+			src_fd = bb_xopen(old_path, O_RDONLY);
 
 			/* Get the time stamp on the input file. */
 			if (stat(old_path, &stat_buf) < 0) {
-				error_msg_and_die("Couldn't stat file %s", old_path);
+				bb_error_msg_and_die("Couldn't stat file %s", old_path);
 			}
 		}
 
 		/* Check that the input is sane.  */
 		if (isatty(src_fd) && ((flags & gunzip_force) == 0)) {
-			error_msg_and_die
+			bb_error_msg_and_die
 				("compressed data not read from terminal.  Use -f to force it.");
 		}
 
 		/* Set output filename and number */
 		if (flags & gunzip_test) {
-			dst_fd = xopen("/dev/null", O_WRONLY);	/* why does test use filenum 2 ? */
+			dst_fd = bb_xopen("/dev/null", O_WRONLY);	/* why does test use filenum 2 ? */
 		} else if (flags & gunzip_to_stdout) {
 			dst_fd = fileno(stdout);
 		} else {
 			char *extension;
 
-			new_path = xstrdup(old_path);
+			new_path = bb_xstrdup(old_path);
 
 			extension = strrchr(new_path, '.');
 #ifdef CONFIG_FEATURE_GUNZIP_UNCOMPRESS
@@ -154,11 +154,11 @@ extern int gunzip_main(int argc, char **argv)
 				extension[2] = 'a';
 				extension[3] = 'r';
 			} else {
-				error_msg_and_die("Invalid extension");
+				bb_error_msg_and_die("Invalid extension");
 			}
 
 			/* Open output file */
-			dst_fd = xopen(new_path, O_WRONLY | O_CREAT);
+			dst_fd = bb_xopen(new_path, O_WRONLY | O_CREAT);
 
 			/* Set permissions on the file */
 			chmod(new_path, stat_buf.st_mode);
@@ -168,10 +168,10 @@ extern int gunzip_main(int argc, char **argv)
 		}
 
 		/* do the decompression, and cleanup */
-		if (xread_char(src_fd) == 0x1f) {
+		if (bb_xread_char(src_fd) == 0x1f) {
 			unsigned char magic2;
 			
-			magic2 = xread_char(src_fd);
+			magic2 = bb_xread_char(src_fd);
 #ifdef CONFIG_FEATURE_GUNZIP_UNCOMPRESS
 			if (magic2 == 0x9d) {
 				status = uncompress(src_fd, dst_fd);
@@ -181,14 +181,14 @@ extern int gunzip_main(int argc, char **argv)
 					check_header_gzip(src_fd);
 					status = inflate(src_fd, dst_fd);
 					if (status != 0) {
-						error_msg_and_die("Error inflating");
+						bb_error_msg_and_die("Error inflating");
 					}
 					check_trailer_gzip(src_fd);
 				} else {
-					error_msg_and_die("Invalid magic");
+					bb_error_msg_and_die("Invalid magic");
 				}
 		} else {
-			error_msg_and_die("Invalid magic");
+			bb_error_msg_and_die("Invalid magic");
 		}
 
 		if ((status != EXIT_SUCCESS) && (new_path)) {
@@ -205,7 +205,7 @@ extern int gunzip_main(int argc, char **argv)
 
 		/* delete_path will be NULL if in test mode or from stdin */
 		if (delete_path && (unlink(delete_path) == -1)) {
-			error_msg_and_die("Couldn't remove %s", delete_path);
+			bb_error_msg_and_die("Couldn't remove %s", delete_path);
 		}
 
 		free(new_path);
diff --git a/archival/gzip.c b/archival/gzip.c
index 971724d74..cabc4aa2f 100644
--- a/archival/gzip.c
+++ b/archival/gzip.c
@@ -187,7 +187,7 @@ typedef int file_t;		/* Do not use stdio */
 
 /* Diagnostic functions */
 #ifdef DEBUG
-#  define Assert(cond,msg) {if(!(cond)) error_msg(msg);}
+#  define Assert(cond,msg) {if(!(cond)) bb_error_msg(msg);}
 #  define Trace(x) fprintf x
 #  define Tracev(x) {if (verbose) fprintf x ;}
 #  define Tracevv(x) {if (verbose>1) fprintf x ;}
@@ -352,10 +352,10 @@ static void clear_bufs(void)
 	bytes_in = 0L;
 }
 
-static void write_error_msg(void)
+static void write_bb_error_msg(void)
 {
 	fputc('\n', stderr);
-	perror_msg("");
+	bb_perror_nomsg();
 	abort_gzip();
 }
 
@@ -369,7 +369,7 @@ static void write_buf(int fd, void *buf, unsigned cnt)
 
 	while ((n = write(fd, buf, cnt)) != cnt) {
 		if (n == (unsigned) (-1)) {
-			write_error_msg();
+			write_bb_error_msg();
 		}
 		cnt -= n;
 		buf = (void *) ((char *) buf + n);
@@ -977,11 +977,11 @@ static void check_match(IPos start, IPos match, int length)
 	/* check that the match is indeed a match */
 	if (memcmp((char *) window + match,
 			   (char *) window + start, length) != EQUAL) {
-		error_msg(" start %d, match %d, length %d", start, match, length);
-		error_msg("invalid match");
+		bb_error_msg(" start %d, match %d, length %d", start, match, length);
+		bb_error_msg("invalid match");
 	}
 	if (verbose > 1) {
-		error_msg("\\[%d,%d]", start - match, length);
+		bb_error_msg("\\[%d,%d]", start - match, length);
 		do {
 			putc(window[start++], stderr);
 		} while (--length != 0);
@@ -1232,7 +1232,7 @@ int gzip_main(int argc, char **argv)
 			return gunzip_main(argc, argv);
 #endif
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
@@ -1282,7 +1282,7 @@ int gzip_main(int argc, char **argv)
 			} else {
 				inFileNum = open(argv[i], O_RDONLY);
 				if (inFileNum < 0 || fstat(inFileNum, &statBuf) < 0)
-					perror_msg_and_die("%s", argv[i]);
+					bb_perror_msg_and_die("%s", argv[i]);
 				time_stamp = statBuf.st_ctime;
 				ifile_size = statBuf.st_size;
 
@@ -1299,7 +1299,7 @@ int gzip_main(int argc, char **argv)
 					outFileNum = open(path, O_RDWR | O_CREAT | O_EXCL);
 #endif
 					if (outFileNum < 0) {
-						perror_msg("%s", path);
+						bb_perror_msg("%s", path);
 						free(path);
 						continue;
 					}
@@ -1311,7 +1311,7 @@ int gzip_main(int argc, char **argv)
 			}
 
 			if (path == NULL && isatty(outFileNum) && force == 0) {
-				error_msg
+				bb_error_msg
 					("compressed data not written to a terminal. Use -f to force compression.");
 				free(path);
 				continue;
@@ -1330,7 +1330,7 @@ int gzip_main(int argc, char **argv)
 					delFileName = path;
 
 				if (unlink(delFileName) < 0)
-					perror_msg("%s", delFileName);
+					bb_perror_msg("%s", delFileName);
 			}
 
 			free(path);
@@ -1655,7 +1655,7 @@ static void set_file_type(void);
 
 #else							/* DEBUG */
 #  define send_code(c, tree) \
-     { if (verbose>1) error_msg("\ncd %3d ",(c)); \
+     { if (verbose>1) bb_error_msg("\ncd %3d ",(c)); \
        send_bits(tree[c].Code, tree[c].Len); }
 #endif
 
@@ -2035,7 +2035,7 @@ static void build_tree(tree_desc * desc)
 		tree[n].Dad = tree[m].Dad = (ush) node;
 #ifdef DUMP_BL_TREE
 		if (tree == bl_tree) {
-			error_msg("\nnode %d(%d), sons %d(%d) %d(%d)",
+			bb_error_msg("\nnode %d(%d), sons %d(%d) %d(%d)",
 					node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
 		}
 #endif
@@ -2273,7 +2273,7 @@ static ulg flush_block(char *buf, ulg stored_len, int eof)
 	if (stored_len <= opt_lenb && eof && compressed_len == 0L && seekable()) {
 		/* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */
 		if (buf == (char *) 0)
-			error_msg("block vanished");
+			bb_error_msg("block vanished");
 
 		copy_block(buf, (unsigned) stored_len, 0);	/* without header */
 		compressed_len = stored_len << 3;
@@ -2442,7 +2442,7 @@ static void set_file_type()
 		bin_freq += dyn_ltree[n++].Freq;
 	*file_type = bin_freq > (ascii_freq >> 2) ? BINARY : ASCII;
 	if (*file_type == BINARY && translate_eol) {
-		error_msg("-l used on binary file");
+		bb_error_msg("-l used on binary file");
 	}
 }
 
diff --git a/archival/libunarchive/archive_copy_file.c b/archival/libunarchive/archive_copy_file.c
index faa8059ef..675bc6ffe 100644
--- a/archival/libunarchive/archive_copy_file.c
+++ b/archival/libunarchive/archive_copy_file.c
@@ -35,7 +35,7 @@ extern void archive_copy_file(const archive_handle_t *archive_handle, const int
 		size = archive_xread(archive_handle, buffer, size);
 
 		if (write(dst_fd, buffer, size) != size) {
-			error_msg_and_die ("Short write");
+			bb_error_msg_and_die ("Short write");
 		}
 		chunksize -= size;
 	}
diff --git a/archival/libunarchive/archive_xread.c b/archival/libunarchive/archive_xread.c
index 7fde4c0b1..0b29dbfb9 100644
--- a/archival/libunarchive/archive_xread.c
+++ b/archival/libunarchive/archive_xread.c
@@ -26,7 +26,7 @@ extern ssize_t archive_xread(const archive_handle_t *archive_handle, unsigned ch
 
 	size = archive_handle->read(archive_handle->src_fd, buf, count);
 	if (size == -1) {
-		perror_msg_and_die("Read error");
+		bb_perror_msg_and_die("Read error");
 	}
 
 	return(size);
diff --git a/archival/libunarchive/archive_xread_all.c b/archival/libunarchive/archive_xread_all.c
index ef8cc0141..cfe046b27 100644
--- a/archival/libunarchive/archive_xread_all.c
+++ b/archival/libunarchive/archive_xread_all.c
@@ -26,7 +26,7 @@ extern void archive_xread_all(const archive_handle_t *archive_handle, void *buf,
 
 	size = archive_xread(archive_handle, buf, count);
 	if (size != count) {
-		error_msg_and_die("Short read");
+		bb_error_msg_and_die("Short read");
 	}
 	return;
 }
diff --git a/archival/libunarchive/archive_xread_all_eof.c b/archival/libunarchive/archive_xread_all_eof.c
index 3cfbbd8d1..23719cd7b 100644
--- a/archival/libunarchive/archive_xread_all_eof.c
+++ b/archival/libunarchive/archive_xread_all_eof.c
@@ -26,7 +26,7 @@ extern ssize_t archive_xread_all_eof(archive_handle_t *archive_handle, unsigned
 
 	size = archive_xread(archive_handle, buf, count);
 	if ((size != 0) && (size != count)) {
-		perror_msg_and_die("Short read, read %d of %d", size, count);
+		bb_perror_msg_and_die("Short read, read %d of %d", size, count);
 	}
 	return(size);
 }
diff --git a/archival/libunarchive/check_header_gzip.c b/archival/libunarchive/check_header_gzip.c
index d661df7cc..13832c240 100644
--- a/archival/libunarchive/check_header_gzip.c
+++ b/archival/libunarchive/check_header_gzip.c
@@ -15,11 +15,11 @@ extern void check_header_gzip(int src_fd)
 		} formated;
 	} header;
 
-	xread_all(src_fd, header.raw, 8);
+	bb_xread_all(src_fd, header.raw, 8);
 
 	/* Check the compression method */
 	if (header.formated.method != 8) {
-		error_msg_and_die("Unknown compression method %d",
+		bb_error_msg_and_die("Unknown compression method %d",
 						  header.formated.method);
 	}
 
@@ -27,10 +27,10 @@ extern void check_header_gzip(int src_fd)
 		/* bit 2 set: extra field present */
 		unsigned char extra_short;
 
-		extra_short = xread_char(src_fd) + (xread_char(src_fd) << 8);
+		extra_short = bb_xread_char(src_fd) + (bb_xread_char(src_fd) << 8);
 		while (extra_short > 0) {
 			/* Ignore extra field */
-			xread_char(src_fd);
+			bb_xread_char(src_fd);
 			extra_short--;
 		}
 	}
@@ -38,19 +38,19 @@ extern void check_header_gzip(int src_fd)
 	/* Discard original name if any */
 	if (header.formated.flags & 0x08) {
 		/* bit 3 set: original file name present */
-		while(xread_char(src_fd) != 0);
+		while(bb_xread_char(src_fd) != 0);
 	}
 
 	/* Discard file comment if any */
 	if (header.formated.flags & 0x10) {
 		/* bit 4 set: file comment present */
-		while(xread_char(src_fd) != 0);
+		while(bb_xread_char(src_fd) != 0);
 	}
 
 	/* Read the header checksum */
 	if (header.formated.flags & 0x02) {
-		xread_char(src_fd);
-		xread_char(src_fd);
+		bb_xread_char(src_fd);
+		bb_xread_char(src_fd);
 	}
 
 	return;
diff --git a/archival/libunarchive/data_extract_all.c b/archival/libunarchive/data_extract_all.c
index 1eb8bb388..77b4de593 100644
--- a/archival/libunarchive/data_extract_all.c
+++ b/archival/libunarchive/data_extract_all.c
@@ -34,8 +34,8 @@ extern void data_extract_all(archive_handle_t *archive_handle)
 	int res;
 
 	if (archive_handle->flags & ARCHIVE_CREATE_LEADING_DIRS) {
-		char *name = xstrdup(file_header->name);
-		make_directory (dirname(name), 0777, FILEUTILS_RECUR);
+		char *name = bb_xstrdup(file_header->name);
+		bb_make_directory (dirname(name), 0777, FILEUTILS_RECUR);
 		free(name);
 	}                  
 
@@ -47,13 +47,13 @@ extern void data_extract_all(archive_handle_t *archive_handle)
 				/* hard link */
 				res = link(file_header->link_name, file_header->name);
 				if ((res == -1) && !(archive_handle->flags & ARCHIVE_EXTRACT_QUIET)) {
-					perror_msg("Couldnt create hard link");
+					bb_perror_msg("Couldnt create hard link");
 				}
 			} else
 #endif
 			{
 				/* Regular file */
-				dst_fd = xopen(file_header->name, O_WRONLY | O_CREAT);
+				dst_fd = bb_xopen(file_header->name, O_WRONLY | O_CREAT);
 				archive_copy_file(archive_handle, dst_fd);
 				close(dst_fd);
 			}
@@ -63,7 +63,7 @@ extern void data_extract_all(archive_handle_t *archive_handle)
 			unlink(file_header->name);
 			res = mkdir(file_header->name, file_header->mode);
 			if ((res == -1) && !(archive_handle->flags & ARCHIVE_EXTRACT_QUIET)) {
-				perror_msg("extract_archive: %s", file_header->name);
+				bb_perror_msg("extract_archive: %s", file_header->name);
 			}
 			break;
 		case S_IFLNK:
@@ -71,7 +71,7 @@ extern void data_extract_all(archive_handle_t *archive_handle)
 			unlink(file_header->name);
 			res = symlink(file_header->link_name, file_header->name);
 			if ((res == -1) && !(archive_handle->flags & ARCHIVE_EXTRACT_QUIET)) {
-				perror_msg("Cannot create symlink from %s to '%s'", file_header->name, file_header->link_name);
+				bb_perror_msg("Cannot create symlink from %s to '%s'", file_header->name, file_header->link_name);
 			}
 			break;
 		case S_IFSOCK:
@@ -81,11 +81,11 @@ extern void data_extract_all(archive_handle_t *archive_handle)
 			unlink(file_header->name);
 			res = mknod(file_header->name, file_header->mode, file_header->device);
 			if ((res == -1) && !(archive_handle->flags & ARCHIVE_EXTRACT_QUIET)) {
-				perror_msg("Cannot create node %s", file_header->name);
+				bb_perror_msg("Cannot create node %s", file_header->name);
 			}
 			break;
 		default:
-			error_msg_and_die("Unrecognised file type");
+			bb_error_msg_and_die("Unrecognised file type");
 	}
 
 	chmod(file_header->name, file_header->mode);
diff --git a/archival/libunarchive/decompress_bunzip2.c b/archival/libunarchive/decompress_bunzip2.c
index 4b611b833..0164b77e0 100644
--- a/archival/libunarchive/decompress_bunzip2.c
+++ b/archival/libunarchive/decompress_bunzip2.c
@@ -1548,7 +1548,7 @@ extern ssize_t read_bz2(int fd, void *buf, size_t count)
 
 	while (1) {
 		if (bzf->strm.avail_in == 0) {
-			n = xread(bzf->fd, bzf->buf, BZ_MAX_UNUSED);
+			n = bb_xread(bzf->fd, bzf->buf, BZ_MAX_UNUSED);
 			if (n == 0) {
 				break;
 			}
@@ -1560,7 +1560,7 @@ extern ssize_t read_bz2(int fd, void *buf, size_t count)
 		ret = BZ2_bzDecompress(&(bzf->strm));
 
 		if ((ret != BZ_OK) && (ret != BZ_STREAM_END)) {
-			error_msg_and_die("Error decompressing");
+			bb_error_msg_and_die("Error decompressing");
 		}
 
 		if (ret == BZ_STREAM_END) {
@@ -1628,12 +1628,12 @@ extern unsigned char uncompressStream(int src_fd, int dst_fd)
 		while (bzerr == BZ_OK) {
 			nread = read_bz2(src_fd, obuf, 5000);
 			if (bzerr == BZ_DATA_ERROR_MAGIC) {
-				error_msg_and_die("invalid magic");
+				bb_error_msg_and_die("invalid magic");
 			}
 			if (((bzerr == BZ_OK) || (bzerr == BZ_STREAM_END)) && (nread > 0)) {
 				if (write(dst_fd, obuf, nread) != nread) {
 					BZ2_bzReadClose();
-					perror_msg_and_die("Couldnt write to file");
+					bb_perror_msg_and_die("Couldnt write to file");
 				}
 			}
 		}
diff --git a/archival/libunarchive/decompress_uncompress.c b/archival/libunarchive/decompress_uncompress.c
index 192e98126..9851ca39d 100644
--- a/archival/libunarchive/decompress_uncompress.c
+++ b/archival/libunarchive/decompress_uncompress.c
@@ -121,14 +121,14 @@ extern int uncompress(int fd_in, int fd_out)
 
 	insize = 0;
 
-	inbuf[0] = xread_char(fd_in);
+	inbuf[0] = bb_xread_char(fd_in);
 
 	maxbits = inbuf[0] & BIT_MASK;
 	block_mode = inbuf[0] & BLOCK_MODE;
 	maxmaxcode = MAXCODE(maxbits);
 
 	if (maxbits > BITS) {
-		error_msg("compressed with %d bits, can only handle %d bits", maxbits,
+		bb_error_msg("compressed with %d bits, can only handle %d bits", maxbits,
 				  BITS);
 		return -1;
 	}
@@ -227,11 +227,11 @@ extern int uncompress(int fd_in, int fd_out)
 					posbits -= n_bits;
 					p = &inbuf[posbits >> 3];
 
-					error_msg
+					bb_error_msg
 						("insize:%d posbits:%d inbuf:%02X %02X %02X %02X %02X (%d)",
 						 insize, posbits, p[-1], p[0], p[1], p[2], p[3],
 						 (posbits & 07));
-					error_msg("uncompress: corrupt input");
+					bb_error_msg("uncompress: corrupt input");
 					return -1;
 				}
 
diff --git a/archival/libunarchive/decompress_unzip.c b/archival/libunarchive/decompress_unzip.c
index 3a7334ce9..2401cf831 100644
--- a/archival/libunarchive/decompress_unzip.c
+++ b/archival/libunarchive/decompress_unzip.c
@@ -150,7 +150,7 @@ static void fill_bytebuffer(void)
 		/* Leave the first 4 bytes empty so we can always unwind the bitbuffer 
 		 * to the front of the bytebuffer, leave 4 bytes free at end of tail
 		 * so we can easily top up buffer in check_trailer_gzip() */
-		bytebuffer_size = 4 + xread(gunzip_src_fd, &bytebuffer[4], BYTEBUFFER_MAX - 8);
+		bytebuffer_size = 4 + bb_xread(gunzip_src_fd, &bytebuffer[4], BYTEBUFFER_MAX - 8);
 		bytebuffer_offset = 4;
 	}
 }
@@ -448,7 +448,7 @@ static int inflate_codes(huft_t * my_tl, huft_t * my_td, const unsigned int my_b
 		if ((e = (t = tl + ((unsigned) b & ml))->e) > 16)
 			do {
 				if (e == 99) {
-					error_msg_and_die("inflate_codes error 1");;
+					bb_error_msg_and_die("inflate_codes error 1");;
 				}
 				b >>= t->b;
 				k -= t->b;
@@ -484,7 +484,7 @@ static int inflate_codes(huft_t * my_tl, huft_t * my_td, const unsigned int my_b
 			if ((e = (t = td + ((unsigned) b & md))->e) > 16)
 				do {
 					if (e == 99)
-						error_msg_and_die("inflate_codes error 2");;
+						bb_error_msg_and_die("inflate_codes error 2");;
 					b >>= t->b;
 					k -= t->b;
 					e -= 16;
@@ -821,7 +821,7 @@ static int inflate_block(int *e)
 
 		if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0) {
 			if (i == 1) {
-				error_msg_and_die("Incomplete literal tree");
+				bb_error_msg_and_die("Incomplete literal tree");
 				huft_free(tl);
 			}
 			return i;	/* incomplete code set */
@@ -830,7 +830,7 @@ static int inflate_block(int *e)
 		bd = dbits;
 		if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0) {
 			if (i == 1) {
-				error_msg_and_die("incomplete distance tree");
+				bb_error_msg_and_die("incomplete distance tree");
 				huft_free(td);
 			}
 			huft_free(tl);
@@ -846,7 +846,7 @@ static int inflate_block(int *e)
 	}
 	default:
 		/* bad block type */
-		error_msg_and_die("bad block type %d\n", t);
+		bb_error_msg_and_die("bad block type %d\n", t);
 	}
 }
 
@@ -884,7 +884,7 @@ static int inflate_get_next_window(void)
 					break;
 			case -2:	ret = inflate_codes(0,0,0,0,0);
 					break;
-			default:	error_msg_and_die("inflate error %d", method);
+			default:	bb_error_msg_and_die("inflate error %d", method);
 		}
 
 		if (ret == 1) {
@@ -975,16 +975,16 @@ extern void GZ_gzReadClose(void)
 	ssize_t nread, nwrote;
 
 	GZ_gzReadOpen(in, 0, 0);
-	while(1) { // Robbed from copyfd.c
+	while(1) { // Robbed from bb_copyfd.c
 		nread = read_gz(in, buf, sizeof(buf));
 		if (nread == 0) break; // no data to write
 		else if (nread == -1) {
-			perror_msg("read");
+			bb_perror_msg("read");
 			return -1;
 		}
-		nwrote = full_write(out, buf, nread);
+		nwrote = bb_full_write(out, buf, nread);
 		if (nwrote == -1) {
-			perror_msg("write");
+			bb_perror_msg("write");
 			return -1;
 		}
 	}
@@ -998,9 +998,9 @@ extern int inflate(int in, int out)
 	GZ_gzReadOpen(in, 0, 0);
 	while(1) {
 		int ret = inflate_get_next_window();
-		nwrote = full_write(out, gunzip_window, gunzip_outbuf_count);
+		nwrote = bb_full_write(out, gunzip_window, gunzip_outbuf_count);
 		if (nwrote == -1) {
-			perror_msg("write");
+			bb_perror_msg("write");
 			return -1;
 		}
 		if (ret == 0) break;
@@ -1017,7 +1017,7 @@ extern void check_trailer_gzip(int src_fd)
 	/* top up the input buffer with the rest of the trailer */
 	count = bytebuffer_size - bytebuffer_offset;
 	if (count < 8) {
-		xread_all(src_fd, &bytebuffer[bytebuffer_size], 8 - count);
+		bb_xread_all(src_fd, &bytebuffer[bytebuffer_size], 8 - count);
 		bytebuffer_size += 8 - count;
 	}
 	for (count = 0; count != 4; count++) {
@@ -1027,14 +1027,14 @@ extern void check_trailer_gzip(int src_fd)
 
 	/* Validate decompression - crc */
 	if (stored_crc != (gunzip_crc ^ 0xffffffffL)) {
-		error_msg_and_die("crc error");
+		bb_error_msg_and_die("crc error");
 	}
 
 	/* Validate decompression - size */
 	if (gunzip_bytes_out !=
 		(bytebuffer[bytebuffer_offset] | (bytebuffer[bytebuffer_offset+1] << 8) |
 		(bytebuffer[bytebuffer_offset+2] << 16) | (bytebuffer[bytebuffer_offset+3] << 24))) {
-		error_msg_and_die("Incorrect length, but crc is correct");
+		bb_error_msg_and_die("Incorrect length, but crc is correct");
 	}
 
 }
diff --git a/archival/libunarchive/get_header_ar.c b/archival/libunarchive/get_header_ar.c
index 1e0e6c12d..6c576a8da 100644
--- a/archival/libunarchive/get_header_ar.c
+++ b/archival/libunarchive/get_header_ar.c
@@ -41,7 +41,7 @@ extern char get_header_ar(archive_handle_t *archive_handle)
 	static unsigned int ar_long_name_size;
 #endif
 
-	/* dont use xread as we want to handle the error ourself */
+	/* dont use bb_xread as we want to handle the error ourself */
 	if (read(archive_handle->src_fd, ar.raw, 60) != 60) {
 		/* End Of File */
 		return(EXIT_FAILURE);
@@ -51,14 +51,14 @@ extern char get_header_ar(archive_handle_t *archive_handle)
 	if (ar.raw[0] == '\n') {
 		/* fix up the header, we started reading 1 byte too early */
 		memmove(ar.raw, &ar.raw[1], 59);
-		ar.raw[59] = xread_char(archive_handle->src_fd);
+		ar.raw[59] = bb_xread_char(archive_handle->src_fd);
 		archive_handle->offset++;
 	}
 	archive_handle->offset += 60;
 		
 	/* align the headers based on the header magic */
 	if ((ar.formated.magic[0] != '`') || (ar.formated.magic[1] != '\n')) {
-		error_msg_and_die("Invalid ar header");
+		bb_error_msg_and_die("Invalid ar header");
 	}
 
 	typed->mode = strtol(ar.formated.mode, NULL, 8);
@@ -76,7 +76,7 @@ extern char get_header_ar(archive_handle_t *archive_handle)
 			 * in static variable long_names for use in future entries */
 			ar_long_name_size = typed->size;
 			ar_long_names = xmalloc(ar_long_name_size);
-			xread_all(archive_handle->src_fd, ar_long_names, ar_long_name_size);
+			bb_xread_all(archive_handle->src_fd, ar_long_names, ar_long_name_size);
 			archive_handle->offset += ar_long_name_size;
 			/* This ar entries data section only contained filenames for other records
 			 * they are stored in the static ar_long_names for future reference */
@@ -90,16 +90,16 @@ extern char get_header_ar(archive_handle_t *archive_handle)
 			(saved in variable long_name) that conatains the real filename */
 			const unsigned int long_offset = atoi(&ar.formated.name[1]);
 			if (long_offset >= ar_long_name_size) {
-				error_msg_and_die("Cant resolve long filename");
+				bb_error_msg_and_die("Cant resolve long filename");
 			}
-			typed->name = xstrdup(ar_long_names + long_offset);
+			typed->name = bb_xstrdup(ar_long_names + long_offset);
 		}
 #else
-		error_msg_and_die("long filenames not supported");
+		bb_error_msg_and_die("long filenames not supported");
 #endif
 	} else {
 		/* short filenames */
-               typed->name = xstrndup(ar.formated.name, 16);
+               typed->name = bb_xstrndup(ar.formated.name, 16);
 	}
 
 	typed->name[strcspn(typed->name, " /")] = '\0';
diff --git a/archival/libunarchive/get_header_cpio.c b/archival/libunarchive/get_header_cpio.c
index ea0857840..975e2a4bd 100644
--- a/archival/libunarchive/get_header_cpio.c
+++ b/archival/libunarchive/get_header_cpio.c
@@ -46,7 +46,7 @@ extern char get_header_cpio(archive_handle_t *archive_handle)
 		oldtmp = NULL;
 
 		while (tmp) {
-			error_msg_and_die("need to fix this\n");
+			bb_error_msg_and_die("need to fix this\n");
 			if (tmp->entry->link_name) { /* Found a hardlink ready to be extracted */
 				file_header = tmp->entry;
 				if (oldtmp) {
@@ -78,11 +78,11 @@ extern char get_header_cpio(archive_handle_t *archive_handle)
 			cpio_header[2],
 			cpio_header[3],
 			cpio_header[4]);
-		error_msg_and_die("Unsupported cpio format");
+		bb_error_msg_and_die("Unsupported cpio format");
 	}
 		
 	if ((cpio_header[5] != '1') && (cpio_header[5] != '2')) {
-		error_msg_and_die("Unsupported cpio format, use newc or crc");
+		bb_error_msg_and_die("Unsupported cpio format, use newc or crc");
 	}
 
 	{
@@ -109,7 +109,7 @@ extern char get_header_cpio(archive_handle_t *archive_handle)
 			hardlinks_t *tmp = saved_hardlinks;
 			hardlinks_t *oldtmp = NULL;
 			while (tmp) {
-				error_msg("%s not created: cannot resolve hardlink", tmp->entry->name);
+				bb_error_msg("%s not created: cannot resolve hardlink", tmp->entry->name);
 				oldtmp = tmp;
 				tmp = tmp->next;
 				free (oldtmp->entry->name);
@@ -142,13 +142,13 @@ extern char get_header_cpio(archive_handle_t *archive_handle)
 			pending_hardlinks = 1;
 			while (tmp) {
 				if (tmp->inode == inode) {
-					tmp->entry->link_name = xstrdup(file_header->name);
+					tmp->entry->link_name = bb_xstrdup(file_header->name);
 					nlink--;
 				}
 				tmp = tmp->next;
 			}
 			if (nlink > 1) {
-				error_msg("error resolving hardlink: did you create the archive with GNU cpio 2.0-2.2?");
+				bb_error_msg("error resolving hardlink: did you create the archive with GNU cpio 2.0-2.2?");
 			}
 		}
 	}
@@ -165,11 +165,11 @@ extern char get_header_cpio(archive_handle_t *archive_handle)
 			if ((archive_handle->flags & ARCHIVE_EXTRACT_UNCONDITIONAL) || (statbuf.st_mtime < file_header->mtime)) {
 				/* Remove file if flag set or its older than the file to be extracted */
 				if (unlink(file_header->name) == -1) {
-					perror_msg_and_die("Couldnt remove old file");
+					bb_perror_msg_and_die("Couldnt remove old file");
 				}
 			} else {
 				if (! archive_handle->flags & ARCHIVE_EXTRACT_QUIET) {
-					error_msg("%s not created: newer or same age file exists", file_header->name);
+					bb_error_msg("%s not created: newer or same age file exists", file_header->name);
 				}
 				extract_flag = FALSE;
 			}
diff --git a/archival/libunarchive/get_header_tar.c b/archival/libunarchive/get_header_tar.c
index 2cb141ede..365f464dd 100644
--- a/archival/libunarchive/get_header_tar.c
+++ b/archival/libunarchive/get_header_tar.c
@@ -75,7 +75,7 @@ extern char get_header_tar(archive_handle_t *archive_handle)
 #ifdef CONFIG_FEATURE_TAR_OLDGNU_COMPATABILITY
 		if (strncmp(tar.formated.magic, "\0\0\0\0\0", 5) != 0)
 #endif
-			error_msg_and_die("Invalid tar magic");
+			bb_error_msg_and_die("Invalid tar magic");
 	}
 	/* Do checksum on headers */
 	for (i =  0; i < 148 ; i++) {
@@ -86,7 +86,7 @@ extern char get_header_tar(archive_handle_t *archive_handle)
 		sum += tar.raw[i];
 	}
 	if (sum != strtol(tar.formated.chksum, NULL, 8)) {
-		error_msg("Invalid tar header checksum");
+		bb_error_msg("Invalid tar header checksum");
 		return(EXIT_FAILURE);
 	}
 
@@ -116,7 +116,7 @@ extern char get_header_tar(archive_handle_t *archive_handle)
 	file_header->size = strtol(tar.formated.size, NULL, 8);
 	file_header->mtime = strtol(tar.formated.mtime, NULL, 8);
 	file_header->link_name = (tar.formated.linkname[0] != '\0') ? 
-	    xstrdup(tar.formated.linkname) : NULL;
+	    bb_xstrdup(tar.formated.linkname) : NULL;
 	file_header->device = (dev_t) ((strtol(tar.formated.devmajor, NULL, 8) << 8) +
 				 strtol(tar.formated.devminor, NULL, 8));
 
@@ -129,7 +129,7 @@ extern char get_header_tar(archive_handle_t *archive_handle)
 		file_header->mode |= S_IFREG;
 		break;
 	case '1':
-		error_msg("Internal hard link not supported");
+		bb_error_msg("Internal hard link not supported");
 		break;
 	case '2':
 		file_header->mode |= S_IFLNK;
@@ -170,7 +170,7 @@ extern char get_header_tar(archive_handle_t *archive_handle)
 	case 'N':
 	case 'S':
 	case 'V':
-		error_msg("Ignoring GNU extension type %c", tar.formated.typeflag);
+		bb_error_msg("Ignoring GNU extension type %c", tar.formated.typeflag);
 # endif
 	}
 #endif
diff --git a/archival/libunarchive/get_header_tar_gz.c b/archival/libunarchive/get_header_tar_gz.c
index a4355d24c..7792432ae 100644
--- a/archival/libunarchive/get_header_tar_gz.c
+++ b/archival/libunarchive/get_header_tar_gz.c
@@ -25,7 +25,7 @@ extern char get_header_tar_gz(archive_handle_t *archive_handle)
 
 	archive_xread_all(archive_handle, &magic, 2);
 	if ((magic[0] != 0x1f) || (magic[1] != 0x8b)) {
-		error_msg_and_die("Invalid gzip magic");
+		bb_error_msg_and_die("Invalid gzip magic");
 	}
 
 	check_header_gzip(archive_handle->src_fd);
diff --git a/archival/libunarchive/header_verbose_list.c b/archival/libunarchive/header_verbose_list.c
index ff7b3bca2..6739dd393 100644
--- a/archival/libunarchive/header_verbose_list.c
+++ b/archival/libunarchive/header_verbose_list.c
@@ -9,7 +9,7 @@ extern void header_verbose_list(const file_header_t *file_header)
 	struct tm *mtime = localtime(&file_header->mtime);
 
 	printf("%s %d/%d%10u %4u-%02u-%02u %02u:%02u:%02u %s",
-		mode_string(file_header->mode),
+		bb_mode_string(file_header->mode),
 		file_header->uid,
 		file_header->gid,
 		(unsigned int) file_header->size,
diff --git a/archival/libunarchive/seek_by_jump.c b/archival/libunarchive/seek_by_jump.c
index 282397616..578870d9b 100644
--- a/archival/libunarchive/seek_by_jump.c
+++ b/archival/libunarchive/seek_by_jump.c
@@ -30,6 +30,6 @@ extern void seek_by_jump(const archive_handle_t *archive_handle, const unsigned
 			seek_by_char(archive_handle, amount);
 		} else
 #endif
-			perror_msg_and_die("Seek failure");
+			bb_perror_msg_and_die("Seek failure");
 	}
 }
diff --git a/archival/libunarchive/uncompress.c b/archival/libunarchive/uncompress.c
index 192e98126..9851ca39d 100644
--- a/archival/libunarchive/uncompress.c
+++ b/archival/libunarchive/uncompress.c
@@ -121,14 +121,14 @@ extern int uncompress(int fd_in, int fd_out)
 
 	insize = 0;
 
-	inbuf[0] = xread_char(fd_in);
+	inbuf[0] = bb_xread_char(fd_in);
 
 	maxbits = inbuf[0] & BIT_MASK;
 	block_mode = inbuf[0] & BLOCK_MODE;
 	maxmaxcode = MAXCODE(maxbits);
 
 	if (maxbits > BITS) {
-		error_msg("compressed with %d bits, can only handle %d bits", maxbits,
+		bb_error_msg("compressed with %d bits, can only handle %d bits", maxbits,
 				  BITS);
 		return -1;
 	}
@@ -227,11 +227,11 @@ extern int uncompress(int fd_in, int fd_out)
 					posbits -= n_bits;
 					p = &inbuf[posbits >> 3];
 
-					error_msg
+					bb_error_msg
 						("insize:%d posbits:%d inbuf:%02X %02X %02X %02X %02X (%d)",
 						 insize, posbits, p[-1], p[0], p[1], p[2], p[3],
 						 (posbits & 07));
-					error_msg("uncompress: corrupt input");
+					bb_error_msg("uncompress: corrupt input");
 					return -1;
 				}
 
diff --git a/archival/libunarchive/unpack_ar_archive.c b/archival/libunarchive/unpack_ar_archive.c
index afa3672ad..e8f113bcf 100644
--- a/archival/libunarchive/unpack_ar_archive.c
+++ b/archival/libunarchive/unpack_ar_archive.c
@@ -26,7 +26,7 @@ extern void unpack_ar_archive(archive_handle_t *ar_archive)
 
 	archive_xread_all(ar_archive, magic, 7);
 	if (strncmp(magic, "!<arch>", 7) != 0) {
-		error_msg_and_die("Invalid ar magic");
+		bb_error_msg_and_die("Invalid ar magic");
 	}
 	ar_archive->offset += 7;
 
diff --git a/archival/libunarchive/unzip.c b/archival/libunarchive/unzip.c
index 3a7334ce9..2401cf831 100644
--- a/archival/libunarchive/unzip.c
+++ b/archival/libunarchive/unzip.c
@@ -150,7 +150,7 @@ static void fill_bytebuffer(void)
 		/* Leave the first 4 bytes empty so we can always unwind the bitbuffer 
 		 * to the front of the bytebuffer, leave 4 bytes free at end of tail
 		 * so we can easily top up buffer in check_trailer_gzip() */
-		bytebuffer_size = 4 + xread(gunzip_src_fd, &bytebuffer[4], BYTEBUFFER_MAX - 8);
+		bytebuffer_size = 4 + bb_xread(gunzip_src_fd, &bytebuffer[4], BYTEBUFFER_MAX - 8);
 		bytebuffer_offset = 4;
 	}
 }
@@ -448,7 +448,7 @@ static int inflate_codes(huft_t * my_tl, huft_t * my_td, const unsigned int my_b
 		if ((e = (t = tl + ((unsigned) b & ml))->e) > 16)
 			do {
 				if (e == 99) {
-					error_msg_and_die("inflate_codes error 1");;
+					bb_error_msg_and_die("inflate_codes error 1");;
 				}
 				b >>= t->b;
 				k -= t->b;
@@ -484,7 +484,7 @@ static int inflate_codes(huft_t * my_tl, huft_t * my_td, const unsigned int my_b
 			if ((e = (t = td + ((unsigned) b & md))->e) > 16)
 				do {
 					if (e == 99)
-						error_msg_and_die("inflate_codes error 2");;
+						bb_error_msg_and_die("inflate_codes error 2");;
 					b >>= t->b;
 					k -= t->b;
 					e -= 16;
@@ -821,7 +821,7 @@ static int inflate_block(int *e)
 
 		if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0) {
 			if (i == 1) {
-				error_msg_and_die("Incomplete literal tree");
+				bb_error_msg_and_die("Incomplete literal tree");
 				huft_free(tl);
 			}
 			return i;	/* incomplete code set */
@@ -830,7 +830,7 @@ static int inflate_block(int *e)
 		bd = dbits;
 		if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0) {
 			if (i == 1) {
-				error_msg_and_die("incomplete distance tree");
+				bb_error_msg_and_die("incomplete distance tree");
 				huft_free(td);
 			}
 			huft_free(tl);
@@ -846,7 +846,7 @@ static int inflate_block(int *e)
 	}
 	default:
 		/* bad block type */
-		error_msg_and_die("bad block type %d\n", t);
+		bb_error_msg_and_die("bad block type %d\n", t);
 	}
 }
 
@@ -884,7 +884,7 @@ static int inflate_get_next_window(void)
 					break;
 			case -2:	ret = inflate_codes(0,0,0,0,0);
 					break;
-			default:	error_msg_and_die("inflate error %d", method);
+			default:	bb_error_msg_and_die("inflate error %d", method);
 		}
 
 		if (ret == 1) {
@@ -975,16 +975,16 @@ extern void GZ_gzReadClose(void)
 	ssize_t nread, nwrote;
 
 	GZ_gzReadOpen(in, 0, 0);
-	while(1) { // Robbed from copyfd.c
+	while(1) { // Robbed from bb_copyfd.c
 		nread = read_gz(in, buf, sizeof(buf));
 		if (nread == 0) break; // no data to write
 		else if (nread == -1) {
-			perror_msg("read");
+			bb_perror_msg("read");
 			return -1;
 		}
-		nwrote = full_write(out, buf, nread);
+		nwrote = bb_full_write(out, buf, nread);
 		if (nwrote == -1) {
-			perror_msg("write");
+			bb_perror_msg("write");
 			return -1;
 		}
 	}
@@ -998,9 +998,9 @@ extern int inflate(int in, int out)
 	GZ_gzReadOpen(in, 0, 0);
 	while(1) {
 		int ret = inflate_get_next_window();
-		nwrote = full_write(out, gunzip_window, gunzip_outbuf_count);
+		nwrote = bb_full_write(out, gunzip_window, gunzip_outbuf_count);
 		if (nwrote == -1) {
-			perror_msg("write");
+			bb_perror_msg("write");
 			return -1;
 		}
 		if (ret == 0) break;
@@ -1017,7 +1017,7 @@ extern void check_trailer_gzip(int src_fd)
 	/* top up the input buffer with the rest of the trailer */
 	count = bytebuffer_size - bytebuffer_offset;
 	if (count < 8) {
-		xread_all(src_fd, &bytebuffer[bytebuffer_size], 8 - count);
+		bb_xread_all(src_fd, &bytebuffer[bytebuffer_size], 8 - count);
 		bytebuffer_size += 8 - count;
 	}
 	for (count = 0; count != 4; count++) {
@@ -1027,14 +1027,14 @@ extern void check_trailer_gzip(int src_fd)
 
 	/* Validate decompression - crc */
 	if (stored_crc != (gunzip_crc ^ 0xffffffffL)) {
-		error_msg_and_die("crc error");
+		bb_error_msg_and_die("crc error");
 	}
 
 	/* Validate decompression - size */
 	if (gunzip_bytes_out !=
 		(bytebuffer[bytebuffer_offset] | (bytebuffer[bytebuffer_offset+1] << 8) |
 		(bytebuffer[bytebuffer_offset+2] << 16) | (bytebuffer[bytebuffer_offset+3] << 24))) {
-		error_msg_and_die("Incorrect length, but crc is correct");
+		bb_error_msg_and_die("Incorrect length, but crc is correct");
 	}
 
 }
diff --git a/archival/rpm.c b/archival/rpm.c
index 61486cb03..5bde53285 100644
--- a/archival/rpm.c
+++ b/archival/rpm.c
@@ -116,7 +116,7 @@ int rpm_main(int argc, char **argv)
 			break;
 		case 'q': // First arg: Query mode
 			if (!func) func |= rpm_query;
-			else show_usage();
+			else bb_show_usage();
 			break;
 		case 'p': // Query a package
 			func |= rpm_query_package;
@@ -133,13 +133,13 @@ int rpm_main(int argc, char **argv)
 			func |= rpm_query_list_config;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
-	if (optind == argc) show_usage();
+	if (optind == argc) bb_show_usage();
 	while (optind < argc) {
-		rpm_fd = xopen(argv[optind], O_RDONLY);
+		rpm_fd = bb_xopen(argv[optind], O_RDONLY);
 		mytags = rpm_gettags(rpm_fd, (int *) &tagcount);
 		offset = lseek(rpm_fd, 0, SEEK_CUR);
 		if (!mytags) { printf("Error reading rpm header\n"); exit(-1); }
@@ -206,9 +206,9 @@ void extract_cpio_gz(int fd) {
 	archive_handle->src_fd = fd;
 	archive_handle->offset = 0;
 	
-	xread_all(archive_handle->src_fd, &magic, 2);
+	bb_xread_all(archive_handle->src_fd, &magic, 2);
 	if ((magic[0] != 0x1f) || (magic[1] != 0x8b)) {
-		error_msg_and_die("Invalid gzip magic");
+		bb_error_msg_and_die("Invalid gzip magic");
 	}
 	check_header_gzip(archive_handle->src_fd);	
 	chdir("/"); // Install RPM's to root
@@ -314,7 +314,7 @@ void fileaction_dobackup(char *filename, int fileref)
 	if (rpm_getint(RPMTAG_FILEFLAGS, fileref) & RPMFILE_CONFIG) { /* Only need to backup config files */
 		stat_res = lstat (filename, &oldfile);
 		if (stat_res == 0 && S_ISREG(oldfile.st_mode)) { /* File already exists  - really should check MD5's etc to see if different */
-			newname = xstrdup(filename);
+			newname = bb_xstrdup(filename);
 			newname = strcat(newname, ".rpmorig");
 			copy_file(filename, newname, FILEUTILS_RECUR | FILEUTILS_PRESERVE_STATUS);
 			remove_file(filename, FILEUTILS_RECUR | FILEUTILS_FORCE);
diff --git a/archival/rpm2cpio.c b/archival/rpm2cpio.c
index 66f680869..bb9f69573 100644
--- a/archival/rpm2cpio.c
+++ b/archival/rpm2cpio.c
@@ -52,12 +52,12 @@ void skip_header(int rpm_fd)
 {
 	struct rpm_header header;
 
-	xread_all(rpm_fd, &header, sizeof(struct rpm_header));
+	bb_xread_all(rpm_fd, &header, sizeof(struct rpm_header));
 	if (strncmp((char *) &header.magic, RPM_HEADER_MAGIC, 3) != 0) {
-		error_msg_and_die("Invalid RPM header magic"); /* Invalid magic */
+		bb_error_msg_and_die("Invalid RPM header magic"); /* Invalid magic */
 	}
 	if (header.version != 1) {
-		error_msg_and_die("Unsupported RPM header version"); /* This program only supports v1 headers */
+		bb_error_msg_and_die("Unsupported RPM header version"); /* This program only supports v1 headers */
 	}
 	header.entries = ntohl(header.entries);
 	header.size = ntohl(header.size);
@@ -75,12 +75,12 @@ extern int rpm2cpio_main(int argc, char **argv)
 	if (argc == 1) {
 		rpm_fd = fileno(stdin);
 	} else {
-		rpm_fd = xopen(argv[1], O_RDONLY);
+		rpm_fd = bb_xopen(argv[1], O_RDONLY);
 	}
 
-	xread_all(rpm_fd, &lead, sizeof(struct rpm_lead));
+	bb_xread_all(rpm_fd, &lead, sizeof(struct rpm_lead));
 	if (strncmp((char *) &lead.magic, RPM_MAGIC, 4) != 0) {
-		error_msg_and_die("Invalid RPM magic"); /* Just check the magic, the rest is irrelevant */
+		bb_error_msg_and_die("Invalid RPM magic"); /* Just check the magic, the rest is irrelevant */
 	}
 
 	/* Skip the signature header */
@@ -90,14 +90,14 @@ extern int rpm2cpio_main(int argc, char **argv)
 	/* Skip the main header */
 	skip_header(rpm_fd);
 	
-	xread_all(rpm_fd, &magic, 2);
+	bb_xread_all(rpm_fd, &magic, 2);
 	if ((magic[0] != 0x1f) || (magic[1] != 0x8b)) {
-		error_msg_and_die("Invalid gzip magic");
+		bb_error_msg_and_die("Invalid gzip magic");
 	}
 
 	check_header_gzip(rpm_fd);
 	if (inflate(rpm_fd, fileno(stdout)) != 0) {
-		error_msg("Error inflating");
+		bb_error_msg("Error inflating");
 	}
 	check_trailer_gzip(rpm_fd);
 
diff --git a/archival/tar.c b/archival/tar.c
index fa1c57512..c39d5787f 100644
--- a/archival/tar.c
+++ b/archival/tar.c
@@ -278,7 +278,7 @@ static inline int writeTarHeader(struct TarBallInfo *tbInfo,
 		header.typeflag = REGTYPE;
 		putOctal(header.size, sizeof(header.size), statbuf->st_size);
 	} else {
-		error_msg("%s: Unknown file type", real_name);
+		bb_error_msg("%s: Unknown file type", real_name);
 		return (FALSE);
 	}
 
@@ -295,9 +295,9 @@ static inline int writeTarHeader(struct TarBallInfo *tbInfo,
 
 	/* Now write the header out to disk */
 	if ((size =
-		 full_write(tbInfo->tarFd, (char *) &header,
+		 bb_full_write(tbInfo->tarFd, (char *) &header,
 					sizeof(struct TarHeader))) < 0) {
-		error_msg(io_error, real_name);
+		bb_error_msg(bb_msg_io_error, real_name);
 		return (FALSE);
 	}
 	/* Pad the header up to the tar block size */
@@ -368,7 +368,7 @@ static int writeFileToTarball(const char *fileName, struct stat *statbuf,
 
 	/* It is against the rules to archive a socket */
 	if (S_ISSOCK(statbuf->st_mode)) {
-		error_msg("%s: socket ignored", fileName);
+		bb_error_msg("%s: socket ignored", fileName);
 		return (TRUE);
 	}
 
@@ -377,7 +377,7 @@ static int writeFileToTarball(const char *fileName, struct stat *statbuf,
 	 * the new tarball */
 	if (tbInfo->statBuf.st_dev == statbuf->st_dev &&
 		tbInfo->statBuf.st_ino == statbuf->st_ino) {
-		error_msg("%s: file is the archive; skipping", fileName);
+		bb_error_msg("%s: file is the archive; skipping", fileName);
 		return (TRUE);
 	}
 
@@ -386,14 +386,14 @@ static int writeFileToTarball(const char *fileName, struct stat *statbuf,
 		static int alreadyWarned = FALSE;
 
 		if (alreadyWarned == FALSE) {
-			error_msg("Removing leading '/' from member names");
+			bb_error_msg("Removing leading '/' from member names");
 			alreadyWarned = TRUE;
 		}
 		header_name++;
 	}
 
 	if (strlen(fileName) >= NAME_SIZE) {
-		error_msg(name_longer_than_foo, NAME_SIZE);
+		bb_error_msg(bb_msg_name_longer_than_foo, NAME_SIZE);
 		return (TRUE);
 	}
 
@@ -419,21 +419,21 @@ static int writeFileToTarball(const char *fileName, struct stat *statbuf,
 
 		/* open the file we want to archive, and make sure all is well */
 		if ((inputFileFd = open(fileName, O_RDONLY)) < 0) {
-			perror_msg("%s: Cannot open", fileName);
+			bb_perror_msg("%s: Cannot open", fileName);
 			return (FALSE);
 		}
 
 		/* write the file to the archive */
-		while ((size = full_read(inputFileFd, buffer, sizeof(buffer))) > 0) {
-			if (full_write(tbInfo->tarFd, buffer, size) != size) {
+		while ((size = bb_full_read(inputFileFd, buffer, sizeof(buffer))) > 0) {
+			if (bb_full_write(tbInfo->tarFd, buffer, size) != size) {
 				/* Output file seems to have a problem */
-				error_msg(io_error, fileName);
+				bb_error_msg(bb_msg_io_error, fileName);
 				return (FALSE);
 			}
 			readSize += size;
 		}
 		if (size == -1) {
-			error_msg(io_error, fileName);
+			bb_error_msg(bb_msg_io_error, fileName);
 			return (FALSE);
 		}
 		/* Pad the file up to the tar block size */
@@ -464,7 +464,7 @@ static inline int writeTarFile(const char *tarName, const int verboseFlag,
 
 	/* Make sure there is at least one file to tar up.  */
 	if (include == NULL) {
-		error_msg_and_die("Cowardly refusing to create an empty archive");
+		bb_error_msg_and_die("Cowardly refusing to create an empty archive");
 	}
 
 	/* Open the tar file for writing.  */
@@ -477,7 +477,7 @@ static inline int writeTarFile(const char *tarName, const int verboseFlag,
 	}
 
 	if (tbInfo.tarFd < 0) {
-		perror_msg("%s: Cannot open", tarName);
+		bb_perror_msg("%s: Cannot open", tarName);
 		freeHardLinkInfo(&tbInfo.hlInfoHead);
 		return (FALSE);
 	}
@@ -485,12 +485,12 @@ static inline int writeTarFile(const char *tarName, const int verboseFlag,
 	/* Store the stat info for the tarball's file, so
 	 * can avoid including the tarball into itself....  */
 	if (fstat(tbInfo.tarFd, &tbInfo.statBuf) < 0)
-		error_msg_and_die(io_error, tarName);
+		bb_error_msg_and_die(bb_msg_io_error, tarName);
 
 #ifdef CONFIG_FEATURE_TAR_GZIP
 	if (gzip) {
 		if (pipe(gzipDataPipe) < 0 || pipe(gzipStatusPipe) < 0) {
-			perror_msg_and_die("Failed to create gzip pipe");
+			bb_perror_msg_and_die("Failed to create gzip pipe");
 		}
 
 		signal(SIGPIPE, SIG_IGN);	/* we only want EPIPE on errors */
@@ -529,7 +529,7 @@ static inline int writeTarFile(const char *tarName, const int verboseFlag,
 
 				if (n == 0 && vfork_exec_errno != 0) {
 					errno = vfork_exec_errno;
-					perror_msg_and_die("Could not exec gzip process");
+					bb_perror_msg_and_die("Could not exec gzip process");
 				} else if ((n < 0) && (errno == EAGAIN || errno == EINTR))
 					continue;	/* try it again */
 				break;
@@ -538,7 +538,7 @@ static inline int writeTarFile(const char *tarName, const int verboseFlag,
 
 			tbInfo.tarFd = gzipDataPipe[1];
 		} else {
-			perror_msg_and_die("Failed to vfork gzip process");
+			bb_perror_msg_and_die("Failed to vfork gzip process");
 		}
 	}
 #endif
@@ -567,7 +567,7 @@ static inline int writeTarFile(const char *tarName, const int verboseFlag,
 	/* Hang up the tools, close up shop, head home */
 	close(tbInfo.tarFd);
 	if (errorFlag)
-		error_msg("Error exit delayed from previous errors");
+		bb_error_msg("Error exit delayed from previous errors");
 
 	freeHardLinkInfo(&tbInfo.hlInfoHead);
 
@@ -585,10 +585,9 @@ static inline int writeTarFile(const char *tarName, const int verboseFlag,
 #ifdef CONFIG_FEATURE_TAR_EXCLUDE
 static llist_t *append_file_list_to_list(const char *filename, llist_t *list)
 {
-	FILE *src_stream = xfopen(filename, "r");
+	FILE *src_stream = bb_xfopen(filename, "r");
 	char *line;
-	while((line = get_line_from_file(src_stream)) != NULL) {
-		chomp(line);
+	while((line = bb_get_chomped_line_from_file(src_stream)) != NULL) {
 		list = llist_add_to(list, line);
 	}
 	fclose(src_stream);
@@ -611,7 +610,7 @@ int tar_main(int argc, char **argv)
 	unsigned char ctx_flag = 0;
 
 	if (argc < 2) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	/* Prepend '-' to the first argument if required */
@@ -690,13 +689,13 @@ int tar_main(int argc, char **argv)
 			break;
 #endif
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
 	/* Check one and only one context option was given */
 	if ((ctx_flag != CTX_CREATE) && (ctx_flag != CTX_TEST) && (ctx_flag != CTX_EXTRACT)) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	/* Check if we are reading from stdin */
@@ -740,11 +739,11 @@ int tar_main(int argc, char **argv)
 			tar_handle->src_fd = fileno(stdin);
 			tar_handle->seek = seek_by_char;
 		} else {
-			tar_handle->src_fd = xopen(tar_filename, O_RDONLY);
+			tar_handle->src_fd = bb_xopen(tar_filename, O_RDONLY);
 		}
 
 		if ((base_dir) && (chdir(base_dir))) {
-			perror_msg_and_die("Couldnt chdir");
+			bb_perror_msg_and_die("Couldnt chdir");
 		}
 
 		while (get_header_ptr(tar_handle) == EXIT_SUCCESS);
@@ -753,7 +752,7 @@ int tar_main(int argc, char **argv)
 		while (tar_handle->accept) {
 			if (find_list_entry(tar_handle->reject, tar_handle->accept->data) == NULL) {
 				if (find_list_entry(tar_handle->passed, tar_handle->accept->data) == NULL) {
-					error_msg_and_die("%s: Not found in archive\n", tar_handle->accept->data);
+					bb_error_msg_and_die("%s: Not found in archive\n", tar_handle->accept->data);
 				}
 			}
 			tar_handle->accept = tar_handle->accept->link;
diff --git a/archival/uncompress.c b/archival/uncompress.c
index 877bcc784..2d2145d18 100644
--- a/archival/uncompress.c
+++ b/archival/uncompress.c
@@ -45,7 +45,7 @@ int uncompress_main(int argc, char **argv)
 			flags |= gunzip_force;
 			break;
 		default:
-			show_usage();	/* exit's inside usage */
+			bb_show_usage();	/* exit's inside usage */
 		}
 	}
 
@@ -63,17 +63,17 @@ int uncompress_main(int argc, char **argv)
 			src_fd = fileno(stdin);
 			flags |= gunzip_to_stdout;
 		} else {
-			src_fd = xopen(old_path, O_RDONLY);
+			src_fd = bb_xopen(old_path, O_RDONLY);
 
 			/* Get the time stamp on the input file. */
 			if (stat(old_path, &stat_buf) < 0) {
-				error_msg_and_die("Couldn't stat file %s", old_path);
+				bb_error_msg_and_die("Couldn't stat file %s", old_path);
 			}
 		}
 
 		/* Check that the input is sane.  */
 		if (isatty(src_fd) && ((flags & gunzip_force) == 0)) {
-			error_msg_and_die
+			bb_error_msg_and_die
 				("compressed data not read from terminal.  Use -f to force it.");
 		}
 
@@ -83,16 +83,16 @@ int uncompress_main(int argc, char **argv)
 		} else {
 			char *extension;
 
-			new_path = xstrdup(old_path);
+			new_path = bb_xstrdup(old_path);
 
 			extension = strrchr(new_path, '.');
 			if (!extension || (strcmp(extension, ".Z") != 0)) {
-				error_msg_and_die("Invalid extension");
+				bb_error_msg_and_die("Invalid extension");
 			}
 			*extension = '\0';
 
 			/* Open output file */
-			dst_fd = xopen(new_path, O_WRONLY | O_CREAT);
+			dst_fd = bb_xopen(new_path, O_WRONLY | O_CREAT);
 
 			/* Set permissions on the file */
 			chmod(new_path, stat_buf.st_mode);
@@ -102,10 +102,10 @@ int uncompress_main(int argc, char **argv)
 		}
 
 		/* do the decompression, and cleanup */
-		if ((xread_char(src_fd) == 0x1f) && (xread_char(src_fd) == 0x9d)) {
+		if ((bb_xread_char(src_fd) == 0x1f) && (bb_xread_char(src_fd) == 0x9d)) {
 			status = uncompress(src_fd, dst_fd);
 		} else {
-			error_msg_and_die("Invalid magic");
+			bb_error_msg_and_die("Invalid magic");
 		}
 
 		if ((status != EXIT_SUCCESS) && (new_path)) {
@@ -122,7 +122,7 @@ int uncompress_main(int argc, char **argv)
 
 		/* delete_path will be NULL if in test mode or from stdin */
 		if (delete_path && (unlink(delete_path) == -1)) {
-			error_msg_and_die("Couldn't remove %s", delete_path);
+			bb_error_msg_and_die("Couldn't remove %s", delete_path);
 		}
 
 		free(new_path);
diff --git a/archival/unzip.c b/archival/unzip.c
index 86416d327..f2d7f4918 100644
--- a/archival/unzip.c
+++ b/archival/unzip.c
@@ -120,12 +120,12 @@ extern int unzip_main(int argc, char **argv)
 				break;
 #endif
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
 	if (argc == optind) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	printf("Archive:  %s\n", argv[optind]);
@@ -138,11 +138,11 @@ extern int unzip_main(int argc, char **argv)
 		archive_handle->src_fd = fileno(stdin);
 		archive_handle->seek = seek_by_char;
 	} else {
-		archive_handle->src_fd = xopen(argv[optind++], O_RDONLY);
+		archive_handle->src_fd = bb_xopen(argv[optind++], O_RDONLY);
 	}
 
 	if ((base_dir) && (chdir(base_dir))) {
-		perror_msg_and_die("Couldnt chdir");
+		bb_perror_msg_and_die("Couldnt chdir");
 	}
 
 	while (optind < argc) {
@@ -163,7 +163,7 @@ extern int unzip_main(int argc, char **argv)
 			break;
 		}
 		else if (magic != ZIP_FILEHEADER_MAGIC) {
-			error_msg_and_die("Invlaide zip magic");
+			bb_error_msg_and_die("Invlaide zip magic");
 		}
 
 		/* Read the file header */
@@ -172,7 +172,7 @@ extern int unzip_main(int argc, char **argv)
 		archive_handle->file_header->mode = S_IFREG | 0777;
 
 		if (zip_header.formated.method != 8) {
-			error_msg_and_die("Unsupported compression method %d\n", zip_header.formated.method);
+			bb_error_msg_and_die("Unsupported compression method %d\n", zip_header.formated.method);
 		}
 
 		/* Read filename */
@@ -198,19 +198,19 @@ extern int unzip_main(int argc, char **argv)
 		if (archive_handle->action_data) {
 			archive_handle->action_data(archive_handle);
 		} else {
-			dst_fd = xopen(archive_handle->file_header->name, O_WRONLY | O_CREAT);
+			dst_fd = bb_xopen(archive_handle->file_header->name, O_WRONLY | O_CREAT);
 			inflate(archive_handle->src_fd, dst_fd);
 			close(dst_fd);
 			chmod(archive_handle->file_header->name, archive_handle->file_header->mode);
 
 			/* Validate decompression - crc */
 			if (zip_header.formated.crc32 != (gunzip_crc ^ 0xffffffffL)) {
-				error_msg("Invalid compressed data--crc error");
+				bb_error_msg("Invalid compressed data--crc error");
 			}
 
 			/* Validate decompression - size */
 			if (gunzip_bytes_out != zip_header.formated.ucmpsize) {
-				error_msg("Invalid compressed data--length error");
+				bb_error_msg("Invalid compressed data--length error");
 			}
 		}
 
diff --git a/console-tools/chvt.c b/console-tools/chvt.c
index 8136f1c15..11e1078b7 100644
--- a/console-tools/chvt.c
+++ b/console-tools/chvt.c
@@ -23,13 +23,13 @@ int chvt_main(int argc, char **argv)
 	int fd, num;
 
 	if ((argc != 2) || (**(argv + 1) == '-'))
-		show_usage();
+		bb_show_usage();
 	fd = get_console_fd();
 	num = atoi(argv[1]);
 	if (ioctl(fd, VT_ACTIVATE, num))
-		perror_msg_and_die("VT_ACTIVATE");
+		bb_perror_msg_and_die("VT_ACTIVATE");
 	if (ioctl(fd, VT_WAITACTIVE, num))
-		perror_msg_and_die("VT_WAITACTIVE");
+		bb_perror_msg_and_die("VT_WAITACTIVE");
 	return EXIT_SUCCESS;
 }
 
diff --git a/console-tools/deallocvt.c b/console-tools/deallocvt.c
index b7dcc9e22..a4ba851c8 100644
--- a/console-tools/deallocvt.c
+++ b/console-tools/deallocvt.c
@@ -19,23 +19,23 @@ int deallocvt_main(int argc, char *argv[])
 
 	//if ((argc > 2) || ((argv == 2) && (**(argv + 1) == '-')))
 	if (argc > 2)
-		show_usage();
+		bb_show_usage();
 
 	fd = get_console_fd();
 
 	if (argc == 1) {
 		/* deallocate all unused consoles */
 		if (ioctl(fd, VT_DISALLOCATE, 0))
-			perror_msg_and_die("VT_DISALLOCATE");
+			bb_perror_msg_and_die("VT_DISALLOCATE");
 	} else {
 		for (i = 1; i < argc; i++) {
 			num = atoi(argv[i]);
 			if (num == 0)
-				error_msg("0: illegal VT number");
+				bb_error_msg("0: illegal VT number");
 			else if (num == 1)
-				error_msg("VT 1 cannot be deallocated");
+				bb_error_msg("VT 1 cannot be deallocated");
 			else if (ioctl(fd, VT_DISALLOCATE, num))
-				perror_msg_and_die("VT_DISALLOCATE");
+				bb_perror_msg_and_die("VT_DISALLOCATE");
 		}
 	}
 
diff --git a/console-tools/dumpkmap.c b/console-tools/dumpkmap.c
index d2bb6dcff..85926556c 100644
--- a/console-tools/dumpkmap.c
+++ b/console-tools/dumpkmap.c
@@ -48,12 +48,12 @@ int dumpkmap_main(int argc, char **argv)
 	char flags[MAX_NR_KEYMAPS], magic[] = "bkeymap";
 
 	if (argc>=2 && *argv[1]=='-') {
-		show_usage();
+		bb_show_usage();
 	}
 
 	fd = open(CURRENT_VC, O_RDWR);
 	if (fd < 0) {
-		perror_msg("Error opening " CURRENT_VC);
+		bb_perror_msg("Error opening " CURRENT_VC);
 		return EXIT_FAILURE;
 	}
 
@@ -81,7 +81,7 @@ int dumpkmap_main(int argc, char **argv)
 				ke.kb_table = i;
 				if (ioctl(fd, KDGKBENT, &ke) < 0) {
 				
-					error_msg("ioctl returned: %m, %s, %s, %xqq", (char *)&ke.kb_index,(char *)&ke.kb_table,(int)&ke.kb_value);
+					bb_error_msg("ioctl returned: %m, %s, %s, %xqq", (char *)&ke.kb_index,(char *)&ke.kb_table,(int)&ke.kb_value);
 					}
 				else {
 					write(1,(void*)&ke.kb_value,2);	
diff --git a/console-tools/loadacm.c b/console-tools/loadacm.c
index 3fb4e7665..640aa4401 100644
--- a/console-tools/loadacm.c
+++ b/console-tools/loadacm.c
@@ -34,16 +34,16 @@ int loadacm_main(int argc, char **argv)
 	int fd;
 
 	if (argc>=2 && *argv[1]=='-') {
-		show_usage();
+		bb_show_usage();
 	}
 
 	fd = open(CURRENT_VC, O_RDWR);
 	if (fd < 0) {
-		perror_msg_and_die("Error opening " CURRENT_VC);
+		bb_perror_msg_and_die("Error opening " CURRENT_VC);
 	}
 
 	if (screen_map_load(fd, stdin)) {
-		perror_msg_and_die("Error loading acm");
+		bb_perror_msg_and_die("Error loading acm");
 	}
 
 	write(fd, "\033(K", 3);
@@ -60,7 +60,7 @@ static int screen_map_load(int fd, FILE * fp)
 	int is_unicode;
 
 	if (fstat(fileno(fp), &stbuf))
-		perror_msg_and_die("Cannot stat map file");
+		bb_perror_msg_and_die("Cannot stat map file");
 
 	/* first try a UTF screen-map: either ASCII (no restriction) or binary (regular file) */
 	if (!
@@ -70,16 +70,16 @@ static int screen_map_load(int fd, FILE * fp)
 		if (parse_failed) {
 			if (-1 == fseek(fp, 0, SEEK_SET)) {
 				if (errno == ESPIPE)
-					error_msg_and_die("16bit screen-map MUST be a regular file.");
+					bb_error_msg_and_die("16bit screen-map MUST be a regular file.");
 				else
-					perror_msg_and_die("fseek failed reading binary 16bit screen-map");
+					bb_perror_msg_and_die("fseek failed reading binary 16bit screen-map");
 			}
 
 			if (fread(wbuf, sizeof(unicode) * E_TABSZ, 1, fp) != 1)
-				perror_msg_and_die("Cannot read [new] map from file");
+				bb_perror_msg_and_die("Cannot read [new] map from file");
 #if 0
 			else
-				error_msg("Input screen-map is binary.");
+				bb_error_msg("Input screen-map is binary.");
 #endif
 		}
 
@@ -87,7 +87,7 @@ static int screen_map_load(int fd, FILE * fp)
 		/* same if it was binary, ie. if parse_failed */
 		if (parse_failed || is_unicode) {
 			if (ioctl(fd, PIO_UNISCRNMAP, wbuf))
-				perror_msg_and_die("PIO_UNISCRNMAP ioctl");
+				bb_perror_msg_and_die("PIO_UNISCRNMAP ioctl");
 			else
 				return 0;
 		}
@@ -96,10 +96,10 @@ static int screen_map_load(int fd, FILE * fp)
 	/* rewind... */
 	if (-1 == fseek(fp, 0, SEEK_SET)) {
 		if (errno == ESPIPE)
-			error_msg("Assuming 8bit screen-map - MUST be a regular file."),
+			bb_error_msg("Assuming 8bit screen-map - MUST be a regular file."),
 				exit(1);
 		else
-			perror_msg_and_die("fseek failed assuming 8bit screen-map");
+			bb_perror_msg_and_die("fseek failed assuming 8bit screen-map");
 	}
 
 	/* ... and try an old 8-bit screen-map */
@@ -109,25 +109,25 @@ static int screen_map_load(int fd, FILE * fp)
 			if (-1 == fseek(fp, 0, SEEK_SET)) {
 				if (errno == ESPIPE)
 					/* should not - it succedeed above */
-					error_msg_and_die("fseek() returned ESPIPE !");
+					bb_error_msg_and_die("fseek() returned ESPIPE !");
 				else
-					perror_msg_and_die("fseek for binary 8bit screen-map");
+					bb_perror_msg_and_die("fseek for binary 8bit screen-map");
 			}
 
 			if (fread(buf, E_TABSZ, 1, fp) != 1)
-				perror_msg_and_die("Cannot read [old] map from file");
+				bb_perror_msg_and_die("Cannot read [old] map from file");
 #if 0
 			else
-				error_msg("Input screen-map is binary.");
+				bb_error_msg("Input screen-map is binary.");
 #endif
 		}
 
 		if (ioctl(fd, PIO_SCRNMAP, buf))
-			perror_msg_and_die("PIO_SCRNMAP ioctl");
+			bb_perror_msg_and_die("PIO_SCRNMAP ioctl");
 		else
 			return 0;
 	}
-	error_msg("Error parsing symbolic map");
+	bb_error_msg("Error parsing symbolic map");
 	return(1);
 }
 
@@ -172,7 +172,7 @@ static int uni_screen_map_read_ascii(FILE * fp, unicode buf[], int *is_unicode)
 			if (feof(fp))
 				break;
 			else
-				perror_msg_and_die("uni_screen_map_read_ascii() can't read line");
+				bb_perror_msg_and_die("uni_screen_map_read_ascii() can't read line");
 		}
 
 		/* get "charset-relative charcode", stripping leading spaces */
diff --git a/console-tools/loadfont.c b/console-tools/loadfont.c
index d66500195..6108151a6 100644
--- a/console-tools/loadfont.c
+++ b/console-tools/loadfont.c
@@ -44,11 +44,11 @@ extern int loadfont_main(int argc, char **argv)
 	int fd;
 
 	if (argc != 1)
-		show_usage();
+		bb_show_usage();
 
 	fd = open(CURRENT_VC, O_RDWR);
 	if (fd < 0)
-		perror_msg_and_die("Error opening " CURRENT_VC);
+		bb_perror_msg_and_die("Error opening " CURRENT_VC);
 	loadnewfont(fd);
 
 	return EXIT_SUCCESS;
@@ -62,7 +62,7 @@ static void do_loadfont(int fd, char *inbuf, int unit, int fontsize)
 	memset(buf, 0, sizeof(buf));
 
 	if (unit < 1 || unit > 32)
-		error_msg_and_die("Bad character size %d", unit);
+		bb_error_msg_and_die("Bad character size %d", unit);
 
 	for (i = 0; i < fontsize; i++)
 		memcpy(buf + (32 * i), inbuf + (unit * i), unit);
@@ -77,11 +77,11 @@ static void do_loadfont(int fd, char *inbuf, int unit, int fontsize)
 
 		if (ioctl(fd, PIO_FONTX, &cfd) == 0)
 			return;				/* success */
-		perror_msg("PIO_FONTX ioctl error (trying PIO_FONT)");
+		bb_perror_msg("PIO_FONTX ioctl error (trying PIO_FONT)");
 	}
 #endif
 	if (ioctl(fd, PIO_FONT, buf))
-		perror_msg_and_die("PIO_FONT ioctl error");
+		bb_perror_msg_and_die("PIO_FONT ioctl error");
 }
 
 static void
@@ -119,11 +119,11 @@ do_loadtable(int fd, unsigned char *inbuf, int tailsz, int fontsize)
 	if (ioctl(fd, PIO_UNIMAPCLR, &advice)) {
 #ifdef ENOIOCTLCMD
 		if (errno == ENOIOCTLCMD) {
-			error_msg("It seems this kernel is older than 1.1.92");
-			error_msg_and_die("No Unicode mapping table loaded.");
+			bb_error_msg("It seems this kernel is older than 1.1.92");
+			bb_error_msg_and_die("No Unicode mapping table loaded.");
 		} else
 #endif
-			perror_msg_and_die("PIO_UNIMAPCLR");
+			bb_perror_msg_and_die("PIO_UNIMAPCLR");
 	}
 	ud.entry_ct = ct;
 	ud.entries = up;
@@ -133,7 +133,7 @@ do_loadtable(int fd, unsigned char *inbuf, int tailsz, int fontsize)
 			/* change advice parameters */
 		}
 #endif
-		perror_msg_and_die("PIO_UNIMAP");
+		bb_perror_msg_and_die("PIO_UNIMAP");
 	}
 }
 
@@ -150,13 +150,13 @@ static void loadnewfont(int fd)
 	 */
 	inputlth = fread(inbuf, 1, sizeof(inbuf), stdin);
 	if (ferror(stdin))
-		perror_msg_and_die("Error reading input font");
+		bb_perror_msg_and_die("Error reading input font");
 	/* use malloc/realloc in case of giant files;
 	   maybe these do not occur: 16kB for the font,
 	   and 16kB for the map leaves 32 unicode values
 	   for each font position */
 	if (!feof(stdin))
-		perror_msg_and_die("Font too large");
+		bb_perror_msg_and_die("Font too large");
 
 	/* test for psf first */
 	{
@@ -174,11 +174,11 @@ static void loadnewfont(int fd)
 			goto no_psf;
 
 		if (psfhdr.mode > PSF_MAXMODE)
-			error_msg_and_die("Unsupported psf file mode");
+			bb_error_msg_and_die("Unsupported psf file mode");
 		fontsize = ((psfhdr.mode & PSF_MODE512) ? 512 : 256);
 #if !defined( PIO_FONTX ) || defined( __sparc__ )
 		if (fontsize != 256)
-			error_msg_and_die("Only fontsize 256 supported");
+			bb_error_msg_and_die("Only fontsize 256 supported");
 #endif
 		hastable = (psfhdr.mode & PSF_MODEHASTAB);
 		unit = psfhdr.charsize;
@@ -186,7 +186,7 @@ static void loadnewfont(int fd)
 
 		head = head0 + fontsize * unit;
 		if (head > inputlth || (!hastable && head != inputlth))
-			error_msg_and_die("Input file: bad length");
+			bb_error_msg_and_die("Input file: bad length");
 		do_loadfont(fd, inbuf + head0, unit, fontsize);
 		if (hastable)
 			do_loadtable(fd, inbuf + head, inputlth - head, fontsize);
@@ -201,7 +201,7 @@ static void loadnewfont(int fd)
 	} else {
 		/* bare font */
 		if (inputlth & 0377)
-			error_msg_and_die("Bad input file size");
+			bb_error_msg_and_die("Bad input file size");
 		offset = 0;
 		unit = inputlth / 256;
 	}
diff --git a/console-tools/loadkmap.c b/console-tools/loadkmap.c
index 4f217d630..f4208df63 100644
--- a/console-tools/loadkmap.c
+++ b/console-tools/loadkmap.c
@@ -51,18 +51,18 @@ int loadkmap_main(int argc, char **argv)
 	char flags[MAX_NR_KEYMAPS], buff[7];
 
 	if (argc != 1)
-		show_usage();
+		bb_show_usage();
 
 	fd = open(CURRENT_VC, O_RDWR);
 	if (fd < 0)
-		perror_msg_and_die("Error opening " CURRENT_VC);
+		bb_perror_msg_and_die("Error opening " CURRENT_VC);
 
 	read(0, buff, 7);
 	if (0 != strncmp(buff, BINARY_KEYMAP_MAGIC, 7))
-		error_msg_and_die("This is not a valid binary keymap.");
+		bb_error_msg_and_die("This is not a valid binary keymap.");
 
 	if (MAX_NR_KEYMAPS != read(0, flags, MAX_NR_KEYMAPS))
-		perror_msg_and_die("Error reading keymap flags");
+		bb_perror_msg_and_die("Error reading keymap flags");
 
 	ibuff = (u_short *) xmalloc(ibuffsz);
 
@@ -71,7 +71,7 @@ int loadkmap_main(int argc, char **argv)
 			pos = 0;
 			while (pos < ibuffsz) {
 				if ((readsz = read(0, (char *) ibuff + pos, ibuffsz - pos)) < 0)
-					perror_msg_and_die("Error reading keymap");
+					bb_perror_msg_and_die("Error reading keymap");
 				pos += readsz;
 			}
 			for (j = 0; j < NR_KEYS; j++) {
diff --git a/console-tools/openvt.c b/console-tools/openvt.c
index 77c897597..519513623 100644
--- a/console-tools/openvt.c
+++ b/console-tools/openvt.c
@@ -43,16 +43,16 @@ int openvt_main(int argc, char **argv)
 	char * cmd_args = NULL;
 
 	if (argc < 3)
-        show_usage();
+        bb_show_usage();
 
 	if (!isdigit(argv[1][0]))
-	        show_usage();
+	        bb_show_usage();
 
 	vtno = (int) atol(argv[1]);
 
 	/* if (vtno <= 0 || vtno > 63) */
 	if (vtno <= 0 || vtno > 12)
-		error_msg_and_die("Illegal vt number (%d)", vtno);	  
+		bb_error_msg_and_die("Illegal vt number (%d)", vtno);	  
 
 	sprintf(vtname, VTNAME, vtno);
 
@@ -69,13 +69,13 @@ int openvt_main(int argc, char **argv)
 		if (setsid() < 0) {
 #endif
 
-			perror_msg_and_die("Unable to set new session");	  
+			bb_perror_msg_and_die("Unable to set new session");	  
 		}
 		close(0);			/* so that new vt becomes stdin */
 
 		/* and grab new one */
 		if ((fd = open(vtname, O_RDWR)) == -1)
-			perror_msg_and_die("could not open %s", vtname);	  
+			bb_perror_msg_and_die("could not open %s", vtname);	  
 
 		/* Reassign stdout and sterr */
 		close(1);
diff --git a/console-tools/setkeycodes.c b/console-tools/setkeycodes.c
index 85612c8b1..796bab285 100644
--- a/console-tools/setkeycodes.c
+++ b/console-tools/setkeycodes.c
@@ -43,7 +43,7 @@ setkeycodes_main(int argc, char** argv)
     struct kbkeycode a;
 
     if (argc % 2 != 1 || argc < 2) {
-      show_usage();
+      bb_show_usage();
 	}
 	 
 	fd = get_console_fd();
@@ -52,18 +52,18 @@ setkeycodes_main(int argc, char** argv)
 	a.keycode = atoi(argv[2]);
 	a.scancode = sc = strtol(argv[1], &ep, 16);
 	if (*ep) {
-      error_msg_and_die("error reading SCANCODE: '%s'", argv[1]);
+      bb_error_msg_and_die("error reading SCANCODE: '%s'", argv[1]);
 	}
 	if (a.scancode > 127) {
 	    a.scancode -= 0xe000;
 	    a.scancode += 128;
 	}
 	if (a.scancode > 255 || a.keycode > 127) {
-      error_msg_and_die("SCANCODE or KEYCODE outside bounds");
+      bb_error_msg_and_die("SCANCODE or KEYCODE outside bounds");
 	}
 	if (ioctl(fd,KDSETKEYCODE,&a)) {
 	    perror("KDSETKEYCODE");
-		error_msg_and_die("failed to set SCANCODE %x to KEYCODE %d", sc, a.keycode);
+		bb_error_msg_and_die("failed to set SCANCODE %x to KEYCODE %d", sc, a.keycode);
 	}
 	argc -= 2;
 	argv += 2;
diff --git a/coreutils/Config.in b/coreutils/Config.in
index 5b9996d5b..9f5c379a3 100644
--- a/coreutils/Config.in
+++ b/coreutils/Config.in
@@ -111,17 +111,31 @@ config CONFIG_DOS2UNIX
 	  Please submit a patch to add help text for this item.
 
 config CONFIG_DU
-	bool "du"
+	bool "du (default blocksize of 512 bytes)"
 	default n
 	help
 	  Please submit a patch to add help text for this item.
 
+config CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K
+	bool "  Use a default blocksize of 1024 bytes (1K)"
+	default y
+	depends on CONFIG_DU
+	help
+	  Please submit a patch to add help text for this item.
+
 config CONFIG_ECHO
-	bool "echo"
+	bool "echo (basic SUSv3 version taking no options"
 	default n
 	help
 	  Please submit a patch to add help text for this item.
 
+config CONFIG_FEATURE_FANCY_ECHO
+	bool "  Enable echo options (-n and -e)"
+	default y
+	depends on CONFIG_ECHO
+	help
+	  Please submit a patch to add help text for this item.
+
 config CONFIG_ENV
 	bool "env"
 	default n
@@ -154,6 +168,13 @@ config CONFIG_HEAD
 	help
 	  Please submit a patch to add help text for this item.
 
+config CONFIG_FEATURE_FANCY_HEAD
+	bool "  Enable head options (-c, -q, and -v)"
+	default n
+	depends on CONFIG_HEAD
+	help
+	  Please submit a patch to add help text for this item.
+
 config CONFIG_HOSTID
 	bool "hostid"
 	default n
@@ -313,8 +334,15 @@ config CONFIG_SHA1SUM
 	  Compute and check SHA1 message digest
 
 config CONFIG_SLEEP
-	bool "sleep"
+	bool "sleep (single integer arg with no suffix)"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_FANCY_SLEEP
+	bool "  Enable multiple integer args and optional time suffixes"
 	default n
+	depends on CONFIG_SLEEP
 	help
 	  Please submit a patch to add help text for this item.
 
@@ -369,6 +397,13 @@ config CONFIG_TEE
 	help
 	  Please submit a patch to add help text for this item.
 
+config CONFIG_FEATURE_TEE_USE_BLOCK_IO
+	bool "  Enable block i/o (larger/faster) instead of byte i/o."
+	default n
+	depends on CONFIG_TEE
+	help
+	  Please submit a patch to add help text for this item.
+
 if CONFIG_ASH || CONFIG_HUSH || CONFIG_LASH || CONFIG_MSH
 	config CONFIG_TEST
 		default y
diff --git a/coreutils/basename.c b/coreutils/basename.c
index bdbcec17a..71bb9b3bd 100644
--- a/coreutils/basename.c
+++ b/coreutils/basename.c
@@ -21,32 +21,43 @@
  *
  */
 
-/* getopt not needed */
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/basename.html */
+
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Changes:
+ * 1) Now checks for too many args.  Need at least one and at most two.
+ * 2) Don't check for options, as per SUSv3.
+ * 3) Save some space by using strcmp().  Calling strncmp() here was silly.
+ */
 
 #include <stdlib.h>
-#include "busybox.h"
+#include <stdio.h>
 #include <string.h>
+#include "busybox.h"
 
 extern int basename_main(int argc, char **argv)
 {
-	int m, n;
+	size_t m, n;
 	char *s;
 
-	if ((argc < 2) || (**(argv + 1) == '-')) {
-		show_usage();
+	if (((unsigned int)(argc-2)) >= 2) {
+		bb_show_usage();
 	}
 
-	argv++;
-
-	s = get_last_path_component(*argv);
+	s = bb_get_last_path_component(*++argv);
 
-	if (argc>2) {
-		argv++;
+	if (*++argv) {
 		n = strlen(*argv);
 		m = strlen(s);
-		if (m>n && strncmp(s+m-n, *argv, n)==0)
+		if ((m > n) && ((strcmp)(s+m-n, *argv) == 0)) {
 			s[m-n] = '\0';
+		}
 	}
+
 	puts(s);
-	return EXIT_SUCCESS;
+
+	bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 }
diff --git a/coreutils/cal.c b/coreutils/cal.c
index ab631576a..ed480dd78 100644
--- a/coreutils/cal.c
+++ b/coreutils/cal.c
@@ -1,3 +1,14 @@
+/* NOTE:
+ *
+ * Apparently, all "Steven J. Merrifield" did was grab the util-linux cal applet,
+ * spend maybe 5 minutes integrating it into busybox, slapped a copyright on it,
+ * and submitted it.  I certainly saw no evidence of any attempt at size reduction.
+ * Not only do I consider his copyright below meaningless, I also consider his
+ * actions shameful.
+ *
+ * Manuel Novoa III   (mjn3@codepoet.org)
+ */
+
 /*
  * Calendar implementation for busybox
  *
@@ -20,7 +31,16 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
 */
-       
+
+/* BB_AUDIT SUSv3 compliant with -j and -y extensions (from util-linux). */
+/* BB_AUDIT BUG: The output of 'cal -j 1752' is incorrect.  The upstream
+ * BB_AUDIT BUG: version in util-linux seems to be broken as well. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/cal.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Major size reduction... over 50% (>1.5k) on i386.
+ */
 
 #include <sys/types.h>
 #include <ctype.h>
@@ -46,44 +66,30 @@
 #define	MAXDAYS			42		/* max slots in a month array */
 #define	SPACE			-1		/* used in day array */
 
-static int days_in_month[2][13] = {
-	{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
-	{0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
+static const char days_in_month[] = {
+	0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
 };
 
-int sep1752[MAXDAYS] = {
-	SPACE,	SPACE,	1,	2,	14,	15,	16,
+static const char sep1752[] = {
+	         1,	2,	14,	15,	16,
 	17,	18,	19,	20,	21,	22,	23,
-	24,	25,	26,	27,	28,	29,	30,
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
-}, j_sep1752[MAXDAYS] = {
-	SPACE,	SPACE,	245,	246,	258,	259,	260,
-	261,	262,	263,	264,	265,	266,	267,
-	268,	269,	270,	271,	272,	273,	274,
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
-}, empty[MAXDAYS] = {
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
-	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,	SPACE,
+	24,	25,	26,	27,	28,	29,	30
 };
 
-char *month_names[12];
-
-char day_headings[] = "                    ";
-char j_day_headings[] = "                           ";
+static int julian;
 
 /* leap year -- account for gregorian reformation in 1752 */
 #define	leap_year(yr) \
 	((yr) <= 1752 ? !((yr) % 4) : \
 	(!((yr) % 4) && ((yr) % 100)) || !((yr) % 400))
 
+static int is_leap_year(int year)
+{
+	return leap_year(year);
+}
+#undef leap_year
+#define leap_year(yr) is_leap_year(yr)
+
 /* number of centuries since 1700, not inclusive */
 #define	centuries_since_1700(yr) \
 	((yr) > 1700 ? (yr) / 100 - 17 : 0)
@@ -96,178 +102,129 @@ char j_day_headings[] = "                           ";
 #define	leap_years_since_year_1(yr) \
 	((yr) / 4 - centuries_since_1700(yr) + quad_centuries_since_1700(yr))
 
-int julian;
-void ascii_day __P((char *, int));
-void center __P((char *, int, int));
-void day_array __P((int, int, int *));
-int day_in_week __P((int, int, int));
-int day_in_year __P((int, int, int));
-void j_yearly __P((int));
-void monthly __P((int, int));
-void trim_trailing_spaces __P((char *));
-void yearly __P((int));
+static void center __P((char *, int, int));
+static void day_array __P((int, int, int *));
+static void trim_trailing_spaces_and_print __P((char *));
+
+static void blank_string(char *buf, size_t buflen);
+static char *build_row(char *p, int *dp);
+
+#define	DAY_LEN		3		/* 3 spaces per day */
+#define	J_DAY_LEN	(DAY_LEN + 1)
+#define	WEEK_LEN	20		/* 7 * 3 - one space at the end */
+#define	J_WEEK_LEN	(WEEK_LEN + 7)
+#define	HEAD_SEP	2		/* spaces between day headings */
 
 int cal_main(int argc, char **argv)
 {
 	struct tm *local_time;
-	static struct tm zero_tm;
+	struct tm zero_tm;
 	time_t now;
-	int ch, month, year, yflag, i;
+	int month, year, flags, i;
+	char *month_names[12];
+	char day_headings[28];	/* 28 for julian, 21 for nonjulian */
 	char buf[40];
 
 #ifdef CONFIG_LOCALE_SUPPORT
 	setlocale(LC_TIME, "");
 #endif
 
-	yflag = 0;
-	while ((ch = getopt(argc, argv, "jy")) != -1)
-		switch(ch) {
-		case 'j':
-			julian = 1;
-			break;
-		case 'y':
-			yflag = 1;
-			break;
-		default:
-			show_usage();
-		}
-	argc -= optind;
+	flags = bb_getopt_ulflags(argc, argv, "jy");
+
+	julian = flags & 1;
+
 	argv += optind;
 
 	month = 0;
-	switch(argc) {
-	case 2:
-		if ((month = atoi(*argv++)) < 1 || month > 12)
-			error_msg_and_die("Illegal month value: use 1-12");
-		/* FALLTHROUGH */
-	case 1:
-		if ((year = atoi(*argv)) < 1 || year > 9999)
-			error_msg_and_die("Illegal year value: use 1-9999");
-		break;
-	case 0:
+
+	if ((argc -= optind) > 2) {
+		bb_show_usage();
+	}
+
+	if (!argc) {
 		time(&now);
 		local_time = localtime(&now);
 		year = local_time->tm_year + 1900;
-		if (!yflag)
+		if (!(flags & 2)) {
 			month = local_time->tm_mon + 1;
-		break;
-	default:
-		show_usage();
+		}
+	} else {
+		if (argc == 2) {
+			month = bb_xgetularg10_bnd(*argv++, 1, 12);
+		}
+		year = bb_xgetularg10_bnd(*argv, 1, 9999);
 	}
 
-	for (i = 0; i < 12; i++) {
+	blank_string(day_headings, sizeof(day_headings) - 7 +  7*julian);
+
+	i = 0;
+	do {
 		zero_tm.tm_mon = i;
 		strftime(buf, sizeof(buf), "%B", &zero_tm);
-		month_names[i] = xstrdup(buf);
-	}
-	for (i = 0; i < 7; i++) {
-		zero_tm.tm_wday = i;
-		strftime(buf, sizeof(buf), "%a", &zero_tm);
-		strncpy(day_headings + i * 3, buf, 2);
-		strncpy(j_day_headings + i * 4 + 1, buf, 2);
-	}
-
-	if (month)
-		monthly(month, year);
-	else if (julian)
-		j_yearly(year);
-	else
-		yearly(year);
-	exit(0);
-}
+		month_names[i] = bb_xstrdup(buf);
 
-#define	DAY_LEN		3		/* 3 spaces per day */
-#define	J_DAY_LEN	4		/* 4 spaces per day */
-#define	WEEK_LEN	20		/* 7 * 3 - one space at the end */
-#define	J_WEEK_LEN	27		/* 7 * 4 - one space at the end */
-#define	HEAD_SEP	2		/* spaces between day headings */
-#define	J_HEAD_SEP	2
-
-void monthly(int month, int year)
-{
-	int col, row, len, days[MAXDAYS];
-	char *p, lineout[30];
-
-	day_array(month, year, days);
-	len = sprintf(lineout, "%s %d", month_names[month - 1], year);
-	printf("%*s%s\n%s\n",
-	    ((julian ? J_WEEK_LEN : WEEK_LEN) - len) / 2, "",
-	    lineout, julian ? j_day_headings : day_headings);
-	for (row = 0; row < 6; row++) {
-		for (col = 0, p = lineout; col < 7; col++,
-		    p += julian ? J_DAY_LEN : DAY_LEN)
-			ascii_day(p, days[row * 7 + col]);
-		*p = '\0';
-		trim_trailing_spaces(lineout);
-		printf("%s\n", lineout);
-	}
-}
-
-void j_yearly(int year)
-{
-	int col, *dp, i, month, row, which_cal;
-	int days[12][MAXDAYS];
-	char *p, lineout[80];
-
-	sprintf(lineout, "%d", year);
-	center(lineout, J_WEEK_LEN * 2 + J_HEAD_SEP, 0);
-	printf("\n\n");
-	for (i = 0; i < 12; i++)
-		day_array(i + 1, year, days[i]);
-	memset(lineout, ' ', sizeof(lineout) - 1);
-	lineout[sizeof(lineout) - 1] = '\0';
-	for (month = 0; month < 12; month += 2) {
-		center(month_names[month], J_WEEK_LEN, J_HEAD_SEP);
-		center(month_names[month + 1], J_WEEK_LEN, 0);
-		printf("\n%s%*s%s\n", j_day_headings, J_HEAD_SEP, "",
-		    j_day_headings);
-		for (row = 0; row < 6; row++) {
-			for (which_cal = 0; which_cal < 2; which_cal++) {
-				p = lineout + which_cal * (J_WEEK_LEN + 2);
-				dp = &days[month + which_cal][row * 7];
-				for (col = 0; col < 7; col++, p += J_DAY_LEN)
-					ascii_day(p, *dp++);
-			}
-			*p = '\0';
-			trim_trailing_spaces(lineout);
-			printf("%s\n", lineout);
+		if (i < 7) {
+			zero_tm.tm_wday = i;
+			strftime(buf, sizeof(buf), "%a", &zero_tm);
+			strncpy(day_headings + i * (3+julian) + julian, buf, 2);
 		}
-	}
-	printf("\n");
-}
-
-void yearly(int year)
-{
-	int col, *dp, i, month, row, which_cal;
-	int days[12][MAXDAYS];
-	char *p, lineout[80];
-
-	sprintf(lineout, "%d", year);
-	center(lineout, WEEK_LEN * 3 + HEAD_SEP * 2, 0);
-	printf("\n\n");
-	for (i = 0; i < 12; i++)
-		day_array(i + 1, year, days[i]);
-	memset(lineout, ' ', sizeof(lineout) - 1);
-	lineout[sizeof(lineout) - 1] = '\0';
-	for (month = 0; month < 12; month += 3) {
-		center(month_names[month], WEEK_LEN, HEAD_SEP);
-		center(month_names[month + 1], WEEK_LEN, HEAD_SEP);
-		center(month_names[month + 2], WEEK_LEN, 0);
-		printf("\n%s%*s%s%*s%s\n", day_headings, HEAD_SEP,
-		    "", day_headings, HEAD_SEP, "", day_headings);
+	} while (++i < 12);
+
+	if (month) {
+		int row, len, days[MAXDAYS];
+		int *dp = days;
+		char lineout[30];
+		
+		day_array(month, year, dp);
+		len = sprintf(lineout, "%s %d", month_names[month - 1], year);
+		bb_printf("%*s%s\n%s\n",
+			   ((7*julian + WEEK_LEN) - len) / 2, "",
+			   lineout, day_headings);
 		for (row = 0; row < 6; row++) {
-			for (which_cal = 0; which_cal < 3; which_cal++) {
-				p = lineout + which_cal * (WEEK_LEN + 2);
-				dp = &days[month + which_cal][row * 7];
-				for (col = 0; col < 7; col++, p += DAY_LEN)
-					ascii_day(p, *dp++);
+			build_row(lineout, dp)[0] = '\0';
+			dp += 7;
+			trim_trailing_spaces_and_print(lineout);
+		}
+	} else {
+		int row, which_cal, week_len, days[12][MAXDAYS];
+		int *dp;
+		char lineout[80];
+		
+		sprintf(lineout, "%d", year);
+		center(lineout,
+			   (WEEK_LEN * 3 + HEAD_SEP * 2)
+			   + julian * (J_WEEK_LEN * 2 + HEAD_SEP
+						   - (WEEK_LEN * 3 + HEAD_SEP * 2)),
+			   0);
+		puts("\n");		/* two \n's */
+		for (i = 0; i < 12; i++) {
+			day_array(i + 1, year, days[i]);
+		}
+		blank_string(lineout, sizeof(lineout));
+		week_len = WEEK_LEN + julian * (J_WEEK_LEN - WEEK_LEN);
+		for (month = 0; month < 12; month += 3-julian) {
+			center(month_names[month], week_len, HEAD_SEP);
+			if (!julian) {
+				center(month_names[month + 1], week_len, HEAD_SEP);
+			}
+			center(month_names[month + 2 - julian], week_len, 0);
+			bb_printf("\n%s%*s%s", day_headings, HEAD_SEP, "", day_headings);
+			if (!julian) {
+				bb_printf("%*s%s", HEAD_SEP, "", day_headings);
+			}
+			putchar('\n');
+			for (row = 0; row < (6*7); row += 7) {
+				for (which_cal = 0; which_cal < 3-julian; which_cal++) {
+					dp = days[month + which_cal] + row;
+					build_row(lineout + which_cal * (week_len + 2), dp);
+				}
+				/* blank_string took care of nul termination. */
+				trim_trailing_spaces_and_print(lineout);
 			}
-			*p = '\0';
-			trim_trailing_spaces(lineout);
-			printf("%s\n", lineout);
 		}
 	}
-	printf("\n");
+
+	bb_fflush_stdout_and_exit(0);
 }
 
 /*
@@ -277,118 +234,129 @@ void yearly(int year)
  *	out end to end.  You would have 42 numbers or spaces.  This routine
  *	builds that array for any month from Jan. 1 through Dec. 9999.
  */
-void day_array(int month, int year, int *days)
+static void day_array(int month, int year, int *days)
 {
+	long temp;
+	int i;
+	int j_offset;
 	int day, dw, dm;
 
+	memset(days, SPACE, MAXDAYS * sizeof(int));
+
 	if ((month == 9) && (year == 1752)) {
-		memmove(days,
-			julian ? j_sep1752 : sep1752, MAXDAYS * sizeof(int));
+		j_offset = julian * 244;
+		i = 0;
+		do {
+			days[i+2] = sep1752[i] + j_offset;
+		} while (++i < sizeof(sep1752));
+
 		return;
 	}
-	memmove(days, empty, MAXDAYS * sizeof(int));
-	dm = days_in_month[leap_year(year)][month];
-	dw = day_in_week(1, month, year);
-	day = julian ? day_in_year(1, month, year) : 1;
-	while (dm--)
-		days[dw++] = day++;
-}
 
-/*
- * day_in_year --
- *	return the 1 based day number within the year
- */
-int day_in_year(int day, int month, int year)
-{
-	int i, leap;
-
-	leap = leap_year(year);
-	for (i = 1; i < month; i++)
-		day += days_in_month[leap][i];
-	return (day);
-}
+	/* day_in_year
+	 *	return the 1 based day number within the year
+	 */
+	day = 1;
+	if ((month > 2) && leap_year(year)) {
+		++day;
+	}
 
-/*
- * day_in_week
- *	return the 0 based day number for any date from 1 Jan. 1 to
- *	31 Dec. 9999.  Assumes the Gregorian reformation eliminates
- *	3 Sep. 1752 through 13 Sep. 1752.  Returns Thursday for all
- *	missing days.
- */
-int day_in_week(int day, int month, int year)
-{
-	long temp;
+	i = month;
+	while (i) {
+		day += days_in_month[--i];
+	}
 
+	/* day_in_week
+	 *	return the 0 based day number for any date from 1 Jan. 1 to
+	 *	31 Dec. 9999.  Assumes the Gregorian reformation eliminates
+	 *	3 Sep. 1752 through 13 Sep. 1752.  Returns Thursday for all
+	 *	missing days.
+	 */
+	dw = THURSDAY;
 	temp = (long)(year - 1) * 365 + leap_years_since_year_1(year - 1)
-	    + day_in_year(day, month, year);
-	if (temp < FIRST_MISSING_DAY)
-		return ((temp - 1 + SATURDAY) % 7);
-	if (temp >= (FIRST_MISSING_DAY + NUMBER_MISSING_DAYS))
-		return (((temp - 1 + SATURDAY) - NUMBER_MISSING_DAYS) % 7);
-	return (THURSDAY);
+		+ day;
+	if (temp < FIRST_MISSING_DAY) {
+		dw = ((temp - 1 + SATURDAY) % 7);
+	} else if (temp >= (FIRST_MISSING_DAY + NUMBER_MISSING_DAYS)) {
+		dw = (((temp - 1 + SATURDAY) - NUMBER_MISSING_DAYS) % 7);
+	}
+
+	if (!julian) {
+		day = 1;
+	}
+
+	dm = days_in_month[month];
+	if ((month == 2) && leap_year(year)) {
+		++dm;
+	}
+
+	while (dm) {
+		days[dw++] = day++;
+		--dm;
+	}
 }
 
-void ascii_day(char *p, int day)
+static void trim_trailing_spaces_and_print(char *s)
 {
-	int display, val;
-	static char *aday[] = {
-		"",
-		" 1", " 2", " 3", " 4", " 5", " 6", " 7",
-		" 8", " 9", "10", "11", "12", "13", "14",
-		"15", "16", "17", "18", "19", "20", "21",
-		"22", "23", "24", "25", "26", "27", "28",
-		"29", "30", "31",
-	};
-
-	if (day == SPACE) {
-		memset(p, ' ', julian ? J_DAY_LEN : DAY_LEN);
-		return;
+	char *p = s;
+
+	while (*p) {
+		++p;
 	}
-	if (julian) {
-		if ((val = day / 100) != 0) {
-			day %= 100;
-			*p++ = val + '0';
-			display = 1;
-		} else {
-			*p++ = ' ';
-			display = 0;
+	while (p > s) {
+		--p;
+		if (!(isspace)(*p)) {	/* We want the function... not the inline. */
+			p[1] = '\0';
+			break;
 		}
-		val = day / 10;
-		if (val || display)
-			*p++ = val + '0';
-		else
-			*p++ = ' ';
-		*p++ = day % 10 + '0';
-	} else {
-		*p++ = aday[day][0];
-		*p++ = aday[day][1];
 	}
-	*p = ' ';
+
+	puts(s);
 }
 
-void trim_trailing_spaces(char *s)
+static void center(char *str, int len, int separate)
 {
-	char *p;
+	int n = strlen(str);
+	len -= n;
+	bb_printf("%*s%*s", (len/2) + n, str, (len/2) + (len % 2) + separate, "");
+}
 
-	for (p = s; *p; ++p)
-		continue;
-	while (p > s && (--p, isspace(*p)))
-		continue;
-	if (p > s)
-		++p;
-	*p = '\0';
+static void blank_string(char *buf, size_t buflen)
+{
+	memset(buf, ' ', buflen);
+	buf[buflen-1] = '\0';
 }
 
-void center(char *str, int len, int separate)
+static char *build_row(char *p, int *dp)
 {
+	int col, val, day;
+		
+	memset(p, ' ', (julian + DAY_LEN) * 7);
+
+	col = 0;
+	do {
+		if ((day = *dp++) != SPACE) {
+			if (julian) {
+				*++p;
+				if (day >= 100) {
+					*p = '0';
+					p[-1] = (day / 100) + '0';
+					day %= 100;
+				}
+			}
+			if ((val = day / 10) > 0) {
+				*p = val + '0';
+			}
+			*++p = day % 10 + '0';
+			p += 2;
+		} else {
+			p += DAY_LEN + julian;
+		}
+	} while (++col < 7);
 
-	len -= strlen(str);
-	printf("%*s%s%*s", len / 2, "", str, len / 2 + len % 2, "");
-	if (separate)
-		printf("%*s", separate, "");
+	return p;
 }
 
-
 /*
  * Copyright (c) 1989, 1993, 1994
  *	The Regents of the University of California.  All rights reserved.
diff --git a/coreutils/cat.c b/coreutils/cat.c
index 33f15da71..865275767 100644
--- a/coreutils/cat.c
+++ b/coreutils/cat.c
@@ -1,9 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini Cat implementation for busybox
+ * cat implementation for busybox
  *
- * Copyright (C) 1999,2000 by Lineo, inc. and Erik Andersen
- * Copyright (C) 1999,2000,2001 by Erik Andersen <andersee@debian.org>
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,33 +20,48 @@
  *
  */
 
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/cat.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * This is a new implementation of 'cat' which aims to be SUSv3 compliant.
+ *
+ * Changes from the previous implementation include:
+ * 1) Multiple '-' args are accepted as required by SUSv3.  The previous
+ *    implementation would close stdin and segfault on a subsequent '-'.
+ * 2) The '-u' options is required by SUSv3.  Note that the specified
+ *    behavior for '-u' is done by default, so all we need do is accept
+ *    the option.
+ */
+
 #include <stdlib.h>
-#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
 #include "busybox.h"
 
 extern int cat_main(int argc, char **argv)
 {
-	int status = EXIT_SUCCESS;
+	FILE *f;
+	int retval = EXIT_SUCCESS;
 
-	if (argc == 1) {
-		print_file(stdin);
-		return status;
+	bb_getopt_ulflags(argc, argv, "u");
+
+	argv += optind;
+	if (!*argv) {
+		*--argv = "-";
 	}
 
-	while (--argc > 0) {
-		if(!(strcmp(*++argv, "-"))) {
-			print_file(stdin);
-		} else if (! print_file_by_name(*argv)) {
-			status = EXIT_FAILURE;
+	do {
+		if ((f = bb_wfopen_input(*argv)) != NULL) {
+			int r = bb_copyfd(fileno(f), STDOUT_FILENO, 0);
+			bb_fclose_nonstdin(f);
+			if (r >= 0) {
+				continue;
+			}
 		}
-	}
-	return status;
-}
+		retval = EXIT_FAILURE;
+	} while (*++argv);
 
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
+	return retval;
+}
diff --git a/coreutils/chgrp.c b/coreutils/chgrp.c
index 968b448c0..f5e5d29f1 100644
--- a/coreutils/chgrp.c
+++ b/coreutils/chgrp.c
@@ -21,9 +21,12 @@
  *
  */
 
-#include <stdio.h>
+/* BB_AUDIT SUSv3 defects - unsupported options -h, -H, -L, and -P. */
+/* BB_AUDIT GNU defects - unsupported options -h, -c, -f, -v, and long options. */
+/* BB_AUDIT Note: gnu chgrp does not support -H, -L, or -P. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/chgrp.html */
+
 #include <stdlib.h>
-#include <string.h>
 #include <unistd.h>
 #include "busybox.h"
 
@@ -32,53 +35,46 @@
 #define lchown	chown
 #endif
 
-
-static long gid;
-
 static int fileAction(const char *fileName, struct stat *statbuf, void* junk)
 {
-	if (lchown(fileName, statbuf->st_uid, (gid == -1) ? statbuf->st_gid : gid) == 0) {
+	if (lchown(fileName, statbuf->st_uid, *((long *) junk)) == 0) {
 		return (TRUE);
 	}
-	perror(fileName);
+	bb_perror_msg("%s", fileName);	/* Avoid multibyte problems. */
 	return (FALSE);
 }
 
 int chgrp_main(int argc, char **argv)
 {
-	int opt;
-	int recursiveFlag = FALSE;
-	char *p=NULL;
+	long gid;
+	int recursiveFlag;;
+	int retval = EXIT_SUCCESS;
+	char *p;
 
-	/* do normal option parsing */
-	while ((opt = getopt(argc, argv, "R")) > 0) {
-		switch (opt) {
-			case 'R':
-				recursiveFlag = TRUE;
-				break;
-			default:
-				show_usage();
-		}
+	recursiveFlag = bb_getopt_ulflags(argc, argv, "R");
+
+	if (argc - optind < 2) {
+		bb_show_usage();
 	}
 
-	if (argc > optind && argc > 2 && argv[optind]) {
-		/* Find the selected group */
-		gid = strtoul(argv[optind], &p, 10);	/* maybe it's already numeric */
-		if (argv[optind] == p)
-			gid = my_getgrnam(argv[optind]);
-	} else {
-		error_msg_and_die(too_few_args);
+	argv += optind;
+
+	/* Find the selected group */
+	gid = strtoul(*argv, &p, 10);	/* maybe it's already numeric */
+	if (*p || (p == *argv)) {		/* trailing chars or nonnumeric */
+		gid = my_getgrnam(*argv);
 	}
+	++argv;
 
 	/* Ok, ready to do the deed now */
-	while (++optind < argc) {
-		if (! recursive_action (argv[optind], recursiveFlag, FALSE, FALSE, 
-					fileAction, fileAction, NULL)) {
-			return EXIT_FAILURE;
+	do {
+		if (! recursive_action (*argv, recursiveFlag, FALSE, FALSE, 
+								fileAction, fileAction, &gid)) {
+			retval = EXIT_FAILURE;
 		}
-	}
-	return EXIT_SUCCESS;
+	} while (*++argv);
 
+	return retval;
 }
 
 /*
diff --git a/coreutils/chmod.c b/coreutils/chmod.c
index ba80e020a..28c98552a 100644
--- a/coreutils/chmod.c
+++ b/coreutils/chmod.c
@@ -24,67 +24,84 @@
  *
  */
 
+/* BB_AUDIT SUSv3 compliant */
+/* BB_AUDIT GNU defects - unsupported options -c, -f, -v, and long options. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/chmod.html */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include <getopt.h>
+#include <sys/stat.h>
 #include "busybox.h"
 
 static int fileAction(const char *fileName, struct stat *statbuf, void* junk)
 {
-	if (!parse_mode((char *)junk, &(statbuf->st_mode)))
-		error_msg_and_die( "unknown mode: %s", (char *)junk);
+	if (!bb_parse_mode((char *)junk, &(statbuf->st_mode)))
+		bb_error_msg_and_die( "unknown mode: %s", (char *)junk);
 	if (chmod(fileName, statbuf->st_mode) == 0)
 		return (TRUE);
-	perror(fileName);
+	bb_perror_msg("%s", fileName);	/* Avoid multibyte problems. */
 	return (FALSE);
 }
 
 int chmod_main(int argc, char **argv)
 {
-	int opt;
+	int retval = EXIT_SUCCESS;
 	int recursiveFlag = FALSE;
-	int modeind = 0;   /* Index of the mode argument in `argv'. */
+	int count;
 	char *smode;
-	static const char chmod_modes[] = "Rrwxstugoa,+-=";
+	char **p;
+	char *p0;
+	char opt = '-';
 
-	/* do normal option parsing */
-	while (1) {
-		int thisind = optind ? optind : 1;
+	++argv;
+	count = 0;
 
-		opt = getopt(argc, argv, chmod_modes);
-		if (opt == EOF)
-				break;
-		smode = strchr(chmod_modes, opt);
-		if(smode == NULL)
-				show_usage();
-		if(smode == chmod_modes) {      /* 'R' */
-			recursiveFlag = TRUE;
-		} else {
-		      if (modeind != 0 && modeind != thisind)
-			show_usage();
-		      modeind = thisind;
+	for (p = argv  ; *p ; p++) {
+		p0 = p[0];
+		if (p0[0] == opt) {
+			if ((p0[1] == '-') && !p0[2]) {
+				opt = 0;	/* Disable further option processing. */
+				continue;
+			}
+			if (p0[1] == 'R') {
+				char *s = p0 + 2;
+				while (*s == 'R') {
+					++s;
+				}
+				if (*s) {
+					bb_show_usage();
+				}
+				recursiveFlag = TRUE;
+				continue;
+			}
+			if (count) {
+				bb_show_usage();
+			}
 		}
+		argv[count] = p0;
+		++count;
 	}
 
-	if (modeind == 0)
-		modeind = optind++;
+	argv[count] = NULL;
 
-	opt = optind;
-	if (opt >= argc) {
-		error_msg_and_die(too_few_args);
+	if (count < 2) {
+		bb_show_usage();
 	}
 
-	smode = argv[modeind];
+	smode = *argv;
+	++argv;
+
 	/* Ok, ready to do the deed now */
-	for (; opt < argc; opt++) {
-		if (! recursive_action (argv[opt], recursiveFlag, FALSE, FALSE, fileAction,
-					fileAction, smode)) {
-			return EXIT_FAILURE;
+	do {
+		if (! recursive_action (*argv, recursiveFlag, FALSE, FALSE,
+								fileAction,	fileAction, smode)) {
+			retval = EXIT_FAILURE;
 		}
-	}
-	return EXIT_SUCCESS;
+	} while (*++argv);
+
+	return retval;
 }
 
 /*
diff --git a/coreutils/chown.c b/coreutils/chown.c
index 4e766a90b..3e983cfa6 100644
--- a/coreutils/chown.c
+++ b/coreutils/chown.c
@@ -21,10 +21,14 @@
  *
  */
 
-#include <stdio.h>
+/* BB_AUDIT SUSv3 defects - unsupported options -h, -H, -L, and -P. */
+/* BB_AUDIT GNU defects - unsupported options -h, -c, -f, -v, and long options. */
+/* BB_AUDIT Note: gnu chown does not support -H, -L, or -P. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/chown.html */
+
 #include <stdlib.h>
-#include <string.h>
 #include <unistd.h>
+#include <string.h>
 #include "busybox.h"
 
 /* Don't use lchown for libc5 or glibc older then 2.1.x */
@@ -42,65 +46,67 @@ static int fileAction(const char *fileName, struct stat *statbuf, void* junk)
 	if (chown_func(fileName, uid, (gid == -1) ? statbuf->st_gid : gid) == 0) {
 		return (TRUE);
 	}
-	perror(fileName);
+	bb_perror_msg("%s", fileName);	/* Avoid multibyte problems. */
 	return (FALSE);
 }
 
+#define FLAG_R 1
+#define FLAG_h 2
+
+static unsigned long get_ug_id(const char *s, long (*my_getxxnam)(const char *))
+{
+	unsigned long r;
+	char *p;
+
+	r = strtoul(s, &p, 10);
+	if (*p || (s == p)) {
+		r = my_getxxnam(s);
+	}
+
+	return r;
+}
+
 int chown_main(int argc, char **argv)
 {
-	int opt;
-	int recursiveFlag = FALSE,
-		noderefFlag = FALSE;
-	char *groupName=NULL;
-	char *p=NULL;
-
-	/* do normal option parsing */
-	while ((opt = getopt(argc, argv, "Rh")) > 0) {
-		switch (opt) {
-			case 'R':
-				recursiveFlag = TRUE;
-				break;
-			case 'h':
-				noderefFlag = TRUE;
-				break;
-			default:
-				show_usage();
-		}
+	int flags;
+	int retval = EXIT_SUCCESS;
+	char *groupName;
+
+	flags = bb_getopt_ulflags(argc, argv, "Rh");
+
+	if (flags & FLAG_h) chown_func = lchown;
+
+	if (argc - optind < 2) {
+		bb_show_usage();
 	}
 
-	if (noderefFlag) chown_func = lchown;
-
-	if (argc > optind && argc > 2 && argv[optind]) {
-		/* First, check if there is a group name here */
-		groupName = strchr(argv[optind], '.');
-		if (groupName == NULL)
-			groupName = strchr(argv[optind], ':');
-		if (groupName) {
-			*groupName++ = '\0';
-			gid = strtoul(groupName, &p, 10);
-			if (groupName == p)
-				gid = my_getgrnam(groupName);
-		} else {
-			gid = -1;
-		}
-		/* Now check for the username */
-		uid = strtoul(argv[optind], &p, 10);	/* Is is numeric? */
-		if (argv[optind] == p) {
-			uid = my_getpwnam(argv[optind]);
-		}
-	} else {
-		error_msg_and_die(too_few_args);
+	argv += optind;
+
+	/* First, check if there is a group name here */
+	if ((groupName = strchr(*argv, '.')) == NULL) {
+		groupName = strchr(*argv, ':');
+	}
+
+	gid = -1;
+	if (groupName) {
+		*groupName++ = '\0';
+		gid = get_ug_id(groupName, my_getgrnam);
 	}
 
+	/* Now check for the username */
+	uid = get_ug_id(*argv, my_getpwnam);
+
+	++argv;
+	
 	/* Ok, ready to do the deed now */
-	while (++optind < argc) {
-		if (! recursive_action (argv[optind], recursiveFlag, FALSE, FALSE, 
-					fileAction, fileAction, NULL)) {
-			return EXIT_FAILURE;
+	do {
+		if (! recursive_action (*argv, (flags & FLAG_R), FALSE, FALSE, 
+								fileAction, fileAction, NULL)) {
+			retval = EXIT_FAILURE;
 		}
-	}
-	return EXIT_SUCCESS;
+	} while (*++argv);
 
+	return retval;
 }
 
 /*
diff --git a/coreutils/chroot.c b/coreutils/chroot.c
index ba3e5f864..01e4d564c 100644
--- a/coreutils/chroot.c
+++ b/coreutils/chroot.c
@@ -21,6 +21,8 @@
  *
  */
 
+/* BB_AUDIT SUSv3 N/A -- Matches GNU behavior. */
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>
@@ -29,46 +31,24 @@
 
 int chroot_main(int argc, char **argv)
 {
-	char *prog;
-
-	if ((argc < 2) || (**(argv + 1) == '-')) {
-		show_usage();
+	if (argc < 2) {
+		bb_show_usage();
 	}
-	argc--;
-	argv++;
 
+	++argv;
 	if (chroot(*argv) || (chdir("/"))) {
-		perror_msg_and_die("cannot change root directory to %s", *argv);
+		bb_perror_msg_and_die("cannot change root directory to %s", *argv);
 	}
 
-	argc--;
-	argv++;
-	if (argc >= 1) {
-		prog = *argv;
-		execvp(*argv, argv);
-	} else {
-#if defined shell_main && defined CONFIG_FEATURE_SH_STANDALONE_SHELL
-		char shell[] = "/bin/sh";
-		char *shell_argv[2] = { shell, NULL };
-		applet_name = shell;
-		shell_main(1, shell_argv);
-		return EXIT_SUCCESS;
-#else
-		prog = getenv("SHELL");
-		if (!prog)
-			prog = "/bin/sh";
-		execlp(prog, prog, NULL);
-#endif
+	++argv;
+	if (argc == 2) {
+		argv -= 2;
+		if (!(*argv = getenv("SHELL"))) {
+			*argv = (char *) "/bin/sh";
+		}
+		argv[1] = (char *) "-i";
 	}
-	perror_msg_and_die("cannot execute %s", prog);
 
+	execvp(*argv, argv);
+	bb_perror_msg_and_die("cannot execute %s", *argv);
 }
-
-
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
diff --git a/coreutils/cmp.c b/coreutils/cmp.c
index 07bf3be92..43dbc842f 100644
--- a/coreutils/cmp.c
+++ b/coreutils/cmp.c
@@ -20,59 +20,133 @@
  *
  */
 
+/* BB_AUDIT SUSv3 (virtually) compliant -- uses nicer GNU format for -l. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/cmp.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Original version majorly reworked for SUSv3 compliance, bug fixes, and
+ * size optimizations.  Changes include:
+ * 1) Now correctly distingusishes between errors and actual file differences.
+ * 2) Proper handling of '-' args.
+ * 3) Actual error checking of i/o.
+ * 4) Accept SUSv3 -l option.  Note that we use the slightly nicer gnu format
+ *    in the '-l' case.
+ */
+
 #include <stdio.h>
-#include <string.h>
-#include <errno.h>
 #include <stdlib.h>
-#include <getopt.h>
+#include <unistd.h>
 #include "busybox.h"
 
+static FILE *cmp_xfopen_input(const char *filename)
+{
+	FILE *fp;
+
+	if ((fp = bb_wfopen_input(filename)) != NULL) {
+		return fp;
+	}
+
+	exit(bb_default_error_retval);	/* We already output an error message. */
+}
+
+static const char fmt_eof[] = "cmp: EOF on %s\n";
+static const char fmt_differ[] = "%s %s differ: char %d, line %d\n";
+#if 0
+static const char fmt_l_opt[] = "%.0s%.0s%d %o %o\n";	/* SUSv3 format */
+#else
+static const char fmt_l_opt[] = "%.0s%.0s%d %3o %3o\n";	/* nicer gnu format */
+#endif
+
+static const char opt_chars[] = "sl";
+
+enum {
+	OPT_s = 1,
+	OPT_l = 2
+};
+
 int cmp_main(int argc, char **argv)
 {
-	FILE *fp1 = NULL, *fp2 = stdin;
-	char *filename1, *filename2 = "-";
-	int c, c1, c2, char_pos = 1, line_pos = 1, silent = FALSE;
-
-	while ((c = getopt(argc, argv, "s")) != EOF) {
-		switch (c) {
-			case 's':
-				silent = TRUE;
-				break;
-			default:
-				show_usage();
-		}
+	FILE *fp1, *fp2, *outfile = stdout;
+	const char *filename1, *filename2;
+	const char *fmt;
+	int c1, c2, char_pos, line_pos;
+	int opt_flags;
+	int exit_val = 0;
+
+	bb_default_error_retval = 2;	/* 1 is returned if files are different. */
+
+	opt_flags = bb_getopt_ulflags(argc, argv, opt_chars);
+
+	if ((opt_flags == 3) || (((unsigned int)(--argc - optind)) > 1)) {
+		bb_show_usage();
 	}
 
-	filename1 = argv[optind];
-	switch (argc - optind) {
-		case 2:
-			fp2 = xfopen(filename2 = argv[optind + 1], "r");
-		case 1:
-			fp1 = xfopen(filename1, "r");
-			break;
-		default:
-			show_usage();
+	fp1 = cmp_xfopen_input(filename1 = *(argv += optind));
+
+	filename2 = "-";
+	if (*++argv) {
+		filename2 = *argv;
 	}
+	fp2 = cmp_xfopen_input(filename2);
 
+	if (fp1 == fp2) {			/* Paranioa check... stdin == stdin? */
+		/* Note that we don't bother reading stdin.  Neither does gnu wc.
+		 * But perhaps we should, so that other apps down the chain don't
+		 * get the input.  Consider 'echo hello | (cmp - - && cat -)'.
+		 */
+		return 0;
+	}
+
+	fmt = fmt_differ;
+	if (opt_flags == OPT_l) {
+		fmt = fmt_l_opt;
+	}
+
+	char_pos = 0;
+	line_pos = 1;
 	do {
-		c1 = fgetc(fp1);
-		c2 = fgetc(fp2);
-		if (c1 != c2) {
-			if (silent)
-				return EXIT_FAILURE;
-			if (c1 == EOF)
-				printf("EOF on %s\n", filename1);
-			else if (c2 == EOF)
-				printf("EOF on %s\n", filename2);
-			else
-				printf("%s %s differ: char %d, line %d\n", filename1, filename2,
-						char_pos, line_pos);
-			return EXIT_FAILURE;
+		c1 = getc(fp1);
+		c2 = getc(fp2);
+		++char_pos;
+		if (c1 != c2) {			/* Remember -- a read error may have occurred. */
+			exit_val = 1;		/* But assume the files are different for now. */
+			if (c2 == EOF) {
+				/* We know that fp1 isn't at EOF or in an error state.  But to
+				 * save space below, things are setup to expect an EOF in fp1
+				 * if an EOF occurred.  So, swap things around.
+				 */
+				fp1 = fp2;
+				filename1 = filename2;
+				c1 = c2;
+			}
+			if (c1 == EOF) {
+				bb_xferror(fp1, filename1);
+				fmt = fmt_eof;	/* Well, no error, so it must really be EOF. */
+				outfile = stderr;
+				/* There may have been output to stdout (option -l), so
+				 * make sure we fflush before writing to stderr. */
+				bb_xfflush_stdout();
+			}
+			if (opt_flags != OPT_s) {
+				if (opt_flags == OPT_l) {
+					line_pos = c1;	/* line_pos is unused in the -l case. */
+				}
+				bb_fprintf(outfile, fmt, filename1, filename2, char_pos, line_pos, c2);
+				if (opt_flags) {	/* This must be -l since not -s. */
+					/* If we encountered and EOF, the while check will catch it. */
+					continue;
+				}
+			}
+			break;
+		}
+		if (c1 == '\n') {
+			++line_pos;
 		}
-		char_pos++;
-		if (c1 == '\n')
-			line_pos++;
 	} while (c1 != EOF);
 
-	return EXIT_SUCCESS;
+	bb_xferror(fp1, filename1);
+	bb_xferror(fp2, filename2);
+
+	bb_fflush_stdout_and_exit(exit_val);
 }
diff --git a/coreutils/cp.c b/coreutils/cp.c
index 8f8fe5ed3..c5dd31ec3 100644
--- a/coreutils/cp.c
+++ b/coreutils/cp.c
@@ -2,7 +2,6 @@
 /*
  * Mini cp implementation for busybox
  *
- *
  * Copyright (C) 2000 by Matt Kraai <kraai@alumni.carnegiemellon.edu>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -21,6 +20,15 @@
  *
  */
 
+/* BB_AUDIT SUSv3 defects - unsupported options -H, -L, and -P. */
+/* BB_AUDIT GNU defects - only extension options supported are -a and -d.  */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/cp.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Size reduction.
+ */
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -29,86 +37,76 @@
 #include <errno.h>
 #include <dirent.h>
 #include <stdlib.h>
-
+#include <assert.h>
 #include "busybox.h"
+#include "libcoreutils/coreutils.h"
+
+static const char cp_opts[] = "pdRfia";	/* WARNING!! ORDER IS IMPORTANT!! */
 
 extern int cp_main(int argc, char **argv)
 {
+	struct stat source_stat;
+	struct stat dest_stat;
+	const char *last;
+	const char *dest;
+	int s_flags;
+	int d_flags;
+	int flags;
 	int status = 0;
-	int opt;
-	int flags = FILEUTILS_DEREFERENCE;
-	int i;
 
-	while ((opt = getopt(argc, argv, "adfipR")) != -1)
-		switch (opt) {
-		case 'a':
-			flags |= FILEUTILS_PRESERVE_STATUS | FILEUTILS_RECUR;
-			/* fallthrough */
-		case 'd':
-			flags &= ~FILEUTILS_DEREFERENCE;
-			break;
-		case 'f':
-			flags |= FILEUTILS_FORCE;
-			break;
-		case 'i':
-			flags |= FILEUTILS_INTERACTIVE;
-			break;
-		case 'p':
-			flags |= FILEUTILS_PRESERVE_STATUS;
-			break;
-		case 'R':
-			flags |= FILEUTILS_RECUR;
-			break;
-		default:
-			show_usage();
-		}
-	
-	if (optind + 2 > argc)
-		show_usage();
+	/* Since these are enums, #if tests will not work.  So use assert()s. */
+	assert(FILEUTILS_PRESERVE_STATUS == 1);
+	assert(FILEUTILS_DEREFERENCE == 2);
+	assert(FILEUTILS_RECUR == 4);
+	assert(FILEUTILS_FORCE == 8);
+	assert(FILEUTILS_INTERACTIVE == 16);
 
-	/* If there are only two arguments and...  */
-	if (optind + 2 == argc) {
-		struct stat source_stat;
-		struct stat dest_stat;
-		int source_exists = 1;
-		int dest_exists = 1;
+	flags = bb_getopt_ulflags(argc, argv, cp_opts);
 
-		if ((!(flags & FILEUTILS_DEREFERENCE) &&
-				lstat(argv[optind], &source_stat) < 0) ||
-				((flags & FILEUTILS_DEREFERENCE) &&
-				 stat(argv[optind], &source_stat))) {
-			if (errno != ENOENT)
-				perror_msg_and_die("unable to stat `%s'", argv[optind]);
-			source_exists = 0;
-		}
+	if (flags & 32) {
+		flags |= (FILEUTILS_PRESERVE_STATUS | FILEUTILS_RECUR | FILEUTILS_DEREFERENCE);
+	}
+
+	flags ^= FILEUTILS_DEREFERENCE;		/* The sense of this flag was reversed. */
+
+	if (optind + 2 > argc) {
+		bb_show_usage();
+	}
+
+	last = argv[argc - 1];
+	argv += optind;
 
-		if (stat(argv[optind + 1], &dest_stat) < 0) {
-			if (errno != ENOENT)
-				perror_msg_and_die("unable to stat `%s'", argv[optind + 1]);
-			dest_exists = 0;
+	/* If there are only two arguments and...  */
+	if (optind + 2 == argc) {
+		s_flags = cp_mv_stat2(*argv, &source_stat,
+								 (flags & FILEUTILS_DEREFERENCE) ? stat : lstat);
+		if ((s_flags < 0) || ((d_flags = cp_mv_stat(last, &dest_stat)) < 0)) {
+			exit(EXIT_FAILURE);
 		}
-		
 		/* ...if neither is a directory or...  */
-		if (((!source_exists || !S_ISDIR(source_stat.st_mode)) &&
-				(!dest_exists || !S_ISDIR(dest_stat.st_mode))) ||
-				/* ...recursing, the first is a directory, and the
-				 * second doesn't exist, then... */
-				((flags & FILEUTILS_RECUR) && S_ISDIR(source_stat.st_mode) &&
-				 !dest_exists)) {
+		if ( !((s_flags | d_flags) & 2) ||
+			/* ...recursing, the 1st is a directory, and the 2nd doesn't exist... */
+			/* ((flags & FILEUTILS_RECUR) && (s_flags & 2) && !d_flags) */
+			/* Simplify the above since FILEUTILS_RECUR >> 1 == 2. */
+			((((flags & FILEUTILS_RECUR) >> 1) & s_flags) && !d_flags)
+		) {
 			/* ...do a simple copy.  */
-			if (copy_file(argv[optind], argv[optind + 1], flags) < 0)
-				status = 1;
-			return status;
+				dest = last;
+				goto DO_COPY; /* Note: optind+2==argc implies argv[1]==last below. */
 		}
 	}
 
-	for (i = optind; i < argc - 1; i++) {
-		char *dest = concat_path_file(argv[argc - 1],
-				get_last_path_component(argv[i]));
-		if (copy_file(argv[i], dest, flags) < 0)
+	do {
+		dest = concat_path_file(last, bb_get_last_path_component(*argv));
+	DO_COPY:
+		if (copy_file(*argv, dest, flags) < 0) {
 			status = 1;
-		free(dest);
-	}
+		}
+		if (*++argv == last) {
+			break;
+		}
+		free((void *) dest);
+	} while (1);
 
-	return status;
+	exit(status);
 }
diff --git a/coreutils/cut.c b/coreutils/cut.c
index 3ed264870..c24cf6611 100644
--- a/coreutils/cut.c
+++ b/coreutils/cut.c
@@ -92,7 +92,7 @@ static void parse_lists(char *lists)
 		} else {
 			s = strtoul(ntok, &junk, 10);
 			if(*junk != '\0' || s < 0)
-				error_msg_and_die("invalid byte or field list");
+				bb_error_msg_and_die("invalid byte or field list");
 			
 			/* account for the fact that arrays are zero based, while the user
 			 * expects the first char on the line to be char # 1 */
@@ -109,7 +109,7 @@ static void parse_lists(char *lists)
 		} else {
 			e = strtoul(ntok, &junk, 10);
 			if(*junk != '\0' || e < 0)
-				error_msg_and_die("invalid byte or field list");
+				bb_error_msg_and_die("invalid byte or field list");
 			/* if the user specified and end position of 0, that means "til the
 			 * end of the line */
 			if (e == 0)
@@ -121,7 +121,7 @@ static void parse_lists(char *lists)
 
 		/* if there's something left to tokenize, the user past an invalid list */
 		if (ltok)
-			error_msg_and_die("invalid byte or field list");
+			bb_error_msg_and_die("invalid byte or field list");
 		
 		/* add the new list */
 		cut_lists = xrealloc(cut_lists, sizeof(struct cut_list) * (++nlists));
@@ -131,7 +131,7 @@ static void parse_lists(char *lists)
 
 	/* make sure we got some cut positions out of all that */
 	if (nlists == 0)
-		error_msg_and_die("missing list of positions");
+		bb_error_msg_and_die("missing list of positions");
 
 	/* now that the lists are parsed, we need to sort them to make life easier
 	 * on us when it comes time to print the chars / fields / lines */
@@ -267,8 +267,7 @@ static void cut_file(FILE *file)
 	unsigned int linenum = 0; /* keep these zero-based to be consistent */
 
 	/* go through every line in the file */
-	while ((line = get_line_from_file(file)) != NULL) {
-		chomp(line);
+	while ((line = bb_get_chomped_line_from_file(file)) != NULL) {
 
 		/* cut based on chars/bytes XXX: only works when sizeof(char) == byte */
 		if (part == 'c' || part == 'b')
@@ -299,14 +298,14 @@ extern int cut_main(int argc, char **argv)
 			case 'f':
 				/* make sure they didn't ask for two types of lists */
 				if (part != 0) {
-					error_msg_and_die("only one type of list may be specified");
+					bb_error_msg_and_die("only one type of list may be specified");
 				}
 				part = (char)opt;
 				parse_lists(optarg);
 				break;
 			case 'd':
 				if (strlen(optarg) > 1) {
-					error_msg_and_die("the delimiter must be a single character");
+					bb_error_msg_and_die("the delimiter must be a single character");
 				}
 				delim = optarg[0];
 				break;
@@ -320,17 +319,17 @@ extern int cut_main(int argc, char **argv)
 	}
 
 	if (part == 0) {
-		error_msg_and_die("you must specify a list of bytes, characters, or fields");
+		bb_error_msg_and_die("you must specify a list of bytes, characters, or fields");
 	}
 
 	/*  non-field (char or byte) cutting has some special handling */
 	if (part != 'f') {
 		if (supress_non_delimited_lines) {
-			error_msg_and_die("suppressing non-delimited lines makes sense"
+			bb_error_msg_and_die("suppressing non-delimited lines makes sense"
 					" only when operating on fields");
 		}
 		if (delim != '\t' && part != 'f') {
-			error_msg_and_die("a delimiter may be specified only when operating on fields");
+			bb_error_msg_and_die("a delimiter may be specified only when operating on fields");
 		}
 	}
 
@@ -344,7 +343,7 @@ extern int cut_main(int argc, char **argv)
 		int i;
 		FILE *file;
 		for (i = optind; i < argc; i++) {
-			file = wfopen(argv[i], "r");
+			file = bb_wfopen(argv[i], "r");
 			if(file) {
 				cut_file(file);
 				fclose(file);
diff --git a/coreutils/date.c b/coreutils/date.c
index d68c04a8d..afbedb90d 100644
--- a/coreutils/date.c
+++ b/coreutils/date.c
@@ -53,7 +53,7 @@ static struct tm *date_conv_time(struct tm *tm_time, const char *t_string)
 				&(tm_time->tm_year));
 
 	if (nr < 4 || nr > 5) {
-		error_msg_and_die(invalid_date, t_string);
+		bb_error_msg_and_die(bb_msg_invalid_date, t_string);
 	}
 
 	/* correct for century  - minor Y2K problem here? */
@@ -108,7 +108,7 @@ static struct tm *date_conv_ftime(struct tm *tm_time, const char *t_string)
 		t.tm_year -= 1900;	/* Adjust years */
 		t.tm_mon -= 1;	/* Adjust dates from 1-12 to 0-11 */
 	} else {
-		error_msg_and_die(invalid_date, t_string);
+		bb_error_msg_and_die(bb_msg_invalid_date, t_string);
 	}
 	*tm_time = t;
 	return (tm_time);
@@ -145,25 +145,25 @@ int date_main(int argc, char **argv)
 		case 's':
 			set_time = 1;
 			if ((date_str != NULL) || ((date_str = optarg) == NULL)) {
-				show_usage();
+				bb_show_usage();
 			}
 			break;
 		case 'u':
 			utc = 1;
 			if (putenv("TZ=UTC0") != 0)
-				error_msg_and_die(memory_exhausted);
+				bb_error_msg_and_die(bb_msg_memory_exhausted);
 			break;
 		case 'd':
 			use_arg = 1;
 			if ((date_str != NULL) || ((date_str = optarg) == NULL))
-				show_usage();
+				bb_show_usage();
 			break;
 #ifdef CONFIG_FEATURE_DATE_ISOFMT
 		case 'I':
 			if (!optarg)
 				ifmt = 1;
 			else {
-				int ifmt_len = xstrlen(optarg);
+				int ifmt_len = bb_strlen(optarg);
 
 				if ((ifmt_len <= 4)
 					&& (strncmp(optarg, "date", ifmt_len) == 0)) {
@@ -180,11 +180,11 @@ int date_main(int argc, char **argv)
 				}
 			}
 			if (ifmt) {
-				break;	/* else show_usage(); */
+				break;	/* else bb_show_usage(); */
 			}
 #endif
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
@@ -220,15 +220,15 @@ int date_main(int argc, char **argv)
 		/* Correct any day of week and day of year etc. fields */
 		tm = mktime(&tm_time);
 		if (tm < 0) {
-			error_msg_and_die(invalid_date, date_str);
+			bb_error_msg_and_die(bb_msg_invalid_date, date_str);
 		}
 		if (utc && (putenv("TZ=UTC0") != 0)) {
-			error_msg_and_die(memory_exhausted);
+			bb_error_msg_and_die(bb_msg_memory_exhausted);
 		}
 
 		/* if setting time, set it */
 		if (set_time && (stime(&tm) < 0)) {
-			perror_msg("cannot set date");
+			bb_perror_msg("cannot set date");
 		}
 	}
 
diff --git a/coreutils/dd.c b/coreutils/dd.c
index 8c7272b5c..11508614f 100644
--- a/coreutils/dd.c
+++ b/coreutils/dd.c
@@ -62,19 +62,19 @@ int dd_main(int argc, char **argv)
 	int ifd;
 	int ofd;
 	int i;
-	char *infile = NULL;
-	char *outfile = NULL;
+	const char *infile = NULL;
+	const char *outfile = NULL;
 	char *buf;
 
 	for (i = 1; i < argc; i++) {
 		if (strncmp("bs=", argv[i], 3) == 0)
-			bs = parse_number(argv[i]+3, dd_suffixes);
+			bs = bb_xparse_number(argv[i]+3, dd_suffixes);
 		else if (strncmp("count=", argv[i], 6) == 0)
-			count = parse_number(argv[i]+6, dd_suffixes);
+			count = bb_xparse_number(argv[i]+6, dd_suffixes);
 		else if (strncmp("seek=", argv[i], 5) == 0)
-			seek = parse_number(argv[i]+5, dd_suffixes);
+			seek = bb_xparse_number(argv[i]+5, dd_suffixes);
 		else if (strncmp("skip=", argv[i], 5) == 0)
-			skip = parse_number(argv[i]+5, dd_suffixes);
+			skip = bb_xparse_number(argv[i]+5, dd_suffixes);
 		else if (strncmp("if=", argv[i], 3) == 0)
 			infile = argv[i]+3;
 		else if (strncmp("of=", argv[i], 3) == 0)
@@ -92,7 +92,7 @@ int dd_main(int argc, char **argv)
 					noerror = TRUE;
 					buf += 7;
 				} else {
-					error_msg_and_die("invalid conversion `%s'", argv[i]+5);
+					bb_error_msg_and_die("invalid conversion `%s'", argv[i]+5);
 				}
 				if (buf[0] == '\0')
 					break;
@@ -100,18 +100,18 @@ int dd_main(int argc, char **argv)
 					buf++;
 			}
 		} else
-			show_usage();
+			bb_show_usage();
 	}
 
 	buf = xmalloc(bs);
 
 	if (infile != NULL) {
 		if ((ifd = open(infile, O_RDONLY)) < 0) {
-			perror_msg_and_die("%s", infile);
+			bb_perror_msg_and_die("%s", infile);
 		}
 	} else {
 		ifd = STDIN_FILENO;
-		infile = "standard input";
+		infile = bb_msg_standard_input;
 	}
 
 	if (outfile != NULL) {
@@ -122,7 +122,7 @@ int dd_main(int argc, char **argv)
 		}
 
 		if ((ofd = open(outfile, oflag, 0666)) < 0) {
-			perror_msg_and_die("%s", outfile);
+			bb_perror_msg_and_die("%s", outfile);
 		}
 
 		if (seek && trunc) {
@@ -131,24 +131,24 @@ int dd_main(int argc, char **argv)
 
 				if (fstat (ofd, &st) < 0 || S_ISREG (st.st_mode) ||
 						S_ISDIR (st.st_mode)) {
-					perror_msg_and_die("%s", outfile);
+					bb_perror_msg_and_die("%s", outfile);
 				}
 			}
 		}
 	} else {
 		ofd = STDOUT_FILENO;
-		outfile = "standard output";
+		outfile = bb_msg_standard_output;
 	}
 
 	if (skip) {
 		if (lseek(ifd, skip * bs, SEEK_CUR) < 0) {
-			perror_msg_and_die("%s", infile);
+			bb_perror_msg_and_die("%s", infile);
 		}
 	}
 
 	if (seek) {
 		if (lseek(ofd, seek * bs, SEEK_CUR) < 0) {
-			perror_msg_and_die("%s", outfile);
+			bb_perror_msg_and_die("%s", outfile);
 		}
 	}
 
@@ -161,9 +161,9 @@ int dd_main(int argc, char **argv)
 		if (n < 0) {
 			if (noerror) {
 				n = bs;
-				perror_msg("%s", infile);
+				bb_perror_msg("%s", infile);
 			} else {
-				perror_msg_and_die("%s", infile);
+				bb_perror_msg_and_die("%s", infile);
 			}
 		}
 		if (n == 0) {
@@ -178,9 +178,9 @@ int dd_main(int argc, char **argv)
 			memset(buf + n, '\0', bs - n);
 			n = bs;
 		}
-		n = full_write(ofd, buf, n);
+		n = bb_full_write(ofd, buf, n);
 		if (n < 0) {
-			perror_msg_and_die("%s", outfile);
+			bb_perror_msg_and_die("%s", outfile);
 		}
 		if (n == bs) {
 			out_full++;
@@ -190,15 +190,16 @@ int dd_main(int argc, char **argv)
 	}
 
 	if (close (ifd) < 0) {
-		perror_msg_and_die("%s", infile);
+		bb_perror_msg_and_die("%s", infile);
 	}
 
 	if (close (ofd) < 0) {
-		perror_msg_and_die("%s", outfile);
+		bb_perror_msg_and_die("%s", outfile);
 	}
 
-	fprintf(stderr, "%ld+%ld records in\n", (long)in_full, (long)in_part);
-	fprintf(stderr, "%ld+%ld records out\n", (long)out_full, (long)out_part);
+	fprintf(stderr, "%ld+%ld records in\n%ld+%ld records out\n",
+			(long)in_full, (long)in_part,
+			(long)out_full, (long)out_part);
 
 	return EXIT_SUCCESS;
 }
diff --git a/coreutils/df.c b/coreutils/df.c
index 0e9e5d61a..7d007a003 100644
--- a/coreutils/df.c
+++ b/coreutils/df.c
@@ -22,74 +22,45 @@
  *
  */
 
+/* BB_AUDIT SUSv3 _NOT_ compliant -- options -P and -t missing.  Also blocksize. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/df.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Size reduction.  Removed floating point dependency.  Added error checking
+ * on output.  Output stats on 0-sized filesystems if specificly listed on
+ * the command line.  Properly round *-blocks, Used, and Available quantities.
+ */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
 #include <mntent.h>
 #include <sys/vfs.h>
-#include <getopt.h>
 #include "busybox.h"
 
-extern const char mtab_file[];	/* Defined in utility.c */
-#ifdef CONFIG_FEATURE_HUMAN_READABLE
-static unsigned long df_disp_hr = KILOBYTE; 
+#ifndef CONFIG_FEATURE_HUMAN_READABLE
+static long kscale(long b, long bs)
+{
+	return ( b * (long long) bs + KILOBYTE/2 ) / KILOBYTE;
+}
 #endif
 
-static int do_df(char *device, const char *mount_point)
+extern int df_main(int argc, char **argv)
 {
-	struct statfs s;
 	long blocks_used;
 	long blocks_percent_used;
-
-	if (statfs(mount_point, &s) != 0) {
-		perror_msg("%s", mount_point);
-		return FALSE;
-	}
-
-	if (s.f_blocks > 0) {
-		blocks_used = s.f_blocks - s.f_bfree;
-		if(blocks_used == 0)
-			blocks_percent_used = 0;
-		else {
-			blocks_percent_used = (long)
-			  (blocks_used * 100.0 / (blocks_used + s.f_bavail) + 0.5);
-		}
-		if (strcmp(device, "/dev/root") == 0) {
-			/* Adjusts device to be the real root device,
-			 * or leaves device alone if it can't find it */
-			device = find_real_root_device_name(device);
-			if(device==NULL)
-				return FALSE;
-		}
 #ifdef CONFIG_FEATURE_HUMAN_READABLE
-		printf("%-20s %9s ", device,
-				make_human_readable_str(s.f_blocks, s.f_bsize, df_disp_hr));
-
-		printf("%9s ",
-				make_human_readable_str( (s.f_blocks - s.f_bfree), s.f_bsize, df_disp_hr));
-
-		printf("%9s %3ld%% %s\n",
-				make_human_readable_str(s.f_bavail, s.f_bsize, df_disp_hr),
-				blocks_percent_used, mount_point);
-#else
-		printf("%-20s %9ld %9ld %9ld %3ld%% %s\n",
-				device,
-				(long) (s.f_blocks * (s.f_bsize / (double)KILOBYTE)),
-				(long) ((s.f_blocks - s.f_bfree)*(s.f_bsize/(double)KILOBYTE)),
-				(long) (s.f_bavail * (s.f_bsize / (double)KILOBYTE)),
-				blocks_percent_used, mount_point);
+	unsigned long df_disp_hr = KILOBYTE; 
 #endif
-	}
-
-	return TRUE;
-}
-
-extern int df_main(int argc, char **argv)
-{
 	int status = EXIT_SUCCESS;
-	int opt = 0;
-	int i = 0;
-	char disp_units_hdr[80] = "1k-blocks"; /* default display is kilobytes */
+	int opt;
+	FILE *mount_table;
+	struct mntent *mount_entry;
+	struct statfs s;
+	static const char hdr_1k[] = "1k-blocks"; /* default display is kilobytes */;
+	const char *disp_units_hdr = hdr_1k;
 
 	while ((opt = getopt(argc, argv, "k"
 #ifdef CONFIG_FEATURE_HUMAN_READABLE
@@ -101,52 +72,106 @@ extern int df_main(int argc, char **argv)
 #ifdef CONFIG_FEATURE_HUMAN_READABLE
 			case 'h':
 				df_disp_hr = 0;
-				strcpy(disp_units_hdr, "     Size");
+				disp_units_hdr = "     Size";
 				break;
 			case 'm':
 				df_disp_hr = MEGABYTE;
-				strcpy(disp_units_hdr, "1M-blocks");
+				disp_units_hdr = "1M-blocks";
 				break;
 #endif
 			case 'k':
 				/* default display is kilobytes */
+#ifdef CONFIG_FEATURE_HUMAN_READABLE
+				df_disp_hr = KILOBYTE;
+				disp_units_hdr =  hdr_1k;
+#endif
 				break;
 			default:
-					  show_usage();
+					  bb_show_usage();
 		}
 	}
 
-	printf("%-20s %-14s %s %s %s %s\n", "Filesystem", disp_units_hdr,
-	       "Used", "Available", "Use%", "Mounted on");
+	bb_printf("Filesystem%11s%-15sUsed Available Use%% Mounted on\n",
+			  "", disp_units_hdr);
 
-	if(optind < argc) {
-		struct mntent *mount_entry;
-		for(i = optind; i < argc; i++)
-		{
-			if ((mount_entry = find_mount_point(argv[i], mtab_file)) == 0) {
-				error_msg("%s: can't find mount point.", argv[i]);
-				status = EXIT_FAILURE;
-			} else if (!do_df(mount_entry->mnt_fsname, mount_entry->mnt_dir))
-				status = EXIT_FAILURE;
+	mount_table = NULL;
+	argv += optind;
+	if (optind >= argc) {
+		if (!(mount_table = setmntent(bb_path_mtab_file, "r"))) {
+			bb_perror_msg_and_die(bb_path_mtab_file);
 		}
-	} else {
-		FILE *mount_table;
-		struct mntent *mount_entry;
+	}
 
-		mount_table = setmntent(mtab_file, "r");
-		if (mount_table == 0) {
-			perror_msg("%s", mtab_file);
-			return EXIT_FAILURE;
-		}
+	do {
+		const char *device;
+		const char *mount_point;
 
-		while ((mount_entry = getmntent(mount_table))) {
-			if (!do_df(mount_entry->mnt_fsname, mount_entry->mnt_dir))
+		if (mount_table) {
+			if (!(mount_entry = getmntent(mount_table))) {
+				endmntent(mount_table);
+				break;
+			}
+		} else {
+			if (!(mount_point = *argv++)) {
+				break;
+			}
+			if (!(mount_entry = find_mount_point(mount_point, bb_path_mtab_file))) {
+				bb_error_msg("%s: can't find mount point.", mount_point);
+			SET_ERROR:
 				status = EXIT_FAILURE;
+				continue;
+			}
 		}
-		endmntent(mount_table);
-	}
 
-	return status;
+		device = mount_entry->mnt_fsname;
+		mount_point = mount_entry->mnt_dir;
+
+		if (statfs(mount_point, &s) != 0) {
+			bb_perror_msg("%s", mount_point);
+			goto SET_ERROR;
+		}
+		
+		if ((s.f_blocks > 0) || !mount_table){
+			blocks_used = s.f_blocks - s.f_bfree;
+			blocks_percent_used = 0;
+			if (blocks_used + s.f_bavail) {
+				blocks_percent_used = (((long long) blocks_used) * 100
+									   + (blocks_used + s.f_bavail)/2
+									   ) / (blocks_used + s.f_bavail);
+			}
+			
+			if (strcmp(device, "/dev/root") == 0) {
+				/* Adjusts device to be the real root device,
+				* or leaves device alone if it can't find it */
+				if ((device = find_real_root_device_name(device)) != NULL) {
+					goto SET_ERROR;
+				}
+			}
+			
+#ifdef CONFIG_FEATURE_HUMAN_READABLE
+			bb_printf("%-21s%9s ", device,
+					  make_human_readable_str(s.f_blocks, s.f_bsize, df_disp_hr));
+			
+			bb_printf("%9s ",
+					  make_human_readable_str( (s.f_blocks - s.f_bfree),
+											  s.f_bsize, df_disp_hr));
+			
+			bb_printf("%9s %3ld%% %s\n",
+					  make_human_readable_str(s.f_bavail, s.f_bsize, df_disp_hr),
+					  blocks_percent_used, mount_point);
+#else
+			bb_printf("%-21s%9ld %9ld %9ld %3ld%% %s\n",
+					  device,
+					  kscale(s.f_blocks, s.f_bsize),
+					  kscale(s.f_blocks-s.f_bfree, s.f_bsize),
+					  kscale(s.f_bavail, s.f_bsize),
+					  blocks_percent_used, mount_point);
+#endif
+		}
+
+	} while (1);
+
+	bb_fflush_stdout_and_exit(status);
 }
 
 /*
diff --git a/coreutils/dirname.c b/coreutils/dirname.c
index 387233789..4c6115e66 100644
--- a/coreutils/dirname.c
+++ b/coreutils/dirname.c
@@ -21,20 +21,20 @@
  *
  */
 
-/* getopt not needed */
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/dirname.html */
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <string.h>
 #include "busybox.h"
 
 extern int dirname_main(int argc, char **argv)
 {
-	if ((argc < 2) || (**(argv + 1) == '-'))
-		show_usage();
-	argv++;
+	if (argc != 2) {
+		bb_show_usage();
+	}
 
-	puts (dirname (argv[0]));
+	puts(dirname(argv[1]));
 
-	return EXIT_SUCCESS;
+	bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 }
diff --git a/coreutils/dos2unix.c b/coreutils/dos2unix.c
index b1d0a9d70..c28e6a8b9 100644
--- a/coreutils/dos2unix.c
+++ b/coreutils/dos2unix.c
@@ -35,6 +35,10 @@
 #include <sys/time.h>
 #include "busybox.h"
 
+#define CT_AUTO         0
+#define CT_UNIX2DOS     1
+#define CT_DOS2UNIX     2
+
 /* We are making a lame pseudo-random string generator here.  in
  * convert(), each pass through the while loop will add more and more
  * stuff into value, which is _supposed_ to wrap.  We don't care about
@@ -55,15 +59,13 @@ static int convert(char *fn, int ConvType)
 	FILE *in = stdin, *out = stdout;
 
 	if (fn != NULL) {
-		if ((in = wfopen(fn, "rw")) == NULL) {
-			return -1;
-		}
+		in = bb_xfopen(fn, "rw");
 		safe_strncpy(tempFn, fn, sizeof(tempFn));
 		c = strlen(tempFn);
 		tempFn[c] = '.';
 		while(1) {
 		    if (c >=BUFSIZ)
-			error_msg_and_die("unique name not found");
+			bb_error_msg_and_die("unique name not found");
 		    /* Get some semi random stuff to try and make a
 		     * random filename based (and in the same dir as)
 		     * the input file... */
@@ -92,7 +94,7 @@ static int convert(char *fn, int ConvType)
 				// file is alredy in DOS format so it is not necessery to touch it
 				remove(tempFn);
 				if (fclose(in) < 0 || fclose(out) < 0) {
-					perror_msg(NULL);
+					bb_perror_nomsg();
 					return -2;
 				}
 				return 0;
@@ -106,7 +108,7 @@ static int convert(char *fn, int ConvType)
 				// file is alredy in UNIX format so it is not necessery to touch it
 				remove(tempFn);
 				if ((fclose(in) < 0) || (fclose(out) < 0)) {
-					perror_msg(NULL);
+					bb_perror_nomsg();
 					return -2;
 				}
 				return 0;
@@ -137,7 +139,7 @@ static int convert(char *fn, int ConvType)
 
 	if (fn != NULL) {
 	    if (fclose(in) < 0 || fclose(out) < 0) {
-		perror_msg(NULL);
+		bb_perror_nomsg();
 		remove(tempFn);
 		return -2;
 	    }
@@ -146,7 +148,7 @@ static int convert(char *fn, int ConvType)
 	     * should be true since we put them into the same directory
 	     * so we _should_ be ok, but you never know... */
 	    if (rename(tempFn, fn) < 0) {
-		perror_msg("unable to rename '%s' as '%s'", tempFn, fn);
+		bb_perror_msg("unable to rename '%s' as '%s'", tempFn, fn);
 		return -1;
 	    }
 	}
@@ -177,7 +179,7 @@ int dos2unix_main(int argc, char *argv[])
 			ConvType = CT_DOS2UNIX;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
diff --git a/coreutils/du.c b/coreutils/du.c
index 2e49b2147..702a9aa14 100644
--- a/coreutils/du.c
+++ b/coreutils/du.c
@@ -22,45 +22,65 @@
  *
  */
 
-#include <sys/types.h>
-#include <fcntl.h>
-#include <dirent.h>
-#include <stdio.h>
+/* BB_AUDIT SUSv3 compliant (unless default blocksize set to 1k) */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/du.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Mostly rewritten for SUSv3 compliance and to fix bugs/defects.
+ * 1) Added support for SUSv3 -a, -H, -L, gnu -c, and (busybox) -d options.
+ *    The -d option allows setting of max depth (similar to gnu --max-depth).
+ * 2) Fixed incorrect size calculations for links and directories, especially
+ *    when errors occurred.  Calculates sizes should now match gnu du output.
+ * 3) Added error checking of output.
+ * 4) Fixed busybox bug #1284 involving long overflow with human_readable.
+ */
+
 #include <stdlib.h>
-#include <getopt.h>
-#include <string.h>
-#include <errno.h>
+#include <limits.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/stat.h>
 #include "busybox.h"
 
-
 #ifdef CONFIG_FEATURE_HUMAN_READABLE
+# ifdef CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K
 static unsigned long disp_hr = KILOBYTE;
+# else
+static unsigned long disp_hr = 512;
+# endif
+#elif defined CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K
+static unsigned int disp_k = 1;
+#else
+static unsigned int disp_k;	/* bss inits to 0 */
 #endif
 
-static int du_depth /*= 0*/;
-static int count_hardlinks /*= 0*/;
-static int one_file_system /*= 0*/;
+static int max_print_depth = INT_MAX;
+static int count_hardlinks = INT_MAX;
+
+static int status
+#if EXIT_SUCCESS == 0
+	= EXIT_SUCCESS
+#endif
+	;
+static int print_files;
+static int slink_depth;
+static int du_depth;
+static int one_file_system;
 static dev_t dir_dev;
 
-static void (*print) (long, char *);
 
-static void print_normal(long size, char *filename)
+static void print(long size, char *filename)
 {
+	/* TODO - May not want to defer error checking here. */
 #ifdef CONFIG_FEATURE_HUMAN_READABLE
-	printf("%s\t%s\n", make_human_readable_str(size << 10, 1, disp_hr),
+	bb_printf("%s\t%s\n", make_human_readable_str(size, 512, disp_hr),
 		   filename);
 #else
-	printf("%ld\t%s\n", size, filename);
+	bb_printf("%ld\t%s\n", size >> disp_k, filename);
 #endif
 }
 
-static void print_summary(long size, char *filename)
-{
-	if (du_depth == 1) {
-		print_normal(size, filename);
-	}
-}
-
 /* tiny recursive du */
 static long du(char *filename)
 {
@@ -68,23 +88,43 @@ static long du(char *filename)
 	long sum;
 
 	if ((lstat(filename, &statbuf)) != 0) {
-		perror_msg("%s", filename);
+		bb_perror_msg("%s", filename);
+		status = EXIT_FAILURE;
 		return 0;
 	}
-	if (du_depth == 0)
-		dir_dev = statbuf.st_dev;
-	else if (one_file_system && dir_dev != statbuf.st_dev)
-		return 0;
 
-	du_depth++;
-	sum = (statbuf.st_blocks >> 1);
+	if (one_file_system) {
+		if (du_depth == 0) {
+			dir_dev = statbuf.st_dev;
+		} else if (dir_dev != statbuf.st_dev) {
+			return 0;
+		}
+	}
+
+	sum = statbuf.st_blocks;
 
-	/* Don't add in stuff pointed to by symbolic links */
 	if (S_ISLNK(statbuf.st_mode)) {
-		sum = 0L;
-		if (du_depth == 1) {
+		if (slink_depth > du_depth) {	/* -H or -L */
+			if ((stat(filename, &statbuf)) != 0) {
+				bb_perror_msg("%s", filename);
+				status = EXIT_FAILURE;
+				return 0;
+			}
+			sum = statbuf.st_blocks;
+			if (slink_depth == 1) {
+				slink_depth = INT_MAX;	/* Convert -H to -L. */
+			}
 		}
 	}
+
+	if (statbuf.st_nlink > count_hardlinks) {
+		/* Add files/directories with links only once */
+		if (is_in_ino_dev_hashtable(&statbuf, NULL)) {
+			return 0;
+		}
+		add_to_ino_dev_hashtable(&statbuf, NULL);
+	}
+
 	if (S_ISDIR(statbuf.st_mode)) {
 		DIR *dir;
 		struct dirent *entry;
@@ -92,8 +132,9 @@ static long du(char *filename)
 
 		dir = opendir(filename);
 		if (!dir) {
-			du_depth--;
-			return 0;
+			bb_perror_msg("%s", filename);
+			status = EXIT_FAILURE;
+			return sum;
 		}
 
 		newfile = last_char_is(filename, '/');
@@ -103,54 +144,86 @@ static long du(char *filename)
 		while ((entry = readdir(dir))) {
 			char *name = entry->d_name;
 
-			if ((strcmp(name, "..") == 0)
-				|| (strcmp(name, ".") == 0)) {
+			if ((name[0] == '.') && (!name[1] || (name[1] == '.' && !name[2]))) {
 				continue;
 			}
 			newfile = concat_path_file(filename, name);
+			++du_depth;
 			sum += du(newfile);
+			--du_depth;
 			free(newfile);
 		}
 		closedir(dir);
+	} else if (du_depth > print_files) {
+		return sum;
+	}
+	if (du_depth <= max_print_depth) {
 		print(sum, filename);
-	} else if (statbuf.st_nlink > 1 && !count_hardlinks) {
-		/* Add files with hard links only once */
-		if (is_in_ino_dev_hashtable(&statbuf, NULL)) {
-			sum = 0L;
-			if (du_depth == 1)
-				print(sum, filename);
-		} else {
-			add_to_ino_dev_hashtable(&statbuf, NULL);
-		}
 	}
-	du_depth--;
 	return sum;
 }
 
 int du_main(int argc, char **argv)
 {
-	int status = EXIT_SUCCESS;
-	int i;
+	long total;
+	int slink_depth_save;
+	int print_final_total = 0;
 	int c;
 
-	/* default behaviour */
-	print = print_normal;
+#ifdef CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K
+	if (getenv("POSIXLY_CORRECT")) {	/* TODO - a new libbb function? */
+#ifdef CONFIG_FEATURE_HUMAN_READABLE
+		disp_hr = 512;
+#else
+		disp_k = 0;
+#endif
+	} 
+#endif
+
+	/* Note: SUSv3 specifies that -a and -s options can not be used together
+	 * in strictly conforming applications.  However, it also says that some
+	 * du implementations may produce output when -a and -s are used together.
+	 * gnu du exits with an error code in this case.  We choose to simply
+	 * ignore -a.  This is consistent with -s being equivalent to -d 0.
+	 */
 
-	/* parse argv[] */
-	while ((c = getopt(argc, argv, "slx"
+	while ((c = getopt(argc, argv, "aHkLsx" "d:" "lc"
 #ifdef CONFIG_FEATURE_HUMAN_READABLE
 					   "hm"
 #endif
-					   "k")) != EOF) {
+					   )) > 0) {
 		switch (c) {
+		case 'a':
+			print_files = INT_MAX;
+			break;
+		case 'H':
+			slink_depth = 1;
+			break;
+		case 'k':
+#ifdef CONFIG_FEATURE_HUMAN_READABLE
+			disp_hr = KILOBYTE;
+#elif !defined CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K
+			disp_k = 1;
+#endif
+			break;
+		case 'L':
+			slink_depth = INT_MAX;
+			break;
 		case 's':
-			print = print_summary;
+			max_print_depth = 0;
+			break;
+		case 'x':
+			one_file_system = 1;
+			break;
+
+		case 'd':
+			max_print_depth = bb_xgetularg10_bnd(optarg, 0, INT_MAX);
 			break;
 		case 'l':
 			count_hardlinks = 1;
 			break;
-		case 'x':
-			one_file_system = 1;
+		case 'c':
+			print_final_total = 1;
 			break;
 #ifdef CONFIG_FEATURE_HUMAN_READABLE
 		case 'h':
@@ -160,37 +233,31 @@ int du_main(int argc, char **argv)
 			disp_hr = MEGABYTE;
 			break;
 #endif
-		case 'k':
-			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
 	/* go through remaining args (if any) */
+	argv += optind;
 	if (optind >= argc) {
-		if (du(".") == 0)
-			status = EXIT_FAILURE;
-	} else {
-		long sum;
-
-		for (i = optind; i < argc; i++) {
-			sum = du(argv[i]);
-			if (is_directory(argv[i], FALSE, NULL) == FALSE) {
-				print_normal(sum, argv[i]);
-			}
-			reset_ino_dev_hashtable();
+		*--argv = ".";
+		if (slink_depth == 1) {
+			slink_depth = 0;
 		}
 	}
 
-	return status;
-}
+	slink_depth_save = slink_depth;
+	total = 0;
+	do {
+		total += du(*argv);
+		slink_depth = slink_depth_save;
+	} while (*++argv);
+	reset_ino_dev_hashtable();
 
-/* $Id: du.c,v 1.55 2002/08/23 07:28:45 aaronl Exp $ */
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
+	if (print_final_total) {
+		print(total, "total");
+	}
+
+	bb_fflush_stdout_and_exit(status);
+}
diff --git a/coreutils/echo.c b/coreutils/echo.c
index 31c031528..b600a1fbd 100644
--- a/coreutils/echo.c
+++ b/coreutils/echo.c
@@ -22,94 +22,107 @@
  * Original copyright notice is retained at the end of this file.
  */
 
+/* BB_AUDIT SUSv3 compliant -- unless configured as fancy echo. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/echo.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Because of behavioral differences, implemented configureable SUSv3
+ * or 'fancy' gnu-ish behaviors.  Also, reduced size and fixed bugs.
+ * 1) In handling '\c' escape, the previous version only suppressed the
+ *     trailing newline.  SUSv3 specifies _no_ output after '\c'.
+ * 2) SUSv3 specifies that octal escapes are of the form \0{#{#{#}}}.
+ *    The previous version version did not allow 4-digit octals.
+ */
+
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include "busybox.h"
 
-extern int 
-echo_main(int argc, char** argv)
+extern int echo_main(int argc, char** argv)
 {
-	int nflag = 0;
+#ifndef CONFIG_FEATURE_FANCY_ECHO
+#define eflag '\\'
+	++argv;
+#else
+	const char *p;
+	int nflag = 1;
 	int eflag = 0;
 
-	/* Skip argv[0]. */
-	argc--;
-	argv++;
-
-	while (argc > 0 && *argv[0] == '-')
-	{
-		register char *temp;
-		register int ix;
-
-		/*
-		 * If it appears that we are handling options, then make sure
+	while (*++argv && (**argv == '-')) {
+		/* If it appears that we are handling options, then make sure
 		 * that all of the options specified are actually valid.
 		 * Otherwise, the string should just be echoed.
 		 */
-		temp = argv[0] + 1;
-
-		for (ix = 0; temp[ix]; ix++)
-		{
-			if (strrchr("neE", temp[ix]) == 0)
-				goto just_echo;
-		}
-
-		if (!*temp)
+		
+		if (!*(p = *argv + 1)) {	/* A single '-', so echo it. */
 			goto just_echo;
+		}
 
-		/*
-		 * All of the options in temp are valid options to echo.
-		 * Handle them.
-		 */
-		while (*temp)
-		{
-			if (*temp == 'n')
-				nflag = 1;
-			else if (*temp == 'e')
-				eflag = 1;
-			else if (*temp == 'E')
-				eflag = 0;
-			else
+		do {
+			if (strrchr("neE", *p) == 0) {
 				goto just_echo;
+			}
+		} while (*++p);
 
-			temp++;
-		}
-		argc--;
-		argv++;
+		/* All of the options in this arg are valid, so handle them. */
+		p = *argv + 1;
+		do {
+			if (*p == 'n') {
+				nflag = 0;
+			} else if (*p == 'e') {
+				eflag = '\\';
+			} else {
+				eflag = 0;
+			}
+		} while (*++p);
 	}
 
 just_echo:
-	while (argc > 0) {
-		const char *arg = argv[0];
+#endif
+	while (*argv) {
 		register int c;
 
-		while ((c = *arg++)) {
-
-			/* Check for escape sequence. */
-			if (c == '\\' && eflag && *arg) {
-				if (*arg == 'c') {
-					/* '\c' means cancel newline. */
-					nflag = 1;
-					arg++;
-					continue;
-				} else {
-					c = process_escape_sequence(&arg);
+		while ((c = *(*argv)++)) {
+			if (c == eflag) {	/* Check for escape seq. */
+				if (**argv == 'c') {
+					/* '\c' means cancel newline and 
+					 * ignore all subsequent chars. */
+					goto DONE;
+				}
+#ifndef CONFIG_FEATURE_FANCY_ECHO
+				/* SUSv3 specifies that octal escapes must begin with '0'. */
+				if (((unsigned int)(**argv - '1')) >= 7)
+#endif
+				{
+					/* Since SUSv3 mandates a first digit of 0, 4-digit octals
+					* of the form \0### are accepted. */
+					if ((**argv == '0') && (((unsigned int)(argv[0][1] - '0')) < 8)) {
+						(*argv)++;
+					}
+					/* bb_process_escape_sequence can handle nul correctly */
+					c = bb_process_escape_sequence((const char **) argv);
 				}
 			}
-
 			putchar(c);
 		}
-		argc--;
-		argv++;
-		if (argc > 0)
+
+		if (*++argv) {
 			putchar(' ');
+		}
 	}
-	if (!nflag)
+
+#ifdef CONFIG_FEATURE_FANCY_ECHO
+	if (nflag) {
 		putchar('\n');
-	fflush(stdout);
+	}
+#else
+	putchar('\n');
+#endif
 
-	return EXIT_SUCCESS;
+DONE:
+	bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 }
 
 /*-
diff --git a/coreutils/env.c b/coreutils/env.c
index 8bb690b72..db13b3aed 100644
--- a/coreutils/env.c
+++ b/coreutils/env.c
@@ -24,50 +24,66 @@
  * Modified for BusyBox by Erik Andersen <andersen@lineo.com>, <andersee@debian.org>
  */
 
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/env.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Fixed bug involving exit return codes if execvp fails.  Also added
+ * output error checking.
+ */
+
 #include <stdio.h>
 #include <string.h>
-#include <getopt.h>
 #include <stdlib.h>
+#include <errno.h>
 #include <unistd.h>
 #include "busybox.h"
 
 extern int env_main(int argc, char** argv)
 {
 	char **ep, *p;
-	char *cleanenv[1];
-	int ignore_environment = 0;
+	char *cleanenv[1] = { NULL };
 	int ch;
 
-	while ((ch = getopt(argc, argv, "+iu:")) != -1) {
+	while ((ch = getopt(argc, argv, "iu:")) > 0) {
 		switch(ch) {
 		case 'i':
-			ignore_environment = 1;
+			environ = cleanenv;
 			break;
 		case 'u':
 			unsetenv(optarg);
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
-	if (optind != argc && !strcmp(argv[optind], "-")) {
-		ignore_environment = 1;
-		argv++;
-	}
-	if (ignore_environment) {
+
+	argv += optind;
+
+	if (*argv && (argv[0][0] == '-') && !argv[0][1]) {
 		environ = cleanenv;
-		cleanenv[0] = NULL;
+		++argv;
 	}
-	for (argv += optind; *argv && (p = strchr(*argv, '=')); ++argv)
-		if (putenv(*argv) < 0)
-			perror_msg_and_die("%s", *argv);
+
+	while (*argv && ((p = strchr(*argv, '=')) != NULL)) {
+		if (putenv(*argv) < 0) {
+			bb_perror_msg_and_die("putenv");
+		}
+		++argv;
+	}
+
 	if (*argv) {
 		execvp(*argv, argv);
-		perror_msg_and_die("%s", *argv);
+		bb_perror_msg("%s", *argv);	/* Avoid multibyte problems. */
+		return (errno == ENOENT) ? 127 : 126;	/* SUSv3-mandated exit codes. */
 	}
-	for (ep = environ; *ep; ep++)
+
+	for (ep = environ; *ep; ep++) {
 		puts(*ep);
-	return 0;
+	}
+
+	bb_fflush_stdout_and_exit(0);
 }
 
 /*
diff --git a/coreutils/expr.c b/coreutils/expr.c
index 55ae3a969..ecba825d5 100644
--- a/coreutils/expr.c
+++ b/coreutils/expr.c
@@ -78,14 +78,14 @@ int expr_main (int argc, char **argv)
 	VALUE *v;
 
 	if (argc == 1) {
-		error_msg_and_die("too few arguments");
+		bb_error_msg_and_die("too few arguments");
 	}
 
 	args = argv + 1;
 
 	v = eval ();
 	if (*args)
-		error_msg_and_die ("syntax error");
+		bb_error_msg_and_die ("syntax error");
 
 	if (v->type == integer)
 		printf ("%d\n", v->u.i);
@@ -147,7 +147,7 @@ static int null (VALUE *v)
 static void tostring (VALUE *v)
 {
 	if (v->type == integer) {
-               bb_asprintf (&(v->u.s), "%d", v->u.i);
+               bb_xasprintf (&(v->u.s), "%d", v->u.i);
 		v->type = string;
 	}
 }
@@ -216,7 +216,7 @@ static						\
 int name (VALUE *l, VALUE *r)		\
 {						\
   if (!toarith (l) || !toarith (r))		\
-    error_msg_and_die ("non-numeric argument");	\
+    bb_error_msg_and_die ("non-numeric argument");	\
   return l->u.i op r->u.i;			\
 }
 
@@ -224,9 +224,9 @@ int name (VALUE *l, VALUE *r)		\
 static int name (VALUE *l, VALUE *r)		\
 {						\
   if (!toarith (l) || !toarith (r))		\
-    error_msg_and_die ( "non-numeric argument");	\
+    bb_error_msg_and_die ( "non-numeric argument");	\
   if (r->u.i == 0)				\
-    error_msg_and_die ( "division by zero");		\
+    bb_error_msg_and_die ( "division by zero");		\
   return l->u.i op r->u.i;			\
 }
 
@@ -270,7 +270,7 @@ of a basic regular expression is not portable; it is being ignored",
 	re_syntax_options = RE_SYNTAX_POSIX_BASIC;
 	errmsg = re_compile_pattern (pv->u.s, len, &re_buffer);
 	if (errmsg) {
-		error_msg_and_die("%s", errmsg);
+		bb_error_msg_and_die("%s", errmsg);
 	}
 
 	len = re_match (&re_buffer, sv->u.s, strlen (sv->u.s), 0, &re_regs);
@@ -301,19 +301,19 @@ static VALUE *eval7 (void)
 	VALUE *v;
 
 	if (!*args)
-		error_msg_and_die ( "syntax error");
+		bb_error_msg_and_die ( "syntax error");
 
 	if (nextarg ("(")) {
 		args++;
 		v = eval ();
 		if (!nextarg (")"))
-			error_msg_and_die ( "syntax error");
+			bb_error_msg_and_die ( "syntax error");
 			args++;
 			return v;
 		}
 
 	if (nextarg (")"))
-		error_msg_and_die ( "syntax error");
+		bb_error_msg_and_die ( "syntax error");
 
 	return str_value (*args++);
 }
@@ -327,7 +327,7 @@ static VALUE *eval6 (void)
 	if (nextarg ("quote")) {
 		args++;
 		if (!*args)
-			error_msg_and_die ( "syntax error");
+			bb_error_msg_and_die ( "syntax error");
 		return str_value (*args++);
 	}
 	else if (nextarg ("length")) {
@@ -373,7 +373,7 @@ static VALUE *eval6 (void)
 		else {
 			v = xmalloc (sizeof(VALUE));
 			v->type = string;
-                       v->u.s = xstrndup(l->u.s + i1->u.i - 1, i2->u.i);
+                       v->u.s = bb_xstrndup(l->u.s + i1->u.i - 1, i2->u.i);
 		}
 		freev (l);
 		freev (i1);
diff --git a/coreutils/false.c b/coreutils/false.c
index 96b18498a..c17de7693 100644
--- a/coreutils/false.c
+++ b/coreutils/false.c
@@ -21,7 +21,8 @@
  *
  */
 
-/* getopt not needed */
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/false.html */
 
 #include <stdlib.h>
 #include "busybox.h"
diff --git a/coreutils/head.c b/coreutils/head.c
index ad21e1b95..dab4de11b 100644
--- a/coreutils/head.c
+++ b/coreutils/head.c
@@ -1,9 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini head implementation for busybox
+ * head implementation for busybox
  *
- * Copyright (C) 1999 by Lineo, inc. and John Beppu
- * Copyright (C) 1999,2000,2001 by John Beppu <beppu@codepoet.org>
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,82 +20,119 @@
  *
  */
 
+/* BB_AUDIT SUSv3 compliant */
+/* BB_AUDIT GNU compatible -c, -q, and -v options in 'fancy' configuration. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/head.html */
+
 #include <stdio.h>
-#include <getopt.h>
 #include <stdlib.h>
-#include <string.h>
+#include <limits.h>
 #include <ctype.h>
+#include <unistd.h>
 #include "busybox.h"
 
-static int head(int len, FILE *fp)
-{
-	int i;
-	char *input;
+static const char head_opts[] =
+	"n:"
+#ifdef CONFIG_FEATURE_FANCY_HEAD
+	"c:qv"
+#endif
+	;
 
-	for (i = 0; i < len; i++) {
-		if ((input = get_line_from_file(fp)) == NULL)
-			break;
-		fputs(input, stdout);
-		free(input);
-	}
-	return 0;
-}
+static const char header_fmt_str[] = "\n==> %s <==\n";
 
-/* BusyBoxed head(1) */
 int head_main(int argc, char **argv)
 {
+	unsigned long count = 10;
+	unsigned long i;
+#ifdef CONFIG_FEATURE_FANCY_HEAD
+	int count_bytes = 0;
+	int header_threshhold = 1;
+#endif
+
 	FILE *fp;
-	int need_headers, opt, len = 10, status = EXIT_SUCCESS;
+	const char *fmt;
+	char *p;
+	int opt;
+	int c;
+	int retval = EXIT_SUCCESS;
 
-	if (( argc >= 2 ) && ( argv [1][0] == '-' ) && isdigit ( argv [1][1] )) {
-		len = atoi ( &argv [1][1] );
-		optind = 2;
+	/* Allow legacy syntax of an initial numeric option without -n. */
+	if ((argc > 1) && (argv[1][0] == '-')
+		/* && (isdigit)(argv[1][1]) */
+		&& (((unsigned int)(argv[1][1] - '0')) <= 9)
+	) {
+		--argc;
+		++argv;
+		p = (*argv) + 1;
+		goto GET_COUNT;
 	}
 
-	/* parse argv[] */
-	while ((opt = getopt(argc, argv, "n:")) > 0) {
-		switch (opt) {
-		case 'n':
-			len = atoi(optarg);
-			if (len >= 0)
+	while ((opt = getopt(argc, argv, head_opts)) > 0) {
+		switch(opt) {
+#ifdef CONFIG_FEATURE_FANCY_HEAD
+			case 'q':
+				header_threshhold = INT_MAX;
+				break;
+			case 'v':
+				header_threshhold = -1;
 				break;
-			/* fallthrough */
-		default:
-			show_usage();
+			case 'c':
+				count_bytes = 1;
+				/* fall through */
+#endif
+			case 'n':
+				p = optarg;
+			GET_COUNT:
+				count = bb_xgetularg10(p);
+				break;
+			default:
+				bb_show_usage();
 		}
 	}
 
-	/* get rest of argv[] or stdin if nothing's left */
-	if (argv[optind] == NULL) {
-		head(len, stdin);
-		return status;
-	} 
+	argv += optind;
+	if (!*argv) {
+		*--argv = "-";
+	}
 
-	need_headers = optind != (argc - 1);
-	while (argv[optind]) {
-		if (strcmp(argv[optind], "-") == 0) {
-			fp = stdin;
-			argv[optind] = "standard input";
-		} else {
-			if ((fp = wfopen(argv[optind], "r")) == NULL)
-				status = EXIT_FAILURE;
-		}
-		if (fp) {
-			if (need_headers) {
-				printf("==> %s <==\n", argv[optind]);
+	fmt = header_fmt_str + 1;
+#ifdef CONFIG_FEATURE_FANCY_HEAD
+	if (argc - optind <= header_threshhold) {
+		header_threshhold = 0;
+	}
+#else
+	if (argc <= optind + 1) {
+		fmt += 11;
+	}
+	/* Now define some things here to avoid #ifdefs in the code below.
+	 * These should optimize out of the if conditions below. */
+#define header_threshhold   1
+#define count_bytes         0
+#endif
+
+	do {
+		if ((fp = bb_wfopen_input(*argv)) != NULL) {
+			if (fp == stdin) {
+				*argv = (char *) bb_msg_standard_input;
 			}
-			head(len, fp);
-			if (ferror(fp)) {
-				perror_msg("%s", argv[optind]);
-				status = EXIT_FAILURE;
+			if (header_threshhold) {
+				bb_printf(fmt, *argv);
 			}
-			if (optind < argc - 1)
-				putchar('\n');
-			if (fp != stdin)
-				fclose(fp);
+			i = count;
+			while (i && ((c = getc(fp)) != EOF)) {
+				if (count_bytes || (c == '\n')) {
+					--i;
+				}
+				putchar(c);
+			}
+			if (bb_fclose_nonstdin(fp)) {
+				bb_perror_msg("%s", *argv);	/* Avoid multibyte problems. */
+				retval = EXIT_FAILURE;
+			}
+			bb_xferror_stdout();
 		}
-		optind++;
-	}
+		fmt = header_fmt_str;
+	} while (*++argv);
 
-	return status;
+	bb_fflush_stdout_and_exit(retval);
 }
diff --git a/coreutils/hostid.c b/coreutils/hostid.c
index 68a2cc659..917dc223e 100644
--- a/coreutils/hostid.c
+++ b/coreutils/hostid.c
@@ -20,13 +20,19 @@
  *
  */
 
-#include <stdio.h>
+/* BB_AUDIT SUSv3 N/A -- Matches GNU behavior. */
+
 #include <stdlib.h>
 #include <unistd.h>
 #include "busybox.h"
 
 extern int hostid_main(int argc, char **argv)
 {
-	printf("%lx\n", gethostid());
-	return EXIT_SUCCESS;
+	if (argc > 1) {
+		bb_show_usage();
+	}
+
+	bb_printf("%lx\n", gethostid());
+
+	bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 }
diff --git a/coreutils/id.c b/coreutils/id.c
index c7f61532d..9b2d60dc7 100644
--- a/coreutils/id.c
+++ b/coreutils/id.c
@@ -20,6 +20,8 @@
  *
  */
 
+/* BB_AUDIT SUSv3 _NOT_ compliant -- option -G is not currently supported. */
+
 #include "busybox.h"
 #include <stdio.h>
 #include <unistd.h>
@@ -27,70 +29,58 @@
 #include <string.h>
 #include <sys/types.h>
 
+#define NO_GROUP          1
+#define NO_USER           2
+#define PRINT_REAL        4
+#define NAME_NOT_NUMBER   8
+
 extern int id_main(int argc, char **argv)
 {
-	int no_user = 0, no_group = 0, print_real = 0;
-	int name_not_number = 0;
 	char user[9], group[9];
-	long gid;
 	long pwnam, grnam;
-	int opt;
+	int uid, gid;
+	int flags;
 	
-	gid = 0;
+	flags = bb_getopt_ulflags(argc, argv, "ugrn");
 
-	while ((opt = getopt(argc, argv, "ugrn")) > 0) {
-		switch (opt) {
-			case 'u':
-				no_group++;
-				break;
-			case 'g':
-				no_user++;
-				break;
-			case 'r':
-				print_real++;
-				break;
-			case 'n':
-				name_not_number++;
-				break;
-			default:
-				show_usage();
-		}
+	if (((flags & (NO_USER | NO_GROUP)) == (NO_USER | NO_GROUP))
+		|| (argc > optind + 1)
+	) {
+		bb_show_usage();
 	}
 
-	if (no_user && no_group) show_usage();
-
 	if (argv[optind] == NULL) {
-		if (print_real) {
-			my_getpwuid(user, getuid());
-			my_getgrgid(group, getgid());
+		if (flags & PRINT_REAL) {
+			uid = getuid();
+			gid = getgid();
 		} else {
-			my_getpwuid(user, geteuid());
-			my_getgrgid(group, getegid());
+			uid = geteuid();
+			gid = getegid();
 		}
+		my_getpwuid(user, uid);
 	} else {
 		safe_strncpy(user, argv[optind], sizeof(user));
 	    gid = my_getpwnamegid(user);
-		my_getgrgid(group, gid);
 	}
+	my_getgrgid(group, gid);
 
 	pwnam=my_getpwnam(user);
 	grnam=my_getgrnam(group);
 
-	if (no_group) {
-		if(name_not_number)
-			puts(user);
-		else
-			printf("%ld\n", pwnam);
-	} else if (no_user) {
-		if(name_not_number)
-			puts(group);
-		else
+	if (flags & (NO_GROUP | NO_USER)) {
+		char *s = group;
+		if (flags & NO_GROUP) {
+			s = user;
+			grnam = pwnam;
+		}
+		if (flags & NAME_NOT_NUMBER) {
+			puts(s);
+		} else {
 			printf("%ld\n", grnam);
+		}
 	} else {
 		printf("uid=%ld(%s) gid=%ld(%s)\n", pwnam, user, grnam, group);
 	}
-	return(0);
-}
 
-
-/* END CODE */
+	bb_fflush_stdout_and_exit(0);
+}
diff --git a/coreutils/length.c b/coreutils/length.c
index 73becd28a..bce43ab3f 100644
--- a/coreutils/length.c
+++ b/coreutils/length.c
@@ -1,4 +1,7 @@
 /* vi: set sw=4 ts=4: */
+
+/* BB_AUDIT SUSv3 N/A -- Apparently a busybox (obsolete?) extension. */
+
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
@@ -6,8 +9,11 @@
 
 extern int length_main(int argc, char **argv)
 {
-	if (argc != 2 || **(argv + 1) == '-')
-		show_usage();
-	printf("%lu\n", (long)strlen(argv[1]));
-	return EXIT_SUCCESS;
+	if ((argc != 2) ||  (**(++argv) == '-')) {
+	    bb_show_usage();
+	}
+
+	bb_printf("%lu\n", (unsigned long)strlen(*argv));
+
+	bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 }
diff --git a/coreutils/libcoreutils/Makefile b/coreutils/libcoreutils/Makefile
new file mode 100644
index 000000000..59ec24ed9
--- /dev/null
+++ b/coreutils/libcoreutils/Makefile
@@ -0,0 +1,30 @@
+# Makefile for busybox
+#
+# Copyright (C) 1999-2002 Erik Andersen <andersee@debian.org>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+#
+
+TOPDIR:= ../../
+LIBCOREUTILS_DIR:=./
+include $(TOPDIR).config
+include $(TOPDIR)Rules.mak
+include Makefile.in
+all: $(libraries-y)
+-include $(TOPDIR).depend
+
+clean:
+	rm -f *.o *.a $(AR_TARGET)
+
diff --git a/coreutils/libcoreutils/Makefile.in b/coreutils/libcoreutils/Makefile.in
new file mode 100644
index 000000000..47391dd49
--- /dev/null
+++ b/coreutils/libcoreutils/Makefile.in
@@ -0,0 +1,32 @@
+# Makefile for busybox
+#
+# Copyright (C) 1999-2002 Erik Andersen <andersee@debian.org>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+#
+
+LIBCOREUTILS_AR:=libcoreutils.a
+ifndef $(LIBCOREUTILS_DIR)
+LIBCOREUTILS_DIR:=$(TOPDIR)coreutils/libcoreutils/
+endif
+
+LIBCOREUTILS_SRC:= cp_mv_stat.c getopt_mk_fifo_nod.c xgetoptfile_sort_uniq.c
+
+LIBCOREUTILS_OBJS=$(patsubst %.c,$(LIBCOREUTILS_DIR)%.o, $(LIBCOREUTILS_SRC))
+
+libraries-y+=$(LIBCOREUTILS_DIR)$(LIBCOREUTILS_AR)
+
+$(LIBCOREUTILS_DIR)$(LIBCOREUTILS_AR): $(LIBCOREUTILS_OBJS)
+	$(AR) -ro $@ $(LIBCOREUTILS_OBJS)
diff --git a/coreutils/libcoreutils/coreutils.h b/coreutils/libcoreutils/coreutils.h
new file mode 100644
index 000000000..eabca8204
--- /dev/null
+++ b/coreutils/libcoreutils/coreutils.h
@@ -0,0 +1,12 @@
+#ifndef COREUTILS_H
+#define COREUTILS_H		1
+
+typedef int (*stat_func)(const char *fn, struct stat *ps);
+
+extern int cp_mv_stat2(const char *fn, struct stat *fn_stat, stat_func sf);
+extern int cp_mv_stat(const char *fn, struct stat *fn_stat);
+
+extern mode_t getopt_mk_fifo_nod(int argc, char **argv);
+extern FILE *xgetoptfile_sort_uniq(char **argv, const char *mode);
+
+#endif
diff --git a/coreutils/libcoreutils/cp_mv_stat.c b/coreutils/libcoreutils/cp_mv_stat.c
new file mode 100644
index 000000000..5a70b0221
--- /dev/null
+++ b/coreutils/libcoreutils/cp_mv_stat.c
@@ -0,0 +1,45 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * coreutils utility routine
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <errno.h>
+#include <sys/stat.h>
+#include "libbb.h"
+#include "coreutils.h"
+
+extern int cp_mv_stat2(const char *fn, struct stat *fn_stat, stat_func sf)
+{
+	if (sf(fn, fn_stat) < 0) {
+		if (errno != ENOENT) {
+			bb_perror_msg("unable to stat `%s'", fn);
+			return -1;
+		}
+		return 0;
+	} else if (S_ISDIR(fn_stat->st_mode)) {
+		return 3;
+	}
+	return 1;
+}
+
+extern int cp_mv_stat(const char *fn, struct stat *fn_stat)
+{
+	return cp_mv_stat2(fn, fn_stat, stat);
+}
diff --git a/coreutils/libcoreutils/getopt_mk_fifo_nod.c b/coreutils/libcoreutils/getopt_mk_fifo_nod.c
new file mode 100644
index 000000000..0872bdcf0
--- /dev/null
+++ b/coreutils/libcoreutils/getopt_mk_fifo_nod.c
@@ -0,0 +1,45 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * coreutils utility routine
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include "libbb.h"
+#include "coreutils.h"
+
+extern mode_t getopt_mk_fifo_nod(int argc, char **argv)
+{
+	mode_t mode = 0666;
+	int opt;
+
+	while ((opt = getopt(argc, argv, "m:")) > 0) {
+		if (opt == 'm') {
+			mode = 0666;
+			if (bb_parse_mode(optarg, &mode)) {
+				umask(0);
+				continue;
+			}
+		}
+		bb_show_usage();
+	}
+	return mode;
+}
diff --git a/coreutils/libcoreutils/xgetoptfile_sort_uniq.c b/coreutils/libcoreutils/xgetoptfile_sort_uniq.c
new file mode 100644
index 000000000..a63daf97b
--- /dev/null
+++ b/coreutils/libcoreutils/xgetoptfile_sort_uniq.c
@@ -0,0 +1,38 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * coreutils utility routine
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include "libbb.h"
+#include "coreutils.h"
+
+extern FILE *xgetoptfile_sort_uniq(char **argv, const char *mode)
+{
+	const char *n;
+
+	if ((n = *argv) != NULL) {
+		if ((*n != '-') || n[1]) {
+			return bb_xfopen(n, mode);
+		}
+	}
+	return (*mode == 'r') ? stdin : stdout;
+}
diff --git a/coreutils/ln.c b/coreutils/ln.c
index 427ffcc6e..2edece104 100644
--- a/coreutils/ln.c
+++ b/coreutils/ln.c
@@ -21,113 +21,86 @@
  *
  */
 
-#include <stdio.h>
-#include <dirent.h>
-#include <string.h>
+/* BB_AUDIT SUSv3 compliant */
+/* BB_AUDIT GNU options missing: -b, -d, -F, -i, -S, and -v. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/ln.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Fixed bug involving -n option.  Essentially, -n was always in effect.
+ */
+
 #include <stdlib.h>
-#include <errno.h>
 #include <unistd.h>
 #include "busybox.h"
 
+#define LN_SYMLINK          1
+#define LN_FORCE            2
+#define LN_NODEREFERENCE    4
 
-static const int LN_SYMLINK = 1;
-static const int LN_FORCE = 2;
-static const int LN_NODEREFERENCE = 4;
-
-/*
- * linkDestName is where the link points to,
- * linkSrcName is the name of the link to be created.
- */
-static int fs_link(const char *link_destname, const char *link_srcname, 
-		const int flag)
+extern int ln_main(int argc, char **argv)
 {
-	int status;
-	int src_is_dir;
-	char *src_name = 0;
+	int status = EXIT_SUCCESS;
+	int flag;
+	char *last;
+	char *src_name;
 	const char *src;
+	int (*link_func)(const char *, const char *);
 
-	if (link_destname==NULL)
-		return(FALSE);
-
-	if (link_srcname==NULL)
-		src = link_destname;
-	else
-		src = link_srcname;
-
-	if (flag&LN_NODEREFERENCE)
-		src_is_dir = is_directory(src, TRUE, NULL);
-	else
-		src_is_dir = is_directory(src, FALSE, NULL);
-	
-	if ((src_is_dir==TRUE)&&((flag&LN_NODEREFERENCE)==0)) {
-		char* srcdir_name;
-
-		srcdir_name = xstrdup(link_destname);
-		src_name = concat_path_file(src, get_last_path_component(srcdir_name));
-		src = src_name;
-		free(srcdir_name);
+	flag = bb_getopt_ulflags(argc, argv, "sfn");
+
+	if (argc == optind) {
+		bb_show_usage();
 	}
-	
-	if (flag&LN_FORCE)
-		unlink(src);
-		
-	if (flag&LN_SYMLINK)
-		status = symlink(link_destname, src);
-	else
-		status = link(link_destname, src);
-
-	if (status != 0) {
-		perror_msg(src);
-		status = FALSE;
-	} else {
-		status = TRUE;
+
+	last = argv[argc - 1];
+	argv += optind;
+
+	if (argc == optind + 1) {
+		*--argv = last;
+		last = bb_get_last_path_component(bb_xstrdup(last));
 	}
-	free(src_name);
-	return status;
-}
 
-extern int ln_main(int argc, char **argv)
-{
-	int status = EXIT_SUCCESS;
-	int flag = 0;
-	int opt;
-	
-	/* Parse any options */
-	while ((opt=getopt(argc, argv, "sfn")) != -1) {
-		switch(opt) {
-			case 's':
-				flag |= LN_SYMLINK;
-				break;
-			case 'f':
-				flag |= LN_FORCE;
-				break;
-			case 'n':
-				flag |= LN_NODEREFERENCE;
-				break;
-			default:
-				show_usage();
+	do {
+		src_name = 0;
+		src = last;
+
+		if (is_directory(src,
+						 (flag & LN_NODEREFERENCE) ^ LN_NODEREFERENCE,
+						 NULL)) {
+			src_name = bb_xstrdup(*argv);
+			src = concat_path_file(src, bb_get_last_path_component(src_name));
+			free(src_name);
+			src_name = (char *)src;
 		}
-	}
-	if (optind > (argc-1)) {
-		show_usage();
-	} 
-	if (optind == (argc-1)) {
-		if (fs_link(argv[optind], 
-					get_last_path_component(argv[optind]), flag)==FALSE)
-			status = EXIT_FAILURE;
-	}
-	while(optind<(argc-1)) {
-		if (fs_link(argv[optind], argv[argc-1], flag)==FALSE)
-			status = EXIT_FAILURE;
-		optind++;
-	}
+
+		if (flag & LN_FORCE) {
+			unlink(src);
+		}
+
+		link_func = link;
+		if (flag & LN_SYMLINK) {
+			link_func = symlink;
+		}
+		
+		if (link_func(*argv, src) != 0) {
+			bb_perror_msg(src);
+			status = EXIT_FAILURE;;
+		}
+
+		free(src_name);
+		
+	} while ((++argv)[1]);
+
 	return status;
 }
 
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
+
+
+
+
+
+
+
+
+
diff --git a/coreutils/logname.c b/coreutils/logname.c
index 3e10fba6f..9cedff027 100644
--- a/coreutils/logname.c
+++ b/coreutils/logname.c
@@ -20,6 +20,19 @@
  *
  */
 
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/logname.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * SUSv3 specifies the string used is that returned from getlogin().
+ * The previous implementation used getpwuid() for geteuid(), which
+ * is _not_ the same.  Erik apparently made this change almost 3 years
+ * ago to avoid failing when no utmp was available.  However, the
+ * correct course of action wrt SUSv3 for a failing getlogin() is
+ * a dianostic message and an error return.
+ */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -27,14 +40,16 @@
 
 extern int logname_main(int argc, char **argv)
 {
-	char user[9];
+	const char *p;
 
-	if (argc > 1)
-		show_usage();
+	if (argc > 1) {
+		bb_show_usage();
+	}
 
-	if (my_getpwuid(user, geteuid())) {
-		puts(user);
-		return EXIT_SUCCESS;
+	if ((p = getlogin()) != NULL) {
+		puts(p);
+		bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 	}
-	error_msg_and_die("no login name");
+
+	bb_perror_msg_and_die("getlogin");
 }
diff --git a/coreutils/ls.c b/coreutils/ls.c
index 64ec0fee6..4a4956611 100644
--- a/coreutils/ls.c
+++ b/coreutils/ls.c
@@ -73,58 +73,76 @@ enum {
 #endif
 
 /* what is the overall style of the listing */
-enum {
-	STYLE_AUTO = 0,
-	STYLE_LONG = 1,		/* one record per line, extended info */
-	STYLE_SINGLE = 2,	/* one record per line */
-	STYLE_COLUMNS = 3	/* fill columns */
-};
+#define STYLE_AUTO      (0)
+#define STYLE_COLUMNS   (1U<<21)	/* fill columns */
+#define STYLE_LONG      (2U<<21)	/* one record per line, extended info */
+#define STYLE_SINGLE    (3U<<21)	/* one record per line */
+
+#define STYLE_MASK                 STYLE_SINGLE
+#define STYLE_ONE_RECORD_FLAG      STYLE_LONG
 
 /* 51306 lrwxrwxrwx  1 root     root         2 May 11 01:43 /bin/view -> vi* */
 /* what file information will be listed */
-#define LIST_INO		(1<<0)
-#define LIST_BLOCKS		(1<<1)
-#define LIST_MODEBITS	(1<<2)
-#define LIST_NLINKS		(1<<3)
-#define LIST_ID_NAME	(1<<4)
-#define LIST_ID_NUMERIC	(1<<5)
-#define LIST_SIZE		(1<<6)
-#define LIST_DEV		(1<<7)
-#define LIST_DATE_TIME	(1<<8)
-#define LIST_FULLTIME	(1<<9)
-#define LIST_FILENAME	(1<<10)
-#define LIST_SYMLINK	(1<<11)
-#define LIST_FILETYPE	(1<<12)
-#define LIST_EXEC		(1<<13)
+#define LIST_INO		(1U<<0)
+#define LIST_BLOCKS		(1U<<1)
+#define LIST_MODEBITS	(1U<<2)
+#define LIST_NLINKS		(1U<<3)
+#define LIST_ID_NAME	(1U<<4)
+#define LIST_ID_NUMERIC	(1U<<5)
+#define LIST_SIZE		(1U<<6)
+#define LIST_DEV		(1U<<7)
+#define LIST_DATE_TIME	(1U<<8)
+#define LIST_FULLTIME	(1U<<9)
+#define LIST_FILENAME	(1U<<10)
+#define LIST_SYMLINK	(1U<<11)
+#define LIST_FILETYPE	(1U<<12)
+#define LIST_EXEC		(1U<<13)
+
+#define LIST_MASK       ((LIST_EXEC << 1) - 1)
 
 /* what files will be displayed */
-#define DISP_NORMAL		(0)	/* show normal filenames */
-#define DISP_DIRNAME	(1<<0)	/* 2 or more items? label directories */
-#define DISP_HIDDEN		(1<<1)	/* show filenames starting with .  */
-#define DISP_DOT		(1<<2)	/* show . and .. */
-#define DISP_NOLIST		(1<<3)	/* show directory as itself, not contents */
-#define DISP_RECURSIVE	(1<<4)	/* show directory and everything below it */
-#define DISP_ROWS		(1<<5)	/* print across rows */
+/* TODO -- We may be able to make DISP_NORMAL 0 to save a bit slot. */
+#define DISP_NORMAL		(1U<<14)	/* show normal filenames */
+#define DISP_DIRNAME	(1U<<15)	/* 2 or more items? label directories */
+#define DISP_HIDDEN		(1U<<16)	/* show filenames starting with .  */
+#define DISP_DOT		(1U<<17)	/* show . and .. */
+#define DISP_NOLIST		(1U<<18)	/* show directory as itself, not contents */
+#define DISP_RECURSIVE	(1U<<19)	/* show directory and everything below it */
+#define DISP_ROWS		(1U<<20)	/* print across rows */
+
+#define DISP_MASK       (((DISP_ROWS << 1) - 1) & ~(DISP_NORMAL - 1))
 
 #ifdef CONFIG_FEATURE_LS_SORTFILES
 /* how will the files be sorted */
-static const int SORT_FORWARD = 0;	/* sort in reverse order */
-static const int SORT_REVERSE = 1;	/* sort in reverse order */
-static const int SORT_NAME = 2;	/* sort by file name */
-static const int SORT_SIZE = 3;	/* sort by file size */
-static const int SORT_ATIME = 4;	/* sort by last access time */
-static const int SORT_CTIME = 5;	/* sort by last change time */
-static const int SORT_MTIME = 6;	/* sort by last modification time */
-static const int SORT_VERSION = 7;	/* sort by version */
-static const int SORT_EXT = 8;	/* sort by file name extension */
-static const int SORT_DIR = 9;	/* sort by file or directory */
+#define SORT_ORDER_FORWARD   0			/* sort in reverse order */
+#define SORT_ORDER_REVERSE   (1U<<27)	/* sort in reverse order */
+
+#define SORT_NAME      0			/* sort by file name */
+#define SORT_SIZE      (1U<<28)		/* sort by file size */
+#define SORT_ATIME     (2U<<28)		/* sort by last access time */
+#define SORT_CTIME     (3U<<28)		/* sort by last change time */
+#define SORT_MTIME     (4U<<28)		/* sort by last modification time */
+#define SORT_VERSION   (5U<<28)		/* sort by version */
+#define SORT_EXT       (6U<<28)		/* sort by file name extension */
+#define SORT_DIR       (7U<<28)		/* sort by file or directory */
+
+#define SORT_MASK      (7U<<28)
 #endif
 
 #ifdef CONFIG_FEATURE_LS_TIMESTAMPS
 /* which of the three times will be used */
-static const int TIME_MOD = 0;
-static const int TIME_CHANGE = 1;
-static const int TIME_ACCESS = 2;
+#define TIME_MOD       0
+#define TIME_CHANGE    (1U<<23)
+#define TIME_ACCESS    (1U<<24)
+
+#define TIME_MASK      (3U<<23)
+#endif
+
+#ifdef CONFIG_FEATURE_LS_FOLLOWLINKS
+#define FOLLOW_LINKS   (1U<<25)
+#endif
+#ifdef CONFIG_FEATURE_HUMAN_READABLE
+#define LS_DISP_HR     (1U<<26)
 #endif
 
 #define LIST_SHORT	(LIST_FILENAME)
@@ -133,9 +151,9 @@ static const int TIME_ACCESS = 2;
 						LIST_DATE_TIME | LIST_FILENAME | LIST_SYMLINK)
 #define LIST_ILONG	(LIST_INO | LIST_LONG)
 
-static const int SPLIT_DIR = 0;
-static const int SPLIT_FILE = 1;
-static const int SPLIT_SUBDIR = 2;
+#define SPLIT_DIR      1
+#define SPLIT_FILE     0
+#define SPLIT_SUBDIR   2
 
 #define TYPEINDEX(mode) (((mode) >> 12) & 0x0f)
 #define TYPECHAR(mode)  ("0pcCd?bB-?l?s???" [TYPEINDEX(mode)])
@@ -169,20 +187,7 @@ static struct dnode **list_dir(const char *);
 static struct dnode **dnalloc(int);
 static int list_single(struct dnode *);
 
-static unsigned int disp_opts;
-static unsigned int style_fmt;
-static unsigned int list_fmt;
-
-#ifdef CONFIG_FEATURE_LS_SORTFILES
-static unsigned int sort_opts;
-static unsigned int sort_order;
-#endif
-#ifdef CONFIG_FEATURE_LS_TIMESTAMPS
-static unsigned int time_fmt;
-#endif
-#ifdef CONFIG_FEATURE_LS_FOLLOWLINKS
-static unsigned int follow_links = FALSE;
-#endif
+static unsigned int all_fmt;
 
 #ifdef CONFIG_FEATURE_AUTOWIDTH
 static unsigned short terminal_width = TERMINAL_WIDTH;
@@ -194,26 +199,22 @@ static unsigned short tabstops = COLUMN_GAP;
 
 static int status = EXIT_SUCCESS;
 
-#ifdef CONFIG_FEATURE_HUMAN_READABLE
-static unsigned long ls_disp_hr = 0;
-#endif
-
 static struct dnode *my_stat(char *fullname, char *name)
 {
 	struct stat dstat;
 	struct dnode *cur;
 
 #ifdef CONFIG_FEATURE_LS_FOLLOWLINKS
-	if (follow_links) {
+	if (all_fmt & FOLLOW_LINKS) {
 		if (stat(fullname, &dstat)) {
-			perror_msg("%s", fullname);
+			bb_perror_msg("%s", fullname);
 			status = EXIT_FAILURE;
 			return 0;
 		}
 	} else
 #endif
 	if (lstat(fullname, &dstat)) {
-		perror_msg("%s", fullname);
+		bb_perror_msg("%s", fullname);
 		status = EXIT_FAILURE;
 	return 0;
 	}
@@ -253,9 +254,9 @@ static char bgcolor(mode_t mode)
 #if defined(CONFIG_FEATURE_LS_FILETYPES) || defined(CONFIG_FEATURE_LS_COLOR)
 static char append_char(mode_t mode)
 {
-	if (!(list_fmt & LIST_FILETYPE))
+	if (!(all_fmt & LIST_FILETYPE))
 		return '\0';
-	if ((list_fmt & LIST_EXEC) && S_ISREG(mode)
+	if ((all_fmt & LIST_EXEC) && S_ISREG(mode)
 		&& (mode & (S_IXUSR | S_IXGRP | S_IXOTH)))
 		return '*';
 	return APPCHAR(mode);
@@ -263,13 +264,11 @@ static char append_char(mode_t mode)
 #endif
 
 /*----------------------------------------------------------------------*/
-static int is_subdir(struct dnode *dn)
-{
-	return (S_ISDIR(dn->dstat.st_mode) && strcmp(dn->name, ".") != 0 &&
-			strcmp(dn->name, "..") != 0);
-}
 
-static int countdirs(struct dnode **dn, int nfiles)
+#define countdirs(A,B) count_dirs((A), (B), 1)
+#define countsubdirs(A,B) count_dirs((A), (B), 0)
+
+static int count_dirs(struct dnode **dn, int nfiles, int notsubdirs)
 {
 	int i, dirs;
 
@@ -277,25 +276,17 @@ static int countdirs(struct dnode **dn, int nfiles)
 		return (0);
 	dirs = 0;
 	for (i = 0; i < nfiles; i++) {
-		if (S_ISDIR(dn[i]->dstat.st_mode))
+		if (S_ISDIR(dn[i]->dstat.st_mode)
+			&& (notsubdirs
+				|| ((dn[i]->name[0] != '.')
+					|| (dn[i]->name[1] 
+						&& ((dn[i]->name[1] != '.')
+							|| dn[i]->name[2])))))
 			dirs++;
 	}
 	return (dirs);
 }
 
-static int countsubdirs(struct dnode **dn, int nfiles)
-{
-	int i, subdirs;
-
-	if (dn == NULL || nfiles < 1)
-		return 0;
-	subdirs = 0;
-	for (i = 0; i < nfiles; i++)
-		if (is_subdir(dn[i]))
-			subdirs++;
-	return subdirs;
-}
-
 static int countfiles(struct dnode **dnp)
 {
 	int nfiles;
@@ -364,18 +355,18 @@ static struct dnode **splitdnarray(struct dnode **dn, int nfiles, int which)
 
 	/* copy the entrys into the file or dir array */
 	for (d = i = 0; i < nfiles; i++) {
-		if (which == SPLIT_DIR) {
-			if (S_ISDIR(dn[i]->dstat.st_mode)) {
-				dnp[d++] = dn[i];
-			}			/* else skip the file */
-		} else if (which == SPLIT_SUBDIR) {
-			if (is_subdir(dn[i])) {
-				dnp[d++] = dn[i];
-			}			/* else skip the file or dir */
-		} else {
-			if (!(S_ISDIR(dn[i]->dstat.st_mode))) {
-				dnp[d++] = dn[i];
-			}			/* else skip the dir */
+		if (S_ISDIR(dn[i]->dstat.st_mode)) {
+			if (which & (SPLIT_DIR|SPLIT_SUBDIR)) {
+				if ((which & SPLIT_DIR)
+					|| ((dn[i]->name[0] != '.')
+						|| (dn[i]->name[1]
+							&& ((dn[i]->name[1] != '.')
+								|| dn[i]->name[2])))) {
+									dnp[d++] = dn[i];
+								}
+			}
+		} else if (!(which & (SPLIT_DIR|SPLIT_SUBDIR))) {
+			dnp[d++] = dn[i];
 		}
 	}
 	return (dnp);
@@ -385,29 +376,24 @@ static struct dnode **splitdnarray(struct dnode **dn, int nfiles, int which)
 #ifdef CONFIG_FEATURE_LS_SORTFILES
 static int sortcmp(struct dnode *d1, struct dnode *d2)
 {
-	int cmp, dif;
+	unsigned int sort_opts = all_fmt & SORT_MASK;
+	int dif;
 
-	cmp = 0;
+	dif = 0;			/* assume SORT_NAME */
 	if (sort_opts == SORT_SIZE) {
-		dif = (int) (d1->dstat.st_size - d2->dstat.st_size);
+		dif = (int) (d2->dstat.st_size - d1->dstat.st_size);
 	} else if (sort_opts == SORT_ATIME) {
-		dif = (int) (d1->dstat.st_atime - d2->dstat.st_atime);
+		dif = (int) (d2->dstat.st_atime - d1->dstat.st_atime);
 	} else if (sort_opts == SORT_CTIME) {
-		dif = (int) (d1->dstat.st_ctime - d2->dstat.st_ctime);
+		dif = (int) (d2->dstat.st_ctime - d1->dstat.st_ctime);
 	} else if (sort_opts == SORT_MTIME) {
-		dif = (int) (d1->dstat.st_mtime - d2->dstat.st_mtime);
+		dif = (int) (d2->dstat.st_mtime - d1->dstat.st_mtime);
 	} else if (sort_opts == SORT_DIR) {
-		dif = S_ISDIR(d1->dstat.st_mode) - S_ISDIR(d2->dstat.st_mode);
+		dif = S_ISDIR(d2->dstat.st_mode) - S_ISDIR(d1->dstat.st_mode);
 		/* } else if (sort_opts == SORT_VERSION) { */
 		/* } else if (sort_opts == SORT_EXT) { */
-	} else {			/* assume SORT_NAME */
-		dif = 0;
 	}
 
-	if (dif > 0)
-		cmp = -1;
-	if (dif < 0)
-		cmp = 1;
 	if (dif == 0) {
 		/* sort by name- may be a tie_breaker for time or size cmp */
 #ifdef CONFIG_LOCALE_SUPPORT
@@ -415,16 +401,12 @@ static int sortcmp(struct dnode *d1, struct dnode *d2)
 #else
 		dif = strcmp(d1->name, d2->name);
 #endif
-		if (dif > 0)
-			cmp = 1;
-		if (dif < 0)
-			cmp = -1;
 	}
 
-	if (sort_order == SORT_REVERSE) {
-		cmp = -1 * cmp;
+	if (all_fmt & SORT_ORDER_REVERSE) {
+		dif = -dif;
 	}
-	return (cmp);
+	return (dif);
 }
 
 /*----------------------------------------------------------------------*/
@@ -463,20 +445,17 @@ static void showfiles(struct dnode **dn, int nfiles)
 	if (dn == NULL || nfiles < 1)
 		return;
 
-	switch (style_fmt) {
-	case STYLE_LONG:        /* one record per line, extended info */
-	case STYLE_SINGLE:      /* one record per line */
+	if (all_fmt & STYLE_ONE_RECORD_FLAG) {
 		ncols = 1;
-		break;
-	default:
-	/* find the longest file name-  use that as the column width */
-	for (i = 0; i < nfiles; i++) {
+	} else {
+		/* find the longest file name-  use that as the column width */
+		for (i = 0; i < nfiles; i++) {
 			int len = strlen(dn[i]->name) +
-			((list_fmt & LIST_INO) ? 8 : 0) +
-			((list_fmt & LIST_BLOCKS) ? 5 : 0);
-		if (column_width < len)
-			column_width = len;
-	}
+			((all_fmt & LIST_INO) ? 8 : 0) +
+			((all_fmt & LIST_BLOCKS) ? 5 : 0);
+			if (column_width < len)
+				column_width = len;
+		}
 		column_width += tabstops;
 		ncols = (int) (terminal_width / column_width);
 	}
@@ -494,7 +473,7 @@ static void showfiles(struct dnode **dn, int nfiles)
 		for (nc = 0; nc < ncols; nc++) {
 			/* reach into the array based on the column and row */
 			i = (nc * nrows) + row;	/* assume display by column */
-			if (disp_opts & DISP_ROWS)
+			if (all_fmt & DISP_ROWS)
 				i = (row * ncols) + nc;	/* display across row */
 			if (i < nfiles) {
 				if (column > 0) {
@@ -528,7 +507,7 @@ static void showdirs(struct dnode **dn, int ndirs)
 		return;
 
 	for (i = 0; i < ndirs; i++) {
-		if (disp_opts & (DISP_DIRNAME | DISP_RECURSIVE)) {
+		if (all_fmt & (DISP_DIRNAME | DISP_RECURSIVE)) {
 			printf("\n%s:\n", dn[i]->fullname);
 		}
 		subdnp = list_dir(dn[i]->fullname);
@@ -540,7 +519,7 @@ static void showdirs(struct dnode **dn, int ndirs)
 #endif
 			showfiles(subdnp, nfiles);
 #ifdef CONFIG_FEATURE_LS_RECURSIVE
-			if (disp_opts & DISP_RECURSIVE) {
+			if (all_fmt & DISP_RECURSIVE) {
 				/* recursive- list the sub-dirs */
 				dnd = splitdnarray(subdnp, nfiles, SPLIT_SUBDIR);
 				dndirs = countsubdirs(subdnp, nfiles);
@@ -573,7 +552,7 @@ static struct dnode **list_dir(const char *path)
 	nfiles = 0;
 	dir = opendir(path);
 	if (dir == NULL) {
-		perror_msg("%s", path);
+		bb_perror_msg("%s", path);
 		status = EXIT_FAILURE;
 		return (NULL);	/* could not open the dir */
 	}
@@ -585,9 +564,9 @@ static struct dnode **list_dir(const char *path)
 			if ((entry->d_name[1] == 0 || (
 				entry->d_name[1] == '.'
 				&& entry->d_name[2] == 0))
-					&& !(disp_opts & DISP_DOT))
+					&& !(all_fmt & DISP_DOT))
 			continue;
-			if (!(disp_opts & DISP_HIDDEN))
+			if (!(all_fmt & DISP_HIDDEN))
 			continue;
 		}
 		fullname = concat_path_file(path, entry->d_name);
@@ -636,9 +615,9 @@ static int list_single(struct dnode *dn)
 
 #ifdef CONFIG_FEATURE_LS_TIMESTAMPS
 	ttime = dn->dstat.st_mtime;	/* the default time */
-	if (time_fmt & TIME_ACCESS)
+	if (all_fmt & TIME_ACCESS)
 		ttime = dn->dstat.st_atime;
-	if (time_fmt & TIME_CHANGE)
+	if (all_fmt & TIME_CHANGE)
 		ttime = dn->dstat.st_ctime;
 	filetime = ctime(&ttime);
 #endif
@@ -647,7 +626,7 @@ static int list_single(struct dnode *dn)
 #endif
 
 	for (i = 0; i <= 31; i++) {
-		switch (list_fmt & (1 << i)) {
+		switch (all_fmt & (1 << i)) {
 		case LIST_INO:
 			column += printf("%7ld ", (long int) dn->dstat.st_ino);
 			break;
@@ -659,7 +638,7 @@ static int list_single(struct dnode *dn)
 #endif
 			break;
 		case LIST_MODEBITS:
-			column += printf("%-10s ", (char *) mode_string(dn->dstat.st_mode));
+			column += printf("%-10s ", (char *) bb_mode_string(dn->dstat.st_mode));
 			break;
 		case LIST_NLINKS:
 			column += printf("%4ld ", (long) dn->dstat.st_nlink);
@@ -683,7 +662,7 @@ static int list_single(struct dnode *dn)
 					   (int) MINOR(dn->dstat.st_rdev));
 			} else {
 #ifdef CONFIG_FEATURE_HUMAN_READABLE
-				if (ls_disp_hr == TRUE) {
+				if (all_fmt & LS_DISP_HR) {
 					column += printf("%9s ",
 							make_human_readable_str(dn->dstat.st_size, 1, 0));
 				} else
@@ -700,7 +679,7 @@ static int list_single(struct dnode *dn)
 #ifdef CONFIG_FEATURE_LS_TIMESTAMPS
 		case LIST_FULLTIME:
 		case LIST_DATE_TIME:
-			if (list_fmt & LIST_FULLTIME) {
+			if (all_fmt & LIST_FULLTIME) {
 				printf("%24.24s ", filetime);
 				column += 25;
 				break;
@@ -774,47 +753,8 @@ static int list_single(struct dnode *dn)
 }
 
 /*----------------------------------------------------------------------*/
-extern int ls_main(int argc, char **argv)
-{
-	struct dnode **dnf, **dnd;
-	int dnfiles, dndirs;
-	struct dnode *dn, *cur, **dnp;
-	int i, nfiles;
-	int opt;
-	int oi, ac;
-	char **av;
-
-#ifdef CONFIG_FEATURE_AUTOWIDTH
-	struct winsize win = { 0, 0, 0, 0 };
-#endif
-
-	disp_opts = DISP_NORMAL;
-	style_fmt = STYLE_AUTO;
-	list_fmt = LIST_SHORT;
-#ifdef CONFIG_FEATURE_LS_SORTFILES
-	sort_opts = SORT_NAME;
-	sort_order = SORT_FORWARD;
-#endif
-#ifdef CONFIG_FEATURE_LS_TIMESTAMPS
-	time_fmt = TIME_MOD;
-#endif
-#ifdef CONFIG_FEATURE_AUTOWIDTH
-	ioctl(fileno(stdout), TIOCGWINSZ, &win);
-	if (win.ws_col > 0)
-		terminal_width = win.ws_col - 1;
-#endif
-	nfiles = 0;
 
-#ifdef CONFIG_FEATURE_LS_COLOR
-	if (isatty(fileno(stdout)))
-		show_color = 1;
-#endif
-
-	/* process options */
-	while ((opt = getopt(argc, argv, "1AaCdgilnsx"
-#ifdef CONFIG_FEATURE_AUTOWIDTH
-						 "T:w:"
-#endif
+static const char ls_opts[] = "1AaCdgilnsx"
 #ifdef CONFIG_FEATURE_LS_FILETYPES
 						 "Fp"
 #endif
@@ -825,7 +765,7 @@ extern int ls_main(int argc, char **argv)
 						 "rSvX"
 #endif
 #ifdef CONFIG_FEATURE_LS_TIMESTAMPS
-						 "cetu"
+						 "ecut"
 #endif
 #ifdef CONFIG_FEATURE_LS_FOLLOWLINKS
 						 "L"
@@ -833,141 +773,180 @@ extern int ls_main(int argc, char **argv)
 #ifdef CONFIG_FEATURE_HUMAN_READABLE
 						 "h"
 #endif
-						 "k")) > 0) {
-		switch (opt) {
-		case '1':
-			style_fmt = STYLE_SINGLE;
-			list_fmt = LIST_SHORT;
-			break;
-		case 'A':
-			disp_opts |= DISP_HIDDEN;
-			break;
-		case 'a':
-			disp_opts |= DISP_HIDDEN | DISP_DOT;
-			break;
-		case 'C':
-			style_fmt = STYLE_COLUMNS;
-			list_fmt = LIST_SHORT;
-			break;
-		case 'd':
-			disp_opts |= DISP_NOLIST;
-			break;
-		case 'g':		/* ignore -- for ftp servers */
-			break;
-		case 'i':
-			list_fmt |= LIST_INO;
-			break;
-		case 'l':
-			style_fmt = STYLE_LONG;
-			list_fmt |= LIST_LONG;
-#ifdef CONFIG_FEATURE_HUMAN_READABLE
-			ls_disp_hr = FALSE;
+						 "k"
+#ifdef CONFIG_FEATURE_AUTOWIDTH
+						 "T:w:"
 #endif
-			break;
-		case 'n':
-			list_fmt |= LIST_ID_NUMERIC;
-			break;
-		case 's':
-			list_fmt |= LIST_BLOCKS;
-			break;
-		case 'x':
-			disp_opts = DISP_ROWS;
-			break;
+	;
+
+#define LIST_MASK_TRIGGER   LIST_SHORT
+#define STYLE_MASK_TRIGGER  STYLE_MASK
+#define SORT_MASK_TRIGGER   SORT_MASK
+#define DISP_MASK_TRIGGER   DISP_ROWS
+#define TIME_MASK_TRIGGER   TIME_MASK
+
+static const unsigned opt_flags[] = {
+	LIST_SHORT | STYLE_SINGLE,	/* 1 */
+	DISP_HIDDEN,				/* A */
+	DISP_HIDDEN | DISP_DOT,		/* a */
+	LIST_SHORT | STYLE_COLUMNS,	/* C */
+	DISP_NOLIST,				/* d */
+	0,							/* g - ingored */
+	LIST_INO,					/* i */
+	LIST_LONG | STYLE_LONG,		/* l - remember LS_DISP_HR in mask! */
+	LIST_ID_NUMERIC,			/* n */
+	LIST_BLOCKS,				/* s */
+	DISP_ROWS,					/* x */
 #ifdef CONFIG_FEATURE_LS_FILETYPES
-		case 'F':
-			list_fmt |= LIST_FILETYPE | LIST_EXEC;
-			break;
-		case 'p':
-			list_fmt |= LIST_FILETYPE;
-			break;
+	LIST_FILETYPE | LIST_EXEC,	/* F */
+	LIST_FILETYPE,				/* p */
 #endif
 #ifdef CONFIG_FEATURE_LS_RECURSIVE
-		case 'R':
-			disp_opts |= DISP_RECURSIVE;
-			break;
+	DISP_RECURSIVE,				/* R */
 #endif
 #ifdef CONFIG_FEATURE_LS_SORTFILES
-		case 'r':
-			sort_order |= SORT_REVERSE;
-			break;
-		case 'S':
-			sort_opts = SORT_SIZE;
-			break;
-		case 'v':
-			sort_opts = SORT_VERSION;
-			break;
-		case 'X':
-			sort_opts = SORT_EXT;
-			break;
+	SORT_ORDER_REVERSE,			/* r */
+	SORT_SIZE,					/* S */
+	SORT_VERSION,				/* v */
+	SORT_EXT,					/* v */
 #endif
 #ifdef CONFIG_FEATURE_LS_TIMESTAMPS
-		case 'e':
-			list_fmt |= LIST_FULLTIME;
-			break;
-		case 'c':
-			time_fmt = TIME_CHANGE;
+	LIST_FULLTIME,				/* e */
 #ifdef CONFIG_FEATURE_LS_SORTFILES
-			sort_opts = SORT_CTIME;
+	TIME_CHANGE | SORT_CTIME,	/* c */
+#else
+	TIME_CHANGE,				/* c */
 #endif
-			break;
-		case 'u':
-			time_fmt = TIME_ACCESS;
 #ifdef CONFIG_FEATURE_LS_SORTFILES
-			sort_opts = SORT_ATIME;
+	TIME_ACCESS | SORT_ATIME,	/* u */
+#else
+	TIME_ACCESS,				/* u */
 #endif
-			break;
-		case 't':
 #ifdef CONFIG_FEATURE_LS_SORTFILES
-			sort_opts = SORT_MTIME;
+	SORT_MTIME,					/* t */
+#else
+	0,							/* t - ignored -- is this correct? */
 #endif
-			break;
 #endif
 #ifdef CONFIG_FEATURE_LS_FOLLOWLINKS
-		case 'L':
-			follow_links = TRUE;
-			break;
+	FOLLOW_LINKS,				/* L */
+#endif
+#ifdef CONFIG_FEATURE_HUMAN_READABLE
+LS_DISP_HR,						/* h */
+#endif
+	0,							/* k - ingored */
+};
+
+
+/*----------------------------------------------------------------------*/
+
+extern int ls_main(int argc, char **argv)
+{
+	struct dnode **dnf, **dnd;
+	int dnfiles, dndirs;
+	struct dnode *dn, *cur, **dnp;
+	int i, nfiles;
+	int opt;
+	int oi, ac;
+	char **av;
+
+#ifdef CONFIG_FEATURE_AUTOWIDTH
+	struct winsize win = { 0, 0, 0, 0 };
+#endif
+
+	all_fmt = LIST_SHORT | DISP_NORMAL | STYLE_AUTO
+#ifdef CONFIG_FEATURE_LS_TIMESTAMPS
+		| TIME_MOD
+#endif
+#ifdef CONFIG_FEATURE_LS_SORTFILES
+		| SORT_NAME | SORT_ORDER_FORWARD
+#endif
+		;
+#ifdef CONFIG_FEATURE_AUTOWIDTH
+	ioctl(fileno(stdout), TIOCGWINSZ, &win);
+	if (win.ws_col > 0)
+		terminal_width = win.ws_col - 1;
+#endif
+	nfiles = 0;
+
+#ifdef CONFIG_FEATURE_LS_COLOR
+	if (isatty(fileno(stdout)))
+		show_color = 1;
 #endif
+
+	/* process options */
+	while ((opt = getopt(argc, argv, ls_opts)) > 0) {
 #ifdef CONFIG_FEATURE_AUTOWIDTH
-		case 'T':
+		if (opt == 'T') {
 			tabstops = atoi(optarg);
-			break;
-		case 'w':
+			continue;
+		}
+		if (opt == 'w') {
 			terminal_width = atoi(optarg);
-			break;
+			continue;
+		}
+		if (opt == ':') {
+			goto print_usage_message;
+		}
 #endif
+		{
+			unsigned int flags;
+			const char *p = strchr(ls_opts, opt);
+			if (!p) {	/* shouldn't be necessary */
+				goto print_usage_message;
+			}
+			flags = opt_flags[(int)(p - ls_opts)];
+			if (flags & LIST_MASK_TRIGGER) {
+				all_fmt &= ~LIST_MASK;
+			}
+			if (flags & STYLE_MASK_TRIGGER) {
+				all_fmt &= ~STYLE_MASK;
+			}
+			if (flags & SORT_MASK_TRIGGER) {
+				all_fmt &= ~SORT_MASK;
+			}
+			if (flags & DISP_MASK_TRIGGER) {
+				all_fmt &= ~DISP_MASK;
+			}
+			if (flags & TIME_MASK_TRIGGER) {
+				all_fmt &= ~TIME_MASK;
+			}
 #ifdef CONFIG_FEATURE_HUMAN_READABLE
-		case 'h':
-			ls_disp_hr = TRUE;
-			break;
+			if (opt == 'l') {
+				all_fmt &= ~LS_DISP_HR;
+			}
 #endif
-		case 'k':
-			break;
-		default:
-			goto print_usage_message;
+			all_fmt |= flags;
 		}
 	}
 
+
 	/* sort out which command line options take precedence */
 #ifdef CONFIG_FEATURE_LS_RECURSIVE
-	if (disp_opts & DISP_NOLIST)
-		disp_opts &= ~DISP_RECURSIVE;	/* no recurse if listing only dir */
+	if (all_fmt & DISP_NOLIST)
+		all_fmt &= ~DISP_RECURSIVE;	/* no recurse if listing only dir */
 #endif
 #if defined (CONFIG_FEATURE_LS_TIMESTAMPS) && defined (CONFIG_FEATURE_LS_SORTFILES)
-	if (time_fmt & TIME_CHANGE)
-		sort_opts = SORT_CTIME;
-	if (time_fmt & TIME_ACCESS)
-		sort_opts = SORT_ATIME;
+	if (all_fmt & TIME_CHANGE)
+		all_fmt = (all_fmt & ~SORT_MASK) | SORT_CTIME;
+	if (all_fmt & TIME_ACCESS)
+		all_fmt = (all_fmt & ~SORT_MASK) | SORT_ATIME;
 #endif
-	if (style_fmt != STYLE_LONG) /* only for long list */
-		list_fmt &= ~(LIST_ID_NUMERIC|LIST_FULLTIME|LIST_ID_NAME|LIST_ID_NUMERIC);
+	if ((all_fmt & STYLE_MASK) != STYLE_LONG) /* only for long list */
+		all_fmt &= ~(LIST_ID_NUMERIC|LIST_FULLTIME|LIST_ID_NAME|LIST_ID_NUMERIC);
 #ifdef CONFIG_FEATURE_LS_USERNAME
-	if (style_fmt == STYLE_LONG && (list_fmt & LIST_ID_NUMERIC))
-		list_fmt &= ~LIST_ID_NAME;	/* don't list names if numeric uid */
+	if ((all_fmt & STYLE_MASK) == STYLE_LONG && (all_fmt & LIST_ID_NUMERIC))
+		all_fmt &= ~LIST_ID_NAME;	/* don't list names if numeric uid */
 #endif
-
+			
 	/* choose a display format */
-	if (style_fmt == STYLE_AUTO)
-		style_fmt = isatty(fileno(stdout)) ? STYLE_COLUMNS : STYLE_SINGLE;
+	if ((all_fmt & STYLE_MASK) == STYLE_AUTO)
+#if STYLE_AUTO != 0
+		all_fmt = (all_fmt & ~STYLE_MASK)
+				| (isatty(fileno(stdout)) ? STYLE_COLUMNS : STYLE_SINGLE);
+#else
+		all_fmt |= (isatty(fileno(stdout)) ? STYLE_COLUMNS : STYLE_SINGLE);
+#endif
 
 	/*
 	 * when there are no cmd line args we have to supply a default "." arg.
@@ -979,7 +958,7 @@ extern int ls_main(int argc, char **argv)
 	ac = argc - optind;	/* how many cmd line args are left */
 	if (ac < 1) {
 		av = (char **) xcalloc((size_t) 1, (size_t) (sizeof(char *)));
-		av[0] = xstrdup(".");
+		av[0] = bb_xstrdup(".");
 		ac = 1;
 	} else {
 		av = (char **) xcalloc((size_t) ac, (size_t) (sizeof(char *)));
@@ -990,12 +969,12 @@ extern int ls_main(int argc, char **argv)
 
 	/* now, everything is in the av array */
 	if (ac > 1)
-		disp_opts |= DISP_DIRNAME;	/* 2 or more items? label directories */
+		all_fmt |= DISP_DIRNAME;	/* 2 or more items? label directories */
 
 	/* stuff the command line file names into an dnode array */
 	dn = NULL;
 	for (oi = 0; oi < ac; oi++) {
-		char *fullname = xstrdup(av[oi]);
+		char *fullname = bb_xstrdup(av[oi]);
 
 		cur = my_stat(fullname, fullname);
 		if (!cur)
@@ -1015,7 +994,7 @@ extern int ls_main(int argc, char **argv)
 	}
 
 
-	if (disp_opts & DISP_NOLIST) {
+	if (all_fmt & DISP_NOLIST) {
 #ifdef CONFIG_FEATURE_LS_SORTFILES
 		shellsort(dnp, nfiles);
 #endif
@@ -1042,5 +1021,5 @@ extern int ls_main(int argc, char **argv)
 	return (status);
 
   print_usage_message:
-	show_usage();
+	bb_show_usage();
 }
diff --git a/coreutils/md5sum.c b/coreutils/md5sum.c
index f5be4486c..c1480cd32 100644
--- a/coreutils/md5sum.c
+++ b/coreutils/md5sum.c
@@ -770,13 +770,13 @@ static int md5_file(const char *filename,
     have_read_stdin = 1;
     fp = stdin;
   } else {
-    fp = wfopen(filename, "r");
+    fp = bb_wfopen(filename, "r");
     if (fp == NULL)
       return FALSE;
     }
 
   if (md5_stream(fp, md5_result)) {
-    perror_msg("%s", filename);
+    bb_perror_msg("%s", filename);
 
     if (fp != stdin)
       fclose(fp);
@@ -784,7 +784,7 @@ static int md5_file(const char *filename,
   }
 
   if (fp != stdin && fclose(fp) == EOF) {
-    perror_msg("%s", filename);
+    bb_perror_msg("%s", filename);
     return FALSE;
   }
 
@@ -805,7 +805,7 @@ static int md5_check(const char *checkfile_name)
     have_read_stdin = 1;
     checkfile_stream = stdin;
   } else {
-    checkfile_stream = wfopen(checkfile_name, "r");
+    checkfile_stream = bb_wfopen(checkfile_name, "r");
     if (checkfile_stream == NULL)
       return FALSE;
     }
@@ -836,7 +836,7 @@ static int md5_check(const char *checkfile_name)
     if (split_3(line, line_length, &md5num, &filename)
         || !hex_digits(md5num)) {
       if (warn) {
-        error_msg("%s: %lu: improperly formatted MD5 checksum line",
+        bb_error_msg("%s: %lu: improperly formatted MD5 checksum line",
                  checkfile_name, (unsigned long) line_number);
       }
     } else {
@@ -881,18 +881,18 @@ static int md5_check(const char *checkfile_name)
   while (!feof(checkfile_stream) && !ferror(checkfile_stream));
 
   if (ferror(checkfile_stream)) {
-    error_msg("%s: read error", checkfile_name);
+    bb_error_msg("%s: read error", checkfile_name);
     return FALSE;
   }
 
   if (checkfile_stream != stdin && fclose(checkfile_stream) == EOF) {
-    perror_msg("md5sum: %s", checkfile_name);
+    bb_perror_msg("md5sum: %s", checkfile_name);
     return FALSE;
   }
 
   if (n_properly_formated_lines == 0) {
     /* Warn if no tests are found.  */
-    error_msg("%s: no properly formatted MD5 checksum lines found",
+    bb_error_msg("%s: no properly formatted MD5 checksum lines found",
              checkfile_name);
     return FALSE;
   } else {
@@ -901,13 +901,13 @@ static int md5_check(const char *checkfile_name)
                                  - n_open_or_read_failures);
 
       if (n_open_or_read_failures > 0) {
-        error_msg("WARNING: %d of %d listed files could not be read",
+        bb_error_msg("WARNING: %d of %d listed files could not be read",
                  n_open_or_read_failures, n_properly_formated_lines);
         return FALSE;
       }
 
       if (n_mismatched_checksums > 0) {
-        error_msg("WARNING: %d of %d computed checksums did NOT match",
+        bb_error_msg("WARNING: %d of %d computed checksums did NOT match",
                  n_mismatched_checksums, n_computed_checkums);
         return FALSE;
       }
@@ -965,31 +965,31 @@ int md5sum_main(int argc,
       break;
 
      default:
-      show_usage();
+      bb_show_usage();
     }
   }
 
   if (file_type_specified && do_check) {
-    error_msg_and_die("the -b and -t options are meaningless when verifying checksums");
+    bb_error_msg_and_die("the -b and -t options are meaningless when verifying checksums");
   }
 
   if (n_strings > 0 && do_check) {
-    error_msg_and_die("the -g and -c options are mutually exclusive");
+    bb_error_msg_and_die("the -g and -c options are mutually exclusive");
   }
 
   if (status_only && !do_check) {
-    error_msg_and_die("the -s option is meaningful only when verifying checksums");
+    bb_error_msg_and_die("the -s option is meaningful only when verifying checksums");
   }
 
   if (warn && !do_check) {
-    error_msg_and_die("the -w option is meaningful only when verifying checksums");
+    bb_error_msg_and_die("the -w option is meaningful only when verifying checksums");
   }
 
   if (n_strings > 0) {
     size_t i;
 
     if (optind < argc) {
-      error_msg_and_die("no files may be specified when using -g");
+      bb_error_msg_and_die("no files may be specified when using -g");
     }
     for (i = 0; i < n_strings; ++i) {
       size_t cnt;
@@ -1002,7 +1002,7 @@ int md5sum_main(int argc,
     }
   } else if (do_check) {
     if (optind + 1 < argc) {
-      error_msg("only one argument may be specified when using -c");
+      bb_error_msg("only one argument may be specified when using -c");
     }
 
     err = md5_check ((optind == argc) ? "-" : argv[optind]);
@@ -1060,11 +1060,11 @@ int md5sum_main(int argc,
   }
 
   if (fclose (stdout) == EOF) {
-    error_msg_and_die("write error");
+    bb_error_msg_and_die("write error");
   }
 
   if (have_read_stdin && fclose (stdin) == EOF) {
-    error_msg_and_die("standard input");
+    bb_error_msg_and_die(bb_msg_standard_input);
   }
 
   if (err == 0)
diff --git a/coreutils/mkdir.c b/coreutils/mkdir.c
index f003db99f..b018ac181 100644
--- a/coreutils/mkdir.c
+++ b/coreutils/mkdir.c
@@ -20,46 +20,50 @@
  *
  */
 
-#include <errno.h>
-#include <getopt.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/mkdir.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Fixed broken permission setting when -p was used; especially in
+ * conjunction with -m.
+ */
 
+#include <stdlib.h>
+#include <unistd.h>
 #include "busybox.h"
 
 extern int mkdir_main (int argc, char **argv)
 {
-	mode_t mode = -1;
+	mode_t mode = (mode_t)(-1);
+	int status = EXIT_SUCCESS;
 	int flags = 0;
-	int i, opt;
+	int opt;
 
-	while ((opt = getopt (argc, argv, "m:p")) != -1) {
-		switch (opt) {
-		case 'm':
+	while ((opt = getopt (argc, argv, "m:p")) > 0) {
+		if (opt == 'm') {
 			mode = 0777;
-			if (!parse_mode (optarg, &mode)) {
-				error_msg_and_die ("invalid mode `%s'", optarg);
+			if (!bb_parse_mode (optarg, &mode)) {
+				bb_error_msg_and_die ("invalid mode `%s'", optarg);
 			}
-			umask(0);
-			break;
-		case 'p':
+		} else if (opt == 'p') {
 			flags |= FILEUTILS_RECUR;
-			break;
-		default:
-			show_usage ();
+		} else {
+			bb_show_usage();
 		}
 	}
 
-	if (optind == argc)
-		show_usage ();
-
-	for (i = optind; i < argc; i++) {
-		make_directory (argv[i], mode, flags);
+	if (optind == argc) {
+		bb_show_usage();
 	}
 
-	return(EXIT_SUCCESS);
+	argv += optind;
+
+	do {
+		if (bb_make_directory(*argv, mode, flags)) {
+			status = EXIT_FAILURE;
+		}
+	} while (*++argv);
+
+	return status;
 }
diff --git a/coreutils/mkfifo.c b/coreutils/mkfifo.c
index ca217fa23..77e0e6dd8 100644
--- a/coreutils/mkfifo.c
+++ b/coreutils/mkfifo.c
@@ -1,8 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini mkfifo implementation for busybox
+ * mkfifo implementation for busybox
  *
- * Copyright (C) 1999 by Randolph Chung <tausq@debian.org>
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,41 +20,32 @@
  *
  */
 
-#include <stdio.h>
-#include <sys/types.h>
-#include <errno.h>
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/mkfifo.html */
+
 #include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
 #include "busybox.h"
+#include "libcoreutils/coreutils.h"
 
 extern int mkfifo_main(int argc, char **argv)
 {
-	char *thisarg;
-	mode_t mode = 0666;
+	mode_t mode;
+	int retval = EXIT_SUCCESS;
 
-	argc--;
-	argv++;
+	mode = getopt_mk_fifo_nod(argc, argv);
 
-	/* Parse any options */
-	while (argc > 1) {
-		if (**argv != '-')
-			show_usage();
-		thisarg = *argv;
-		thisarg++;
-		switch (*thisarg) {
-		case 'm':
-			argc--;
-			argv++;
-			parse_mode(*argv, &mode);
-			break;
-		default:
-			show_usage();
-		}
-		argc--;
-		argv++;
+	if (!*(argv += optind)) {
+		bb_show_usage();
 	}
-	if (argc < 1 || *argv[0] == '-')
-		show_usage();
-	if (mkfifo(*argv, mode) < 0)
-		perror_msg_and_die("mkfifo");
-	return EXIT_SUCCESS;
+
+	do {
+		if (mkfifo(*argv, mode) < 0) {
+			bb_perror_msg("%s", *argv);	/* Avoid multibyte problems. */
+			retval = EXIT_FAILURE;
+		}
+	} while (*++argv);
+
+	return retval;
 }
diff --git a/coreutils/mknod.c b/coreutils/mknod.c
index 432ec2b25..59294e9cb 100644
--- a/coreutils/mknod.c
+++ b/coreutils/mknod.c
@@ -1,9 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini mknod implementation for busybox
+ * mknod implementation for busybox
  *
- * Copyright (C) 1995, 1996 by Bruce Perens <bruce@pixar.com>.
- * Copyright (C) 1999-2002 by Erik Andersen <andersee@debian.org>
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,73 +20,44 @@
  *
  */
 
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <string.h>
+/* BB_AUDIT SUSv3 N/A -- Matches GNU behavior. */
+
 #include <stdlib.h>
-#include <sys/types.h>
+#include <string.h>
 #include <sys/stat.h>
+#include <unistd.h>
 #include "busybox.h"
+#include "libcoreutils/coreutils.h"
+
+static const char modes_chars[] = { 'p', 'c', 'u', 'b', 0, 1, 1, 2 };
+static const mode_t modes_cubp[] = { S_IFIFO, S_IFCHR, S_IFBLK };
 
-int mknod_main(int argc, char **argv)
+extern int mknod_main(int argc, char **argv)
 {
-	char *thisarg;
-	mode_t mode = 0;
-	mode_t perm = 0666;
-	dev_t dev = (dev_t) 0;
+	mode_t mode;
+	dev_t dev;
+	const char *name;
+
+	mode = getopt_mk_fifo_nod(argc, argv);
+	argv += optind;
+	argc -= optind;
 
-	argc--;
-	argv++;
+	if ((argc >= 2) && ((name = strchr(modes_chars, argv[1][0])) != NULL)) {
+		mode |= modes_cubp[(int)(name[4])];
 
-	/* Parse any options */
-	while (argc > 1) {
-		if (**argv != '-')
-			break;
-		thisarg = *argv;
-		thisarg++;
-		switch (*thisarg) {
-		case 'm':
-			argc--;
-			argv++;
-			parse_mode(*argv, &perm);
-			umask(0);
-			break;
-		default:
-			show_usage();
+		dev = 0;
+		if ((*name != 'p') && ((argc -= 2) == 0)) {
+			dev = (bb_xgetularg10_bnd(argv[2], 0, 255) << 8)
+				+ bb_xgetularg10_bnd(argv[3], 0, 255);
 		}
-		argc--;
-		argv++;
-	}
-	if (argc != 4 && argc != 2) {
-		show_usage();
-	}
-	switch (argv[1][0]) {
-	case 'c':
-	case 'u':
-		mode = S_IFCHR;
-		break;
-	case 'b':
-		mode = S_IFBLK;
-		break;
-	case 'p':
-		mode = S_IFIFO;
-		if (argc != 2) {
-			show_usage();
+	
+		if (argc == 2) {
+			name = *argv;
+			if (mknod(name, mode, dev) == 0) {
+				return EXIT_SUCCESS;
+			}
+			bb_perror_msg_and_die("%s", name);
 		}
-		break;
-	default:
-		show_usage();
-	}
-
-	if (mode == S_IFCHR || mode == S_IFBLK) {
-		dev = (dev_t) ((atoi(argv[2]) << 8) | atoi(argv[3]));
 	}
-
-	mode |= perm;
-
-	if (mknod(argv[0], mode, dev) != 0)
-		perror_msg_and_die("%s", argv[0]);
-	return EXIT_SUCCESS;
+	bb_show_usage();
 }
diff --git a/coreutils/mv.c b/coreutils/mv.c
index 1c4a34788..ae0ee92e4 100644
--- a/coreutils/mv.c
+++ b/coreutils/mv.c
@@ -2,7 +2,6 @@
 /*
  * Mini mv implementation for busybox
  *
- *
  * Copyright (C) 2000 by Matt Kraai <kraai@alumni.carnegiemellon.edu>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -21,148 +20,122 @@
  *
  */
 
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Size reduction and improved error checking.
+ */
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 #include <dirent.h>
 #include <errno.h>
 #include <stdlib.h>
-
 #include "busybox.h"
+#include "libcoreutils/coreutils.h"
 
-static int flags;
+static const char *fmt = "cannot overwrite %sdirectory with %sdirectory";
 
-static int manual_rename(const char *source, const char *dest)
+extern int mv_main(int argc, char **argv)
 {
 	struct stat source_stat;
 	struct stat dest_stat;
-	int source_exists = 1;
-	int dest_exists = 1;
+	const char *last;
+	const char *dest;
+	int dest_exists;
+	int source_exists;
+	int opt;
+	int flags = 0;
+	int status = 0;
 
-	if (stat(source, &source_stat) < 0) {
-		if (errno != ENOENT) {
-			perror_msg("unable to stat `%s'", source);
-			return -1;
+	while ((opt = getopt(argc, argv, "fi")) > 0) {
+		flags &= ~(FILEUTILS_INTERACTIVE | FILEUTILS_FORCE);
+		if (opt == 'i') {
+			flags |= FILEUTILS_INTERACTIVE;
+		} else if (opt == 'f') {
+			flags |= FILEUTILS_FORCE;
+		} else {
+			bb_show_usage();
 		}
-		source_exists = 0;
 	}
 
-	if (stat(dest, &dest_stat) < 0) {
-		if (errno != ENOENT) {
-			perror_msg("unable to stat `%s'", dest);
-			return -1;
-		}
-		dest_exists = 0;
-	}
+	if (optind + 2 > argc)
+		bb_show_usage();
 
-	if (dest_exists) {
-		if (S_ISDIR(dest_stat.st_mode) &&
-			  (!source_exists || !S_ISDIR(source_stat.st_mode))) {
-			error_msg("cannot overwrite directory with non-directory");
-			return -1;
-		}
+	last = argv[argc - 1];
+	argv += optind;
 
-		if (!S_ISDIR(dest_stat.st_mode) && source_exists &&
-				S_ISDIR(source_stat.st_mode)) {
-			error_msg("cannot overwrite non-directory with directory");
-			return -1;
+	if (optind + 2 == argc) {
+		if ((dest_exists = cp_mv_stat(last, &dest_stat)) < 0) {
+			return 1;
 		}
 
-		if (unlink(dest) < 0) {
-			perror_msg("cannot remove `%s'", dest);
-			return -1;
+		if (!(dest_exists & 2)) {
+			dest = last;
+			goto DO_MOVE;
 		}
 	}
+	
+	do {
+		dest = concat_path_file(last,
+								bb_get_last_path_component(*argv));
 
-	if (copy_file(source, dest,
-			FILEUTILS_RECUR | FILEUTILS_PRESERVE_STATUS) < 0)
-		return -1;
-
-	if (remove_file(source, FILEUTILS_RECUR | FILEUTILS_FORCE) < 0)
-		return -1;
-
-	return 0;
-}
-
-static int move_file(const char *source, const char *dest)
-{
-	struct stat dest_stat;
-	int dest_exists = 1;
-
-	if (stat(dest, &dest_stat) < 0) {
-		if (errno != ENOENT) {
-			perror_msg("unable to stat `%s'", dest);
-			return -1;
+		if ((dest_exists = cp_mv_stat(dest, &dest_stat)) < 0) {
+			goto RET_1;
 		}
-		dest_exists = 0;
-	}
 
-	if (dest_exists && !(flags & FILEUTILS_FORCE) &&
+	DO_MOVE:
+		
+		if (dest_exists && !(flags & FILEUTILS_FORCE) &&
 			((access(dest, W_OK) < 0 && isatty(0)) ||
 			 (flags & FILEUTILS_INTERACTIVE))) {
-		fprintf(stderr, "mv: overwrite `%s'? ", dest);
-		if (!ask_confirmation())
-			return 0;
-	}
-
-	if (rename(source, dest) < 0) {
-		if (errno == EXDEV)
-			return manual_rename(source, dest);
-
-		perror_msg("unable to rename `%s'", source);
-		return -1;
-	}
-	
-	return 0;
-}
-
-extern int mv_main(int argc, char **argv)
-{
-	int status = 0;
-	int opt;
-	int i;
-
-	while ((opt = getopt(argc, argv, "fi")) != -1)
-		switch (opt) {
-		case 'f':
-			flags &= ~FILEUTILS_INTERACTIVE;
-			flags |= FILEUTILS_FORCE;
-			break;
-		case 'i':
-			flags &= ~FILEUTILS_FORCE;
-			flags |= FILEUTILS_INTERACTIVE;
-			break;
-		default:
-			show_usage();
-		}
-
-	if (optind + 2 > argc)
-		show_usage();
-
-	if (optind + 2 == argc) {
-		struct stat dest_stat;
-		int dest_exists = 1;
-
-		if (stat(argv[optind + 1], &dest_stat) < 0) {
-			if (errno != ENOENT)
-				perror_msg_and_die("unable to stat `%s'", argv[optind + 1]);
-			dest_exists = 0;
+				 if (fprintf(stderr, "mv: overwrite `%s'? ", dest) < 0) {
+					 goto RET_1;	/* Ouch! fprintf failed! */
+				 }
+				 if (!bb_ask_confirmation())
+					 goto RET_0;
+		 }
+		
+		if (rename(*argv, dest) < 0) {
+			if (errno != EXDEV) {
+				bb_perror_msg("unable to rename `%s'", *argv);
+			} else if ((source_exists = cp_mv_stat(*argv, &source_stat)) >= 0) {
+				if (dest_exists) {
+					if (dest_exists & 2) {
+						if (!(source_exists & 2)) {
+							bb_error_msg(fmt, "", "non-");
+							goto RET_1;
+						}
+					} else {
+						if (source_exists & 2) {
+							bb_error_msg(fmt, "non-", "");
+							goto RET_1;
+						}
+					}
+					if (unlink(dest) < 0) {
+						bb_perror_msg("cannot remove `%s'", dest);
+						goto RET_1;
+					}
+				}
+				
+				if ((copy_file(*argv, dest,
+							   FILEUTILS_RECUR | FILEUTILS_PRESERVE_STATUS) >= 0)
+					&& (remove_file(*argv, FILEUTILS_RECUR | FILEUTILS_FORCE) >= 0)
+					) {
+					goto RET_0;
+				}
+				
+			}
+		RET_1:
+			status = 1;
 		}
 
-		if (!dest_exists || !S_ISDIR(dest_stat.st_mode)) {
-			if (move_file(argv[optind], argv[optind + 1]) < 0)
-				status = 1;
-			return status;
+	RET_0:
+		if (dest != last) {
+			free((void *) dest);
 		}
-	}
-
-	for (i = optind; i < argc - 1; i++) {
-		char *dest = concat_path_file(argv[argc - 1],
-				get_last_path_component(argv[i]));
-		if (move_file(argv[i], dest) < 0)
-			status = 1;
-		free(dest);
-	}
-
-	return status;
+		
+	} while (*++argv != last);
+	
+	exit(status);
 }
diff --git a/coreutils/od.c b/coreutils/od.c
index 6187cadf2..5eaaf5024 100644
--- a/coreutils/od.c
+++ b/coreutils/od.c
@@ -23,22 +23,18 @@
  */
 
 #include <ctype.h>
+#include <string.h>
 #include <getopt.h>
 #include <stdlib.h>
-#include "dump.h"
 #include "busybox.h"
+#include "dump.h"
 
-extern FS *fshead;				/* head of format strings */
-extern int blocksize;				/* data block size */
-extern int length;			/* max bytes to read */
-
-#define	ishexdigit(c) \
-	((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))
+#define isdecdigit(c) (isdigit)(c)
+#define ishexdigit(c) (isxdigit)(c)
 
 static void
 odoffset(int argc, char ***argvp)
 {
-	extern off_t skip;
 	register char *num, *p;
 	int base;
 	char *end;
@@ -62,13 +58,15 @@ odoffset(int argc, char ***argvp)
 		return;
 	}
 
-	if (*p != '+' && (argc < 2 ||
-	    (!isdigit(p[0]) && (p[0] != 'x' || !ishexdigit(p[1])))))
+	if ((*p != '+')
+		&& (argc < 2
+			|| (!isdecdigit(p[0])
+				&& ((p[0] != 'x') || !ishexdigit(p[1])))))
 		return;
 
 	base = 0;
 	/*
-	 * skip over leading '+', 'x[0-9a-fA-f]' or '0x', and
+	 * bb_dump_skip over leading '+', 'x[0-9a-fA-f]' or '0x', and
 	 * set base.
 	 */
 	if (p[0] == '+')
@@ -81,11 +79,11 @@ odoffset(int argc, char ***argvp)
 		base = 16;
 	}
 
-	/* skip over the number */
+	/* bb_dump_skip over the number */
 	if (base == 16)
 		for (num = p; ishexdigit(*p); ++p);
 	else
-		for (num = p; isdigit(*p); ++p);
+		for (num = p; isdecdigit(*p); ++p);
 
 	/* check for no number */
 	if (num == p)
@@ -98,21 +96,23 @@ odoffset(int argc, char ***argvp)
 		base = 10;
 	}
 
-	skip = strtol(num, &end, base ? base : 8);
+	bb_dump_skip = strtol(num, &end, base ? base : 8);
 
 	/* if end isn't the same as p, we got a non-octal digit */
 	if (end != p)
-		skip = 0;
+		bb_dump_skip = 0;
 	else {
 		if (*p) {
-			if (*p == 'b')
-				skip *= 512;
-			else if (*p == 'B')
-				skip *= 1024;
-			++p;
+			if (*p == 'b') {
+				bb_dump_skip *= 512;
+				++p;
+			} else if (*p == 'B') {
+				bb_dump_skip *= 1024;
+				++p;
+			}
 		}
 		if (*p)
-			skip = 0;
+			bb_dump_skip = 0;
 		else {
 			++*argvp;
 			/*
@@ -121,117 +121,76 @@ odoffset(int argc, char ***argvp)
 			 * but it's easy.
 			 */
 #define	TYPE_OFFSET	7
-			if (base == 16) {
-				fshead->nextfu->fmt[TYPE_OFFSET] = 'x';
-				fshead->nextfs->nextfu->fmt[TYPE_OFFSET] = 'x';
-			} else if (base == 10) {
-				fshead->nextfu->fmt[TYPE_OFFSET] = 'd';
-				fshead->nextfs->nextfu->fmt[TYPE_OFFSET] = 'd';
+			{
+				char x_or_d;
+				if (base == 16) {
+					x_or_d = 'x';
+					goto DO_X_OR_D;
+				}
+				if (base == 10) {
+					x_or_d = 'd';
+				DO_X_OR_D:
+					bb_dump_fshead->nextfu->fmt[TYPE_OFFSET]
+						= bb_dump_fshead->nextfs->nextfu->fmt[TYPE_OFFSET]
+						= x_or_d;
+				}
 			}
 		}
 	}
 }
 
-static void odprecede(void)
-{
-	static int first = 1;
-
-	if (first) {
-		first = 0;
-		add("\"%07.7_Ao\n\"");
-		add("\"%07.7_ao  \"");
-	} else
-		add("\"         \"");
-}
+static const char * const add_strings[] = {
+	"16/1 \"%3_u \" \"\\n\"",				/* a */
+	"8/2 \" %06o \" \"\\n\"",				/* B, o */
+	"16/1 \"%03o \" \"\\n\"",				/* b */
+	"16/1 \"%3_c \" \"\\n\"",				/* c */
+	"8/2 \"  %05u \" \"\\n\"",				/* d */
+	"4/4 \"     %010u \" \"\\n\"",			/* D */
+	"2/8 \"          %21.14e \" \"\\n\"",	/* e (undocumented in od), F */
+	"4/4 \" %14.7e \" \"\\n\"",				/* f */
+	"4/4 \"       %08x \" \"\\n\"",			/* H, X */
+	"8/2 \"   %04x \" \"\\n\"",				/* h, x */
+	"4/4 \"    %11d \" \"\\n\"",			/* I, L, l */
+	"8/2 \" %6d \" \"\\n\"",				/* i */
+	"4/4 \"    %011o \" \"\\n\"",			/* O */
+};
+
+static const signed char od_opts[] = "aBbcDdeFfHhIiLlOovXx";
+
+static const signed char od_o2si[] = {
+	0, 1, 2, 3, 5,
+	4, 6, 6, 7, 8,
+	9, 0xa, 0xb, 0xa, 0xa,
+	0xb, 1, -1, 8, 9,
+};
 
 int od_main(int argc, char **argv)
 {
 	int ch;
-	extern enum _vflag vflag;
-	vflag = FIRST;
-	length = -1;
-
-	while ((ch = getopt(argc, argv, "aBbcDdeFfHhIiLlOoPpswvXx")) != EOF)
-		switch (ch) {
-		case 'a':
-			odprecede();
-			add("16/1 \"%3_u \" \"\\n\"");
-			break;
-		case 'B':
-		case 'o':
-			odprecede();
-			add("8/2 \" %06o \" \"\\n\"");
-			break;
-		case 'b':
-			odprecede();
-			add("16/1 \"%03o \" \"\\n\"");
-			break;
-		case 'c':
-			odprecede();
-			add("16/1 \"%3_c \" \"\\n\"");
-			break;
-		case 'd':
-			odprecede();
-			add("8/2 \"  %05u \" \"\\n\"");
-			break;
-		case 'D':
-			odprecede();
-			add("4/4 \"     %010u \" \"\\n\"");
-			break;
-		case 'e':		/* undocumented in od */
-		case 'F':
-			odprecede();
-			add("2/8 \"          %21.14e \" \"\\n\"");
-			break;
-			
-		case 'f':
-			odprecede();
-			add("4/4 \" %14.7e \" \"\\n\"");
-			break;
-		case 'H':
-		case 'X':
-			odprecede();
-			add("4/4 \"       %08x \" \"\\n\"");
-			break;
-		case 'h':
-		case 'x':
-			odprecede();
-			add("8/2 \"   %04x \" \"\\n\"");
-			break;
-		case 'I':
-		case 'L':
-		case 'l':
-			odprecede();
-			add("4/4 \"    %11d \" \"\\n\"");
-			break;
-		case 'i':
-			odprecede();
-			add("8/2 \" %6d \" \"\\n\"");
-			break;
-		case 'O':
-			odprecede();
-			add("4/4 \"    %011o \" \"\\n\"");
-			break;
-		case 'v':
-			vflag = ALL;
-			break;
-		case 'P':
-		case 'p':
-		case 's':
-		case 'w':
-		case '?':
-		default:
-			error_msg("od: od(1) has been deprecated for hexdump(1).\n");
-			if (ch != '?') {
-				error_msg("od: hexdump(1) compatibility doesn't support the -%c option%s\n",
-				    ch, ch == 's' ? "; see strings(1)." : ".");
+	bb_dump_vflag = FIRST;
+	bb_dump_length = -1;
+	int first = 1;
+	signed char *p;
+
+	while ((ch = getopt(argc, argv, od_opts)) > 0) {
+		if (((p = strchr(od_opts, ch)) != NULL) && (*p >= 0)) {
+			if (first) {
+				first = 0;
+				bb_dump_add("\"%07.7_Ao\n\"");
+				bb_dump_add("\"%07.7_ao  \"");
+			} else {
+				bb_dump_add("\"         \"");
 			}
-			show_usage();
+			bb_dump_add(add_strings[od_o2si[(int)(p-od_opts)]]);
+		} else if (ch == 'v') {
+			bb_dump_vflag = ALL;
+		} else {	/* P, p, s, w, or other unhandled */
+			bb_show_usage();
 		}
-
-	if (!fshead) {
-		add("\"%07.7_Ao\n\"");
-		add("\"%07.7_ao  \" 8/2 \"%06o \" \"\\n\"");
+	}
+	if (!bb_dump_fshead) {
+		bb_dump_add("\"%07.7_Ao\n\"");
+		bb_dump_add("\"%07.7_ao  \" 8/2 \"%06o \" \"\\n\"");
 	}
 
 	argc -= optind;
@@ -239,7 +198,7 @@ int od_main(int argc, char **argv)
 
 	odoffset(argc, &argv);
 
-	return(dump(argv));
+	return(bb_dump_dump(argv));
 }
 
 /*-
diff --git a/coreutils/printf.c b/coreutils/printf.c
index d579a9b4e..9602788de 100644
--- a/coreutils/printf.c
+++ b/coreutils/printf.c
@@ -124,7 +124,7 @@ int printf_main(int argc, char **argv)
 
 	exit_status = 0;
 	if (argc <= 1 || **(argv + 1) == '-') {
-		show_usage();
+		bb_show_usage();
 	}
 
 	format = argv[1];
diff --git a/coreutils/pwd.c b/coreutils/pwd.c
index 9c5d70cef..7e0dc056a 100644
--- a/coreutils/pwd.c
+++ b/coreutils/pwd.c
@@ -20,24 +20,18 @@
  *
  */
 
-/* getopt not needed */
-
 #include <stdio.h>
-#include <dirent.h>
-#include <errno.h>
-#include <unistd.h>
 #include <stdlib.h>
 #include "busybox.h"
 
 extern int pwd_main(int argc, char **argv)
 {
-	static char *buf; 
-	
-	buf = xgetcwd(buf);
-	
-	if (buf != NULL) {
+	char *buf;
+
+	if ((buf = xgetcwd(NULL)) != NULL) {
 		puts(buf);
-		return EXIT_SUCCESS;
+		bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 	}
+
 	return EXIT_FAILURE;
 }
diff --git a/coreutils/realpath.c b/coreutils/realpath.c
index f89e0a274..ec98221ad 100644
--- a/coreutils/realpath.c
+++ b/coreutils/realpath.c
@@ -14,17 +14,26 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+/* BB_AUDIT SUSv3 N/A -- Apparently a busybox extension. */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Now does proper error checking on output and returns a failure exit code
+ * if one or more paths can not be resolved.
+ */
+
 #include <limits.h>
 #include <stdlib.h>
-
 #include "busybox.h"
 
 int realpath_main(int argc, char **argv)
 {
+	int retval = EXIT_SUCCESS;
+
 	RESERVE_CONFIG_BUFFER(resolved_path, PATH_MAX);
 
 	if (--argc == 0) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	do {
@@ -32,11 +41,14 @@ int realpath_main(int argc, char **argv)
 		if (realpath(*argv, resolved_path) != NULL) {
 			puts(resolved_path);
 		} else {
-			perror_msg("%s", *argv);
+			retval = EXIT_FAILURE;
+			bb_perror_msg("%s", *argv);
 		}
 	} while (--argc);
 
+#ifdef CONFIG_FEATURE_CLEAN_UP
 	RELEASE_CONFIG_BUFFER(resolved_path);
+#endif
 
-	return(EXIT_SUCCESS);
+	bb_fflush_stdout_and_exit(retval);
 }
diff --git a/coreutils/rm.c b/coreutils/rm.c
index 51c9f4ceb..5489350e5 100644
--- a/coreutils/rm.c
+++ b/coreutils/rm.c
@@ -2,7 +2,6 @@
 /*
  * Mini rm implementation for busybox
  *
- *
  * Copyright (C) 2001 Matt Kraai <kraai@alumni.carnegiemellon.edu>
  *
  *
@@ -22,55 +21,51 @@
  *
  */
 
-#include <stdio.h>
-#include <time.h>
-#include <utime.h>
-#include <dirent.h>
-#include <errno.h>
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/rm.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Size reduction.
+ */
+
 #include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <getopt.h>
 #include "busybox.h"
 
 extern int rm_main(int argc, char **argv)
 {
 	int status = 0;
-	int opt;
 	int flags = 0;
-	int i;
+	int opt;
 
-	while ((opt = getopt(argc, argv, "fiRr")) != -1) {
-		switch (opt) {
-		case 'f':
-			flags &= ~FILEUTILS_INTERACTIVE;
-			flags |= FILEUTILS_FORCE;
-			break;
-		case 'i':
-			flags &= ~FILEUTILS_FORCE;
-			flags |= FILEUTILS_INTERACTIVE;
-			break;
-		case 'R':
-		case 'r':
+	while ((opt = getopt(argc, argv, "fiRr")) > 0) {
+		if ((opt == 'r') || (opt == 'R')) {
 			flags |= FILEUTILS_RECUR;
-			break;
+		} else {
+			flags &= ~(FILEUTILS_INTERACTIVE | FILEUTILS_FORCE);
+			if (opt == 'i') {
+				flags |= FILEUTILS_INTERACTIVE;
+			} else if (opt == 'f') {
+				flags |= FILEUTILS_FORCE;
+			} else {
+				bb_show_usage();
+			}
 		}
 	}
 
-	if (!(flags & FILEUTILS_FORCE) && optind == argc)
-		show_usage();
-
-	for (i = optind; i < argc; i++) {
-		char *base = get_last_path_component(argv[i]);
-
-		if (strcmp(base, ".") == 0 || strcmp(base, "..") == 0) {
-			error_msg("cannot remove `.' or `..'");
-			status = 1;
-			continue;
-		}
+	if (*(argv += optind) != NULL) {
+		do {
+			const char *base = bb_get_last_path_component(*argv);
 
-		if (remove_file(argv[i], flags) < 0)
+			if ((base[0] == '.') && (!base[1] || ((base[1] == '.') && !base[2]))) {
+				bb_error_msg("cannot remove `.' or `..'");
+			} else if (remove_file(*argv, flags) >= 0) {
+				continue;
+			}
 			status = 1;
+		} while (*++argv);
+	} else if (!(flags & FILEUTILS_FORCE)) {
+		bb_show_usage();
 	}
 
 	return status;
diff --git a/coreutils/rmdir.c b/coreutils/rmdir.c
index 83b27c9bd..3f6037170 100644
--- a/coreutils/rmdir.c
+++ b/coreutils/rmdir.c
@@ -1,9 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini rmdir implementation for busybox
+ * rmdir implementation for busybox
  *
- * Copyright (C) 1999,2000 by Lineo, inc. and Erik Andersen
- * Copyright (C) 1999,2000,2001 by Erik Andersen <andersee@debian.org>
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,76 +20,54 @@
  *
  */
 
-#include <getopt.h>
-#include <unistd.h>
-#include <stdlib.h>
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/rmdir.html */
 
+#include <stdlib.h>
+#include <unistd.h>
+#include <libgen.h>
 #include "busybox.h"
 
-
-/* Return true if a path is composed of multiple components.  */
-
-static int
-multiple_components_p (const char *path)
-{
-	const char *s = path;
-
-	while (s[0] != '\0' && s[0] != '/')
-		s++;
-
-	while (s[0] == '/')
-		s++;
-
-	return (s[0] != '\0');
-}
-
-
-/* Remove a directory.  Returns 0 if successful, -1 on error.  */
-
-static int
-remove_directory (char *path, int flags)
-{
-	if (!(flags & FILEUTILS_RECUR)) {
-		if (rmdir (path) < 0) {
-			perror_msg ("unable to remove `%s'", path);
-			return -1;
-		}
-	} else {
-		if (remove_directory (path, 0) < 0)
-			return -1;
-
-		if (multiple_components_p (path))
-			if (remove_directory (dirname (path), flags) < 0)
-				return -1;
-	}
-
-	return 0;
-}
-
-
-extern int
-rmdir_main (int argc, char **argv)
+extern int rmdir_main(int argc, char **argv)
 {
 	int status = EXIT_SUCCESS;
-	int flags = 0;
-	int i, opt;
+	int flags;
+	int do_dot;
+	char *path;
 
-	while ((opt = getopt (argc, argv, "p")) != -1)
-		switch (opt) {
-			case 'p':
-				flags |= FILEUTILS_RECUR;
-				break;
+	flags = bb_getopt_ulflags(argc, argv, "p");
 
-			default:
-				show_usage ();
-		}
+	argv += optind;
 
-	if (optind == argc)
-		show_usage();
+	if (!*argv) {
+		bb_show_usage();
+	}
 
-	for (i = optind; i < argc; i++)
-		if (remove_directory (argv[i], flags) < 0)
-			status = EXIT_FAILURE;
+	do {
+		path = *argv;
+
+		/* Record if the first char was a '.' so we can use dirname later. */
+		do_dot = (*path == '.');
+
+		do {
+			if (rmdir(path) < 0) {
+				bb_perror_msg("`%s'", path);	/* Match gnu rmdir msg. */
+				status = EXIT_FAILURE;
+			} else if (flags) {
+				/* Note: path was not empty or null since rmdir succeeded. */
+				path = dirname(path);
+				/* Path is now just the parent component.  Note that dirname
+				 * returns "." if there are no parents.  We must distinguish
+				 * this from the case of the original path starting with '.'.
+                 */
+				if (do_dot || (*path != '.') || path[1]) {
+					continue;
+				}
+			}
+			break;
+		} while (1);
+		
+	} while (*++argv);
 
 	return status;
 }
diff --git a/coreutils/sha1sum.c b/coreutils/sha1sum.c
index 03009f76f..d94cb4b53 100644
--- a/coreutils/sha1sum.c
+++ b/coreutils/sha1sum.c
@@ -187,7 +187,7 @@ extern int authenticate(const int argc, char **argv, void (*hash_ptr)(FILE *stre
 			break;
 #endif
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
@@ -204,7 +204,7 @@ extern int authenticate(const int argc, char **argv, void (*hash_ptr)(FILE *stre
 				hash_ptr(stdin, hashval);
 				print_hash(hash_length, hashval, NULL);
 			} else {
-				FILE *stream = xfopen(argv[i], "r");
+				FILE *stream = bb_xfopen(argv[i], "r");
 				hash_ptr(stream, hashval);
 				fclose(stream);
 				print_hash(hash_length, hashval, argv[i]);
diff --git a/coreutils/sleep.c b/coreutils/sleep.c
index 7bc98d8e8..506192dd3 100644
--- a/coreutils/sleep.c
+++ b/coreutils/sleep.c
@@ -1,8 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini sleep implementation for busybox
+ * sleep implementation for busybox
  *
- * Copyright (C) 1995, 1996 by Bruce Perens <bruce@pixar.com>.
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,18 +20,67 @@
  *
  */
 
-#include <stdio.h>
-#include <unistd.h>
+/* BB_AUDIT SUSv3 compliant */
+/* BB_AUDIT GNU issues -- fancy version matches except args must be ints. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/sleep.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Rewritten to do proper arg and error checking.
+ * Also, added a 'fancy' configuration to accept multiple args with
+ * time suffixes for seconds, minutes, hours, and days.
+ */
+
 #include <stdlib.h>
+#include <limits.h>
+#include <unistd.h>
 #include "busybox.h"
 
+#ifdef CONFIG_FEATURE_FANCY_SLEEP
+static const struct suffix_mult sleep_suffixes[] = {
+	{ "s", 1 },
+	{ "m", 60 },
+	{ "h", 60*60 },
+	{ "d", 24*60*60 },
+	{ NULL, 0 }
+};
+#endif
+
 extern int sleep_main(int argc, char **argv)
 {
-	if ((argc < 2) || (**(argv + 1) == '-')) {
-		show_usage();
+	unsigned int duration;
+
+#ifdef CONFIG_FEATURE_FANCY_SLEEP
+
+	if (argc < 2) {
+		bb_show_usage();
+	}
+
+	++argv;
+	duration = 0;
+	do {
+		duration += bb_xgetularg_bnd_sfx(*argv, 10,
+										 0, UINT_MAX-duration,
+										 sleep_suffixes);
+	} while (*++argv);
+
+#else  /* CONFIG_FEATURE_FANCY_SLEEP */
+
+	if (argc != 2) {
+		bb_show_usage();
+	}
+
+#if UINT_MAX == ULONG_MAX
+	duration = bb_xgetularg10(argv[1]);
+#else
+	duration = bb_xgetularg10_bnd(argv[1], 0, UINT_MAX);
+#endif
+
+#endif /* CONFIG_FEATURE_FANCY_SLEEP */
+
+	if (sleep(duration)) {
+		bb_perror_nomsg_and_die();
 	}
 
-	if (sleep(atoi(*(++argv))) != 0)
-		perror_msg_and_die("sleep");
 	return EXIT_SUCCESS;
 }
diff --git a/coreutils/sort.c b/coreutils/sort.c
index fc12dfb01..8cc4d8886 100644
--- a/coreutils/sort.c
+++ b/coreutils/sort.c
@@ -2,7 +2,6 @@
 /*
  * Mini sort implementation for busybox
  *
- *
  * Copyright (C) 2000 by Matt Kraai <kraai@alumni.carnegiemellon.edu>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -21,10 +20,20 @@
  *
  */
 
-#include <getopt.h>
-#include <string.h>
+/* BB_AUDIT SUSv3 _NOT_ compliant -- a number of options are not supported. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/sort.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Now does proper error checking on i/o.  Plus some space savings.
+ */
+
+#include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
 #include "busybox.h"
+#include "libcoreutils/coreutils.h"
 
 static int compare_ascii(const void *x, const void *y)
 {
@@ -41,66 +50,51 @@ int sort_main(int argc, char **argv)
 {
 	FILE *fp;
 	char *line, **lines = NULL;
-	int i, opt, nlines = 0;
+	int i, nlines = 0, inc;
 	int (*compare)(const void *, const void *) = compare_ascii;
-#ifdef CONFIG_FEATURE_SORT_REVERSE
-	int reverse = FALSE;
-#endif
-#ifdef CONFIG_FEATURE_SORT_UNIQUE
-	int unique = FALSE;
-#endif
 
-	while ((opt = getopt(argc, argv, "nru")) != -1) {
-		switch (opt) {
-			case 'n':
-				compare = compare_numeric;
-				break;
-#ifdef CONFIG_FEATURE_SORT_REVERSE
-			case 'r':
-				reverse = TRUE;
-				break;
-#endif
-#ifdef CONFIG_FEATURE_SORT_UNIQUE
-			case 'u':
-				unique = TRUE;
-				break;
-#endif
-			default:
-				show_usage();
-		}
+	int flags;
+
+	bb_default_error_retval = 2;
+
+	flags = bb_getopt_ulflags(argc, argv, "nru");
+	if (flags & 1) {
+		compare = compare_numeric;
 	}
 
-	/* read the input */
-	for (i = optind; i == optind || i < argc; i++) {
-		if (argv[i] == NULL)
-			fp = stdin;
-		else
-			fp = xfopen(argv[i], "r");
+	argv += optind;
+	if (!*argv) {
+		*--argv = "-";
+	}
 
-		while ((line = get_line_from_file(fp)) != NULL) {
+	do {
+		fp = xgetoptfile_sort_uniq(argv, "r");
+		while ((line = bb_get_chomped_line_from_file(fp)) != NULL) {
 			lines = xrealloc(lines, sizeof(char *) * (nlines + 1));
-			chomp(line);
 			lines[nlines++] = line;
 		}
-	}
+		bb_xferror(fp, *argv);
+		bb_fclose_nonstdin(fp);
+	} while (*++argv);
 
 	/* sort it */
 	qsort(lines, nlines, sizeof(char *), compare);
 
 	/* print it */
-#ifdef CONFIG_FEATURE_SORT_REVERSE
-	if (reverse) {
-		for (i = --nlines; 0 <= i; i--)
-#ifdef CONFIG_FEATURE_SORT_UNIQUE
-			if((!unique) || (i == nlines) || (strcmp(lines[i + 1], lines[i])))
-#endif
-				puts(lines[i]);
-	} else
-#endif
-		for (i = 0; i < nlines; i++)
-#ifdef CONFIG_FEATURE_SORT_UNIQUE
-			if((!unique) || (!i) || (strcmp(lines[i - 1], lines[i])))
-#endif
-				puts(lines[i]);
-	return EXIT_SUCCESS;
+	i = 0;
+	--nlines;
+	if ((inc = 1 - (flags & 2)) < 0) {	/* reverse */
+		i = nlines;
+	}
+	flags &= 4;
+
+	while (nlines >= 0) {
+		if (!flags || !nlines || strcmp(lines[i+inc], lines[i])) {
+			puts(lines[i]);
+		}
+		i += inc;
+		--nlines;
+	}
+
+	bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 }
diff --git a/coreutils/stty.c b/coreutils/stty.c
index a67a17c0f..a3a98d9ef 100644
--- a/coreutils/stty.c
+++ b/coreutils/stty.c
@@ -30,9 +30,9 @@
 
 //#define TEST
 
+#include <stddef.h>
 #include <termios.h>
 #include <sys/ioctl.h>
-#include <getopt.h>
 
 #include <sys/param.h>
 #include <unistd.h>
@@ -155,13 +155,10 @@ enum speed_setting {
 	input_speed, output_speed, both_speeds
 };
 
-/* What to output and how.  */
-enum output_type {
-	changed, all, recoverable       /* Default, -a, -g.  */
-};
-
 /* Which member(s) of `struct termios' a mode uses.  */
 enum mode_type {
+	/* Do NOT change the order or values, as mode_type_flag()
+	 * depends on them. */
 	control, input, output, local, combination
 };
 
@@ -199,156 +196,159 @@ static const char stty_dec  [] = "dec";
 /* Each mode.  */
 struct mode_info {
 	const char *name;       /* Name given on command line.           */
-	enum mode_type type;    /* Which structure element to change.    */
+	/* enum mode_type type; */
+	char type;              /* Which structure element to change.    */
 	char flags;             /* Setting and display options.          */
+	unsigned short mask;     /* Other bits to turn off for this mode. */
 	unsigned long bits;     /* Bits to set for this mode.            */
-	unsigned long mask;     /* Other bits to turn off for this mode. */
 };
 
+#define MI_ENTRY(N,T,F,B,M) { N, T, F, M, B }
+
 static const struct  mode_info mode_info[] = {
-	{"parenb",   control,     REV,               PARENB,     0 },
-	{"parodd",   control,     REV,               PARODD,     0 },
-	{"cs5",      control,     0,                 CS5,     CSIZE},
-	{"cs6",      control,     0,                 CS6,     CSIZE},
-	{"cs7",      control,     0,                 CS7,     CSIZE},
-	{"cs8",      control,     0,                 CS8,     CSIZE},
-	{"hupcl",    control,     REV,               HUPCL,      0 },
-	{"hup",      control,     REV        | OMIT, HUPCL,      0 },
-	{"cstopb",   control,     REV,               CSTOPB,     0 },
-	{"cread",    control,     SANE_SET   | REV,  CREAD,      0 },
-	{"clocal",   control,     REV,               CLOCAL,     0 },
+	MI_ENTRY("parenb",   control,     REV,               PARENB,     0 ),
+	MI_ENTRY("parodd",   control,     REV,               PARODD,     0 ),
+	MI_ENTRY("cs5",      control,     0,                 CS5,     CSIZE),
+	MI_ENTRY("cs6",      control,     0,                 CS6,     CSIZE),
+	MI_ENTRY("cs7",      control,     0,                 CS7,     CSIZE),
+	MI_ENTRY("cs8",      control,     0,                 CS8,     CSIZE),
+	MI_ENTRY("hupcl",    control,     REV,               HUPCL,      0 ),
+	MI_ENTRY("hup",      control,     REV        | OMIT, HUPCL,      0 ),
+	MI_ENTRY("cstopb",   control,     REV,               CSTOPB,     0 ),
+	MI_ENTRY("cread",    control,     SANE_SET   | REV,  CREAD,      0 ),
+	MI_ENTRY("clocal",   control,     REV,               CLOCAL,     0 ),
 #ifdef CRTSCTS
-	{"crtscts",  control,     REV,               CRTSCTS,    0 },
-#endif
-	{"ignbrk",   input,       SANE_UNSET | REV,  IGNBRK,     0 },
-	{"brkint",   input,       SANE_SET   | REV,  BRKINT,     0 },
-	{"ignpar",   input,       REV,               IGNPAR,     0 },
-	{"parmrk",   input,       REV,               PARMRK,     0 },
-	{"inpck",    input,       REV,               INPCK,      0 },
-	{"istrip",   input,       REV,               ISTRIP,     0 },
-	{"inlcr",    input,       SANE_UNSET | REV,  INLCR,      0 },
-	{"igncr",    input,       SANE_UNSET | REV,  IGNCR,      0 },
-	{"icrnl",    input,       SANE_SET   | REV,  ICRNL,      0 },
-	{"ixon",     input,       REV,               IXON,       0 },
-	{"ixoff",    input,       SANE_UNSET | REV,  IXOFF,      0 },
-	{"tandem",   input,       REV        | OMIT, IXOFF,      0 },
+	MI_ENTRY("crtscts",  control,     REV,               CRTSCTS,    0 ),
+#endif
+	MI_ENTRY("ignbrk",   input,       SANE_UNSET | REV,  IGNBRK,     0 ),
+	MI_ENTRY("brkint",   input,       SANE_SET   | REV,  BRKINT,     0 ),
+	MI_ENTRY("ignpar",   input,       REV,               IGNPAR,     0 ),
+	MI_ENTRY("parmrk",   input,       REV,               PARMRK,     0 ),
+	MI_ENTRY("inpck",    input,       REV,               INPCK,      0 ),
+	MI_ENTRY("istrip",   input,       REV,               ISTRIP,     0 ),
+	MI_ENTRY("inlcr",    input,       SANE_UNSET | REV,  INLCR,      0 ),
+	MI_ENTRY("igncr",    input,       SANE_UNSET | REV,  IGNCR,      0 ),
+	MI_ENTRY("icrnl",    input,       SANE_SET   | REV,  ICRNL,      0 ),
+	MI_ENTRY("ixon",     input,       REV,               IXON,       0 ),
+	MI_ENTRY("ixoff",    input,       SANE_UNSET | REV,  IXOFF,      0 ),
+	MI_ENTRY("tandem",   input,       REV        | OMIT, IXOFF,      0 ),
 #ifdef IUCLC
-	{"iuclc",    input,       SANE_UNSET | REV,  IUCLC,      0 },
+	MI_ENTRY("iuclc",    input,       SANE_UNSET | REV,  IUCLC,      0 ),
 #endif
 #ifdef IXANY
-	{"ixany",    input,       SANE_UNSET | REV,  IXANY,      0 },
+	MI_ENTRY("ixany",    input,       SANE_UNSET | REV,  IXANY,      0 ),
 #endif
 #ifdef IMAXBEL
-	{"imaxbel",  input,       SANE_SET   | REV,  IMAXBEL,    0 },
+	MI_ENTRY("imaxbel",  input,       SANE_SET   | REV,  IMAXBEL,    0 ),
 #endif
-	{"opost",    output,      SANE_SET   | REV,  OPOST,      0 },
+	MI_ENTRY("opost",    output,      SANE_SET   | REV,  OPOST,      0 ),
 #ifdef OLCUC
-	{"olcuc",    output,      SANE_UNSET | REV,  OLCUC,      0 },
+	MI_ENTRY("olcuc",    output,      SANE_UNSET | REV,  OLCUC,      0 ),
 #endif
 #ifdef OCRNL
-	{"ocrnl",    output,      SANE_UNSET | REV,  OCRNL,      0 },
+	MI_ENTRY("ocrnl",    output,      SANE_UNSET | REV,  OCRNL,      0 ),
 #endif
 #ifdef ONLCR
-	{"onlcr",    output,      SANE_SET   | REV,  ONLCR,      0 },
+	MI_ENTRY("onlcr",    output,      SANE_SET   | REV,  ONLCR,      0 ),
 #endif
 #ifdef ONOCR
-	{"onocr",    output,      SANE_UNSET | REV,  ONOCR,      0 },
+	MI_ENTRY("onocr",    output,      SANE_UNSET | REV,  ONOCR,      0 ),
 #endif
 #ifdef ONLRET
-	{"onlret",   output,      SANE_UNSET | REV,  ONLRET,     0 },
+	MI_ENTRY("onlret",   output,      SANE_UNSET | REV,  ONLRET,     0 ),
 #endif
 #ifdef OFILL
-	{"ofill",    output,      SANE_UNSET | REV,  OFILL,      0 },
+	MI_ENTRY("ofill",    output,      SANE_UNSET | REV,  OFILL,      0 ),
 #endif
 #ifdef OFDEL
-	{"ofdel",    output,      SANE_UNSET | REV,  OFDEL,      0 },
+	MI_ENTRY("ofdel",    output,      SANE_UNSET | REV,  OFDEL,      0 ),
 #endif
 #ifdef NLDLY
-	{"nl1",      output,      SANE_UNSET,        NL1,     NLDLY},
-	{"nl0",      output,      SANE_SET,          NL0,     NLDLY},
+	MI_ENTRY("nl1",      output,      SANE_UNSET,        NL1,     NLDLY),
+	MI_ENTRY("nl0",      output,      SANE_SET,          NL0,     NLDLY),
 #endif
 #ifdef CRDLY
-	{"cr3",      output,      SANE_UNSET,        CR3,     CRDLY},
-	{"cr2",      output,      SANE_UNSET,        CR2,     CRDLY},
-	{"cr1",      output,      SANE_UNSET,        CR1,     CRDLY},
-	{"cr0",      output,      SANE_SET,          CR0,     CRDLY},
+	MI_ENTRY("cr3",      output,      SANE_UNSET,        CR3,     CRDLY),
+	MI_ENTRY("cr2",      output,      SANE_UNSET,        CR2,     CRDLY),
+	MI_ENTRY("cr1",      output,      SANE_UNSET,        CR1,     CRDLY),
+	MI_ENTRY("cr0",      output,      SANE_SET,          CR0,     CRDLY),
 #endif
 
 #ifdef TABDLY
-	{"tab3",     output,      SANE_UNSET,        TAB3,   TABDLY},
-	{"tab2",     output,      SANE_UNSET,        TAB2,   TABDLY},
-	{"tab1",     output,      SANE_UNSET,        TAB1,   TABDLY},
-	{"tab0",     output,      SANE_SET,          TAB0,   TABDLY},
+	MI_ENTRY("tab3",     output,      SANE_UNSET,        TAB3,   TABDLY),
+	MI_ENTRY("tab2",     output,      SANE_UNSET,        TAB2,   TABDLY),
+	MI_ENTRY("tab1",     output,      SANE_UNSET,        TAB1,   TABDLY),
+	MI_ENTRY("tab0",     output,      SANE_SET,          TAB0,   TABDLY),
 #else
 # ifdef OXTABS
-	{"tab3",     output,      SANE_UNSET,        OXTABS,     0 },
+	MI_ENTRY("tab3",     output,      SANE_UNSET,        OXTABS,     0 ),
 # endif
 #endif
 
 #ifdef BSDLY
-	{"bs1",      output,      SANE_UNSET,        BS1,     BSDLY},
-	{"bs0",      output,      SANE_SET,          BS0,     BSDLY},
+	MI_ENTRY("bs1",      output,      SANE_UNSET,        BS1,     BSDLY),
+	MI_ENTRY("bs0",      output,      SANE_SET,          BS0,     BSDLY),
 #endif
 #ifdef VTDLY
-	{"vt1",      output,      SANE_UNSET,        VT1,     VTDLY},
-	{"vt0",      output,      SANE_SET,          VT0,     VTDLY},
+	MI_ENTRY("vt1",      output,      SANE_UNSET,        VT1,     VTDLY),
+	MI_ENTRY("vt0",      output,      SANE_SET,          VT0,     VTDLY),
 #endif
 #ifdef FFDLY
-	{"ff1",      output,      SANE_UNSET,        FF1,     FFDLY},
-	{"ff0",      output,      SANE_SET,          FF0,     FFDLY},
+	MI_ENTRY("ff1",      output,      SANE_UNSET,        FF1,     FFDLY),
+	MI_ENTRY("ff0",      output,      SANE_SET,          FF0,     FFDLY),
 #endif
-	{"isig",     local,       SANE_SET   | REV,  ISIG,       0 },
-	{"icanon",   local,       SANE_SET   | REV,  ICANON,     0 },
+	MI_ENTRY("isig",     local,       SANE_SET   | REV,  ISIG,       0 ),
+	MI_ENTRY("icanon",   local,       SANE_SET   | REV,  ICANON,     0 ),
 #ifdef IEXTEN
-	{"iexten",   local,       SANE_SET   | REV,  IEXTEN,     0 },
-#endif
-	{"echo",     local,       SANE_SET   | REV,  ECHO,       0 },
-	{"echoe",    local,       SANE_SET   | REV,  ECHOE,      0 },
-	{"crterase", local,       REV        | OMIT, ECHOE,      0 },
-	{"echok",    local,       SANE_SET   | REV,  ECHOK,      0 },
-	{"echonl",   local,       SANE_UNSET | REV,  ECHONL,     0 },
-	{"noflsh",   local,       SANE_UNSET | REV,  NOFLSH,     0 },
+	MI_ENTRY("iexten",   local,       SANE_SET   | REV,  IEXTEN,     0 ),
+#endif
+	MI_ENTRY("echo",     local,       SANE_SET   | REV,  ECHO,       0 ),
+	MI_ENTRY("echoe",    local,       SANE_SET   | REV,  ECHOE,      0 ),
+	MI_ENTRY("crterase", local,       REV        | OMIT, ECHOE,      0 ),
+	MI_ENTRY("echok",    local,       SANE_SET   | REV,  ECHOK,      0 ),
+	MI_ENTRY("echonl",   local,       SANE_UNSET | REV,  ECHONL,     0 ),
+	MI_ENTRY("noflsh",   local,       SANE_UNSET | REV,  NOFLSH,     0 ),
 #ifdef XCASE
-	{"xcase",    local,       SANE_UNSET | REV,  XCASE,      0 },
+	MI_ENTRY("xcase",    local,       SANE_UNSET | REV,  XCASE,      0 ),
 #endif
 #ifdef TOSTOP
-	{"tostop",   local,       SANE_UNSET | REV,  TOSTOP,     0 },
+	MI_ENTRY("tostop",   local,       SANE_UNSET | REV,  TOSTOP,     0 ),
 #endif
 #ifdef ECHOPRT
-	{"echoprt",  local,       SANE_UNSET | REV,  ECHOPRT,    0 },
-	{"prterase", local,       REV | OMIT,        ECHOPRT,    0 },
+	MI_ENTRY("echoprt",  local,       SANE_UNSET | REV,  ECHOPRT,    0 ),
+	MI_ENTRY("prterase", local,       REV | OMIT,        ECHOPRT,    0 ),
 #endif
 #ifdef ECHOCTL
-	{"echoctl",  local,       SANE_SET   | REV,  ECHOCTL,    0 },
-	{"ctlecho",  local,       REV        | OMIT, ECHOCTL,    0 },
+	MI_ENTRY("echoctl",  local,       SANE_SET   | REV,  ECHOCTL,    0 ),
+	MI_ENTRY("ctlecho",  local,       REV        | OMIT, ECHOCTL,    0 ),
 #endif
 #ifdef ECHOKE
-	{"echoke",   local,       SANE_SET   | REV,  ECHOKE,     0 },
-	{"crtkill",  local,       REV        | OMIT, ECHOKE,     0 },
-#endif
-	{evenp,      combination, REV        | OMIT, 0,          0 },
-	{parity,     combination, REV        | OMIT, 0,          0 },
-	{stty_oddp,  combination, REV        | OMIT, 0,          0 },
-	{stty_nl,    combination, REV        | OMIT, 0,          0 },
-	{stty_ek,    combination, OMIT,              0,          0 },
-	{stty_sane,  combination, OMIT,              0,          0 },
-	{cooked,     combination, REV        | OMIT, 0,          0 },
-	{raw,        combination, REV        | OMIT, 0,          0 },
-	{stty_pass8, combination, REV        | OMIT, 0,          0 },
-	{litout,     combination, REV        | OMIT, 0,          0 },
-	{cbreak,     combination, REV        | OMIT, 0,          0 },
+	MI_ENTRY("echoke",   local,       SANE_SET   | REV,  ECHOKE,     0 ),
+	MI_ENTRY("crtkill",  local,       REV        | OMIT, ECHOKE,     0 ),
+#endif
+	MI_ENTRY(evenp,      combination, REV        | OMIT, 0,          0 ),
+	MI_ENTRY(parity,     combination, REV        | OMIT, 0,          0 ),
+	MI_ENTRY(stty_oddp,  combination, REV        | OMIT, 0,          0 ),
+	MI_ENTRY(stty_nl,    combination, REV        | OMIT, 0,          0 ),
+	MI_ENTRY(stty_ek,    combination, OMIT,              0,          0 ),
+	MI_ENTRY(stty_sane,  combination, OMIT,              0,          0 ),
+	MI_ENTRY(cooked,     combination, REV        | OMIT, 0,          0 ),
+	MI_ENTRY(raw,        combination, REV        | OMIT, 0,          0 ),
+	MI_ENTRY(stty_pass8, combination, REV        | OMIT, 0,          0 ),
+	MI_ENTRY(litout,     combination, REV        | OMIT, 0,          0 ),
+	MI_ENTRY(cbreak,     combination, REV        | OMIT, 0,          0 ),
 #ifdef IXANY
-	{decctlq,    combination, REV        | OMIT, 0,          0 },
+	MI_ENTRY(decctlq,    combination, REV        | OMIT, 0,          0 ),
 #endif
 #if defined (TABDLY) || defined (OXTABS)
-	{stty_tabs,  combination, REV        | OMIT, 0,          0 },
+	MI_ENTRY(stty_tabs,  combination, REV        | OMIT, 0,          0 ),
 #endif
 #if defined(XCASE) && defined(IUCLC) && defined(OLCUC)
-	{stty_lcase, combination, REV        | OMIT, 0,          0 },
-	{stty_LCASE, combination, REV        | OMIT, 0,          0 },
+	MI_ENTRY(stty_lcase, combination, REV        | OMIT, 0,          0 ),
+	MI_ENTRY(stty_LCASE, combination, REV        | OMIT, 0,          0 ),
 #endif
-	{stty_crt,   combination, OMIT,              0,          0 },
-	{stty_dec,   combination, OMIT,              0,          0 },
+	MI_ENTRY(stty_crt,   combination, OMIT,              0,          0 ),
+	MI_ENTRY(stty_dec,   combination, OMIT,              0,          0 ),
 };
 
 static const int NUM_mode_info =
@@ -359,7 +359,7 @@ static const int NUM_mode_info =
 struct control_info {
 	const char *name;                       /* Name given on command line.  */
 	unsigned char saneval;          /* Value to set for `stty sane'.  */
-	int offset;                                     /* Offset in c_cc.  */
+	unsigned char offset;                           /* Offset in c_cc.  */
 };
 
 /* Control characters. */
@@ -408,7 +408,6 @@ static const int NUM_control_info =
 
 
 static const char *  visible(unsigned int ch);
-static unsigned long baud_to_value(speed_t speed);
 static int           recover_mode(char *arg, struct termios *mode);
 static int           screen_columns(void);
 static int           set_mode(const struct mode_info *info,
@@ -416,12 +415,11 @@ static int           set_mode(const struct mode_info *info,
 static speed_t       string_to_baud(const char *arg);
 static tcflag_t*     mode_type_flag(enum mode_type type, struct termios *mode);
 static void          display_all(struct termios *mode, int fd,
-					const char *device_name);
-static void          display_changed(struct termios *mode);
-static void          display_recoverable(struct termios *mode);
-static void          display_settings(enum output_type output_type,
-					struct termios *mode, int fd,
-					const char *device_name);
+								 const char *device_name);
+static void          display_changed(struct termios *mode, int fd,
+									 const char *device_name);
+static void          display_recoverable(struct termios *mode, int fd,
+										 const char *device_name);
 static void          display_speed(struct termios *mode, int fancy);
 static void          display_window_size(int fancy, int fd,
 					const char *device_name);
@@ -479,7 +477,7 @@ extern int main(int argc, char **argv)
 #endif
 {
 	struct termios mode;
-	enum   output_type output_type;
+	void (*output_func)(struct termios *, int, const char *);
 	int    optc;
 	int    require_set_attr;
 	int    speed_was_set;
@@ -491,7 +489,7 @@ extern int main(int argc, char **argv)
 	int    fd;
 	const char *device_name;
 
-	output_type = changed;
+	output_func = display_changed;
 	verbose_output = 0;
 	recoverable_output = 0;
 
@@ -502,17 +500,17 @@ extern int main(int argc, char **argv)
 		switch (optc) {
 		case 'a':
 			verbose_output = 1;
-			output_type = all;
+			output_func = display_all;
 			break;
 
 		case 'g':
 			recoverable_output = 1;
-			output_type = recoverable;
+			output_func = display_recoverable;
 			break;
 
 		case 'F':
 			if (file_name)
-				error_msg_and_die("only one device may be specified");
+				bb_error_msg_and_die("only one device may be specified");
 			file_name = optarg;
 			break;
 
@@ -529,12 +527,12 @@ extern int main(int argc, char **argv)
 		noargs = 0;
 
 	/* Specifying both -a and -g gets an error.  */
-	if (verbose_output && recoverable_output)
-		error_msg_and_die ("verbose and stty-readable output styles are mutually exclusive");
+	if (verbose_output & recoverable_output)
+		bb_error_msg_and_die ("verbose and stty-readable output styles are mutually exclusive");
 
 	/* Specifying any other arguments with -a or -g gets an error.  */
-	if (!noargs && (verbose_output || recoverable_output))
-		error_msg_and_die ("modes may not be set when specifying an output style");
+	if (~noargs & (verbose_output | recoverable_output))
+		bb_error_msg_and_die ("modes may not be set when specifying an output style");
 
 	/* FIXME: it'd be better not to open the file until we've verified
 	   that all arguments are valid.  Otherwise, we could end up doing
@@ -547,26 +545,26 @@ extern int main(int argc, char **argv)
 		device_name = file_name;
 		fd = open(device_name, O_RDONLY | O_NONBLOCK);
 		if (fd < 0)
-			perror_msg_and_die("%s", device_name);
+			bb_perror_msg_and_die("%s", device_name);
 		if ((fdflags = fcntl(fd, F_GETFL)) == -1
 			|| fcntl(fd, F_SETFL, fdflags & ~O_NONBLOCK) < 0)
-			perror_msg_and_die("%s: couldn't reset non-blocking mode",
+			bb_perror_msg_and_die("%s: couldn't reset non-blocking mode",
 							   device_name);
 	} else {
 		fd = 0;
-		device_name = "standard input";
+		device_name = bb_msg_standard_input;
 	}
 
 	/* Initialize to all zeroes so there is no risk memcmp will report a
 	   spurious difference in an uninitialized portion of the structure.  */
 	memset(&mode, 0, sizeof(mode));
 	if (tcgetattr(fd, &mode))
-		perror_msg_and_die("%s", device_name);
+		bb_perror_msg_and_die("%s", device_name);
 
-	if (verbose_output || recoverable_output || noargs) {
+	if (verbose_output | recoverable_output | noargs) {
 		max_col = screen_columns();
 		current_col = 0;
-		display_settings(output_type, &mode, fd, device_name);
+		output_func(&mode, fd, device_name);
 		return EXIT_SUCCESS;
 	}
 
@@ -610,13 +608,13 @@ extern int main(int argc, char **argv)
 			}
 
 		if (match_found == 0 && reversed)
-			error_msg_and_die("invalid argument `%s'", --argv[k]);
+			bb_error_msg_and_die("invalid argument `%s'", --argv[k]);
 
 		if (match_found == 0)
 			for (i = 0; i < NUM_control_info; ++i)
 				if (STREQ(argv[k], control_info[i].name)) {
 					if (k == argc - 1)
-					    error_msg_and_die("missing argument to `%s'", argv[k]);
+					    bb_error_msg_and_die("missing argument to `%s'", argv[k]);
 					match_found = 1;
 					++k;
 					set_control_char(&control_info[i], argv[k], &mode);
@@ -627,14 +625,14 @@ extern int main(int argc, char **argv)
 		if (match_found == 0) {
 			if (STREQ(argv[k], "ispeed")) {
 				if (k == argc - 1)
-				    error_msg_and_die("missing argument to `%s'", argv[k]);
+				    bb_error_msg_and_die("missing argument to `%s'", argv[k]);
 				++k;
 				set_speed(input_speed, argv[k], &mode);
 				speed_was_set = 1;
 				require_set_attr = 1;
 			} else if (STREQ(argv[k], "ospeed")) {
 				if (k == argc - 1)
-				    error_msg_and_die("missing argument to `%s'", argv[k]);
+				    bb_error_msg_and_die("missing argument to `%s'", argv[k]);
 				++k;
 				set_speed(output_speed, argv[k], &mode);
 				speed_was_set = 1;
@@ -643,16 +641,16 @@ extern int main(int argc, char **argv)
 #ifdef TIOCGWINSZ
 			else if (STREQ(argv[k], "rows")) {
 				if (k == argc - 1)
-				    error_msg_and_die("missing argument to `%s'", argv[k]);
+				    bb_error_msg_and_die("missing argument to `%s'", argv[k]);
 				++k;
-				set_window_size((int) parse_number(argv[k], stty_suffixes),
+				set_window_size((int) bb_xparse_number(argv[k], stty_suffixes),
 								-1, fd, device_name);
 			} else if (STREQ(argv[k], "cols") || STREQ(argv[k], "columns")) {
 				if (k == argc - 1)
-				    error_msg_and_die("missing argument to `%s'", argv[k]);
+				    bb_error_msg_and_die("missing argument to `%s'", argv[k]);
 				++k;
 				set_window_size(-1,
-						(int) parse_number(argv[k], stty_suffixes),
+						(int) bb_xparse_number(argv[k], stty_suffixes),
 						fd, device_name);
 			} else if (STREQ(argv[k], "size")) {
 				max_col = screen_columns();
@@ -663,9 +661,9 @@ extern int main(int argc, char **argv)
 #ifdef HAVE_C_LINE
 			else if (STREQ(argv[k], "line")) {
 				if (k == argc - 1)
-					error_msg_and_die("missing argument to `%s'", argv[k]);
+					bb_error_msg_and_die("missing argument to `%s'", argv[k]);
 				++k;
-				mode.c_line = parse_number(argv[k], stty_suffixes);
+				mode.c_line = bb_xparse_number(argv[k], stty_suffixes);
 				require_set_attr = 1;
 			}
 #endif
@@ -679,7 +677,7 @@ extern int main(int argc, char **argv)
 				speed_was_set = 1;
 				require_set_attr = 1;
 			} else
-				error_msg_and_die("invalid argument `%s'", argv[k]);
+				bb_error_msg_and_die("invalid argument `%s'", argv[k]);
 		}
 	}
 
@@ -687,7 +685,7 @@ extern int main(int argc, char **argv)
 		struct termios new_mode;
 
 		if (tcsetattr(fd, TCSADRAIN, &mode))
-			perror_msg_and_die("%s", device_name);
+			bb_perror_msg_and_die("%s", device_name);
 
 		/* POSIX (according to Zlotnick's book) tcsetattr returns zero if
 		   it performs *any* of the requested operations.  This means it
@@ -700,7 +698,7 @@ extern int main(int argc, char **argv)
 		   spurious difference in an uninitialized portion of the structure.  */
 		memset(&new_mode, 0, sizeof(new_mode));
 		if (tcgetattr(fd, &new_mode))
-			perror_msg_and_die("%s", device_name);
+			bb_perror_msg_and_die("%s", device_name);
 
 		/* Normally, one shouldn't use memcmp to compare structures that
 		   may have `holes' containing uninitialized data, but we have been
@@ -723,7 +721,7 @@ extern int main(int argc, char **argv)
 			new_mode.c_cflag &= (~CIBAUD);
 			if (speed_was_set || memcmp(&mode, &new_mode, sizeof(mode)) != 0)
 #endif
-				error_msg_and_die ("%s: unable to perform all requested operations",
+				bb_error_msg_and_die ("%s: unable to perform all requested operations",
 					 device_name);
 		}
 	}
@@ -896,9 +894,9 @@ set_mode(const struct mode_info *info, int reversed, struct termios *mode)
 #endif
 		}
 	} else if (reversed)
-		*bitsp = *bitsp & ~info->mask & ~info->bits;
+		*bitsp = *bitsp & ~((unsigned long)info->mask) & ~info->bits;
 	else
-		*bitsp = (*bitsp & ~info->mask) | info->bits;
+		*bitsp = (*bitsp & ~((unsigned long)info->mask)) | info->bits;
 
 	return 1;
 }
@@ -910,7 +908,7 @@ set_control_char(const struct control_info *info, const char *arg,
 	unsigned char value;
 
 	if (info->name == stty_min || info->name == stty_time)
-		value = parse_number(arg, stty_suffixes);
+		value = bb_xparse_number(arg, stty_suffixes);
 	else if (arg[0] == '\0' || arg[1] == '\0')
 		value = arg[0];
 	else if (STREQ(arg, "^-") || STREQ(arg, "undef"))
@@ -921,7 +919,7 @@ set_control_char(const struct control_info *info, const char *arg,
 		else
 			value = arg[1] & ~0140; /* Non-letters get weird results. */
 	} else
-		value = parse_number(arg, stty_suffixes);
+		value = bb_xparse_number(arg, stty_suffixes);
 	mode->c_cc[info->offset] = value;
 }
 
@@ -931,10 +929,13 @@ set_speed(enum speed_setting type, const char *arg, struct termios *mode)
 	speed_t baud;
 
 	baud = string_to_baud(arg);
-	if (type == input_speed || type == both_speeds)
+
+	if (type != output_speed) {	/* either input or both */
 		cfsetispeed(mode, baud);
-	if (type == output_speed || type == both_speeds)
+	}
+	if (type != input_speed) {	/* either output or both */
 		cfsetospeed(mode, baud);
+	}
 }
 
 #ifdef TIOCGWINSZ
@@ -953,7 +954,7 @@ set_window_size(int rows, int cols, int fd, const char *device_name)
 
 	if (get_win_size(fd, &win)) {
 		if (errno != EINVAL)
-			perror_msg_and_die("%s", device_name);
+			bb_perror_msg_and_die("%s", device_name);
 		memset(&win, 0, sizeof(win));
 	}
 
@@ -975,32 +976,28 @@ set_window_size(int rows, int cols, int fd, const char *device_name)
 		ttysz.ts_lines = win.ws_row;
 		ttysz.ts_cols = win.ws_col;
 
-		win.ws_row = 1;
-		win.ws_col = 1;
-
-		if (ioctl(fd, TIOCSWINSZ, (char *) &win))
-			perror_msg_and_die("%s", device_name);
+		win.ws_row = win.ws_col = 1;
 
-		if (ioctl(fd, TIOCSSIZE, (char *) &ttysz))
-			perror_msg_and_die("%s", device_name);
+		if ((ioctl(fd, TIOCSWINSZ, (char *) &win) != 0)
+			|| (ioctl(fd, TIOCSSIZE, (char *) &ttysz) != 0)) {
+			bb_perror_msg_and_die("%s", device_name);
 		return;
 	}
 # endif
 
 	if (ioctl(fd, TIOCSWINSZ, (char *) &win))
-		perror_msg_and_die("%s", device_name);
+		bb_perror_msg_and_die("%s", device_name);
 }
 
 static void display_window_size(int fancy, int fd, const char *device_name)
 {
+	const char *fmt_str = "%s" "\0" "%s: no size information for this device";
 	struct winsize win;
 
 	if (get_win_size(fd, &win)) {
-		if (errno != EINVAL)
-			perror_msg_and_die("%s", device_name);
-		if (!fancy)
-			perror_msg_and_die("%s: no size information for this device",
-							   device_name);
+		if ((errno != EINVAL) || ((fmt_str += 2), !fancy)) {
+			bb_perror_msg_and_die(fmt_str, device_name);
+		}
 	} else {
 		wrapf(fancy ? "rows %d; columns %d;" : "%d %d\n",
 			  win.ws_row, win.ws_col);
@@ -1012,6 +1009,9 @@ static void display_window_size(int fancy, int fd, const char *device_name)
 
 static int screen_columns(void)
 {
+	int columns;
+	const char *s;
+
 #ifdef TIOCGWINSZ
 	struct winsize win;
 
@@ -1025,51 +1025,29 @@ static int screen_columns(void)
 		return win.ws_col;
 #endif
 
-	if (getenv("COLUMNS"))
-		return atoi(getenv("COLUMNS"));
-	return 80;
-}
-
-static tcflag_t *mode_type_flag(enum mode_type type, struct termios *mode)
-{
-	switch (type) {
-	case control:
-		return &mode->c_cflag;
-
-	case input:
-		return &mode->c_iflag;
-
-	case output:
-		return &mode->c_oflag;
-
-	case local:
-		return &mode->c_lflag;
-
-	default:                                        /* combination: */
-		return NULL;
+	columns = 80;
+	if ((s = getenv("COLUMNS"))) {
+		columns = atoi(s);
 	}
+	return columns;
 }
 
-static void
-display_settings(enum output_type output_type, struct termios *mode,
-				 int fd, const char *device_name)
+static tcflag_t *mode_type_flag(enum mode_type type, struct termios *mode)
 {
-	switch (output_type) {
-	case changed:
-		display_changed(mode);
-		break;
-
-	case all:
-		display_all(mode, fd, device_name);
-		break;
-
-	case recoverable:
-		display_recoverable(mode);
-		break;
+	static const unsigned char tcflag_offsets[] = {
+		offsetof(struct termios, c_cflag), /* control */
+		offsetof(struct termios, c_iflag), /* input */
+		offsetof(struct termios, c_oflag), /* output */
+		offsetof(struct termios, c_lflag) /* local */
+	};
+
+	if (((unsigned int) type) <= local) {
+		return (tcflag_t *)(((char *) mode) + tcflag_offsets[(int)type]);
 	}
+	return NULL;
 }
 
-static void display_changed(struct termios *mode)
+static void display_changed(struct termios *mode, int fd, const char *device_name)
 {
 	int i;
 	int empty_line;
@@ -1206,18 +1184,25 @@ display_all(struct termios *mode, int fd, const char *device_name)
 
 static void display_speed(struct termios *mode, int fancy)
 {
-	if (cfgetispeed(mode) == 0 || cfgetispeed(mode) == cfgetospeed(mode))
-		wrapf(fancy ? "speed %lu baud;" : "%lu\n",
-			  baud_to_value(cfgetospeed(mode)));
-	else
-		wrapf(fancy ? "ispeed %lu baud; ospeed %lu baud;" : "%lu %lu\n",
-			  baud_to_value(cfgetispeed(mode)),
-			  baud_to_value(cfgetospeed(mode)));
+	unsigned long ispeed, ospeed;
+	const char *fmt_str =
+		"%lu %lu\n\0"        "ispeed %lu baud; ospeed %lu baud;\0"
+		"%lu\n\0" "\0\0\0\0" "speed %lu baud;";
+
+	ospeed = ispeed = cfgetispeed(mode);
+	if (ispeed == 0 || ispeed == (ospeed = cfgetospeed(mode))) {
+		ispeed = ospeed;		/* in case ispeed was 0 */
+		fmt_str += 43;
+	}
+	if (fancy) {
+		fmt_str += 9;
+	}
+	wrapf(fmt_str, bb_baud_to_value(ispeed), bb_baud_to_value(ospeed));
 	if (!fancy)
 		current_col = 0;
 }
 
-static void display_recoverable(struct termios *mode)
+static void display_recoverable(struct termios *mode, int fd, const char *device_name)
 {
 	int i;
 
@@ -1259,62 +1244,9 @@ static int recover_mode(char *arg, struct termios *mode)
 	return 1;
 }
 
-struct speed_map {
-	speed_t speed;                          /* Internal form. */
-	unsigned long value;            /* Numeric value. */
-};
-
-static const struct speed_map speeds[] = {
-	{B0, 0},
-	{B50, 50},
-	{B75, 75},
-	{B110, 110},
-	{B134, 134},
-	{B150, 150},
-	{B200, 200},
-	{B300, 300},
-	{B600, 600},
-	{B1200, 1200},
-	{B1800, 1800},
-	{B2400, 2400},
-	{B4800, 4800},
-	{B9600, 9600},
-	{B19200, 19200},
-	{B38400, 38400},
-#ifdef B57600
-	{B57600, 57600},
-#endif
-#ifdef B115200
-	{B115200, 115200},
-#endif
-#ifdef B230400
-	{B230400, 230400},
-#endif
-#ifdef B460800
-	{B460800, 460800},
-#endif
-};
-
-static const int NUM_SPEEDS = (sizeof(speeds) / sizeof(struct speed_map));
-
 static speed_t string_to_baud(const char *arg)
 {
-	int i;
-
-	for (i = 0; i < NUM_SPEEDS; ++i)
-		if (parse_number(arg, 0) == speeds[i].value)
-			return speeds[i].speed;
-	return (speed_t) - 1;
-}
-
-static unsigned long baud_to_value(speed_t speed)
-{
-	int i;
-
-	for (i = 0; i < NUM_SPEEDS; ++i)
-		if (speed == speeds[i].speed)
-			return speeds[i].value;
-	return 0;
+	return bb_value_to_baud(bb_xparse_number(arg, 0));
 }
 
 static void sane_mode(struct termios *mode)
@@ -1333,10 +1265,12 @@ static void sane_mode(struct termios *mode)
 	for (i = 0; i < NUM_mode_info; ++i) {
 		if (mode_info[i].flags & SANE_SET) {
 			bitsp = mode_type_flag(mode_info[i].type, mode);
-			*bitsp = (*bitsp & ~mode_info[i].mask) | mode_info[i].bits;
+			*bitsp = (*bitsp & ~((unsigned long)mode_info[i].mask))
+				| mode_info[i].bits;
 		} else if (mode_info[i].flags & SANE_UNSET) {
 			bitsp = mode_type_flag(mode_info[i].type, mode);
-			*bitsp = *bitsp & ~mode_info[i].mask & ~mode_info[i].bits;
+			*bitsp = *bitsp & ~((unsigned long)mode_info[i].mask)
+				& ~mode_info[i].bits;
 		}
 	}
 }
@@ -1349,47 +1283,32 @@ static const char *visible(unsigned int ch)
 	static char buf[10];
 	char *bpout = buf;
 
-	if (ch == _POSIX_VDISABLE)
+	if (ch == _POSIX_VDISABLE) {
 		return "<undef>";
+	}
 
-	if (ch >= 32) {
-		if (ch < 127)
-			*bpout++ = ch;
-		else if (ch == 127) {
-			*bpout++ = '^';
-			*bpout++ = '?';
-		} else {
-			*bpout++ = 'M', *bpout++ = '-';
-			if (ch >= 128 + 32) {
-				if (ch < 128 + 127)
-					*bpout++ = ch - 128;
-				else {
-					*bpout++ = '^';
-					*bpout++ = '?';
-				}
-			} else {
-				*bpout++ = '^';
-				*bpout++ = ch - 128 + 64;
-			}
-		}
-	} else {
+	if (ch >= 128) {
+		ch -= 128;
+		*bpout++ = 'M';
+		*bpout++ = '-';
+	}
+
+	if (ch < 32) {
 		*bpout++ = '^';
 		*bpout++ = ch + 64;
+	} else if (ch < 127) {
+		*bpout++ = ch;
+	} else {
+		*bpout++ = '^';
+		*bpout++ = '?';
 	}
+
 	*bpout = '\0';
 	return (const char *) buf;
 }
 
 #ifdef TEST
 
-const char *applet_name = "stty";
+const char *bb_applet_name = "stty";
 
 #endif
-
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
diff --git a/coreutils/sync.c b/coreutils/sync.c
index d58168065..84746311f 100644
--- a/coreutils/sync.c
+++ b/coreutils/sync.c
@@ -20,15 +20,17 @@
  *
  */
 
-#include <stdio.h>
+/* BB_AUDIT SUSv3 N/A -- Matches GNU behavior. */
+
 #include <stdlib.h>
 #include <unistd.h>
 #include "busybox.h"
 
 extern int sync_main(int argc, char **argv)
 {
-	if (argc > 1 && **(argv + 1) == '-')
-		show_usage();
+	bb_warn_ignoring_args(argc - 1);
+
 	sync();
+
 	return(EXIT_SUCCESS);
 }
diff --git a/coreutils/tail.c b/coreutils/tail.c
index 1703eefc6..8e0adf5b5 100644
--- a/coreutils/tail.c
+++ b/coreutils/tail.c
@@ -2,7 +2,6 @@
 /*
  * Mini tail implementation for busybox
  *
- *
  * Copyright (C) 2001 by Matt Kraai <kraai@alumni.carnegiemellon.edu>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -21,14 +20,30 @@
  *
  */
 
+/* BB_AUDIT SUSv3 compliant (need fancy for -c) */
+/* BB_AUDIT GNU compatible -c, -q, and -v options in 'fancy' configuration. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/tail.html */
 
-#include <fcntl.h>
-#include <getopt.h>
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Pretty much rewritten to fix numerous bugs and reduce realloc() calls.
+ * Bugs fixed (although I may have forgotten one or two... it was pretty bad)
+ * 1) mixing printf/write without fflush()ing stdout
+ * 2) no check that any open files are present
+ * 3) optstring had -q taking an arg
+ * 4) no error checking on write in some cases, and a warning even then
+ * 5) q and s interaction bug
+ * 6) no check for lseek error
+ * 7) lseek attempted when count==0 even if arg was +0 (from top)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
-#include <stdlib.h>
 #include <unistd.h>
-#include <sys/types.h>
+#include <fcntl.h>
+#include <sys/stat.h>
 #include "busybox.h"
 
 static const struct suffix_mult tail_suffixes[] = {
@@ -38,234 +53,287 @@ static const struct suffix_mult tail_suffixes[] = {
 	{ NULL, 0 }
 };
 
-static const int BYTES = 0;
-static const int LINES = 1;
-
-static char *tailbuf;
-static int taillen;
-static int newline;
+static int status
+#if EXIT_SUCCESS != 0
+	= EXIT_SUCCESS	/* If it is 0 (paranoid check), let bss initialize it. */
+#endif
+	;
 
-static void tailbuf_append(char *buf, int len)
+static void tail_xprint_header(const char *fmt, const char *filename)
 {
-	tailbuf = xrealloc(tailbuf, taillen + len);
-	memcpy(tailbuf + taillen, buf, len);
-	taillen += len;
+	/* If we get an output error, there is really no sense in continuing. */
+	if (dprintf(STDOUT_FILENO, fmt, filename) < 0) {
+		bb_perror_nomsg_and_die();
+	}
 }
 
-static void tailbuf_trunc(void)
+/* len should probably be size_t */
+static void tail_xbb_full_write(const char *buf, size_t len)
 {
-	char *s;
-	s = memchr(tailbuf, '\n', taillen);
-	memmove(tailbuf, s + 1, taillen - ((s + 1) - tailbuf));
-	taillen -= (s + 1) - tailbuf;
-	newline = 0;
+	/* If we get a write error, there is really no sense in continuing. */
+	if (bb_full_write(STDOUT_FILENO, buf, len) < 0) {
+		bb_perror_nomsg_and_die();
+	}
 }
 
-int tail_main(int argc, char **argv)
+static ssize_t tail_read(int fd, char *buf, size_t count)
 {
-	int from_top = 0, units = LINES, count = 10, sleep_period = 1;
-	int show_headers = 0, hide_headers = 0, follow = 0;
-	int *fds, nfiles = 0, status = EXIT_SUCCESS, nread, nwrite, seen = 0;
-	char *s, *start, *end, buf[BUFSIZ];
-	int i, opt;
-
-	if (argc >= 2) {
-		int line_num;
-		switch (argv[1][0]) {
-			case '+':
-				from_top = 1;
-				/* FALLS THROUGH */
-			case '-':
-				line_num = atoi(&argv[1][1]);
-				if (line_num != 0) {
-					optind = 2;
-					count = line_num;
-				}
-				break;
-		}
+	ssize_t r;
+
+	if ((r = safe_read(fd, buf, count)) < 0) {
+		bb_perror_msg("read");
+		status = EXIT_FAILURE;
 	}
 
+	return r;
+}
+
+static const char tail_opts[] =
+	"fn:"
+#ifdef CONFIG_FEATURE_FANCY_TAIL
+	"c:qs:v"
+#endif
+	;
+
+static const char header_fmt[] = "\n==> %s <==\n";
+
+int tail_main(int argc, char **argv)
+{
+	long count = 10;
+	unsigned int sleep_period = 1;
+	int from_top = 0;
+	int follow = 0;
+	int header_threshhold = 1;
 #ifdef CONFIG_FEATURE_FANCY_TAIL
-	while ((opt = getopt(argc, argv, "c:fn:q:s:v")) > 0) {
-#else
-	while ((opt = getopt(argc, argv, "fn:")) > 0) {
+	int count_bytes = 0;
 #endif
+
+	char *tailbuf;
+	size_t tailbufsize;
+	int taillen = 0;
+	int newline = 0;
+
+	int *fds, nfiles, nread, nwrite, seen, i, opt;
+	char *s, *buf;
+	const char *fmt;
+
+	/* Allow legacy syntax of an initial numeric option without -n. */
+	if ((argv[1][0] == '+')
+		|| ((argv[1][0] == '-')
+			/* && (isdigit)(argv[1][1]) */
+			&& (((unsigned int)(argv[1][1] - '0')) <= 9))
+		) {
+		optind = 2;
+		optarg = argv[1];
+		goto GET_COUNT;
+	}
+
+	while ((opt = getopt(argc, argv, tail_opts)) > 0) {
 		switch (opt) {
 			case 'f':
 				follow = 1;
 				break;
 #ifdef CONFIG_FEATURE_FANCY_TAIL
 			case 'c':
-				units = BYTES;
+				count_bytes = 1;
 				/* FALLS THROUGH */
 #endif
 			case 'n':
-				count = parse_number(optarg, tail_suffixes);
-				if (count < 0)
-					count = -count;
-				if (optarg[0] == '+')
+			GET_COUNT:
+				count = bb_xgetlarg10_sfx(optarg, tail_suffixes);
+				/* Note: Leading whitespace is an error trapped above. */
+				if (*optarg == '+') {
 					from_top = 1;
+				} else {
+					from_top = 0;
+				}
+				if (count < 0) {
+					count = -count;
+				}
 				break;
 #ifdef CONFIG_FEATURE_FANCY_TAIL
 			case 'q':
-				hide_headers = 1;
+				header_threshhold = INT_MAX;
 				break;
 			case 's':
-				sleep_period = parse_number(optarg, 0);
+				sleep_period =bb_xgetularg10_bnd(optarg, 0, UINT_MAX);
 				break;
 			case 'v':
-				show_headers = 1;
+				header_threshhold = 0;
 				break;
 #endif
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
 	/* open all the files */
 	fds = (int *)xmalloc(sizeof(int) * (argc - optind + 1));
-	if (argc == optind) {
-		fds[nfiles++] = STDIN_FILENO;
-		argv[optind] = "standard input";
-	} else {
-		for (i = optind; i < argc; i++) {
-			if (strcmp(argv[i], "-") == 0) {
-				fds[nfiles++] = STDIN_FILENO;
-				argv[i] = "standard input";
-			} else if ((fds[nfiles++] = open(argv[i], O_RDONLY)) < 0) {
-				perror_msg("%s", argv[i]);
-				status = EXIT_FAILURE;
-			}
+
+	argv += optind;
+	nfiles = i = 0;
+
+	if ((argc -= optind) == 0) {
+		struct stat statbuf;
+
+		if (!fstat(STDIN_FILENO, &statbuf) && S_ISFIFO(statbuf.st_mode)) {
+			follow = 0;
 		}
+		/* --argv; */
+		*argv = (char *) bb_msg_standard_input;
+		goto DO_STDIN;
+	}
+
+	do {
+		if ((argv[i][0] == '-') && !argv[i][1]) {
+		DO_STDIN:
+			fds[nfiles] = STDIN_FILENO;
+		} else if ((fds[nfiles] = open(argv[i], O_RDONLY)) < 0) {
+			bb_perror_msg("%s", argv[i]);
+			status = EXIT_FAILURE;
+			continue;
+		}
+		argv[nfiles] = argv[i];
+		++nfiles;
+	} while (++i < argc);
+
+	if (!nfiles) {
+		bb_error_msg_and_die("no files");
 	}
-	
+
+	tailbufsize = BUFSIZ;
 #ifdef CONFIG_FEATURE_FANCY_TAIL
 	/* tail the files */
-	if (!from_top && units == BYTES)
-		tailbuf = xmalloc(count);
+	if (from_top < count_bytes) {	/* Each is 0 or 1, so true iff 0 < 1. */
+		/* Hence, !from_top && count_bytes */
+		if (tailbufsize < count) {
+			tailbufsize = count + BUFSIZ;
+		}
+	}
 #endif
+	buf = tailbuf = xmalloc(tailbufsize);
 
-	for (i = 0; i < nfiles; i++) {
-		if (fds[i] == -1)
-			continue;
-		if (!count) {
-			lseek(fds[i], 0, SEEK_END);
+	fmt = header_fmt + 1;	/* Skip header leading newline on first output. */
+	i = 0;
+	do {
+		/* Be careful.  It would be possible to optimize the count-bytes
+		 * case if the file is seekable.  If you do though, remember that
+		 * starting file position may not be the beginning of the file.
+		 * Beware of backing up too far.  See example in wc.c.
+		 */
+		if ((!(count|from_top)) && (lseek(fds[i], 0, SEEK_END) >= 0)) {
 			continue;
 		}
-		seen = 0;
-		if (show_headers || (!hide_headers && nfiles > 1))
-			printf("%s==> %s <==\n", i == 0 ? "" : "\n", argv[optind + i]);
-		while ((nread = safe_read(fds[i], buf, sizeof(buf))) > 0) {
+
+		if (nfiles > header_threshhold) {
+			tail_xprint_header(fmt, argv[i]);
+			fmt = header_fmt;
+		}
+
+		buf = tailbuf;
+		taillen = 0;
+		seen = 1;
+
+		while ((nread = tail_read(fds[i], buf, tailbufsize-taillen)) > 0) {
 			if (from_top) {
+				nwrite = nread;
+				if (seen < count) {
 #ifdef CONFIG_FEATURE_FANCY_TAIL
-				if (units == BYTES) {
-					if (count - 1 <= seen)
-						nwrite = nread;
-					else if (count - 1 <= seen + nread)
-						nwrite = nread + seen - (count - 1);
-					else
-						nwrite = 0;
-					seen += nread;
-				} else {
-#else
-				{
+					if (count_bytes) {
+						nwrite -= (count - seen);
+						seen = count;
+					} else
 #endif
-					if (count - 1 <= seen)
-						nwrite = nread;
-					else {
-						nwrite = 0;
-						for (s = memchr(buf, '\n', nread); s != NULL;
-								s = memchr(s+1, '\n', nread - (s + 1 - buf))) {
-							if (count - 1 <= ++seen) {
-								nwrite = nread - (s + 1 - buf);
+					{
+						s = buf;
+						do {
+							--nwrite;
+							if ((*s++ == '\n') && (++seen == count)) {
 								break;
 							}
-						}
+						} while (nwrite);
 					}
 				}
-				if (full_write(STDOUT_FILENO, buf + nread - nwrite,
-							nwrite) < 0) {
-					perror_msg("write");
-					status = EXIT_FAILURE;
-					break;
-				}
-			} else {
+				tail_xbb_full_write(buf + nread - nwrite, nwrite);
+			} else if (count) {
 #ifdef CONFIG_FEATURE_FANCY_TAIL
-				if (units == BYTES) {
-					if (nread < count) {
-						memmove(tailbuf, tailbuf + nread, count - nread);
-						memcpy(tailbuf + count - nread, buf, nread);
-					} else {
-						memcpy(tailbuf, buf + nread - count, count);
+				if (count_bytes) {
+					taillen += nread;
+					if (taillen > count) {
+						memmove(tailbuf, tailbuf + taillen - count, count);
+						taillen = count;
 					}
-					seen += nread;
-				} else {
-#else
-				{
+				} else
 #endif
-					for (start = buf, end = memchr(buf, '\n', nread);
-							end != NULL; start = end+1,
-							end = memchr(start, '\n', nread - (start - buf))) {
-						if (newline && count <= seen)
-							tailbuf_trunc();
-						tailbuf_append(start, end - start + 1);
-						seen++;
-						newline = 1;
+				{
+					int k = nread;
+					int nbuf = 0;
+
+					while (k) {
+						--k;
+						if (buf[k] == '\n') {
+							++nbuf;
+						}
 					}
-					if (newline && count <= seen && nread - (start - buf) > 0)
-						tailbuf_trunc();
-					tailbuf_append(start, nread - (start - buf));
-				}
-			}
-		}
 
-		if (nread < 0) {
-			perror_msg("read");
-			status = EXIT_FAILURE;
-		}
+					if (newline + nbuf < count) {
+						newline += nbuf;
+						taillen += nread;
 
-#ifdef CONFIG_FEATURE_FANCY_TAIL
-		if (!from_top && units == BYTES) {
-			if (count < seen)
-				seen = count;
-			if (full_write(STDOUT_FILENO, tailbuf + count - seen, seen) < 0) {
-				perror_msg("write");
-				status = EXIT_FAILURE;
+					} else {
+						int extra = 0;
+						if (buf[nread-1] != '\n') {
+							extra = 1;
+						}
+
+						k = newline + nbuf + extra - count;
+						s = tailbuf;
+						while (k) {
+							if (*s == '\n') {
+								--k;
+							}
+							++s;
+						}
+
+						taillen += nread - (s - tailbuf);
+						memmove(tailbuf, s, taillen);
+						newline = count - extra;
+					}
+					if (tailbufsize < taillen + BUFSIZ) {
+						tailbufsize = taillen + BUFSIZ;
+						tailbuf = xrealloc(tailbuf, tailbufsize);
+					}
+				}
+				buf = tailbuf + taillen;
 			}
 		}
-#endif
 
-		if (!from_top && units == LINES) {
-			if (full_write(STDOUT_FILENO, tailbuf, taillen) < 0) {
-				perror_msg("write");
-				status = EXIT_FAILURE;
-			}
+		if (!from_top) {
+			tail_xbb_full_write(tailbuf, taillen);
 		}
 
 		taillen = 0;
-	}
-
-	while (follow) {
-		sleep(sleep_period);
+	} while (++i < nfiles);
 
-		for (i = 0; i < nfiles; i++) {
-			if (fds[i] == -1)
-				continue;
+	buf = xrealloc(tailbuf, BUFSIZ);
 
-			if ((nread = safe_read(fds[i], buf, sizeof(buf))) > 0) {
-				if (show_headers || (!hide_headers && nfiles > 1))
-					printf("\n==> %s <==\n", argv[optind + i]);
+	fmt = NULL;
 
-				do {
-					full_write(STDOUT_FILENO, buf, nread);
-				} while ((nread = safe_read(fds[i], buf, sizeof(buf))) > 0);
+	while (follow) {
+		sleep(sleep_period);
+		i = 0;
+		do {
+			if (nfiles > header_threshhold) {
+				fmt = header_fmt;
 			}
-
-			if (nread < 0) {
-				perror_msg("read");
-				status = EXIT_FAILURE;
+			while ((nread = tail_read(fds[i], buf, sizeof(buf))) > 0) {
+				if (fmt) {
+					tail_xprint_header(fmt, argv[i]);
+					fmt = NULL;
+				}
+				tail_xbb_full_write(buf, nread);
 			}
-		}
+		} while (++i < nfiles);
 	}
 
 	return status;
diff --git a/coreutils/tee.c b/coreutils/tee.c
index 1c145426a..7e86f2e29 100644
--- a/coreutils/tee.c
+++ b/coreutils/tee.c
@@ -1,8 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini tee implementation for busybox
+ * tee implementation for busybox
  *
- * Copyright (C) 2000,2001 by Matt Kraai <kraai@alumni.carnegiemellon.edu>
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,47 +20,96 @@
  *
  */
 
-#include "busybox.h"
-#include <getopt.h>
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/tee.html */
+
 #include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+#include "busybox.h"
 
-int
-tee_main(int argc, char **argv)
+int tee_main(int argc, char **argv)
 {
-	char *mode = "w";
-	int c, i, status = 0, nfiles = 0;
+	const char *mode = "w\0a";
 	FILE **files;
+	FILE **p;
+	char **filenames;
+	int flags;
+	int retval = EXIT_SUCCESS;
+#ifdef CONFIG_FEATURE_TEE_USE_BLOCK_IO
+	size_t c;
+	RESERVE_CONFIG_BUFFER(buf, BUFSIZ);
+#else
+	int c;
+#endif
+
+	flags = bb_getopt_ulflags(argc, argv, "ia");	/* 'a' must be 2nd */
+
+	mode += (flags & 2);	/* Since 'a' is the 2nd option... */
+
+	if (flags & 1) {
+		signal(SIGINT, SIG_IGN);	/* TODO - switch to sigaction.*/
+	}
+
+	/* gnu tee ignores SIGPIPE in case one of the output files is a pipe
+	 * that doesn't consume all its input.  Good idea... */
+	signal(SIGPIPE, SIG_IGN);		/* TODO - switch to sigaction.*/
 
-	while ((c = getopt(argc, argv, "a")) != EOF) {
-		switch (c) {
-		case 'a': 
-			mode = "a";
-			break;
-		default:
-			show_usage();
+	/* Allocate an array of FILE *'s, with one extra for a sentinal. */
+	p = files = (FILE **)xmalloc(sizeof(FILE *) * (argc - optind + 2));
+	*p = stdout;
+	argv += optind - 1;
+	filenames = argv - 1;
+	*filenames = (char *) bb_msg_standard_input;	/* for later */
+	goto GOT_NEW_FILE;
+
+	do {
+		if ((*p = bb_wfopen(*argv, mode)) == NULL) {
+			retval = EXIT_FAILURE;
+			continue;
+		}
+		filenames[(int)(p - files)] = *argv;
+	GOT_NEW_FILE:
+		setbuf(*p, NULL);	/* tee must not buffer output. */
+		++p;
+	} while (*++argv);
+
+	*p = NULL;				/* Store the sentinal value. */
+
+#ifdef CONFIG_FEATURE_TEE_USE_BLOCK_IO
+	while ((c = fread(buf, 1, BUFSIZ, stdin)) != 0) {
+		for (p=files ; *p ; p++) {
+			fwrite(buf, 1, c, *p);
 		}
 	}
 
-	files = (FILE **)xmalloc(sizeof(FILE *) * (argc - optind + 1));
-	files[nfiles++] = stdout;
-	while (optind < argc) {
-		if ((files[nfiles++] = wfopen(argv[optind++], mode)) == NULL) {
-			nfiles--;
-			status = 1;
+#ifdef CONFIG_FEATURE_CLEAN_UP
+	RELEASE_CONFIG_BUFFER(buf);
+#endif
+
+#else
+	while ((c = getchar()) != EOF) {
+		for (p=files ; *p ; p++) {
+			putc(c, *p);
 		}
 	}
+#endif
 
-	while ((c = getchar()) != EOF)
-		for (i = 0; i < nfiles; i++)
-			putc(c, files[i]);
+	/* Now we need to check for i/o errors on stdin and the various 
+	 * output files.  Since we know that the first entry in the output
+	 * file table is stdout, we can save one "if ferror" test by
+	 * setting the first entry to stdin and checking stdout error
+	 * status with bb_fflush_stdout_and_exit()... although fflush()ing
+	 * is unnecessary here. */
 
-	return status;
-}
+	p = files;
+	*p = stdin;
+	do {		/* Now check for (input and) output errors. */
+		/* Checking ferror should be sufficient, but we may want to fclose.
+		 * If we do, remember not to close stdin! */
+		bb_xferror(*p, filenames[(int)(p - files)]);
+	} while (*++p);
 
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
+	bb_fflush_stdout_and_exit(retval);
+}
diff --git a/coreutils/test.c b/coreutils/test.c
index 83e31ea5c..0bce66e6f 100644
--- a/coreutils/test.c
+++ b/coreutils/test.c
@@ -180,9 +180,9 @@ extern int test_main(int argc, char **argv)
 {
 	int res;
 
-	if (strcmp(applet_name, "[") == 0) {
+	if (strcmp(bb_applet_name, "[") == 0) {
 		if (strcmp(argv[--argc], "]"))
-			error_msg_and_die("missing ]");
+			bb_error_msg_and_die("missing ]");
 		argv[argc] = NULL;
 	}
 	/* Implement special cases from POSIX.2, section 4.62.4 */
@@ -226,9 +226,9 @@ extern int test_main(int argc, char **argv)
 static void syntax(const char *op, const char *msg)
 {
 	if (op && *op) {
-		error_msg_and_die("%s: %s", op, msg);
+		bb_error_msg_and_die("%s: %s", op, msg);
 	} else {
-		error_msg_and_die("%s", msg);
+		bb_error_msg_and_die("%s", msg);
 	}
 }
 
@@ -450,13 +450,13 @@ static int getn(const char *s)
 	r = strtol(s, &p, 10);
 
 	if (errno != 0)
-		error_msg_and_die("%s: out of range", s);
+		bb_error_msg_and_die("%s: out of range", s);
 
 	while (isspace(*p))
 		p++;
 
 	if (*p)
-		error_msg_and_die("%s: bad number", s);
+		bb_error_msg_and_die("%s: bad number", s);
 
 	return (int) r;
 }
diff --git a/coreutils/touch.c b/coreutils/touch.c
index f1c6dc484..c66f26e0d 100644
--- a/coreutils/touch.c
+++ b/coreutils/touch.c
@@ -21,6 +21,16 @@
  *
  */
 
+/* BB_AUDIT SUSv3 _NOT_ compliant -- options -a, -m, -r, -t not supported. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/touch.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Previous version called open() and then utime().  While this will be
+ * be necessary to implement -r and -t, it currently only makes things bigger.
+ * Also, exiting on a failure was a bug.  All args should be processed.
+ */
+
 #include <stdio.h>
 #include <sys/types.h>
 #include <fcntl.h>
@@ -33,44 +43,35 @@
 extern int touch_main(int argc, char **argv)
 {
 	int fd;
-	int create = TRUE;
+	int flags;
+	int status = EXIT_SUCCESS;
 
-	/* Parse options */
-	while (--argc > 0 && **(++argv) == '-') {
-		while (*(++(*argv))) {
-			switch (**argv) {
-			case 'c':
-				create = FALSE;
-				break;
-			default:
-				show_usage();
-			}
-		}
-	}
+	flags = bb_getopt_ulflags(argc, argv, "c");
+
+	argv += optind;
 
-	if (argc < 1) {
-		show_usage();
+	if (!*argv) {
+		bb_show_usage();
 	}
 
-	while (argc > 0) {
-		fd = open(*argv, create ? O_RDWR | O_CREAT : O_RDWR,
-				S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
-		if (fd < 0) {
-			if (! create && errno == ENOENT) {
-				argc--;
-				argv++;
-				continue;
-			} else {
-				perror_msg_and_die("%s", *argv);
-			}
-		}
-		close(fd);
+	do {
 		if (utime(*argv, NULL)) {
-			perror_msg_and_die("%s", *argv);
+			if (errno == ENOENT) {	/* no such file*/
+				if (flags & 1) {	/* Creation is disabled, so ignore. */
+					continue;
+				}
+				/* Try to create the file. */
+				fd = open(*argv, O_RDWR | O_CREAT,
+						  S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH
+						  );
+				if ((fd >= 0) && !close(fd)) {
+					continue;
+				}
+			}
+			status = EXIT_FAILURE;
+			bb_perror_msg("%s", *argv);
 		}
-		argc--;
-		argv++;
-	}
+	} while (*++argv);
 
-	return EXIT_SUCCESS;
+	return status;
 }
diff --git a/coreutils/tr.c b/coreutils/tr.c
index e2a4ef6c5..a00e36134 100644
--- a/coreutils/tr.c
+++ b/coreutils/tr.c
@@ -54,7 +54,7 @@ static void convert(void)
 		if (in_index == read_chars) {
 			if ((read_chars = read(0, (char *) pinput, BUFSIZ)) <= 0) {
 				if (write(1, (char *) poutput, out_index) != out_index)
-					error_msg("%s", write_error);
+					bb_error_msg(bb_msg_write_error);
 				exit(0);
 			}
 			in_index = 0;
@@ -68,7 +68,7 @@ static void convert(void)
 		poutput[out_index++] = last = coded;
 		if (out_index == BUFSIZ) {
 			if (write(1, (char *) poutput, out_index) != out_index)
-				error_msg_and_die("%s", write_error);
+				bb_error_msg_and_die(bb_msg_write_error);
 			out_index = 0;
 		}
 	}
@@ -102,7 +102,7 @@ static unsigned int expand(const char *arg, register unsigned char *buffer)
 	while (*arg) {
 		if (*arg == '\\') {
 			arg++;
-			*buffer++ = process_escape_sequence(&arg);
+			*buffer++ = bb_process_escape_sequence(&arg);
 		} else if (*(arg+1) == '-') {
 			ac = *(arg+2);
 			if(ac == 0) {
@@ -181,7 +181,7 @@ extern int tr_main(int argc, char **argv)
 				sq_fl = TRUE;
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 			}
 		}
 		idx++;
@@ -197,7 +197,7 @@ extern int tr_main(int argc, char **argv)
 			input_length = complement(input, input_length);
 		if (argv[idx] != NULL) {
 			if (*argv[idx] == '\0')
-				error_msg_and_die("STRING2 cannot be empty");
+				bb_error_msg_and_die("STRING2 cannot be empty");
 			output_length = expand(argv[idx], output);
 			map(input, input_length, output, output_length);
 		}
diff --git a/coreutils/true.c b/coreutils/true.c
index 9644aad4a..0fbe1023d 100644
--- a/coreutils/true.c
+++ b/coreutils/true.c
@@ -21,7 +21,8 @@
  *
  */
 
-/* getopt not needed */
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/true.html */
 
 #include <stdlib.h>
 #include "busybox.h"
diff --git a/coreutils/tty.c b/coreutils/tty.c
index 4510c2996..cd2c784fd 100644
--- a/coreutils/tty.c
+++ b/coreutils/tty.c
@@ -1,8 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini tty implementation for busybox
+ * tty implementation for busybox
  *
- * Copyright (C) 2000  Edward Betts <edward@debian.org>.
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,25 +20,39 @@
  *
  */
 
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/tty.html */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include <sys/types.h>
 #include "busybox.h"
 
 extern int tty_main(int argc, char **argv)
 {
-	char *tty;
-
-	if (argc > 1) {
-		if (argv[1][0] != '-' || argv[1][1] != 's')
-			show_usage();
-	} else {
-		tty = ttyname(0);
-		if (tty)
-			puts(tty);
-		else
-			puts("not a tty");
+	const char *s;
+	int silent;		/* Note: No longer relevant in SUSv3. */
+	int retval;
+
+	bb_default_error_retval = 2;	/* SUSv3 requires > 1 for error. */
+
+	silent = bb_getopt_ulflags(argc, argv, "s");
+
+	/* gnu tty outputs a warning that it is ignoring all args. */
+	bb_warn_ignoring_args(argc - optind);
+
+	retval = 0;
+
+	if ((s = ttyname(0)) == NULL) {
+	/* According to SUSv3, ttyname can on fail with EBADF or ENOTTY.
+	 * We know the file descriptor is good, so failure means not a tty. */
+		s = "not a tty";
+		retval = 1;
+	}
+
+	if (!silent) {
+		puts(s);
 	}
-	return(isatty(0) ? EXIT_SUCCESS : EXIT_FAILURE);
+
+	bb_fflush_stdout_and_exit(retval);
 }
diff --git a/coreutils/uname.c b/coreutils/uname.c
index df4f14ea0..a3e52e39f 100644
--- a/coreutils/uname.c
+++ b/coreutils/uname.c
@@ -16,6 +16,9 @@
    along with this program; if not, write to the Free Software Foundation,
    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/uname.html */
+
 /* Option		Example
 
    -s, --sysname	SunOS
@@ -33,13 +36,18 @@
 
 /* Further size reductions by Glenn McGrath and Manuel Novoa III. */
 
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Now does proper error checking on i/o.  Plus some further space savings.
+ */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
 #include <string.h>
+#include <unistd.h>
 #include <sys/types.h>
 #include <sys/utsname.h>
-#include <getopt.h>
 #include "busybox.h"
 
 typedef struct {
@@ -48,7 +56,6 @@ typedef struct {
 } uname_info_t;
 
 static const char options[] = "snrvmpa";
-static const char flags[] = "\x01\x02\x04\x08\x10\x20\x3f";
 static const unsigned short int utsname_offset[] = {
 	offsetof(uname_info_t,name.sysname),
 	offsetof(uname_info_t,name.nodename),
@@ -61,29 +68,28 @@ static const unsigned short int utsname_offset[] = {
 int uname_main(int argc, char **argv)
 {
 	uname_info_t uname_info;
-
 #if defined(__sparc__) && defined(__linux__)
 	char *fake_sparc = getenv("FAKE_SPARC");
 #endif
-
 	const unsigned short int *delta;
-	int opt;
-	char toprint = 0;
+	char toprint;
 
-	while ((opt = getopt(argc, argv, options)) != -1) {
-		const char *p = strchr(options,opt);
-		if (p == NULL) {
-			show_usage();
-		}
-		toprint |= flags[(int)(p-options)];
+	toprint = bb_getopt_ulflags(argc, argv, options);
+
+	if (argc != optind) {
+		bb_show_usage();
+	}
+
+	if (toprint & (1 << 6)) {
+		toprint = 0x3f;
 	}
 
 	if (toprint == 0) {
-		toprint = flags[0];		/* sysname */
+		toprint = 1;			/* sysname */
 	}
 
 	if (uname(&uname_info.name) == -1) {
-		error_msg_and_die("cannot get system name");
+		bb_error_msg_and_die("cannot get system name");
 	}
 
 #if defined(__sparc__) && defined(__linux__)
@@ -99,7 +105,7 @@ int uname_main(int argc, char **argv)
 	delta=utsname_offset;
 	do {
 		if (toprint & 1) {
-			printf(((char *)(&uname_info)) + *delta);
+			bb_printf(((char *)(&uname_info)) + *delta);
 			if (toprint > 1) {
 				putchar(' ');
 			}
@@ -108,5 +114,5 @@ int uname_main(int argc, char **argv)
 	} while (toprint >>= 1);
 	putchar('\n');
 
-	return EXIT_SUCCESS;
+	bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 }
diff --git a/coreutils/uniq.c b/coreutils/uniq.c
index cb63c4277..90686c9af 100644
--- a/coreutils/uniq.c
+++ b/coreutils/uniq.c
@@ -1,10 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini uniq implementation for busybox
+ * uniq implementation for busybox
  *
- * Copyright (C) 1999 by Lineo, inc. and John Beppu
- * Copyright (C) 1999,2000,2001 by John Beppu <beppu@codepoet.org>
- * Rewritten by Matt Kraai <kraai@alumni.carnegiemellon.edu>
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,67 +20,93 @@
  *
  */
 
+/* BB_AUDIT SUSv3 compliant */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/uniq.html */
+
 #include <stdio.h>
-#include <string.h>
-#include <getopt.h>
-#include <errno.h>
 #include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
 #include "busybox.h"
+#include "libcoreutils/coreutils.h"
 
-static int print_count;
-static int print_uniq = 1;
-static int print_duplicates = 1;
-
-static void print_line(char *line, int count, FILE *fp)
-{
-	if ((print_duplicates && count > 1) || (print_uniq && count == 1)) {
-		if (print_count)
-			fprintf(fp, "%7d\t%s", count, line);
-		else
-			fputs(line, fp);
-	}
-}
+static const char uniq_opts[] = "f:s:cdu\0\7\3\5\1\2\4";
 
 int uniq_main(int argc, char **argv)
 {
-	FILE *in = stdin, *out = stdout;
-	char *lastline = NULL, *input;
-	int opt, count = 0;
+	FILE *in, *out;
+	/* Note: Ignore the warning about dups and e0 possibly being uninitialized.
+	 * They will be initialized on the fist pass of the loop (since s0 is NULL). */
+	unsigned long dups, skip_fields, skip_chars, i;
+	const char *s0, *e0, *s1, *e1, *input_filename;
+	int opt;
+	int uniq_flags = 6;		/* -u */
 
-	/* parse argv[] */
-	while ((opt = getopt(argc, argv, "cdu")) > 0) {
-		switch (opt) {
-			case 'c':
-				print_count = 1;
-				break;
-			case 'd':
-				print_duplicates = 1;
-				print_uniq = 0;
-				break;
-			case 'u':
-				print_duplicates = 0;
-				print_uniq = 1;
-				break;
+	skip_fields = skip_chars = 0;
+
+	while ((opt = getopt(argc, argv, uniq_opts)) > 0) {
+		if (opt == 'f') {
+			skip_fields = bb_xgetularg10(optarg);
+		} else if (opt == 's') {
+			skip_chars = bb_xgetularg10(optarg);
+		} else if ((s0 = strchr(uniq_opts, opt)) != NULL) {
+			uniq_flags &= s0[4];
+			uniq_flags |= s0[7];
+		} else {
+			bb_show_usage();
 		}
 	}
 
-	if (argv[optind] != NULL) {
-		in = xfopen(argv[optind], "r");
-		if (argv[optind+1] != NULL)
-			out = xfopen(argv[optind+1], "w");
+	input_filename = *(argv += optind);
+
+	in = xgetoptfile_sort_uniq(argv, "r");
+	if (*argv) {
+		++argv;
 	}
+	out = xgetoptfile_sort_uniq(argv, "w");
+	if (*argv && argv[1]) {
+		bb_show_usage();
+	}
+
+	s0 = NULL;
 
-	while ((input = get_line_from_file(in)) != NULL) {
-		if (lastline == NULL || strcmp(input, lastline) != 0) {
-			print_line(lastline, count, out);
-			free(lastline);
-			lastline = input;
-			count = 0;
+	/* gnu uniq ignores newlines */
+	while ((s1 = bb_get_chomped_line_from_file(in)) != NULL) {
+		e1 = s1;
+		for (i=skip_fields ; i ; i--) {
+			e1 = bb_skip_whitespace(e1);
+			while (*e1 && !isspace(*e1)) {
+				++e1;
+			}
+		}
+		for (i = skip_chars ; *e1 && i ; i--) {
+			++e1;
+		}
+		if (s0) {
+			if (strcmp(e0, e1) == 0) {
+				++dups;		/* Note: Testing for overflow seems excessive. */
+				continue;
+			}
+		DO_LAST:
+			if ((dups && (uniq_flags & 2)) || (!dups && (uniq_flags & 4))) {
+				bb_fprintf(out, "\0%7d\t" + (uniq_flags & 1), dups + 1);
+				bb_fprintf(out, "%s\n", s0);
+			}
+			free((void *)s0);
 		}
-		count++;
+
+		s0 = s1;
+		e0 = e1;
+		dups = 0;
+	}
+
+	if (s0) {
+		e1 = NULL;
+		goto DO_LAST;
 	}
-	print_line(lastline, count, out);
-	free(lastline);
 
-	return EXIT_SUCCESS;
+	bb_xferror(in, input_filename);
+
+	bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 }
diff --git a/coreutils/usleep.c b/coreutils/usleep.c
index ac268b485..f570f2734 100644
--- a/coreutils/usleep.c
+++ b/coreutils/usleep.c
@@ -1,8 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini usleep implementation for busybox
+ * usleep implementation for busybox
  *
- * Copyright (C) 1995, 1996 by Bruce Perens <bruce@pixar.com>.
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,18 +20,22 @@
  *
  */
 
-/* getopt not needed */
+/* BB_AUDIT SUSv3 N/A -- Apparently a busybox extension. */
 
 #include <stdlib.h>
+#include <limits.h>
 #include <unistd.h>
 #include "busybox.h"
 
 extern int usleep_main(int argc, char **argv)
 {
-	if ((argc < 2) || (**(argv + 1) == '-')) {
-		show_usage();
+	if (argc != 2) {
+		bb_show_usage();
+	}
+
+	if (usleep(bb_xgetularg10_bnd(argv[1], 0, UINT_MAX))) {
+		bb_perror_nomsg_and_die();
 	}
 
-	usleep(atoi(*(++argv)));	/* return void */
 	return EXIT_SUCCESS;
 }
diff --git a/coreutils/uudecode.c b/coreutils/uudecode.c
index a5ac002e9..4f9270c18 100644
--- a/coreutils/uudecode.c
+++ b/coreutils/uudecode.c
@@ -46,7 +46,7 @@ static int read_stduu (const char *inname)
     char *p;
 
     if (fgets (buf, sizeof(buf), stdin) == NULL) {
-      error_msg("%s: Short file", inname);
+      bb_error_msg("%s: Short file", inname);
       return FALSE;
     }
     p = buf;
@@ -81,7 +81,7 @@ static int read_stduu (const char *inname)
 
   if (fgets (buf, sizeof(buf), stdin) == NULL
       || strcmp (buf, "end\n")) {
-    error_msg("%s: No `end' line", inname);
+    bb_error_msg("%s: No `end' line", inname);
     return FALSE;
   }
 
@@ -131,7 +131,7 @@ static int read_base64 (const char *inname)
     unsigned char *p;
 
     if (fgets (buf, sizeof(buf), stdin) == NULL) {
-      error_msg("%s: Short file", inname);
+      bb_error_msg("%s: Short file", inname);
       return FALSE;
     }
     p = buf;
@@ -139,7 +139,7 @@ static int read_base64 (const char *inname)
     if (memcmp (buf, "====", 4) == 0)
       break;
     if (last_data != 0) {
-      error_msg("%s: data following `=' padding character", inname);
+      bb_error_msg("%s: data following `=' padding character", inname);
       return FALSE;
     }
 
@@ -161,14 +161,14 @@ static int read_base64 (const char *inname)
 
       while ((b64_tab[*p] & '\100') != 0)
         if (*p == '\n' || *p++ == '=') {
-          error_msg("%s: illegal line", inname);
+          bb_error_msg("%s: illegal line", inname);
           return FALSE;
         }
       c2 = b64_tab[*p++];
 
       while (b64_tab[*p] == '\177')
         if (*p++ == '\n') {
-          error_msg("%s: illegal line", inname);
+          bb_error_msg("%s: illegal line", inname);
           return FALSE;
         }
       if (*p == '=') {
@@ -180,7 +180,7 @@ static int read_base64 (const char *inname)
 
       while (b64_tab[*p] == '\177')
         if (*p++ == '\n') {
-          error_msg("%s: illegal line", inname);
+          bb_error_msg("%s: illegal line", inname);
           return FALSE;
         }
       putchar (c1 << 2 | c2 >> 4);
@@ -213,7 +213,7 @@ static int decode (const char *inname,
 
   while (1) {
     if (fgets (buf, sizeof (buf), stdin) == NULL) {
-      error_msg("%s: No `begin' line", inname);
+      bb_error_msg("%s: No `begin' line", inname);
       return FALSE;
     }
 
@@ -239,13 +239,13 @@ static int decode (const char *inname,
       while (*p != '/')
         ++p;
       if (*p == '\0') {
-        error_msg("%s: Illegal ~user", inname);
+        bb_error_msg("%s: Illegal ~user", inname);
         return FALSE;
       }
       *p++ = '\0';
       pw = getpwnam (buf + 1);
       if (pw == NULL) {
-        error_msg("%s: No user `%s'", inname, buf + 1);
+        bb_error_msg("%s: No user `%s'", inname, buf + 1);
         return FALSE;
       }
       outname = concat_path_file(pw->pw_dir, p);
@@ -258,7 +258,7 @@ static int decode (const char *inname,
       && (freopen (outname, "w", stdout) == NULL
 	  || chmod (outname, mode & (S_IRWXU | S_IRWXG | S_IRWXO))
          )) {
-    perror_msg("%s", outname); /* */
+    bb_perror_msg("%s", outname); /* */
     if (dofre)
 	free(outname);
     return FALSE;
@@ -295,7 +295,7 @@ int uudecode_main (int argc,
       break;
 
      default:
-      show_usage();
+      bb_show_usage();
     }
   }
 
@@ -308,7 +308,7 @@ int uudecode_main (int argc,
         if (decode (argv[optind], outname) != 0)
           exit_status = FALSE;
       } else {
-        perror_msg("%s", argv[optind]);
+        bb_perror_msg("%s", argv[optind]);
         exit_status = EXIT_FAILURE;
       }
       optind++;
diff --git a/coreutils/uuencode.c b/coreutils/uuencode.c
index 49b2d9189..fd3326d80 100644
--- a/coreutils/uuencode.c
+++ b/coreutils/uuencode.c
@@ -29,7 +29,7 @@
 #include "busybox.h"
 
 /* Conversion table.  for base 64 */
-static char tbl_base64[65] = {
+static const char tbl_base64[65] = {
 	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
 	'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
 	'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
@@ -41,7 +41,7 @@ static char tbl_base64[65] = {
 	'=' /* termination character */
 };
 
-static char tbl_std[65] = {
+static const char tbl_std[65] = {
 	'`', '!', '"', '#', '$', '%', '&', '\'',
 	'(', ')', '*', '+', ',', '-', '.', '/',
 	'0', '1', '2', '3', '4', '5', '6', '7',
@@ -92,40 +92,36 @@ int uuencode_main(int argc, char **argv)
 	int write_size = dst_buf_size;
 	struct stat stat_buf;
 	FILE *src_stream = stdin;
-	char *tbl = tbl_std;
+	const char *tbl;
 	size_t size;
 	mode_t mode;
-	int opt;
 	RESERVE_CONFIG_BUFFER(src_buf, SRC_BUF_SIZE + 1);
 	RESERVE_CONFIG_BUFFER(dst_buf, DST_BUF_SIZE + 1);
 
-	while ((opt = getopt(argc, argv, "m")) != -1) {
-		switch (opt) {
-		case 'm':
-			tbl = tbl_base64;
-   			break;
-		default:
-			show_usage();
-		}
+	tbl = tbl_std;
+	if (bb_getopt_ulflags(argc, argv, "m") & 1) {
+		tbl = tbl_base64;
 	}
 
 	switch (argc - optind) {
 		case 2:
-			src_stream = xfopen(argv[optind], "r");
-			stat(argv[optind], &stat_buf);
+			src_stream = bb_xfopen(argv[optind], "r");
+			if (stat(argv[optind], &stat_buf) < 0) {
+				bb_perror_msg_and_die("stat");
+			}
 			mode = stat_buf.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO);
 			if (src_stream == stdout) {
-				printf("NULL\n");
+				puts("NULL");
 			}
 			break;
 		case 1:
 			mode = 0666 & ~umask(0666);
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 	}
 
-	printf("begin%s %o %s", tbl == tbl_std ? "" : "-base64", mode, argv[argc - 1]);
+	bb_printf("begin%s %o %s", tbl == tbl_std ? "" : "-base64", mode, argv[argc - 1]);
 
 	while ((size = fread(src_buf, 1, src_buf_size, src_stream)) > 0) {
 		if (size != src_buf_size) {
@@ -142,10 +138,12 @@ int uuencode_main(int argc, char **argv)
 			putchar(tbl[size]);
 		}
 		if (fwrite(dst_buf, 1, write_size, stdout) != write_size) {
-			perror("Couldnt finish writing");
+			bb_perror_msg_and_die(bb_msg_write_error);
 		}
 	}
-	printf(tbl == tbl_std ? "\n`\nend\n" : "\n====\n");
+	bb_printf(tbl == tbl_std ? "\n`\nend\n" : "\n====\n");
+
+	bb_xferror(src_stream, "source");	/* TODO - Fix this! */
 
-	return(EXIT_SUCCESS);
+	bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 }
diff --git a/coreutils/watch.c b/coreutils/watch.c
index c275f3bb3..f9f40189e 100644
--- a/coreutils/watch.c
+++ b/coreutils/watch.c
@@ -20,67 +20,76 @@
  *
  */
 
-/* getopt not needed */
+/* BB_AUDIT SUSv3 N/A */
+/* BB_AUDIT GNU defects -- only option -n is supported. */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Removed dependency on date_main(), added proper error checking, and
+ * reduced size.
+ */
 
 #include <stdio.h>
-#include <errno.h>
-#include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
+#include <limits.h>
+#include <time.h>
+#include <assert.h>
+#include <unistd.h>
 #include <sys/wait.h>
 #include "busybox.h"
 
 extern int watch_main(int argc, char **argv)
 {
-	const char date_argv[2][10] = { "date", "" };
 	const int header_len = 40;
-	char header[header_len + 1];
-	int period = 2;
-	char **cargv;
-	int cargc;
+	time_t t;
 	pid_t pid;
+	unsigned period = 2;
 	int old_stdout;
-	int i;
+	int len, len2;
+	char **watched_argv;
+	char header[header_len + 1];
 
 	if (argc < 2) {
-		show_usage();
-	} else {
-		cargv = argv + 1;
-		cargc = argc - 1;
-
-		/* don't use getopt, because it permutes the arguments */
-		if (argc >= 3 && !strcmp(argv[1], "-n")) {
-			period = strtol(argv[2], NULL, 10);
-			if (period < 1)
-				show_usage();
-			cargv += 2;
-			cargc -= 2;
-		}
+		bb_show_usage();
 	}
 
-
-	/* create header */
-	snprintf(header, header_len, "Every %ds: ", period);
-	for (i = 0; i < cargc && (strlen(header) + strlen(cargv[i]) < header_len);
-		 i++) {
-		strcat(header, cargv[i]);
-		strcat(header, " ");
+	/* don't use getopt, because it permutes the arguments */
+	++argv;
+	if ((argc > 3) && !strcmp(*argv, "-n")
+	) {
+		period = bb_xgetularg10_bnd(argv[1], 1, UINT_MAX);
+		argv += 2;
 	}
+	watched_argv = argv;
 
-	/* fill with blanks */
-	for (i = strlen(header); i < header_len; i++)
-		header[i] = ' ';
+	/* create header */
 
-	header[header_len - 1] = '\0';
+	len = snprintf(header, header_len, "Every %ds:", period);
+	/* Don't bother checking for len < 0, as it should never happen.
+	 * But, just to be prepared... */
+	assert(len >= 0);
+	do {
+		len2 = strlen(*argv);
+		if (len + len2 >= header_len-1) {
+			break;
+		}
+		header[len] = ' ';
+		memcpy(header+len+1, *argv, len2);
+		len += len2+1;
+	} while (*++argv);
 
+	header[len] = 0;
 
 	/* thanks to lye, who showed me how to redirect stdin/stdout */
 	old_stdout = dup(1);
 
 	while (1) {
-		printf("\033[H\033[J%s", header);
-		date_main(1, (char **) date_argv);
-		printf("\n");
+		time(&t);
+		/* Use dprintf to avoid fflush()ing stdout. */
+		if (dprintf(1, "\033[H\033[J%-*s%s\n", header_len, header, ctime(&t)) < 0) {
+			bb_perror_msg_and_die("printf");
+		}
 
 		pid = vfork();	/* vfork, because of ucLinux */
 		if (pid > 0) {
@@ -91,13 +100,11 @@ extern int watch_main(int argc, char **argv)
 			//child
 			close(1);
 			dup(old_stdout);
-			if (execvp(*cargv, cargv))
-				error_msg_and_die("Couldn't run command\n");
+			if (execvp(*watched_argv, watched_argv)) {
+				bb_error_msg_and_die("Couldn't run command\n");
+			}
 		} else {
-			error_msg_and_die("Couldn't vfork\n");
+			bb_error_msg_and_die("Couldn't vfork\n");
 		}
 	}
-
-
-	return EXIT_SUCCESS;
 }
diff --git a/coreutils/wc.c b/coreutils/wc.c
index 8e3b5bbf4..779901524 100644
--- a/coreutils/wc.c
+++ b/coreutils/wc.c
@@ -1,8 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini wc implementation for busybox
+ * wc implementation for busybox
  *
- * Copyright (C) 2000  Edward Betts <edward@debian.org>
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,159 +20,208 @@
  *
  */
 
+/* BB_AUDIT SUSv3 _NOT_ compliant -- option -m is not currently supported. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/wc.html */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Rewritten to fix a number of problems and do some size optimizations.
+ * Problems in the previous busybox implementation (besides bloat) included: 
+ *  1) broken 'wc -c' optimization (read note below)
+ *  2) broken handling of '-' args
+ *  3) no checking of ferror on EOF returns
+ *  4) isprint() wasn't considered when word counting.
+ *
+ * TODO:
+ *
+ * When locale support is enabled, count multibyte chars in the '-m' case.
+ *
+ * NOTES:
+ *
+ * The previous busybox wc attempted an optimization using stat for the
+ * case of counting chars only.  I omitted that because it was broken.
+ * It didn't take into account the possibility of input coming from a
+ * pipe, or input from a file with file pointer not at the beginning.
+ *
+ * To implement such a speed optimization correctly, not only do you
+ * need the size, but also the file position.  Note also that the
+ * file position may be past the end of file.  Consider the example
+ * (adapted from example in gnu wc.c)
+ *
+ *      echo hello > /tmp/testfile &&
+ *      (dd ibs=1k skip=1 count=0 &> /dev/null ; wc -c) < /tmp/testfile
+ *
+ * for which 'wc -c' should output '0'.
+ */
+
 #include <stdio.h>
-#include <getopt.h>
-#include <string.h>
 #include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
 #include "busybox.h"
 
-enum print_e {
-	print_lines = 1,
-	print_words = 2,
-	print_chars = 4,
-	print_length = 8
+#ifdef CONFIG_LOCALE_SUPPORT
+#include <locale.h>
+#include <ctype.h>
+#define isspace_given_isprint(c) isspace(c)
+#else
+#undef isspace
+#undef isprint
+#define isspace(c) ((((c) == ' ') || (((unsigned int)((c) - 9)) <= (13 - 9))))
+#define isprint(c) (((unsigned int)((c) - 0x20)) <= (0x7e - 0x20))
+#define isspace_given_isprint(c) ((c) == ' ')
+#endif
+
+enum {
+	WC_LINES	= 0,
+	WC_WORDS	= 1,
+	WC_CHARS	= 2,
+	WC_LENGTH	= 3
 };
 
-static unsigned int total_lines = 0;
-static unsigned int total_words = 0;
-static unsigned int total_chars = 0;
-static unsigned int max_length = 0;
-static char print_type = 0;
+/* Note: If this changes, remember to change the initialization of
+ *       'name' in wc_main.  It needs to point to the terminating nul. */
+static const char wc_opts[] = "lwcL";	/* READ THE WARNING ABOVE! */
 
-static void print_counts(const unsigned int lines, const unsigned int words,
-	const unsigned int chars, const unsigned int length, const char *name)
-{
-	int output = 0;
+enum {
+	OP_INC_LINE	= 1, /* OP_INC_LINE must be 1. */
+	OP_SPACE	= 2,
+	OP_NEWLINE	= 4,
+	OP_TAB		= 8,
+	OP_NUL		= 16,
+};
 
-	if (print_type & print_lines) {
-		printf("%7d", lines);
-		output++;
-	}
-	if (print_type & print_words) {
-		if (output++)
-			putchar(' ');
-		printf("%7d", words);
-	}
-	if (print_type & print_chars) {
-		if (output++)
-			putchar(' ');
-		printf("%7d", chars);
-	}
-	if (print_type & print_length) {
-		if (output++)
-			putchar(' ');
-		printf("%7d", length);
-	}
-	if (*name) {
-		printf(" %s", name);
-	}
-	putchar('\n');
-}
+/* Note: If fmt_str changes, the offsets to 's' in the OUTPUT section
+ *       will need to be updated. */
+static const char fmt_str[] = " %7u\0 %s\n";
+static const char total_str[] = "total";
 
-static void wc_file(FILE * file, const char *name)
+int wc_main(int argc, char **argv)
 {
-	unsigned int lines = 0;
-	unsigned int words = 0;
-	unsigned int chars = 0;
-	unsigned int length = 0;
-	unsigned int linepos = 0;
-	char in_word = 0;
+	FILE *fp;
+	const char *s;
+	unsigned int *pcounts;
+	unsigned int counts[4];
+	unsigned int totals[4];
+	unsigned int linepos;
+	unsigned int u;
+	int num_files = 0;
 	int c;
-
-	while ((c = getc(file)) != EOF) {
-		chars++;
-		switch (c) {
-		case '\n':
-			lines++;
-		case '\r':
-		case '\f':
-			if (linepos > length)
-				length = linepos;
-			linepos = 0;
-			goto word_separator;
-		case '\t':
-			linepos += 8 - (linepos % 8);
-			goto word_separator;
-		case ' ':
-			linepos++;
-		case '\v':
-word_separator:
-			if (in_word) {
-				in_word = 0;
-				words++;
-			}
-			break;
-		default:
-			linepos++;
-			in_word = 1;
-			break;
-		}
-	}
-	if (linepos > length) {
-		length = linepos;
-	}
-	if (in_word) {
-		words++;
+	char status = EXIT_SUCCESS;
+	char in_word;
+	char print_type;
+		
+	print_type = bb_getopt_ulflags(argc, argv, wc_opts);
+	
+	if (print_type == 0) {
+		print_type = (1 << WC_LINES) | (1 << WC_WORDS) | (1 << WC_CHARS);
 	}
-	print_counts(lines, words, chars, length, name);
-	total_lines += lines;
-	total_words += words;
-	total_chars += chars;
-	if (length > max_length) {
-		max_length = length;
+	
+	argv += optind;
+	if (!*argv) {
+		*--argv = (char *) bb_msg_standard_input;
 	}
-}
-
-int wc_main(int argc, char **argv)
-{
-	int opt;
-
-	while ((opt = getopt(argc, argv, "clLw")) > 0) {
-		switch (opt) {
-			case 'c':
-				print_type |= print_chars;
-				break;
-			case 'l':
-				print_type |= print_lines;
-				break;
-			case 'L':
-				print_type |= print_length;
-				break;
-			case 'w':
-				print_type |= print_words;
-				break;
-			default:
-				show_usage();
+	
+	memset(totals, 0, sizeof(totals));
+	
+	pcounts = counts;
+	
+	do {
+		++num_files;
+		if (!(fp = bb_wfopen_input(*argv))) {
+			status = EXIT_FAILURE;
+			continue;
 		}
-	}
-
-	if (print_type == 0) {
-		print_type = print_lines | print_words | print_chars;
-	}
-
-	if (argv[optind] == NULL || strcmp(argv[optind], "-") == 0) {
-		wc_file(stdin, "");
-	} else {
-		unsigned short num_files_counted = 0;
-		while (optind < argc) {
-			if (print_type == print_chars) {
-				struct stat statbuf;
-				stat(argv[optind], &statbuf);
-				print_counts(0, 0, statbuf.st_size, 0, argv[optind]);
-				total_chars += statbuf.st_size;
+		
+		memset(counts, 0, sizeof(counts));
+		linepos = 0;
+		in_word = 0;
+		
+		do {
+			++counts[WC_CHARS];
+			c = getc(fp);
+			if (isprint(c)) {
+				++linepos;
+				if (!isspace_given_isprint(c)) {
+					in_word = 1;
+					continue;
+				}
+			} else if (((unsigned int)(c - 9)) <= 4) {
+				/* \t  9
+				 * \n 10
+				 * \v 11
+				 * \f 12
+				 * \r 13
+				 */
+				if (c == '\t') {
+					linepos = (linepos | 7) + 1;
+				} else {			/* '\n', '\r', '\f', or '\v' */
+				DO_EOF:
+					if (linepos > counts[WC_LENGTH]) {
+						counts[WC_LENGTH] = linepos;
+					}
+					if (c == '\n') {
+						++counts[WC_LINES];
+					}
+					if (c != '\v') {
+						linepos = 0;
+					}
+				}
+			} else if (c == EOF) {
+				if (ferror(fp)) {
+					bb_perror_msg("%s", *argv);
+					status = EXIT_FAILURE;
+				}
+				--counts[WC_CHARS];
+				goto DO_EOF;		/* Treat an EOF as '\r'. */
 			} else {
-				FILE *file;
-				file = xfopen(argv[optind], "r");
-				wc_file(file, argv[optind]);
-				fclose(file);
+				continue;
+			}
+			
+			counts[WC_WORDS] += in_word;
+			in_word = 0;
+			if (c == EOF) {
+				break;
 			}
-			optind++;
-			num_files_counted++;
+		} while (1);
+		
+		if (totals[WC_LENGTH] < counts[WC_LENGTH]) {
+			totals[WC_LENGTH] = counts[WC_LENGTH];
 		}
-		if (num_files_counted > 1) {
-			print_counts(total_lines, total_words, total_chars, max_length, "total");
+		totals[WC_LENGTH] -= counts[WC_LENGTH];
+		
+		bb_fclose_nonstdin(fp);
+		
+	OUTPUT:
+		s = fmt_str + 1;			/* Skip the leading space on 1st pass. */
+		u = 0;
+		do {
+			if (print_type & (1 << u)) {
+				bb_printf(s, pcounts[u]);
+				s = fmt_str;		/* Ok... restore the leading space. */
+			}
+			totals[u] += pcounts[u];
+		} while (++u < 4);
+		
+		s += 8;						/* Set the format to the empty string. */
+		
+		if (*argv != bb_msg_standard_input) {
+			s -= 3;					/* We have a name, so do %s conversion. */
 		}
+		bb_printf(s, *argv);
+		
+	} while (*++argv);
+	
+	/* If more than one file was processed, we want the totals.  To save some
+	 * space, we set the pcounts ptr to the totals array.  This has the side
+	 * effect of trashing the totals array after outputting it, but that's
+	 * irrelavent since we no longer need it. */
+	if (num_files > 1) {
+		num_files = 0;				/* Make sure we don't get here again. */
+		*--argv = (char *) total_str;
+		pcounts = totals;
+		goto OUTPUT;
 	}
-
-	return(EXIT_SUCCESS);
+	
+	bb_fflush_stdout_and_exit(status);
 }
diff --git a/coreutils/who.c b/coreutils/who.c
index 3da7ed1c7..1bf552056 100644
--- a/coreutils/who.c
+++ b/coreutils/who.c
@@ -23,7 +23,7 @@
 #include <errno.h>
 #include <string.h>
 #include <time.h>
-#include <busybox.h>
+#include "busybox.h"
 
 extern int who_main(int argc, char **argv)
 {
@@ -33,7 +33,7 @@ extern int who_main(int argc, char **argv)
     time_t      now, idle; 
 
     if (argc > 1) 
-        show_usage();
+        bb_show_usage();
 
     setutent();
     devlen = sizeof("/dev/") - 1;
@@ -81,5 +81,3 @@ extern int who_main(int argc, char **argv)
 
     return 0;
 }
-       
-     
diff --git a/coreutils/whoami.c b/coreutils/whoami.c
index a9d6ecf26..f93034d3a 100644
--- a/coreutils/whoami.c
+++ b/coreutils/whoami.c
@@ -20,7 +20,7 @@
  *
  */
 
-/* getopt not needed */
+/* BB_AUDIT SUSv3 N/A -- Matches GNU behavior. */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -30,14 +30,15 @@
 extern int whoami_main(int argc, char **argv)
 {
 	char user[9];
-	uid_t uid = geteuid();
+	uid_t uid;
 
 	if (argc > 1)
-		show_usage();
+		bb_show_usage();
 
+	uid = geteuid();
 	if (my_getpwuid(user, uid)) {
 		puts(user);
-		return EXIT_SUCCESS;
+		bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 	}
-	error_msg_and_die("cannot find username for UID %u", (unsigned) uid);
+	bb_error_msg_and_die("cannot find username for UID %u", (unsigned) uid);
 }
diff --git a/coreutils/yes.c b/coreutils/yes.c
index 7d9596d0b..74f7571cf 100644
--- a/coreutils/yes.c
+++ b/coreutils/yes.c
@@ -1,8 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini yes implementation for busybox
+ * yes implementation for busybox
  *
- * Copyright (C) 2000  Edward Betts <edward@debian.org>.
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -20,7 +20,12 @@
  *
  */
 
-/* getopt not needed */
+/* BB_AUDIT SUSv3 N/A -- Matches GNU behavior. */
+
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Size reductions and removed redundant applet name prefix from error messages.
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -28,26 +33,24 @@
 
 extern int yes_main(int argc, char **argv)
 {
-	int i;
-
-	if (argc >= 2 && *argv[1] == '-')
-		show_usage();
+	static const char fmt_str[] = " %s";
+	const char *fmt;
+	char **first_arg;
 
-	if (argc == 1) {
-		while (1)
-			if (puts("y") == EOF) {
-				perror("yes");
-				return EXIT_FAILURE;
-			}
+	*argv = "y";
+	if (argc != 1) {
+		++argv;
 	}
 
-	while (1)
-		for (i = 1; i < argc; i++)
-			if (fputs(argv[i], stdout) == EOF
-				|| putchar(i == argc - 1 ? '\n' : ' ') == EOF) {
-				perror("yes");
-				return EXIT_FAILURE;
-			}
+	first_arg = argv;
+	do {
+		fmt = fmt_str + 1;
+		do {
+			bb_printf(fmt, *argv);
+			fmt = fmt_str;
+		} while (*++argv);
+		argv = first_arg;
+	} while (putchar('\n') != EOF);
 
-	return EXIT_SUCCESS;
+	bb_perror_nomsg_and_die();
 }
diff --git a/debianutils/mktemp.c b/debianutils/mktemp.c
index bc47d0af0..9d8de2174 100644
--- a/debianutils/mktemp.c
+++ b/debianutils/mktemp.c
@@ -32,7 +32,7 @@
 extern int mktemp_main(int argc, char **argv)
 {
 	if (argc != 2 && (argc != 3 || strcmp(argv[1], "-q")))
-		show_usage();
+		bb_show_usage();
 	if(mkstemp(argv[argc-1]) < 0)
 		return EXIT_FAILURE;
 	(void) puts(argv[argc-1]);
diff --git a/debianutils/readlink.c b/debianutils/readlink.c
index da5259038..d8d7e8c2d 100644
--- a/debianutils/readlink.c
+++ b/debianutils/readlink.c
@@ -32,7 +32,7 @@ int readlink_main(int argc, char **argv)
 	/* no options, no getopt */
 
 	if (argc != 2)
-		show_usage();
+		bb_show_usage();
 
 	buf = xreadlink(argv[1]);
 	if (!buf)
diff --git a/debianutils/run_parts.c b/debianutils/run_parts.c
index a6ad81096..a941e1fc8 100644
--- a/debianutils/run_parts.c
+++ b/debianutils/run_parts.c
@@ -78,7 +78,7 @@ int run_parts_main(int argc, char **argv)
 			{
 				const unsigned int mask = (unsigned int) strtol(optarg, NULL, 8);
 				if (mask > 07777) {
-					perror_msg_and_die("bad umask value");
+					bb_perror_msg_and_die("bad umask value");
 				}
 				umask(mask);
 			}
@@ -90,13 +90,13 @@ int run_parts_main(int argc, char **argv)
 			args[argcount++] = optarg;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
 	/* We require exactly one argument: the directory name */
 	if (optind != (argc - 1)) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	args[0] = argv[optind];
diff --git a/debianutils/start_stop_daemon.c b/debianutils/start_stop_daemon.c
index 576526183..a1c2c21c2 100644
--- a/debianutils/start_stop_daemon.c
+++ b/debianutils/start_stop_daemon.c
@@ -74,7 +74,7 @@ parse_options(int argc, char * const *argv)
 			break;
 		case 's':
 			if (sscanf(optarg, "%d", &signal_nr) != 1)
-				error_msg_and_die ("-s takes a numeric argument");
+				bb_error_msg_and_die ("-s takes a numeric argument");
 			break;
 		case 'u':
 			userspec = optarg;
@@ -86,21 +86,21 @@ parse_options(int argc, char * const *argv)
 			fork_before_exec = 1;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
 	if (start == stop)
-		error_msg_and_die ("need one of -S or -K");
+		bb_error_msg_and_die ("need one of -S or -K");
 
 	if (!execname && !userspec)
-		error_msg_and_die ("need at least one of -x or -u");
+		bb_error_msg_and_die ("need at least one of -x or -u");
 
 	if (!startas)
 		startas = execname;
 
 	if (start && !startas)
-		error_msg_and_die ("-S needs -x or -a");
+		bb_error_msg_and_die ("-S needs -x or -a");
 }
 
 
@@ -185,7 +185,7 @@ do_procfs(void)
 
 	procdir = opendir("/proc");
 	if (!procdir)
-		perror_msg_and_die ("opendir /proc");
+		bb_perror_msg_and_die ("opendir /proc");
 
 	foundany = 0;
 	while ((entry = readdir(procdir)) != NULL) {
@@ -196,7 +196,7 @@ do_procfs(void)
 	}
 	closedir(procdir);
 	if (!foundany)
-		error_msg_and_die ("nothing in /proc - not mounted?");
+		bb_error_msg_and_die ("nothing in /proc - not mounted?");
 }
 
 
@@ -214,7 +214,7 @@ do_stop(void)
 	else if (userspec)
 		sprintf(what, "process(es) owned by `%s'", userspec);
 	else
-		error_msg_and_die ("internal error, please report");
+		bb_error_msg_and_die ("internal error, please report");
 
 	if (!found) {
 		printf("no %s found; none killed.\n", what);
@@ -225,7 +225,7 @@ do_stop(void)
 			p->pid = -p->pid;
 			killed++;
 		} else {
-			perror_msg("warning: failed to kill %d:", p->pid);
+			bb_perror_msg("warning: failed to kill %d:", p->pid);
 		}
 	}
 	if (killed) {
@@ -262,10 +262,10 @@ start_stop_daemon_main(int argc, char **argv)
 	*--argv = startas;
 	if (fork_before_exec) {
 		if (daemon(0, 0) == -1)
-			perror_msg_and_die ("unable to fork");
+			bb_perror_msg_and_die ("unable to fork");
 	}
 	setsid();
 	execv(startas, argv);
-	perror_msg_and_die ("unable to start %s", startas);
+	bb_perror_msg_and_die ("unable to start %s", startas);
 }
 
diff --git a/debianutils/which.c b/debianutils/which.c
index b2af5a8ea..fbcfb371b 100644
--- a/debianutils/which.c
+++ b/debianutils/which.c
@@ -34,7 +34,7 @@ extern int which_main(int argc, char **argv)
 	int i, count=1, found, status = EXIT_SUCCESS;
 
 	if (argc <= 1 || **(argv + 1) == '-')
-		show_usage();
+		bb_show_usage();
 	argc--;
 
 	path_list = getenv("PATH");
diff --git a/editors/awk.c b/editors/awk.c
index 44c2f45b2..0f8cf94f4 100644
--- a/editors/awk.c
+++ b/editors/awk.c
@@ -463,7 +463,7 @@ static const char EMSG_NO_MATH[] = "Math support is not compiled in";
 
 static void syntax_error(const char * const message)
 {
-	error_msg("%s:%i: %s", programname, lineno, message);
+	bb_error_msg("%s:%i: %s", programname, lineno, message);
 	awk_exit(1);
 }
 
@@ -546,7 +546,7 @@ static void *hash_find(xhash *hash, char *name) {
 		if (++hash->nel / hash->csize > 10)
 			hash_rebuild(hash);
 
-		l = xstrlen(name) + 1;
+		l = bb_strlen(name) + 1;
 		hi = xcalloc(sizeof(hash_item) + l, 1);
 		memcpy(hi->name, name, l);
 
@@ -571,7 +571,7 @@ static void hash_remove(xhash *hash, char *name) {
 	while (*phi) {
 		hi = *phi;
 		if (strcmp(hi->name, name) == 0) {
-			hash->glen -= (xstrlen(name) + 1);
+			hash->glen -= (bb_strlen(name) + 1);
 			hash->nel--;
 			*phi = hi->next;
 			free(hi);
@@ -609,7 +609,7 @@ static char nextchar(char **s) {
 
 	c = *((*s)++);
 	pps = *s;
-	if (c == '\\') c = process_escape_sequence((const char**)s);
+	if (c == '\\') c = bb_process_escape_sequence((const char**)s);
 	if (c == '\\' && *s == pps) c = *((*s)++);
 	return c;
 }
@@ -621,7 +621,7 @@ static inline int isalnum_(int c) {
 
 static FILE *afopen(const char *path, const char *mode) {
 
-	return (*path == '-' && *(path+1) == '\0') ? stdin : xfopen(path, mode);
+	return (*path == '-' && *(path+1) == '\0') ? stdin : bb_xfopen(path, mode);
 }
 
 /* -------- working with variables (set/get/copy/etc) -------- */
@@ -683,7 +683,7 @@ static var *setvar_p(var *v, char *value) {
 /* same as setvar_p but make a copy of string */
 static var *setvar_s(var *v, char *value) {
 
-	return setvar_p(v, (value && *value) ? xstrdup(value) : NULL);
+	return setvar_p(v, (value && *value) ? bb_xstrdup(value) : NULL);
 }
 
 /* same as setvar_s but set USER flag */
@@ -720,7 +720,7 @@ static char *getvar_s(var *v) {
 	/* if v is numeric and has no cached string, convert it to string */
 	if ((v->type & (VF_NUMBER | VF_CACHED)) == VF_NUMBER) {
 		fmt_num(buf, MAXVARFMT, getvar_s(V[CONVFMT]), v->number, TRUE);
-		v->string = xstrdup(buf);
+		v->string = bb_xstrdup(buf);
 		v->type |= VF_CACHED;
 	}
 	return (v->string == NULL) ? "" : v->string;
@@ -755,7 +755,7 @@ static var *copyvar(var *dest, var *src) {
 		dest->type |= (src->type & ~VF_DONTTOUCH);
 		dest->number = src->number;
 		if (src->string)
-			dest->string = xstrdup(src->string);
+			dest->string = bb_xstrdup(src->string);
 	}
 	handle_special(dest);
 	return dest;
@@ -903,7 +903,7 @@ static unsigned long next_token(unsigned long expected) {
 					syntax_error(EMSG_UNEXP_EOS);
 				if ((*s++ = *p++) == '\\') {
 					pp = p;
-					*(s-1) = process_escape_sequence((const char **)&p);
+					*(s-1) = bb_process_escape_sequence((const char **)&p);
 					if (*pp == '\\') *s++ = '\\';
 					if (p == pp) *s++ = *p++;
 				}
@@ -1153,7 +1153,7 @@ static node *chain_node(unsigned long info) {
 	if (seq->programname != programname) {
 		seq->programname = programname;
 		n = chain_node(OC_NEWSOURCE);
-		n->l.s = xstrdup(programname);
+		n->l.s = bb_xstrdup(programname);
 	}
 
 	n = seq->last;
@@ -1373,7 +1373,7 @@ static node *mk_splitter(char *s, tsplitter *spl) {
 		regfree(re);
 		regfree(ire);
 	}
-	if (xstrlen(s) > 1) {
+	if (bb_strlen(s) > 1) {
 		mk_re_node(s, n, re);
 	} else {
 		n->info = (unsigned long) *s;
@@ -1441,7 +1441,7 @@ static int awk_split(char *s, node *spl, char **slist) {
 	regmatch_t pmatch[2];
 
 	/* in worst case, each char would be a separate field */
-	*slist = s1 = xstrndup(s, xstrlen(s) * 2 + 3);
+	*slist = s1 = bb_xstrndup(s, bb_strlen(s) * 2 + 3);
 
 	c[0] = c[1] = (char)spl->info;
 	c[2] = c[3] = '\0';
@@ -1536,12 +1536,12 @@ static void handle_special(var *v) {
 
 		/* recalculate $0 */
 		sep = getvar_s(V[OFS]);
-		sl = xstrlen(sep);
+		sl = bb_strlen(sep);
 		b = NULL;
 		len = 0;
 		for (i=0; i<n; i++) {
 			s = getvar_s(&Fields[i]);
-			l = xstrlen(s);
+			l = bb_strlen(s);
 			if (b) {
 				memcpy(b+len, sep, sl);
 				len += sl;
@@ -1744,7 +1744,7 @@ static char *awk_printf(node *n) {
 	var *v, *arg;
 
 	v = nvalloc(1);
-	fmt = f = xstrdup(getvar_s(evaluate(nextarg(&n), v)));
+	fmt = f = bb_xstrdup(getvar_s(evaluate(nextarg(&n), v)));
 
 	i = 0;
 	while (*f) {
@@ -1767,7 +1767,7 @@ static char *awk_printf(node *n) {
 
 		} else if (c == 's') {
 		    s1 = getvar_s(arg);
-			qrealloc(&b, incr+i+xstrlen(s1), &bsize);
+			qrealloc(&b, incr+i+bb_strlen(s1), &bsize);
 			i += sprintf(b+i, s, s1);
 
 		} else {
@@ -1807,7 +1807,7 @@ static int awk_sub(node *rn, char *repl, int nm, var *src, var *dest, int ex) {
 
 	i = di = 0;
 	sp = getvar_s(src);
-	rl = xstrlen(repl);
+	rl = bb_strlen(repl);
 	while (regexec(re, sp, 10, pmatch, sp==getvar_s(src) ? 0:REG_NOTBOL) == 0) {
 		so = pmatch[0].rm_so;
 		eo = pmatch[0].rm_eo;
@@ -1920,7 +1920,7 @@ static var *exec_builtin(node *op, var *res) {
 		break;
 
 	  case B_ss:
-		l = xstrlen(as[0]);
+		l = bb_strlen(as[0]);
 		i = getvar_i(av[1]) - 1;
 		if (i>l) i=l; if (i<0) i=0;
 		n = (nargs > 2) ? getvar_i(av[2]) : l-i;
@@ -1938,7 +1938,7 @@ static var *exec_builtin(node *op, var *res) {
 	  case B_up:
 		to_xxx = toupper;
 lo_cont:
-		s1 = s = xstrdup(as[0]);
+		s1 = s = bb_xstrdup(as[0]);
 		while (*s1) {
 			*s1 = (*to_xxx)(*s1);
 			s1++;
@@ -1948,8 +1948,8 @@ lo_cont:
 
 	  case B_ix:
 		n = 0;
-		ll = xstrlen(as[1]);
-		l = xstrlen(as[0]) - ll;
+		ll = bb_strlen(as[1]);
+		l = bb_strlen(as[0]) - ll;
 		if (ll > 0 && l >= 0) {
 			if (! icase) {
 				s = strstr(as[0], as[1]);
@@ -2112,10 +2112,10 @@ static var *evaluate(node *op, var *res) {
 				if (! X.rsm->F) {
 					if (opn == '|') {
 						if((X.rsm->F = popen(R.s, "w")) == NULL)
-							perror_msg_and_die("popen");
+							bb_perror_msg_and_die("popen");
 						X.rsm->is_pipe = 1;
 					} else {
-						X.rsm->F = xfopen(R.s, opn=='w' ? "w" : "a");
+						X.rsm->F = bb_xfopen(R.s, opn=='w' ? "w" : "a");
 					}
 				}
 				X.F = X.rsm->F;
@@ -2269,7 +2269,7 @@ re_cont:
 						X.rsm->F = popen(L.s, "r");
 						X.rsm->is_pipe = TRUE;
 					} else {
-						X.rsm->F = fopen(L.s, "r");		/* not xfopen! */
+						X.rsm->F = fopen(L.s, "r");		/* not bb_xfopen! */
 					}
 				}
 			} else {
@@ -2351,7 +2351,7 @@ re_cont:
 			  case F_le:
 			  	if (! op1)
 					L.s = getvar_s(V[F0]);
-				R.d = xstrlen(L.s);
+				R.d = bb_strlen(L.s);
 				break;
 
 			  case F_sy:
@@ -2439,12 +2439,12 @@ re_cont:
 		  /* concatenation (" ") and index joining (",") */
 		  case XC( OC_CONCAT ):
 		  case XC( OC_COMMA ):
-			opn = xstrlen(L.s) + xstrlen(R.s) + 2;
+			opn = bb_strlen(L.s) + bb_strlen(R.s) + 2;
 		  	X.s = (char *)xmalloc(opn);
 			strcpy(X.s, L.s);
 			if ((opinfo & OPCLSMASK) == OC_COMMA) {
 				L.s = getvar_s(V[SUBSEP]);
-				X.s = (char *)xrealloc(X.s, opn + xstrlen(L.s));
+				X.s = (char *)xrealloc(X.s, opn + bb_strlen(L.s));
 				strcat(X.s, L.s);
 			}
 			strcat(X.s, R.s);
@@ -2554,7 +2554,7 @@ static int is_assignment(char *expr) {
 
 	char *exprc, *s, *s0, *s1;
 
-	exprc = xstrdup(expr);
+	exprc = bb_xstrdup(expr);
 	if (!isalnum_(*exprc) || (s = strchr(exprc, '=')) == NULL) {
 		free(exprc);
 		return FALSE;
@@ -2649,7 +2649,7 @@ extern int awk_main(int argc, char **argv) {
 	}
 
 	for (envp=environ; *envp; envp++) {
-		s = xstrdup(*envp);
+		s = bb_xstrdup(*envp);
 		s1 = strchr(s, '=');
 		*(s1++) = '\0';
 		setvar_u(findvar(iamarray(V[ENVIRON]), s), s1);
@@ -2663,7 +2663,7 @@ extern int awk_main(int argc, char **argv) {
 				break;
 			case 'v':
 				if (! is_assignment(optarg))
-					show_usage();
+					bb_show_usage();
 				break;
 			case 'f':
 				from_file = TRUE;
@@ -2680,17 +2680,17 @@ extern int awk_main(int argc, char **argv) {
 				free(s);
 				break;
 			case 'W':
-				error_msg("Warning: unrecognized option '-W %s' ignored\n", optarg);
+				bb_error_msg("Warning: unrecognized option '-W %s' ignored\n", optarg);
 				break;
 
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
 	if (!from_file) {
 		if (argc == optind)
-			show_usage();
+			bb_show_usage();
 		programname="cmd. line";
 		parse_program(argv[optind++]);
 
diff --git a/editors/sed.c b/editors/sed.c
index 8bd627a9c..2ff028498 100644
--- a/editors/sed.c
+++ b/editors/sed.c
@@ -200,7 +200,7 @@ static int get_address(char *delimiter, char *my_str, int *linenum, regex_t **re
 		}
 		idx = index_of_next_unescaped_regexp_delim(*delimiter, my_str, ++idx);
 		if (idx == -1) {
-			error_msg_and_die("unterminated match expression");
+			bb_error_msg_and_die("unterminated match expression");
 		}
 		my_str[idx] = '\0';
 		*regex = (regex_t *)xmalloc(sizeof(regex_t));
@@ -230,7 +230,7 @@ static int parse_subst_cmd(sed_cmd_t * const sed_cmd, const char *substr)
 	/* verify that the 's' is followed by something.  That something
 	 * (typically a 'slash') is now our regexp delimiter... */
 	if (substr[idx] == '\0')
-		error_msg_and_die("bad format in substitution expression");
+		bb_error_msg_and_die("bad format in substitution expression");
 	else
 	    sed_cmd->delimiter=substr[idx];
 
@@ -238,8 +238,8 @@ static int parse_subst_cmd(sed_cmd_t * const sed_cmd, const char *substr)
 	oldidx = idx+1;
 	idx = index_of_next_unescaped_regexp_delim(sed_cmd->delimiter, substr, ++idx);
 	if (idx == -1)
-		error_msg_and_die("bad format in substitution expression");
-	match = xstrndup(substr + oldidx, idx - oldidx);
+		bb_error_msg_and_die("bad format in substitution expression");
+	match = bb_xstrndup(substr + oldidx, idx - oldidx);
 
 	/* determine the number of back references in the match string */
 	/* Note: we compute this here rather than in the do_subst_command()
@@ -257,8 +257,8 @@ static int parse_subst_cmd(sed_cmd_t * const sed_cmd, const char *substr)
 	oldidx = idx+1;
 	idx = index_of_next_unescaped_regexp_delim(sed_cmd->delimiter, substr, ++idx);
 	if (idx == -1)
-		error_msg_and_die("bad format in substitution expression");
-	sed_cmd->replace = xstrndup(substr + oldidx, idx - oldidx);
+		bb_error_msg_and_die("bad format in substitution expression");
+	sed_cmd->replace = bb_xstrndup(substr + oldidx, idx - oldidx);
 
 	/* process the flags */
 	while (substr[++idx]) {
@@ -278,7 +278,7 @@ static int parse_subst_cmd(sed_cmd_t * const sed_cmd, const char *substr)
 				if (strchr(semicolon_whitespace, substr[idx]))
 					goto out;
 				/* else */
-				error_msg_and_die("bad option in substitution expression");
+				bb_error_msg_and_die("bad option in substitution expression");
 		}
 	}
 
@@ -317,7 +317,7 @@ static int parse_edit_cmd(sed_cmd_t *sed_cmd, const char *editstr)
 	 *
 	 */
 	if ((*editstr != '\\') || ((editstr[1] != '\n') && (editstr[1] != '\r'))) {
-		error_msg_and_die("bad format in edit expression");
+		bb_error_msg_and_die("bad format in edit expression");
 	}
 
 	/* store the edit line text */
@@ -390,20 +390,20 @@ static char *parse_cmd_str(sed_cmd_t * const sed_cmd, char *cmdstr)
 	/* handle edit cmds: (a)ppend, (i)nsert, and (c)hange */
 	else if (strchr("aic", sed_cmd->cmd)) {
 		if ((sed_cmd->end_line || sed_cmd->end_match) && sed_cmd->cmd != 'c')
-			error_msg_and_die("only a beginning address can be specified for edit commands");
+			bb_error_msg_and_die("only a beginning address can be specified for edit commands");
 		cmdstr += parse_edit_cmd(sed_cmd, cmdstr);
 	}
 	/* handle file cmds: (r)ead */
 	else if (sed_cmd->cmd == 'r') {
 		if (sed_cmd->end_line || sed_cmd->end_match)
-			error_msg_and_die("Command only uses one address");
+			bb_error_msg_and_die("Command only uses one address");
 		cmdstr += parse_file_cmd(sed_cmd, cmdstr);
 	}
 	/* if it wasnt a single-letter command that takes no arguments
 	 * then it must be an invalid command.
 	 */
 	else if (strchr("nNpPqd=", sed_cmd->cmd) == 0) {
-		error_msg_and_die("Unsupported command %c", sed_cmd->cmd);
+		bb_error_msg_and_die("Unsupported command %c", sed_cmd->cmd);
 	}
 
 	/* give back whatever's left over */
@@ -442,7 +442,7 @@ static char *add_cmd(sed_cmd_t *sed_cmd, char *cmdstr)
 		cmdstr++;
 		idx = get_address(&(sed_cmd->delimiter), cmdstr, &sed_cmd->end_line, &sed_cmd->end_match);
 		if (idx == 0) {
-			error_msg_and_die("get_address: no address found in string\n"
+			bb_error_msg_and_die("get_address: no address found in string\n"
 				"\t(you probably didn't check the string you passed me)");
 		}
 		cmdstr += idx;
@@ -465,7 +465,7 @@ static char *add_cmd(sed_cmd_t *sed_cmd, char *cmdstr)
 		 * with <blank>s.
 		 */
 		if (isblank(cmdstr[idx]) {
-			error_msg_and_die("blank follows '!'");
+			bb_error_msg_and_die("blank follows '!'");
 		}
 #else 
 		/* skip whitespace before the command */
@@ -478,7 +478,7 @@ static char *add_cmd(sed_cmd_t *sed_cmd, char *cmdstr)
 
 	/* last part (mandatory) will be a command */
 	if (*cmdstr == '\0')
-		error_msg_and_die("missing command");
+		bb_error_msg_and_die("missing command");
 
 	sed_cmd->cmd = *cmdstr;
 	cmdstr++;
@@ -517,14 +517,16 @@ static void load_cmd_file(char *filename)
 	FILE *cmdfile;
 	char *line;
 	char *nextline;
+	char *e;
 
-	cmdfile = xfopen(filename, "r");
+	cmdfile = bb_xfopen(filename, "r");
 
-	while ((line = get_line_from_file(cmdfile)) != NULL) {
+	while ((line = bb_get_line_from_file(cmdfile)) != NULL) {
 		/* if a line ends with '\' it needs the next line appended to it */
-		while (line[strlen(line)-2] == '\\' &&
-				(nextline = get_line_from_file(cmdfile)) != NULL) {
-			line = xrealloc(line, strlen(line) + strlen(nextline) + 1);
+		while (((e = last_char_is(line, '\n')) != NULL)
+			   && (e > line) && (e[-1] == '\\')
+			   && ((nextline = bb_get_line_from_file(cmdfile)) != NULL)) {
+			line = xrealloc(line, (e - line) + 1 + strlen(nextline) + 1);
 			strcat(line, nextline);
 			free(nextline);
 		}
@@ -677,20 +679,18 @@ static void process_file(FILE *file)
 	int altered;
 	int i;
 
-	line = get_line_from_file(file);
+	line = bb_get_chomped_line_from_file(file);
 	if (line == NULL) {
 		return;
 	}
-	chomp(line);
 
 	/* go through every line in the file */
 	do {
 		char *next_line;
 
 		/* Read one line in advance so we can act on the last line, the '$' address */
-		next_line = get_line_from_file(file);
+		next_line = bb_get_chomped_line_from_file(file);
 
-		chomp(next_line);
 		linenum++;
 		altered = 0;
 
@@ -805,7 +805,7 @@ static void process_file(FILE *file)
 							puts(line);
 							outfile = fopen(sed_cmd->filename, "r");
 							if (outfile)
-								print_file(outfile);
+								bb_xprint_and_close_file(outfile);
 								/* else if we couldn't open the output file,
 								 * no biggie, just don't print anything */
 								altered++;
@@ -817,16 +817,14 @@ static void process_file(FILE *file)
 					case 'n':	/* Read next line from input */
 						free(line);
 						line = next_line;
-						next_line = get_line_from_file(file);
-						chomp(next_line);
+						next_line = bb_get_chomped_line_from_file(file);
 						linenum++;
 						break;
 					case 'N':	/* Append the next line to the current line */
 						line = realloc(line, strlen(line) + strlen(next_line) + 2);
 						strcat(line, "\n");
 						strcat(line, next_line);
-						next_line = get_line_from_file(file);
-						chomp(next_line);
+						next_line = bb_get_chomped_line_from_file(file);
 						linenum++;
 				}
 			}
@@ -880,7 +878,7 @@ extern int sed_main(int argc, char **argv)
 #ifdef CONFIG_FEATURE_CLEAN_UP
 	/* destroy command strings on exit */
 	if (atexit(destroy_cmd_strs) == -1)
-		perror_msg_and_die("atexit");
+		bb_perror_msg_and_die("atexit");
 #endif
 
 	/* do normal option parsing */
@@ -896,7 +894,7 @@ extern int sed_main(int argc, char **argv)
 				load_cmd_file(optarg);
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
@@ -904,7 +902,7 @@ extern int sed_main(int argc, char **argv)
 	 * argv[optind] should be the pattern. no pattern, no worky */
 	if (ncmds == 0) {
 		if (argv[optind] == NULL)
-			show_usage();
+			bb_show_usage();
 		else {
 			add_cmd_str(argv[optind]);
 			optind++;
@@ -921,7 +919,7 @@ extern int sed_main(int argc, char **argv)
 		int i;
 		FILE *file;
 		for (i = optind; i < argc; i++) {
-			file = wfopen(argv[i], "r");
+			file = bb_wfopen(argv[i], "r");
 			if (file) {
 				process_file(file);
 				fclose(file);
diff --git a/editors/vi.c b/editors/vi.c
index cda17db1a..144e9d760 100644
--- a/editors/vi.c
+++ b/editors/vi.c
@@ -19,7 +19,7 @@
  */
 
 static const char vi_Version[] =
-	"$Id: vi.c,v 1.27 2002/12/03 21:48:15 bug1 Exp $";
+	"$Id: vi.c,v 1.28 2003/03/19 09:11:45 mjn3 Exp $";
 
 /*
  * To compile for standalone use:
@@ -403,7 +403,7 @@ extern int vi_main(int argc, char **argv)
 		for (; optind < argc; optind++) {
 			editing = 1;	// 0=exit, 1=one file, 2+ =many files
 			free(cfn);
-			cfn = (Byte *) xstrdup(argv[optind]);
+			cfn = (Byte *) bb_xstrdup(argv[optind]);
 			edit_file(cfn);
 		}
 	}
@@ -597,7 +597,7 @@ static Byte *get_one_address(Byte * p, int *addr)	// get colon addr, if present
 			*q++ = *p;
 			*q = '\0';
 		}
-		pat = (Byte *) xstrdup((char *) buf);	// save copy of pattern
+		pat = (Byte *) bb_xstrdup((char *) buf);	// save copy of pattern
 		if (*p == '/')
 			p++;
 		q = char_search(dot, pat, FORWARD, FULL);
@@ -811,7 +811,7 @@ static void colon(Byte * buf)
 
 		// There is a read-able regular file
 		// make this the current file
-		q = (Byte *) xstrdup((char *) fn);	// save the cfn
+		q = (Byte *) bb_xstrdup((char *) fn);	// save the cfn
 		free(cfn);		// free the old name
 		cfn = q;			// remember new cfn
 
@@ -862,7 +862,7 @@ static void colon(Byte * buf)
 		if (strlen((char *) args) > 0) {
 			// user wants a new filename
 			free(cfn);
-			cfn = (Byte *) xstrdup((char *) args);
+			cfn = (Byte *) bb_xstrdup((char *) args);
 		} else {
 			// user wants file status info
 			edit_status();
@@ -2432,7 +2432,7 @@ static Byte *get_input_line(Byte * prompt) // get input line- use "status line"
 	}
 	refresh(FALSE);
 	free(obufp);
-	obufp = (Byte *) xstrdup((char *) buf);
+	obufp = (Byte *) bb_xstrdup((char *) buf);
 	return (obufp);
 }
 
@@ -3263,7 +3263,7 @@ key_cmd_mode:
 		// Stuff the last_modifying_cmd back into stdin
 		// and let it be re-executed.
 		if (last_modifying_cmd != 0) {
-			ioq = ioq_start = (Byte *) xstrdup((char *) last_modifying_cmd);
+			ioq = ioq_start = (Byte *) bb_xstrdup((char *) last_modifying_cmd);
 		}
 		break;
 #endif							/* CONFIG_FEATURE_VI_DOT_CMD */
@@ -3278,7 +3278,7 @@ key_cmd_mode:
 		if (strlen((char *) q) > 1) {	// new pat- save it and find
 			// there is a new pat
 			free(last_search_pattern);
-			last_search_pattern = (Byte *) xstrdup((char *) q);
+			last_search_pattern = (Byte *) bb_xstrdup((char *) q);
 			goto dc3;	// now find the pattern
 		}
 		// user changed mind and erased the "/"-  do nothing
diff --git a/findutils/find.c b/findutils/find.c
index 048aac503..58bc8bf9c 100644
--- a/findutils/find.c
+++ b/findutils/find.c
@@ -167,7 +167,7 @@ static int find_type(char *type)
 	}
 
 	if (mask == 0 || type[1] != '\0')
-		error_msg_and_die(msg_invalid_arg, type, "-type");
+		bb_error_msg_and_die(msg_invalid_arg, type, "-type");
 
 	return mask;
 }
@@ -192,22 +192,22 @@ int find_main(int argc, char **argv)
 			}
 		else if (strcmp(argv[i], "-name") == 0) {
 			if (++i == argc)
-				error_msg_and_die(msg_req_arg, "-name");
+				bb_error_msg_and_die(msg_req_arg, "-name");
 			pattern = argv[i];
 #ifdef CONFIG_FEATURE_FIND_TYPE
 		} else if (strcmp(argv[i], "-type") == 0) {
 			if (++i == argc)
-				error_msg_and_die(msg_req_arg, "-type");
+				bb_error_msg_and_die(msg_req_arg, "-type");
 			type_mask = find_type(argv[i]);
 #endif
 #ifdef CONFIG_FEATURE_FIND_PERM
 		} else if (strcmp(argv[i], "-perm") == 0) {
 			char *end;
 			if (++i == argc)
-				error_msg_and_die(msg_req_arg, "-perm");
+				bb_error_msg_and_die(msg_req_arg, "-perm");
 			perm_mask = strtol(argv[i], &end, 8);
 			if ((end[0] != '\0') || (perm_mask > 07777))
-				error_msg_and_die(msg_invalid_arg, argv[i], "-perm");
+				bb_error_msg_and_die(msg_invalid_arg, argv[i], "-perm");
 			if ((perm_char = argv[i][0]) == '-')
 				perm_mask = -perm_mask;
 #endif
@@ -215,10 +215,10 @@ int find_main(int argc, char **argv)
 		} else if (strcmp(argv[i], "-mtime") == 0) {
 			char *end;
 			if (++i == argc)
-				error_msg_and_die(msg_req_arg, "-mtime");
+				bb_error_msg_and_die(msg_req_arg, "-mtime");
 			mtime_days = strtol(argv[i], &end, 10);
 			if (end[0] != '\0')
-				error_msg_and_die(msg_invalid_arg, argv[i], "-mtime");
+				bb_error_msg_and_die(msg_invalid_arg, argv[i], "-mtime");
 			if ((mtime_char = argv[i][0]) == '-')
 				mtime_days = -mtime_days;
 #endif
@@ -231,14 +231,14 @@ int find_main(int argc, char **argv)
 
 			if ( firstopt == 1 ) {
 				if ( stat ( ".", &stbuf ) < 0 )
-					error_msg_and_die("could not stat '.'" );
+					bb_error_msg_and_die("could not stat '.'" );
 				xdev_dev [0] = stbuf. st_dev;
 			}
 			else {
 			
 				for (i = 1; i < firstopt; i++) {
 					if ( stat ( argv [i], &stbuf ) < 0 )
-						error_msg_and_die("could not stat '%s'", argv [i] );
+						bb_error_msg_and_die("could not stat '%s'", argv [i] );
 					xdev_dev [i-1] = stbuf. st_dev;
 				}
 			}						
@@ -247,22 +247,22 @@ int find_main(int argc, char **argv)
 		} else if (strcmp(argv[i], "-newer") == 0) {
 			struct stat stat_newer;
 			if (++i == argc)
-				error_msg_and_die(msg_req_arg, "-newer");
+				bb_error_msg_and_die(msg_req_arg, "-newer");
 		    if (stat (argv[i], &stat_newer) != 0)
-				error_msg_and_die("file %s not found", argv[i]);
+				bb_error_msg_and_die("file %s not found", argv[i]);
 			newer_mtime = stat_newer.st_mtime;
 #endif
 #ifdef CONFIG_FEATURE_FIND_INUM
 		} else if (strcmp(argv[i], "-inum") == 0) {
 			char *end;
 			if (++i == argc)
-				error_msg_and_die(msg_req_arg, "-inum");
+				bb_error_msg_and_die(msg_req_arg, "-inum");
 			inode_num = strtol(argv[i], &end, 10);
 			if (end[0] != '\0')
-				error_msg_and_die(msg_invalid_arg, argv[i], "-inum");
+				bb_error_msg_and_die(msg_invalid_arg, argv[i], "-inum");
 #endif
 		} else
-			show_usage();
+			bb_show_usage();
 	}
 
 	if (firstopt == 1) {
diff --git a/findutils/grep.c b/findutils/grep.c
index cc2b697e8..b4a25923e 100644
--- a/findutils/grep.c
+++ b/findutils/grep.c
@@ -88,8 +88,7 @@ static void grep_file(FILE *file)
 	int idx = 0; /* used for iteration through the circular buffer */
 #endif /* CONFIG_FEATURE_GREP_CONTEXT */ 
 
-	while ((line = get_line_from_file(file)) != NULL) {
-		chomp(line);
+	while ((line = bb_get_chomped_line_from_file(file)) != NULL) {
 		linenum++;
 
 		for (i = 0; i < nregexes; i++) {
@@ -154,7 +153,7 @@ static void grep_file(FILE *file)
 				/* Add the line to the circular 'before' buffer */
 				if(lines_before) {
 					free(before_buf[curpos]);
-					before_buf[curpos] = xstrdup(line);
+					before_buf[curpos] = bb_xstrdup(line);
 					curpos = (curpos + 1) % lines_before;
 				}
 			}
@@ -205,9 +204,8 @@ static void add_regex(const char *restr)
 static void	load_regexes_from_file(const char *filename)
 {
 	char *line;
-	FILE *f = xfopen(filename, "r");
-	while ((line = get_line_from_file(f)) != NULL) {
-		chomp(line);
+	FILE *f = bb_xfopen(filename, "r");
+	while ((line = bb_get_chomped_line_from_file(f)) != NULL) {
 		add_regex(line);
 		free(line);
 	}
@@ -242,7 +240,7 @@ extern int grep_main(int argc, char **argv)
 #endif
 
 #ifdef CONFIG_FEATURE_GREP_EGREP_ALIAS
-	if (strcmp(get_last_path_component(argv[0]), "egrep") == 0)
+	if (strcmp(bb_get_last_path_component(argv[0]), "egrep") == 0)
 		reflags |= REG_EXTENDED;
 #endif
 
@@ -298,23 +296,23 @@ extern int grep_main(int argc, char **argv)
 			case 'A':
 				lines_after = strtoul(optarg, &junk, 10);
 				if(*junk != '\0')
-					error_msg_and_die("invalid context length argument");
+					bb_error_msg_and_die("invalid context length argument");
 				break;
 			case 'B':
 				lines_before = strtoul(optarg, &junk, 10);
 				if(*junk != '\0')
-					error_msg_and_die("invalid context length argument");
+					bb_error_msg_and_die("invalid context length argument");
 				before_buf = (char **)xcalloc(lines_before, sizeof(char *));
 				break;
 			case 'C':
 				lines_after = lines_before = strtoul(optarg, &junk, 10);
 				if(*junk != '\0')
-					error_msg_and_die("invalid context length argument");
+					bb_error_msg_and_die("invalid context length argument");
 				before_buf = (char **)xcalloc(lines_before, sizeof(char *));
 				break;
 #endif /* CONFIG_FEATURE_GREP_CONTEXT */
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
@@ -322,7 +320,7 @@ extern int grep_main(int argc, char **argv)
 	 * argv[optind] should be the pattern. no pattern, no worky */
 	if (nregexes == 0) {
 		if (argv[optind] == NULL)
-			show_usage();
+			bb_show_usage();
 		else {
 			add_regex(argv[optind]);
 			optind++;
@@ -356,7 +354,7 @@ extern int grep_main(int argc, char **argv)
 			file = fopen(cur_file, "r");
 			if (file == NULL) {
 				if (!suppress_err_msgs)
-					perror_msg("%s", cur_file);
+					bb_perror_msg("%s", cur_file);
 			}
 			else {
 				grep_file(file);
diff --git a/findutils/xargs.c b/findutils/xargs.c
index 677618dc0..d4bed57f0 100644
--- a/findutils/xargs.c
+++ b/findutils/xargs.c
@@ -53,11 +53,11 @@ static void xargs_exec(char * const * args)
 			wait(NULL);
 			if(common[0]) {
 				errno = common[0];
-				perror_msg_and_die("%s", args[0]);
+				bb_perror_msg_and_die("%s", args[0]);
 			}
 		}
 	} else {
-		perror_msg_and_die("vfork");
+		bb_perror_msg_and_die("vfork");
 	}
 }
 
@@ -81,7 +81,7 @@ int xargs_main(int argc, char **argv)
 				flg_no_empty = 1;
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
@@ -101,9 +101,7 @@ int xargs_main(int argc, char **argv)
 
 	/* Now, read in one line at a time from stdin, and store this 
 	 * line to be used later as an argument to the command */
-	while ((file_to_act_on = get_line_from_file(stdin)) != NULL) {
-		/* eat the newline off the filename. */
-		chomp(file_to_act_on);
+	while ((file_to_act_on = bb_get_chomped_line_from_file(stdin)) != NULL) {
 		if(file_to_act_on[0] != 0 || flg_no_empty == 0) {
 			args[a] = file_to_act_on[0] ? file_to_act_on : NULL;
 			if(flg_vi) {
@@ -114,7 +112,7 @@ int xargs_main(int argc, char **argv)
 				}
 				fprintf(stderr, "%s", ((flg_vi & 2) ? " ?..." : "\n"));
 			}
-			if((flg_vi & 2) == 0 || ask_confirmation() != 0 ) {
+			if((flg_vi & 2) == 0 || bb_ask_confirmation() != 0 ) {
 				xargs_exec(args);
 			}
 		}
diff --git a/include/dump.h b/include/dump.h
index 0e8dbe07f..3f4b480b2 100644
--- a/include/dump.h
+++ b/include/dump.h
@@ -38,5 +38,12 @@ typedef struct _fs {			/* format strings */
 	int bcnt;
 } FS;
 
-void add(char *fmt);
-int dump (char **argv);
+extern void bb_dump_add(const char *fmt);
+extern int bb_dump_dump (char **argv);
+extern int bb_dump_size(FS * fs);
+
+extern FS *bb_dump_fshead;		/* head of format strings */
+extern int bb_dump_blocksize;				/* data block size */
+extern int bb_dump_length;			/* max bytes to read */
+extern enum _vflag bb_dump_vflag;
+extern off_t bb_dump_skip;                      /* bytes to skip */
diff --git a/include/libbb.h b/include/libbb.h
index 8cb72de8b..f79def321 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -28,6 +28,7 @@
 #include <stdarg.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <termios.h>
 
 #include <netdb.h>
 
@@ -86,84 +87,132 @@ char *strtok_r(char *s, const char *delim, char **ptrptr);
 #define	MAX(a,b) (((a)>(b))?(a):(b))
 #endif
 
-extern void show_usage(void) __attribute__ ((noreturn));
-extern void error_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
-extern void error_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2)));
-extern void perror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
-extern void perror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2)));
-extern void vherror_msg(const char *s, va_list p);
-extern void herror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
-extern void herror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2)));
+extern void bb_show_usage(void) __attribute__ ((noreturn));
+extern void bb_error_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
+extern void bb_error_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2)));
+extern void bb_perror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
+extern void bb_perror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2)));
+extern void bb_vherror_msg(const char *s, va_list p);
+extern void bb_herror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
+extern void bb_herror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2)));
+
+extern void bb_perror_nomsg_and_die(void) __attribute__ ((noreturn));
+extern void bb_perror_nomsg(void);
 
 /* These two are used internally -- you shouldn't need to use them */
-extern void verror_msg(const char *s, va_list p);
-extern void vperror_msg(const char *s, va_list p);
-
-const char *mode_string(int mode);
-const char *time_string(time_t timeVal);
-int is_directory(const char *name, int followLinks, struct stat *statBuf);
-int isDevice(const char *name);
-
-int remove_file(const char *path, int flags);
-int copy_file(const char *source, const char *dest, int flags);
-int copy_file_chunk(FILE *src_file, FILE *dst_file, unsigned long long chunksize);
-char *buildName(const char *dirName, const char *fileName);
-int makeString(int argc, const char **argv, char *buf, int bufLen);
-char *getChunk(int size);
-char *chunkstrdup(const char *str);
-void freeChunks(void);
-ssize_t safe_read(int fd, void *buf, size_t count);
-int full_write(int fd, const char *buf, int len);
-int full_read(int fd, char *buf, int len);
-int recursive_action(const char *fileName, int recurse, int followLinks, int depthFirst,
+extern void bb_verror_msg(const char *s, va_list p) __attribute__ ((format (printf, 1, 0)));
+extern void bb_vperror_msg(const char *s, va_list p)  __attribute__ ((format (printf, 1, 0)));
+
+extern const char *bb_mode_string(int mode);
+extern int is_directory(const char *name, int followLinks, struct stat *statBuf);
+
+extern int remove_file(const char *path, int flags);
+extern int copy_file(const char *source, const char *dest, int flags);
+extern ssize_t safe_read(int fd, void *buf, size_t count);
+extern ssize_t bb_full_write(int fd, const void *buf, size_t len);
+extern ssize_t bb_full_read(int fd, void *buf, size_t len);
+extern int recursive_action(const char *fileName, int recurse,
+	  int followLinks, int depthFirst,
 	  int (*fileAction) (const char *fileName, struct stat* statbuf, void* userData),
 	  int (*dirAction) (const char *fileName, struct stat* statbuf, void* userData),
 	  void* userData);
 
-extern int parse_mode( const char* s, mode_t* theMode);
+extern int bb_parse_mode( const char* s, mode_t* theMode);
 extern long bb_xgetlarg(char *arg, int base, long lower, long upper);
 
+extern unsigned long bb_baud_to_value(speed_t speed);
+extern speed_t bb_value_to_baud(unsigned long value);
+
 extern int get_kernel_revision(void);
 
 extern int get_console_fd(void);
 extern struct mntent *find_mount_point(const char *name, const char *table);
 extern void write_mtab(char* blockDevice, char* directory, 
-	char* filesystemType, long flags, char* string_flags);
+					   char* filesystemType, long flags, char* string_flags);
 extern void erase_mtab(const char * name);
-extern long atoi_w_units (const char *cp);
-extern long* find_pid_by_name( const char* pidName);
+extern long *find_pid_by_name( const char* pidName);
 extern char *find_real_root_device_name(const char* name);
-extern char *get_line_from_file(FILE *file);
-extern void print_file(FILE *file);
-extern int copyfd(int fd1, int fd2, const off_t chunksize);
-extern int print_file_by_name(char *filename);
-extern char process_escape_sequence(const char **ptr);
-extern char *get_last_path_component(char *path);
-extern FILE *wfopen(const char *path, const char *mode);
-extern FILE *xfopen(const char *path, const char *mode);
+extern char *bb_get_line_from_file(FILE *file);
+extern char *bb_get_chomped_line_from_file(FILE *file);
+extern int   bb_copyfd(int fd1, int fd2, const off_t chunksize);
+extern void  bb_xprint_and_close_file(FILE *file);
+extern int   bb_xprint_file_by_name(const char *filename);
+extern char  bb_process_escape_sequence(const char **ptr);
+extern char *bb_get_last_path_component(char *path);
+extern FILE *bb_wfopen(const char *path, const char *mode);
+extern FILE *bb_xfopen(const char *path, const char *mode);
+
+//#warning rename?
+extern int   bb_fclose_nonstdin(FILE *f);
+extern void  bb_fflush_stdout_and_exit(int retval) __attribute__ ((noreturn));
+extern unsigned long bb_getopt_ulflags(int argc, char **argv, const char *applet_opts);
+//#warning rename?
+extern FILE *bb_wfopen_input(const char *filename);
+
+extern int bb_vfprintf(FILE * __restrict stream, const char * __restrict format,
+					   va_list arg) __attribute__ ((format (printf, 2, 0)));
+extern int bb_vprintf(const char * __restrict format, va_list arg)
+	__attribute__ ((format (printf, 1, 0)));
+extern int bb_fprintf(FILE * __restrict stream, const char * __restrict format, ...)
+	__attribute__ ((format (printf, 2, 3)));
+extern int bb_printf(const char * __restrict format, ...)
+	__attribute__ ((format (printf, 1, 2)));
+
+//#warning rename to xferror_filename?
+extern void bb_xferror(FILE *fp, const char *fn);
+extern void bb_xferror_stdout(void);
+extern void bb_xfflush_stdout(void);
+
+extern void bb_warn_ignoring_args(int n);
+
 extern void chomp(char *s);
 extern void trim(char *s);
+extern const char *bb_skip_whitespace(const char *);
+
 extern struct BB_applet *find_applet_by_name(const char *name);
 void run_applet_by_name(const char *name, int argc, char **argv);
 
+//#warning is this needed anymore?
 #ifndef DMALLOC
 extern void *xmalloc (size_t size);
 extern void *xrealloc(void *old, size_t size);
 extern void *xcalloc(size_t nmemb, size_t size);
-extern char *xstrdup (const char *s);
+extern char *bb_xstrdup (const char *s);
 #endif
-extern char *xstrndup (const char *s, int n);
+extern char *bb_xstrndup (const char *s, int n);
 extern char * safe_strncpy(char *dst, const char *src, size_t size);
 
 struct suffix_mult {
 	const char *suffix;
-	int mult;
+	unsigned int mult;
 };
 
-extern unsigned long parse_number(const char *numstr,
+extern unsigned long bb_xgetularg_bnd_sfx(const char *arg, int base,
+										  unsigned long lower,
+										  unsigned long upper,
+										  const struct suffix_mult *suffixes);
+extern unsigned long bb_xgetularg_bnd(const char *arg, int base,
+									  unsigned long lower,
+									  unsigned long upper);
+extern unsigned long bb_xgetularg10_bnd(const char *arg,
+										unsigned long lower,
+										unsigned long upper);
+extern unsigned long bb_xgetularg10(const char *arg);
+
+extern long bb_xgetlarg_bnd_sfx(const char *arg, int base,
+								long lower,
+								long upper,
+								const struct suffix_mult *suffixes);
+extern long bb_xgetlarg10_sfx(const char *arg, const struct suffix_mult *suffixes);
+
+
+//#warning pitchable now?
+extern unsigned long bb_xparse_number(const char *numstr,
 		const struct suffix_mult *suffixes);
 
 
+//#warning change names?
+
 /* These parse entries in /etc/passwd and /etc/group.  This is desirable
  * for BusyBox since we want to avoid using the glibc NSS stuff, which
  * increases target size and is often not needed embedded systems.  */
@@ -217,7 +266,7 @@ enum {
 };
 const char *make_human_readable_str(unsigned long size, unsigned long block_size, unsigned long display_unit);
 
-int ask_confirmation(void);
+int bb_ask_confirmation(void);
 int klogctl(int type, char * b, int len);
 
 char *xgetcwd(char *cwd);
@@ -228,6 +277,7 @@ char *last_char_is(const char *s, int c);
 extern long arith (const char *startbuf, int *errcode);
 
 int read_package_field(const char *package_buffer, char **field_name, char **field_value);
+//#warning yuk!
 char *fgets_str(FILE *file, const char *terminating_string);
 
 extern int uncompress(int fd_in, int fd_out);
@@ -239,19 +289,15 @@ extern int create_icmp_socket(void);
 extern int create_icmp6_socket(void);
 extern int xconnect(const char *host, const char *port);
 
+//#warning wrap this?
 char *dirname (char *path);
 
-int make_directory (char *path, long mode, int flags);
+int bb_make_directory (char *path, long mode, int flags);
 
 const char *u_signal_names(const char *str_sig, int *signo, int startnum);
-char *simplify_path(const char *path);
-
-#define CT_AUTO	0
-#define CT_UNIX2DOS	1
-#define CT_DOS2UNIX	2
-/* extern int convert(char *fn, int ConvType); */
+char *bb_simplify_path(const char *path);
 
-enum {
+enum {	/* DO NOT CHANGE THESE VALUES!  cp.c depends on them. */
 	FILEUTILS_PRESERVE_STATUS = 1,
 	FILEUTILS_DEREFERENCE = 2,
 	FILEUTILS_RECUR = 4,
@@ -259,29 +305,31 @@ enum {
 	FILEUTILS_INTERACTIVE = 16
 };
 
-extern const char *applet_name;
-extern const char * const full_version;
-extern const char * const name_too_long;
-extern const char * const omitting_directory;
-extern const char * const not_a_directory;
-extern const char * const memory_exhausted;
-extern const char * const invalid_date;
-extern const char * const invalid_option;
-extern const char * const io_error;
-extern const char * const dash_dash_help;
-extern const char * const write_error;
-extern const char * const too_few_args;
-extern const char * const name_longer_than_foo;
-extern const char * const unknown;
-extern const char * const can_not_create_raw_socket;
-extern const char * const nologin_file;
-extern const char * const passwd_file;
-extern const char * const shadow_file;
-extern const char * const gshadow_file;
-extern const char * const group_file;
-extern const char * const securetty_file;
-extern const char * const motd_file;
-extern const char * const _path_login;
+extern const char *bb_applet_name;
+
+extern const char * const bb_msg_full_version;
+extern const char * const bb_msg_memory_exhausted;
+extern const char * const bb_msg_invalid_date;
+extern const char * const bb_msg_io_error;
+extern const char * const bb_msg_write_error;
+extern const char * const bb_msg_name_longer_than_foo;
+extern const char * const bb_msg_unknown;
+extern const char * const bb_msg_can_not_create_raw_socket;
+extern const char * const bb_msg_perm_denied_are_you_root;
+extern const char * const bb_msg_standard_input;
+extern const char * const bb_msg_standard_output;
+
+extern const char * const bb_path_nologin_file;
+extern const char * const bb_path_passwd_file;
+extern const char * const bb_path_shadow_file;
+extern const char * const bb_path_gshadow_file;
+extern const char * const bb_path_group_file;
+extern const char * const bb_path_securetty_file;
+extern const char * const bb_path_motd_file;
+
+extern const char bb_path_mtab_file[];
+
+extern int bb_default_error_retval;
 
 #ifdef CONFIG_FEATURE_DEVFS
 # define CURRENT_VC "/dev/vc/0"
@@ -309,6 +357,8 @@ extern const char * const _path_login;
 # define LOOP_FORMAT "/dev/loop%d"
 #endif
 
+//#warning put these in .o files
+
 /* The following devices are the same on devfs and non-devfs systems.  */
 #define CURRENT_TTY "/dev/tty"
 #define CONSOLE_DEV "/dev/console"
@@ -318,10 +368,10 @@ void add_to_ino_dev_hashtable(const struct stat *statbuf, const char *name);
 void reset_ino_dev_hashtable(void);
 
 /* Stupid gcc always includes its own builtin strlen()... */
-extern size_t xstrlen(const char *string);
-#define strlen(x)   xstrlen(x)
+extern size_t bb_strlen(const char *string);
+#define strlen(x)   bb_strlen(x)
 
-void bb_asprintf(char **string_ptr, const char *format, ...) __attribute__ ((format (printf, 2, 3)));
+void bb_xasprintf(char **string_ptr, const char *format, ...) __attribute__ ((format (printf, 2, 3)));
 
 
 #define FAIL_DELAY    3
@@ -335,10 +385,10 @@ extern char *pw_encrypt(const char *clear, const char *salt);
 extern struct spwd *pwd_to_spwd(const struct passwd *pw);
 extern int obscure(const char *old, const char *newval, const struct passwd *pwdp);
 
-extern int xopen(const char *pathname, int flags);
-extern ssize_t xread(int fd, void *buf, size_t count);
-extern void xread_all(int fd, void *buf, size_t count);
-extern unsigned char xread_char(int fd);
+extern int bb_xopen(const char *pathname, int flags);
+extern ssize_t bb_xread(int fd, void *buf, size_t count);
+extern void bb_xread_all(int fd, void *buf, size_t count);
+extern unsigned char bb_xread_char(int fd);
 
 typedef struct {
 	int pid;
diff --git a/include/usage.h b/include/usage.h
index 8fc12f151..bbc0babfc 100644
--- a/include/usage.h
+++ b/include/usage.h
@@ -98,9 +98,11 @@
        "\t-y\tDisplay the entire year."
 
 #define cat_trivial_usage \
-	"[FILE]..."
+	"[-u] [FILE]..."
 #define cat_full_usage \
-	"Concatenates FILE(s) and prints them to stdout."
+	"Concatenates FILE(s) and prints them to stdout.\n\n" \
+	"Options:\n" \
+	"\t-u\tignored since unbuffered i/o is always used"
 #define cat_example_usage \
 	"$ cat /proc/uptime\n" \
 	"110716.72 17.67"
@@ -397,20 +399,34 @@
 #define dpkg_deb_example_usage \
 	"$ dpkg-deb -X ./busybox_0.48-1_i386.deb /tmp\n"
 
+#ifdef CONFIG_FEATURE_DU_DEFALT_BLOCKSIZE_1K
+#define USAGE_DU_DEFALT_BLOCKSIZE_1k(a) a
+#define USAGE_NOT_DU_DEFALT_BLOCKSIZE_1k(a)
+#else
+#define USAGE_DU_DEFALT_BLOCKSIZE_1k(a)
+#define USAGE_NOT_DU_DEFALT_BLOCKSIZE_1k(a) a
+#endif
+
 #define du_trivial_usage \
-	"[-lsx" USAGE_HUMAN_READABLE("hm") USAGE_NOT_HUMAN_READABLE("") "k] [FILE]..."
+	"[-aHLdclsx" USAGE_HUMAN_READABLE("hm") "k] [FILE]..."
 #define du_full_usage \
 	"Summarizes disk space used for each FILE and/or directory.\n" \
-	"Disk space is printed in units of 1024 bytes.\n\n" \
-	"Options:\n" \
+	"Disk space is printed in units of " \
+	USAGE_DU_DEFALT_BLOCKSIZE_1k("1024") USAGE_NOT_DU_DEFALT_BLOCKSIZE_1k("512") \
+	" bytes.\n\n" \
+	"Options:\n" \
+	"\t-a\tshow sizes of files in addition to directories\n" \
+	"\t-H\tfollow symbolic links that are FILE command line args\n" \
+	"\t-L\tfollow all symbolic links encountered\n" \
+	"\t-d N\tlimit output to directories (and files with -a) of depth < N\n" \
+	"\t-c\toutput a grand total\n" \
 	"\t-l\tcount sizes many times if hard linked\n" \
-	"\t-s\tdisplay only a total for each argument" \
-	USAGE_HUMAN_READABLE( \
-	"\n\t-h\tprint sizes in human readable format (e.g., 1K 243M 2G )\n" \
-	"\t-m\tprint sizes in megabytes\n" \
+	"\t-s\tdisplay only a total for each argument\n" \
 	"\t-x\tskip directories on different filesystems\n" \
-	"\t-k\tprint sizes in kilobytes(default)") USAGE_NOT_HUMAN_READABLE( \
-	"\n\t-k\tprint sizes in kilobytes(compatibility)")
+	USAGE_HUMAN_READABLE( \
+	"\t-h\tprint sizes in human readable format (e.g., 1K 243M 2G )\n" \
+	"\t-m\tprint sizes in megabytes\n" ) \
+	"\t-k\tprint sizes in kilobytes" USAGE_DU_DEFALT_BLOCKSIZE_1k("(default)")
 #define du_example_usage \
 	"$ du\n" \
 	"16      ./CVS\n" \
@@ -451,25 +467,31 @@
 	"8|125||l4|||0|0|0|955637629|998367|0\n" \
 	"6|245|tty1|1|LOGIN||0|0|0|955637630|998974|0\n" \
 	"6|246|tty2|2|LOGIN||0|0|0|955637630|999498|0\n" \
-	"7|336|pts/0|vt00andersen|andersen|:0.0|0|0|0|955637763|0|0\n"
+	"7|336|pts/0|vt00|andersen|:0.0|0|0|0|955637763|0|0\n"
+
+#ifdef CONFIG_FEATURE_FANCY_ECHO
+  #define USAGE_FANCY_ECHO(a) a
+#else
+  #define USAGE_FANCY_ECHO(a) 
+#endif
 
 #define echo_trivial_usage \
-	"[-neE] [ARG ...]"
+	USAGE_FANCY_ECHO("[-neE] ") "[ARG ...]"
 #define echo_full_usage \
 	"Prints the specified ARGs to stdout\n\n" \
-	"Options:\n" \
+	USAGE_FANCY_ECHO("Options:\n" \
 	"\t-n\tsuppress trailing newline\n" \
 	"\t-e\tinterpret backslash-escaped characters (i.e., \\t=tab)\n" \
-	"\t-E\tdisable interpretation of backslash-escaped characters"
+	"\t-E\tdisable interpretation of backslash-escaped characters")
 #define echo_example_usage \
 	"$ echo "Erik is cool"\n" \
 	"Erik is cool\n" \
-	"$  echo -e "Erik\\nis\\ncool"\n" \
+	USAGE_FANCY_ECHO("$  echo -e "Erik\\nis\\ncool"\n" \
 	"Erik\n" \
 	"is\n" \
 	"cool\n" \
 	"$ echo "Erik\\nis\\ncool"\n" \
-	"Erik\\nis\\ncool\n"
+	"Erik\\nis\\ncool\n")
 
 #define env_trivial_usage \
 	"[-iu] [-] [name=value]... [command]"
@@ -757,6 +779,12 @@
 #define halt_full_usage \
 	"Halt the system."
 
+#ifdef CONFIG_FEATURE_FANCY_HEAD
+#define USAGE_FANCY_HEAD(a) a
+#else
+#define USAGE_FANCY_HEAD(a)
+#endif
+
 #define head_trivial_usage \
 	"[OPTION] [FILE]..."
 #define head_full_usage \
@@ -764,7 +792,11 @@
 	"With more than one FILE, precede each with a header giving the\n" \
 	"file name. With no FILE, or when FILE is -, read standard input.\n\n" \
 	"Options:\n" \
-	"\t-n NUM\t\tPrint first NUM lines instead of first 10"
+	"\t-n NUM\t\tPrint first NUM lines instead of first 10" \
+	USAGE_FANCY_HEAD( \
+	"\n\t-c NUM\t\toutput the first NUM bytes\n" \
+	"\t-q\t\tnever output headers giving file names\n" \
+	"\t-v\t\talways output headers giving file names" )
 #define head_example_usage \
 	"$ head -n 2 /etc/passwd\n" \
 	"root:x:0:0:root:/root:/bin/bash\n" \
@@ -1762,7 +1794,7 @@
 	"Remove (unlink) the FILE(s).  You may use '--' to\n" \
 	"indicate that all following arguments are non-options.\n\n" \
 	"Options:\n" \
-	"\t-i\t\talways prompt before removing each destination" \
+	"\t-i\t\talways prompt before removing each destination\n" \
 	"\t-f\t\tremove existing destinations, never prompt\n" \
 	"\t-r or -R\tremove the contents of directories recursively"
 #define rm_example_usage \
@@ -1864,14 +1896,26 @@
 #define sha1sum_full_usage \
 	"[OPTION] [FILE]"
 
+#ifdef CONFIG_FEATURE_FANCY_SLEEP
+  #define USAGE_FANCY_SLEEP(a) a
+  #define USAGE_NOT_FANCY_SLEEP(a)
+#else
+  #define USAGE_FANCY_SLEEP(a) 
+  #define USAGE_NOT_FANCY_SLEEP(a) a
+#endif
+
 #define sleep_trivial_usage \
-	"N"
+	USAGE_FANCY_SLEEP("[") "N" USAGE_FANCY_SLEEP("]...") 
 #define sleep_full_usage \
-	"Pause for N seconds."
+	USAGE_NOT_FANCY_SLEEP("Pause for N seconds.") \
+	USAGE_FANCY_SLEEP( \
+"Pause for a time equal to the total of the args given, where each arg can\n" \
+"have an optional suffix of (s)econds, (m)inutes, (h)ours, or (d)ays.")
 #define sleep_example_usage \
 	"$ sleep 2\n" \
-	"[2 second delay results]\n"
-
+	"[2 second delay results]\n" \
+	USAGE_FANCY_SLEEP("$ sleep 1d 3h 22m 8s\n" \
+	"[98528 second delay results]\n")
 
 #ifdef CONFIG_FEATURE_SORT_UNIQUE
   #define USAGE_SORT_UNIQUE(a) a
@@ -2077,7 +2121,8 @@
 #define tee_full_usage \
 	"Copy standard input to each FILE, and also to standard output.\n\n" \
 	"Options:\n" \
-	"\t-a\tappend to the given FILEs, do not overwrite"
+	"\t-a\tappend to the given FILEs, do not overwrite\n" \
+	"\t-i\tignore interrupt signals (SIGINT)"
 #define tee_example_usage \
 	"$ echo "Hello" | tee /tmp/foo\n" \
 	"$ cat /tmp/foo\n" \
@@ -2312,7 +2357,9 @@
 	"Options:\n" \
 	"\t-c\tprefix lines by the number of occurrences\n" \
 	"\t-d\tonly print duplicate lines\n" \
-	"\t-u\tonly print unique lines"
+	"\t-u\tonly print unique lines\n" \
+	"\t-f N\tskip the first N fields\n" \
+	"\t-s N\tskip the first N chars (after any skipped fields)"
 #define uniq_example_usage \
 	"$ echo -e \"a\\na\\nb\\nc\\nc\\na\" | sort | uniq\n" \
 	"a\n" \
diff --git a/init/halt.c b/init/halt.c
index 3d4725f09..7e663227c 100644
--- a/init/halt.c
+++ b/init/halt.c
@@ -32,7 +32,7 @@ extern int halt_main(int argc, char **argv)
 	if (!pid || *pid<=0) {
 		pid = find_pid_by_name("linuxrc");
 		if (!pid || *pid<=0)
-			error_msg_and_die("no process killed");
+			bb_error_msg_and_die("no process killed");
 	}
 	return(kill(*pid, SIGUSR1));
 #else
diff --git a/init/init.c b/init/init.c
index 258a7fa6b..be91d6a8f 100644
--- a/init/init.c
+++ b/init/init.c
@@ -247,14 +247,14 @@ static void message(int device, const char *fmt, ...)
 	if (log_fd < 0) {
 		if ((log_fd = device_open(log, O_RDWR | O_NDELAY | O_NOCTTY)) < 0) {
 			log_fd = -2;
-			error_msg("Bummer, can't write to log on %s!", log);
+			bb_error_msg("Bummer, can't write to log on %s!", log);
 			device = CONSOLE;
 		} else {
 			fcntl(log_fd, F_SETFD, FD_CLOEXEC);
 		}
 	}
 	if ((device & LOG) && (log_fd >= 0)) {
-		full_write(log_fd, msg, l);
+		bb_full_write(log_fd, msg, l);
 	}
 #endif
 
@@ -263,12 +263,12 @@ static void message(int device, const char *fmt, ...)
 					O_WRONLY | O_NOCTTY | O_NDELAY);
 		/* Always send console messages to /dev/console so people will see them. */
 		if (fd >= 0) {
-			full_write(fd, msg, l);
+			bb_full_write(fd, msg, l);
 			close(fd);
 #ifdef DEBUG_INIT
 		/* all descriptors may be closed */
 		} else {
-			error_msg("Bummer, can't print: ");
+			bb_error_msg("Bummer, can't print: ");
 			va_start(arguments, fmt);
 			vfprintf(stderr, fmt, arguments);
 			va_end(arguments);
@@ -323,7 +323,7 @@ static int check_free_memory(void)
 	unsigned int result, u, s = 10;
 
 	if (sysinfo(&info) != 0) {
-		perror_msg("Error checking free memory");
+		bb_perror_msg("Error checking free memory");
 		return -1;
 	}
 
@@ -564,11 +564,11 @@ static pid_t run(const struct init_action *a)
 			++cmdpath;
 
 			/* find the last component in the command pathname */
-			s = get_last_path_component(cmdpath);
+			s = bb_get_last_path_component(cmdpath);
 
 			/* make a new argv[0] */
 			if ((cmd[0] = malloc(strlen(s) + 2)) == NULL) {
-				message(LOG | CONSOLE, memory_exhausted);
+				message(LOG | CONSOLE, bb_msg_memory_exhausted);
 				cmd[0] = cmdpath;
 			} else {
 				cmd[0][0] = '-';
@@ -589,7 +589,7 @@ static pid_t run(const struct init_action *a)
 			messageD(LOG, "Waiting for enter to start '%s'"
 						"(pid %d, terminal %s)\n",
 					  cmdpath, getpid(), a->terminal);
-			full_write(1, press_enter, sizeof(press_enter) - 1);
+			bb_full_write(1, press_enter, sizeof(press_enter) - 1);
 			while(read(0, &c, 1) == 1 && c != '\n')
 				;
 		}
@@ -1017,7 +1017,7 @@ extern int init_main(int argc, char **argv)
 		if (!pid || *pid <= 0) {
 			pid = find_pid_by_name("linuxrc");
 			if (!pid || *pid <= 0)
-				error_msg_and_die("no process killed");
+				bb_error_msg_and_die("no process killed");
 		}
 		return kill(*pid, SIGHUP);
 	}
@@ -1025,10 +1025,10 @@ extern int init_main(int argc, char **argv)
 	/* Expect to be invoked as init with PID=1 or be invoked as linuxrc */
 	if (getpid() != 1
 #ifdef CONFIG_FEATURE_INITRD
-		&& strstr(applet_name, "linuxrc") == NULL
+		&& strstr(bb_applet_name, "linuxrc") == NULL
 #endif
 		) {
-		show_usage();
+		bb_show_usage();
 	}
 	/* Set up sig handlers  -- be sure to
 	 * clear all of these in run() */
@@ -1068,10 +1068,10 @@ extern int init_main(int argc, char **argv)
 		const char * const *e;
 		/* Make sure environs is set to something sane */
 		for(e = environment; *e; e++)
-			putenv(*e);
+			putenv((char *) *e);
 	}
 	/* Hello world */
-	message(MAYBE_CONSOLE | LOG, "init started:  %s", full_version);
+	message(MAYBE_CONSOLE | LOG, "init started:  %s", bb_msg_full_version);
 
 	/* Make sure there is enough memory to do something useful. */
 	check_memory();
diff --git a/init/mesg.c b/init/mesg.c
index f9b46e029..7b8acf657 100644
--- a/init/mesg.c
+++ b/init/mesg.c
@@ -52,7 +52,7 @@ extern int mesg_main(int argc, char *argv[])
 				return EXIT_SUCCESS;
 			}
 		}
-		perror_msg_and_die("%s", tty);
+		bb_perror_msg_and_die("%s", tty);
 	}
-	show_usage();
+	bb_show_usage();
 }
diff --git a/init/poweroff.c b/init/poweroff.c
index 27468bac0..aca6e2f25 100644
--- a/init/poweroff.c
+++ b/init/poweroff.c
@@ -32,7 +32,7 @@ extern int poweroff_main(int argc, char **argv)
 	if (!pid || *pid<=0) {
 		pid = find_pid_by_name("linuxrc");
 		if (!pid || *pid<=0)
-			error_msg_and_die("no process killed");
+			bb_error_msg_and_die("no process killed");
 	}
 	return(kill(*pid, SIGUSR2));
 #else
diff --git a/init/reboot.c b/init/reboot.c
index 872d9e741..8c380fa6a 100644
--- a/init/reboot.c
+++ b/init/reboot.c
@@ -52,7 +52,7 @@ extern int reboot_main(int argc, char **argv)
 			break;
 
 		default:
-			show_usage();
+			bb_show_usage();
 			break;
 		}
 	}
@@ -99,7 +99,7 @@ extern int reboot_main(int argc, char **argv)
 		if (!pid || *pid<=0)
 			pid = find_pid_by_name("linuxrc");
 		if (!pid || *pid<=0)
-			error_msg_and_die("no process killed");
+			bb_error_msg_and_die("no process killed");
 		fflush(stdout);
 		return(kill(*pid, SIGTERM));
 	}
diff --git a/init/start_stop_daemon.c b/init/start_stop_daemon.c
index 576526183..a1c2c21c2 100644
--- a/init/start_stop_daemon.c
+++ b/init/start_stop_daemon.c
@@ -74,7 +74,7 @@ parse_options(int argc, char * const *argv)
 			break;
 		case 's':
 			if (sscanf(optarg, "%d", &signal_nr) != 1)
-				error_msg_and_die ("-s takes a numeric argument");
+				bb_error_msg_and_die ("-s takes a numeric argument");
 			break;
 		case 'u':
 			userspec = optarg;
@@ -86,21 +86,21 @@ parse_options(int argc, char * const *argv)
 			fork_before_exec = 1;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
 	if (start == stop)
-		error_msg_and_die ("need one of -S or -K");
+		bb_error_msg_and_die ("need one of -S or -K");
 
 	if (!execname && !userspec)
-		error_msg_and_die ("need at least one of -x or -u");
+		bb_error_msg_and_die ("need at least one of -x or -u");
 
 	if (!startas)
 		startas = execname;
 
 	if (start && !startas)
-		error_msg_and_die ("-S needs -x or -a");
+		bb_error_msg_and_die ("-S needs -x or -a");
 }
 
 
@@ -185,7 +185,7 @@ do_procfs(void)
 
 	procdir = opendir("/proc");
 	if (!procdir)
-		perror_msg_and_die ("opendir /proc");
+		bb_perror_msg_and_die ("opendir /proc");
 
 	foundany = 0;
 	while ((entry = readdir(procdir)) != NULL) {
@@ -196,7 +196,7 @@ do_procfs(void)
 	}
 	closedir(procdir);
 	if (!foundany)
-		error_msg_and_die ("nothing in /proc - not mounted?");
+		bb_error_msg_and_die ("nothing in /proc - not mounted?");
 }
 
 
@@ -214,7 +214,7 @@ do_stop(void)
 	else if (userspec)
 		sprintf(what, "process(es) owned by `%s'", userspec);
 	else
-		error_msg_and_die ("internal error, please report");
+		bb_error_msg_and_die ("internal error, please report");
 
 	if (!found) {
 		printf("no %s found; none killed.\n", what);
@@ -225,7 +225,7 @@ do_stop(void)
 			p->pid = -p->pid;
 			killed++;
 		} else {
-			perror_msg("warning: failed to kill %d:", p->pid);
+			bb_perror_msg("warning: failed to kill %d:", p->pid);
 		}
 	}
 	if (killed) {
@@ -262,10 +262,10 @@ start_stop_daemon_main(int argc, char **argv)
 	*--argv = startas;
 	if (fork_before_exec) {
 		if (daemon(0, 0) == -1)
-			perror_msg_and_die ("unable to fork");
+			bb_perror_msg_and_die ("unable to fork");
 	}
 	setsid();
 	execv(startas, argv);
-	perror_msg_and_die ("unable to start %s", startas);
+	bb_perror_msg_and_die ("unable to start %s", startas);
 }
 
diff --git a/libbb/Makefile.in b/libbb/Makefile.in
index 6d2475bcf..c7916f108 100644
--- a/libbb/Makefile.in
+++ b/libbb/Makefile.in
@@ -42,26 +42,59 @@ LIBBB_SRC:= \
 	restricted_shell.c run_parts.c run_shell.c safe_read.c safe_strncpy.c \
 	setup_environment.c simplify_path.c syscalls.c syslog_msg_with_name.c \
 	time_string.c trim.c u_signal_names.c vdprintf.c verror_msg.c \
-	vherror_msg.c vperror_msg.c wfopen.c xconnect.c xgetcwd.c xfuncs.c \
-	xgethostbyname.c xgethostbyname2.c xreadlink.c xregcomp.c xgetlarg.c 
-	
+	vherror_msg.c vperror_msg.c wfopen.c xconnect.c xgetcwd.c \
+	xgethostbyname.c xgethostbyname2.c xreadlink.c xregcomp.c xgetlarg.c \
+	\
+	fclose_nonstdin.c fflush_stdout_and_exit.c getopt_ulflags.c \
+	default_error_retval.c wfopen_input.c speed_table.c \
+	perror_nomsg_and_die.c perror_nomsg.c skip_whitespace.c \
+	warn_ignoring_args.c
 
 LIBBB_OBJS=$(patsubst %.c,$(LIBBB_DIR)%.o, $(LIBBB_SRC))
 
-LIBBB_MSRC:=$(LIBBB_DIR)messages.c
-LIBBB_MOBJ:=full_version.o name_too_long.o omitting_directory.o not_a_directory.o \
-	memory_exhausted.o invalid_date.o invalid_option.o io_error.o dash_dash_help.o \
-	write_error.o too_few_args.o name_longer_than_foo.o unknown.o can_not_create_raw_socket.o \
-	shadow_file.o passwd_file.o group_file.o gshadow_file.o nologin_file.o securetty_file.o \
-	motd_file.o
-LIBBB_MOBJS=$(patsubst %,$(LIBBB_DIR)%, $(LIBBB_MOBJ))
+LIBBB_MSRC0:=$(LIBBB_DIR)messages.c
+LIBBB_MOBJ0:=full_version.o \
+	memory_exhausted.o invalid_date.o io_error.o \
+	write_error.o name_longer_than_foo.o unknown.o \
+	can_not_create_raw_socket.o perm_denied_are_you_root.o \
+	shadow_file.o passwd_file.o group_file.o gshadow_file.o nologin_file.o \
+	securetty_file.o motd_file.o \
+	msg_standard_input.o msg_standard_output.o
+
+LIBBB_MSRC1:=$(LIBBB_DIR)xfuncs.c
+LIBBB_MOBJ1:=xmalloc.o xrealloc.o xcalloc.o xstrdup.o xstrndup.o \
+	xfopen.o xopen.o xread.o xread_all.o xread_char.o \
+	xferror.o xferror_stdout.o xfflush_stdout.o strlen.o
+
+LIBBB_MSRC2:=$(LIBBB_DIR)printf.c
+LIBBB_MOBJ2:=vfprintf.o vprintf.o fprintf.o printf.o
+
+LIBBB_MSRC3:=$(LIBBB_DIR)xgetularg.c
+LIBBB_MOBJ3:=xgetularg_bnd_sfx.o xgetlarg_bnd_sfx.o getlarg10_sfx.o \
+	xgetularg_bnd.o xgetularg10_bnd.o xgetularg10.o
+
+LIBBB_MOBJS0=$(patsubst %,$(LIBBB_DIR)%, $(LIBBB_MOBJ0))
+LIBBB_MOBJS1=$(patsubst %,$(LIBBB_DIR)%, $(LIBBB_MOBJ1))
+LIBBB_MOBJS2=$(patsubst %,$(LIBBB_DIR)%, $(LIBBB_MOBJ2))
+LIBBB_MOBJS3=$(patsubst %,$(LIBBB_DIR)%, $(LIBBB_MOBJ3))
 
 libraries-y+=$(LIBBB_DIR)$(LIBBB_AR)
 
-$(LIBBB_DIR)$(LIBBB_AR): $(LIBBB_OBJS) $(LIBBB_MOBJS) 
-	$(AR) -ro $@ $(LIBBB_OBJS) $(LIBBB_MOBJS)
+$(LIBBB_DIR)$(LIBBB_AR): $(LIBBB_OBJS) $(LIBBB_MOBJS0) $(LIBBB_MOBJS1) \
+	$(LIBBB_MOBJS2) $(LIBBB_MOBJS3)
+	$(AR) -ro $@ $(LIBBB_OBJS) $(LIBBB_MOBJS0) $(LIBBB_MOBJS1) \
+		$(LIBBB_MOBJS2) $(LIBBB_MOBJS3) 
+
+$(LIBBB_MOBJS0): $(LIBBB_MSRC0)
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -DL_$(notdir $*) -c $< -o $@
+
+$(LIBBB_MOBJS1): $(LIBBB_MSRC1)
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -DL_$(notdir $*) -c $< -o $@
+
+$(LIBBB_MOBJS2): $(LIBBB_MSRC2)
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -DL_$(notdir $*) -c $< -o $@
 
-$(LIBBB_MOBJS): $(LIBBB_MSRC)
+$(LIBBB_MOBJS3): $(LIBBB_MSRC3)
 	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -DL_$(notdir $*) -c $< -o $@
 
 $(LIBBB_DIR)loop.o: $(LIBBB_DIR)loop.h
diff --git a/libbb/ask_confirmation.c b/libbb/ask_confirmation.c
index d4d943ad7..a99a4e733 100644
--- a/libbb/ask_confirmation.c
+++ b/libbb/ask_confirmation.c
@@ -1,49 +1,49 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Utility routines.
+ * bb_ask_confirmation implementation for busybox
  *
- * Copyright (C) many different people.  If you wrote this, please
- * acknowledge your work.
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+/* Read a line from stdin.  If the first non-whitespace char is 'y' or 'Y',
+ * return 1.  Otherwise return 0.
  */
 
 #include <stdio.h>
+#include <ctype.h>
 #include "libbb.h"
 
-
-int ask_confirmation()
+int bb_ask_confirmation(void)
 {
-	int c = '\0';
-	int ret = 0;
+	int retval = 0;
+	int first = 1;
+	int c;
 
-	while (c != '\n') {
-		c = getchar();
-		if ( c != '\n' ) {
-			ret = ((c=='y')||(c=='Y')) ? 1 : 0;
+	while (((c = getchar()) != EOF) && (c != '\n')) {
+		/* Make sure we get the actual function call for isspace,
+		 * as speed is not critical here. */
+		if (first && !(isspace)(c)) {
+			--first;
+			if ((c == 'y') || (c == 'Y')) {
+				++retval;
+			}
 		}
 	}
-	return ret;
-}
 
-/* END CODE */
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
+	return retval;
+}
diff --git a/libbb/bb_asprintf.c b/libbb/bb_asprintf.c
index 9a71be7f5..7075b46de 100644
--- a/libbb/bb_asprintf.c
+++ b/libbb/bb_asprintf.c
@@ -5,17 +5,18 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <stdarg.h>
-
-
 #include "libbb.h"
 
-
-void bb_asprintf(char **string_ptr, const char *format, ...)
+void bb_xasprintf(char **string_ptr, const char *format, ...)
 {
-       va_list p;
+	va_list p;
+	int r;
+	
+	va_start(p, format);
+	r = vasprintf(string_ptr, format, p);
+	va_end(p);
 
-       va_start(p, format);
-       if(vasprintf(string_ptr, format, p)<0)
-		error_msg_and_die(memory_exhausted);
-       va_end(p);
+	if (r < 0) {
+		bb_perror_msg_and_die("bb_xasprintf");
+	}
 }
diff --git a/libbb/change_identity.c b/libbb/change_identity.c
index 819b216e0..c2b73eeb8 100644
--- a/libbb/change_identity.c
+++ b/libbb/change_identity.c
@@ -43,12 +43,12 @@
 void change_identity ( const struct passwd *pw )
 {
 	if ( initgroups ( pw-> pw_name, pw-> pw_gid ) == -1 )
-		perror_msg_and_die ( "cannot set groups" );
+		bb_perror_msg_and_die ( "cannot set groups" );
 	endgrent ( );
 
 	if ( setgid ( pw-> pw_gid ))
-		perror_msg_and_die ( "cannot set group id" );
+		bb_perror_msg_and_die ( "cannot set group id" );
 	if ( setuid ( pw->pw_uid ))
-		perror_msg_and_die ( "cannot set user id" );
+		bb_perror_msg_and_die ( "cannot set user id" );
 }
 
diff --git a/libbb/compare_string_array.c b/libbb/compare_string_array.c
index b158ae447..993b46266 100644
--- a/libbb/compare_string_array.c
+++ b/libbb/compare_string_array.c
@@ -27,4 +27,5 @@ extern unsigned short compare_string_array(const char *string_array[], const cha
 		}
 	}
 	return(i);
-}
\ No newline at end of file
+}
+
diff --git a/libbb/concat_path_file.c b/libbb/concat_path_file.c
index 0146606a1..b972ba6a3 100644
--- a/libbb/concat_path_file.c
+++ b/libbb/concat_path_file.c
@@ -38,7 +38,7 @@ extern char *concat_path_file(const char *path, const char *filename)
 	lc = last_char_is(path, '/');
 	while (*filename == '/')
 		filename++;
-       bb_asprintf(&outbuf, "%s%s%s", path, (lc==NULL)? "/" : "", filename);
+	bb_xasprintf(&outbuf, "%s%s%s", path, (lc==NULL)? "/" : "", filename);
 
 	return outbuf;
 }
diff --git a/libbb/copy_file.c b/libbb/copy_file.c
index 23a2d75a3..81c547479 100644
--- a/libbb/copy_file.c
+++ b/libbb/copy_file.c
@@ -43,19 +43,19 @@ int copy_file(const char *source, const char *dest, int flags)
 			lstat(source, &source_stat) < 0) ||
 			((flags & FILEUTILS_DEREFERENCE) &&
 			 stat(source, &source_stat) < 0)) {
-		perror_msg("%s", source);
+		bb_perror_msg("%s", source);
 		return -1;
 	}
 
 	if (lstat(dest, &dest_stat) < 0) {
 		if (errno != ENOENT) {
-			perror_msg("unable to stat `%s'", dest);
+			bb_perror_msg("unable to stat `%s'", dest);
 			return -1;
 		}
 	} else {
 		if (source_stat.st_dev == dest_stat.st_dev &&
 			source_stat.st_ino == dest_stat.st_ino) {
-		error_msg("`%s' and `%s' are the same file", source, dest);
+		bb_error_msg("`%s' and `%s' are the same file", source, dest);
 		return -1;
 	}
 		dest_exists = 1;
@@ -67,14 +67,14 @@ int copy_file(const char *source, const char *dest, int flags)
 		mode_t saved_umask = 0;
 
 		if (!(flags & FILEUTILS_RECUR)) {
-			error_msg("%s: omitting directory", source);
+			bb_error_msg("%s: omitting directory", source);
 			return -1;
 		}
 
 		/* Create DEST.  */
 		if (dest_exists) {
 			if (!S_ISDIR(dest_stat.st_mode)) {
-				error_msg("`%s' is not a directory", dest);
+				bb_error_msg("`%s' is not a directory", dest);
 				return -1;
 			}
 		} else {
@@ -88,7 +88,7 @@ int copy_file(const char *source, const char *dest, int flags)
 
 			if (mkdir(dest, mode) < 0) {
 				umask(saved_umask);
-				perror_msg("cannot create directory `%s'", dest);
+				bb_perror_msg("cannot create directory `%s'", dest);
 				return -1;
 			}
 
@@ -97,7 +97,7 @@ int copy_file(const char *source, const char *dest, int flags)
 
 		/* Recursively copy files in SOURCE.  */
 		if ((dp = opendir(source)) == NULL) {
-			perror_msg("unable to open directory `%s'", source);
+			bb_perror_msg("unable to open directory `%s'", source);
 			status = -1;
 			goto end;
 		}
@@ -121,7 +121,7 @@ int copy_file(const char *source, const char *dest, int flags)
 
 		if (!dest_exists &&
 				chmod(dest, source_stat.st_mode & ~saved_umask) < 0) {
-			perror_msg("unable to change permissions of `%s'", dest);
+			bb_perror_msg("unable to change permissions of `%s'", dest);
 			status = -1;
 		}
 	} else if (S_ISREG(source_stat.st_mode)) {
@@ -132,7 +132,7 @@ int copy_file(const char *source, const char *dest, int flags)
 		if (!(flags & FILEUTILS_DEREFERENCE) &&
 				is_in_ino_dev_hashtable(&source_stat, &link_name)) {
 			if (link(link_name, dest) < 0) {
-				perror_msg("unable to link `%s'", dest);
+				bb_perror_msg("unable to link `%s'", dest);
 				return -1;
 			}
 
@@ -140,14 +140,14 @@ int copy_file(const char *source, const char *dest, int flags)
 		}
 #endif
 
-		if ((sfp = wfopen(source, "r")) == NULL) {
+		if ((sfp = bb_wfopen(source, "r")) == NULL) {
 			return -1;
 		}
 
 		if (dest_exists) {
 			if (flags & FILEUTILS_INTERACTIVE) {
-				fprintf(stderr, "%s: overwrite `%s'? ", applet_name, dest);
-				if (!ask_confirmation()) {
+				fprintf(stderr, "%s: overwrite `%s'? ", bb_applet_name, dest);
+				if (!bb_ask_confirmation()) {
 					fclose (sfp);
 					return 0;
 				}
@@ -155,13 +155,13 @@ int copy_file(const char *source, const char *dest, int flags)
 
 			if ((dfp = fopen(dest, "w")) == NULL) {
 				if (!(flags & FILEUTILS_FORCE)) {
-					perror_msg("unable to open `%s'", dest);
+					bb_perror_msg("unable to open `%s'", dest);
 					fclose (sfp);
 					return -1;
 				}
 
 				if (unlink(dest) < 0) {
-					perror_msg("unable to remove `%s'", dest);
+					bb_perror_msg("unable to remove `%s'", dest);
 					fclose (sfp);
 					return -1;
 				}
@@ -177,22 +177,22 @@ int copy_file(const char *source, const char *dest, int flags)
 					(dfp = fdopen(fd, "w")) == NULL) {
 				if (fd >= 0)
 					close(fd);
-				perror_msg("unable to open `%s'", dest);
+				bb_perror_msg("unable to open `%s'", dest);
 				fclose (sfp);
 				return -1;
 			}
 		}
 
-		if (copyfd(fileno(sfp), fileno(dfp), 0) == -1)
+		if (bb_copyfd(fileno(sfp), fileno(dfp), 0) == -1)
 			status = -1;
 
 		if (fclose(dfp) < 0) {
-			perror_msg("unable to close `%s'", dest);
+			bb_perror_msg("unable to close `%s'", dest);
 			status = -1;
 		}
 
 		if (fclose(sfp) < 0) {
-			perror_msg("unable to close `%s'", source);
+			bb_perror_msg("unable to close `%s'", source);
 			status = -1;
 		}
 			}
@@ -202,23 +202,23 @@ int copy_file(const char *source, const char *dest, int flags)
 
 		if (dest_exists &&
 		       ((flags & FILEUTILS_FORCE) == 0 || unlink(dest) < 0)) {
-				perror_msg("unable to remove `%s'", dest);
+				bb_perror_msg("unable to remove `%s'", dest);
 				return -1;
 
 			}
 	} else {
-		error_msg("internal error: unrecognized file type");
+		bb_error_msg("internal error: unrecognized file type");
 		return -1;
 		}
 	if (S_ISBLK(source_stat.st_mode) || S_ISCHR(source_stat.st_mode) ||
 	    S_ISSOCK(source_stat.st_mode)) {
 		if (mknod(dest, source_stat.st_mode, source_stat.st_rdev) < 0) {
-			perror_msg("unable to create `%s'", dest);
+			bb_perror_msg("unable to create `%s'", dest);
 			return -1;
 		}
 	} else if (S_ISFIFO(source_stat.st_mode)) {
 		if (mkfifo(dest, source_stat.st_mode) < 0) {
-			perror_msg("cannot create fifo `%s'", dest);
+			bb_perror_msg("cannot create fifo `%s'", dest);
 			return -1;
 		}
 	} else if (S_ISLNK(source_stat.st_mode)) {
@@ -226,7 +226,7 @@ int copy_file(const char *source, const char *dest, int flags)
 
 		lpath = xreadlink(source);
 		if (symlink(lpath, dest) < 0) {
-			perror_msg("cannot create symlink `%s'", dest);
+			bb_perror_msg("cannot create symlink `%s'", dest);
 			return -1;
 		}
 		free(lpath);
@@ -234,7 +234,7 @@ int copy_file(const char *source, const char *dest, int flags)
 #if (__GLIBC__ >= 2) && (__GLIBC_MINOR__ >= 1)
 		if (flags & FILEUTILS_PRESERVE_STATUS)
 			if (lchown(dest, source_stat.st_uid, source_stat.st_gid) < 0)
-				perror_msg("unable to preserve ownership of `%s'", dest);
+				bb_perror_msg("unable to preserve ownership of `%s'", dest);
 #endif
 
 #ifdef CONFIG_FEATURE_PRESERVE_HARDLINKS
@@ -256,13 +256,13 @@ end:
 		times.actime = source_stat.st_atime;
 		times.modtime = source_stat.st_mtime;
 		if (utime(dest, &times) < 0)
-			perror_msg("unable to preserve times of `%s'", dest);
+			bb_perror_msg("unable to preserve times of `%s'", dest);
 		if (chown(dest, source_stat.st_uid, source_stat.st_gid) < 0) {
 			source_stat.st_mode &= ~(S_ISUID | S_ISGID);
-			perror_msg("unable to preserve ownership of `%s'", dest);
+			bb_perror_msg("unable to preserve ownership of `%s'", dest);
 		}
 		if (chmod(dest, source_stat.st_mode) < 0)
-			perror_msg("unable to preserve permissions of `%s'", dest);
+			bb_perror_msg("unable to preserve permissions of `%s'", dest);
 	}
 
 	return status;
diff --git a/libbb/copy_file_chunk.c b/libbb/copy_file_chunk.c
deleted file mode 100644
index 63d2ab173..000000000
--- a/libbb/copy_file_chunk.c
+++ /dev/null
@@ -1,70 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * Utility routines.
- *
- * Copyright (C) many different people.  If you wrote this, please
- * acknowledge your work.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
- */
-
-#include <stdio.h>
-#include <sys/stat.h>
-#include "libbb.h"
-
-/* Copy CHUNKSIZE bytes (or until EOF if CHUNKSIZE equals -1) from SRC_FILE
- * to DST_FILE.  */
-extern int copy_file_chunk(FILE *src_file, FILE *dst_file, unsigned long long chunksize)
-{
-	size_t nread, nwritten, size;
-	char buffer[BUFSIZ];
-
-	while (chunksize != 0) {
-		if (chunksize > BUFSIZ)
-			size = BUFSIZ;
-		else
-			size = chunksize;
-
-		nread = fread (buffer, 1, size, src_file);
-
-		if (nread != size && ferror (src_file)) {
-			perror_msg ("read");
-			return -1;
-		} else if (nread == 0) {
-			if (chunksize != -1) {
-				error_msg ("Unable to read all data");
-				return -1;
-			}
-
-			return 0;
-		}
-
-		nwritten = fwrite (buffer, 1, nread, dst_file);
-
-		if (nwritten != nread) {
-			if (ferror (dst_file))
-				perror_msg ("write");
-			else
-				error_msg ("Unable to write all data");
-			return -1;
-		}
-
-		if (chunksize != -1)
-			chunksize -= nwritten;
-	}
-
-	return 0;
-}
diff --git a/libbb/copyfd.c b/libbb/copyfd.c
index 4df1fd084..41b78c7d6 100644
--- a/libbb/copyfd.c
+++ b/libbb/copyfd.c
@@ -22,65 +22,51 @@
 #include <unistd.h>
 #include <string.h>
 #include <errno.h>
-#include "libbb.h"
+#include "busybox.h"
 
-/* If chunksize is 0 copy untill EOF */
-extern int copyfd(int fd1, int fd2, const off_t chunksize)
+#if BUFSIZ < 4096
+#undef BUFSIZ
+#define BUFSIZ 4096
+#endif
+
+/* If chunksize is 0 copy until EOF */
+extern int bb_copyfd(int fd1, int fd2, const off_t chunksize)
 {
-	size_t nread;
-	size_t nwritten;
+	ssize_t nread;
 	size_t size;
-	size_t remaining;
-	char buffer[BUFSIZ];
+	off_t remaining;
+	RESERVE_CONFIG_BUFFER(buffer,BUFSIZ);
 
+	remaining = size = BUFSIZ;
 	if (chunksize) {
 		remaining = chunksize;
-	} else {
-		remaining = -1;
 	}
 
 	do {
-		if ((chunksize > BUFSIZ) || (chunksize == 0)) {
-			size = BUFSIZ;
-		} else {
-			size = chunksize;
+		if (size > remaining) {
+			size = remaining;
 		}
 
-		nread = safe_read(fd1, buffer, size);
-
-		if (nread == -1) {
-			perror_msg("read failure");
-			return(-1);
-		}
-		else if (nread == 0) {
+		if ((nread = safe_read(fd1, buffer, size)) > 0) {
+			if (bb_full_write(fd2, buffer, nread) < 0) {
+				bb_perror_msg(bb_msg_write_error);	/* match Read error below */
+				break;
+			}
+			if (chunksize && ((remaining -= nread) == 0)) {
+				return 0;
+			}
+		} else if (!nread) {
 			if (chunksize) {
-				error_msg("Unable to read all data");
-				return(-1);
-			} else {
-				return(0);
+				bb_error_msg("Unable to read all data");
+				break;
 			}
+			return 0;
+		} else {				/* nread < 0 */
+			bb_perror_msg("Read error");	/* match bb_msg_write_error above */
+			break;
 		}
 
-		nwritten = full_write(fd2, buffer, nread);
+	} while (1);
 
-		if (nwritten != nread) {
-			error_msg("Unable to write all data");
-			return(-1);
-		}
-
-		if (chunksize) {
-			remaining -= nwritten;
-		}
-	} while (remaining != 0);
-
-	return 0;
+	return -1;
 }
-
-/* END CODE */
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
diff --git a/libbb/correct_password.c b/libbb/correct_password.c
index 758b89eed..396253614 100644
--- a/libbb/correct_password.c
+++ b/libbb/correct_password.c
@@ -55,7 +55,7 @@ int correct_password ( const struct passwd *pw )
 		struct spwd *sp = getspnam ( pw-> pw_name );
 		
 		if ( !sp )
-			error_msg_and_die ( "no valid shadow password" );
+			bb_error_msg_and_die ( "no valid shadow password" );
 		
 		correct = sp-> sp_pwdp;
 	}
@@ -73,6 +73,6 @@ int correct_password ( const struct passwd *pw )
 		return 0;
 	}
 	encrypted = crypt ( unencrypted, correct );
-	memset ( unencrypted, 0, xstrlen ( unencrypted ));
+	memset ( unencrypted, 0, bb_strlen ( unencrypted ));
 	return ( strcmp ( encrypted, correct ) == 0 ) ? 1 : 0;
 }
diff --git a/libbb/create_icmp6_socket.c b/libbb/create_icmp6_socket.c
index 1d0b6b6bf..596610449 100644
--- a/libbb/create_icmp6_socket.c
+++ b/libbb/create_icmp6_socket.c
@@ -26,9 +26,9 @@ int create_icmp6_socket(void)
 	if ((sock = socket(AF_INET6, SOCK_RAW,
 			(proto ? proto->p_proto : IPPROTO_ICMPV6))) < 0) {
 		if (errno == EPERM)
-			error_msg_and_die("permission denied. (are you root?)");
+			bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 		else
-			perror_msg_and_die(can_not_create_raw_socket);
+			bb_perror_msg_and_die(bb_msg_can_not_create_raw_socket);
 	}
 
 	/* drop root privs if running setuid */
diff --git a/libbb/create_icmp_socket.c b/libbb/create_icmp_socket.c
index d804b3987..58d792b1b 100644
--- a/libbb/create_icmp_socket.c
+++ b/libbb/create_icmp_socket.c
@@ -25,9 +25,9 @@ int create_icmp_socket(void)
 	if ((sock = socket(AF_INET, SOCK_RAW,
 			(proto ? proto->p_proto : 1))) < 0) {        /* 1 == ICMP */
 		if (errno == EPERM)
-			error_msg_and_die("permission denied. (are you root?)");
+			bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 		else
-			perror_msg_and_die(can_not_create_raw_socket);
+			bb_perror_msg_and_die(bb_msg_can_not_create_raw_socket);
 	}
 
 	/* drop root privs if running setuid */
diff --git a/libbb/default_error_retval.c b/libbb/default_error_retval.c
new file mode 100644
index 000000000..7d2d89bb5
--- /dev/null
+++ b/libbb/default_error_retval.c
@@ -0,0 +1,32 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+/* Seems silly to copyright a global variable.  ;-)  Oh well.
+ *
+ * At least one applet (cmp) returns a value different from the typical
+ * EXIT_FAILURE values (1) when an error occurs.  So, make it configureable
+ * by the applet.  I suppose we could use a wrapper function to set it, but
+ * that too seems silly.
+ */
+
+#include <stdlib.h>
+#include "libbb.h"
+
+int bb_default_error_retval = EXIT_FAILURE;
diff --git a/libbb/dirname.c b/libbb/dirname.c
index df9a49daa..81298730b 100644
--- a/libbb/dirname.c
+++ b/libbb/dirname.c
@@ -1,8 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini dirname function.
+ * dirname implementation for busybox (for libc's missing one)
  *
- * Copyright (C) 2001  Matt Kraai.
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -17,39 +17,53 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+/* Note: The previous busybox implementation did not handle NULL path
+ * and also moved a pointer before path, which is not portable in C.
+ * So I replaced it with my uClibc version.
  */
 
 #include <string.h>
 #include "libbb.h"
 
-#if defined __UCLIBC__ || __GNU_LIBRARY___ < 5
-
-/* Return a string containing the path name of the parent
- * directory of PATH.  */
+#if __GNU_LIBRARY__ < 5
 
+extern 
 char *dirname(char *path)
 {
-	char *s;
-
-	/* Go to the end of the string.  */
-	s = path + strlen(path) - 1;
-
-	/* Strip off trailing /s (unless it is also the leading /).  */
-	while (path < s && s[0] == '/')
-		s--;
+	static const char null_or_empty_or_noslash[] = ".";
+	register char *s;
+	register char *last;
+	char *first;
 
-	/* Strip the last component.  */
-	while (path <= s && s[0] != '/')
-		s--;
+	last = s = path;
 
-	while (path < s && s[0] == '/')
-		s--;
+	if (s != NULL) {
 
-	if (s < path)
-		return ".";
+	LOOP:
+		while (*s && (*s != '/')) ++s;
+		first = s;
+		while (*s == '/') ++s;
+		if (*s) {
+			last = first;
+			goto LOOP;
+		}
 
-	s[1] = '\0';
-	return path;
+		if (last == path) {
+			if (*last != '/') {
+				goto DOT;
+			}
+			if ((*++last == '/') && (last[1] == 0)) {
+				++last;
+			}
+		}
+		*last = 0;
+		return path;
+	}
+ DOT:
+	return (char *) null_or_empty_or_noslash;
 }
 
 #endif
diff --git a/libbb/dump.c b/libbb/dump.c
index 1afad83fd..26dabe57f 100644
--- a/libbb/dump.c
+++ b/libbb/dump.c
@@ -25,94 +25,80 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>		/* for isdigit() */
-#include "dump.h"
 #include "libbb.h"
+#include "dump.h"
 
-enum _vflag vflag = FIRST;
-FS *fshead;				/* head of format strings */
-extern FS *fshead;		/* head of format strings */
-extern int blocksize;
+enum _vflag bb_dump_vflag = FIRST;
+FS *bb_dump_fshead;				/* head of format strings */
 static FU *endfu;
 static char **_argv;
 static off_t savaddress;	/* saved address/offset in stream */
 static off_t eaddress;	/* end address */
 static off_t address;	/* address/offset in stream */
-off_t skip;				/* bytes to skip */
-off_t saveaddress;
-int exitval;			/* final exit value */
-int blocksize;			/* data block size */
-int length = -1;		/* max bytes to read */
+off_t bb_dump_skip;				/* bytes to skip */
+static int exitval;			/* final exit value */
+int bb_dump_blocksize;			/* data block size */
+int bb_dump_length = -1;		/* max bytes to read */
+
+static const char index_str[] = ".#-+ 0123456789";
 
+static const char size_conv_str[] =
+"\x1\x4\x4\x4\x4\x4\x4\x8\x8\x8\x8\010cdiouxXeEfgG";
 
-int size(FS * fs)
+static const char lcc[] = "diouxX";
+
+int bb_dump_size(FS * fs)
 {
 	register FU *fu;
-	register int bcnt, cursize;
+	register int bcnt, cur_size;
 	register char *fmt;
+	const char *p;
 	int prec;
 
-	/* figure out the data block size needed for each format unit */
-	for (cursize = 0, fu = fs->nextfu; fu; fu = fu->nextfu) {
+	/* figure out the data block bb_dump_size needed for each format unit */
+	for (cur_size = 0, fu = fs->nextfu; fu; fu = fu->nextfu) {
 		if (fu->bcnt) {
-			cursize += fu->bcnt * fu->reps;
+			cur_size += fu->bcnt * fu->reps;
 			continue;
 		}
 		for (bcnt = prec = 0, fmt = fu->fmt; *fmt; ++fmt) {
 			if (*fmt != '%')
 				continue;
 			/*
-			 * skip any special chars -- save precision in
+			 * bb_dump_skip any special chars -- save precision in
 			 * case it's a %s format.
 			 */
-			while (index(".#-+ 0123456789" + 1, *++fmt));
+			while (strchr(index_str + 1, *++fmt));
 			if (*fmt == '.' && isdigit(*++fmt)) {
 				prec = atoi(fmt);
 				while (isdigit(*++fmt));
 			}
-			switch (*fmt) {
-			case 'c':
-				bcnt += 1;
-				break;
-			case 'd':
-			case 'i':
-			case 'o':
-			case 'u':
-			case 'x':
-			case 'X':
-				bcnt += 4;
-				break;
-			case 'e':
-			case 'E':
-			case 'f':
-			case 'g':
-			case 'G':
-				bcnt += 8;
-				break;
-			case 's':
-				bcnt += prec;
-				break;
-			case '_':
-				switch (*++fmt) {
-				case 'c':
-				case 'p':
-				case 'u':
-					bcnt += 1;
-					break;
+			if (!(p = strchr(size_conv_str + 12, *fmt))) {
+				if (*fmt == 's') {
+					bcnt += prec;
+				} else if (*fmt == '_') {
+					++fmt;
+					if ((*fmt == 'c') || (*fmt == 'p') || (*fmt == 'u')) {
+						bcnt += 1;
+					}
 				}
+			} else {
+				bcnt += size_conv_str[p - (size_conv_str + 12)];
 			}
 		}
-		cursize += bcnt * fu->reps;
+		cur_size += bcnt * fu->reps;
 	}
-	return (cursize);
+	return (cur_size);
 }
 
-void rewrite(FS * fs)
+static void rewrite(FS * fs)
 {
 	enum { NOTOKAY, USEBCNT, USEPREC } sokay;
 	register PR *pr, **nextpr = NULL;
 	register FU *fu;
 	register char *p1, *p2;
 	char savech, *fmtp;
+	const char *byte_count_str;
 	int nconv, prec = 0;
 
 	for (fu = fs->nextfu; fu; fu = fu->nextfu) {
@@ -128,7 +114,7 @@ void rewrite(FS * fs)
 			else
 				*nextpr = pr;
 
-			/* skip preceding text and up to the next % sign */
+			/* bb_dump_skip preceding text and up to the next % sign */
 			for (p1 = fmtp; *p1 && *p1 != '%'; ++p1);
 
 			/* only text in the string */
@@ -144,11 +130,11 @@ void rewrite(FS * fs)
 			 */
 			if (fu->bcnt) {
 				sokay = USEBCNT;
-				/* skip to conversion character */
-				for (++p1; index(".#-+ 0123456789", *p1); ++p1);
+				/* bb_dump_skip to conversion character */
+				for (++p1; strchr(index_str, *p1); ++p1);
 			} else {
-				/* skip any special chars, field width */
-				while (index(".#-+ 0123456789" + 1, *++p1));
+				/* bb_dump_skip any special chars, field width */
+				while (strchr(index_str + 1, *++p1));
 				if (*p1 == '.' && isdigit(*++p1)) {
 					sokay = USEPREC;
 					prec = atoi(p1);
@@ -162,104 +148,59 @@ void rewrite(FS * fs)
 			/*
 			 * figure out the byte count for each conversion;
 			 * rewrite the format as necessary, set up blank-
-			 * padding for end of data.
+			 * pbb_dump_adding for end of data.
 			 */
-			switch (*p1) {
-			case 'c':
+
+			if (*p1 == 'c') {
 				pr->flags = F_CHAR;
-				switch (fu->bcnt) {
-				case 0:
-				case 1:
-					pr->bcnt = 1;
-					break;
-				default:
-					p1[1] = '\0';
-					error_msg_and_die
-						("bad byte count for conversion character %s.", p1);
+			DO_BYTE_COUNT_1:
+				byte_count_str = "\001";
+			DO_BYTE_COUNT:
+				if (fu->bcnt) {
+					do {
+						if (fu->bcnt == *byte_count_str) {
+							break;
+						}
+					} while (*++byte_count_str);
 				}
-				break;
-			case 'd':
-			case 'i':
-				pr->flags = F_INT;
-				goto sw1;
-			case 'l':
+				/* Unlike the original, output the remainder of the format string. */
+				if (!*byte_count_str) {
+					bb_error_msg_and_die("bad byte count for conversion character %s.", p1);
+				}
+				pr->bcnt = *byte_count_str;
+			} else if (*p1 == 'l') {
 				++p2;
-				switch (p1[1]) {
-				case 'd':
-				case 'i':
-					++p1;
+				++p1;
+			DO_INT_CONV:
+				{
+					const char *e;
+					if (!(e = strchr(lcc, *p1))) {
+						goto DO_BAD_CONV_CHAR;
+					}
 					pr->flags = F_INT;
-					goto sw1;
-				case 'o':
-				case 'u':
-				case 'x':
-				case 'X':
-					++p1;
-					pr->flags = F_UINT;
-					goto sw1;
-				default:
-					p1[2] = '\0';
-					error_msg_and_die
-						("hexdump: bad conversion character %%%s.\n", p1);
+					if (e > lcc + 1) {
+						pr->flags = F_UINT;
+					}
+					byte_count_str = "\004\002\001";
+					goto DO_BYTE_COUNT;
 				}
 				/* NOTREACHED */
-			case 'o':
-			case 'u':
-			case 'x':
-			case 'X':
-				pr->flags = F_UINT;
-			  sw1:switch (fu->bcnt) {
-				case 0:
-				case 4:
-					pr->bcnt = 4;
-					break;
-				case 1:
-					pr->bcnt = 1;
-					break;
-				case 2:
-					pr->bcnt = 2;
-					break;
-				default:
-					p1[1] = '\0';
-					error_msg_and_die
-						("bad byte count for conversion character %s.", p1);
-				}
-				break;
-			case 'e':
-			case 'E':
-			case 'f':
-			case 'g':
-			case 'G':
+			} else if (strchr(lcc, *p1)) {
+				goto DO_INT_CONV;
+			} else if (strchr("eEfgG", *p1)) {
 				pr->flags = F_DBL;
-				switch (fu->bcnt) {
-				case 0:
-				case 8:
-					pr->bcnt = 8;
-					break;
-				case 4:
-					pr->bcnt = 4;
-					break;
-				default:
-					p1[1] = '\0';
-					error_msg_and_die
-						("bad byte count for conversion character %s.", p1);
-				}
-				break;
-			case 's':
+				byte_count_str = "\010\004";
+				goto DO_BYTE_COUNT;
+			} else if (*p1 == 's') {
 				pr->flags = F_STR;
-				switch (sokay) {
-				case NOTOKAY:
-					error_msg_and_die
-						("%%s requires a precision or a byte count.");
-				case USEBCNT:
+				if (sokay == USEBCNT) {
 					pr->bcnt = fu->bcnt;
-					break;
-				case USEPREC:
+				} else if (sokay == USEPREC) {
 					pr->bcnt = prec;
-					break;
+				} else {	/* NOTOKAY */
+					bb_error_msg_and_die("%%s requires a precision or a byte count.");
 				}
-				break;
-			case '_':
+			} else if (*p1 == '_') {
 				++p2;
 				switch (p1[1]) {
 				case 'A':
@@ -269,51 +210,29 @@ void rewrite(FS * fs)
 				case 'a':
 					pr->flags = F_ADDRESS;
 					++p2;
-					switch (p1[2]) {
-					case 'd':
-					case 'o':
-					case 'x':
-						*p1 = p1[2];
-						break;
-					default:
-						p1[3] = '\0';
-						error_msg_and_die
-							("hexdump: bad conversion character %%%s.\n", p1);
+					if ((p1[2] != 'd') && (p1[2] != 'o') && (p1[2] != 'x')) {
+						goto DO_BAD_CONV_CHAR;
 					}
+					*p1 = p1[2];
 					break;
 				case 'c':
 					pr->flags = F_C;
 					/* *p1 = 'c';   set in conv_c */
-					goto sw2;
+					goto DO_BYTE_COUNT_1;
 				case 'p':
 					pr->flags = F_P;
 					*p1 = 'c';
-					goto sw2;
+					goto DO_BYTE_COUNT_1;
 				case 'u':
 					pr->flags = F_U;
 					/* *p1 = 'c';   set in conv_u */
-				  sw2:switch (fu->bcnt) {
-					case 0:
-					case 1:
-						pr->bcnt = 1;
-						break;
-					default:
-						p1[2] = '\0';
-						error_msg_and_die
-							("bad byte count for conversion character %s.",
-							 p1);
-					}
-					break;
+					goto DO_BYTE_COUNT_1;
 				default:
-					p1[2] = '\0';
-					error_msg_and_die
-						("hexdump: bad conversion character %%%s.\n", p1);
+					goto DO_BAD_CONV_CHAR;
 				}
-				break;
-			default:
-				p1[1] = '\0';
-				error_msg_and_die("hexdump: bad conversion character %%%s.\n",
-								  p1);
+			} else {
+			DO_BAD_CONV_CHAR:
+				bb_error_msg_and_die("bad conversion character %%%s.\n", p1);
 			}
 
 			/*
@@ -322,16 +241,14 @@ void rewrite(FS * fs)
 			 */
 			savech = *p2;
 			p1[1] = '\0';
-			if (!(pr->fmt = strdup(fmtp)))
-				perror_msg_and_die("hexdump");
+			pr->fmt = bb_xstrdup(fmtp);
 			*p2 = savech;
 			pr->cchar = pr->fmt + (p1 - fmtp);
 			fmtp = p2;
 
 			/* only one conversion character if byte count */
 			if (!(pr->flags & F_ADDRESS) && fu->bcnt && nconv++) {
-				error_msg_and_die
-					("hexdump: byte count with multiple conversion characters.\n");
+				bb_error_msg_and_die("byte count with multiple conversion characters.\n");
 			}
 		}
 		/*
@@ -344,7 +261,7 @@ void rewrite(FS * fs)
 	}
 	/*
 	 * if the format string interprets any data at all, and it's
-	 * not the same as the blocksize, and its last format unit
+	 * not the same as the bb_dump_blocksize, and its last format unit
 	 * interprets any data at all, and has no iteration count,
 	 * repeat it as necessary.
 	 *
@@ -352,9 +269,9 @@ void rewrite(FS * fs)
 	 * gets output from the last iteration of the format unit.
 	 */
 	for (fu = fs->nextfu;; fu = fu->nextfu) {
-		if (!fu->nextfu && fs->bcnt < blocksize &&
+		if (!fu->nextfu && fs->bcnt < bb_dump_blocksize &&
 			!(fu->flags & F_SETREP) && fu->bcnt)
-			fu->reps += (blocksize - fs->bcnt) / fu->bcnt;
+			fu->reps += (bb_dump_blocksize - fs->bcnt) / fu->bcnt;
 		if (fu->reps > 1) {
 			for (pr = fu->nextpr;; pr = pr->nextpr)
 				if (!pr->nextpr)
@@ -369,31 +286,31 @@ void rewrite(FS * fs)
 	}
 }
 
-static void doskip(char *fname, int statok)
+static void do_skip(char *fname, int statok)
 {
 	struct stat sbuf;
 
 	if (statok) {
 		if (fstat(fileno(stdin), &sbuf)) {
-			perror_msg_and_die("hexdump: %s", fname);
+			bb_perror_msg_and_die("%s", fname);
 		}
 		if ((!(S_ISCHR(sbuf.st_mode) ||
 			   S_ISBLK(sbuf.st_mode) ||
-			   S_ISFIFO(sbuf.st_mode))) && skip >= sbuf.st_size) {
-			/* If size valid and skip >= size */
-			skip -= sbuf.st_size;
+			   S_ISFIFO(sbuf.st_mode))) && bb_dump_skip >= sbuf.st_size) {
+			/* If bb_dump_size valid and bb_dump_skip >= size */
+			bb_dump_skip -= sbuf.st_size;
 			address += sbuf.st_size;
 			return;
 		}
 	}
-	if (fseek(stdin, skip, SEEK_SET)) {
-		perror_msg_and_die("hexdump: %s", fname);
+	if (fseek(stdin, bb_dump_skip, SEEK_SET)) {
+		bb_perror_msg_and_die("%s", fname);
 	}
-	savaddress = address += skip;
-	skip = 0;
+	savaddress = address += bb_dump_skip;
+	bb_dump_skip = 0;
 }
 
-int next(char **argv)
+static int next(char **argv)
 {
 	static int done;
 	int statok;
@@ -405,7 +322,7 @@ int next(char **argv)
 	for (;;) {
 		if (*_argv) {
 			if (!(freopen(*_argv, "r", stdin))) {
-				perror_msg("%s", *_argv);
+				bb_perror_msg("%s", *_argv);
 				exitval = 1;
 				++_argv;
 				continue;
@@ -416,11 +333,11 @@ int next(char **argv)
 				return (0);
 			statok = 0;
 		}
-		if (skip)
-			doskip(statok ? *_argv : "stdin", statok);
+		if (bb_dump_skip)
+			do_skip(statok ? *_argv : "stdin", statok);
 		if (*_argv)
 			++_argv;
-		if (!skip)
+		if (!bb_dump_skip)
 			return (1);
 	}
 	/* NOTREACHED */
@@ -435,26 +352,26 @@ static u_char *get(void)
 	u_char *tmpp;
 
 	if (!curp) {
-		curp = (u_char *) xmalloc(blocksize);
-		savp = (u_char *) xmalloc(blocksize);
+		curp = (u_char *) xmalloc(bb_dump_blocksize);
+		savp = (u_char *) xmalloc(bb_dump_blocksize);
 	} else {
 		tmpp = curp;
 		curp = savp;
 		savp = tmpp;
-		address = savaddress += blocksize;
+		address = savaddress += bb_dump_blocksize;
 	}
-	for (need = blocksize, nread = 0;;) {
+	for (need = bb_dump_blocksize, nread = 0;;) {
 		/*
 		 * if read the right number of bytes, or at EOF for one file,
 		 * and no other files are available, zero-pad the rest of the
 		 * block and set the end flag.
 		 */
-		if (!length || (ateof && !next((char **) NULL))) {
-			if (need == blocksize) {
+		if (!bb_dump_length || (ateof && !next((char **) NULL))) {
+			if (need == bb_dump_blocksize) {
 				return ((u_char *) NULL);
 			}
-			if (vflag != ALL && !bcmp(curp, savp, nread)) {
-				if (vflag != DUP) {
+			if (bb_dump_vflag != ALL && !bcmp(curp, savp, nread)) {
+				if (bb_dump_vflag != DUP) {
 					printf("*\n");
 				}
 				return ((u_char *) NULL);
@@ -464,31 +381,32 @@ static u_char *get(void)
 			return (curp);
 		}
 		n = fread((char *) curp + nread, sizeof(u_char),
-				  length == -1 ? need : MIN(length, need), stdin);
+				  bb_dump_length == -1 ? need : MIN(bb_dump_length, need), stdin);
 		if (!n) {
 			if (ferror(stdin)) {
-				perror_msg("%s", _argv[-1]);
+				bb_perror_msg("%s", _argv[-1]);
 			}
 			ateof = 1;
 			continue;
 		}
 		ateof = 0;
-		if (length != -1) {
-			length -= n;
+		if (bb_dump_length != -1) {
+			bb_dump_length -= n;
 		}
 		if (!(need -= n)) {
-			if (vflag == ALL || vflag == FIRST || bcmp(curp, savp, blocksize)) {
-				if (vflag == DUP || vflag == FIRST) {
-					vflag = WAIT;
+			if (bb_dump_vflag == ALL || bb_dump_vflag == FIRST
+				|| bcmp(curp, savp, bb_dump_blocksize)) {
+				if (bb_dump_vflag == DUP || bb_dump_vflag == FIRST) {
+					bb_dump_vflag = WAIT;
 				}
 				return (curp);
 			}
-			if (vflag == WAIT) {
+			if (bb_dump_vflag == WAIT) {
 				printf("*\n");
 			}
-			vflag = DUP;
-			address = savaddress += blocksize;
-			need = blocksize;
+			bb_dump_vflag = DUP;
+			address = savaddress += bb_dump_blocksize;
+			need = bb_dump_blocksize;
 			nread = 0;
 		} else {
 			nread += n;
@@ -507,67 +425,59 @@ static void bpad(PR * pr)
 	pr->flags = F_BPAD;
 	*pr->cchar = 's';
 	for (p1 = pr->fmt; *p1 != '%'; ++p1);
-	for (p2 = ++p1; *p1 && index(" -0+#", *p1); ++p1);
+	for (p2 = ++p1; *p1 && strchr(" -0+#", *p1); ++p1);
 	while ((*p2++ = *p1++) != 0);
 }
 
-void conv_c(PR * pr, u_char * p)
+static const char conv_str[] =
+	"\0\\0\0"
+	"\007\\a\0"				/* \a */
+	"\b\\b\0"
+	"\f\\b\0"
+	"\n\\n\0"
+	"\r\\r\0"
+	"\t\\t\0"
+	"\v\\v\0"
+	"\0";
+
+
+static void conv_c(PR * pr, u_char * p)
 {
-	char buf[10], *str;
-
-	switch (*p) {
-	case '\0':
-		str = "\\0";
-		goto strpr;
-		/* case '\a': */
-	case '\007':
-		str = "\\a";
-		goto strpr;
-	case '\b':
-		str = "\\b";
-		goto strpr;
-	case '\f':
-		str = "\\f";
-		goto strpr;
-	case '\n':
-		str = "\\n";
-		goto strpr;
-	case '\r':
-		str = "\\r";
-		goto strpr;
-	case '\t':
-		str = "\\t";
-		goto strpr;
-	case '\v':
-		str = "\\v";
-		goto strpr;
-	default:
-		break;
-	}
+	const char *str = conv_str;
+	char buf[10];
+
+	do {
+		if (*p == *str) {
+			++str;
+			goto strpr;
+		}
+		str += 4;
+	} while (*str);
+
 	if (isprint(*p)) {
 		*pr->cchar = 'c';
 		(void) printf(pr->fmt, *p);
 	} else {
-		sprintf(str = buf, "%03o", (int) *p);
+		sprintf(buf, "%03o", (int) *p);
+		str = buf;
 	  strpr:
 		*pr->cchar = 's';
 		printf(pr->fmt, str);
 	}
 }
 
-void conv_u(PR * pr, u_char * p)
+static void conv_u(PR * pr, u_char * p)
 {
-	static char *list[] = {
-		"nul", "soh", "stx", "etx", "eot", "enq", "ack", "bel",
-		"bs", "ht", "lf", "vt", "ff", "cr", "so", "si",
-		"dle", "dcl", "dc2", "dc3", "dc4", "nak", "syn", "etb",
-		"can", "em", "sub", "esc", "fs", "gs", "rs", "us",
-	};
+	static const char list[] =
+		"nul\0soh\0stx\0etx\0eot\0enq\0ack\0bel\0"
+		"bs\0_ht\0_lf\0_vt\0_ff\0_cr\0_so\0_si\0_"
+		"dle\0dcl\0dc2\0dc3\0dc4\0nak\0syn\0etb\0"
+		"can\0em\0_sub\0esc\0fs\0_gs\0_rs\0_us";
 
 	/* od used nl, not lf */
 	if (*p <= 0x1f) {
 		*pr->cchar = 's';
-		printf(pr->fmt, list[*p]);
+		printf(pr->fmt, list[4 * (int)(*p)]);
 	} else if (*p == 0x7f) {
 		*pr->cchar = 's';
 		printf(pr->fmt, "del");
@@ -580,7 +490,7 @@ void conv_u(PR * pr, u_char * p)
 	}
 }
 
-void display(void)
+static void display(void)
 {
 /*  extern FU *endfu; */
 	register FS *fs;
@@ -589,11 +499,11 @@ void display(void)
 	register int cnt;
 	register u_char *bp;
 
-/*  off_t saveaddress; */
+	off_t saveaddress;
 	u_char savech = 0, *savebp;
 
 	while ((bp = get()) != NULL) {
-		for (fs = fshead, savebp = bp, saveaddress = address; fs;
+		for (fs = bb_dump_fshead, savebp = bp, saveaddress = address; fs;
 			 fs = fs->nextfs, bp = savebp, address = saveaddress) {
 			for (fu = fs->nextfu; fu; fu = fu->nextfu) {
 				if (fu->flags & F_IGNORE) {
@@ -707,8 +617,8 @@ void display(void)
 	}
 	if (endfu) {
 		/*
-		 * if eaddress not set, error or file size was multiple of
-		 * blocksize, and no partial block ever found.
+		 * if eaddress not set, error or file bb_dump_size was multiple of
+		 * bb_dump_blocksize, and no partial block ever found.
 		 */
 		if (!eaddress) {
 			if (!address) {
@@ -729,19 +639,19 @@ void display(void)
 	}
 }
 
-int dump(char **argv)
+int bb_dump_dump(char **argv)
 {
 	register FS *tfs;
 
-	/* figure out the data block size */
-	for (blocksize = 0, tfs = fshead; tfs; tfs = tfs->nextfs) {
-		tfs->bcnt = size(tfs);
-		if (blocksize < tfs->bcnt) {
-			blocksize = tfs->bcnt;
+	/* figure out the data block bb_dump_size */
+	for (bb_dump_blocksize = 0, tfs = bb_dump_fshead; tfs; tfs = tfs->nextfs) {
+		tfs->bcnt = bb_dump_size(tfs);
+		if (bb_dump_blocksize < tfs->bcnt) {
+			bb_dump_blocksize = tfs->bcnt;
 		}
 	}
 	/* rewrite the rules, do syntax checking */
-	for (tfs = fshead; tfs; tfs = tfs->nextfs) {
+	for (tfs = bb_dump_fshead; tfs; tfs = tfs->nextfs) {
 		rewrite(tfs);
 	}
 
@@ -751,21 +661,21 @@ int dump(char **argv)
 	return (exitval);
 }
 
-void add(char *fmt)
+void bb_dump_add(const char *fmt)
 {
-	register char *p;
+	register const char *p;
 	register char *p1;
 	register char *p2;
 	static FS **nextfs;
 	FS *tfs;
 	FU *tfu, **nextfu;
-	char *savep;
+	const char *savep;
 
 	/* start new linked list of format units */
 	/* NOSTRICT */
 	tfs = (FS *) xmalloc(sizeof(FS));
-	if (!fshead) {
-		fshead = tfs;
+	if (!bb_dump_fshead) {
+		bb_dump_fshead = tfs;
 	} else {
 		*nextfs = tfs;
 	}
@@ -774,8 +684,8 @@ void add(char *fmt)
 
 	/* take the format string and break it up into format units */
 	for (p = fmt;;) {
-		/* skip leading white space */
-		for (; isspace(*p); ++p);
+		/* bb_dump_skip leading white space */
+		p = bb_skip_whitespace(p);
 		if (!*p) {
 			break;
 		}
@@ -791,43 +701,41 @@ void add(char *fmt)
 		if (isdigit(*p)) {
 			for (savep = p; isdigit(*p); ++p);
 			if (!isspace(*p) && *p != '/') {
-				error_msg_and_die("hexdump: bad format {%s}", fmt);
+				bb_error_msg_and_die("bad format {%s}", fmt);
 			}
 			/* may overwrite either white space or slash */
 			tfu->reps = atoi(savep);
 			tfu->flags = F_SETREP;
-			/* skip trailing white space */
-			for (++p; isspace(*p); ++p);
+			/* bb_dump_skip trailing white space */
+			p = bb_skip_whitespace(++p);
 		}
 
-		/* skip slash and trailing white space */
+		/* bb_dump_skip slash and trailing white space */
 		if (*p == '/') {
-			while (isspace(*++p));
+			p = bb_skip_whitespace(++p);
 		}
 
 		/* byte count */
 		if (isdigit(*p)) {
 			for (savep = p; isdigit(*p); ++p);
 			if (!isspace(*p)) {
-				error_msg_and_die("hexdump: bad format {%s}", fmt);
+				bb_error_msg_and_die("bad format {%s}", fmt);
 			}
 			tfu->bcnt = atoi(savep);
-			/* skip trailing white space */
-			for (++p; isspace(*p); ++p);
+			/* bb_dump_skip trailing white space */
+			p = bb_skip_whitespace(++p);
 		}
 
 		/* format */
 		if (*p != '"') {
-			error_msg_and_die("hexdump: bad format {%s}", fmt);
+			bb_error_msg_and_die("bad format {%s}", fmt);
 		}
 		for (savep = ++p; *p != '"';) {
 			if (*p++ == 0) {
-				error_msg_and_die("hexdump: bad format {%s}", fmt);
+				bb_error_msg_and_die("bad format {%s}", fmt);
 			}
 		}
-		if (!(tfu->fmt = malloc(p - savep + 1))) {
-			perror_msg_and_die("hexdump");
-		}
+		tfu->fmt = xmalloc(p - savep + 1);
 		strncpy(tfu->fmt, savep, p - savep);
 		tfu->fmt[p - savep] = '\0';
 /*      escape(tfu->fmt); */
@@ -841,33 +749,16 @@ void add(char *fmt)
 				break;
 			}
 			if (*p1 == '\\') {
-				switch (*++p1) {
-				case 'a':
-					/* *p2 = '\a'; */
-					*p2 = '\007';
-					break;
-				case 'b':
-					*p2 = '\b';
-					break;
-				case 'f':
-					*p2 = '\f';
-					break;
-				case 'n':
-					*p2 = '\n';
-					break;
-				case 'r':
-					*p2 = '\r';
-					break;
-				case 't':
-					*p2 = '\t';
-					break;
-				case 'v':
-					*p2 = '\v';
-					break;
-				default:
-					*p2 = *p1;
-					break;
-				}
+				const char *cs = conv_str + 4;
+				++p1;
+				*p2 = *p1;
+				do {
+					if (*p1 == cs[2]) {
+						*p2 = cs[0];
+						break;
+					}
+					cs += 4;
+				} while (*cs);
 			}
 		}
 
diff --git a/libbb/error_msg.c b/libbb/error_msg.c
index 58308b6be..5456dd361 100644
--- a/libbb/error_msg.c
+++ b/libbb/error_msg.c
@@ -25,12 +25,12 @@
 #include <stdlib.h>
 #include "libbb.h"
 
-extern void error_msg(const char *s, ...)
+extern void bb_error_msg(const char *s, ...)
 {
 	va_list p;
 
 	va_start(p, s);
-	verror_msg(s, p);
+	bb_verror_msg(s, p);
 	va_end(p);
 	putc('\n', stderr);
 }
diff --git a/libbb/error_msg_and_die.c b/libbb/error_msg_and_die.c
index 67a79c375..7e7393773 100644
--- a/libbb/error_msg_and_die.c
+++ b/libbb/error_msg_and_die.c
@@ -25,15 +25,15 @@
 #include <stdlib.h>
 #include "libbb.h"
 
-extern void error_msg_and_die(const char *s, ...)
+extern void bb_error_msg_and_die(const char *s, ...)
 {
 	va_list p;
 
 	va_start(p, s);
-	verror_msg(s, p);
+	bb_verror_msg(s, p);
 	va_end(p);
 	putc('\n', stderr);
-	exit(EXIT_FAILURE);
+	exit(bb_default_error_retval);
 }
 
 
diff --git a/libbb/fclose_nonstdin.c b/libbb/fclose_nonstdin.c
new file mode 100644
index 000000000..97e303e9c
--- /dev/null
+++ b/libbb/fclose_nonstdin.c
@@ -0,0 +1,37 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * fclose_nonstdin implementation for busybox
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+/* A number of standard utilites can accept multiple command line args
+ * of '-' for stdin, according to SUSv3.  So we encapsulate the check
+ * here to save a little space.
+ */
+
+#include <stdio.h>
+#include <libbb.h>
+
+int bb_fclose_nonstdin(FILE *f)
+{
+	if (f != stdin) {
+		return fclose(f);
+	}
+	return 0;
+}
diff --git a/libbb/fflush_stdout_and_exit.c b/libbb/fflush_stdout_and_exit.c
new file mode 100644
index 000000000..cbba04207
--- /dev/null
+++ b/libbb/fflush_stdout_and_exit.c
@@ -0,0 +1,37 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * fflush_stdout_and_exit implementation for busybox
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+/* Attempt to fflush(stdout), and exit with an error code if stdout is
+ * in an error state.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <libbb.h>
+
+void bb_fflush_stdout_and_exit(int retval)
+{
+	if (fflush(stdout)) {
+		retval = bb_default_error_retval;
+	}
+	exit(retval);
+}
diff --git a/libbb/find_root_device.c b/libbb/find_root_device.c
index 0a3f1bc77..763ac7519 100644
--- a/libbb/find_root_device.c
+++ b/libbb/find_root_device.c
@@ -38,14 +38,14 @@ extern char *find_real_root_device_name(const char* name)
 	dev_t dev;
 
 	if (stat("/", &rootStat) != 0) 
-		perror_msg("could not stat '/'");
+		bb_perror_msg("could not stat '/'");
 	else {
 		if ((dev = rootStat.st_rdev)==0) 
 			dev=rootStat.st_dev;
 
 		dir = opendir("/dev");
 		if (!dir) 
-			perror_msg("could not open '/dev'");
+			bb_perror_msg("could not open '/dev'");
 		else {
 			while((entry = readdir(dir)) != NULL) {
 
@@ -69,7 +69,7 @@ extern char *find_real_root_device_name(const char* name)
 		}
 	}
 	if(fileName==NULL)
-		fileName=xstrdup("/dev/root");
+		fileName=bb_xstrdup("/dev/root");
 	return fileName;
 }
 
diff --git a/libbb/full_read.c b/libbb/full_read.c
index ccf26fc3d..e75f967db 100644
--- a/libbb/full_read.c
+++ b/libbb/full_read.c
@@ -23,17 +23,16 @@
 #include <unistd.h>
 #include "libbb.h"
 
-
 /*
  * Read all of the supplied buffer from a file.
  * This does multiple reads as necessary.
  * Returns the amount read, or -1 on an error.
  * A short read is returned on an end of file.
  */
-int full_read(int fd, char *buf, int len)
+ssize_t bb_full_read(int fd, void *buf, size_t len)
 {
-	int cc;
-	int total;
+	ssize_t cc;
+	ssize_t total;
 
 	total = 0;
 
@@ -41,12 +40,12 @@ int full_read(int fd, char *buf, int len)
 		cc = read(fd, buf, len);
 
 		if (cc < 0)
-			return -1;
+			return cc;	/* read() returns -1 on failure. */
 
 		if (cc == 0)
 			break;
 
-		buf += cc;
+		buf = ((char *)buf) + cc;
 		total += cc;
 		len -= cc;
 	}
diff --git a/libbb/full_write.c b/libbb/full_write.c
index a2c07fbc9..1106a53b4 100644
--- a/libbb/full_write.c
+++ b/libbb/full_write.c
@@ -28,10 +28,10 @@
  * This does multiple writes as necessary.
  * Returns the amount written, or -1 on an error.
  */
-int full_write(int fd, const char *buf, int len)
+ssize_t bb_full_write(int fd, const void *buf, size_t len)
 {
-	int cc;
-	int total;
+	ssize_t cc;
+	ssize_t total;
 
 	total = 0;
 
@@ -39,10 +39,10 @@ int full_write(int fd, const char *buf, int len)
 		cc = write(fd, buf, len);
 
 		if (cc < 0)
-			return -1;
+			return cc;		/* write() returns -1 on failure. */
 
-		buf += cc;
 		total += cc;
+		buf = ((const char *)buf) + cc;
 		len -= cc;
 	}
 
diff --git a/libbb/get_console.c b/libbb/get_console.c
index 794888fa7..562b57703 100644
--- a/libbb/get_console.c
+++ b/libbb/get_console.c
@@ -106,7 +106,7 @@ int get_console_fd(void)
 		if (is_a_console(fd))
 			return fd;
 
-	error_msg("Couldn't get a file descriptor referring to the console");
+	bb_error_msg("Couldn't get a file descriptor referring to the console");
 	return -1;					/* total failure */
 }
 
diff --git a/libbb/get_last_path_component.c b/libbb/get_last_path_component.c
index 6af726c83..497d6ae4e 100644
--- a/libbb/get_last_path_component.c
+++ b/libbb/get_last_path_component.c
@@ -1,8 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * get_last_path_component implementation for busybox
+ * bb_get_last_path_component implementation for busybox
  *
- * Copyright (C) 2001  Manuel Novoa III  <mjn3@opensource.lineo.com>
+ * Copyright (C) 2001  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -24,7 +24,7 @@
 /* WARNING!!! Doing so will break basename applet at least! */
 #define EMULATE_BASENAME	0
 
-char *get_last_path_component(char *path)
+char *bb_get_last_path_component(char *path)
 {
 #if EMULATE_BASENAME
 	static const char null_or_empty[] = ".";
diff --git a/libbb/get_line_from_file.c b/libbb/get_line_from_file.c
index 5e7062127..5af898934 100644
--- a/libbb/get_line_from_file.c
+++ b/libbb/get_line_from_file.c
@@ -21,41 +21,57 @@
  */
 
 #include <stdio.h>
+#include <stdlib.h>
 #include "libbb.h"
 
-
-
-/* get_line_from_file() - This function reads an entire line from a text file
+/* get_line_from_file() - This function reads an entire line from a text file,
  * up to a newline. It returns a malloc'ed char * which must be stored and
- * free'ed  by the caller. */
-extern char *get_line_from_file(FILE *file)
+ * free'ed  by the caller.  If 'c' is nonzero, the trailing '\n' (if any)
+ * is removed.  In event of a read error or EOF, NULL is returned. */
+
+static char *private_get_line_from_file(FILE *file, int c)
 {
-	static const int GROWBY = 80; /* how large we will grow strings by */
+#define GROWBY (80)		/* how large we will grow strings by */
 
 	int ch;
 	int idx = 0;
 	char *linebuf = NULL;
 	int linebufsz = 0;
 
-	while (1) {
-		ch = fgetc(file);
-		if (ch == EOF)
-			break;
+	while ((ch = getc(file)) != EOF) {
 		/* grow the line buffer as necessary */
-		while (idx > linebufsz-2)
+		if (idx > linebufsz-2) {
 			linebuf = xrealloc(linebuf, linebufsz += GROWBY);
+		}
 		linebuf[idx++] = (char)ch;
-		if (ch == '\n' || ch == '\0')
+		if (ch == '\n' || ch == '\0') {
+			if (c) {
+				--idx;
+			}
 			break;
+		}
 	}
 
-	if (idx == 0)
-		return NULL;
-
-	linebuf[idx] = 0;
+	if (linebuf) {
+		if (ferror(file)) {
+			free(linebuf);
+			return NULL;
+		}
+		linebuf[idx] = 0;
+	}
 	return linebuf;
 }
 
+extern char *bb_get_line_from_file(FILE *file)
+{
+	return private_get_line_from_file(file, 0);
+}
+
+extern char *bb_get_chomped_line_from_file(FILE *file)
+{
+	return private_get_line_from_file(file, 1);
+}
+
 
 /* END CODE */
 /*
diff --git a/libbb/time_string.c b/libbb/getopt_ulflags.c
similarity index 54%
rename from libbb/time_string.c
rename to libbb/getopt_ulflags.c
index d103a02f8..91de392b6 100644
--- a/libbb/time_string.c
+++ b/libbb/getopt_ulflags.c
@@ -1,8 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Utility routines.
+ * getopt_ulflags implementation for busybox
  *
- * Copyright (C) 1999,2000,2001 by Erik Andersen <andersee@debian.org>
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -17,46 +17,25 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
  */
 
-#include <stdio.h>
+#include <getopt.h>
 #include <string.h>
-#include <time.h>
-#include <utime.h>
 #include "libbb.h"
 
-
-/*
- * Return the standard ls-like time string from a time_t
- * This is static and so is overwritten on each call.
- */
-const char *time_string(time_t timeVal)
+unsigned long bb_getopt_ulflags(int argc, char **argv, const char *applet_opts)
 {
-	time_t now;
-	char *str;
-	static char buf[26];
-
-	time(&now);
-
-	str = ctime(&timeVal);
-
-	strcpy(buf, &str[4]);
-	buf[12] = '\0';
-
-	if ((timeVal > now) || (timeVal < now - 365 * 24 * 60 * 60L)) {
-		strcpy(&buf[7], &str[20]);
-		buf[11] = '\0';
+	unsigned long flags = 0;
+	const char *s;
+	int c;
+
+	while ((c = getopt(argc, argv, applet_opts)) > 0) {
+		if (!(s = strchr(applet_opts, c))) {
+			bb_show_usage();
+		}
+		flags |= (1 << (s-applet_opts));
 	}
 
-	return buf;
+	return flags;
 }
-
-
-/* END CODE */
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
diff --git a/libbb/herror_msg.c b/libbb/herror_msg.c
index 1081a56b1..4fe921b29 100644
--- a/libbb/herror_msg.c
+++ b/libbb/herror_msg.c
@@ -24,12 +24,12 @@
 
 #include "libbb.h"
 
-extern void herror_msg(const char *s, ...)
+extern void bb_herror_msg(const char *s, ...)
 {
 	va_list p;
 
 	va_start(p, s);
-	vherror_msg(s, p);
+	bb_vherror_msg(s, p);
 	va_end(p);
 }
 
diff --git a/libbb/herror_msg_and_die.c b/libbb/herror_msg_and_die.c
index a47c7ff95..33a8c3e28 100644
--- a/libbb/herror_msg_and_die.c
+++ b/libbb/herror_msg_and_die.c
@@ -24,14 +24,14 @@
 
 #include "libbb.h"
 
-extern void herror_msg_and_die(const char *s, ...)
+extern void bb_herror_msg_and_die(const char *s, ...)
 {
 	va_list p;
 
 	va_start(p, s);
-	vherror_msg(s, p);
+	bb_vherror_msg(s, p);
 	va_end(p);
-	exit(EXIT_FAILURE);
+	exit(bb_default_error_retval);
 }
 
 
diff --git a/libbb/inet_common.c b/libbb/inet_common.c
index 16dd1db7c..5e2343bdd 100644
--- a/libbb/inet_common.c
+++ b/libbb/inet_common.c
@@ -4,7 +4,7 @@
  *
  * Heavily modified by Manuel Novoa III       Mar 12, 2001
  *
- * Version:     $Id: inet_common.c,v 1.5 2002/11/28 09:52:23 bug1 Exp $
+ * Version:     $Id: inet_common.c,v 1.6 2003/03/19 09:12:07 mjn3 Exp $
  *
  */
 
@@ -44,7 +44,7 @@ int INET_resolve(const char *name, struct sockaddr_in *s_in, int hostfirst)
 	/* If we expect this to be a hostname, try hostname database first */
 #ifdef DEBUG
 	if (hostfirst) {
-		error_msg("gethostbyname (%s)", name);
+		bb_error_msg("gethostbyname (%s)", name);
 	}
 #endif
 	if (hostfirst && (hp = gethostbyname(name)) != (struct hostent *) NULL) {
@@ -54,7 +54,7 @@ int INET_resolve(const char *name, struct sockaddr_in *s_in, int hostfirst)
 	}
 	/* Try the NETWORKS database to see if this is a known network. */
 #ifdef DEBUG
-	error_msg("getnetbyname (%s)", name);
+	bb_error_msg("getnetbyname (%s)", name);
 #endif
 	if ((np = getnetbyname(name)) != (struct netent *) NULL) {
 		s_in->sin_addr.s_addr = htonl(np->n_net);
@@ -71,7 +71,7 @@ int INET_resolve(const char *name, struct sockaddr_in *s_in, int hostfirst)
 #endif
 
 #ifdef DEBUG
-	error_msg("gethostbyname (%s)", name);
+	bb_error_msg("gethostbyname (%s)", name);
 #endif
 	if ((hp = gethostbyname(name)) == (struct hostent *) NULL) {
 		errno = h_errno;
@@ -109,7 +109,7 @@ int INET_rresolve(char *name, size_t len, struct sockaddr_in *s_in,
 	/* Grmpf. -FvK */
 	if (s_in->sin_family != AF_INET) {
 #ifdef DEBUG
-		error_msg("rresolve: unsupport address family %d !",
+		bb_error_msg("rresolve: unsupport address family %d !",
 				  s_in->sin_family);
 #endif
 		errno = EAFNOSUPPORT;
@@ -117,7 +117,7 @@ int INET_rresolve(char *name, size_t len, struct sockaddr_in *s_in,
 	}
 	ad = (unsigned long) s_in->sin_addr.s_addr;
 #ifdef DEBUG
-	error_msg("rresolve: %08lx, mask %08x, num %08x", ad, netmask, numeric);
+	bb_error_msg("rresolve: %08lx, mask %08x, num %08x", ad, netmask, numeric);
 #endif
 	if (ad == INADDR_ANY) {
 		if ((numeric & 0x0FFF) == 0) {
@@ -143,7 +143,7 @@ int INET_rresolve(char *name, size_t len, struct sockaddr_in *s_in,
 		if (pn->addr.sin_addr.s_addr == ad && pn->host == host) {
 			safe_strncpy(name, pn->name, len);
 #ifdef DEBUG
-			error_msg("rresolve: found %s %08lx in cache",
+			bb_error_msg("rresolve: found %s %08lx in cache",
 					  (host ? "host" : "net"), ad);
 #endif
 			return (0);
@@ -156,7 +156,7 @@ int INET_rresolve(char *name, size_t len, struct sockaddr_in *s_in,
 	ent = NULL;
 	if (host) {
 #ifdef DEBUG
-		error_msg("gethostbyaddr (%08lx)", ad);
+		bb_error_msg("gethostbyaddr (%08lx)", ad);
 #endif
 		ent = gethostbyaddr((char *) &ad, 4, AF_INET);
 		if (ent != NULL) {
@@ -164,7 +164,7 @@ int INET_rresolve(char *name, size_t len, struct sockaddr_in *s_in,
 		}
 	} else {
 #ifdef DEBUG
-		error_msg("getnetbyaddr (%08lx)", host_ad);
+		bb_error_msg("getnetbyaddr (%08lx)", host_ad);
 #endif
 		np = getnetbyaddr(host_ad, AF_INET);
 		if (np != NULL) {
@@ -178,7 +178,7 @@ int INET_rresolve(char *name, size_t len, struct sockaddr_in *s_in,
 	pn->addr = *s_in;
 	pn->next = INET_nn;
 	pn->host = host;
-	pn->name = xstrdup(name);
+	pn->name = bb_xstrdup(name);
 	INET_nn = pn;
 
 	return (0);
@@ -194,7 +194,7 @@ int INET6_resolve(char *name, struct sockaddr_in6 *sin6)
 	memset(&req, '\0', sizeof req);
 	req.ai_family = AF_INET6;
 	if ((s = getaddrinfo(name, NULL, &req, &ai))) {
-		error_msg("getaddrinfo: %s: %d", name, s);
+		bb_error_msg("getaddrinfo: %s: %d", name, s);
 		return -1;
 	}
 	memcpy(sin6, ai->ai_addr, sizeof(struct sockaddr_in6));
@@ -219,7 +219,7 @@ int INET6_rresolve(char *name, size_t len, struct sockaddr_in6 *sin6,
 	/* Grmpf. -FvK */
 	if (sin6->sin6_family != AF_INET6) {
 #ifdef DEBUG
-		error_msg(_("rresolve: unsupport address family %d !\n"),
+		bb_error_msg(_("rresolve: unsupport address family %d !\n"),
 				  sin6->sin6_family);
 #endif
 		errno = EAFNOSUPPORT;
@@ -240,7 +240,7 @@ int INET6_rresolve(char *name, size_t len, struct sockaddr_in6 *sin6,
 
 	s = getnameinfo((struct sockaddr *) sin6, sizeof(struct sockaddr_in6), name, len, NULL, 0, 0);
 	if (s) {
-		error_msg("getnameinfo failed");
+		bb_error_msg("getnameinfo failed");
 		return -1;
 	}
 	return (0);
diff --git a/libbb/interface.c b/libbb/interface.c
index fb794169d..531700f45 100644
--- a/libbb/interface.c
+++ b/libbb/interface.c
@@ -15,7 +15,7 @@
  *              that either displays or sets the characteristics of
  *              one or more of the system's networking interfaces.
  *
- * Version:     $Id: interface.c,v 1.14 2003/02/09 22:40:33 bug1 Exp $
+ * Version:     $Id: interface.c,v 1.15 2003/03/19 09:12:07 mjn3 Exp $
  *
  * Author:      Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
  *              and others.  Copyright 1993 MicroWalt Corporation
@@ -619,7 +619,7 @@ static int aftrans_opt(const char *arg)
 			if (strcmp(tmp1, paft->alias))
 				continue;
 			if (strlen(paft->name) + strlen(afname) + 1 >= sizeof(afname)) {
-				error_msg(_("Too many address family arguments."));
+				bb_error_msg(_("Too many address family arguments."));
 				return (0);
 			}
 			if (paft->flag)
@@ -630,7 +630,7 @@ static int aftrans_opt(const char *arg)
 			break;
 		}
 		if (!paft->alias) {
-			error_msg(_("Unknown address family `%s'."), tmp1);
+			bb_error_msg(_("Unknown address family `%s'."), tmp1);
 			return (1);
 		}
 		tmp1 = tmp2;
@@ -693,7 +693,7 @@ static struct aftype *get_aftype(const char *name)
 		afp++;
 	}
 	if (strchr(name, ','))
-		error_msg(_("Please don't supply more than one address family."));
+		bb_error_msg(_("Please don't supply more than one address family."));
 	return (NULL);
 }
 #endif							/* KEEP_UNUSED */
@@ -888,7 +888,7 @@ static int sockets_open(int family)
 			sfd = af->fd;
 	}
 	if (sfd < 0) {
-		error_msg(_("No usable address families found."));
+		bb_error_msg(_("No usable address families found."));
 	}
 	return sfd;
 }
@@ -960,7 +960,7 @@ static int if_readconf(void)
 	   (as of 2.1.128) */
 	skfd2 = get_socket_for_af(AF_INET);
 	if (skfd2 < 0) {
-		perror_msg(("warning: no inet socket available"));
+		bb_perror_msg(("warning: no inet socket available"));
 		/* Try to soldier on with whatever socket we can get hold of.  */
 		skfd2 = sockets_open(0);
 		if (skfd2 < 0)
@@ -1106,7 +1106,7 @@ static int if_readlist_proc(char *target)
 
 	fh = fopen(_PATH_PROCNET_DEV, "r");
 	if (!fh) {
-		perror_msg(_("Warning: cannot open %s. Limited output."), _PATH_PROCNET_DEV);
+		bb_perror_msg(_("Warning: cannot open %s. Limited output."), _PATH_PROCNET_DEV);
 		return if_readconf();
 	}
 	fgets(buf, sizeof buf, fh);	/* eat line */
@@ -1366,7 +1366,7 @@ static int do_if_fetch(struct interface *ife)
 		} else {
 			errmsg = strerror(errno);
 		}
-		error_msg(_("%s: error fetching interface information: %s\n"),
+		bb_error_msg(_("%s: error fetching interface information: %s\n"),
 				ife->name, errmsg);
 		return -1;
 	}
@@ -1441,7 +1441,7 @@ static int in_ether(char *bufp, struct sockaddr *sap)
 			val = c - 'A' + 10;
 		else {
 #ifdef DEBUG
-			error_msg(_("in_ether(%s): invalid ether address!\n"), orig);
+			bb_error_msg(_("in_ether(%s): invalid ether address!\n"), orig);
 #endif
 			errno = EINVAL;
 			return (-1);
@@ -1458,7 +1458,7 @@ static int in_ether(char *bufp, struct sockaddr *sap)
 			val >>= 4;
 		else {
 #ifdef DEBUG
-			error_msg(_("in_ether(%s): invalid ether address!"), orig);
+			bb_error_msg(_("in_ether(%s): invalid ether address!"), orig);
 #endif
 			errno = EINVAL;
 			return (-1);
@@ -1472,7 +1472,7 @@ static int in_ether(char *bufp, struct sockaddr *sap)
 		if (*bufp == ':') {
 #ifdef DEBUG
 			if (i == ETH_ALEN) {
-				error_msg(_("in_ether(%s): trailing : ignored!"), orig);
+				bb_error_msg(_("in_ether(%s): trailing : ignored!"), orig);
 			}
 #endif
 			bufp++;
@@ -1482,11 +1482,11 @@ static int in_ether(char *bufp, struct sockaddr *sap)
 #ifdef DEBUG
 	/* That's it.  Any trailing junk? */
 	if ((i == ETH_ALEN) && (*bufp != '\0')) {
-		error_msg(_("in_ether(%s): trailing junk!"), orig);
+		bb_error_msg(_("in_ether(%s): trailing junk!"), orig);
 		errno = EINVAL;
 		return (-1);
 	}
-	error_msg("in_ether(%s): %s", orig, pr_ether(sap->sa_data));
+	bb_error_msg("in_ether(%s): %s", orig, pr_ether(sap->sa_data));
 #endif
 
 	return (0);
@@ -1511,7 +1511,7 @@ static struct hwtype ether_hwtype = {
 /* Start the PPP encapsulation on the file descriptor. */
 static int do_ppp(int fd)
 {
-	error_msg(_("You cannot start PPP with this program."));
+	bb_error_msg(_("You cannot start PPP with this program."));
 	return -1;
 }
 #endif							/* KEEP_UNUSED */
@@ -2052,7 +2052,7 @@ int display_interfaces(char *ifname)
 
 	/* Create a channel to the NET kernel. */
 	if ((skfd = sockets_open(0)) < 0) {
-		perror_msg_and_die("socket");
+		bb_perror_msg_and_die("socket");
 	}
 
 	/* Do we have to show the current setup? */
diff --git a/libbb/kernel_version.c b/libbb/kernel_version.c
index 694af8e2c..14b163654 100644
--- a/libbb/kernel_version.c
+++ b/libbb/kernel_version.c
@@ -37,7 +37,7 @@ extern int get_kernel_revision(void)
 	int i, r;
 
 	if (uname(&name) == -1) {
-		perror_msg("cannot get system information");
+		bb_perror_msg("cannot get system information");
 		return (0);
 	}
 
diff --git a/libbb/loop.c b/libbb/loop.c
index 7e58b2f85..29128abe4 100644
--- a/libbb/loop.c
+++ b/libbb/loop.c
@@ -33,11 +33,11 @@ extern int del_loop(const char *device)
 	int fd;
 
 	if ((fd = open(device, O_RDONLY)) < 0) {
-		perror_msg("%s", device);
+		bb_perror_msg("%s", device);
 		return (FALSE);
 	}
 	if (ioctl(fd, LOOP_CLR_FD, 0) < 0) {
-		perror_msg("ioctl: LOOP_CLR_FD");
+		bb_perror_msg("ioctl: LOOP_CLR_FD");
 		return (FALSE);
 	}
 	close(fd);
@@ -53,12 +53,12 @@ extern int set_loop(const char *device, const char *file, int offset,
 	mode = *loopro ? O_RDONLY : O_RDWR;
 	if ((ffd = open(file, mode)) < 0 && !*loopro
 		&& (errno != EROFS || (ffd = open(file, mode = O_RDONLY)) < 0)) {
-		perror_msg("%s", file);
+		bb_perror_msg("%s", file);
 		return 1;
 	}
 	if ((fd = open(device, mode)) < 0) {
 		close(ffd);
-		perror_msg("%s", device);
+		bb_perror_msg("%s", device);
 		return 1;
 	}
 	*loopro = (mode == O_RDONLY);
@@ -70,14 +70,14 @@ extern int set_loop(const char *device, const char *file, int offset,
 
 	loopinfo.lo_encrypt_key_size = 0;
 	if (ioctl(fd, LOOP_SET_FD, ffd) < 0) {
-		perror_msg("ioctl: LOOP_SET_FD");
+		bb_perror_msg("ioctl: LOOP_SET_FD");
 		close(fd);
 		close(ffd);
 		return 1;
 	}
 	if (ioctl(fd, LOOP_SET_STATUS, &loopinfo) < 0) {
 		(void) ioctl(fd, LOOP_CLR_FD, 0);
-		perror_msg("ioctl: LOOP_SET_STATUS");
+		bb_perror_msg("ioctl: LOOP_SET_STATUS");
 		close(fd);
 		close(ffd);
 		return 1;
diff --git a/libbb/make_directory.c b/libbb/make_directory.c
index 65be397bf..e3d2c52b1 100644
--- a/libbb/make_directory.c
+++ b/libbb/make_directory.c
@@ -1,12 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Mini make_directory implementation for busybox
+ * parse_mode implementation for busybox
  *
- * Copyright (C) 2001  Matt Kraai.
- * 
- * Rewriten in 2002
- * Copyright (C) 2002 Glenn McGrath
- * Copyright (C) 2002 Vladimir N. Oleynik
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -24,57 +20,87 @@
  *
  */
 
+/* Mar 5, 2003    Manuel Novoa III
+ *
+ * This is the main work function for the 'mkdir' applet.  As such, it
+ * strives to be SUSv3 compliant in it's behaviour when recursively
+ * making missing parent dirs, and in it's mode setting of the final
+ * directory 'path'.
+ *
+ * To recursively build all missing intermediate directories, make
+ * sure that (flags & FILEUTILS_RECUR) is non-zero.  Newly created
+ * intermediate directories will have at least u+wx perms.
+ *
+ * To set specific permisions on 'path', pass the appropriate 'mode'
+ * val.  Otherwise, pass -1 to get default permisions.
+ */
+
 #include <errno.h>
-#include <fcntl.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/types.h>
 #include <unistd.h>
-#include <stdlib.h>
-
 #include "libbb.h"
 
-/* Create the directory PATH with mode MODE, or the default if MODE is -1.
- * Also create parent directories as necessary if flags contains
- * FILEUTILS_RECUR.  */
-
-int make_directory (char *path, long mode, int flags)
+int bb_make_directory (char *path, long mode, int flags)
 {
-	int ret;
-
-	if (flags == FILEUTILS_RECUR) {
-		char *pp = strrchr(path, '/');
-		if ((pp) && (pp != path)) {
-			*pp = '\0';
-			make_directory(path, -1, flags);
-			*pp = '/';
-		}
-	}
+	mode_t mask;
+	const char *fail_msg;
+	char *s = path;
+	char c;
 
-	if (mode == -1) {
-		struct stat statbuf;
-		char *pp = strrchr(path, '/');
+	mask = umask(0);
+	umask(mask & ~0300);
 
-		statbuf.st_mode = 0777;
+	do {
+		c = 0;
 
-		/* stat the directory */
-		if ((pp) && (pp != path)) {
-			*pp = '\0';
-			stat(path, &statbuf);
-			*pp = '/';
+		if (flags & FILEUTILS_RECUR) {	/* Get the parent. */
+			/* Bypass leading non-'/'s and then subsequent '/'s. */
+			while (*s) {
+				if (*s == '/') {
+					do {
+						++s;
+					} while (*s == '/');
+					c = *s;		/* Save the current char */
+					*s = 0;		/* and replace it with nul. */
+					break;
+				}
+				++s;
+			}
 		}
 
-		mode = statbuf.st_mode;
-	}
+		if (mkdir(path, 0777) < 0) {
+			/* If we failed for any other reason than the directory
+			 * already exists, output a diagnostic and return -1.*/
+			if (errno != EEXIST) {
+				fail_msg = "create";
+				umask(mask);
+				break;
+			}
+			/* Since the directory exists, don't attempt to change
+			 * permissions if it was the full target.  Note that
+			 * this is not an error conditon. */
+			if (!c) {
+				umask(mask);
+				return 0;
+			}
+		}
 
-	ret = mkdir(path, mode);
-	if (ret == -1) {
-		if ((flags == FILEUTILS_RECUR) && (errno == EEXIST)) {
-			ret = 0;
-		} else {
-			perror_msg_and_die("Cannot create directory '%s'", path);
+		if (!c) {
+			/* Done.  If necessary, updated perms on the newly
+			 * created directory.  Failure to update here _is_
+			 * an error.*/
+			umask(mask);
+			if ((mode != -1) && (chmod(path, mode) < 0)){
+				fail_msg = "set permissions of";
+				break;
+			}
+			return 0;
 		}
-	}
 
-	return(ret);
+		/* Remove any inserted nul from the path (recursive mode). */
+		*s = c;
+
+	} while (1);
+
+	bb_perror_msg ("Cannot %s directory `%s'", fail_msg, path);
+	return -1;
 }
diff --git a/libbb/messages.c b/libbb/messages.c
index cc7e2146c..e5ffbf7f7 100644
--- a/libbb/messages.c
+++ b/libbb/messages.c
@@ -23,82 +23,71 @@
 #include "libbb.h"
 
 #ifdef L_full_version
-	const char * const full_version = BB_BANNER " multi-call binary";
-#endif
-#ifdef L_name_too_long
-	const char * const name_too_long = "file name too long";
-#endif
-
-#ifdef L_omitting_directory
-	const char * const omitting_directory = "%s: omitting directory";
-#endif
-#ifdef L_not_a_directory
-	const char * const not_a_directory = "%s: not a directory";
+	const char * const bb_msg_full_version = BB_BANNER " multi-call binary";
 #endif
 #ifdef L_memory_exhausted
-	const char * const memory_exhausted = "memory exhausted";
+	const char * const bb_msg_memory_exhausted = "memory exhausted";
 #endif
 #ifdef L_invalid_date
-	const char * const invalid_date = "invalid date `%s'";
-#endif
-#ifdef L_invalid_option
-	const char * const invalid_option = "invalid option -- %c";
+	const char * const bb_msg_invalid_date = "invalid date `%s'";
 #endif
 #ifdef L_io_error
-	const char * const io_error = "%s: input/output error -- %m";
-#endif
-#ifdef L_dash_dash_help
-	const char * const dash_dash_help = "--help";
+	const char * const bb_msg_io_error = "%s: input/output error -- %m";
 #endif
 #ifdef L_write_error
-	const char * const write_error = "Write Error";
-#endif
-#ifdef L_too_few_args
-	const char * const too_few_args = "too few arguments";
+	const char * const bb_msg_write_error = "Write Error";
 #endif
 #ifdef L_name_longer_than_foo
-	const char * const name_longer_than_foo = "Names longer than %d chars not supported.";
+	const char * const bb_msg_name_longer_than_foo = "Names longer than %d chars not supported.";
 #endif
 #ifdef L_unknown
-	const char * const unknown = "(unknown)";
+	const char * const bb_msg_unknown = "(unknown)";
 #endif
-
 #ifdef L_can_not_create_raw_socket
-	const char * const can_not_create_raw_socket = "can`t create raw socket";
+	const char * const bb_msg_can_not_create_raw_socket = "can`t create raw socket";
+#endif
+#ifdef L_perm_denied_are_you_root
+	const char * const bb_msg_perm_denied_are_you_root = "permission denied. (are you root?)";
+#endif
+#ifdef L_msg_standard_input
+	const char * const bb_msg_standard_input = "standard input";
+#endif
+#ifdef L_msg_standard_output
+	const char * const bb_msg_standard_output = "standard output";
 #endif
 
 #ifdef L_passwd_file
 #define PASSWD_FILE        "/etc/passwd"
-const char * const passwd_file = PASSWD_FILE;
+const char * const bb_path_passwd_file = PASSWD_FILE;
 #endif
 
 #ifdef L_shadow_file
 #define SHADOW_FILE        "/etc/shadow"
-const char * const shadow_file = SHADOW_FILE;
+const char * const bb_path_shadow_file = SHADOW_FILE;
 #endif
 
 #ifdef L_group_file
 #define GROUP_FILE         "/etc/group"
-const char * const group_file = GROUP_FILE;
+const char * const bb_path_group_file = GROUP_FILE;
 #endif
 
 #ifdef L_gshadow_file
 #define GSHADOW_FILE       "/etc/gshadow"
-const char * const gshadow_file = GSHADOW_FILE;
+const char * const bb_path_gshadow_file = GSHADOW_FILE;
 #endif
 
 #ifdef L_nologin_file
 #define NOLOGIN_FILE       "/etc/nologin"
-const char * const nologin_file = NOLOGIN_FILE;
+const char * const bb_path_nologin_file = NOLOGIN_FILE;
 #endif
 
 #ifdef L_securetty_file
 #define SECURETTY_FILE     "/etc/securetty"
-const char * const securetty_file = SECURETTY_FILE;
+const char * const bb_path_securetty_file = SECURETTY_FILE;
 #endif
 
 #ifdef L_motd_file
 #define MOTD_FILE          "/etc/motd"
-const char * const motd_file = MOTD_FILE;
+const char * const bb_path_motd_file = MOTD_FILE;
 #endif
 
diff --git a/libbb/mode_string.c b/libbb/mode_string.c
index 12dc17966..8d4d736ef 100644
--- a/libbb/mode_string.c
+++ b/libbb/mode_string.c
@@ -1,78 +1,134 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Utility routines.
+ * mode_string implementation for busybox
  *
- * Copyright (C) many different people.  If you wrote this, please
- * acknowledge your work.
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
  */
 
-#include <stdio.h>
-#include "libbb.h"
+#include <assert.h>
+#include <sys/stat.h>
 
+#if ( S_ISUID != 04000 ) || ( S_ISGID != 02000 ) || ( S_ISVTX != 01000 ) \
+ || ( S_IRUSR != 00400 ) || ( S_IWUSR != 00200 ) || ( S_IXUSR != 00100 ) \
+ || ( S_IRGRP != 00040 ) || ( S_IWGRP != 00020 ) || ( S_IXGRP != 00010 ) \
+ || ( S_IROTH != 00004 ) || ( S_IWOTH != 00002 ) || ( S_IXOTH != 00001 )
+#error permission bitflag value assumption(s) violated!
+#endif
 
+#if ( S_IFSOCK!= 0140000 ) || ( S_IFLNK != 0120000 ) \
+ || ( S_IFREG != 0100000 ) || ( S_IFBLK != 0060000 ) \
+ || ( S_IFDIR != 0040000 ) || ( S_IFCHR != 0020000 ) \
+ || ( S_IFIFO != 0010000 )
+#warning mode type bitflag value assumption(s) violated! falling back to larger version
 
-#define TYPEINDEX(mode) (((mode) >> 12) & 0x0f)
-#define TYPECHAR(mode)  ("0pcCd?bB-?l?s???" [TYPEINDEX(mode)])
+#if (S_IRWXU | S_IRWXG | S_IRWXO | S_ISUID | S_ISGID | S_ISVTX) == 07777
+#undef mode_t
+#define mode_t unsigned short
+#endif
 
-/* The special bits. If set, display SMODE0/1 instead of MODE0/1 */
-static const mode_t SBIT[] = {
-	0, 0, S_ISUID,
-	0, 0, S_ISGID,
-	0, 0, S_ISVTX
+static const mode_t mode_flags[] = {
+	S_IRUSR, S_IWUSR, S_IXUSR, S_ISUID,
+	S_IRGRP, S_IWGRP, S_IXGRP, S_ISGID,
+	S_IROTH, S_IWOTH, S_IXOTH, S_ISVTX
 };
 
-/* The 9 mode bits to test */
-static const mode_t MBIT[] = {
-	S_IRUSR, S_IWUSR, S_IXUSR,
-	S_IRGRP, S_IWGRP, S_IXGRP,
-	S_IROTH, S_IWOTH, S_IXOTH
-};
+/* The static const char arrays below are duplicated for the two cases
+ * because moving them ahead of the mode_flags declaration cause a text
+ * size increase with the gcc version I'm using. */
 
-static const char MODE1[]  = "rwxrwxrwx";
-static const char MODE0[]  = "---------";
-static const char SMODE1[] = "..s..s..t";
-static const char SMODE0[] = "..S..S..T";
+/* The previous version used "0pcCd?bB-?l?s???".  However, the '0', 'C',
+ * and 'B' types don't appear to be available on linux.  So I removed them. */
+static const char type_chars[16] = "?pc?d?b?-?l?s???";
+/*                                  0123456789abcdef */
+static const char mode_chars[7] = "rwxSTst";
 
-/*
- * Return the standard ls-like mode string from a file mode.
- * This is static and so is overwritten on each call.
- */
-const char *mode_string(int mode)
+const char *bb_mode_string(int mode)
 {
 	static char buf[12];
+	char *p = buf;
+
+	int i, j, k;
 
-	int i;
+	*p = type_chars[ (mode >> 12) & 0xf ];
+	i = 0;
+	do {
+		j = k = 0;
+		do {
+			*++p = '-';
+			if (mode & mode_flags[i+j]) {
+				*p = mode_chars[j];
+				k = j;
+			}
+		} while (++j < 3);
+		if (mode & mode_flags[i+j]) {
+			*p = mode_chars[3 + (k & 2) + ((i&8) >> 3)];
+		}
+		i += 4;
+	} while (i < 12);
+
+	/* Note: We don't bother with nul termination because bss initialization
+	 * should have taken care of that for us.  If the user scribbled in buf
+	 * memory, they deserve whatever happens.  But we'll at least assert. */
+	assert(buf[10] == 0);
 
-	buf[0] = TYPECHAR(mode);
-	for (i = 0; i < 9; i++) {
-		if (mode & SBIT[i])
-			buf[i + 1] = (mode & MBIT[i]) ? SMODE1[i] : SMODE0[i];
-		else
-			buf[i + 1] = (mode & MBIT[i]) ? MODE1[i] : MODE0[i];
-	}
 	return buf;
 }
 
-/* END CODE */
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
+#else
+
+/* The previous version used "0pcCd?bB-?l?s???".  However, the '0', 'C',
+ * and 'B' types don't appear to be available on linux.  So I removed them. */
+static const char type_chars[16] = "?pc?d?b?-?l?s???";
+/*                                  0123456789abcdef */
+static const char mode_chars[7] = "rwxSTst";
+
+const char *bb_mode_string(int mode)
+{
+	static char buf[12];
+	char *p = buf;
+
+	int i, j, k, m;
+
+	*p = type_chars[ (mode >> 12) & 0xf ];
+	i = 0;
+	m = 0400;
+	do {
+		j = k = 0;
+		do {
+			*++p = '-';
+			if (mode & m) {
+				*p = mode_chars[j];
+				k = j;
+			}
+			m >>= 1;
+		} while (++j < 3);
+		++i;
+		if (mode & (010000 >> i)) {
+			*p = mode_chars[3 + k + (i >> 1)];
+		}
+	} while (i < 3);
+
+	/* Note: We don't bother with nul termination because bss initialization
+	 * should have taken care of that for us.  If the user scribbled in buf
+	 * memory, they deserve whatever happens.  But we'll at least assert. */
+	assert(buf[10] == 0);
+
+	return buf;
+}
+
+#endif
diff --git a/libbb/module_syscalls.c b/libbb/module_syscalls.c
index 6bfff207f..8fe9e525c 100644
--- a/libbb/module_syscalls.c
+++ b/libbb/module_syscalls.c
@@ -51,7 +51,7 @@ _syscall5(int, init_module, void *, first, void *, second, void *, third,
 #warning -> The query_module system call is being stubbed out...
 int query_module(const char *name, int which, void *buf, size_t bufsize, size_t *ret)
 {
-	error_msg("\n\nTo make this application work, you will need to recompile\n"
+	bb_error_msg("\n\nTo make this application work, you will need to recompile\n"
 		"with a kernel supporting the query_module system call. -Erik\n");
 	errno=ENOSYS;
 	return -1;
diff --git a/libbb/mtab.c b/libbb/mtab.c
index c521b1e05..54905c724 100644
--- a/libbb/mtab.c
+++ b/libbb/mtab.c
@@ -27,21 +27,20 @@
 #include <mntent.h>
 #include "libbb.h"
 
-extern const char mtab_file[];	/* Defined in utility.c */
 static const int MS_RDONLY = 1;	/* Mount read-only.  */
 
 void erase_mtab(const char *name)
 {
 	struct mntent entries[20];
 	int count = 0;
-	FILE *mountTable = setmntent(mtab_file, "r");
+	FILE *mountTable = setmntent(bb_path_mtab_file, "r");
 	struct mntent *m;
 
 	/* Check if reading the mtab file failed */
 	if (mountTable == 0
 			/* Bummer.  fall back on trying the /proc filesystem */
 			&& (mountTable = setmntent("/proc/mounts", "r")) == 0) {
-		perror_msg("%s", mtab_file);
+		bb_perror_msg(bb_path_mtab_file);
 		return;
 	}
 
@@ -55,7 +54,7 @@ void erase_mtab(const char *name)
 		count++;
 	}
 	endmntent(mountTable);
-	if ((mountTable = setmntent(mtab_file, "w"))) {
+	if ((mountTable = setmntent(bb_path_mtab_file, "w"))) {
 		int i;
 
 		for (i = 0; i < count; i++) {
@@ -69,17 +68,17 @@ void erase_mtab(const char *name)
 		}
 		endmntent(mountTable);
 	} else if (errno != EROFS)
-		perror_msg("%s", mtab_file);
+		bb_perror_msg(bb_path_mtab_file);
 }
 
 void write_mtab(char *blockDevice, char *directory,
 				char *filesystemType, long flags, char *string_flags)
 {
-	FILE *mountTable = setmntent(mtab_file, "a+");
+	FILE *mountTable = setmntent(bb_path_mtab_file, "a+");
 	struct mntent m;
 
 	if (mountTable == 0) {
-		perror_msg("%s", mtab_file);
+		bb_perror_msg(bb_path_mtab_file);
 		return;
 	}
 	if (mountTable) {
diff --git a/libbb/mtab_file.c b/libbb/mtab_file.c
index 2124e0144..898e2fa89 100644
--- a/libbb/mtab_file.c
+++ b/libbb/mtab_file.c
@@ -26,9 +26,9 @@
 /* Busybox mount uses either /proc/mounts or /etc/mtab to 
  * get the list of currently mounted filesystems */ 
 #if defined CONFIG_FEATURE_MTAB_SUPPORT
-const char mtab_file[] = CONFIG_FEATURE_MTAB_FILENAME;
+const char bb_path_mtab_file[] = CONFIG_FEATURE_MTAB_FILENAME;
 #else
-const char mtab_file[] = "/proc/mounts";
+const char bb_path_mtab_file[] = "/proc/mounts";
 #endif
 
 
diff --git a/libbb/my_getgrnam.c b/libbb/my_getgrnam.c
index f80d3f824..eb5b58174 100644
--- a/libbb/my_getgrnam.c
+++ b/libbb/my_getgrnam.c
@@ -33,7 +33,7 @@ long my_getgrnam(const char *name)
 
 	mygroup  = getgrnam(name);
 	if (mygroup==NULL)
-		error_msg_and_die("unknown group name: %s", name);
+		bb_error_msg_and_die("unknown group name: %s", name);
 
 	return (mygroup->gr_gid);
 }
diff --git a/libbb/my_getpwnam.c b/libbb/my_getpwnam.c
index 04951a4d0..ada2ffb56 100644
--- a/libbb/my_getpwnam.c
+++ b/libbb/my_getpwnam.c
@@ -33,7 +33,7 @@ long my_getpwnam(const char *name)
 
 	myuser  = getpwnam(name);
 	if (myuser==NULL)
-		error_msg_and_die("unknown user name: %s", name);
+		bb_error_msg_and_die("unknown user name: %s", name);
 
 	return myuser->pw_uid;
 }
diff --git a/libbb/my_getpwnamegid.c b/libbb/my_getpwnamegid.c
index 07e02c1cf..06071c9f2 100644
--- a/libbb/my_getpwnamegid.c
+++ b/libbb/my_getpwnamegid.c
@@ -35,11 +35,11 @@ long my_getpwnamegid(const char *name)
 
 	myuser=getpwnam(name);
 	if (myuser==NULL)
-		error_msg_and_die("unknown user name: %s", name);
+		bb_error_msg_and_die("unknown user name: %s", name);
 
 	mygroup  = getgrgid(myuser->pw_gid);
 	if (mygroup==NULL)
-		error_msg_and_die("unknown gid %ld", (long)myuser->pw_gid);
+		bb_error_msg_and_die("unknown gid %ld", (long)myuser->pw_gid);
 
 	return mygroup->gr_gid;
 }
diff --git a/libbb/obscure.c b/libbb/obscure.c
index 588ef5af6..1a99b7cf9 100644
--- a/libbb/obscure.c
+++ b/libbb/obscure.c
@@ -143,7 +143,7 @@ password_check(const char *old, const char *newval, const struct passwd *pwdp)
 		return "too simple";
 
 	msg = NULL;
-	newmono = str_lower(xstrdup(newval));
+	newmono = str_lower(bb_xstrdup(newval));
 	lenwrap = strlen(old) * 2 + 1;
 	wrapped = (char *) xmalloc(lenwrap);
 	str_lower(strcpy(wrapped, old));
@@ -208,8 +208,8 @@ obscure_msg(const char *old, const char *newval, const struct passwd *pwdp)
 	if (oldlen <= maxlen && newlen <= maxlen)
 		return NULL;
 
-	new1 = (char *) xstrdup(newval);
-	old1 = (char *) xstrdup(old);
+	new1 = (char *) bb_xstrdup(newval);
+	old1 = (char *) bb_xstrdup(old);
 	if (newlen > maxlen)
 		new1[maxlen] = '\0';
 	if (oldlen > maxlen)
diff --git a/libbb/parse_mode.c b/libbb/parse_mode.c
index ba34ea929..49573dfbb 100644
--- a/libbb/parse_mode.c
+++ b/libbb/parse_mode.c
@@ -1,134 +1,177 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Utility routines.
+ * parse_mode implementation for busybox
  *
- * Copyright (C) many different people.  If you wrote this, please
- * acknowledge your work.
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
  */
 
-#include <stdio.h>
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/chmod.html */
+
 #include <stdlib.h>
+#include <assert.h>
+#include <sys/stat.h>
 #include "libbb.h"
 
+#define FILEMODEBITS    (S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
 
-/* This function parses the sort of string you might pass
- * to chmod (i.e., [ugoa]{+|-|=}[rwxst] ) and returns the
- * correct mode described by the string. */
-extern int parse_mode(const char *s, mode_t * theMode)
+extern int bb_parse_mode(const char *s, mode_t *current_mode)
 {
-	static const mode_t group_set[] = { 
+	static const mode_t who_mask[] = { 
+		S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO, /* a */
 		S_ISUID | S_IRWXU,		/* u */
 		S_ISGID | S_IRWXG,		/* g */
-		S_IRWXO,				/* o */
-		S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO /* a */
+		S_IRWXO					/* o */
 	};
 
-	static const mode_t mode_set[] = {
+	static const mode_t perm_mask[] = {
 		S_IRUSR | S_IRGRP | S_IROTH, /* r */
 		S_IWUSR | S_IWGRP | S_IWOTH, /* w */
 		S_IXUSR | S_IXGRP | S_IXOTH, /* x */
+		S_IXUSR | S_IXGRP | S_IXOTH, /* X -- special -- see below */
 		S_ISUID | S_ISGID,		/* s */
 		S_ISVTX					/* t */
 	};
 
-	static const char group_chars[] = "ugoa";
-	static const char mode_chars[] = "rwxst";
+	static const char who_chars[] = "augo";
+	static const char perm_chars[] = "rwxXst";
 
 	const char *p;
 
-	mode_t andMode =
-		S_ISVTX | S_ISUID | S_ISGID | S_IRWXU | S_IRWXG | S_IRWXO;
-	mode_t orMode = 0;
-	mode_t mode;
-	mode_t groups;
-	char type;
-	char c;
+	mode_t wholist;
+	mode_t permlist;
+	mode_t mask;
+	mode_t new_mode;
+	char op;
+
+	assert(s);
+
+	if (((unsigned int)(*s - '0')) < 8) {
+		unsigned long tmp;
+		char *e;
 
-	if (s==NULL) {
-		return (FALSE);
+		tmp = strtol(s, &e, 8);
+		if (*e || (tmp > 0xffffU)) { /* Check range and trailing chars. */
+			return 0;
+		}
+		*current_mode = tmp;
+		return 1;
 	}
 
-	do {
-		mode = 0;
-		groups = 0;
-	NEXT_GROUP:
-		if ((c = *s++) == '\0') {
-			return -1;
+	mask = umask(0);
+	umask(mask);
+
+	new_mode = *current_mode;
+
+	/* Note: We allow empty clauses, and hence empty modes.
+	 * We treat an empty mode as no change to perms. */
+
+	while (*s) {	/* Process clauses. */
+
+		if (*s == ',') {	/* We allow empty clauses. */
+			++s;
+			continue;
 		}
-		for (p=group_chars ; *p ; p++) {
-			if (*p == c) {
-				groups |= group_set[(int)(p-group_chars)];
-				goto NEXT_GROUP;
+
+		/* Get a wholist. */
+		wholist = 0;
+
+	WHO_LIST:
+		p = who_chars;
+		do {
+			if (*p == *s) {
+				wholist |= who_mask[(int)(p-who_chars)];
+				if (!*++s) {
+					return 0;
+				}
+				goto WHO_LIST;
 			}
-		}
-		switch (c) {
-			case '=':
-			case '+':
-			case '-':
-				type = c;
-				if (groups == 0) { /* The default is "all" */
-					groups |= S_ISUID | S_ISGID | S_ISVTX
-							| S_IRWXU | S_IRWXG | S_IRWXO;
+		} while (*++p);
+
+		do {	/* Process action list. */
+			if ((*s != '+') && (*s != '-')) {
+				if (*s != '=') {
+					return 0;
 				}
-				break;
-			default:
-				if ((c < '0') || (c > '7') || (mode | groups)) {
-					return (FALSE);
-				} else {
-					*theMode = strtol(--s, NULL, 8);
-					return (TRUE);
+				/* Since op is '=', clear all bits corresponding to the
+				 * wholist, of all file bits if wholist is empty. */
+				permlist = ~FILEMODEBITS;
+				if (wholist) {
+					permlist = ~wholist;
 				}
-		}
+				new_mode &= permlist;
+			}
+			op = *s++;
+
+			/* Check for permcopy. */
+			p = who_chars + 1;	/* Skip 'a' entry. */
+			do {
+				if (*p == *s) {
+					int i = 0;
+					permlist = who_mask[(int)(p-who_chars)]
+							 & (S_IRWXU | S_IRWXG | S_IRWXO)
+							 & new_mode;
+					do {
+						if (permlist & perm_mask[i]) {
+							permlist |= perm_mask[i];
+						}
+					} while (++i < 3);
+					++s;
+					goto GOT_ACTION;
+				}
+			} while (*++p);
 
-	NEXT_MODE:
-		if (((c = *s++) != '\0') && (c != ',')) {
-			for (p=mode_chars ; *p ; p++) {
-				if (*p == c) {
-					mode |= mode_set[(int)(p-mode_chars)];
-					goto NEXT_MODE;
+			/* It was not a permcopy, so get a permlist. */
+			permlist = 0;
+
+		PERM_LIST:
+			p = perm_chars;
+			do {
+				if (*p == *s) {
+					if ((*p != 'X')
+						|| (new_mode & (S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH))
+					) {
+						permlist |= perm_mask[(int)(p-perm_chars)];
+					}
+					if (!*++s) {
+						break;
+					}
+					goto PERM_LIST;
+				}
+			} while (*++p);
+
+		GOT_ACTION:
+			if (permlist) {	/* The permlist was nonempty. */
+				mode_t tmp = ~mask;
+				if (wholist) {
+					tmp = wholist;
+				}
+				permlist &= tmp;
+
+				if (op == '-') {
+					new_mode &= ~permlist;
+				} else {
+					new_mode |= permlist;
 				}
 			}
-			break;				/* We're done so break out of loop.*/
-		}
-		switch (type) {
-			case '=':
-				andMode &= ~(groups); /* Now fall through. */
-			case '+':
-				orMode |= mode & groups;
-				break;
-			case '-':
-				andMode &= ~(mode & groups);
-				orMode &= ~(mode & groups);
-				break;
-		}
-	} while (c == ',');
+		} while (*s && (*s != ','));
+	}
 
-	*theMode &= andMode;
-	*theMode |= orMode;
+	*current_mode = new_mode;
 
-	return TRUE;
+	return 1;
 }
-
-/* END CODE */
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
diff --git a/libbb/parse_number.c b/libbb/parse_number.c
index 755a357ad..92ad6a216 100644
--- a/libbb/parse_number.c
+++ b/libbb/parse_number.c
@@ -1,70 +1,64 @@
 /* vi: set sw=4 ts=4: */
 /*
- * Utility routines.
+ * bb_xparse_number implementation for busybox
  *
- * Copyright (C) many different people.  If you wrote this, please
- * acknowledge your work.
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
  */
 
-#include <stdio.h>
-#include <string.h>
 #include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <errno.h>
+#include <assert.h>
 #include "libbb.h"
 
-
-unsigned long parse_number(const char *numstr,
-		const struct suffix_mult *suffixes)
+extern
+unsigned long bb_xparse_number(const char *numstr,
+							   const struct suffix_mult *suffixes)
 {
-	const struct suffix_mult *sm;
-	unsigned long int ret;
-	int len;
-	char *end;
+	unsigned long int r;
+	char *e;
+	int old_errno;
 	
-	ret = strtoul(numstr, &end, 10);
-	if (numstr == end)
-		error_msg_and_die("invalid number `%s'", numstr);
-	while (end[0] != '\0') {
-		sm = suffixes;
-		while ( sm != 0 ) {
-			if(sm->suffix) {
-				len = strlen(sm->suffix);
-				if (strncmp(sm->suffix, end, len) == 0) {
-					ret *= sm->mult;
-					end += len;
-					break;
+	/* Since this is a lib function, we're not allowed to reset errno to 0.
+	 * Doing so could break an app that is deferring checking of errno.
+	 * So, save the old value so that we can restore it if successful. */
+	old_errno = errno;
+	errno = 0;
+	r = strtoul(numstr, &e, 10);
+
+	if ((numstr != e) && !errno) {
+		errno = old_errno;	/* Ok.  So restore errno. */
+		if (!*e) {
+			return r;
+		}
+		if (suffixes) {
+			assert(suffixes->suffix);	/* No nul suffixes. */
+			do {
+				if (strcmp(suffixes->suffix, e) == 0) {
+					if (ULONG_MAX / suffixes->mult < r) {	/* Overflow! */
+						break;
+					}
+					return r * suffixes->mult;
 				}
-			sm++;
-			
-			} else
-				sm = 0;
+				++suffixes;
+			} while (suffixes->suffix);
 		}
-		if (sm == 0)
-			error_msg_and_die("invalid number `%s'", numstr);
 	}
-	return ret;
+	bb_error_msg_and_die("invalid number `%s'", numstr);
 }
-
-
-/* END CODE */
-/*
-Local Variables:
-c-file-style: "linux"
-c-basic-offset: 4
-tab-width: 4
-End:
-*/
diff --git a/libbb/perror_msg.c b/libbb/perror_msg.c
index 8c57b0d16..f32c1c8fe 100644
--- a/libbb/perror_msg.c
+++ b/libbb/perror_msg.c
@@ -25,12 +25,12 @@
 #include <stdlib.h>
 #include "libbb.h"
 
-extern void perror_msg(const char *s, ...)
+extern void bb_perror_msg(const char *s, ...)
 {
 	va_list p;
 
 	va_start(p, s);
-	vperror_msg(s, p);
+	bb_vperror_msg(s, p);
 	va_end(p);
 }
 
diff --git a/libbb/perror_msg_and_die.c b/libbb/perror_msg_and_die.c
index 9004925cc..57a21136d 100644
--- a/libbb/perror_msg_and_die.c
+++ b/libbb/perror_msg_and_die.c
@@ -25,14 +25,14 @@
 #include <stdlib.h>
 #include "libbb.h"
 
-extern void perror_msg_and_die(const char *s, ...)
+extern void bb_perror_msg_and_die(const char *s, ...)
 {
 	va_list p;
 
 	va_start(p, s);
-	vperror_msg(s, p);
+	bb_vperror_msg(s, p);
 	va_end(p);
-	exit(EXIT_FAILURE);
+	exit(bb_default_error_retval);
 }
 
 
diff --git a/libbb/perror_nomsg.c b/libbb/perror_nomsg.c
new file mode 100644
index 000000000..464cb86c4
--- /dev/null
+++ b/libbb/perror_nomsg.c
@@ -0,0 +1,30 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * bb_perror_nomsg implementation for busybox
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <stddef.h>
+#include <libbb.h>
+
+extern void bb_perror_nomsg(void)
+{
+	/* Ignore the gcc warning about a null format string. */
+	bb_perror_msg(NULL);
+}
diff --git a/libbb/perror_nomsg_and_die.c b/libbb/perror_nomsg_and_die.c
new file mode 100644
index 000000000..bab228455
--- /dev/null
+++ b/libbb/perror_nomsg_and_die.c
@@ -0,0 +1,30 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * bb_perror_nomsg_and_die implementation for busybox
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <stddef.h>
+#include "libbb.h"
+
+extern void bb_perror_nomsg_and_die(void)
+{
+	/* Ignore the gcc warning about a null format string. */
+	bb_perror_msg_and_die(NULL);
+}
diff --git a/libbb/print_file.c b/libbb/print_file.c
index cdd60e7a0..8417c10d3 100644
--- a/libbb/print_file.c
+++ b/libbb/print_file.c
@@ -21,39 +21,50 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <sys/stat.h>
 #include "libbb.h"
 
-
-extern void print_file(FILE *file)
+extern void bb_xprint_and_close_file(FILE *file)
 {
-	fflush(stdout);
-	if (copyfd(fileno(file), fileno(stdout), 0) == -1) {
-		exit(EXIT_FAILURE);
+	bb_xfflush_stdout();
+	/* Note: Do not use STDOUT_FILENO here, as this is a lib routine
+	 *       and the calling code may have reassigned stdout. */
+	if (bb_copyfd(fileno(file), fileno(stdout), 0) == -1) {
+		/* bb_copyfd outputs any needed messages, so just die. */
+		exit(bb_default_error_retval);
 	}
+	/* Note: Since we're reading, don't bother checking the return value
+	 *       of fclose().  The only possible failure is EINTR which
+	 *       should already have been taken care of. */
 	fclose(file);
 }
 
-extern int print_file_by_name(char *filename)
+/* Returns:
+ *    0      if successful
+ *   -1      if 'filename' does not exist or is a directory
+ *  exits with default error code if an error occurs
+ */
+
+extern int bb_xprint_file_by_name(const char *filename)
 {
+	FILE *f;
+
+#if 0
+	/* This check shouldn't be necessary for linux, but is left
+	* here disabled just in case. */
 	struct stat statBuf;
-	int status = TRUE;
 
-	if(is_directory(filename, TRUE, &statBuf)==TRUE) {
-		error_msg("%s: Is directory", filename);
-		status = FALSE;
-	} else {
-		FILE *f = wfopen(filename, "r");
-		if(f!=NULL)
-			print_file(f);
-		else
-			status = FALSE;
+	if(is_directory(filename, TRUE, &statBuf)) {
+		bb_error_msg("%s: Is directory", filename);
+	} else
+#endif
+	if ((f = bb_wfopen(filename, "r")) != NULL) {
+		bb_xprint_and_close_file(f);
+		return 0;
 	}
 
-	return status;
+	return -1;
 }
 
-
 /* END CODE */
 /*
 Local Variables:
diff --git a/libbb/printf.c b/libbb/printf.c
new file mode 100644
index 000000000..686257699
--- /dev/null
+++ b/libbb/printf.c
@@ -0,0 +1,177 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * *printf implementations for busybox
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+/* Mar 12, 2003     Manuel Novoa III
+ *
+ * While fwrite(), fputc(), fputs(), etc. all set the stream error flag
+ * on failure, the *printf functions are unique in that they can fail
+ * for reasons not related to the actual output itself.  Among the possible
+ * reasons for failure which don't set the streams error indicator,
+ * SUSv3 lists EILSEQ, EINVAL, and ENOMEM.
+ *
+ * In some cases, it would be desireable to have a group of *printf()
+ * functions available that _always_ set the stream error indicator on
+ * failure.  That would allow us to defer error checking until applet
+ * exit.  Unfortunately, there is no standard way of setting a streams
+ * error indicator... even though we can clear it with clearerr().
+ *
+ * Therefore, we have to resort to implementation dependent code.  Feel
+ * free to send patches for stdio implementations where the following
+ * fails.
+ *
+ * NOTE: None of this is threadsafe.  As busybox is a nonthreaded app,
+ *       that isn't currently an issue.
+ */
+
+#include <stdio.h>
+#include <stdarg.h>
+#include "libbb.h"
+
+#if defined(__UCLIBC__) 
+
+# if defined(__FLAG_ERROR)
+/* Using my newer stdio implementation.  Unlocked macros are:
+ * #define __CLEARERR(stream) \
+	  ((stream)->modeflags &= ~(__FLAG_EOF|__FLAG_ERROR), (void)0)
+ * #define __FEOF(stream)		((stream)->modeflags & __FLAG_EOF)
+ * #define __FERROR(stream)	((stream)->modeflags & __FLAG_ERROR)
+ */
+#define SET_FERROR_UNLOCKED(S)    ((S)->modeflags |= __FLAG_ERROR)
+
+#elif defined(__MODE_ERR)
+/* Using either the original stdio implementation (from dev86) or
+ * my original stdio rewrite.  Macros were:
+ * #define ferror(fp)	(((fp)->mode&__MODE_ERR) != 0)
+ * #define feof(fp)   	(((fp)->mode&__MODE_EOF) != 0)
+ * #define clearerr(fp)	((fp)->mode &= ~(__MODE_EOF|__MODE_ERR),0)
+ */
+#define SET_FERROR_UNLOCKED(S)    ((S)->mode |= __MODE_ERR)
+
+#else
+#error unknown uClibc stdio implemenation!
+#endif
+
+#elif defined(__GLIBC__)
+
+# if defined(_STDIO_USES_IOSTREAM)
+/* Apparently using the newer libio implementation, with associated defines:
+ * #define _IO_feof_unlocked(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)
+ * #define _IO_ferror_unlocked(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)
+ */
+#define SET_FERROR_UNLOCKED(S)    ((S)->_flags |= _IO_ERR_SEEN)
+
+# else
+/* Assume the older version of glibc which used a bitfield entry
+ * as a stream error flag.  The associated defines were:
+ * #define __clearerr(stream)      ((stream)->__error = (stream)->__eof = 0)
+ * #define feof_unlocked(stream)         ((stream)->__eof != 0)
+ * #define ferror_unlocked(stream)       ((stream)->__error != 0)
+ */
+#define SET_FERROR_UNLOCKED(S)    ((S)->__error = 1)
+
+# endif
+
+#elif defined(__NEWLIB_H__)
+/* I honestly don't know if there are different versions of stdio in
+ * newlibs history.  Anyway, here's what's current.
+ * #define __sfeof(p)      (((p)->_flags & __SEOF) != 0)
+ * #define __sferror(p)    (((p)->_flags & __SERR) != 0)
+ * #define __sclearerr(p)  ((void)((p)->_flags &= ~(__SERR|__SEOF)))
+ */
+#define SET_FERROR_UNLOCKED(S)    ((S)->_flags |= __SERR)
+
+#elif defined(__dietlibc__)
+/*
+ *     WARNING!!!  dietlibc is quite buggy.  WARNING!!!
+ *
+ * Some example bugs as of March 12, 2003...
+ *   1) fputc() doesn't set the error indicator on failure.
+ *   2) freopen() doesn't maintain the same stream object, contary to
+ *      standards.  This makes it useless in its primary role of
+ *      reassociating stdin/stdout/stderr.
+ *   3) printf() often fails to correctly format output when conversions
+ *      involve padding.  It is also practically useless for floating
+ *      point output.
+ *
+ * But, if you're determined to use it anyway, (as of the current version)
+ * you can extract the information you need from dietstdio.h.  See the
+ * other library implementations for examples.
+ */
+#error dietlibc is currently not supported.  Please see the commented source.
+
+#else /* some other lib */
+/* Please see the comments for the above supported libaries for examples
+ * of what is required to support your stdio implementation.
+ */
+#error Your stdio library is currently not supported.  Please see the commented source.
+#endif
+
+#ifdef L_vfprintf
+extern int bb_vfprintf(FILE * __restrict stream,
+					   const char * __restrict format,
+					   va_list arg)
+{
+	int rv;
+
+	if ((rv = vfprintf(stream, format, arg)) < 0) {
+		SET_FERROR_UNLOCKED(stream);
+	}
+
+	return rv;
+}
+#endif
+
+#ifdef L_vprintf
+extern int bb_vprintf(const char * __restrict format, va_list arg)
+{
+	return bb_vfprintf(stdout, format, arg);
+}
+#endif
+
+#ifdef L_fprintf
+extern int bb_fprintf(FILE * __restrict stream,
+					  const char * __restrict format, ...)
+{
+	va_list arg;
+	int rv;
+
+	va_start(arg, format);
+	rv = bb_vfprintf(stream, format, arg);
+	va_end(arg);
+
+	return rv;
+}
+#endif
+
+#ifdef L_printf
+extern int bb_printf(const char * __restrict format, ...)
+{
+	va_list arg;
+	int rv;
+
+	va_start(arg, format);
+	rv = bb_vfprintf(stdout, format, arg);
+	va_end(arg);
+
+	return rv;
+}
+#endif
diff --git a/libbb/process_escape_sequence.c b/libbb/process_escape_sequence.c
index 9a16f80ab..ef2717bdd 100644
--- a/libbb/process_escape_sequence.c
+++ b/libbb/process_escape_sequence.c
@@ -2,7 +2,7 @@
 /*
  * Utility routines.
  *
- * Copyright (C) Manuel Nova III <mnovoa3@bellsouth.net>
+ * Copyright (C) Manuel Novoa III <mjn3@codepoet.org>
  * and Vladimir Oleynik <dzo@simtreas.ru>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -26,9 +26,7 @@
 #include <limits.h>
 #include "libbb.h"
 
-
-
-char process_escape_sequence(const char **ptr)
+char bb_process_escape_sequence(const char **ptr)
 {
 	static const char charmap[] = {
 		'a',  'b',  'f',  'n',  'r',  't',  'v',  '\\', 0,
@@ -36,40 +34,43 @@ char process_escape_sequence(const char **ptr)
 
 	const char *p;
 	const char *q;
-	int num_digits;
+	unsigned int num_digits;
+	unsigned int r;
 	unsigned int n;
 	
 	n = 0;
 	q = *ptr;
 
-	for ( num_digits = 0 ; num_digits < 3 ; ++num_digits) {
-		if ((*q < '0') || (*q > '7')) { /* not a digit? */
-			break;
+	num_digits = 0;
+	do {
+		if (((unsigned int)(*q - '0')) <= 7) {
+			r = n * 8 + (*q - '0');
+			if (r <= UCHAR_MAX) {
+				n = r;
+				++q;
+				if (++num_digits < 3) {
+					continue;
+				}
+			}
 		}
-		n = n * 8 + (*q++ - '0');
-	}
+		break;
+	} while (1);
 
 	if (num_digits == 0) {	/* mnemonic escape sequence? */
-		for (p=charmap ; *p ; p++) {
+		p = charmap;
+		do {
 			if (*p == *q) {
 				q++;
 				break;
 			}
-		}
+		} while (*++p);
 		n = *(p+(sizeof(charmap)/2));
 	}
 
-	   /* doesn't hurt to fall through to here from mnemonic case */
-	if (n > UCHAR_MAX) {	/* is octal code too big for a char? */
-		n /= 8;			/* adjust value and */
-		--q;				/* back up one char */
-	}
-
 	*ptr = q;
 	return (char) n;
 }
 
-
 /* END CODE */
 /*
 Local Variables:
diff --git a/libbb/procps.c b/libbb/procps.c
index fcc9c2d3a..a513f3f7f 100644
--- a/libbb/procps.c
+++ b/libbb/procps.c
@@ -34,7 +34,7 @@ extern procps_status_t * procps_scan(int save_user_arg0)
 	if (!dir) {
 		dir = opendir("/proc");
 		if(!dir)
-			error_msg_and_die("Can't open /proc");
+			bb_error_msg_and_die("Can't open /proc");
 	}
 	for(;;) {
 		if((entry = readdir(dir)) == NULL) {
diff --git a/libbb/read_package_field.c b/libbb/read_package_field.c
index 867b198ba..42628f35c 100644
--- a/libbb/read_package_field.c
+++ b/libbb/read_package_field.c
@@ -102,10 +102,10 @@ int read_package_field(const char *package_buffer, char **field_name, char **fie
 	if (name_length == 0) {
 		*field_name = NULL;
 	} else {
-		*field_name = xstrndup(&package_buffer[offset_name_start], name_length);
+		*field_name = bb_xstrndup(&package_buffer[offset_name_start], name_length);
 	}
 	if (value_length > 0) {
-		*field_value = xstrndup(&package_buffer[offset_value_start], value_length);
+		*field_value = bb_xstrndup(&package_buffer[offset_value_start], value_length);
 	} else {
 		*field_value = NULL;
 	}
diff --git a/libbb/recursive_action.c b/libbb/recursive_action.c
index 8f9cc2f91..a4a4a7be3 100644
--- a/libbb/recursive_action.c
+++ b/libbb/recursive_action.c
@@ -60,10 +60,10 @@ int recursive_action(const char *fileName,
 
 	if (status < 0) {
 #ifdef DEBUG_RECURS_ACTION
-		error_msg("status=%d followLinks=%d TRUE=%d",
+		bb_error_msg("status=%d followLinks=%d TRUE=%d",
 				status, followLinks, TRUE);
 #endif
-		perror_msg("%s", fileName);
+		bb_perror_msg("%s", fileName);
 		return FALSE;
 	}
 
@@ -89,14 +89,14 @@ int recursive_action(const char *fileName,
 		if (dirAction != NULL && ! depthFirst) {
 			status = dirAction(fileName, &statbuf, userData);
 			if (! status) {
-				perror_msg("%s", fileName);
+				bb_perror_msg("%s", fileName);
 				return FALSE;
 			} else if (status == SKIP)
 				return TRUE;
 		}
 		dir = opendir(fileName);
 		if (!dir) {
-			perror_msg("%s", fileName);
+			bb_perror_msg("%s", fileName);
 			return FALSE;
 		}
 		status = TRUE;
@@ -117,7 +117,7 @@ int recursive_action(const char *fileName,
 		closedir(dir);
 		if (dirAction != NULL && depthFirst) {
 			if (! dirAction(fileName, &statbuf, userData)) {
-				perror_msg("%s", fileName);
+				bb_perror_msg("%s", fileName);
 				return FALSE;
 			}
 		}
diff --git a/libbb/remove_file.c b/libbb/remove_file.c
index 988b09124..65708a252 100644
--- a/libbb/remove_file.c
+++ b/libbb/remove_file.c
@@ -37,7 +37,7 @@ extern int remove_file(const char *path, int flags)
 
 	if (lstat(path, &path_stat) < 0) {
 		if (errno != ENOENT) {
-			perror_msg("unable to stat `%s'", path);
+			bb_perror_msg("unable to stat `%s'", path);
 			return -1;
 		}
 
@@ -46,7 +46,7 @@ extern int remove_file(const char *path, int flags)
 
 	if (!path_exists) {
 		if (!(flags & FILEUTILS_FORCE)) {
-			perror_msg("cannot remove `%s'", path);
+			bb_perror_msg("cannot remove `%s'", path);
 			return -1;
 		}
 		return 0;
@@ -58,21 +58,21 @@ extern int remove_file(const char *path, int flags)
 		int status = 0;
 
 		if (!(flags & FILEUTILS_RECUR)) {
-			error_msg("%s: is a directory", path);
+			bb_error_msg("%s: is a directory", path);
 			return -1;
 		}
 
 		if ((!(flags & FILEUTILS_FORCE) && access(path, W_OK) < 0 &&
 					isatty(0)) ||
 				(flags & FILEUTILS_INTERACTIVE)) {
-			fprintf(stderr, "%s: descend into directory `%s'? ", applet_name,
+			fprintf(stderr, "%s: descend into directory `%s'? ", bb_applet_name,
 					path);
-			if (!ask_confirmation())
+			if (!bb_ask_confirmation())
 				return 0;
 		}
 
 		if ((dp = opendir(path)) == NULL) {
-			perror_msg("unable to open `%s'", path);
+			bb_perror_msg("unable to open `%s'", path);
 			return -1;
 		}
 
@@ -90,18 +90,18 @@ extern int remove_file(const char *path, int flags)
 		}
 
 		if (closedir(dp) < 0) {
-			perror_msg("unable to close `%s'", path);
+			bb_perror_msg("unable to close `%s'", path);
 			return -1;
 		}
 
 		if (flags & FILEUTILS_INTERACTIVE) {
-			fprintf(stderr, "%s: remove directory `%s'? ", applet_name, path);
-			if (!ask_confirmation())
+			fprintf(stderr, "%s: remove directory `%s'? ", bb_applet_name, path);
+			if (!bb_ask_confirmation())
 				return status;
 		}
 
 		if (rmdir(path) < 0) {
-			perror_msg("unable to remove `%s'", path);
+			bb_perror_msg("unable to remove `%s'", path);
 			return -1;
 		}
 
@@ -111,13 +111,13 @@ extern int remove_file(const char *path, int flags)
 					!S_ISLNK(path_stat.st_mode) &&
 					isatty(0)) ||
 				(flags & FILEUTILS_INTERACTIVE)) {
-			fprintf(stderr, "%s: remove `%s'? ", applet_name, path);
-			if (!ask_confirmation())
+			fprintf(stderr, "%s: remove `%s'? ", bb_applet_name, path);
+			if (!bb_ask_confirmation())
 				return 0;
 		}
 
 		if (unlink(path) < 0) {
-			perror_msg("unable to remove `%s'", path);
+			bb_perror_msg("unable to remove `%s'", path);
 			return -1;
 		}
 
diff --git a/libbb/run_parts.c b/libbb/run_parts.c
index 7829a84ba..58645660b 100644
--- a/libbb/run_parts.c
+++ b/libbb/run_parts.c
@@ -69,7 +69,7 @@ extern int run_parts(char **args, const unsigned char test_mode)
 		if (test_mode & 2) {
 			return(2);
 		}
-		perror_msg_and_die("failed to open directory %s", arg0);
+		bb_perror_msg_and_die("failed to open directory %s", arg0);
 	}
 
 	for (i = 0; i < entries; i++) {
@@ -77,7 +77,7 @@ extern int run_parts(char **args, const unsigned char test_mode)
 		filename = concat_path_file(arg0, namelist[i]->d_name);
 
 		if (stat(filename, &st) < 0) {
-			perror_msg_and_die("failed to stat component %s", filename);
+			bb_perror_msg_and_die("failed to stat component %s", filename);
 		}
 		if (S_ISREG(st.st_mode) && !access(filename, X_OK)) {
 			if (test_mode & 1) {
@@ -89,7 +89,7 @@ extern int run_parts(char **args, const unsigned char test_mode)
 				int pid;
 
 				if ((pid = vfork()) < 0) {
-					perror_msg_and_die("failed to fork");
+					bb_perror_msg_and_die("failed to fork");
 				} else if (!pid) {
 					args[0] = filename;
 					execv(filename, args);
@@ -100,19 +100,19 @@ extern int run_parts(char **args, const unsigned char test_mode)
 				waitpid(pid, &result, 0);
 				if(exec_errno) {
 					errno = exec_errno;
-					perror_msg_and_die("failed to exec %s", filename);
+					bb_perror_msg_and_die("failed to exec %s", filename);
 				}
 				if (WIFEXITED(result) && WEXITSTATUS(result)) {
-					perror_msg("%s exited with return code %d", filename, WEXITSTATUS(result));
+					bb_perror_msg("%s exited with return code %d", filename, WEXITSTATUS(result));
 					exitstatus = 1;
 				} else if (WIFSIGNALED(result)) {
-					perror_msg("%s exited because of uncaught signal %d", filename, WTERMSIG(result));
+					bb_perror_msg("%s exited because of uncaught signal %d", filename, WTERMSIG(result));
 					exitstatus = 1;
 				}
 			}
 		} 
 		else if (!S_ISDIR(st.st_mode)) {
-			error_msg("component %s is not an executable plain file", filename);
+			bb_error_msg("component %s is not an executable plain file", filename);
 			exitstatus = 1;
 		}
 
diff --git a/libbb/run_shell.c b/libbb/run_shell.c
index b26eba115..d154b9852 100644
--- a/libbb/run_shell.c
+++ b/libbb/run_shell.c
@@ -57,11 +57,11 @@ void run_shell ( const char *shell, int loginshell, const char *command, const c
 	else
 		args = (const char **) xmalloc (sizeof (char *) * 4 );
 		
-	args [0] = get_last_path_component ( xstrdup ( shell ));
+	args [0] = bb_get_last_path_component ( bb_xstrdup ( shell ));
 	
 	if ( loginshell ) {
 		char *args0;
-		bb_asprintf ( &args0, "-%s", args [0] );
+		bb_xasprintf ( &args0, "-%s", args [0] );
 		args [0] = args0;
 	}
     
@@ -75,6 +75,6 @@ void run_shell ( const char *shell, int loginshell, const char *command, const c
 	}
 	args [argno] = 0;
 	execv ( shell, (char **) args );
-	perror_msg_and_die ( "cannot run %s", shell );
+	bb_perror_msg_and_die ( "cannot run %s", shell );
 }
 
diff --git a/libbb/setup_environment.c b/libbb/setup_environment.c
index dc171fa1f..30d317cea 100644
--- a/libbb/setup_environment.c
+++ b/libbb/setup_environment.c
@@ -45,7 +45,7 @@
 static void xsetenv ( const char *key, const char *value )
 {
 	    if ( setenv ( key, value, 1 ))
-			        error_msg_and_die ( "out of memory" );
+			        bb_error_msg_and_die ( "out of memory" );
 }
 
 void setup_environment ( const char *shell, int loginshell, int changeenv, const struct passwd *pw )
@@ -62,7 +62,7 @@ void setup_environment ( const char *shell, int loginshell, int changeenv, const
 		if ( chdir ( pw-> pw_dir )) {
 			if ( chdir ( "/" )) {
 				syslog ( LOG_WARNING, "unable to cd to %s' for user %s'\n", pw-> pw_dir, pw-> pw_name );
-				error_msg_and_die ( "cannot cd to home directory or /" );
+				bb_error_msg_and_die ( "cannot cd to home directory or /" );
 			}
 			fputs ( "warning: cannot change to home directory\n", stderr );
 		}
diff --git a/libbb/simplify_path.c b/libbb/simplify_path.c
index 7b2a1ca51..743133cd1 100644
--- a/libbb/simplify_path.c
+++ b/libbb/simplify_path.c
@@ -1,8 +1,8 @@
 /* vi: set sw=4 ts=4: */
 /*
- * simplify_path implementation for busybox
+ * bb_simplify_path implementation for busybox
  *
- * Copyright (C) 2001  Manuel Novoa III  <mjn3@opensource.lineo.com>
+ * Copyright (C) 2001  Manuel Novoa III  <mjn3@codepoet.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -21,15 +21,14 @@
  */
 
 #include <stdlib.h>
-
 #include "libbb.h"
 
-char *simplify_path(const char *path)
+char *bb_simplify_path(const char *path)
 {
 	char *s, *start, *p;
 
 	if (path[0] == '/')
-		start = xstrdup(path);
+		start = bb_xstrdup(path);
 	else {
 		s = xgetcwd(NULL);
 		start = concat_path_file(s, path);
diff --git a/libbb/skip_whitespace.c b/libbb/skip_whitespace.c
new file mode 100644
index 000000000..bf049a2d2
--- /dev/null
+++ b/libbb/skip_whitespace.c
@@ -0,0 +1,33 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * skip_whitespace implementation for busybox
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <ctype.h>
+#include "libbb.h"
+
+extern const char *bb_skip_whitespace(const char *s)
+{
+	while (isspace(*s)) {
+		++s;
+	}
+
+	return s;
+}
diff --git a/libbb/speed_table.c b/libbb/speed_table.c
new file mode 100644
index 000000000..b04429e91
--- /dev/null
+++ b/libbb/speed_table.c
@@ -0,0 +1,130 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * compact speed_t <-> speed functions for busybox
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <termios.h>
+#include "libbb.h"
+
+struct speed_map {
+	unsigned short speed;
+	unsigned short value;
+};
+
+static const struct speed_map speeds[] = {
+	{B0, 0},
+	{B50, 50},
+	{B75, 75},
+	{B110, 110},
+	{B134, 134},
+	{B150, 150},
+	{B200, 200},
+	{B300, 300},
+	{B600, 600},
+	{B1200, 1200},
+	{B1800, 1800},
+	{B2400, 2400},
+	{B4800, 4800},
+	{B9600, 9600},
+#ifdef	B19200
+	{B19200, 19200},
+#elif defined(EXTA)
+	{EXTA, 19200},
+#endif
+#ifdef	B38400
+	{B38400, 38400/256 + 0x8000U},
+#elif defined(EXTB)
+	{EXTB, 38400/256 + 0x8000U},
+#endif
+#ifdef B57600
+	{B57600, 57600/256 + 0x8000U},
+#endif
+#ifdef B115200
+	{B115200, 115200/256 + 0x8000U},
+#endif
+#ifdef B230400
+	{B230400, 230400/256 + 0x8000U},
+#endif
+#ifdef B460800
+	{B460800, 460800/256 + 0x8000U},
+#endif
+};
+
+static const int NUM_SPEEDS = (sizeof(speeds) / sizeof(struct speed_map));
+
+unsigned long bb_baud_to_value(speed_t speed)
+{
+	int i = 0;
+
+	do {
+		if (speed == speeds[i].speed) {
+			if (speeds[i].value & 0x8000U) {
+				return ((unsigned long) (speeds[i].value) & 0x7fffU) * 256;
+			}
+			return speeds[i].value;
+		}
+	} while (++i < NUM_SPEEDS);
+
+	return 0;
+}
+
+speed_t bb_value_to_baud(unsigned long value)
+{
+	int i = 0;
+
+	do {
+		if (value == bb_baud_to_value(speeds[i].speed)) {
+			return speeds[i].speed;
+		}
+	} while (++i < NUM_SPEEDS);
+
+	return (speed_t) - 1;
+}
+
+#if 0
+/* testing code */
+#include <stdio.h>
+
+int main(void)
+{
+	unsigned long v;
+	speed_t s;
+
+	for (v = 0 ; v < 500000 ; v++) {
+		s = bb_value_to_baud(v);
+		if (s == (speed_t) -1) {
+			continue;
+		}
+		printf("v = %lu -- s = %0lo\n", v, (unsigned long) s);
+	}
+
+	printf("-------------------------------\n");
+
+	for (s = 0 ; s < 010017+1 ; s++) {
+		v = bb_baud_to_value(s);
+		if (!v) {
+			continue;
+		}
+		printf("v = %lu -- s = %0lo\n", v, (unsigned long) s);
+	}
+
+	return 0;
+}
+#endif
diff --git a/libbb/syscalls.c b/libbb/syscalls.c
index 91e97b178..8d8c689f1 100644
--- a/libbb/syscalls.c
+++ b/libbb/syscalls.c
@@ -53,7 +53,7 @@ int pivot_root(const char * new_root,const char * put_old)
 	 *  you will need to recompile with a kernel supporting the
 	 *  pivot_root system call.
 	 */
-	error_msg("\n\nTo make this application work, you will need to recompile\n"
+	bb_error_msg("\n\nTo make this application work, you will need to recompile\n"
 		"with a kernel supporting the pivot_root system call. -Erik\n");
 	errno=ENOSYS;
 	return -1;
@@ -91,7 +91,7 @@ int umount2(const char * special_file, int flags)
 	 *  you will need to recompile with a kernel supporting the
 	 *  umount2 system call.
 	 */
-	error_msg("\n\nTo make this application work, you will need to recompile\n"
+	bb_error_msg("\n\nTo make this application work, you will need to recompile\n"
 		"with a kernel supporting the umount2 system call. -Erik\n");
 	errno=ENOSYS;
 	return -1;
diff --git a/libbb/syslog_msg_with_name.c b/libbb/syslog_msg_with_name.c
index 6474da459..bd3f44824 100644
--- a/libbb/syslog_msg_with_name.c
+++ b/libbb/syslog_msg_with_name.c
@@ -32,7 +32,7 @@ void syslog_msg_with_name(const char *name, int facility, int pri, const char *m
 
 void syslog_msg(int facility, int pri, const char *msg)
 {
- 	syslog_msg_with_name(applet_name, facility, pri, msg);
+ 	syslog_msg_with_name(bb_applet_name, facility, pri, msg);
 }
 
 /* END CODE */
diff --git a/libbb/verror_msg.c b/libbb/verror_msg.c
index 21cde2047..4612bf378 100644
--- a/libbb/verror_msg.c
+++ b/libbb/verror_msg.c
@@ -25,10 +25,10 @@
 #include <stdlib.h>
 #include "libbb.h"
 
-extern void verror_msg(const char *s, va_list p)
+extern void bb_verror_msg(const char *s, va_list p)
 {
 	fflush(stdout);
-	fprintf(stderr, "%s: ", applet_name);
+	fprintf(stderr, "%s: ", bb_applet_name);
 	vfprintf(stderr, s, p);
 }
 
diff --git a/libbb/vherror_msg.c b/libbb/vherror_msg.c
index 67db17fe4..eb341bf84 100644
--- a/libbb/vherror_msg.c
+++ b/libbb/vherror_msg.c
@@ -26,11 +26,11 @@
 #include "libbb.h"
 
 
-extern void vherror_msg(const char *s, va_list p)
+extern void bb_vherror_msg(const char *s, va_list p)
 {
 	if(s == 0)
 		s = "";
-	verror_msg(s, p);
+	bb_verror_msg(s, p);
 	if (*s)
 		fputs(": ", stderr);
 	herror("");
diff --git a/libbb/vperror_msg.c b/libbb/vperror_msg.c
index 7da5bae0a..febe4e22e 100644
--- a/libbb/vperror_msg.c
+++ b/libbb/vperror_msg.c
@@ -25,11 +25,11 @@
 #include <stdlib.h>
 #include "libbb.h"
 
-extern void vperror_msg(const char *s, va_list p)
+extern void bb_vperror_msg(const char *s, va_list p)
 {
 	int err=errno;
 	if(s == 0) s = "";
-	verror_msg(s, p);
+	bb_verror_msg(s, p);
 	if (*s) s = ": ";
 	fprintf(stderr, "%s%s\n", s, strerror(err));
 }
diff --git a/libbb/warn_ignoring_args.c b/libbb/warn_ignoring_args.c
new file mode 100644
index 000000000..223831fd1
--- /dev/null
+++ b/libbb/warn_ignoring_args.c
@@ -0,0 +1,30 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * warn_ingoring_args implementations for busybox
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <libbb.h>
+
+extern void bb_warn_ignoring_args(int n)
+{
+	if (n) {
+		bb_perror_msg("ignoring all arguments");
+	}
+}
diff --git a/libbb/wfopen.c b/libbb/wfopen.c
index f58ec90c0..22f22b373 100644
--- a/libbb/wfopen.c
+++ b/libbb/wfopen.c
@@ -23,11 +23,11 @@
 #include <errno.h>
 #include "libbb.h"
 
-FILE *wfopen(const char *path, const char *mode)
+FILE *bb_wfopen(const char *path, const char *mode)
 {
 	FILE *fp;
 	if ((fp = fopen(path, mode)) == NULL) {
-		perror_msg("%s", path);
+		bb_perror_msg("%s", path);
 		errno = 0;
 	}
 	return fp;
diff --git a/libbb/wfopen_input.c b/libbb/wfopen_input.c
new file mode 100644
index 000000000..bff6606b5
--- /dev/null
+++ b/libbb/wfopen_input.c
@@ -0,0 +1,54 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * wfopen_input implementation for busybox
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+/* A number of applets need to open a file for reading, where the filename
+ * is a command line arg.  Since often that arg is '-' (meaning stdin),
+ * we avoid testing everywhere by consolidating things in this routine.
+ *
+ * Note: We also consider "" to main stdin (for 'cmp' at least).
+ */
+
+#include <stdio.h>
+#include <sys/stat.h>
+#include <libbb.h>
+
+FILE *bb_wfopen_input(const char *filename)
+{
+	FILE *fp = stdin;
+
+	if ((filename != bb_msg_standard_input)
+		&& filename[0] && ((filename[0] != '-') || filename[1])
+	) {
+#if 0
+		/* This check shouldn't be necessary for linux, but is left
+		 * here disabled just in case. */
+		struct stat stat_buf;
+		if (is_directory(filename, 1, &stat_buf)) {
+			bb_error_msg("%s: Is a directory", filename);
+			return NULL;
+		}
+#endif
+		fp = bb_wfopen(filename, "r");
+	}
+
+	return fp;
+}
diff --git a/libbb/xconnect.c b/libbb/xconnect.c
index bc6505a40..2945d760f 100644
--- a/libbb/xconnect.c
+++ b/libbb/xconnect.c
@@ -30,7 +30,7 @@ int xconnect(const char *host, const char *port)
 	hints.ai_socktype = SOCK_STREAM;
 	error = getaddrinfo(host, port, &hints, &res);
 	if (error||!res)
-		perror_msg_and_die(gai_strerror(error));
+		bb_perror_msg_and_die(gai_strerror(error));
 	addr_info=res;
 	while (res) {
 		s=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
@@ -50,7 +50,7 @@ int xconnect(const char *host, const char *port)
 	freeaddrinfo(addr_info);
 	if (error < 0)
 	{
-		perror_msg_and_die("Unable to connect to remote host (%s)", host);
+		bb_perror_msg_and_die("Unable to connect to remote host (%s)", host);
 	}
 	return s;
 #else
@@ -72,7 +72,7 @@ int xconnect(const char *host, const char *port)
 
 	if (connect(s, (struct sockaddr *)&s_addr, sizeof s_addr) < 0)
 	{
-		perror_msg_and_die("Unable to connect to remote host (%s)", host);
+		bb_perror_msg_and_die("Unable to connect to remote host (%s)", host);
 	}
 	return s;
 #endif
diff --git a/libbb/xfuncs.c b/libbb/xfuncs.c
index 820a0d7cc..43e8aef0c 100644
--- a/libbb/xfuncs.c
+++ b/libbb/xfuncs.c
@@ -30,31 +30,38 @@
 
 
 #ifndef DMALLOC
+#ifdef L_xmalloc
 extern void *xmalloc(size_t size)
 {
 	void *ptr = malloc(size);
 	if (ptr == NULL && size != 0)
-		error_msg_and_die(memory_exhausted);
+		bb_error_msg_and_die(bb_msg_memory_exhausted);
 	return ptr;
 }
+#endif
 
+#ifdef L_xrealloc
 extern void *xrealloc(void *ptr, size_t size)
 {
 	ptr = realloc(ptr, size);
 	if (ptr == NULL && size != 0)
-		error_msg_and_die(memory_exhausted);
+		bb_error_msg_and_die(bb_msg_memory_exhausted);
 	return ptr;
 }
+#endif
 
+#ifdef L_xcalloc
 extern void *xcalloc(size_t nmemb, size_t size)
 {
 	void *ptr = calloc(nmemb, size);
 	if (ptr == NULL && nmemb != 0 && size != 0)
-		error_msg_and_die(memory_exhausted);
+		bb_error_msg_and_die(bb_msg_memory_exhausted);
 	return ptr;
 }
+#endif
 
-extern char * xstrdup (const char *s) {
+#ifdef L_xstrdup
+extern char * bb_xstrdup (const char *s) {
 	char *t;
 
 	if (s == NULL)
@@ -63,79 +70,121 @@ extern char * xstrdup (const char *s) {
 	t = strdup (s);
 
 	if (t == NULL)
-		error_msg_and_die(memory_exhausted);
+		bb_error_msg_and_die(bb_msg_memory_exhausted);
 
 	return t;
 }
 #endif
+#endif /* DMALLOC */
 
-extern char * xstrndup (const char *s, int n) {
+#ifdef L_xstrndup
+extern char * bb_xstrndup (const char *s, int n) {
 	char *t;
 
 	if (s == NULL)
-		error_msg_and_die("xstrndup bug");
+		bb_error_msg_and_die("bb_xstrndup bug");
 
 	t = xmalloc(++n);
 	
 	return safe_strncpy(t,s,n);
 }
+#endif
 
-FILE *xfopen(const char *path, const char *mode)
+#ifdef L_xfopen
+FILE *bb_xfopen(const char *path, const char *mode)
 {
 	FILE *fp;
 	if ((fp = fopen(path, mode)) == NULL)
-		perror_msg_and_die("%s", path);
+		bb_perror_msg_and_die("%s", path);
 	return fp;
 }
+#endif
 
-extern int xopen(const char *pathname, int flags)
+#ifdef L_xopen
+extern int bb_xopen(const char *pathname, int flags)
 {
 	int ret;
 	
 	ret = open(pathname, flags, 0777);
 	if (ret == -1) {
-		perror_msg_and_die("%s", pathname);
+		bb_perror_msg_and_die("%s", pathname);
 	}
 	return ret;
 }
+#endif
 
-extern ssize_t xread(int fd, void *buf, size_t count)
+#ifdef L_xread
+extern ssize_t bb_xread(int fd, void *buf, size_t count)
 {
 	ssize_t size;
 
 	size = read(fd, buf, count);
 	if (size == -1) {
-		perror_msg_and_die("Read error");
+		bb_perror_msg_and_die("Read error");
 	}
 	return(size);
 }
+#endif
 
-extern void xread_all(int fd, void *buf, size_t count)
+#ifdef L_xread_all
+extern void bb_xread_all(int fd, void *buf, size_t count)
 {
 	ssize_t size;
 
-	size = xread(fd, buf, count);
-	if (size != count) {
-		error_msg_and_die("Short read");
+	while (count) {
+		if ((size = bb_xread(fd, buf, count)) == 0) {	/* EOF */
+			bb_error_msg_and_die("Short read");
+		}
+		count -= size;
 	}
 	return;
 }
+#endif
 
-extern unsigned char xread_char(int fd)
+#ifdef L_xread_char
+extern unsigned char bb_xread_char(int fd)
 {
 	char tmp;
 	
-	xread_all(fd, &tmp, 1);
+	bb_xread_all(fd, &tmp, 1);
 
 	return(tmp);	
 }
+#endif
+
+#ifdef L_xferror
+extern void bb_xferror(FILE *fp, const char *fn)
+{
+	if (ferror(fp)) {
+		bb_error_msg_and_die("%s", fn);
+	}
+}
+#endif
+
+#ifdef L_xferror_stdout
+extern void bb_xferror_stdout(void)
+{
+	bb_xferror(stdout, bb_msg_standard_output);
+}
+#endif
+
+#ifdef L_xfflush_stdout
+extern void bb_xfflush_stdout(void)
+{
+	if (fflush(stdout)) {
+		bb_perror_msg_and_die(bb_msg_standard_output);
+	}
+}
+#endif
 
+#ifdef L_strlen
 /* Stupid gcc always includes its own builtin strlen()... */
 #undef strlen
-size_t xstrlen(const char *string)
+size_t bb_strlen(const char *string)
 {
 	    return(strlen(string));
 }
+#endif
 
 /* END CODE */
 /*
diff --git a/libbb/xgetcwd.c b/libbb/xgetcwd.c
index 54e9785ed..85a5c4125 100644
--- a/libbb/xgetcwd.c
+++ b/libbb/xgetcwd.c
@@ -40,7 +40,7 @@ xgetcwd (char *cwd)
 
   if (ret == NULL) {
       free (cwd);
-      perror_msg("getcwd()");
+      bb_perror_msg("getcwd()");
       return NULL;
   }
 
diff --git a/libbb/xgethostbyname.c b/libbb/xgethostbyname.c
index b71979701..6b2dff711 100644
--- a/libbb/xgethostbyname.c
+++ b/libbb/xgethostbyname.c
@@ -29,7 +29,7 @@ struct hostent *xgethostbyname(const char *name)
 	struct hostent *retval;
 
 	if ((retval = gethostbyname(name)) == NULL)
-		herror_msg_and_die("%s", name);
+		bb_herror_msg_and_die("%s", name);
 
 	return retval;
 }
diff --git a/libbb/xgethostbyname2.c b/libbb/xgethostbyname2.c
index f4cbb6a56..3a16ae4dc 100644
--- a/libbb/xgethostbyname2.c
+++ b/libbb/xgethostbyname2.c
@@ -30,7 +30,7 @@ struct hostent *xgethostbyname2(const char *name, int af)
 	struct hostent *retval;
 
 	if ((retval = gethostbyname2(name, af)) == NULL)
-		herror_msg_and_die("%s", name);
+		bb_herror_msg_and_die("%s", name);
 
 	return retval;
 }
diff --git a/libbb/xgetlarg.c b/libbb/xgetlarg.c
index 598b0b3d6..06e776dc9 100644
--- a/libbb/xgetlarg.c
+++ b/libbb/xgetlarg.c
@@ -9,6 +9,7 @@
 #include <getopt.h>
 #include <errno.h>
 #include <assert.h>
+#include <ctype.h>
 
 #include "busybox.h"
 
@@ -19,10 +20,16 @@ extern long bb_xgetlarg(char *arg, int base, long lower, long upper)
 	int errno_save = errno;
 
 	assert(arg!=NULL);
+
+	/* Don't allow leading whitespace. */
+	if ((isspace)(*arg)) {	/* Use an actual funciton call for minimal size. */
+		bb_show_usage();
+	}
+
 	errno = 0;
 	result = strtol(arg, &endptr, base);
-	if (errno != 0 || *endptr!='\0' || result < lower || result > upper)
-		show_usage();
+	if (errno != 0 || *endptr!='\0' || endptr==arg || result < lower || result > upper)
+		bb_show_usage();
 	errno = errno_save;
 	return result;
 }
diff --git a/libbb/xgetularg.c b/libbb/xgetularg.c
new file mode 100644
index 000000000..d743520c3
--- /dev/null
+++ b/libbb/xgetularg.c
@@ -0,0 +1,160 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * xgetularg* implementations for busybox
+ *
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <ctype.h>
+#include <errno.h>
+#include <assert.h>
+#include "libbb.h"
+
+#ifdef L_xgetularg_bnd_sfx
+extern 
+unsigned long bb_xgetularg_bnd_sfx(const char *arg, int base,
+								   unsigned long lower,
+								   unsigned long upper,
+								   const struct suffix_mult *suffixes)
+{
+	unsigned long r;
+	int old_errno;
+	char *e;
+
+	assert(arg);
+
+	/* Disallow '-' and any leading whitespace.  Speed isn't critical here
+	 * since we're parsing commandline args.  So make sure we get the
+	 * actual isspace function rather than a larger macro implementaion. */
+	if ((*arg == '-') || (isspace)(*arg)) {
+		bb_show_usage();
+	}
+
+	/* Since this is a lib function, we're not allowed to reset errno to 0.
+	 * Doing so could break an app that is deferring checking of errno.
+	 * So, save the old value so that we can restore it if successful. */
+	old_errno = errno;
+	errno = 0;
+	r = strtoul(arg, &e, base);
+	/* Do the initial validity check.  Note: The standards do not
+	 * guarantee that errno is set if no digits were found.  So we
+	 * must test for this explicitly. */
+	if (errno || (arg == e)) {	/* error or no digits */
+		bb_show_usage();
+	}
+	errno = old_errno;	/* Ok.  So restore errno. */
+	
+	/* Do optional suffix parsing.  Allow 'empty' suffix tables.
+	 * Note that we also all nul suffixes with associated multipliers,
+	 * to allow for scaling of the arg by some default multiplier. */
+
+	if (suffixes) {
+		while (suffixes->suffix) {
+			if (strcmp(suffixes->suffix, e) == 0) {
+				if (ULONG_MAX / suffixes->mult < r) {	/* Overflow! */
+					bb_show_usage();
+				}
+				++e;
+				r *= suffixes->mult;
+				break;
+ 			}
+			++suffixes;
+		}
+	}		
+
+	/* Finally, check for illegal trailing chars and range limits. */
+	/* Note: although we allow leading space (via stroul), trailing space
+	 * is an error.  It would be easy enough to allow though if desired. */
+	if (*e || (r < lower) || (r > upper)) {
+		bb_show_usage();
+	}
+
+	return r;
+}
+#endif
+
+#ifdef L_xgetlarg_bnd_sfx
+extern 
+long bb_xgetlarg_bnd_sfx(const char *arg, int base,
+						 long lower,
+						 long upper,
+						 const struct suffix_mult *suffixes)
+{
+	unsigned long u = LONG_MAX;
+	long r;
+	const char *p = arg;
+
+	if ((*p == '-') && (p[1] != '+')) {
+		++p;
+#if LONG_MAX == (-(LONG_MIN + 1))
+		++u;	/* two's complement */
+#endif
+	}
+
+	r = bb_xgetularg_bnd_sfx(p, base, 0, u, suffixes);
+
+	if (*arg == '-') {
+		r = -r;
+	}
+
+	if ((r < lower) || (r > upper)) {
+		bb_show_usage();
+	}
+
+	return r;
+}
+#endif
+
+#ifdef L_getlarg10_sfx
+extern 
+long bb_xgetlarg10_sfx(const char *arg, const struct suffix_mult *suffixes)
+{
+	return bb_xgetlarg_bnd_sfx(arg, 10, LONG_MIN, LONG_MAX, suffixes);
+}
+#endif
+
+#ifdef L_xgetularg_bnd
+extern 
+unsigned long bb_xgetularg_bnd(const char *arg, int base,
+							   unsigned long lower,
+							   unsigned long upper)
+{
+	return bb_xgetularg_bnd_sfx(arg, base, lower, upper, NULL);
+}
+#endif
+
+#ifdef L_xgetularg10_bnd
+extern 
+unsigned long bb_xgetularg10_bnd(const char *arg,
+								 unsigned long lower,
+								 unsigned long upper)
+{
+	return bb_xgetularg_bnd(arg, 10, lower, upper);
+}
+#endif
+
+#ifdef L_xgetularg10
+extern 
+unsigned long bb_xgetularg10(const char *arg)
+{
+	return bb_xgetularg10_bnd(arg, 0, ULONG_MAX);
+}
+#endif
diff --git a/libbb/xreadlink.c b/libbb/xreadlink.c
index 9944b5129..b8cfe617a 100644
--- a/libbb/xreadlink.c
+++ b/libbb/xreadlink.c
@@ -24,7 +24,7 @@ extern char *xreadlink(const char *path)
 		buf = xrealloc(buf, bufsize += GROWBY);
 		readsize = readlink(path, buf, bufsize); /* 1st try */
 		if (readsize == -1) {
-                   perror_msg("%s", path);
+                   bb_perror_msg("%s", path);
 		    return NULL;
 		}
 	}           
diff --git a/libbb/xregcomp.c b/libbb/xregcomp.c
index 07cf779d1..56746ac53 100644
--- a/libbb/xregcomp.c
+++ b/libbb/xregcomp.c
@@ -34,7 +34,7 @@ void xregcomp(regex_t *preg, const char *regex, int cflags)
 		int errmsgsz = regerror(ret, preg, NULL, 0);
 		char *errmsg = xmalloc(errmsgsz);
 		regerror(ret, preg, errmsg, errmsgsz);
-		error_msg_and_die("xregcomp: %s", errmsg);
+		bb_error_msg_and_die("xregcomp: %s", errmsg);
 	}
 }
 
diff --git a/libpwdgrp/shadow.c b/libpwdgrp/shadow.c
index 2d2b108f2..f3d624213 100644
--- a/libpwdgrp/shadow.c
+++ b/libpwdgrp/shadow.c
@@ -55,7 +55,7 @@ void setspent(void)
 		rewind(shadow);
 	} else {
 		if ((shadow = fopen("/etc/shadow", "r")) == NULL)
-			perror_msg_and_die("/etc/shadow");
+			bb_perror_msg_and_die("/etc/shadow");
 	}
 }
 
diff --git a/loginutils/addgroup.c b/loginutils/addgroup.c
index 1d754af8e..2e8188dec 100644
--- a/loginutils/addgroup.c
+++ b/loginutils/addgroup.c
@@ -54,16 +54,16 @@ static int group_study(const char *filename, struct group *g)
 	struct group *grp;
 	const int max = 65000;
 
-	etc_group = xfopen(filename, "r");
+	etc_group = bb_xfopen(filename, "r");
 
 	/* make sure gr_name isn't taken, make sure gid is kosher */
 	desired = g->gr_gid;
 	while ((grp = fgetgrent(etc_group))) {
 		if ((strcmp(grp->gr_name, g->gr_name)) == 0) {
-			error_msg_and_die("%s: group already in use\n", g->gr_name);
+			bb_error_msg_and_die("%s: group already in use\n", g->gr_name);
 		}
 		if ((desired) && grp->gr_gid == desired) {
-			error_msg_and_die("%d: gid has already been allocated\n",
+			bb_error_msg_and_die("%d: gid has already been allocated\n",
 							  desired);
 		}
 		if ((grp->gr_gid > g->gr_gid) && (grp->gr_gid < max)) {
@@ -89,7 +89,6 @@ static int addgroup(const char *filename, char *group, gid_t gid, const char *us
 
 #ifdef CONFIG_FEATURE_SHADOWPASSWDS
 	FILE *etc_gshadow;
-	const char *gshadow = gshadow_file;
 #endif
 
 	struct group gr;
@@ -104,7 +103,7 @@ static int addgroup(const char *filename, char *group, gid_t gid, const char *us
 		return 1;
 
 	/* add entry to group */
-	etc_group = xfopen(filename, "a");
+	etc_group = bb_xfopen(filename, "a");
 
 	fprintf(etc_group, entryfmt, group, default_passwd, gr.gr_gid, user);
 	fclose(etc_group);
@@ -112,8 +111,8 @@ static int addgroup(const char *filename, char *group, gid_t gid, const char *us
 
 #ifdef CONFIG_FEATURE_SHADOWPASSWDS
 	/* add entry to gshadow if necessary */
-	if (access(gshadow, F_OK|W_OK) == 0) {
-		etc_gshadow = xfopen(gshadow, "a");
+	if (access(bb_path_gshadow_file, F_OK|W_OK) == 0) {
+		etc_gshadow = bb_xfopen(bb_path_gshadow_file, "a");
 		fprintf(etc_gshadow, "%s:!::\n", group);
 		fclose(etc_gshadow);
 	}
@@ -144,7 +143,7 @@ int addgroup_main(int argc, char **argv)
 				gid = strtol(optarg, NULL, 10);
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 				break;
 		}
 	}
@@ -153,7 +152,7 @@ int addgroup_main(int argc, char **argv)
 		group = argv[optind];
 		optind++;
 	} else {
-		show_usage();
+		bb_show_usage();
 	}
 	
 	if (optind < argc) {
@@ -164,12 +163,12 @@ int addgroup_main(int argc, char **argv)
 	}
 	
 	if (geteuid() != 0) {
-		error_msg_and_die
+		bb_error_msg_and_die
 			("Only root may add a group to the system.");
 	}
 
 	/* werk */
-	return addgroup(group_file, group, gid, user);
+	return addgroup(bb_path_group_file, group, gid, user);
 }
 
-/* $Id: addgroup.c,v 1.9 2003/01/09 18:53:53 andersen Exp $ */
+/* $Id: addgroup.c,v 1.10 2003/03/19 09:12:20 mjn3 Exp $ */
diff --git a/loginutils/adduser.c b/loginutils/adduser.c
index 3485611cc..cfaf860e0 100644
--- a/loginutils/adduser.c
+++ b/loginutils/adduser.c
@@ -66,7 +66,7 @@ static int passwd_study(const char *filename, struct passwd *p)
 	const int min = 500;
 	const int max = 65000;
 
-	passwd = wfopen(filename, "r");
+	passwd = bb_wfopen(filename, "r");
 	if (!passwd)
 		return 4;
 
@@ -112,7 +112,7 @@ static void addgroup_wrapper(const char *login, gid_t gid)
 {
 	char *cmd;
 
-	bb_asprintf(&cmd, "addgroup -g %d %s", gid, login);
+	bb_xasprintf(&cmd, "addgroup -g %d %s", gid, login);
 	system(cmd);
 	free(cmd);
 }
@@ -123,7 +123,7 @@ static void passwd_wrapper(const char *login)
 {
 	static const char prog[] = "passwd";
 	execlp(prog, prog, login, NULL);
-	error_msg_and_die("Failed to execute '%s', you must set the password for '%s' manually", prog, login);
+	bb_error_msg_and_die("Failed to execute '%s', you must set the password for '%s' manually", prog, login);
 }
 
 /* putpwent(3) remix */
@@ -137,7 +137,7 @@ static int adduser(const char *filename, struct passwd *p)
 #endif
 
 	/* make sure everything is kosher and setup uid && gid */
-	passwd = wfopen(filename, "a");
+	passwd = bb_wfopen(filename, "a");
 	if (passwd == NULL) {
 		return 1;
 	}
@@ -147,13 +147,13 @@ static int adduser(const char *filename, struct passwd *p)
 	r = passwd_study(filename, p);
 	if (r) {
 		if (r == 1)
-			error_msg("%s: login already in use", p->pw_name);
+			bb_error_msg("%s: login already in use", p->pw_name);
 		else if (r == 2)
-			error_msg("illegal uid or no uids left");
+			bb_error_msg("illegal uid or no uids left");
 		else if (r == 3)
-			error_msg("group name %s already in use", p->pw_name);
+			bb_error_msg("group name %s already in use", p->pw_name);
 		else
-			error_msg("generic error.");
+			bb_error_msg("generic error.");
 		return 1;
 	}
 
@@ -166,7 +166,7 @@ static int adduser(const char *filename, struct passwd *p)
 #ifdef CONFIG_FEATURE_SHADOWPASSWDS
 	/* add to shadow if necessary */
 	if (shadow_enabled) {
-		shadow = wfopen(shadow_file, "a");
+		shadow = bb_wfopen(bb_path_shadow_file, "a");
 		if (shadow == NULL) {
 			return 1;
 		}
@@ -191,16 +191,16 @@ static int adduser(const char *filename, struct passwd *p)
 
 	/* mkdir */
 	if (mkdir(p->pw_dir, 0755)) {
-		perror_msg("%s", p->pw_dir);
+		bb_perror_msg("%s", p->pw_dir);
 	}
 	/* Set the owner and group so it is owned by the new user. */
 	if (chown(p->pw_dir, p->pw_uid, p->pw_gid)) {
-		perror_msg("%s", p->pw_dir);
+		bb_perror_msg("%s", p->pw_dir);
 	}
 	/* Now fix up the permissions to 2755. Can't do it before now
 	 * since chown will clear the setgid bit */
 	if (chmod(p->pw_dir, 02755)) {
-		perror_msg("%s", p->pw_dir);
+		bb_perror_msg("%s", p->pw_dir);
 	}
 	/* interactively set passwd */
 	passwd_wrapper(p->pw_name);
@@ -234,7 +234,7 @@ int adduser_main(int argc, char **argv)
 
 	/* init */
 	if (argc < 2) {
-		show_usage();
+		bb_show_usage();
 	}
 	gecos = default_gecos;
 	shell = default_shell;
@@ -252,18 +252,18 @@ int adduser_main(int argc, char **argv)
 				shell = optarg;
 				break;
 			default:
-				show_usage ();
+				bb_show_usage();
 				break;
 		}
 
 	/* got root? */
 	if (i_am_not_root()) {
-		error_msg_and_die( "Only root may add a user or group to the system.");
+		bb_error_msg_and_die( "Only root may add a user or group to the system.");
 	}
 
 	/* get login */
 	if (optind >= argc) {
-		error_msg_and_die( "no user specified");
+		bb_error_msg_and_die( "no user specified");
 	}
 	login = argv[optind];
 
@@ -273,7 +273,7 @@ int adduser_main(int argc, char **argv)
 	}
 #ifdef CONFIG_FEATURE_SHADOWPASSWDS
 	/* is /etc/shadow in use? */
-	shadow_enabled = (0 == access(shadow_file, F_OK));
+	shadow_enabled = (0 == access(bb_path_shadow_file, F_OK));
 #endif
 
 	/* create a passwd struct */
@@ -286,7 +286,7 @@ int adduser_main(int argc, char **argv)
 	pw.pw_shell = (char *)shell;
 
 	/* grand finale */
-	return adduser(passwd_file, &pw);
+	return adduser(bb_path_passwd_file, &pw);
 }
 
-/* $Id: adduser.c,v 1.4 2002/09/16 06:22:24 andersen Exp $ */
+/* $Id: adduser.c,v 1.5 2003/03/19 09:12:20 mjn3 Exp $ */
diff --git a/loginutils/deluser.c b/loginutils/deluser.c
index c7d6ece64..ad62d41e0 100644
--- a/loginutils/deluser.c
+++ b/loginutils/deluser.c
@@ -116,19 +116,19 @@ int delgroup_main(int argc, char **argv)
 	int failure;
 
 	if (argc != 2) {
-		show_usage();
+		bb_show_usage();
 	} else {
 
-		failure = del_line_matching(argv[1], group_file);
+		failure = del_line_matching(argv[1], bb_path_group_file);
 #ifdef CONFIG_FEATURE_SHADOWPASSWDS
-		if (access(gshadow_file, W_OK) == 0) {
+		if (access(bb_path_gshadow_file, W_OK) == 0) {
 			/* EDR the |= works if the error is not 0, so he had it wrong */
-			failure |= del_line_matching(argv[1], gshadow_file);
+			failure |= del_line_matching(argv[1], bb_path_gshadow_file);
 		}
 #endif							/* CONFIG_FEATURE_SHADOWPASSWDS */
 		/* if (!successful) { */
 		if (failure) {
-			error_msg_and_die("%s: Group could not be removed\n", argv[1]);
+			bb_error_msg_and_die("%s: Group could not be removed\n", argv[1]);
 		}
 
 	}
@@ -142,38 +142,38 @@ int deluser_main(int argc, char **argv)
 	int failure;
 
 	if (argc != 2) {
-		show_usage();
+		bb_show_usage();
 	} else {
 
-		failure = del_line_matching(argv[1], passwd_file);
+		failure = del_line_matching(argv[1], bb_path_passwd_file);
 		/* if (!successful) { */
 		if (failure) {
-			error_msg_and_die("%s: User could not be removed from %s\n",
-							  argv[1], passwd_file);
+			bb_error_msg_and_die("%s: User could not be removed from %s\n",
+							  argv[1], bb_path_passwd_file);
 		}
 #ifdef CONFIG_FEATURE_SHADOWPASSWDS
-		failure = del_line_matching(argv[1], shadow_file);
+		failure = del_line_matching(argv[1], bb_path_shadow_file);
 		/* if (!successful) { */
 		if (failure) {
-			error_msg_and_die("%s: User could not be removed from %s\n",
-							  argv[1], shadow_file);
+			bb_error_msg_and_die("%s: User could not be removed from %s\n",
+							  argv[1], bb_path_shadow_file);
 		}
-		failure = del_line_matching(argv[1], gshadow_file);
+		failure = del_line_matching(argv[1], bb_path_gshadow_file);
 		/* if (!successful) { */
 		if (failure) {
-			error_msg_and_die("%s: User could not be removed from %s\n",
-							  argv[1], gshadow_file);
+			bb_error_msg_and_die("%s: User could not be removed from %s\n",
+							  argv[1], bb_path_gshadow_file);
 		}
 #endif							/* CONFIG_FEATURE_SHADOWPASSWDS */
-		failure = del_line_matching(argv[1], group_file);
+		failure = del_line_matching(argv[1], bb_path_group_file);
 		/* if (!successful) { */
 		if (failure) {
-			error_msg_and_die("%s: User could not be removed from %s\n",
-							  argv[1], group_file);
+			bb_error_msg_and_die("%s: User could not be removed from %s\n",
+							  argv[1], bb_path_group_file);
 		}
 
 	}
 	return (EXIT_SUCCESS);
 }
 
-/* $Id: deluser.c,v 1.2 2002/06/23 04:24:24 andersen Exp $ */
+/* $Id: deluser.c,v 1.3 2003/03/19 09:12:20 mjn3 Exp $ */
diff --git a/loginutils/getty.c b/loginutils/getty.c
index b8be8b603..4219ff821 100644
--- a/loginutils/getty.c
+++ b/loginutils/getty.c
@@ -169,6 +169,7 @@ struct chardata init_chardata = {
 	0,							/* no capslock */
 };
 
+#if 0
 struct Speedtab {
 	long speed;
 	int code;
@@ -211,6 +212,7 @@ static struct Speedtab speedtab[] = {
 #endif
 	{0, 0},
 };
+#endif
 
 static void parse_args(int argc, char **argv, struct options *op);
 static void parse_speeds(struct options *op, char *arg);
@@ -263,7 +265,7 @@ int getty_main(int argc, char **argv)
 	};
 
 #ifdef DEBUGGING
-	dbf = xfopen(DEBUGTERM, "w");
+	dbf = bb_xfopen(DEBUGTERM, "w");
 
 	{
 		int i;
@@ -383,7 +385,7 @@ static void parse_args(int argc, char **argv, struct options *op)
 		switch (c) {
 		case 'I':
 			if (!(op->initstring = strdup(optarg)))
-				error(memory_exhausted);
+				error(bb_msg_memory_exhausted);
 				
 			{
 				const char *p;
@@ -396,7 +398,7 @@ static void parse_args(int argc, char **argv, struct options *op)
 				while (*p) {
 					if (*p == '\\') {
 						p++;
-						*q++ = process_escape_sequence(&p);
+						*q++ = bb_process_escape_sequence(&p);
 					} else {
 						*q++ = *p++;
 					}
@@ -439,12 +441,12 @@ static void parse_args(int argc, char **argv, struct options *op)
 			op->flags |= F_WAITCRLF;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 	debug("after getopt loop\n");
 	if (argc < optind + 2)		/* check parameter count */
-		show_usage();
+		bb_show_usage();
 
 	/* we loosen up a bit and accept both "baudrate tty" and "tty baudrate" */
 	if ('0' <= argv[optind][0] && argv[optind][0] <= '9') {
@@ -953,6 +955,7 @@ static int caps_lock(const char *s)
 /* bcode - convert speed string to speed code; return 0 on failure */
 static int bcode(const char *s)
 {
+#if 0
 	struct Speedtab *sp;
 	long speed = atol(s);
 
@@ -960,6 +963,14 @@ static int bcode(const char *s)
 		if (sp->speed == speed)
 			return (sp->code);
 	return (0);
+#else
+	int r;
+
+	if ((r = bb_value_to_baud(atol(s))) > 0) {
+		return r;
+	}
+	return 0;
+#endif
 }
 
 /* error - report errors to console or syslog; only understands %s and %m */
@@ -982,7 +993,7 @@ static void error(const char *fmt, ...)
 	buf[0] = '\0';
 	bp = buf;
 #else
-	strncpy(buf, applet_name, 256);
+	strncpy(buf, bb_applet_name, 256);
 	strncat(buf, ": ", 256);
 	buf[255] = 0;
 	bp = buf + strlen(buf);
diff --git a/loginutils/login.c b/loginutils/login.c
index c1ea165c8..e239f421c 100644
--- a/loginutils/login.c
+++ b/loginutils/login.c
@@ -94,10 +94,10 @@ extern int login_main(int argc, char **argv)
 			 * (-f root, *NOT* -froot). --marekm
 			 */
 			if ( optarg != argv[optind-1] )
-				show_usage ( );
+				bb_show_usage( );
 
 			if ( !amroot ) 		/* Auth bypass only if real UID is zero */
-				error_msg_and_die ( "-f permission denied" );
+				bb_error_msg_and_die ( "-f permission denied" );
 			
 			safe_strncpy(username, optarg, USERNAME_SIZE);
 			opt_fflag = 1;
@@ -106,7 +106,7 @@ extern int login_main(int argc, char **argv)
 			opt_host = optarg;
 			break;
 		default:
-			show_usage ( );
+			bb_show_usage( );
 		}
 	}
 
@@ -275,11 +275,11 @@ static int login_prompt ( char *buf_name )
 
 static int check_nologin ( int amroot )
 {
-	if ( access ( nologin_file, F_OK ) == 0 ) {
+	if ( access ( bb_path_nologin_file, F_OK ) == 0 ) {
 		FILE *fp;
 		int c;
 
-		if (( fp = fopen ( nologin_file, "r" ))) {
+		if (( fp = fopen ( bb_path_nologin_file, "r" ))) {
 			while (( c = getc ( fp )) != EOF )
 				putchar (( c == '\n' ) ? '\r' : c );
 
@@ -304,9 +304,9 @@ static int check_tty ( const char *tty )
 	int i;
 	char buf[BUFSIZ];
 
-	if (( fp = fopen ( securetty_file, "r" ))) {
+	if (( fp = fopen ( bb_path_securetty_file, "r" ))) {
 		while ( fgets ( buf, sizeof( buf ) - 1, fp )) {
-			for ( i = xstrlen( buf ) - 1; i >= 0; --i ) {
+			for ( i = bb_strlen( buf ) - 1; i >= 0; --i ) {
 				if ( !isspace ( buf[i] ))
 					break;
 			}
@@ -348,7 +348,7 @@ static void motd ( )
 	FILE *fp;
 	register int c;
 
-	if (( fp = fopen ( motd_file, "r" ))) {
+	if (( fp = fopen ( bb_path_motd_file, "r" ))) {
 		while (( c = getc ( fp )) != EOF ) 
 			putchar ( c );		
 		fclose ( fp );
diff --git a/loginutils/passwd.c b/loginutils/passwd.c
index e02cc4b81..e8577066a 100644
--- a/loginutils/passwd.c
+++ b/loginutils/passwd.c
@@ -46,13 +46,13 @@ extern int update_passwd(const struct passwd *pw, char *crypt_pw)
 	struct stat sb;
 	struct flock lock;
 
-	if (access(shadow_file, F_OK) == 0) {
+	if (access(bb_path_shadow_file, F_OK) == 0) {
 		has_shadow = 1;
 	}
 	if (has_shadow) {
-		snprintf(filename, sizeof filename, "%s", shadow_file);
+		snprintf(filename, sizeof filename, "%s", bb_path_shadow_file);
 	} else {
-		snprintf(filename, sizeof filename, "%s", passwd_file);
+		snprintf(filename, sizeof filename, "%s", bb_path_passwd_file);
 	}
 
 	if (((fp = fopen(filename, "r+")) == 0) || (fstat(fileno(fp), &sb))) {
@@ -167,30 +167,30 @@ extern int passwd_main(int argc, char **argv)
 			uflg++;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 	ruid = getuid();
 	pw = (struct passwd *) getpwuid(ruid);
 	if (!pw) {
-               error_msg_and_die("Cannot determine your user name.");
+               bb_error_msg_and_die("Cannot determine your user name.");
 	}
-	myname = (char *) xstrdup(pw->pw_name);
+	myname = (char *) bb_xstrdup(pw->pw_name);
 	if (optind < argc) {
 		name = argv[optind];
 	} else {
 		name = myname;
 	}
 	if ((lflg || uflg || dflg) && (optind >= argc || !amroot)) {
-		show_usage();
+		bb_show_usage();
 	}
 	pw = getpwnam(name);
 	if (!pw) {
-		error_msg_and_die("Unknown user %s\n", name);
+		bb_error_msg_and_die("Unknown user %s\n", name);
 	}
 	if (!amroot && pw->pw_uid != getuid()) {
 		syslog(LOG_WARNING, "can't change pwd for `%s'", name);
-		error_msg_and_die("Permission denied.\n");
+		bb_error_msg_and_die("Permission denied.\n");
 	}
 #ifdef CONFIG_FEATURE_SHADOWPASSWDS
 	sp = getspnam(name);
@@ -209,12 +209,12 @@ extern int passwd_main(int argc, char **argv)
 		if (!amroot) {
 			if (cp[0] == '!') {
 				syslog(LOG_WARNING, "password locked for `%s'", np);
-				error_msg_and_die( "The password for `%s' cannot be changed.\n", np);
+				bb_error_msg_and_die( "The password for `%s' cannot be changed.\n", np);
 			}
 		}
 		printf("Changing password for %s\n", name);
 		if (new_password(pw, amroot, algo)) {
-			error_msg_and_die( "The password for %s is unchanged.\n", name);
+			bb_error_msg_and_die( "The password for %s is unchanged.\n", name);
 		}
 	} else if (lflg) {
 		if (crypt_passwd[0] != '!') {
@@ -238,7 +238,7 @@ extern int passwd_main(int argc, char **argv)
 	umask(077);
 	if (setuid(0)) {
 		syslog(LOG_ERR, "can't setuid(0)");
-		error_msg_and_die( "Cannot change ID to root.\n");
+		bb_error_msg_and_die( "Cannot change ID to root.\n");
 	}
 	if (!update_passwd(pw, crypt_passwd)) {
 		syslog(LOG_INFO, "password for `%s' changed by user `%s'", name,
@@ -246,7 +246,7 @@ extern int passwd_main(int argc, char **argv)
 		printf("Password changed.\n");
 	} else {
 		syslog(LOG_WARNING, "an error occurred updating the password file");
-		error_msg_and_die("An error occurred updating the password file.\n");
+		bb_error_msg_and_die("An error occurred updating the password file.\n");
 	}
 	return (0);
 }
diff --git a/loginutils/su.c b/loginutils/su.c
index 6d427262e..5e40cf2e4 100644
--- a/loginutils/su.c
+++ b/loginutils/su.c
@@ -94,7 +94,7 @@ int su_main ( int argc, char **argv )
 			opt_loginshell = 1;
 			break;
 		default:
-			show_usage ( );
+			bb_show_usage( );
 			break;
 		}
 	}
@@ -114,7 +114,7 @@ int su_main ( int argc, char **argv )
 		
 	pw = getpwnam ( opt_username );
 	if ( !pw )
-		error_msg_and_die ( "user %s does not exist", opt_username );
+		bb_error_msg_and_die ( "user %s does not exist", opt_username );
 		
 	/* Make sure pw->pw_shell is non-NULL.  It may be NULL when NEW_USER
 	   is a username that is retrieved via NIS (YP), but that doesn't have
@@ -127,15 +127,15 @@ int su_main ( int argc, char **argv )
 	   the static data through the getlogin call from log_su.  */
 	pw_copy = *pw;
 	pw = &pw_copy;
-	pw-> pw_name  = xstrdup ( pw-> pw_name );
-	pw-> pw_dir   = xstrdup ( pw-> pw_dir );
-	pw-> pw_shell = xstrdup ( pw-> pw_shell );
+	pw-> pw_name  = bb_xstrdup ( pw-> pw_name );
+	pw-> pw_dir   = bb_xstrdup ( pw-> pw_dir );
+	pw-> pw_shell = bb_xstrdup ( pw-> pw_shell );
 
 	if (( getuid ( ) == 0 ) || correct_password ( pw )) 
 		log_su ( pw, 1 );
 	else {
 		log_su ( pw, 0 );
-		error_msg_and_die ( "incorrect password" );
+		bb_error_msg_and_die ( "incorrect password" );
 	}
 
 	if ( !opt_shell && opt_preserve )
@@ -152,7 +152,7 @@ int su_main ( int argc, char **argv )
 	}
 
 	if ( !opt_shell )
-		opt_shell = xstrdup ( pw-> pw_shell );
+		opt_shell = bb_xstrdup ( pw-> pw_shell );
 
 	change_identity ( pw );	
 	setup_environment ( opt_shell, opt_loginshell, !opt_preserve, pw );
diff --git a/loginutils/sulogin.c b/loginutils/sulogin.c
index a654ffb89..bb4716e0d 100644
--- a/loginutils/sulogin.c
+++ b/loginutils/sulogin.c
@@ -117,9 +117,9 @@ extern int sulogin_main(int argc, char **argv)
 			}
 		}
 	}
-	if (access(passwd_file, 0) == -1) {
+	if (access(bb_path_passwd_file, 0) == -1) {
 		syslog(LOG_WARNING, "No password file\n");
-		error_msg_and_die("No password file\n");
+		bb_error_msg_and_die("No password file\n");
 	}
 	if (!isatty(0) || !isatty(1) || !isatty(2)) {
 		exit(EXIT_FAILURE);
@@ -135,7 +135,7 @@ extern int sulogin_main(int argc, char **argv)
 	alarm(timeout);
 	if (!(pwd = getpwnam(name))) {
 		syslog(LOG_WARNING, "No password entry for `root'\n");
-		error_msg_and_die("No password entry for `root'\n");
+		bb_error_msg_and_die("No password entry for `root'\n");
 	}
 	pwent = *pwd;
 #ifdef CONFIG_FEATURE_SHADOWPASSWDS
diff --git a/loginutils/vlock.c b/loginutils/vlock.c
index 18f4b9407..7abf120d9 100644
--- a/loginutils/vlock.c
+++ b/loginutils/vlock.c
@@ -29,6 +29,7 @@
  * It now works with md5, sha1, etc passwords. */
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <sys/vt.h>
 #include <signal.h>
 #include <string.h>
@@ -96,26 +97,26 @@ extern int vlock_main(int argc, char **argv)
 	struct termios term;
 
 	if (argc > 2) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	if (argc == 2) {
 		if (strncmp(argv[1], "-a", 2)) {
-			show_usage();
+			bb_show_usage();
 		} else {
 			o_lock_all = 1;
 		}
 	}
 
 	if ((pw = getpwuid(getuid())) == NULL) {
-		error_msg_and_die("no password for uid %d\n", getuid());
+		bb_error_msg_and_die("no password for uid %d\n", getuid());
 	}
 #ifdef CONFIG_FEATURE_SHADOWPASSWDS
 	if ((strcmp(pw->pw_passwd, "x") == 0)
 		|| (strcmp(pw->pw_passwd, "*") == 0)) {
 
 		if ((spw = getspuid(getuid())) == NULL) {
-			error_msg_and_die("could not read shadow password for uid %d: %s\n",
+			bb_error_msg_and_die("could not read shadow password for uid %d: %s\n",
 					   getuid(), strerror(errno));
 		}
 		if (spw->sp_pwdp) {
@@ -124,7 +125,7 @@ extern int vlock_main(int argc, char **argv)
 	}
 #endif							/* CONFIG_FEATURE_SHADOWPASSWDS */
 	if (pw->pw_passwd[0] == '!' || pw->pw_passwd[0] == '*') {
-		error_msg_and_die("Account disabled for uid %d\n", getuid());
+		bb_error_msg_and_die("Account disabled for uid %d\n", getuid());
 	}
 
 	/* we no longer need root privs */
@@ -132,11 +133,11 @@ extern int vlock_main(int argc, char **argv)
 	setgid(getgid());
 
 	if ((vfd = open("/dev/tty", O_RDWR)) < 0) {
-		error_msg_and_die("/dev/tty");
+		bb_error_msg_and_die("/dev/tty");
 	};
 
 	if (ioctl(vfd, VT_GETMODE, &vtm) < 0) {
-		error_msg_and_die("/dev/tty");
+		bb_error_msg_and_die("/dev/tty");
 	};
 
 	/* mask a bunch of signals */
diff --git a/miscutils/adjtimex.c b/miscutils/adjtimex.c
index 848f7340e..d541848f0 100644
--- a/miscutils/adjtimex.c
+++ b/miscutils/adjtimex.c
@@ -87,7 +87,7 @@ void usage(char *prog)
 		"Usage: %s [ -q ] [ -o offset ] [ -f frequency ] [ -p timeconstant ] [ -t tick ]\n",
 		prog);
 }
-#define show_usage() usage(argv[0])
+#define bb_show_usage() usage(argv[0])
 #endif
 
 int main(int argc, char ** argv)
@@ -121,12 +121,12 @@ int main(int argc, char ** argv)
 				txc.modes |= ADJ_TICK;
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 				exit(1);
 		}
 	}
 	if (argc != optind) { /* no valid non-option parameters */
-		show_usage();
+		bb_show_usage();
 		exit(1);
 	}
 
diff --git a/miscutils/crond.c b/miscutils/crond.c
index 8ae54a536..cbb4ffc58 100644
--- a/miscutils/crond.c
+++ b/miscutils/crond.c
@@ -154,7 +154,7 @@ crond_main(int ac, char **av)
 		if (*optarg != 0) CDir = optarg;
 		break;
 	    default: /*  parse error */
-		show_usage();
+		bb_show_usage();
 	}
     }
 
@@ -163,7 +163,7 @@ crond_main(int ac, char **av)
      */
 
     if (chdir(CDir) != 0)
-	perror_msg_and_die("chdir");
+	bb_perror_msg_and_die("chdir");
 
     /*
      * close stdin and stdout, stderr.
@@ -173,7 +173,7 @@ crond_main(int ac, char **av)
 
     if (ForegroundOpt == 0) {
 	if(daemon(1, 0) < 0)
-		perror_msg_and_die("daemon");
+		bb_perror_msg_and_die("daemon");
     }
 
     (void)startlogger();                /* need if syslog mode selected */
@@ -268,7 +268,7 @@ vlog(int level, int MLOG_LEVEL, const char *ctl, va_list va)
 		    close(logfd);
 		 } else
 #ifdef FEATURE_DEBUG_OPT
-		    perror_msg("Can't open log file")
+		    bb_perror_msg("Can't open log file")
 #endif
 							;
 	    }
@@ -385,7 +385,7 @@ startlogger(void)
     int  logfd;
 
     if (LoggerOpt == 0)
-	openlog(applet_name, LOG_CONS|LOG_PID,LOG_CRON);
+	openlog(bb_applet_name, LOG_CONS|LOG_PID,LOG_CRON);
 
     else { /* test logfile */
 	if ((logfd = open(LogFile,O_WRONLY|O_CREAT|O_APPEND,600)) >= 0)
diff --git a/miscutils/crontab.c b/miscutils/crontab.c
index 5bd7db6e5..c6c33ace9 100644
--- a/miscutils/crontab.c
+++ b/miscutils/crontab.c
@@ -61,7 +61,7 @@ crontab_main(int ac, char **av)
 
     UserId = getuid();
     if ((pas = getpwuid(UserId)) == NULL)
-	perror_msg_and_die("getpwuid");
+	bb_perror_msg_and_die("getpwuid");
 
     strncpy(caller, pas->pw_name, sizeof(caller));
 
@@ -105,10 +105,10 @@ crontab_main(int ac, char **av)
 		    if (pas) {
 			UserId = pas->pw_uid;
 		    } else {
-			error_msg_and_die("user %s unknown", av[i]);
+			bb_error_msg_and_die("user %s unknown", av[i]);
 		    }
 		} else {
-		    error_msg_and_die("only the superuser may specify a user");
+		    bb_error_msg_and_die("only the superuser may specify a user");
 		}
 	    }
 	    break;
@@ -116,7 +116,7 @@ crontab_main(int ac, char **av)
 	    if (getuid() == geteuid()) {
 		CDir = (*ptr) ? ptr : av[++i];
 	    } else {
-		error_msg_and_die("-c option: superuser only");
+		bb_error_msg_and_die("-c option: superuser only");
 	    }
 	    break;
 	default:
@@ -125,14 +125,14 @@ crontab_main(int ac, char **av)
 	}
     }
     if (i != ac || option == NONE)
-	show_usage();
+	bb_show_usage();
 
     /*
      * Get password entry
      */
 
     if ((pas = getpwuid(UserId)) == NULL)
-	perror_msg_and_die("getpwuid");
+	bb_perror_msg_and_die("getpwuid");
 
     /*
      * If there is a replacement file, obtain a secure descriptor to it.
@@ -141,7 +141,7 @@ crontab_main(int ac, char **av)
     if (repFile) {
 	repFd = GetReplaceStream(caller, repFile);
 	if (repFd < 0)
-	    error_msg_and_die("unable to read replacement file");
+	    bb_error_msg_and_die("unable to read replacement file");
     }
 
     /*
@@ -149,7 +149,7 @@ crontab_main(int ac, char **av)
      */
 
     if (chdir(CDir) < 0)
-	perror_msg_and_die("cannot change dir to %s", CDir);
+	bb_perror_msg_and_die("cannot change dir to %s", CDir);
 
     /*
      * Handle options as appropriate
@@ -166,7 +166,7 @@ crontab_main(int ac, char **av)
 		    fputs(buf, stdout);
 		fclose(fi);
 	    } else {
-		error_msg("no crontab for %s", pas->pw_name);
+		bb_error_msg("no crontab for %s", pas->pw_name);
 	    }
 	}
 	break;
@@ -190,7 +190,7 @@ crontab_main(int ac, char **av)
 		lseek(fd, 0L, 0);
 		repFd = fd;
 	    } else {
-		error_msg_and_die("unable to create %s", tmp);
+		bb_error_msg_and_die("unable to create %s", tmp);
 	    }
 
 	}
@@ -211,7 +211,7 @@ crontab_main(int ac, char **av)
 		close(fd);
 		rename(path, pas->pw_name);
 	    } else {
-		error_msg("unable to create %s/%s", CDir, path);
+		bb_error_msg("unable to create %s/%s", CDir, path);
 	    }
 	    close(repFd);
 	}
@@ -244,7 +244,7 @@ crontab_main(int ac, char **av)
 	    /* loop */
 	}
 	if (fo == NULL) {
-	    error_msg("unable to append to %s/%s", CDir, CRONUPDATE);
+	    bb_error_msg("unable to append to %s/%s", CDir, CRONUPDATE);
 	}
     }
     return 0;
@@ -291,7 +291,7 @@ GetReplaceStream(const char *user, const char *file)
 
     fd = open(file, O_RDONLY);
     if (fd < 0) {
-	error_msg("unable to open %s", file);
+	bb_error_msg("unable to open %s", file);
 	exit(0);
     }
     buf[0] = 0;
@@ -328,7 +328,7 @@ EditFile(const char *user, const char *file)
 	/*
 	 * PARENT - failure
 	 */
-	perror_msg_and_die("fork");
+	bb_perror_msg_and_die("fork");
     }
     wait4(pid, NULL, 0, NULL);
 }
diff --git a/miscutils/dc.c b/miscutils/dc.c
index c7b43ea0a..5e367fe68 100644
--- a/miscutils/dc.c
+++ b/miscutils/dc.c
@@ -16,14 +16,14 @@ static unsigned char base;
 static void push(double a)
 {
 	if (pointer >= (sizeof(stack) / sizeof(*stack)))
-		error_msg_and_die("stack overflow");
+		bb_error_msg_and_die("stack overflow");
 	stack[pointer++] = a;
 }
 
 static double pop(void)
 {
 	if (pointer == 0)
-		error_msg_and_die("stack underflow");
+		bb_error_msg_and_die("stack underflow");
 	return stack[--pointer];
 }
 
@@ -154,7 +154,7 @@ static void stack_machine(const char *argument)
 		}
 		o++;
 	}
-	error_msg_and_die("%s: syntax error.", argument);
+	bb_error_msg_and_die("%s: syntax error.", argument);
 }
 
 /* return pointer to next token in buffer and set *buffer to one char
@@ -191,7 +191,7 @@ int dc_main(int argc, char **argv)
 		char *line   = NULL;
 		char *cursor = NULL;
 		char *token  = NULL;
-		while ((line = get_line_from_file(stdin))) {
+		while ((line = bb_get_chomped_line_from_file(stdin))) {
 			cursor = line;
 			len = number_of_tokens(line);
 			for (i = 0; i < len; i++) {
@@ -203,7 +203,7 @@ int dc_main(int argc, char **argv)
 		}
 	} else {
 		if (*argv[1]=='-')
-			show_usage();
+			bb_show_usage();
 		while (argc >= 2) {
 			stack_machine(argv[1]);
 			argv++;
diff --git a/miscutils/dutmp.c b/miscutils/dutmp.c
index 19e09fbb0..113f850fe 100644
--- a/miscutils/dutmp.c
+++ b/miscutils/dutmp.c
@@ -8,57 +8,76 @@
  * versions of 'who', 'last', etc. IP Addr is output in hex, 
  * little endian on x86.
  * 
- * Modified to support all sorts of libcs by 
- * Erik Andersen <andersen@lineo.com>
  */
 
-#include <sys/types.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <utmp.h>
+/* Mar 13, 2003       Manuel Novoa III
+ *
+ * 1) Added proper error checking.
+ * 2) Allow '-' arg for stdin.
+ * 3) For modern libcs, take into account that utmp char[] members
+ *    need not be nul-terminated.
+ */
+
 #include <stdlib.h>
 #include <unistd.h>
-#include <time.h>
+#include <fcntl.h>
+#include <utmp.h>
 #include "busybox.h"
 
+/* Grr... utmp char[] members  do not have to be nul-terminated.
+ * Do what we can while still keeping this reasonably small.
+ * Note: We are assuming the ut_id[] size is fixed at 4. */
+
+#if __GNU_LIBRARY__ < 5
+#warning the format string needs to be changed
+#else
+#if (UT_LINESIZE != 32) || (UT_NAMESIZE != 32) || (UT_HOSTSIZE != 256)
+#error struct utmp member char[] size(s) have changed!
+#endif
+#endif
+
 extern int dutmp_main(int argc, char **argv)
 {
-
-	int file;
+	int file = STDIN_FILENO;
+	ssize_t n;
 	struct utmp ut;
 
-	if (argc<2) {
-		file = fileno(stdin);
-	} else if (*argv[1] == '-' ) {
-		show_usage();
-	} else  {
-		file = open(argv[1], O_RDONLY);
-		if (file < 0) {
-			error_msg_and_die(io_error, argv[1]);
-		}
+	if (argc > 2) {
+		bb_show_usage();
+	}
+	++argv;
+	if ((argc == 2) && ((argv[0][0] != '-') || argv[0][1])) {
+		file = bb_xopen(*argv, O_RDONLY);
 	}
 
-/* Kludge around the fact that the binary format for utmp has changed. */
+
+	while ((n = safe_read(file, (void*)&ut, sizeof(struct utmp))) != 0) {
+
+		if (n != sizeof(struct utmp)) {
+			bb_perror_msg_and_die("short read");
+		}
+
+		/* Kludge around the fact that the binary format for utmp has changed. */
 #if __GNU_LIBRARY__ < 5
-	/* Linux libc5 */
-	while (read(file, (void*)&ut, sizeof(struct utmp))) {
-		printf("%d|%d|%s|%s|%s|%s|%s|%lx\n",
-				ut.ut_type, ut.ut_pid, ut.ut_line,
-				ut.ut_id, ut.ut_user, ut.ut_host,
-				ctime(&(ut.ut_time)), 
-				(long)ut.ut_addr);
-	}
+		/* Linux libc5 */
+
+		bb_printf("%d|%d|%s|%s|%s|%s|%s|%lx\n",
+				  ut.ut_type, ut.ut_pid, ut.ut_line,
+				  ut.ut_id, ut.ut_user, ut.ut_host,
+				  ctime(&(ut.ut_time)), 
+				  (long)ut.ut_addr);
 #else
-	/* Glibc, uClibc, etc. */
-	while (read(file, (void*)&ut, sizeof(struct utmp))) {
-		printf("%d|%d|%s|%s|%s|%s|%d|%d|%ld|%ld|%ld|%x\n",
-		ut.ut_type, ut.ut_pid, ut.ut_line,
-		ut.ut_id, ut.ut_user,	ut.ut_host,
-		ut.ut_exit.e_termination, ut.ut_exit.e_exit,
-		ut.ut_session,
-		ut.ut_tv.tv_sec, ut.ut_tv.tv_usec,
-		ut.ut_addr);
-	}
+		/* Glibc, uClibc, etc. */
+
+		bb_printf("%d|%d|%.32s|%.4s|%.32s|%.256s|%d|%d|%ld|%ld|%ld|%x\n",
+				  ut.ut_type, ut.ut_pid, ut.ut_line,
+				  ut.ut_id, ut.ut_user,	ut.ut_host,
+				  ut.ut_exit.e_termination, ut.ut_exit.e_exit,
+				  ut.ut_session,
+				  ut.ut_tv.tv_sec, ut.ut_tv.tv_usec,
+				  ut.ut_addr);
 #endif
-	return EXIT_SUCCESS;
+	}
+
+	bb_fflush_stdout_and_exit(EXIT_SUCCESS);
 }
diff --git a/miscutils/makedevs.c b/miscutils/makedevs.c
index 67b28b534..308d651ae 100644
--- a/miscutils/makedevs.c
+++ b/miscutils/makedevs.c
@@ -22,7 +22,7 @@ int makedevs_main(int argc, char **argv)
 	int major, Sminor, S, E;
 
 	if (argc < 7 || *argv[1]=='-')
-		show_usage();
+		bb_show_usage();
 
 	basedev = argv[1];
 	type = argv[2];
@@ -45,7 +45,7 @@ int makedevs_main(int argc, char **argv)
 		mode |= S_IFIFO;
 		break;
 	default:
-		show_usage();
+		bb_show_usage();
 	}
 
 	while (S <= E) {
@@ -53,12 +53,12 @@ int makedevs_main(int argc, char **argv)
 
 		sz = snprintf(buf, sizeof(buf), "%s%d", basedev, S);
 		if(sz<0 || sz>=sizeof(buf))  /* libc different */
-			error_msg_and_die("%s too large", basedev);
+			bb_error_msg_and_die("%s too large", basedev);
 
 	/* if mode != S_IFCHR and != S_IFBLK third param in mknod() ignored */
 
 		if (mknod(nodname, mode, major | Sminor))
-			error_msg("Failed to create: %s", nodname);
+			bb_error_msg("Failed to create: %s", nodname);
 
 		if (nodname == basedev) /* ex. /dev/hda - to /dev/hda1 ... */
 			nodname = buf;
diff --git a/miscutils/mt.c b/miscutils/mt.c
index 49dc70ac6..e79954552 100644
--- a/miscutils/mt.c
+++ b/miscutils/mt.c
@@ -59,12 +59,12 @@ extern int mt_main(int argc, char **argv)
 	int fd, mode;
 	
 	if (argc < 2) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	if (strcmp(argv[1], "-f") == 0) {
 		if (argc < 4) {
-			show_usage();
+			bb_show_usage();
 		}
 		file = argv[2];
 		argv += 2;
@@ -78,7 +78,7 @@ extern int mt_main(int argc, char **argv)
 	}
 
 	if (code->name == 0) {
-		error_msg("unrecognized opcode %s.", argv[1]);
+		bb_error_msg("unrecognized opcode %s.", argv[1]);
 		return EXIT_FAILURE;
 	}
 
@@ -102,18 +102,18 @@ extern int mt_main(int argc, char **argv)
 	}
 
 	if ((fd = open(file, mode, 0)) < 0)
-		perror_msg_and_die("%s", file);
+		bb_perror_msg_and_die("%s", file);
 
 	switch (code->value) {
 		case MTTELL:
 			if (ioctl(fd, MTIOCPOS, &position) < 0)
-				perror_msg_and_die("%s", file);
+				bb_perror_msg_and_die("%s", file);
 			printf ("At block %d.\n", (int) position.mt_blkno);
 			break;
 
 		default:
 			if (ioctl(fd, MTIOCTOP, &op) != 0)
-				perror_msg_and_die("%s", file);
+				bb_perror_msg_and_die("%s", file);
 			break;
 	}
 
diff --git a/miscutils/strings.c b/miscutils/strings.c
index 8d08b3f23..2413c3f2d 100644
--- a/miscutils/strings.c
+++ b/miscutils/strings.c
@@ -57,7 +57,7 @@ int strings_main(int argc, char **argv)
 				n = bb_xgetlarg(optarg, 10, 1, LONG_MAX);
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 
 	argc -= optind;
@@ -118,7 +118,7 @@ pipe:
 		}
 		else
 		{
-			perror_msg("%s",argv[a]);
+			bb_perror_msg("%s",argv[a]);
 			status=EXIT_FAILURE;
 		}
 	}
diff --git a/miscutils/time.c b/miscutils/time.c
index fa352a899..c30ef4311 100644
--- a/miscutils/time.c
+++ b/miscutils/time.c
@@ -141,7 +141,7 @@ static void fprintargv (FILE *fp, char *const *argv, const char *filler)
 	fputs (*av, fp);
     }
     if (ferror (fp))
-	error_msg_and_die("write error");
+	bb_error_msg_and_die("write error");
 }
 
 /* Return the number of kilobytes corresponding to a number of pages PAGES.
@@ -416,12 +416,12 @@ static void summarize (FILE *fp, const char *fmt, char **command, resource_t *re
 	}
 
 	if (ferror (fp))
-	    error_msg_and_die("write error");
+	    bb_error_msg_and_die("write error");
     }
     putc ('\n', fp);
 
     if (ferror (fp))
-	error_msg_and_die("write error");
+	bb_error_msg_and_die("write error");
 }
 
 /* Run command CMD and return statistics on it.
@@ -434,13 +434,13 @@ static void run_command (char *const *cmd, resource_t *resp)
     gettimeofday (&resp->start, (struct timezone *) 0);
     pid = fork ();		/* Run CMD as child process.  */
     if (pid < 0)
-	error_msg_and_die("cannot fork");
+	bb_error_msg_and_die("cannot fork");
     else if (pid == 0)
     {				/* If child.  */
 	/* Don't cast execvp arguments; that causes errors on some systems,
 	   versus merely warnings if the cast is left off.  */
 	execvp (cmd[0], cmd);
-	error_msg("cannot run %s", cmd[0]);
+	bb_error_msg("cannot run %s", cmd[0]);
 	_exit (errno == ENOENT ? 127 : 126);
     }
 
@@ -449,7 +449,7 @@ static void run_command (char *const *cmd, resource_t *resp)
     quit_signal = signal (SIGQUIT, SIG_IGN);
 
     if (resuse_end (pid, resp) == 0)
-	error_msg("error waiting for child process");
+	bb_error_msg("error waiting for child process");
 
     /* Re-enable signals.  */
     signal (SIGINT, interrupt_signal);
@@ -477,7 +477,7 @@ extern int time_main (int argc, char **argv)
 		    output_format = posix_format;
 		    break;
 		default:
-		    show_usage();
+		    bb_show_usage();
 	    }
 	    argc--;
 	    argv++;
@@ -486,7 +486,7 @@ extern int time_main (int argc, char **argv)
     }
 
     if (argv == NULL || *argv == NULL)
-	show_usage();
+	bb_show_usage();
 
     run_command (argv, &res);
     summarize (stdout, output_format, argv, &res);
diff --git a/miscutils/update.c b/miscutils/update.c
index 27a04ddee..48ea02deb 100644
--- a/miscutils/update.c
+++ b/miscutils/update.c
@@ -62,12 +62,12 @@ extern int update_main(int argc, char **argv)
 				flush_duration = atoi(optarg);
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 	
 	if (daemon(0, 1) < 0)
-		perror_msg_and_die("daemon");
+		bb_perror_msg_and_die("daemon");
 
 #ifdef OPEN_MAX
 	for (pid = 0; pid < OPEN_MAX; pid++) close(pid);
diff --git a/miscutils/watchdog.c b/miscutils/watchdog.c
index f0b0ebd0e..cfe19abc3 100644
--- a/miscutils/watchdog.c
+++ b/miscutils/watchdog.c
@@ -33,11 +33,11 @@ extern int watchdog_main(int argc, char **argv)
 	int fd;
 
 	if (argc != 2) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	if ((fd=open(argv[1], O_WRONLY)) == -1) {
-		perror_msg_and_die(argv[1]);
+		bb_perror_msg_and_die(argv[1]);
 	}
 
 	while (1) {
diff --git a/modutils/insmod.c b/modutils/insmod.c
index 56e78e833..b45357a69 100644
--- a/modutils/insmod.c
+++ b/modutils/insmod.c
@@ -247,7 +247,7 @@
 #ifndef MODUTILS_MODULE_H
 static const int MODUTILS_MODULE_H = 1;
 
-#ident "$Id: insmod.c,v 1.96 2003/03/13 18:57:08 andersen Exp $"
+#ident "$Id: insmod.c,v 1.97 2003/03/19 09:12:33 mjn3 Exp $"
 
 /* This file contains the structures used by the 2.0 and 2.1 kernels.
    We do not use the kernel headers directly because we do not wish
@@ -468,7 +468,7 @@ int delete_module(const char *);
 #ifndef MODUTILS_OBJ_H
 static const int MODUTILS_OBJ_H = 1;
 
-#ident "$Id: insmod.c,v 1.96 2003/03/13 18:57:08 andersen Exp $"
+#ident "$Id: insmod.c,v 1.97 2003/03/19 09:12:33 mjn3 Exp $"
 
 /* The relocatable object is manipulated using elfin types.  */
 
@@ -769,12 +769,12 @@ static int check_module_name_match(const char *filename, struct stat *statbuf,
 	if (fullname[0] == '\0')
 		return (FALSE);
 	else {
-		char *tmp, *tmp1 = xstrdup(filename);
-		tmp = get_last_path_component(tmp1);
+		char *tmp, *tmp1 = bb_xstrdup(filename);
+		tmp = bb_get_last_path_component(tmp1);
 		if (strcmp(tmp, fullname) == 0) {
 			free(tmp1);
 			/* Stop searching if we find a match */
-			m_filename = xstrdup(filename);
+			m_filename = bb_xstrdup(filename);
 			return (TRUE);
 		}
 		free(tmp1);
@@ -1700,7 +1700,7 @@ obj_add_symbol(struct obj_file *f, const char *name,
 				/* Don't report an error if the symbol is coming from
 				   the kernel or some external module.  */
 				if (secidx <= SHN_HIRESERVE)
-					error_msg("%s multiply defined", name);
+					bb_error_msg("%s multiply defined", name);
 				return sym;
 			}
 		}
@@ -1713,7 +1713,7 @@ obj_add_symbol(struct obj_file *f, const char *name,
 
 	if (ELFW(ST_BIND)(info) == STB_LOCAL && symidx != -1) {
 		if (symidx >= f->local_symtab_size)
-			error_msg("local symbol %s with index %ld exceeds local_symtab_size %ld",
+			bb_error_msg("local symbol %s with index %ld exceeds local_symtab_size %ld",
 					name, (long) symidx, (long) f->local_symtab_size);
 		else
 			f->local_symtab[symidx] = sym;
@@ -1996,7 +1996,7 @@ old_process_module_arguments(struct obj_file *f, int argc, char **argv)
 
 		/* Also check that the parameter was not resolved from the kernel.  */
 		if (sym == NULL || sym->secidx > SHN_HIRESERVE) {
-			error_msg("symbol for parameter %s not found", p);
+			bb_error_msg("symbol for parameter %s not found", p);
 			return 0;
 		}
 
@@ -2009,7 +2009,7 @@ old_process_module_arguments(struct obj_file *f, int argc, char **argv)
 			str = alloca(strlen(q));
 			for (r = str, q++; *q != '"'; ++q, ++r) {
 				if (*q == '\0') {
-					error_msg("improperly terminated string argument for %s", p);
+					bb_error_msg("improperly terminated string argument for %s", p);
 					return 0;
 				} else if (*q == '\\')
 					switch (*++q) {
@@ -2139,9 +2139,9 @@ static int old_get_kernel_symbols(const char *m_name)
 	nks = get_kernel_syms(NULL);
 	if (nks <= 0) {
 		if (nks)
-			perror_msg("get_kernel_syms: %s", m_name);
+			bb_perror_msg("get_kernel_syms: %s", m_name);
 		else
-			error_msg("No kernel symbols");
+			bb_error_msg("No kernel symbols");
 		return 0;
 	}
 
@@ -2322,7 +2322,7 @@ old_init_module(const char *m_name, struct obj_file *f,
 							  m_size | (flag_autoclean ? OLD_MOD_AUTOCLEAN
 										: 0), &routines, symtab);
 	if (ret)
-		perror_msg("init_module: %s", m_name);
+		bb_perror_msg("init_module: %s", m_name);
 
 	free(image);
 	free(symtab);
@@ -2365,7 +2365,7 @@ new_process_module_arguments(struct obj_file *f, int argc, char **argv)
 		p = get_modinfo_value(f, key);
 		key += 5;
 		if (p == NULL) {
-			error_msg("invalid parameter %s", key);
+			bb_error_msg("invalid parameter %s", key);
 			return 0;
 		}
 
@@ -2380,7 +2380,7 @@ new_process_module_arguments(struct obj_file *f, int argc, char **argv)
 
 		/* Also check that the parameter was not resolved from the kernel.  */
 		if (sym == NULL || sym->secidx > SHN_HIRESERVE) {
-			error_msg("symbol for parameter %s not found", key);
+			bb_error_msg("symbol for parameter %s not found", key);
 			return 0;
 		}
 
@@ -2408,7 +2408,7 @@ new_process_module_arguments(struct obj_file *f, int argc, char **argv)
 					str = alloca(strlen(q));
 					for (r = str, q++; *q != '"'; ++q, ++r) {
 						if (*q == '\0') {
-							error_msg("improperly terminated string argument for %s",
+							bb_error_msg("improperly terminated string argument for %s",
 									key);
 							return 0;
 						} else if (*q == '\\')
@@ -2502,7 +2502,7 @@ new_process_module_arguments(struct obj_file *f, int argc, char **argv)
 					/* Get the size of each member */
 					/* Probably we should do that outside the loop ? */
 					if (!isdigit(*(p + 1))) {
-						error_msg("parameter type 'c' for %s must be followed by"
+						bb_error_msg("parameter type 'c' for %s must be followed by"
 								" the maximum size", key);
 						return 0;
 					}
@@ -2510,7 +2510,7 @@ new_process_module_arguments(struct obj_file *f, int argc, char **argv)
 
 					/* Check length */
 					if (strlen(str) >= charssize) {
-						error_msg("string too long for %s (max %ld)", key,
+						bb_error_msg("string too long for %s (max %ld)", key,
 								charssize - 1);
 						return 0;
 					}
@@ -2539,7 +2539,7 @@ new_process_module_arguments(struct obj_file *f, int argc, char **argv)
 					break;
 
 				default:
-					error_msg("unknown parameter type '%c' for %s", *p, key);
+					bb_error_msg("unknown parameter type '%c' for %s", *p, key);
 					return 0;
 				}
 			}
@@ -2558,21 +2558,21 @@ new_process_module_arguments(struct obj_file *f, int argc, char **argv)
 
 			case ',':
 				if (++n > max) {
-					error_msg("too many values for %s (max %d)", key, max);
+					bb_error_msg("too many values for %s (max %d)", key, max);
 					return 0;
 				}
 				++q;
 				break;
 
 			default:
-				error_msg("invalid argument syntax for %s", key);
+				bb_error_msg("invalid argument syntax for %s", key);
 				return 0;
 			}
 		}
 
 	  end_of_arg:
 		if (n < min) {
-			error_msg("too few values for %s (min %d)", key, min);
+			bb_error_msg("too few values for %s (min %d)", key, min);
 			return 0;
 		}
 
@@ -2641,7 +2641,7 @@ static int new_get_kernel_symbols(void)
 			module_names = xrealloc(module_names, bufsize = ret);
 			goto retry_modules_load;
 		}
-		perror_msg("QM_MODULES");
+		bb_perror_msg("QM_MODULES");
 		return 0;
 	}
 
@@ -2661,7 +2661,7 @@ static int new_get_kernel_symbols(void)
 					/* The module was removed out from underneath us.  */
 					continue;
 				}
-				perror_msg("query_module: QM_INFO: %s", mn);
+				bb_perror_msg("query_module: QM_INFO: %s", mn);
 				return 0;
 			}
 	
@@ -2676,7 +2676,7 @@ static int new_get_kernel_symbols(void)
 					/* The module was removed out from underneath us.  */
 					continue;
 				default:
-					perror_msg("query_module: QM_SYMBOLS: %s", mn);
+					bb_perror_msg("query_module: QM_SYMBOLS: %s", mn);
 					return 0;
 				}
 			}
@@ -2702,7 +2702,7 @@ static int new_get_kernel_symbols(void)
 			syms = xrealloc(syms, bufsize = ret);
 			goto retry_kern_sym_load;
 		}
-		perror_msg("kernel: QM_SYMBOLS");
+		bb_perror_msg("kernel: QM_SYMBOLS");
 		return 0;
 	}
 	nksyms = nsyms = ret;
@@ -2863,7 +2863,7 @@ new_init_module(const char *m_name, struct obj_file *f,
 
 	sec = obj_find_section(f, ".this");
 	if (!sec || !sec->contents) { 
-		perror_msg_and_die("corrupt module %s?",m_name);
+		bb_perror_msg_and_die("corrupt module %s?",m_name);
 	}
 	module = (struct new_module *) sec->contents;
 	m_addr = sec->header.sh_addr;
@@ -2927,7 +2927,7 @@ new_init_module(const char *m_name, struct obj_file *f,
 
 	ret = new_sys_init_module(m_name, (struct new_module *) image);
 	if (ret)
-		perror_msg("init_module: %s", m_name);
+		bb_perror_msg("init_module: %s", m_name);
 
 	free(image);
 
@@ -3008,7 +3008,7 @@ static int obj_check_undefineds(struct obj_file *f)
 					sym->value = 0;
 				} else {
 					if (!flag_quiet) {
-						error_msg("unresolved symbol %s", sym->name);
+						bb_error_msg("unresolved symbol %s", sym->name);
 					}
 					ret = 0;
 				}
@@ -3236,11 +3236,11 @@ static int obj_relocate(struct obj_file *f, ElfW(Addr) base)
 				errmsg = "Unhandled relocation";
 			  bad_reloc:
 				if (extsym) {
-					error_msg("%s of type %ld for %s", errmsg,
+					bb_error_msg("%s of type %ld for %s", errmsg,
 							(long) ELFW(R_TYPE) (rel->r_info),
 							strtab + extsym->st_name);
 				} else {
-					error_msg("%s of type %ld", errmsg,
+					bb_error_msg("%s of type %ld", errmsg,
 							(long) ELFW(R_TYPE) (rel->r_info));
 				}
 				ret = 0;
@@ -3317,7 +3317,7 @@ static struct obj_file *obj_load(FILE * fp, int loadprogbits)
 
 	fseek(fp, 0, SEEK_SET);
 	if (fread(&f->header, sizeof(f->header), 1, fp) != 1) {
-		perror_msg("error reading ELF header");
+		bb_perror_msg("error reading ELF header");
 		return NULL;
 	}
 
@@ -3325,25 +3325,25 @@ static struct obj_file *obj_load(FILE * fp, int loadprogbits)
 		|| f->header.e_ident[EI_MAG1] != ELFMAG1
 		|| f->header.e_ident[EI_MAG2] != ELFMAG2
 		|| f->header.e_ident[EI_MAG3] != ELFMAG3) {
-		error_msg("not an ELF file");
+		bb_error_msg("not an ELF file");
 		return NULL;
 	}
 	if (f->header.e_ident[EI_CLASS] != ELFCLASSM
 		|| f->header.e_ident[EI_DATA] != ELFDATAM
 		|| f->header.e_ident[EI_VERSION] != EV_CURRENT
 		|| !MATCH_MACHINE(f->header.e_machine)) {
-		error_msg("ELF file not for this architecture");
+		bb_error_msg("ELF file not for this architecture");
 		return NULL;
 	}
 	if (f->header.e_type != ET_REL) {
-		error_msg("ELF file not a relocatable object");
+		bb_error_msg("ELF file not a relocatable object");
 		return NULL;
 	}
 
 	/* Read the section headers.  */
 
 	if (f->header.e_shentsize != sizeof(ElfW(Shdr))) {
-		error_msg("section header size mismatch: %lu != %lu",
+		bb_error_msg("section header size mismatch: %lu != %lu",
 				(unsigned long) f->header.e_shentsize,
 				(unsigned long) sizeof(ElfW(Shdr)));
 		return NULL;
@@ -3356,7 +3356,7 @@ static struct obj_file *obj_load(FILE * fp, int loadprogbits)
 	section_headers = alloca(sizeof(ElfW(Shdr)) * shnum);
 	fseek(fp, f->header.e_shoff, SEEK_SET);
 	if (fread(section_headers, sizeof(ElfW(Shdr)), shnum, fp) != shnum) {
-		perror_msg("error reading ELF section headers");
+		bb_perror_msg("error reading ELF section headers");
 		return NULL;
 	}
 
@@ -3392,7 +3392,7 @@ static struct obj_file *obj_load(FILE * fp, int loadprogbits)
 				sec->contents = xmalloc(sec->header.sh_size);
 				fseek(fp, sec->header.sh_offset, SEEK_SET);
 				if (fread(sec->contents, sec->header.sh_size, 1, fp) != 1) {
-					perror_msg("error reading ELF section data");
+					bb_perror_msg("error reading ELF section data");
 					return NULL;
 				}
 			} else {
@@ -3402,11 +3402,11 @@ static struct obj_file *obj_load(FILE * fp, int loadprogbits)
 
 #if SHT_RELM == SHT_REL
 		case SHT_RELA:
-			error_msg("RELA relocations not supported on this architecture");
+			bb_error_msg("RELA relocations not supported on this architecture");
 			return NULL;
 #else
 		case SHT_REL:
-			error_msg("REL relocations not supported on this architecture");
+			bb_error_msg("REL relocations not supported on this architecture");
 			return NULL;
 #endif
 
@@ -3419,7 +3419,7 @@ static struct obj_file *obj_load(FILE * fp, int loadprogbits)
 				break;
 			}
 
-			error_msg("can't handle sections of type %ld",
+			bb_error_msg("can't handle sections of type %ld",
 					(long) sec->header.sh_type);
 			return NULL;
 		}
@@ -3454,7 +3454,7 @@ static struct obj_file *obj_load(FILE * fp, int loadprogbits)
 				ElfW(Sym) * sym;
 
 				if (sec->header.sh_entsize != sizeof(ElfW(Sym))) {
-					error_msg("symbol size mismatch: %lu != %lu",
+					bb_error_msg("symbol size mismatch: %lu != %lu",
 							(unsigned long) sec->header.sh_entsize,
 							(unsigned long) sizeof(ElfW(Sym)));
 					return NULL;
@@ -3484,7 +3484,7 @@ static struct obj_file *obj_load(FILE * fp, int loadprogbits)
 
 		case SHT_RELM:
 			if (sec->header.sh_entsize != sizeof(ElfW(RelM))) {
-				error_msg("relocation entry size mismatch: %lu != %lu",
+				bb_error_msg("relocation entry size mismatch: %lu != %lu",
 						(unsigned long) sec->header.sh_entsize,
 						(unsigned long) sizeof(ElfW(RelM)));
 				return NULL;
@@ -3523,7 +3523,7 @@ static int obj_load_progbits(FILE * fp, struct obj_file* f, char* imagebase)
 		sec->contents = imagebase + (sec->header.sh_addr - base);
 		fseek(fp, sec->header.sh_offset, SEEK_SET);
 		if (fread(sec->contents, sec->header.sh_size, 1, fp) != 1) {
-			error_msg("error reading ELF section data: %s\n", strerror(errno));
+			bb_error_msg("error reading ELF section data: %s\n", strerror(errno));
 			return 0;
 		}
 
@@ -3710,14 +3710,14 @@ add_ksymoops_symbols(struct obj_file *f, const char *filename,
 	};
 
 	if (realpath(filename, real)) {
-		absolute_filename = xstrdup(real);
+		absolute_filename = bb_xstrdup(real);
 	}
 	else {
 		int save_errno = errno;
-		error_msg("cannot get realpath for %s", filename);
+		bb_error_msg("cannot get realpath for %s", filename);
 		errno = save_errno;
 		perror("");
-		absolute_filename = xstrdup(filename);
+		absolute_filename = bb_xstrdup(filename);
 	}
 
 	lm_name = strlen(m_name);
@@ -3953,7 +3953,7 @@ extern int insmod_main( int argc, char **argv)
 				break;
 			case 'o':			/* name the output module */
 				free(m_name);
-				m_name = xstrdup(optarg);
+				m_name = bb_xstrdup(optarg);
 				break;
 			case 'L':			/* Stub warning */
 				/* This is needed for compatibility with modprobe.
@@ -3967,16 +3967,16 @@ extern int insmod_main( int argc, char **argv)
 				break;
 #endif
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 	
 	if (argv[optind] == NULL) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	/* Grab the module name */
-	tmp1 = xstrdup(argv[optind]);
+	tmp1 = bb_xstrdup(argv[optind]);
 	tmp = basename(tmp1);
 	len = strlen(tmp);
 
@@ -3985,7 +3985,7 @@ extern int insmod_main( int argc, char **argv)
 		tmp[len] = '\0';
 	}
 
-	bb_asprintf(&m_fullName, "%s.o", tmp);
+	bb_xasprintf(&m_fullName, "%s.o", tmp);
 
 	if (!m_name) {
 		m_name = tmp;
@@ -4038,19 +4038,19 @@ extern int insmod_main( int argc, char **argv)
 				if (m_filename == 0
 						|| ((fp = fopen(m_filename, "r")) == NULL)) 
 				{
-					error_msg("%s: no module by that name found", m_fullName);
+					bb_error_msg("%s: no module by that name found", m_fullName);
 					goto out;
 				}
 			} else
-				error_msg_and_die("%s: no module by that name found", m_fullName);
+				bb_error_msg_and_die("%s: no module by that name found", m_fullName);
 		}
 	} else 
-		m_filename = xstrdup(argv[optind]);
+		m_filename = bb_xstrdup(argv[optind]);
 
 	printf("Using %s\n", m_filename);
 
 	if ((f = obj_load(fp, LOADBITS)) == NULL)
-		perror_msg_and_die("Could not load the module");
+		bb_perror_msg_and_die("Could not load the module");
 
 	if (get_modinfo_value(f, "kernel_version") == NULL)
 		m_has_modinfo = 0;
@@ -4067,7 +4067,7 @@ extern int insmod_main( int argc, char **argv)
 		} else {
 			m_version = old_get_module_version(f, m_strversion);
 			if (m_version == -1) {
-				error_msg("couldn't find the kernel version the module was "
+				bb_error_msg("couldn't find the kernel version the module was "
 						"compiled for");
 				goto out;
 			}
@@ -4075,12 +4075,12 @@ extern int insmod_main( int argc, char **argv)
 
 		if (strncmp(uts_info.release, m_strversion, STRVERSIONLEN) != 0) {
 			if (flag_force_load) {
-				error_msg("Warning: kernel-module version mismatch\n"
+				bb_error_msg("Warning: kernel-module version mismatch\n"
 						"\t%s was compiled for kernel version %s\n"
 						"\twhile this kernel is version %s",
 						m_filename, m_strversion, uts_info.release);
 			} else {
-				error_msg("kernel-module version mismatch\n"
+				bb_error_msg("kernel-module version mismatch\n"
 						"\t%s was compiled for kernel version %s\n"
 						"\twhile this kernel is version %s.",
 						m_filename, m_strversion, uts_info.release);
@@ -4099,7 +4099,7 @@ extern int insmod_main( int argc, char **argv)
 			goto out;
 		k_crcs = new_is_kernel_checksummed();
 #else
-		error_msg("Not configured to support new kernels");
+		bb_error_msg("Not configured to support new kernels");
 		goto out;
 #endif
 	} else {
@@ -4108,7 +4108,7 @@ extern int insmod_main( int argc, char **argv)
 			goto out;
 		k_crcs = old_is_kernel_checksummed();
 #else
-		error_msg("Not configured to support old kernels");
+		bb_error_msg("Not configured to support old kernels");
 		goto out;
 #endif
 	}
@@ -4170,14 +4170,14 @@ extern int insmod_main( int argc, char **argv)
 	m_addr = create_module(m_name, m_size);
 	if (m_addr == -1) switch (errno) {
 	case EEXIST:
-		error_msg("A module named %s already exists", m_name);
+		bb_error_msg("A module named %s already exists", m_name);
 		goto out;
 	case ENOMEM:
-		error_msg("Can't allocate kernel memory for module; needed %lu bytes",
+		bb_error_msg("Can't allocate kernel memory for module; needed %lu bytes",
 				m_size);
 		goto out;
 	default:
-		perror_msg("create_module: %s", m_name);
+		bb_perror_msg("create_module: %s", m_name);
 		goto out;
 	}
 
diff --git a/modutils/lsmod.c b/modutils/lsmod.c
index b87a26a57..bb9947a23 100644
--- a/modutils/lsmod.c
+++ b/modutils/lsmod.c
@@ -108,7 +108,7 @@ extern int lsmod_main(int argc, char **argv)
 	module_names = xmalloc(bufsize = 256);
 	if (my_query_module(NULL, QM_MODULES, (void **)&module_names, &bufsize,
 				&nmod)) {
-		perror_msg_and_die("QM_MODULES");
+		bb_perror_msg_and_die("QM_MODULES");
 	}
 
 	deps = xmalloc(depsize = 256);
@@ -122,14 +122,14 @@ extern int lsmod_main(int argc, char **argv)
 				continue;
 			}
 			/* else choke */
-			perror_msg_and_die("module %s: QM_INFO", mn);
+			bb_perror_msg_and_die("module %s: QM_INFO", mn);
 		}
 		if (my_query_module(mn, QM_REFS, (void **)&deps, &depsize, &count)) {
 			if (errno == ENOENT) {
 				/* The module was removed out from underneath us. */
 				continue;
 			}
-			perror_msg_and_die("module %s: QM_REFS", mn);
+			bb_perror_msg_and_die("module %s: QM_REFS", mn);
 		}
 		printf("%-20s%8lu%4ld", mn, info.size, info.usecount);
 		if (info.flags & NEW_MOD_DELETED)
@@ -167,9 +167,10 @@ extern int lsmod_main(int argc, char **argv)
 	printf("Module                  Size  Used by");
 	check_tainted();
 
-	if(print_file_by_name("/proc/modules") == FALSE)
+	if (bb_xprint_file_by_name("/proc/modules") < 0) {
+		return 0;
+	}
 	return 1;
-	return 0;
 }
 
 #endif /* CONFIG_FEATURE_QUERY_MODULE_INTERFACE */
diff --git a/modutils/modprobe.c b/modutils/modprobe.c
index 99650ff03..154e66224 100644
--- a/modutils/modprobe.c
+++ b/modutils/modprobe.c
@@ -73,7 +73,7 @@ int parse_tag_value ( char *buffer, char **ptag, char **pvalue )
 	*ptag = tag;
 	*pvalue = value;
 	
-	return xstrlen( tag ) && xstrlen( value );
+	return bb_strlen( tag ) && bb_strlen( value );
 }
 
 /* Jump through hoops to simulate how fgets() grabs just one line at a
@@ -119,7 +119,7 @@ static struct dep_t *build_dep ( void )
 		return 0;
 		
 	// check for buffer overflow in following code
-	if ( xstrlen ( un.release ) > ( sizeof( buffer ) - 64 )) {
+	if ( bb_strlen ( un.release ) > ( sizeof( buffer ) - 64 )) {
 		return 0;
 	}
 				
@@ -131,7 +131,7 @@ static struct dep_t *build_dep ( void )
 		return 0;
 
 	while ( reads ( fd, buffer, sizeof( buffer ))) {
-		int l = xstrlen ( buffer );
+		int l = bb_strlen ( buffer );
 		char *p = 0;
 		
 		while ( isspace ( buffer [l-1] )) {
@@ -163,7 +163,7 @@ static struct dep_t *build_dep ( void )
 				if (( *(col-2) == '.' ) && ( *(col-1) == 'o' ))
 					ext = 2;
 				
-				mod = xstrndup ( mods, col - mods - ext );
+				mod = bb_xstrndup ( mods, col - mods - ext );
 					
 				if ( !current ) {
 					first = current = (struct dep_t *) xmalloc ( sizeof ( struct dep_t ));
@@ -216,7 +216,7 @@ static struct dep_t *build_dep ( void )
 			if ((end-deps-ext+1) <= 0)
 				continue;
 			
-			dep = xstrndup ( deps, end - deps - ext + 1 );
+			dep = bb_xstrndup ( deps, end - deps - ext + 1 );
 			
 			current-> m_depcnt++;
 			current-> m_deparr = (char **) xrealloc ( current-> m_deparr, sizeof ( char *) * current-> m_depcnt );
@@ -247,7 +247,7 @@ static struct dep_t *build_dep ( void )
 		if ( p )
 			*p = 0;
 			
-		l = xstrlen ( buffer );
+		l = bb_strlen ( buffer );
 	
 		while ( l && isspace ( buffer [l-1] )) {
 			buffer [l-1] = 0;
@@ -273,7 +273,7 @@ static struct dep_t *build_dep ( void )
 						current-> m_next = (struct dep_t *) xmalloc ( sizeof ( struct dep_t ));
 						current = current-> m_next;
 					}
-					current-> m_module  = xstrdup ( alias );
+					current-> m_module  = bb_xstrdup ( alias );
 					current-> m_isalias = 1;
 					
 					if (( strcmp ( alias, "off" ) == 0 ) || ( strcmp ( alias, "null" ) == 0 )) {
@@ -283,7 +283,7 @@ static struct dep_t *build_dep ( void )
 					else {
 						current-> m_depcnt  = 1;
 						current-> m_deparr  = xmalloc ( 1 * sizeof( char * ));
-						current-> m_deparr[0] = xstrdup ( mod );
+						current-> m_deparr[0] = bb_xstrdup ( mod );
 					}
 					current-> m_next    = 0;					
 				}
@@ -299,7 +299,7 @@ static struct dep_t *build_dep ( void )
 							break;
 					}
 					if ( dt ) {
-						dt-> m_options = xrealloc ( dt-> m_options, xstrlen( opt ) + 1 );
+						dt-> m_options = xrealloc ( dt-> m_options, bb_strlen( opt ) + 1 );
 						strcpy ( dt-> m_options, opt );
 						
 						// fprintf ( stderr, "OPTION: '%s' -> '%s'\n", dt-> m_module, dt-> m_options );
@@ -346,7 +346,7 @@ static void check_dep ( char *mod, struct mod_list_t **head, struct mod_list_t *
 	int lm;
 
 	// remove .o extension
-	lm = xstrlen ( mod );
+	lm = bb_strlen ( mod );
 	if (( mod [lm-2] == '.' ) && ( mod [lm-1] == 'o' ))
 		mod [lm-2] = 0;
 
@@ -441,7 +441,7 @@ static int mod_insert ( char *mod, int argc, char **argv )
 	
 			// append module args
 			for ( i = 0; i < argc; i++ ) 
-				l += ( xstrlen ( argv [i] ) + 1 );
+				l += ( bb_strlen ( argv [i] ) + 1 );
 		
 			head-> m_options = xrealloc ( head-> m_options, l + 1 );
 			head-> m_options [0] = 0;
@@ -494,7 +494,7 @@ extern int modprobe_main(int argc, char** argv)
 			break;
 		case 'C': // no config used
 		case 't': // no pattern matching
-			error_msg_and_die("-t and -C not supported");
+			bb_error_msg_and_die("-t and -C not supported");
 
 		case 'a': // ignore
 		case 'd': // ignore
@@ -519,7 +519,7 @@ extern int modprobe_main(int argc, char** argv)
 			break;
 		case 'V':
 		default:
-			show_usage();
+			bb_show_usage();
 			break;
 		}
 	}
@@ -527,21 +527,21 @@ extern int modprobe_main(int argc, char** argv)
 	depend = build_dep ( );	
 
 	if ( !depend ) 
-		error_msg_and_die ( "could not parse modules.dep\n" );
+		bb_error_msg_and_die ( "could not parse modules.dep\n" );
 	
 	if (remove_opt) {
 		do {
-			mod_remove ( optind < argc ? xstrdup ( argv [optind] ) : NULL );
+			mod_remove ( optind < argc ? bb_xstrdup ( argv [optind] ) : NULL );
 		} while ( ++optind < argc );
 		
 		return EXIT_SUCCESS;
 	}
 
 	if (optind >= argc) 
-		error_msg_and_die ( "No module or pattern provided\n" );
+		bb_error_msg_and_die ( "No module or pattern provided\n" );
 	
-	if ( mod_insert ( xstrdup ( argv [optind] ), argc - optind - 1, argv + optind + 1 )) 
-		error_msg_and_die ( "failed to load module %s", argv [optind] );
+	if ( mod_insert ( bb_xstrdup ( argv [optind] ), argc - optind - 1, argv + optind + 1 )) 
+		bb_error_msg_and_die ( "failed to load module %s", argv [optind] );
 	
 	return EXIT_SUCCESS;
 }
diff --git a/modutils/rmmod.c b/modutils/rmmod.c
index 0103d9145..3154b30cc 100644
--- a/modutils/rmmod.c
+++ b/modutils/rmmod.c
@@ -48,11 +48,11 @@ extern int rmmod_main(int argc, char **argv)
 				buf = xmalloc(bufsize = 256);
 				while (nmod != pnmod) {
 					if (delete_module(NULL))
-						perror_msg_and_die("rmmod");
+						bb_perror_msg_and_die("rmmod");
 					pnmod = nmod;
 					/* 1 == QM_MODULES */
 					if (my_query_module(NULL, 1, &buf, &bufsize, &nmod)) {
-						perror_msg_and_die("QM_MODULES");
+						bb_perror_msg_and_die("QM_MODULES");
 					}
 				}
 #ifdef CONFIG_FEATURE_CLEAN_UP
@@ -60,16 +60,16 @@ extern int rmmod_main(int argc, char **argv)
 #endif
 				return EXIT_SUCCESS;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
 	if (optind == argc)
-			show_usage();
+			bb_show_usage();
 
 	for (n = optind; n < argc; n++) {
 		if (delete_module(argv[n]) < 0) {
-			perror_msg("%s", argv[n]);
+			bb_perror_msg("%s", argv[n]);
 			ret = EXIT_FAILURE;
 		}
 	}
diff --git a/networking/arping.c b/networking/arping.c
index bf0a77cf4..2e1adf0a2 100644
--- a/networking/arping.c
+++ b/networking/arping.c
@@ -302,9 +302,9 @@ int arping_main(int argc, char **argv)
 			break;
 		case 'I':
 			if (optarg == NULL)
-				show_usage();
-			if (xstrlen(optarg) > IF_NAMESIZE) {
-				error_msg("Interface name `%s' must be less than %d", optarg,
+				bb_show_usage();
+			if (bb_strlen(optarg) > IF_NAMESIZE) {
+				bb_error_msg("Interface name `%s' must be less than %d", optarg,
 						  IF_NAMESIZE);
 				exit(2);
 			}
@@ -319,20 +319,20 @@ int arping_main(int argc, char **argv)
 		case 'h':
 		case '?':
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 	argc -= optind;
 	argv += optind;
 
 	if (argc != 1)
-		show_usage();
+		bb_show_usage();
 
 	target = *argv;
 
 
 	if (s < 0) {
-		error_msg("socket");
+		bb_error_msg("socket");
 		exit(socket_errno);
 	}
 
@@ -342,21 +342,21 @@ int arping_main(int argc, char **argv)
 		memset(&ifr, 0, sizeof(ifr));
 		strncpy(ifr.ifr_name, device, IFNAMSIZ - 1);
 		if (ioctl(s, SIOCGIFINDEX, &ifr) < 0) {
-			error_msg("Interface %s not found", device);
+			bb_error_msg("Interface %s not found", device);
 			exit(2);
 		}
 		ifindex = ifr.ifr_ifindex;
 
 		if (ioctl(s, SIOCGIFFLAGS, (char *) &ifr)) {
-			error_msg("SIOCGIFFLAGS");
+			bb_error_msg("SIOCGIFFLAGS");
 			exit(2);
 		}
 		if (!(ifr.ifr_flags & IFF_UP)) {
-			error_msg("Interface %s is down", device);
+			bb_error_msg("Interface %s is down", device);
 			exit(2);
 		}
 		if (ifr.ifr_flags & (IFF_NOARP | IFF_LOOPBACK)) {
-			error_msg("Interface %s is not ARPable", device);
+			bb_error_msg("Interface %s is not ARPable", device);
 			exit(dad ? 0 : 2);
 		}
 	}
@@ -366,14 +366,14 @@ int arping_main(int argc, char **argv)
 
 		hp = gethostbyname2(target, AF_INET);
 		if (!hp) {
-			error_msg("invalid or unknown target %s", target);
+			bb_error_msg("invalid or unknown target %s", target);
 			exit(2);
 		}
 		memcpy(&dst, hp->h_addr, 4);
 	}
 
 	if (source && !inet_aton(source, &src)) {
-		error_msg("invalid source address %s", source);
+		bb_error_msg("invalid source address %s", source);
 		exit(2);
 	}
 
@@ -385,21 +385,21 @@ int arping_main(int argc, char **argv)
 		int probe_fd = socket(AF_INET, SOCK_DGRAM, 0);
 
 		if (probe_fd < 0) {
-			error_msg("socket");
+			bb_error_msg("socket");
 			exit(2);
 		}
 		if (device) {
 			if (setsockopt
 				(probe_fd, SOL_SOCKET, SO_BINDTODEVICE, device,
 				 strlen(device) + 1) == -1)
-				error_msg("WARNING: interface %s is ignored", device);
+				bb_error_msg("WARNING: interface %s is ignored", device);
 		}
 		memset(&saddr, 0, sizeof(saddr));
 		saddr.sin_family = AF_INET;
 		if (src.s_addr) {
 			saddr.sin_addr = src;
 			if (bind(probe_fd, (struct sockaddr *) &saddr, sizeof(saddr)) == -1) {
-				error_msg("bind");
+				bb_error_msg("bind");
 				exit(2);
 			}
 		} else if (!dad) {
@@ -415,12 +415,12 @@ int arping_main(int argc, char **argv)
 				perror("WARNING: setsockopt(SO_DONTROUTE)");
 			if (connect(probe_fd, (struct sockaddr *) &saddr, sizeof(saddr))
 				== -1) {
-				error_msg("connect");
+				bb_error_msg("connect");
 				exit(2);
 			}
 			if (getsockname(probe_fd, (struct sockaddr *) &saddr, &alen) ==
 				-1) {
-				error_msg("getsockname");
+				bb_error_msg("getsockname");
 				exit(2);
 			}
 			src = saddr.sin_addr;
@@ -432,7 +432,7 @@ int arping_main(int argc, char **argv)
 	me.sll_ifindex = ifindex;
 	me.sll_protocol = htons(ETH_P_ARP);
 	if (bind(s, (struct sockaddr *) &me, sizeof(me)) == -1) {
-		error_msg("bind");
+		bb_error_msg("bind");
 		exit(2);
 	}
 
@@ -440,12 +440,12 @@ int arping_main(int argc, char **argv)
 		int alen = sizeof(me);
 
 		if (getsockname(s, (struct sockaddr *) &me, &alen) == -1) {
-			error_msg("getsockname");
+			bb_error_msg("getsockname");
 			exit(2);
 		}
 	}
 	if (me.sll_halen == 0) {
-		error_msg("Interface \"%s\" is not ARPable (no ll address)", device);
+		bb_error_msg("Interface \"%s\" is not ARPable (no ll address)", device);
 		exit(dad ? 0 : 2);
 	}
 	he = me;
@@ -458,7 +458,7 @@ int arping_main(int argc, char **argv)
 	}
 
 	if (!src.s_addr && !dad) {
-		error_msg("no src address in the non-DAD mode");
+		bb_error_msg("no src address in the non-DAD mode");
 		exit(2);
 	}
 
diff --git a/networking/ftpgetput.c b/networking/ftpgetput.c
index 44e91c37a..394389043 100644
--- a/networking/ftpgetput.c
+++ b/networking/ftpgetput.c
@@ -77,7 +77,7 @@ static ftp_host_info_t *ftp_init(void)
 static int ftpcmd(const char *s1, const char *s2, FILE *stream, char *buf)
 {
 	if (verbose_flag) {
-		error_msg("cmd %s%s", s1, s2);
+		bb_error_msg("cmd %s%s", s1, s2);
 	}
 
 	if (s1) {
@@ -90,7 +90,7 @@ static int ftpcmd(const char *s1, const char *s2, FILE *stream, char *buf)
 
 	do {
 		if (fgets(buf, 510, stream) == NULL) {
-			perror_msg_and_die("fgets()");
+			bb_perror_msg_and_die("fgets()");
 		}
 	} while (! isdigit(buf[0]) || buf[3] != ' ');
 
@@ -125,11 +125,11 @@ static FILE *ftp_login(ftp_host_info_t *server)
 	control_fd = xconnect(server->host, server->port);
 	control_stream = fdopen(control_fd, "r+");
 	if (control_stream == NULL) {
-		perror_msg_and_die("Couldnt open control stream");
+		bb_perror_msg_and_die("Couldnt open control stream");
 	}
 
 	if (ftpcmd(NULL, NULL, control_stream, buf) != 220) {
-		error_msg_and_die("%s", buf + 4);
+		bb_error_msg_and_die("%s", buf + 4);
 	}
 
 	/*  Login to the server */
@@ -138,11 +138,11 @@ static FILE *ftp_login(ftp_host_info_t *server)
 		break;
 	case 331:
 		if (ftpcmd("PASS ", server->password, control_stream, buf) != 230) {
-			error_msg_and_die("PASS error: %s", buf + 4);
+			bb_error_msg_and_die("PASS error: %s", buf + 4);
 		}
 		break;
 	default:
-		error_msg_and_die("USER error: %s", buf + 4);
+		bb_error_msg_and_die("USER error: %s", buf + 4);
 	}
 
 	ftpcmd("TYPE I", NULL, control_stream, buf);
@@ -161,12 +161,12 @@ static int ftp_recieve(FILE *control_stream, const char *host, const char *local
 	int fd_local;
 	off_t beg_range = 0;
 
-	filename = get_last_path_component(server_path);
+	filename = bb_get_last_path_component(server_path);
 	local_file = concat_path_file(local_path, filename);
 
 	/* Connect to the data socket */
 	if (ftpcmd("PASV", NULL, control_stream, buf) != 227) {
-		error_msg_and_die("PASV error: %s", buf + 4);
+		bb_error_msg_and_die("PASV error: %s", buf + 4);
 	}
 	fd_data = xconnect_ftpdata(host, buf);
 
@@ -177,7 +177,7 @@ static int ftp_recieve(FILE *control_stream, const char *host, const char *local
 	if (do_continue) {
 		struct stat sbuf;
 		if (lstat(local_file, &sbuf) < 0) {
-			perror_msg_and_die("fstat()");
+			bb_perror_msg_and_die("fstat()");
 		}
 		if (sbuf.st_size > 0) {
 			beg_range = sbuf.st_size;
@@ -196,25 +196,25 @@ static int ftp_recieve(FILE *control_stream, const char *host, const char *local
 	}
 
 	if (ftpcmd("RETR ", server_path, control_stream, buf) > 150) {
-		error_msg_and_die("RETR error: %s", buf + 4);
+		bb_error_msg_and_die("RETR error: %s", buf + 4);
 	}
 
 	/* only make a local file if we know that one exists on the remote server */
 	if (do_continue) {
-		fd_local = xopen(local_file, O_APPEND | O_WRONLY);
+		fd_local = bb_xopen(local_file, O_APPEND | O_WRONLY);
 	} else {
-		fd_local = xopen(local_file, O_CREAT | O_TRUNC | O_WRONLY);
+		fd_local = bb_xopen(local_file, O_CREAT | O_TRUNC | O_WRONLY);
 	}
 
 	/* Copy the file */
-	if (copyfd(fd_data, fd_local, filesize) == -1) {
+	if (bb_copyfd(fd_data, fd_local, filesize) == -1) {
 		exit(EXIT_FAILURE);
 	}
 
 	/* close it all down */
 	close(fd_data);
 	if (ftpcmd(NULL, NULL, control_stream, buf) != 226) {
-		error_msg_and_die("ftp error: %s", buf + 4);
+		bb_error_msg_and_die("ftp error: %s", buf + 4);
 	}
 	ftpcmd("QUIT", NULL, control_stream, buf);
 	
@@ -233,16 +233,16 @@ static int ftp_send(FILE *control_stream, const char *host, const char *server_p
 
 	/*  Connect to the data socket */
 	if (ftpcmd("PASV", NULL, control_stream, buf) != 227) {
-		error_msg_and_die("PASV error: %s", buf + 4);
+		bb_error_msg_and_die("PASV error: %s", buf + 4);
 	}
 	fd_data = xconnect_ftpdata(host, buf);
 
 	if (ftpcmd("CWD ", server_path, control_stream, buf) != 250) {
-		error_msg_and_die("CWD error: %s", buf + 4);
+		bb_error_msg_and_die("CWD error: %s", buf + 4);
 	}
 
 	/* get the local file */
-	fd_local = xopen(local_path, O_RDONLY);
+	fd_local = bb_xopen(local_path, O_RDONLY);
 	fstat(fd_local, &sbuf);
 
 	sprintf(buf, "ALLO %lu", sbuf.st_size);
@@ -253,7 +253,7 @@ static int ftp_send(FILE *control_stream, const char *host, const char *server_p
 		break;
 	default:
 		close(fd_local);
-		error_msg_and_die("ALLO error: %s", buf + 4);
+		bb_error_msg_and_die("ALLO error: %s", buf + 4);
 		break;
 	}
 
@@ -264,18 +264,18 @@ static int ftp_send(FILE *control_stream, const char *host, const char *server_p
 		break;
 	default:
 		close(fd_local);
-		error_msg_and_die("STOR error: %s", buf + 4);
+		bb_error_msg_and_die("STOR error: %s", buf + 4);
 	}
 
 	/* transfer the file  */
-	if (copyfd(fd_local, fd_data, 0) == -1) {
+	if (bb_copyfd(fd_local, fd_data, 0) == -1) {
 		exit(EXIT_FAILURE);
 	}
 
 	/* close it all down */
 	close(fd_data);
 	if (ftpcmd(NULL, NULL, control_stream, buf) != 226) {
-		error_msg_and_die("error: %s", buf + 4);
+		bb_error_msg_and_die("error: %s", buf + 4);
 	}
 	ftpcmd("QUIT", NULL, control_stream, buf);
 
@@ -307,12 +307,12 @@ int ftpgetput_main(int argc, char **argv)
 	};
 
 #ifdef CONFIG_FTPPUT
-	if (applet_name[3] == 'p') {
+	if (bb_applet_name[3] == 'p') {
 		ftp_action = ftp_send;
 	} 
 #endif
 #ifdef CONFIG_FTPGET
-	if (applet_name[3] == 'g') {
+	if (bb_applet_name[3] == 'g') {
 		ftp_action = ftp_recieve;
 	}
 #endif
@@ -342,7 +342,7 @@ int ftpgetput_main(int argc, char **argv)
 			verbose_flag = 1;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
@@ -350,7 +350,7 @@ int ftpgetput_main(int argc, char **argv)
 	 * Process the non-option command line arguments
 	 */
 	if (argc - optind != 3) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	/*  Connect/Setup/Configure the FTP session */
diff --git a/networking/hostname.c b/networking/hostname.c
index f7c9fc426..6522bb21b 100644
--- a/networking/hostname.c
+++ b/networking/hostname.c
@@ -1,6 +1,6 @@
 /* vi: set sw=4 ts=4: */
 /*
- * $Id: hostname.c,v 1.34 2002/11/10 22:07:48 bug1 Exp $
+ * $Id: hostname.c,v 1.35 2003/03/19 09:12:37 mjn3 Exp $
  * Mini hostname implementation for busybox
  *
  * Copyright (C) 1999 by Randolph Chung <tausq@debian.org>
@@ -46,12 +46,12 @@ static void do_sethostname(char *s, int isfile)
 	if (!isfile) {
 		if (sethostname(s, strlen(s)) < 0) {
 			if (errno == EPERM)
-				error_msg_and_die("you must be root to change the hostname");
+				bb_error_msg_and_die("you must be root to change the hostname");
 			else
-				perror_msg_and_die("sethostname");
+				bb_perror_msg_and_die("sethostname");
 		}
 	} else {
-		f = xfopen(s, "r");
+		f = bb_xfopen(s, "r");
 		while (fgets(buf, 255, f) != NULL) {
 			if (buf[0] =='#') {
 				continue;
@@ -75,7 +75,7 @@ int hostname_main(int argc, char **argv)
 	char *p = NULL;
 
 	if (argc < 1)
-		show_usage();
+		bb_show_usage();
 
         while ((opt = getopt(argc, argv, "dfisF:")) > 0) {
                 switch (opt) {
@@ -89,7 +89,7 @@ int hostname_main(int argc, char **argv)
 			filename = optarg;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
diff --git a/networking/httpd.c b/networking/httpd.c
index fb37224cf..e62168d38 100644
--- a/networking/httpd.c
+++ b/networking/httpd.c
@@ -178,12 +178,12 @@ static const char home[] = "/www";
 #define CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP
 
 /* require from libbb.a for linking */
-const char *applet_name = "httpd";
+const char *bb_applet_name = "httpd";
 
-void show_usage(void)
+void bb_show_usage(void)
 {
   fprintf(stderr, "Usage: %s [-p <port>] [-c configFile] [-d/-e <string>] "
-		  "[-r realm] [-u user]\n", applet_name);
+		  "[-r realm] [-u user]\n", bb_applet_name);
   exit(1);
 }
 #endif
@@ -395,7 +395,7 @@ static int conf_sort(const void *p1, const void *p2)
     }
 #ifdef DEBUG
     if(!test)
-	error_msg_and_die("sort: can`t found compares!");
+	bb_error_msg_and_die("sort: can`t found compares!");
 #endif
     return test;
 }
@@ -423,7 +423,7 @@ static void parse_conf(const char *path, int flag)
 	cf = p0 = alloca(strlen(path) + sizeof(httpd_conf) + 2);
 	if(p0 == NULL) {
 	    if(flag == FIRST_PARSE)
-		error_msg_and_die(memory_exhausted);
+		bb_error_msg_and_die(bb_msg_memory_exhausted);
 	    return;
 	}
 	sprintf(p0, "%s/%s", path, httpd_conf);
@@ -433,7 +433,7 @@ static void parse_conf(const char *path, int flag)
 	if(flag != FIRST_PARSE)
 	    return;                 /* subdir config not found */
 	if(p0 == NULL)              /* if -c option gived */
-		perror_msg_and_die("%s", cf);
+		bb_perror_msg_and_die("%s", cf);
 	p0 = NULL;
 	cf = httpd_conf;            /* set -c ./httpd_conf */
     }
@@ -543,7 +543,7 @@ static void parse_conf(const char *path, int flag)
 	pcur = alloca((n + 1) * sizeof(Htaccess *));
 	if(pcur == NULL) {
 	    if(flag == FIRST_PARSE)
-		error_msg_and_die(memory_exhausted);
+		bb_error_msg_and_die(bb_msg_memory_exhausted);
 	    return;
 	}
 	n = 0;
@@ -557,7 +557,7 @@ static void parse_conf(const char *path, int flag)
 	config->Httpd_conf_parsed = *pcur;
 	for(cur = *pcur; cur; cur = cur->next) {
 #ifdef DEBUG
-	    error_msg("%s: %s:%s", cf, cur->before_colon, cur->after_colon);
+	    bb_error_msg("%s: %s:%s", cf, cur->before_colon, cur->after_colon);
 #endif
 	    cur->next = *++pcur;
 	}
@@ -829,10 +829,10 @@ static int openServer(void)
       listen(fd, 9);
       signal(SIGCHLD, SIG_IGN);   /* prevent zombie (defunct) processes */
     } else {
-	perror_msg_and_die("bind");
+	bb_perror_msg_and_die("bind");
     }
   } else {
-	perror_msg_and_die("create socket");
+	bb_perror_msg_and_die("create socket");
   }
   return fd;
 }
@@ -905,7 +905,7 @@ static int sendHeaders(HttpResponseNum responseNum)
 #ifdef DEBUG
   if (config->debugHttpd) fprintf(stderr, "Headers: '%s'", buf);
 #endif
-  return full_write(a_c_w, buf, len);
+  return bb_full_write(a_c_w, buf, len);
 }
 
 /****************************************************************************
@@ -1105,7 +1105,7 @@ static int sendCgi(const char *url,
     outFd = toCgi[1];
     close(fromCgi[1]);
     close(toCgi[0]);
-    if (body) full_write(outFd, body, bodyLen);
+    if (body) bb_full_write(outFd, body, bodyLen);
     close(outFd);
 
     while (1) {
@@ -1129,9 +1129,9 @@ static int sendCgi(const char *url,
 #ifdef DEBUG
 	  if (config->debugHttpd) {
 	    if (WIFEXITED(status))
-	      error_msg("piped has exited with status=%d", WEXITSTATUS(status));
+	      bb_error_msg("piped has exited with status=%d", WEXITSTATUS(status));
 	    if (WIFSIGNALED(status))
-	      error_msg("piped has exited with signal=%d", WTERMSIG(status));
+	      bb_error_msg("piped has exited with signal=%d", WTERMSIG(status));
 	  }
 #endif
 	  pid = -1;
@@ -1141,7 +1141,7 @@ static int sendCgi(const char *url,
 	int s = a_c_w;
 
 	// There is something to read
-	count = full_read(inFd, buf, sizeof(buf)-1);
+	count = bb_full_read(inFd, buf, sizeof(buf)-1);
 	// If a read returns 0 at this point then some type of error has
 	// occurred.  Bail now.
 	if (count == 0) break;
@@ -1149,14 +1149,14 @@ static int sendCgi(const char *url,
 	  if (firstLine) {
 	    /* check to see if the user script added headers */
 	    if (strncmp(buf, "HTTP/1.0 200 OK\n", 4) != 0) {
-	      full_write(s, "HTTP/1.0 200 OK\n", 16);
+	      bb_full_write(s, "HTTP/1.0 200 OK\n", 16);
 	    }
 	    if (strstr(buf, "ontent-") == 0) {
-	      full_write(s, "Content-type: text/plain\n\n", 26);
+	      bb_full_write(s, "Content-type: text/plain\n\n", 26);
 	    }
 	    firstLine=0;
 	  }
-	  full_write(s, buf, count);
+	  bb_full_write(s, buf, count);
 #ifdef DEBUG
 	  if (config->debugHttpd)
 		fprintf(stderr, "cgi read %d bytes\n", count);
@@ -1223,14 +1223,14 @@ static int sendFile(const char *url, char *buf)
 	int count;
 
 	sendHeaders(HTTP_OK);
-	while ((count = full_read(f, buf, MAX_MEMORY_BUFF)) > 0) {
-		full_write(a_c_w, buf, count);
+	while ((count = bb_full_read(f, buf, MAX_MEMORY_BUFF)) > 0) {
+		bb_full_write(a_c_w, buf, count);
 	}
 	close(f);
   } else {
 #ifdef DEBUG
 	if (config->debugHttpd)
-		perror_msg("Unable to open '%s'", url);
+		bb_perror_msg("Unable to open '%s'", url);
 #endif
 	sendHeaders(HTTP_NOT_FOUND);
   }
@@ -1399,7 +1399,7 @@ BAD_REQUEST:
 			   but CGI script can`t be a directory */
     }
 
-    /* algorithm stolen from libbb simplify_path(),
+    /* algorithm stolen from libbb bb_simplify_path(),
        but don`t strdup and reducing trailing slash */
     purl = test = url;
 
@@ -1517,7 +1517,7 @@ FORBIDDEN:      /* protect listing /cgi-bin */
     if (length > 0) {
       body = malloc(length + 1);
       if (body) {
-	length = full_read(a_c_r, body, length);
+	length = bb_full_read(a_c_r, body, length);
 	if(length < 0)          // closed
 		length = 0;
 	body[length] = 0;       // always null terminate for safety
@@ -1629,7 +1629,7 @@ static int miniHttpd(int server)
 	config->port = ntohs(fromAddr.sin_port);
 #ifdef DEBUG
 	if (config->debugHttpd) {
-		error_msg("connection from IP=%s, port %u\n",
+		bb_error_msg("connection from IP=%s, port %u\n",
 					config->rmt_ip, config->port);
 	}
 #endif
@@ -1748,7 +1748,7 @@ int httpd_main(int argc, char *argv[])
     case 'p':
       config->port = atoi(optarg);
       if(config->port <= 0 || config->port > 0xffff)
-	error_msg_and_die("invalid %s for -p", optarg);
+	bb_error_msg_and_die("invalid %s for -p", optarg);
       break;
 #endif
 #ifdef CONFIG_FEATURE_HTTPD_DECODE_URL_STR
@@ -1780,13 +1780,13 @@ int httpd_main(int argc, char *argv[])
       break;
 #endif
     default:
-      error_msg("%s", httpdVersion);
-      show_usage();
+      bb_error_msg("%s", httpdVersion);
+      bb_show_usage();
     }
   }
 
   if(chdir(home_httpd)) {
-    perror_msg_and_die("can`t chdir to %s", home_httpd);
+    bb_perror_msg_and_die("can`t chdir to %s", home_httpd);
   }
 #ifndef CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY
   server = openServer();
@@ -1809,7 +1809,7 @@ int httpd_main(int argc, char *argv[])
 #ifndef CONFIG_FEATURE_HTTPD_USAGE_FROM_INETD_ONLY
   if (!config->debugHttpd) {
     if (daemon(1, 0) < 0)     /* don`t change curent directory */
-	perror_msg_and_die("daemon");
+	bb_perror_msg_and_die("daemon");
   }
   return miniHttpd(server);
 #else
diff --git a/networking/ifconfig.c b/networking/ifconfig.c
index 95cc07ab0..c09c48c58 100644
--- a/networking/ifconfig.c
+++ b/networking/ifconfig.c
@@ -15,7 +15,7 @@
  * Foundation;  either  version 2 of the License, or  (at
  * your option) any later version.
  *
- * $Id: ifconfig.c,v 1.22 2003/01/14 08:54:07 andersen Exp $
+ * $Id: ifconfig.c,v 1.23 2003/03/19 09:12:38 mjn3 Exp $
  *
  */
 
@@ -323,14 +323,14 @@ int ifconfig_main(int argc, char **argv)
 #ifdef CONFIG_FEATURE_IFCONFIG_STATUS
 		return display_interfaces(argc ? *argv : NULL);
 #else
-		error_msg_and_die
+		bb_error_msg_and_die
 			("ifconfig was not compiled with interface status display support.");
 #endif
 	}
 
 	/* Create a channel to the NET kernel. */
 	if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-		perror_msg_and_die("socket");
+		bb_perror_msg_and_die("socket");
 	}
 
 	/* get interface name */
@@ -366,11 +366,11 @@ int ifconfig_main(int argc, char **argv)
 			mask = op->arg_flags;
 			a1op = Arg1Opt + (op - OptArray);
 			if (mask & A_NETMASK & did_flags) {
-				show_usage();
+				bb_show_usage();
 			}
 			if (*++argv == NULL) {
 				if (mask & A_ARG_REQ) {
-					show_usage();
+					bb_show_usage();
 				} else {
 					--argv;
 					mask &= A_SET_AFTER;	/* just for broadcast */
@@ -421,7 +421,7 @@ int ifconfig_main(int argc, char **argv)
 
 							/* Create a channel to the NET kernel. */
 							if ((sockfd6 = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
-								perror_msg_and_die("socket6");
+								bb_perror_msg_and_die("socket6");
 							}
 							if (ioctl(sockfd6, SIOGIFINDEX, &ifr) < 0) {
 								perror("SIOGIFINDEX");
@@ -454,11 +454,11 @@ int ifconfig_main(int argc, char **argv)
 					} else {	/* A_CAST_HOST_COPY_IN_ETHER */
 						/* This is the "hw" arg case. */
 						if (strcmp("ether", *argv) || (*++argv == NULL)) {
-							show_usage();
+							bb_show_usage();
 						}
 						safe_strncpy(host, *argv, (sizeof host));
 						if (in_ether(host, &sa)) {
-							error_msg("invalid hw-addr %s", host);
+							bb_error_msg("invalid hw-addr %s", host);
 							++goterr;
 							continue;
 						}
diff --git a/networking/ifupdown.c b/networking/ifupdown.c
index 0511a5b95..9bbb90496 100644
--- a/networking/ifupdown.c
+++ b/networking/ifupdown.c
@@ -244,7 +244,7 @@ static char *parse(char *command, interface_defn_t *ifd)
 			varvalue = get_var(command, nextpercent - command, ifd);
 
 			if (varvalue) {
-				addstr(&result, &len, &pos, varvalue, xstrlen(varvalue));
+				addstr(&result, &len, &pos, varvalue, bb_strlen(varvalue));
 			} else {
 #ifdef CONFIG_FEATURE_IFUPDOWN_IP
 				/* Sigh...  Add a special case for 'ip' to convert from
@@ -255,7 +255,7 @@ static char *parse(char *command, interface_defn_t *ifd)
 					if (varvalue && (res=count_netmask_bits(varvalue)) > 0) {
 						char argument[255];
 						sprintf(argument, "%d", res);
-						addstr(&result, &len, &pos, argument, xstrlen(argument));
+						addstr(&result, &len, &pos, argument, bb_strlen(argument));
 						command = nextpercent + 1;
 						break;
 					}
@@ -734,9 +734,9 @@ static interfaces_file_t *read_interfaces(char *filename)
 	defn->mappings = NULL;
 	defn->ifaces = NULL;
 
-	f = xfopen(filename, "r");
+	f = bb_xfopen(filename, "r");
 
-	while ((buf = get_line_from_file(f)) != NULL) {
+	while ((buf = bb_get_line_from_file(f)) != NULL) {
 		char *buf_ptr = buf;
 
 		/* Ignore comments */
@@ -762,7 +762,7 @@ static interfaces_file_t *read_interfaces(char *filename)
 					currmap->match = xrealloc(currmap->match, sizeof(currmap->match) * currmap->max_matches);
 				}
 
-				currmap->match[currmap->n_matches++] = xstrdup(firstword);
+				currmap->match[currmap->n_matches++] = bb_xstrdup(firstword);
 			}
 			currmap->max_mappings = 0;
 			currmap->n_mappings = 0;
@@ -802,26 +802,26 @@ static interfaces_file_t *read_interfaces(char *filename)
 				method_name = next_word(&buf_ptr);
 
 				if (buf_ptr == NULL) {
-					error_msg("too few parameters for line \"%s\"", buf);
+					bb_error_msg("too few parameters for line \"%s\"", buf);
 					return NULL;
 				}
 
 				if (buf_ptr[0] != '\0') {
-					error_msg("too many parameters \"%s\"", buf);
+					bb_error_msg("too many parameters \"%s\"", buf);
 					return NULL;
 				}
 
-				currif->iface = xstrdup(iface_name);
+				currif->iface = bb_xstrdup(iface_name);
 
 				currif->address_family = get_address_family(addr_fams, address_family_name);
 				if (!currif->address_family) {
-					error_msg("unknown address type \"%s\"", buf);
+					bb_error_msg("unknown address type \"%s\"", buf);
 					return NULL;
 				}
 
 				currif->method = get_method(currif->address_family, method_name);
 				if (!currif->method) {
-					error_msg("unknown method \"%s\"", buf);
+					bb_error_msg("unknown method \"%s\"", buf);
 					return NULL;
 				}
 
@@ -836,7 +836,7 @@ static interfaces_file_t *read_interfaces(char *filename)
 
 					while (*where != NULL) {
 						if (duplicate_if(*where, currif)) {
-							error_msg("duplicate interface \"%s\"", buf);
+							bb_error_msg("duplicate interface \"%s\"", buf);
 							return NULL;
 						}
 						where = &(*where)->next;
@@ -852,7 +852,7 @@ static interfaces_file_t *read_interfaces(char *filename)
 
 				/* Check the interface isnt already listed */
 				if (find_list_string(defn->autointerfaces, firstword)) {
-					perror_msg_and_die("interface declared auto twice \"%s\"", buf);
+					bb_perror_msg_and_die("interface declared auto twice \"%s\"", buf);
 				}
 
 				/* Add the interface to the list */
@@ -865,8 +865,8 @@ static interfaces_file_t *read_interfaces(char *filename)
 			{
 				int i;
 
-				if (xstrlen(buf_ptr) == 0) {
-					error_msg("option with empty value \"%s\"", buf);
+				if (bb_strlen(buf_ptr) == 0) {
+					bb_error_msg("option with empty value \"%s\"", buf);
 					return NULL;
 				}
 
@@ -876,7 +876,7 @@ static interfaces_file_t *read_interfaces(char *filename)
 					&& strcmp(firstword, "post-down") != 0) {
 					for (i = 0; i < currif->n_options; i++) {
 						if (strcmp(currif->option[i].name, firstword) == 0) {
-							error_msg("duplicate option \"%s\"", buf);
+							bb_error_msg("duplicate option \"%s\"", buf);
 							return NULL;
 						}
 					}
@@ -889,8 +889,8 @@ static interfaces_file_t *read_interfaces(char *filename)
 					opt = xrealloc(currif->option, sizeof(*opt) * currif->max_options);
 					currif->option = opt;
 				}
-				currif->option[currif->n_options].name = xstrdup(firstword);
-				currif->option[currif->n_options].value = xstrdup(next_word(&buf_ptr));
+				currif->option[currif->n_options].name = bb_xstrdup(firstword);
+				currif->option[currif->n_options].value = bb_xstrdup(next_word(&buf_ptr));
 				if (!currif->option[currif->n_options].name) {
 					perror(filename);
 					return NULL;
@@ -905,34 +905,34 @@ static interfaces_file_t *read_interfaces(char *filename)
 #ifdef CONFIG_FEATURE_IFUPDOWN_MAPPING
 				if (strcmp(firstword, "script") == 0) {
 					if (currmap->script != NULL) {
-						error_msg("duplicate script in mapping \"%s\"", buf);
+						bb_error_msg("duplicate script in mapping \"%s\"", buf);
 						return NULL;
 					} else {
-						currmap->script = xstrdup(next_word(&buf_ptr));
+						currmap->script = bb_xstrdup(next_word(&buf_ptr));
 					}
 				} else if (strcmp(firstword, "map") == 0) {
 					if (currmap->max_mappings == currmap->n_mappings) {
 						currmap->max_mappings = currmap->max_mappings * 2 + 1;
 						currmap->mapping = xrealloc(currmap->mapping, sizeof(char *) * currmap->max_mappings);
 					}
-					currmap->mapping[currmap->n_mappings] = xstrdup(next_word(&buf_ptr));
+					currmap->mapping[currmap->n_mappings] = bb_xstrdup(next_word(&buf_ptr));
 					currmap->n_mappings++;
 				} else {
-					error_msg("misplaced option \"%s\"", buf);
+					bb_error_msg("misplaced option \"%s\"", buf);
 					return NULL;
 				}
 #endif
 				break;
 			case NONE:
 			default:
-				error_msg("misplaced option \"%s\"", buf);
+				bb_error_msg("misplaced option \"%s\"", buf);
 				return NULL;
 			}
 		}
 		free(buf);
 	}
 	if (ferror(f) != 0) {
-		perror_msg_and_die("%s", filename);
+		bb_perror_msg_and_die("%s", filename);
 	}
 	fclose(f);
 
@@ -945,7 +945,7 @@ static char *setlocalenv(char *format, char *name, char *value)
 	char *here;
 	char *there;
 
-	result = xmalloc(xstrlen(format) + xstrlen(name) + xstrlen(value) + 1);
+	result = xmalloc(bb_strlen(format) + bb_strlen(name) + bb_strlen(value) + 1);
 
 	sprintf(result, format, name, value);
 
@@ -960,7 +960,7 @@ static char *setlocalenv(char *format, char *name, char *value)
 			here++;
 		}
 	}
-	memmove(here, there, xstrlen(there) + 1);
+	memmove(here, there, bb_strlen(there) + 1);
 
 	return result;
 }
@@ -1010,7 +1010,7 @@ static void set_environ(interface_defn_t *iface, char *mode)
 static int doit(char *str)
 {
 	if (verbose || no_act) {
-		error_msg("%s", str);
+		bb_error_msg("%s", str);
 	}
 	if (!no_act) {
 		pid_t child;
@@ -1045,7 +1045,7 @@ static int execute_all(interface_defn_t *ifd, execfn *exec, const char *opt)
 		}
 	}
 
-	buf = xmalloc(xstrlen(opt) + 19);
+	buf = xmalloc(bb_strlen(opt) + 19);
 	sprintf(buf, "/etc/network/if-%s.d", opt);
 	run_parts(&buf, 2);
 	free(buf);
@@ -1155,7 +1155,7 @@ static int run_mapping(char *physical, char *logical, int len, mapping_defn_t *
 	waitpid(pid, &status, 0);
 	if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
 		if (fgets(logical, len, out)) {
-			char *pch = logical + xstrlen(logical) - 1;
+			char *pch = logical + bb_strlen(logical) - 1;
 
 			while (pch >= logical && isspace(*pch))
 				*(pch--) = '\0';
@@ -1169,7 +1169,7 @@ static int run_mapping(char *physical, char *logical, int len, mapping_defn_t *
 
 static llist_t *find_iface_state(llist_t *state_list, const char *iface)
 {
-	unsigned short iface_len = xstrlen(iface);
+	unsigned short iface_len = bb_strlen(iface);
 	llist_t *search = state_list;
 
 	while (search) {
@@ -1199,7 +1199,7 @@ extern int ifupdown_main(int argc, char **argv)
 	int force = 0;
 	int i;
 
-	if (applet_name[2] == 'u') {
+	if (bb_applet_name[2] == 'u') {
 		/* ifup command */
 		cmds = iface_up;
 	} else {
@@ -1214,7 +1214,7 @@ extern int ifupdown_main(int argc, char **argv)
 #endif
 		switch (i) {
 		case 'i':	/* interfaces */
-			interfaces = xstrdup(optarg);
+			interfaces = bb_xstrdup(optarg);
 			break;
 		case 'v':	/* verbose */
 			verbose = 1;
@@ -1234,18 +1234,18 @@ extern int ifupdown_main(int argc, char **argv)
 			force = 1;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 			break;
 		}
 	}
 
 	if (argc - optind > 0) {
 		if (do_all) {
-			show_usage();
+			bb_show_usage();
 		}
 	} else {
 		if (!do_all) {
-			show_usage();
+			bb_show_usage();
 		}
 	}			
 
@@ -1297,13 +1297,13 @@ extern int ifupdown_main(int argc, char **argv)
 			if (cmds == iface_up) {
 				/* ifup */
 				if (iface_state) {
-					error_msg("interface %s already configured", iface);
+					bb_error_msg("interface %s already configured", iface);
 					continue;
 				}
 			} else {
 				/* ifdown */
 				if (iface_state) {
-					error_msg("interface %s not configured", iface);
+					bb_error_msg("interface %s not configured", iface);
 					continue;
 				}
 			}
@@ -1319,7 +1319,7 @@ extern int ifupdown_main(int argc, char **argv)
 					if (fnmatch(currmap->match[i], liface, 0) != 0)
 						continue;
 					if (verbose) {
-						error_msg("Running mapping script %s on %s", currmap->script, liface);
+						bb_error_msg("Running mapping script %s on %s", currmap->script, liface);
 					}
 					run_mapping(iface, liface, sizeof(liface), currmap);
 					break;
@@ -1336,7 +1336,7 @@ extern int ifupdown_main(int argc, char **argv)
 				currif->iface = iface;
 
 				if (verbose) {
-					error_msg("Configuring interface %s=%s (%s)", iface, liface, currif->address_family->name);
+					bb_error_msg("Configuring interface %s=%s (%s)", iface, liface, currif->address_family->name);
 				}
 
 				/* Call the cmds function pointer, does either iface_up() or iface_down() */
@@ -1351,12 +1351,12 @@ extern int ifupdown_main(int argc, char **argv)
 		}
 
 		if (!okay && !force) {
-			error_msg("Ignoring unknown interface %s=%s.", iface, liface);
+			bb_error_msg("Ignoring unknown interface %s=%s.", iface, liface);
 		} else {
 			llist_t *iface_state = find_iface_state(state_list, iface);
 
 			if (cmds == iface_up) {
-				char *newiface = xmalloc(xstrlen(iface) + 1 + xstrlen(liface) + 1);
+				char *newiface = xmalloc(bb_strlen(iface) + 1 + bb_strlen(liface) + 1);
 				sprintf(newiface, "%s=%s", iface, liface);
 				if (iface_state == NULL) {
 					state_list = llist_add_to(state_list, newiface);
@@ -1387,10 +1387,10 @@ extern int ifupdown_main(int argc, char **argv)
 
 		if (state_fp)
 			fclose(state_fp);
-		state_fp = xfopen(statefile, "a+");
+		state_fp = bb_xfopen(statefile, "a+");
 
 		if (ftruncate(fileno(state_fp), 0) < 0) {
-			error_msg_and_die("failed to truncate statefile %s: %s", statefile, strerror(errno));
+			bb_error_msg_and_die("failed to truncate statefile %s: %s", statefile, strerror(errno));
 		}
 
 		rewind(state_fp);
diff --git a/networking/inetd.c b/networking/inetd.c
index 2769c01b7..33b97ba94 100644
--- a/networking/inetd.c
+++ b/networking/inetd.c
@@ -519,7 +519,7 @@ enter(struct servtab *cp)
 
 	sep = (struct servtab *)malloc(sizeof (*sep));
 	if (sep == NULL) {
-		syslog_err_and_discard_dg(SOCK_STREAM, memory_exhausted);
+		syslog_err_and_discard_dg(SOCK_STREAM, bb_msg_memory_exhausted);
 	}
 	*sep = *cp;
 	sep->se_fd = -1;
@@ -835,7 +835,7 @@ inetd_main(int argc, char *argv[])
 			if (global_queuelen < 8) global_queuelen=8;
 			break;
 		default:
-			show_usage(); // "[-q len] [conf]"
+			bb_show_usage(); // "[-q len] [conf]"
 		}
 	argc -= optind;
 	argv += optind;
@@ -844,7 +844,7 @@ inetd_main(int argc, char *argv[])
 		CONFIG = argv[0];
 
 	daemon(0, 0);
-	openlog(applet_name, LOG_PID | LOG_NOWAIT, LOG_DAEMON);
+	openlog(bb_applet_name, LOG_PID | LOG_NOWAIT, LOG_DAEMON);
 	{
 		FILE *fp;
 
diff --git a/networking/ip.c b/networking/ip.c
index e7cab74c9..a0781bdba 100644
--- a/networking/ip.c
+++ b/networking/ip.c
@@ -72,7 +72,7 @@ void ip_parse_common_args(int *argcp, char ***argvp)
 		} else if (matches(opt, "-oneline") == 0) {
 			++oneline;
 		} else {
-			show_usage();
+			bb_show_usage();
 		}
 		argc--;	argv++;
 	}
@@ -109,7 +109,7 @@ int ip_main(int argc, char **argv)
 #endif
 	}
 	if (ret) {
-		show_usage();
+		bb_show_usage();
 	}
 	return(EXIT_SUCCESS);
 }
diff --git a/networking/ipcalc.c b/networking/ipcalc.c
index f130f3b7c..2c23d17f6 100644
--- a/networking/ipcalc.c
+++ b/networking/ipcalc.c
@@ -82,24 +82,24 @@ int ipcalc_main(int argc, char **argv)
 			mode |= SILENT;
 #endif
 		else {
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
 	if (mode & (BROADCAST | NETWORK)) {
 		if (argc - optind > 2) {
-			show_usage();
+			bb_show_usage();
 		}
 	} else {
 		if (argc - optind != 1) {
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
 	ipaddr = inet_addr(argv[optind]);
 
 	if (ipaddr == INADDR_NONE) {
-		IPCALC_MSG(error_msg_and_die("bad IP address: %s\n", argv[optind]),
+		IPCALC_MSG(bb_error_msg_and_die("bad IP address: %s\n", argv[optind]),
 				   exit(EXIT_FAILURE));
 	}
 
@@ -109,7 +109,7 @@ int ipcalc_main(int argc, char **argv)
 	}
 
 	if (ipaddr == INADDR_NONE) {
-		IPCALC_MSG(error_msg_and_die("bad netmask: %s\n", argv[optind + 1]),
+		IPCALC_MSG(bb_error_msg_and_die("bad netmask: %s\n", argv[optind + 1]),
 				   exit(EXIT_FAILURE));
 	}
 
@@ -138,7 +138,7 @@ int ipcalc_main(int argc, char **argv)
 
 		hostinfo = gethostbyaddr((char *) &ipaddr, sizeof(ipaddr), AF_INET);
 		if (!hostinfo) {
-			IPCALC_MSG(error_msg("cannot find hostname for %s", argv[optind]);
+			IPCALC_MSG(bb_error_msg("cannot find hostname for %s", argv[optind]);
 					   herror(NULL);
 					   putc('\n', stderr);,);
 			exit(EXIT_FAILURE);
diff --git a/networking/libiproute/ip_parse_common_args.c b/networking/libiproute/ip_parse_common_args.c
index 4b4355ac1..21e9f74ba 100644
--- a/networking/libiproute/ip_parse_common_args.c
+++ b/networking/libiproute/ip_parse_common_args.c
@@ -48,7 +48,7 @@ void ip_parse_common_args(int *argcp, char ***argvp)
 			argc--;
 			argv++;
 			if (! argv[1]) 
-			    show_usage();
+			    bb_show_usage();
 			if (strcmp(argv[1], "inet") == 0)
 				preferred_family = AF_INET;
 			else if (strcmp(argv[1], "inet6") == 0)
@@ -66,7 +66,7 @@ void ip_parse_common_args(int *argcp, char ***argvp)
 		} else if (matches(opt, "-oneline") == 0) {
 			++oneline;
 		} else {
-			show_usage();
+			bb_show_usage();
 		}
 		argc--;	argv++;
 	}
diff --git a/networking/libiproute/ipaddress.c b/networking/libiproute/ipaddress.c
index 8eba90c77..44e871ee5 100644
--- a/networking/libiproute/ipaddress.c
+++ b/networking/libiproute/ipaddress.c
@@ -125,7 +125,7 @@ static int print_linkinfo(struct sockaddr_nl *who, struct nlmsghdr *n, void *arg
 	memset(tb, 0, sizeof(tb));
 	parse_rtattr(tb, IFLA_MAX, IFLA_RTA(ifi), len);
 	if (tb[IFLA_IFNAME] == NULL) {
-		error_msg("nil ifname");
+		bb_error_msg("nil ifname");
 		return -1;
 	}
 	if (filter.label &&
@@ -217,7 +217,7 @@ static int print_addrinfo(struct sockaddr_nl *who, struct nlmsghdr *n, void *arg
 		return 0;
 	len -= NLMSG_LENGTH(sizeof(*ifa));
 	if (len < 0) {
-		error_msg("wrong nlmsg len %d", len);
+		bb_error_msg("wrong nlmsg len %d", len);
 		return -1;
 	}
 
@@ -489,17 +489,17 @@ extern int ipaddr_list_or_flush(int argc, char **argv, int flush)
 		exit(1);
 
 	if (rtnl_wilddump_request(&rth, preferred_family, RTM_GETLINK) < 0) {
-		perror_msg_and_die("Cannot send dump request");
+		bb_perror_msg_and_die("Cannot send dump request");
 	}
 
 	if (rtnl_dump_filter(&rth, store_nlmsg, &linfo, NULL, NULL) < 0) {
-		error_msg_and_die("Dump terminated");
+		bb_error_msg_and_die("Dump terminated");
 	}
 
 	if (filter_dev) {
 		filter.ifindex = ll_name_to_index(filter_dev);
 		if (filter.ifindex <= 0) {
-			error_msg("Device \"%s\" does not exist.", filter_dev);
+			bb_error_msg("Device \"%s\" does not exist.", filter_dev);
 			return -1;
 		}
 	}
@@ -539,11 +539,11 @@ extern int ipaddr_list_or_flush(int argc, char **argv, int flush)
 
 	if (filter.family != AF_PACKET) {
 		if (rtnl_wilddump_request(&rth, filter.family, RTM_GETADDR) < 0) {
-			perror_msg_and_die("Cannot send dump request");
+			bb_perror_msg_and_die("Cannot send dump request");
 		}
 
 		if (rtnl_dump_filter(&rth, store_nlmsg, &ainfo, NULL, NULL) < 0) {
-			error_msg_and_die("Dump terminated");
+			bb_error_msg_and_die("Dump terminated");
 		}
 	}
 
@@ -749,11 +749,11 @@ static int ipaddr_modify(int cmd, int argc, char **argv)
 	}
 
 	if (d == NULL) {
-		error_msg("Not enough information: \"dev\" argument is required.");
+		bb_error_msg("Not enough information: \"dev\" argument is required.");
 		return -1;
 	}
 	if (l && matches(d, l) != 0) {
-		error_msg_and_die("\"dev\" (%s) must match \"label\" (%s).", d, l);
+		bb_error_msg_and_die("\"dev\" (%s) must match \"label\" (%s).", d, l);
 	}
 
 	if (peer_len == 0 && local_len && cmd != RTM_DELADDR) {
@@ -767,7 +767,7 @@ static int ipaddr_modify(int cmd, int argc, char **argv)
 		inet_prefix brd;
 		int i;
 		if (req.ifa.ifa_family != AF_INET) {
-			error_msg("Broadcast can be set only for IPv4 addresses");
+			bb_error_msg("Broadcast can be set only for IPv4 addresses");
 			return -1;
 		}
 		brd = peer;
@@ -791,7 +791,7 @@ static int ipaddr_modify(int cmd, int argc, char **argv)
 	ll_init_map(&rth);
 
 	if ((req.ifa.ifa_index = ll_name_to_index(d)) == 0) {
-		error_msg("Cannot find device \"%s\"", d);
+		bb_error_msg("Cannot find device \"%s\"", d);
 		return -1;
 	}
 
@@ -821,5 +821,5 @@ extern int do_ipaddr(int argc, char **argv)
 		case 5: /* flush */
 			return ipaddr_list_or_flush(argc-1, argv+1, 1);
 	}
-	error_msg_and_die("Unknown command %s", *argv);
+	bb_error_msg_and_die("Unknown command %s", *argv);
 }
diff --git a/networking/libiproute/iplink.c b/networking/libiproute/iplink.c
index 1cfaf6d6a..f826ba081 100644
--- a/networking/libiproute/iplink.c
+++ b/networking/libiproute/iplink.c
@@ -42,7 +42,7 @@ static int do_link;
 
 static int on_off(char *msg)
 {
-	error_msg("Error: argument of \"%s\" must be \"on\" or \"off\"", msg);
+	bb_error_msg("Error: argument of \"%s\" must be \"on\" or \"off\"", msg);
 	return -1;
 }
 
@@ -211,7 +211,7 @@ static int parse_address(char *dev, int hatype, int halen, char *lla, struct ifr
 	if (alen < 0)
 		return -1;
 	if (alen != halen) {
-		error_msg("Wrong address (%s) length: expected %d bytes", lla, halen);
+		bb_error_msg("Wrong address (%s) length: expected %d bytes", lla, halen);
 		return -1;
 	}
 	return 0; 
@@ -293,7 +293,7 @@ static int do_set(int argc, char **argv)
 	}
 
 	if (!dev) {
-		error_msg("Not enough of information: \"dev\" argument is required.");
+		bb_error_msg("Not enough of information: \"dev\" argument is required.");
 		exit(-1);
 	}
 
@@ -358,6 +358,6 @@ int do_iplink(int argc, char **argv)
 	} else
 		return ipaddr_list_link(0, NULL);
 
-	error_msg("Command \"%s\" is unknown, try \"ip link help\".", *argv);
+	bb_error_msg("Command \"%s\" is unknown, try \"ip link help\".", *argv);
 	exit(-1);
 }
diff --git a/networking/libiproute/iproute.c b/networking/libiproute/iproute.c
index be4435f66..3dcafdb6f 100644
--- a/networking/libiproute/iproute.c
+++ b/networking/libiproute/iproute.c
@@ -85,7 +85,7 @@ static int print_route(struct sockaddr_nl *who, struct nlmsghdr *n, void *arg)
 		return 0;
 	len -= NLMSG_LENGTH(sizeof(*r));
 	if (len < 0) {
-		error_msg("wrong nlmsg len %d", len);
+		bb_error_msg("wrong nlmsg len %d", len);
 		return -1;
 	}
 
@@ -385,7 +385,7 @@ static int iproute_modify(int cmd, unsigned flags, int argc, char **argv)
 
 		if (d) {
 			if ((idx = ll_name_to_index(d)) == 0) {
-				error_msg("Cannot find device \"%s\"", d);
+				bb_error_msg("Cannot find device \"%s\"", d);
 				return -1;
 			}
 			addattr32(&req.n, sizeof(req), RTA_OIF, idx);
@@ -549,7 +549,7 @@ static int iproute_list_or_flush(int argc, char **argv, int flush)
 
 		if (id) {
 			if ((idx = ll_name_to_index(id)) == 0) {
-				error_msg("Cannot find device \"%s\"", id);
+				bb_error_msg("Cannot find device \"%s\"", id);
 				return -1;
 			}
 			filter.iif = idx;
@@ -557,7 +557,7 @@ static int iproute_list_or_flush(int argc, char **argv, int flush)
 		}
 		if (od) {
 			if ((idx = ll_name_to_index(od)) == 0) {
-				error_msg("Cannot find device \"%s\"", od);
+				bb_error_msg("Cannot find device \"%s\"", od);
 			}
 			filter.oif = idx;
 			filter.oifmask = -1;
@@ -587,7 +587,7 @@ static int iproute_list_or_flush(int argc, char **argv, int flush)
 			}
 			filter.flushed = 0;
 			if (rtnl_dump_filter(&rth, print_route, stdout, NULL, NULL) < 0) {
-				error_msg("Flush terminated\n");
+				bb_error_msg("Flush terminated\n");
 				return -1;
 			}
 			if (filter.flushed == 0) {
@@ -606,16 +606,16 @@ static int iproute_list_or_flush(int argc, char **argv, int flush)
 
 	if (filter.tb != -1) {
 		if (rtnl_wilddump_request(&rth, do_ipv6, RTM_GETROUTE) < 0) {
-			perror_msg_and_die("Cannot send dump request");
+			bb_perror_msg_and_die("Cannot send dump request");
 		}
 	} else {
 		if (rtnl_rtcache_request(&rth, do_ipv6) < 0) {
-			perror_msg_and_die("Cannot send dump request");
+			bb_perror_msg_and_die("Cannot send dump request");
 		}
 	}
 
 	if (rtnl_dump_filter(&rth, print_route, stdout, NULL, NULL) < 0) {
-		error_msg_and_die("Dump terminated");
+		bb_error_msg_and_die("Dump terminated");
 	}
 
 	exit(0);
@@ -703,7 +703,7 @@ static int iproute_get(int argc, char **argv)
 	}
 
 	if (req.r.rtm_dst_len == 0) {
-		error_msg_and_die("need at least destination address");
+		bb_error_msg_and_die("need at least destination address");
 	}
 
 	if (rtnl_open(&rth, 0) < 0)
@@ -716,14 +716,14 @@ static int iproute_get(int argc, char **argv)
 
 		if (idev) {
 			if ((idx = ll_name_to_index(idev)) == 0) {
-				error_msg("Cannot find device \"%s\"", idev);
+				bb_error_msg("Cannot find device \"%s\"", idev);
 				return -1;
 			}
 			addattr32(&req.n, sizeof(req), RTA_IIF, idx);
 		}
 		if (odev) {
 			if ((idx = ll_name_to_index(odev)) == 0) {
-				error_msg("Cannot find device \"%s\"", odev);
+				bb_error_msg("Cannot find device \"%s\"", odev);
 				return -1;
 			}
 			addattr32(&req.n, sizeof(req), RTA_OIF, idx);
@@ -744,16 +744,16 @@ static int iproute_get(int argc, char **argv)
 		struct rtattr * tb[RTA_MAX+1];
 
 		if (print_route(NULL, &req.n, (void*)stdout) < 0) {
-			error_msg_and_die("An error :-)");
+			bb_error_msg_and_die("An error :-)");
 		}
 
 		if (req.n.nlmsg_type != RTM_NEWROUTE) {
-			error_msg("Not a route?");
+			bb_error_msg("Not a route?");
 			return -1;
 		}
 		len -= NLMSG_LENGTH(sizeof(*r));
 		if (len < 0) {
-			error_msg("Wrong len %d", len);
+			bb_error_msg("Wrong len %d", len);
 			return -1;
 		}
 
@@ -764,7 +764,7 @@ static int iproute_get(int argc, char **argv)
 			tb[RTA_PREFSRC]->rta_type = RTA_SRC;
 			r->rtm_src_len = 8*RTA_PAYLOAD(tb[RTA_PREFSRC]);
 		} else if (!tb[RTA_SRC]) {
-			error_msg("Failed to connect the route");
+			bb_error_msg("Failed to connect the route");
 			return -1;
 		}
 		if (!odev && tb[RTA_OIF]) {
@@ -785,7 +785,7 @@ static int iproute_get(int argc, char **argv)
 	}
 
 	if (print_route(NULL, &req.n, (void*)stdout) < 0) {
-		error_msg_and_die("An error :-)");
+		bb_error_msg_and_die("An error :-)");
 	}
 
 	exit(0);
@@ -830,7 +830,7 @@ int do_iproute(int argc, char **argv)
 		case 11: /* flush */
 			return iproute_list_or_flush(argc-1, argv+1, 1);
 		default:
-			error_msg_and_die("Unknown command %s", *argv);
+			bb_error_msg_and_die("Unknown command %s", *argv);
 	}
 
 	return iproute_modify(cmd, flags, argc-1, argv+1);
diff --git a/networking/libiproute/iptunnel.c b/networking/libiproute/iptunnel.c
index 1eb17799c..eae5bb091 100644
--- a/networking/libiproute/iptunnel.c
+++ b/networking/libiproute/iptunnel.c
@@ -47,7 +47,7 @@ static int do_ioctl_get_ifindex(char *dev)
 	strcpy(ifr.ifr_name, dev);
 	fd = socket(AF_INET, SOCK_DGRAM, 0);
 	if (ioctl(fd, SIOCGIFINDEX, &ifr)) {
-		perror_msg("ioctl");
+		bb_perror_msg("ioctl");
 		return 0;
 	}
 	close(fd);
@@ -62,7 +62,7 @@ static int do_ioctl_get_iftype(char *dev)
 	strcpy(ifr.ifr_name, dev);
 	fd = socket(AF_INET, SOCK_DGRAM, 0);
 	if (ioctl(fd, SIOCGIFHWADDR, &ifr)) {
-		perror_msg("ioctl");
+		bb_perror_msg("ioctl");
 		return -1;
 	}
 	close(fd);
@@ -78,7 +78,7 @@ static char *do_ioctl_get_ifname(int idx)
 	ifr.ifr_ifindex = idx;
 	fd = socket(AF_INET, SOCK_DGRAM, 0);
 	if (ioctl(fd, SIOCGIFNAME, &ifr)) {
-		perror_msg("ioctl");
+		bb_perror_msg("ioctl");
 		return NULL;
 	}
 	close(fd);
@@ -98,7 +98,7 @@ static int do_get_ioctl(char *basedev, struct ip_tunnel_parm *p)
 	fd = socket(AF_INET, SOCK_DGRAM, 0);
 	err = ioctl(fd, SIOCGETTUNNEL, &ifr);
 	if (err) {
-		perror_msg("ioctl");
+		bb_perror_msg("ioctl");
 	}
 	close(fd);
 	return err;
@@ -119,7 +119,7 @@ static int do_add_ioctl(int cmd, char *basedev, struct ip_tunnel_parm *p)
 	fd = socket(AF_INET, SOCK_DGRAM, 0);
 	err = ioctl(fd, cmd, &ifr);
 	if (err) {
-		perror_msg("ioctl");
+		bb_perror_msg("ioctl");
 	}
 	close(fd);
 	return err;
@@ -140,7 +140,7 @@ static int do_del_ioctl(char *basedev, struct ip_tunnel_parm *p)
 	fd = socket(AF_INET, SOCK_DGRAM, 0);
 	err = ioctl(fd, SIOCDELTUNNEL, &ifr);
 	if (err) {
-		perror_msg("ioctl");
+		bb_perror_msg("ioctl");
 	}
 	close(fd);
 	return err;
@@ -166,26 +166,26 @@ static int parse_args(int argc, char **argv, int cmd, struct ip_tunnel_parm *p)
 			if (strcmp(*argv, "ipip") == 0 ||
 			    strcmp(*argv, "ip/ip") == 0) {
 				if (p->iph.protocol && p->iph.protocol != IPPROTO_IPIP) {
-					error_msg("You managed to ask for more than one tunnel mode.");
+					bb_error_msg("You managed to ask for more than one tunnel mode.");
 					exit(-1);
 				}
 				p->iph.protocol = IPPROTO_IPIP;
 			} else if (strcmp(*argv, "gre") == 0 ||
 				   strcmp(*argv, "gre/ip") == 0) {
 				if (p->iph.protocol && p->iph.protocol != IPPROTO_GRE) {
-					error_msg("You managed to ask for more than one tunnel mode.");
+					bb_error_msg("You managed to ask for more than one tunnel mode.");
 					exit(-1);
 				}
 				p->iph.protocol = IPPROTO_GRE;
 			} else if (strcmp(*argv, "sit") == 0 ||
 				   strcmp(*argv, "ipv6/ip") == 0) {
 				if (p->iph.protocol && p->iph.protocol != IPPROTO_IPV6) {
-					error_msg("You managed to ask for more than one tunnel mode.");
+					bb_error_msg("You managed to ask for more than one tunnel mode.");
 					exit(-1);
 				}
 				p->iph.protocol = IPPROTO_IPV6;
 			} else {
-				error_msg("Cannot guess tunnel mode.");
+				bb_error_msg("Cannot guess tunnel mode.");
 				exit(-1);
 			}
 		} else if (strcmp(*argv, "key") == 0) {
@@ -197,7 +197,7 @@ static int parse_args(int argc, char **argv, int cmd, struct ip_tunnel_parm *p)
 				p->i_key = p->o_key = get_addr32(*argv);
 			else {
 				if (get_unsigned(&uval, *argv, 0)<0) {
-					error_msg("invalid value of \"key\"");
+					bb_error_msg("invalid value of \"key\"");
 					exit(-1);
 				}
 				p->i_key = p->o_key = htonl(uval);
@@ -210,7 +210,7 @@ static int parse_args(int argc, char **argv, int cmd, struct ip_tunnel_parm *p)
 				p->o_key = get_addr32(*argv);
 			else {
 				if (get_unsigned(&uval, *argv, 0)<0) {
-					error_msg("invalid value of \"ikey\"");
+					bb_error_msg("invalid value of \"ikey\"");
 					exit(-1);
 				}
 				p->i_key = htonl(uval);
@@ -223,7 +223,7 @@ static int parse_args(int argc, char **argv, int cmd, struct ip_tunnel_parm *p)
 				p->o_key = get_addr32(*argv);
 			else {
 				if (get_unsigned(&uval, *argv, 0)<0) {
-					error_msg("invalid value of \"okey\"");
+					bb_error_msg("invalid value of \"okey\"");
 					exit(-1);
 				}
 				p->o_key = htonl(uval);
@@ -308,7 +308,7 @@ static int parse_args(int argc, char **argv, int cmd, struct ip_tunnel_parm *p)
 
 	if (p->iph.protocol == IPPROTO_IPIP || p->iph.protocol == IPPROTO_IPV6) {
 		if ((p->i_flags & GRE_KEY) || (p->o_flags & GRE_KEY)) {
-			error_msg("Keys are not allowed with ipip and sit.");
+			bb_error_msg("Keys are not allowed with ipip and sit.");
 			return -1;
 		}
 	}
@@ -328,7 +328,7 @@ static int parse_args(int argc, char **argv, int cmd, struct ip_tunnel_parm *p)
 		p->o_flags |= GRE_KEY;
 	}
 	if (IN_MULTICAST(ntohl(p->iph.daddr)) && !p->iph.saddr) {
-		error_msg("Broadcast tunnel requires a source address.");
+		bb_error_msg("Broadcast tunnel requires a source address.");
 		return -1;
 	}
 	return 0;
@@ -343,7 +343,7 @@ static int do_add(int cmd, int argc, char **argv)
 		return -1;
 
 	if (p.iph.ttl && p.iph.frag_off == 0) {
-		error_msg("ttl != 0 and noptmudisc are incompatible");
+		bb_error_msg("ttl != 0 and noptmudisc are incompatible");
 		return -1;
 	}
 
@@ -355,7 +355,7 @@ static int do_add(int cmd, int argc, char **argv)
 	case IPPROTO_IPV6:
 		return do_add_ioctl(cmd, "sit0", &p);
 	default:	
-		error_msg("cannot determine tunnel mode (ipip, gre or sit)");
+		bb_error_msg("cannot determine tunnel mode (ipip, gre or sit)");
 		return -1;
 	}
 	return -1;
@@ -464,7 +464,7 @@ static int do_tunnels_list(struct ip_tunnel_parm *p)
 		buf[sizeof(buf) - 1] = 0;
 		if ((ptr = strchr(buf, ':')) == NULL ||
 		    (*ptr++ = 0, sscanf(buf, "%s", name) != 1)) {
-			error_msg("Wrong format of /proc/net/dev. Sorry.");
+			bb_error_msg("Wrong format of /proc/net/dev. Sorry.");
 			return -1;
 		}
 		if (sscanf(ptr, "%ld%ld%ld%ld%ld%ld%ld%*d%ld%ld%ld%ld%ld%ld%ld",
@@ -477,7 +477,7 @@ static int do_tunnels_list(struct ip_tunnel_parm *p)
 			continue;
 		type = do_ioctl_get_iftype(name);
 		if (type == -1) {
-			error_msg("Failed to get type of [%s]", name);
+			bb_error_msg("Failed to get type of [%s]", name);
 			continue;
 		}
 		if (type != ARPHRD_TUNNEL && type != ARPHRD_IPGRE && type != ARPHRD_SIT)
@@ -543,6 +543,6 @@ int do_iptunnel(int argc, char **argv)
 	} else
 		return do_show(0, NULL);
 
-	error_msg("Command \"%s\" is unknown, try \"ip tunnel help\".", *argv);
+	bb_error_msg("Command \"%s\" is unknown, try \"ip tunnel help\".", *argv);
 	exit(-1);
 }
diff --git a/networking/libiproute/libnetlink.c b/networking/libiproute/libnetlink.c
index fbc555dfe..04411931d 100644
--- a/networking/libiproute/libnetlink.c
+++ b/networking/libiproute/libnetlink.c
@@ -34,7 +34,7 @@ int rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)
 
 	rth->fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
 	if (rth->fd < 0) {
-		perror_msg("Cannot open netlink socket");
+		bb_perror_msg("Cannot open netlink socket");
 		return -1;
 	}
 
@@ -43,20 +43,20 @@ int rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)
 	rth->local.nl_groups = subscriptions;
 
 	if (bind(rth->fd, (struct sockaddr*)&rth->local, sizeof(rth->local)) < 0) {
-		perror_msg("Cannot bind netlink socket");
+		bb_perror_msg("Cannot bind netlink socket");
 		return -1;
 	}
 	addr_len = sizeof(rth->local);
 	if (getsockname(rth->fd, (struct sockaddr*)&rth->local, &addr_len) < 0) {
-		perror_msg("Cannot getsockname");
+		bb_perror_msg("Cannot getsockname");
 		return -1;
 	}
 	if (addr_len != sizeof(rth->local)) {
-		error_msg("Wrong address length %d", addr_len);
+		bb_error_msg("Wrong address length %d", addr_len);
 		return -1;
 	}
 	if (rth->local.nl_family != AF_NETLINK) {
-		error_msg("Wrong address family %d", rth->local.nl_family);
+		bb_error_msg("Wrong address family %d", rth->local.nl_family);
 		return -1;
 	}
 	rth->seq = time(NULL);
@@ -144,15 +144,15 @@ int rtnl_dump_filter(struct rtnl_handle *rth,
 		if (status < 0) {
 			if (errno == EINTR)
 				continue;
-			perror_msg("OVERRUN");
+			bb_perror_msg("OVERRUN");
 			continue;
 		}
 		if (status == 0) {
-			error_msg("EOF on netlink");
+			bb_error_msg("EOF on netlink");
 			return -1;
 		}
 		if (msg.msg_namelen != sizeof(nladdr)) {
-			error_msg_and_die("sender address length == %d", msg.msg_namelen);
+			bb_error_msg_and_die("sender address length == %d", msg.msg_namelen);
 		}
 
 		h = (struct nlmsghdr*)buf;
@@ -176,10 +176,10 @@ int rtnl_dump_filter(struct rtnl_handle *rth,
 			if (h->nlmsg_type == NLMSG_ERROR) {
 				struct nlmsgerr *l_err = (struct nlmsgerr*)NLMSG_DATA(h);
 				if (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {
-					error_msg("ERROR truncated");
+					bb_error_msg("ERROR truncated");
 				} else {
 					errno = -l_err->error;
-					perror_msg("RTNETLINK answers");
+					bb_perror_msg("RTNETLINK answers");
 				}
 				return -1;
 			}
@@ -192,11 +192,11 @@ skip_it:
 			h = NLMSG_NEXT(h, status);
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
-			error_msg("Message truncated");
+			bb_error_msg("Message truncated");
 			continue;
 		}
 		if (status) {
-			error_msg_and_die("!!!Remnant of size %d", status);
+			bb_error_msg_and_die("!!!Remnant of size %d", status);
 		}
 	}
 }
@@ -231,7 +231,7 @@ int rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,
 	status = sendmsg(rtnl->fd, &msg, 0);
 
 	if (status < 0) {
-		perror_msg("Cannot talk to rtnetlink");
+		bb_perror_msg("Cannot talk to rtnetlink");
 		return -1;
 	}
 
@@ -245,15 +245,15 @@ int rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,
 			if (errno == EINTR) {
 				continue;
 			}
-			perror_msg("OVERRUN");
+			bb_perror_msg("OVERRUN");
 			continue;
 		}
 		if (status == 0) {
-			error_msg("EOF on netlink");
+			bb_error_msg("EOF on netlink");
 			return -1;
 		}
 		if (msg.msg_namelen != sizeof(nladdr)) {
-			error_msg_and_die("sender address length == %d", msg.msg_namelen);
+			bb_error_msg_and_die("sender address length == %d", msg.msg_namelen);
 		}
 		for (h = (struct nlmsghdr*)buf; status >= sizeof(*h); ) {
 			int l_err;
@@ -262,10 +262,10 @@ int rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,
 
 			if (l<0 || len>status) {
 				if (msg.msg_flags & MSG_TRUNC) {
-					error_msg("Truncated message");
+					bb_error_msg("Truncated message");
 					return -1;
 				}
-				error_msg_and_die("!!!malformed message: len=%d", len);
+				bb_error_msg_and_die("!!!malformed message: len=%d", len);
 			}
 
 			if (h->nlmsg_pid != rtnl->local.nl_pid ||
@@ -282,7 +282,7 @@ int rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,
 			if (h->nlmsg_type == NLMSG_ERROR) {
 				struct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);
 				if (l < sizeof(struct nlmsgerr)) {
-					error_msg("ERROR truncated");
+					bb_error_msg("ERROR truncated");
 				} else {
 					errno = -err->error;
 					if (errno == 0) {
@@ -291,7 +291,7 @@ int rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,
 						}
 						return 0;
 					}
-					perror_msg("RTNETLINK answers");
+					bb_perror_msg("RTNETLINK answers");
 				}
 				return -1;
 			}
@@ -300,17 +300,17 @@ int rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n, pid_t peer,
 				return 0;
 			}
 
-			error_msg("Unexpected reply!!!");
+			bb_error_msg("Unexpected reply!!!");
 
 			status -= NLMSG_ALIGN(len);
 			h = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
-			error_msg("Message truncated");
+			bb_error_msg("Message truncated");
 			continue;
 		}
 		if (status) {
-			error_msg_and_die("!!!Remnant of size %d", status);
+			bb_error_msg_and_die("!!!Remnant of size %d", status);
 		}
 	}
 }
@@ -346,15 +346,15 @@ int rtnl_listen(struct rtnl_handle *rtnl,
 		if (status < 0) {
 			if (errno == EINTR)
 				continue;
-			perror_msg("OVERRUN");
+			bb_perror_msg("OVERRUN");
 			continue;
 		}
 		if (status == 0) {
-			error_msg("EOF on netlink");
+			bb_error_msg("EOF on netlink");
 			return -1;
 		}
 		if (msg.msg_namelen != sizeof(nladdr)) {
-			error_msg_and_die("Sender address length == %d", msg.msg_namelen);
+			bb_error_msg_and_die("Sender address length == %d", msg.msg_namelen);
 		}
 		for (h = (struct nlmsghdr*)buf; status >= sizeof(*h); ) {
 			int err;
@@ -363,10 +363,10 @@ int rtnl_listen(struct rtnl_handle *rtnl,
 
 			if (l<0 || len>status) {
 				if (msg.msg_flags & MSG_TRUNC) {
-					error_msg("Truncated message");
+					bb_error_msg("Truncated message");
 					return -1;
 				}
-				error_msg_and_die("!!!malformed message: len=%d", len);
+				bb_error_msg_and_die("!!!malformed message: len=%d", len);
 			}
 
 			err = handler(&nladdr, h, jarg);
@@ -378,11 +378,11 @@ int rtnl_listen(struct rtnl_handle *rtnl,
 			h = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
-			error_msg("Message truncated");
+			bb_error_msg("Message truncated");
 			continue;
 		}
 		if (status) {
-			error_msg_and_die("!!!Remnant of size %d", status);
+			bb_error_msg_and_die("!!!Remnant of size %d", status);
 		}
 	}
 }
@@ -410,7 +410,7 @@ int rtnl_from_file(FILE *rtnl,
 		if (status < 0) {
 			if (errno == EINTR)
 				continue;
-			perror_msg("rtnl_from_file: fread");
+			bb_perror_msg("rtnl_from_file: fread");
 			return -1;
 		}
 		if (status == 0)
@@ -421,7 +421,7 @@ int rtnl_from_file(FILE *rtnl,
 		l = len - sizeof(*h);
 
 		if (l<0 || len>sizeof(buf)) {
-			error_msg("!!!malformed message: len=%d @%lu",
+			bb_error_msg("!!!malformed message: len=%d @%lu",
 				len, ftell(rtnl));
 			return -1;
 		}
@@ -429,11 +429,11 @@ int rtnl_from_file(FILE *rtnl,
 		status = fread(NLMSG_DATA(h), 1, NLMSG_ALIGN(l), rtnl);
 
 		if (status < 0) {
-			perror_msg("rtnl_from_file: fread");
+			bb_perror_msg("rtnl_from_file: fread");
 			return -1;
 		}
 		if (status < l) {
-			error_msg("rtnl-from_file: truncated message");
+			bb_error_msg("rtnl-from_file: truncated message");
 			return -1;
 		}
 
@@ -514,7 +514,7 @@ int parse_rtattr(struct rtattr *tb[], int max, struct rtattr *rta, int len)
 		rta = RTA_NEXT(rta,len);
 	}
 	if (len) {
-		error_msg("!!!Deficit %d, rta_len=%d", len, rta->rta_len);
+		bb_error_msg("!!!Deficit %d, rta_len=%d", len, rta->rta_len);
 	}
 	return 0;
 }
diff --git a/networking/libiproute/ll_addr.c b/networking/libiproute/ll_addr.c
index 39e561fe5..ada685f4e 100644
--- a/networking/libiproute/ll_addr.c
+++ b/networking/libiproute/ll_addr.c
@@ -44,7 +44,7 @@ int ll_addr_a2n(unsigned char *lladdr, int len, char *arg)
 	if (strchr(arg, '.')) {
 		inet_prefix pfx;
 		if (get_addr_1(&pfx, arg, AF_INET)) {
-			error_msg("\"%s\" is invalid lladdr.", arg);
+			bb_error_msg("\"%s\" is invalid lladdr.", arg);
 			return -1;
 		}
 		if (len < 4) {
@@ -63,11 +63,11 @@ int ll_addr_a2n(unsigned char *lladdr, int len, char *arg)
 				cp++;
 			}
 			if (sscanf(arg, "%x", &temp) != 1) {
-				error_msg("\"%s\" is invalid lladdr.", arg);
+				bb_error_msg("\"%s\" is invalid lladdr.", arg);
 				return -1;
 			}
 			if (temp < 0 || temp > 255) {
-				error_msg("\"%s\" is invalid lladdr.", arg);
+				bb_error_msg("\"%s\" is invalid lladdr.", arg);
 				return -1;
 			}
 			lladdr[i] = temp;
diff --git a/networking/libiproute/utils.c b/networking/libiproute/utils.c
index 2c23cd294..fa1548609 100644
--- a/networking/libiproute/utils.c
+++ b/networking/libiproute/utils.c
@@ -209,10 +209,10 @@ int get_prefix_1(inet_prefix * dst, char *arg, int family)
 int get_addr(inet_prefix * dst, char *arg, int family)
 {
 	if (family == AF_PACKET) {
-		error_msg_and_die("\"%s\" may be inet address, but it is not allowed in this context.", arg);
+		bb_error_msg_and_die("\"%s\" may be inet address, but it is not allowed in this context.", arg);
 	}
 	if (get_addr_1(dst, arg, family)) {
-		error_msg_and_die("an inet address is expected rather than \"%s\".", arg);
+		bb_error_msg_and_die("an inet address is expected rather than \"%s\".", arg);
 	}
 	return 0;
 }
@@ -220,10 +220,10 @@ int get_addr(inet_prefix * dst, char *arg, int family)
 int get_prefix(inet_prefix * dst, char *arg, int family)
 {
 	if (family == AF_PACKET) {
-		error_msg_and_die("\"%s\" may be inet address, but it is not allowed in this context.", arg);
+		bb_error_msg_and_die("\"%s\" may be inet address, but it is not allowed in this context.", arg);
 	}
 	if (get_prefix_1(dst, arg, family)) {
-		error_msg_and_die("an inet address is expected rather than \"%s\".", arg);
+		bb_error_msg_and_die("an inet address is expected rather than \"%s\".", arg);
 	}
 	return 0;
 }
@@ -233,32 +233,32 @@ __u32 get_addr32(char *name)
 	inet_prefix addr;
 
 	if (get_addr_1(&addr, name, AF_INET)) {
-		error_msg_and_die("an IP address is expected rather than \"%s\"", name);
+		bb_error_msg_and_die("an IP address is expected rather than \"%s\"", name);
 	}
 	return addr.data[0];
 }
 
 void incomplete_command()
 {
-	error_msg("Command line is not complete. Try option \"help\"");
+	bb_error_msg("Command line is not complete. Try option \"help\"");
 	exit(-1);
 }
 
 void invarg(char *msg, char *arg)
 {
-	error_msg("argument \"%s\" is wrong: %s", arg, msg);
+	bb_error_msg("argument \"%s\" is wrong: %s", arg, msg);
 	exit(-1);
 }
 
 void duparg(char *key, char *arg)
 {
-	error_msg("duplicate \"%s\": \"%s\" is the second value.", key, arg);
+	bb_error_msg("duplicate \"%s\": \"%s\" is the second value.", key, arg);
 	exit(-1);
 }
 
 void duparg2(char *key, char *arg)
 {
-	error_msg("either \"%s\" is duplicate, or \"%s\" is a garbage.", key, arg);
+	bb_error_msg("either \"%s\" is duplicate, or \"%s\" is a garbage.", key, arg);
 	exit(-1);
 }
 
diff --git a/networking/nameif.c b/networking/nameif.c
index f3b927158..e74a04213 100644
--- a/networking/nameif.c
+++ b/networking/nameif.c
@@ -63,11 +63,11 @@ static void serror(const char *s, ...)
 	va_start(ap, s);
 
 	if (use_syslog) {
-		openlog(applet_name, 0, LOG_LOCAL0);
+		openlog(bb_applet_name, 0, LOG_LOCAL0);
 		vsyslog(LOG_ERR, s, ap);
 		closelog();
 	} else {
-		verror_msg(s, ap);
+		bb_verror_msg(s, ap);
 		putc('\n', stderr);
 	}
 
@@ -111,12 +111,12 @@ int nameif_main(int argc, char **argv)
 			use_syslog = 1;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
 	if ((argc - optind) & 1)
-		show_usage();
+		bb_show_usage();
 
 	if (optind < argc) {
 		char **a = argv + optind;
@@ -126,7 +126,7 @@ int nameif_main(int argc, char **argv)
 			if (strlen(*a) > IF_NAMESIZE)
 				serror("interface name `%s' too long", *a);
 			ch = xcalloc(1, sizeof(mactable_t));
-			ch->ifname = xstrdup(*a++);
+			ch->ifname = bb_xstrdup(*a++);
 			ch->mac = cc_macaddr(*a++);
 			if (clist)
 				clist->prev = ch;
@@ -134,9 +134,9 @@ int nameif_main(int argc, char **argv)
 			clist = ch;
 		}
 	} else {
-		ifh = xfopen(fname, "r");
+		ifh = bb_xfopen(fname, "r");
 
-		while ((line = get_line_from_file(ifh)) != NULL) {
+		while ((line = bb_get_line_from_file(ifh)) != NULL) {
 			char *line_ptr;
 			size_t name_length;
 
@@ -145,7 +145,7 @@ int nameif_main(int argc, char **argv)
 				continue;
 			name_length = strcspn(line_ptr, " \t");
 			ch = xcalloc(1, sizeof(mactable_t));
-			ch->ifname = xstrndup(line_ptr, name_length);
+			ch->ifname = bb_xstrndup(line_ptr, name_length);
 			if (name_length > IF_NAMESIZE)
 				serror("interface name `%s' too long", ch->ifname);
 			line_ptr += name_length;
diff --git a/networking/nc.c b/networking/nc.c
index 63d8c5b19..4888ccceb 100644
--- a/networking/nc.c
+++ b/networking/nc.c
@@ -72,7 +72,7 @@ int nc_main(int argc, char **argv)
 				break;
 #endif
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
@@ -85,13 +85,13 @@ int nc_main(int argc, char **argv)
 
 
 	if ((do_listen && optind != argc) || (!do_listen && optind + 2 != argc))
-		show_usage();
+		bb_show_usage();
 
 	if ((sfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
-		perror_msg_and_die("socket");
+		bb_perror_msg_and_die("socket");
 	x = 1;
 	if (setsockopt (sfd, SOL_SOCKET, SO_REUSEADDR, &x, sizeof (x)) == -1)
-		perror_msg_and_die ("reuseaddr failed");
+		bb_perror_msg_and_die ("reuseaddr failed");
 	address.sin_family = AF_INET;
 
 	if (lport != 0) {
@@ -99,17 +99,17 @@ int nc_main(int argc, char **argv)
 		address.sin_port = htons(lport);
 
 		if (bind(sfd, (struct sockaddr *) &address, sizeof(address)) < 0)
-			perror_msg_and_die("bind");
+			bb_perror_msg_and_die("bind");
 	}
 
 	if (do_listen) {
 		socklen_t addrlen = sizeof(address);
 
 		if (listen(sfd, 1) < 0)
-			perror_msg_and_die("listen");
+			bb_perror_msg_and_die("listen");
 
 		if ((tmpfd = accept(sfd, (struct sockaddr *) &address, &addrlen)) < 0)
-			perror_msg_and_die("accept");
+			bb_perror_msg_and_die("accept");
 
 		close(sfd);
 		sfd = tmpfd;
@@ -120,7 +120,7 @@ int nc_main(int argc, char **argv)
 		address.sin_port = htons(atoi(argv[optind+1]));
 
 		if (connect(sfd, (struct sockaddr *) &address, sizeof(address)) < 0)
-			perror_msg_and_die("connect");
+			bb_perror_msg_and_die("connect");
 	}
 
 #ifdef GAPING_SECURITY_HOLE
@@ -149,12 +149,12 @@ int nc_main(int argc, char **argv)
 		testfds = readfds;
 
 		if (select(FD_SETSIZE, &testfds, NULL, NULL, NULL) < 0)
-			perror_msg_and_die("select");
+			bb_perror_msg_and_die("select");
 
 		for (fd = 0; fd < FD_SETSIZE; fd++) {
 			if (FD_ISSET(fd, &testfds)) {
 				if ((nread = safe_read(fd, buf, sizeof(buf))) < 0)
-					perror_msg_and_die("read");
+					bb_perror_msg_and_die("read");
 
 				if (fd == sfd) {
 					if (nread == 0)
@@ -166,8 +166,8 @@ int nc_main(int argc, char **argv)
 					ofd = sfd;
 				}
 
-				if (full_write(ofd, buf, nread) < 0)
-					perror_msg_and_die("write");
+				if (bb_full_write(ofd, buf, nread) < 0)
+					bb_perror_msg_and_die("write");
 				if (delay > 0) {
 					sleep(delay);
 				}
diff --git a/networking/netstat.c b/networking/netstat.c
index d2b2d5ede..17a58876c 100644
--- a/networking/netstat.c
+++ b/networking/netstat.c
@@ -200,7 +200,7 @@ static void tcp_do_one(int lnr, const char *line)
 	}
 
 	if (num < 10) {
-		error_msg("warning, got bogus tcp line.");
+		bb_error_msg("warning, got bogus tcp line.");
 		return;
 	}
 	state_str = tcp_state[state];
@@ -271,7 +271,7 @@ static void udp_do_one(int lnr, const char *line)
 	}
 
 	if (num < 10) {
-		error_msg("warning, got bogus udp line.");
+		bb_error_msg("warning, got bogus udp line.");
 		return;
 	}
 	switch (state) {
@@ -365,7 +365,7 @@ static void raw_do_one(int lnr, const char *line)
 	}
 
 	if (num < 10) {
-		error_msg("warning, got bogus raw line.");
+		bb_error_msg("warning, got bogus raw line.");
 		return;
 	}
 	state_str=itoa(state);
@@ -418,7 +418,7 @@ static void unix_do_one(int nr, const char *line)
 	num = sscanf(line, "%p: %lX %lX %lX %X %X %d %s",
 				 &d, &refcnt, &proto, &unix_flags, &type, &state, &inode, path);
 	if (num < 6) {
-		error_msg("warning, got bogus unix line.");
+		bb_error_msg("warning, got bogus unix line.");
 		return;
 	}
 	if (!(has & HAS_INODE))
@@ -539,7 +539,7 @@ static void do_info(const char *file, const char *name, void (*proc)(int, const
 		if (errno != ENOENT) {
 			perror(file);
 		} else {
-		error_msg("no support for `%s' on this system.", name);
+		bb_error_msg("no support for `%s' on this system.", name);
 		}
 	} else {
 		do {
@@ -597,14 +597,14 @@ int netstat_main(int argc, char **argv)
 			new_flags |= NETSTAT_UNIX;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	if ( showroute ) {
 #ifdef CONFIG_ROUTE	
 		displayroutes ( flags & NETSTAT_NUMERIC, !extended );
 		return 0; 
 #else
-		error_msg_and_die( "-r (display routing table) is not compiled in." );
+		bb_error_msg_and_die( "-r (display routing table) is not compiled in." );
 #endif
 	}	
 		
diff --git a/networking/nslookup.c b/networking/nslookup.c
index edbc65650..0f3102e30 100644
--- a/networking/nslookup.c
+++ b/networking/nslookup.c
@@ -185,7 +185,7 @@ int nslookup_main(int argc, char **argv)
 	*/
 
 	if (argc < 2 || *argv[1]=='-' || argc > 3) 
-		show_usage();
+		bb_show_usage();
 	else if(argc == 3) 
 		set_default_dns(argv[2]);
 
@@ -199,4 +199,4 @@ int nslookup_main(int argc, char **argv)
 	return EXIT_SUCCESS;
 }
 
-/* $Id: nslookup.c,v 1.29 2002/07/24 00:56:56 sandman Exp $ */
+/* $Id: nslookup.c,v 1.30 2003/03/19 09:12:38 mjn3 Exp $ */
diff --git a/networking/ping.c b/networking/ping.c
index 044b547ac..28b38db14 100644
--- a/networking/ping.c
+++ b/networking/ping.c
@@ -1,6 +1,6 @@
 /* vi: set sw=4 ts=4: */
 /*
- * $Id: ping.c,v 1.53 2003/01/12 06:08:33 andersen Exp $
+ * $Id: ping.c,v 1.54 2003/03/19 09:12:38 mjn3 Exp $
  * Mini ping implementation for busybox
  *
  * Copyright (C) 1999 by Randolph Chung <tausq@debian.org>
@@ -208,7 +208,7 @@ static void ping(const char *host)
 			   (struct sockaddr *) &pingaddr, sizeof(struct sockaddr_in));
 
 	if (c < 0 || c != sizeof(packet))
-		perror_msg_and_die("sendto");
+		bb_perror_msg_and_die("sendto");
 
 	signal(SIGALRM, noresp);
 	alarm(5);					/* give the host 5000ms to respond */
@@ -221,7 +221,7 @@ static void ping(const char *host)
 						  (struct sockaddr *) &from, &fromlen)) < 0) {
 			if (errno == EINTR)
 				continue;
-			perror_msg("recvfrom");
+			bb_perror_msg("recvfrom");
 			continue;
 		}
 		if (c >= 76) {			/* ip + icmp */
@@ -241,7 +241,7 @@ extern int ping_main(int argc, char **argv)
 	argc--;
 	argv++;
 	if (argc < 1)
-		show_usage();
+		bb_show_usage();
 	ping(*argv);
 	return EXIT_SUCCESS;
 }
@@ -313,9 +313,9 @@ static void sendping(int junk)
 			   (struct sockaddr *) &pingaddr, sizeof(struct sockaddr_in));
 
 	if (i < 0)
-		perror_msg_and_die("sendto");
+		bb_perror_msg_and_die("sendto");
 	else if ((size_t)i != sizeof(packet))
-		error_msg_and_die("ping wrote %d chars; %d expected", i,
+		bb_error_msg_and_die("ping wrote %d chars; %d expected", i,
 			   (int)sizeof(packet));
 
 	signal(SIGALRM, sendping);
@@ -410,7 +410,7 @@ static void unpack(char *buf, int sz, struct sockaddr_in *from)
 		printf("\n");
 	} else 
 		if (icmppkt->icmp_type != ICMP_ECHO)
-			error_msg("Warning: Got ICMP %d (%s)",
+			bb_error_msg("Warning: Got ICMP %d (%s)",
 					icmppkt->icmp_type, icmp_type_name (icmppkt->icmp_type));
 }
 
@@ -426,7 +426,7 @@ static void ping(const char *host)
 	pingaddr.sin_family = AF_INET;
 	hostent = xgethostbyname(host);
 	if (hostent->h_addrtype != AF_INET)
-		error_msg_and_die("unknown address type; only AF_INET is currently supported.");
+		bb_error_msg_and_die("unknown address type; only AF_INET is currently supported.");
 
 	memcpy(&pingaddr.sin_addr, hostent->h_addr, sizeof(pingaddr.sin_addr));
 
@@ -460,7 +460,7 @@ static void ping(const char *host)
 						  (struct sockaddr *) &from, &fromlen)) < 0) {
 			if (errno == EINTR)
 				continue;
-			perror_msg("recvfrom");
+			bb_perror_msg("recvfrom");
 			continue;
 		}
 		unpack(packet, c, &from);
@@ -489,24 +489,24 @@ extern int ping_main(int argc, char **argv)
 			break;
 		case 'c':
 			if (--argc <= 0)
-			        show_usage();
+			        bb_show_usage();
 			argv++;
 			pingcount = atoi(*argv);
 			break;
 		case 's':
 			if (--argc <= 0)
-			        show_usage();
+			        bb_show_usage();
 			argv++;
 			datalen = atoi(*argv);
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 		argc--;
 		argv++;
 	}
 	if (argc < 1)
-		show_usage();
+		bb_show_usage();
 
 	myid = getpid() & 0xFFFF;
 	ping(*argv);
diff --git a/networking/ping6.c b/networking/ping6.c
index f1ccff483..c40624219 100644
--- a/networking/ping6.c
+++ b/networking/ping6.c
@@ -1,6 +1,6 @@
 /* vi: set sw=4 ts=4: */
 /*
- * $Id: ping6.c,v 1.3 2003/01/12 06:08:33 andersen Exp $
+ * $Id: ping6.c,v 1.4 2003/03/19 09:12:38 mjn3 Exp $
  * Mini ping implementation for busybox
  *
  * Copyright (C) 1999 by Randolph Chung <tausq@debian.org>
@@ -112,7 +112,7 @@ static void ping(const char *host)
 			   (struct sockaddr *) &pingaddr, sizeof(struct sockaddr_in6));
 
 	if (c < 0 || c != sizeof(packet))
-		perror_msg_and_die("sendto");
+		bb_perror_msg_and_die("sendto");
 
 	signal(SIGALRM, noresp);
 	alarm(5);					/* give the host 5000ms to respond */
@@ -125,7 +125,7 @@ static void ping(const char *host)
 						  (struct sockaddr *) &from, &fromlen)) < 0) {
 			if (errno == EINTR)
 				continue;
-			perror_msg("recvfrom");
+			bb_perror_msg("recvfrom");
 			continue;
 		}
 		if (c >= 8) {			/* icmp6_hdr */
@@ -143,7 +143,7 @@ extern int ping6_main(int argc, char **argv)
 	argc--;
 	argv++;
 	if (argc < 1)
-		show_usage();
+		bb_show_usage();
 	ping(*argv);
 	return EXIT_SUCCESS;
 }
@@ -218,9 +218,9 @@ static void sendping(int junk)
 			   (struct sockaddr *) &pingaddr, sizeof(struct sockaddr_in6));
 
 	if (i < 0)
-		perror_msg_and_die("sendto");
+		bb_perror_msg_and_die("sendto");
 	else if ((size_t)i != sizeof(packet))
-		error_msg_and_die("ping wrote %d chars; %d expected", i,
+		bb_error_msg_and_die("ping wrote %d chars; %d expected", i,
 			   (int)sizeof(packet));
 
 	signal(SIGALRM, sendping);
@@ -308,7 +308,7 @@ static void unpack(char *packet, int sz, struct sockaddr_in6 *from, int hoplimit
 		printf("\n");
 	} else 
 		if (icmppkt->icmp6_type != ICMP6_ECHO_REQUEST)
-			error_msg("Warning: Got ICMP %d (%s)",
+			bb_error_msg("Warning: Got ICMP %d (%s)",
 					icmppkt->icmp6_type, icmp6_type_name (icmppkt->icmp6_type));
 }
 
@@ -329,7 +329,7 @@ static void ping(const char *host)
 	pingaddr.sin6_family = AF_INET6;
 	hostent = xgethostbyname2(host, AF_INET6);
 	if (hostent->h_addrtype != AF_INET6)
-		error_msg_and_die("unknown address type; only AF_INET6 is currently supported.");
+		bb_error_msg_and_die("unknown address type; only AF_INET6 is currently supported.");
 
 	memcpy(&pingaddr.sin6_addr, hostent->h_addr, sizeof(pingaddr.sin6_addr));
 
@@ -350,7 +350,7 @@ static void ping(const char *host)
 		}
 		if (setsockopt(pingsock, IPPROTO_ICMPV6, ICMP6_FILTER, &filt,
 					   sizeof(filt)) < 0)
-			error_msg_and_die("setsockopt(ICMP6_FILTER)");
+			bb_error_msg_and_die("setsockopt(ICMP6_FILTER)");
 	}
 #endif /*ICMP6_FILTER*/
 
@@ -374,7 +374,7 @@ static void ping(const char *host)
 
 	if (ifname) {
 		if ((pingaddr.sin6_scope_id = if_nametoindex(ifname)) == 0)
-			error_msg_and_die("%s: invalid interface name", ifname);
+			bb_error_msg_and_die("%s: invalid interface name", ifname);
 	}
 
 	printf("PING %s (%s): %d data bytes\n",
@@ -405,7 +405,7 @@ static void ping(const char *host)
 		if ((c = recvmsg(pingsock, &msg, 0)) < 0) {
 			if (errno == EINTR)
 				continue;
-			perror_msg("recvfrom");
+			bb_perror_msg("recvfrom");
 			continue;
 		}
 		for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL;
@@ -446,30 +446,30 @@ extern int ping6_main(int argc, char **argv)
 			break;
 		case 'c':
 			if (--argc <= 0)
-			        show_usage();
+			        bb_show_usage();
 			argv++;
 			pingcount = atoi(*argv);
 			break;
 		case 's':
 			if (--argc <= 0)
-			        show_usage();
+			        bb_show_usage();
 			argv++;
 			datalen = atoi(*argv);
 			break;
 		case 'I':
 			if (--argc <= 0)
-			        show_usage();
+			        bb_show_usage();
 			argv++;
 			ifname = *argv;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 		argc--;
 		argv++;
 	}
 	if (argc < 1)
-		show_usage();
+		bb_show_usage();
 
 	myid = getpid() & 0xFFFF;
 	ping(*argv);
diff --git a/networking/route.c b/networking/route.c
index b564c6dcd..083149a3d 100644
--- a/networking/route.c
+++ b/networking/route.c
@@ -15,7 +15,7 @@
  * Foundation;  either  version 2 of the License, or  (at
  * your option) any later version.
  *
- * $Id: route.c,v 1.21 2002/12/16 22:04:18 sandman Exp $
+ * $Id: route.c,v 1.22 2003/03/19 09:12:39 mjn3 Exp $
  *
  * displayroute() code added by Vladimir N. Oleynik <dzo@simtreas.ru>
  * adjustments by Larry Doolittle  <LRDoolittle@lbl.gov>
@@ -88,7 +88,7 @@ static int INET_setroute(int action, int options, char **args)
 	xflag = 0;
 
 	if (*args == NULL)
-		show_usage();
+		bb_show_usage();
 	if (strcmp(*args, "-net") == 0) {
 		xflag = 1;
 		args++;
@@ -97,7 +97,7 @@ static int INET_setroute(int action, int options, char **args)
 		args++;
 	}
 	if (*args == NULL)
-		show_usage();
+		bb_show_usage();
 	safe_strncpy(target, *args++, (sizeof target));
 
 	/* Clean out the RTREQ structure. */
@@ -107,7 +107,7 @@ static int INET_setroute(int action, int options, char **args)
 	if ((isnet =
 		 INET_resolve(target, (struct sockaddr_in *) &rt.rt_dst,
 					  xflag != 1)) < 0) {
-		error_msg(_("can't resolve %s"), target);
+		bb_error_msg(_("can't resolve %s"), target);
 		return EXIT_FAILURE;	/* XXX change to E_something */
 	}
 
@@ -135,7 +135,7 @@ static int INET_setroute(int action, int options, char **args)
 
 			args++;
 			if (!*args || !isdigit(**args))
-				show_usage();
+				bb_show_usage();
 			metric = atoi(*args);
 #if HAVE_NEW_ADDRT
 			rt.rt_metric = metric + 1;
@@ -151,12 +151,12 @@ static int INET_setroute(int action, int options, char **args)
 
 			args++;
 			if (!*args || mask_in_addr(rt))
-				show_usage();
+				bb_show_usage();
 			netmask = *args;
 			if ((isnet =
 				 INET_resolve(netmask, (struct sockaddr_in *) &mask,
 							  0)) < 0) {
-				error_msg(_("can't resolve netmask %s"), netmask);
+				bb_error_msg(_("can't resolve netmask %s"), netmask);
 				return E_LOOKUP;
 			}
 			rt.rt_genmask = full_mask(mask);
@@ -167,18 +167,18 @@ static int INET_setroute(int action, int options, char **args)
 		if (strcmp(*args, "gw") == 0 || strcmp(*args, "gateway") == 0) {
 			args++;
 			if (!*args)
-				show_usage();
+				bb_show_usage();
 			if (rt.rt_flags & RTF_GATEWAY)
-				show_usage();
+				bb_show_usage();
 			safe_strncpy(gateway, *args, (sizeof gateway));
 			if ((isnet =
 				 INET_resolve(gateway, (struct sockaddr_in *) &rt.rt_gateway,
 							  1)) < 0) {
-				error_msg(_("can't resolve gw %s"), gateway);
+				bb_error_msg(_("can't resolve gw %s"), gateway);
 				return E_LOOKUP;
 			}
 			if (isnet) {
-				error_msg(_("%s: cannot use a NETWORK as gateway!"), gateway);
+				bb_error_msg(_("%s: cannot use a NETWORK as gateway!"), gateway);
 				return E_OPTERR;
 			}
 			rt.rt_flags |= RTF_GATEWAY;
@@ -190,11 +190,11 @@ static int INET_setroute(int action, int options, char **args)
 			args++;
 			rt.rt_flags |= RTF_MSS;
 			if (!*args)
-				show_usage();
+				bb_show_usage();
 			rt.rt_mss = atoi(*args);
 			args++;
 			if (rt.rt_mss < 64 || rt.rt_mss > 32768) {
-				error_msg(_("Invalid MSS."));
+				bb_error_msg(_("Invalid MSS."));
 				return E_OPTERR;
 			}
 			continue;
@@ -203,12 +203,12 @@ static int INET_setroute(int action, int options, char **args)
 		if (strcmp(*args, "window") == 0) {
 			args++;
 			if (!*args)
-				show_usage();
+				bb_show_usage();
 			rt.rt_flags |= RTF_WINDOW;
 			rt.rt_window = atoi(*args);
 			args++;
 			if (rt.rt_window < 128) {
-				error_msg(_("Invalid window."));
+				bb_error_msg(_("Invalid window."));
 				return E_OPTERR;
 			}
 			continue;
@@ -217,7 +217,7 @@ static int INET_setroute(int action, int options, char **args)
 		if (strcmp(*args, "irtt") == 0) {
 			args++;
 			if (!*args)
-				show_usage();
+				bb_show_usage();
 			args++;
 #if HAVE_RTF_IRTT
 			rt.rt_flags |= RTF_IRTT;
@@ -225,7 +225,7 @@ static int INET_setroute(int action, int options, char **args)
 			rt.rt_irtt *= (sysconf(_SC_CLK_TCK) / 100);	/* FIXME */
 #if 0					/* FIXME: do we need to check anything of this? */
 			if (rt.rt_irtt < 1 || rt.rt_irtt > (120 * HZ)) {
-				error_msg(_("Invalid initial rtt."));
+				bb_error_msg(_("Invalid initial rtt."));
 				return E_OPTERR;
 			}
 #endif
@@ -262,7 +262,7 @@ static int INET_setroute(int action, int options, char **args)
 		if (strcmp(*args, "device") == 0 || strcmp(*args, "dev") == 0) {
 			args++;
 			if (rt.rt_dev || *args == NULL)
-				show_usage();
+				bb_show_usage();
 			rt.rt_dev = *args++;
 			continue;
 		}
@@ -270,9 +270,9 @@ static int INET_setroute(int action, int options, char **args)
 		if (!rt.rt_dev) {
 			rt.rt_dev = *args++;
 			if (*args)
-				show_usage();	/* must be last to catch typos */
+				bb_show_usage();	/* must be last to catch typos */
 		} else {
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
@@ -287,17 +287,17 @@ static int INET_setroute(int action, int options, char **args)
 
 		mask = ~ntohl(mask);
 		if ((rt.rt_flags & RTF_HOST) && mask != 0xffffffff) {
-			error_msg(_("netmask %.8x doesn't make sense with host route"),
+			bb_error_msg(_("netmask %.8x doesn't make sense with host route"),
 					  (unsigned int) mask);
 			return E_OPTERR;
 		}
 		if (mask & (mask + 1)) {
-			error_msg(_("bogus netmask %s"), netmask);
+			bb_error_msg(_("bogus netmask %s"), netmask);
 			return E_OPTERR;
 		}
 		mask = ((struct sockaddr_in *) &rt.rt_dst)->sin_addr.s_addr;
 		if (mask & ~mask_in_addr(rt)) {
-			error_msg(_("netmask doesn't match route address"));
+			bb_error_msg(_("netmask doesn't match route address"));
 			return E_OPTERR;
 		}
 	}
@@ -343,7 +343,7 @@ static int INET6_setroute(int action, int options, char **args)
 	int skfd;
 
 	if (*args == NULL)
-		show_usage();
+		bb_show_usage();
 
 	strcpy(target, *args++);
 	if (!strcmp(target, "default")) {
@@ -353,13 +353,13 @@ static int INET6_setroute(int action, int options, char **args)
 		if ((cp = strchr(target, '/'))) {
 			prefix_len = atol(cp + 1);
 			if ((prefix_len < 0) || (prefix_len > 128))
-				show_usage();
+				bb_show_usage();
 			*cp = 0;
 		} else {
 			prefix_len = 128;
 		}
 		if (INET6_resolve(target, (struct sockaddr_in6 *) &sa6) < 0) {
-			error_msg(_("can't resolve %s"), target);
+			bb_error_msg(_("can't resolve %s"), target);
 			return EXIT_FAILURE;	/* XXX change to E_something */
 		}
 	}
@@ -381,7 +381,7 @@ static int INET6_setroute(int action, int options, char **args)
 
 			args++;
 			if (!*args || !isdigit(**args))
-				show_usage();
+				bb_show_usage();
 			metric = atoi(*args);
 			rt.rtmsg_metric = metric;
 			args++;
@@ -390,12 +390,12 @@ static int INET6_setroute(int action, int options, char **args)
 		if (!strcmp(*args, "gw") || !strcmp(*args, "gateway")) {
 			args++;
 			if (!*args)
-				show_usage();
+				bb_show_usage();
 			if (rt.rtmsg_flags & RTF_GATEWAY)
-				show_usage();
+				bb_show_usage();
 			strcpy(gateway, *args);
 			if (INET6_resolve(gateway, (struct sockaddr_in6 *) &sa6) < 0) {
-				error_msg(_("can't resolve gw %s"), gateway);
+				bb_error_msg(_("can't resolve gw %s"), gateway);
 				return (E_LOOKUP);
 			}
 			memcpy(&rt.rtmsg_gateway, sa6.sin6_addr.s6_addr,
@@ -417,9 +417,9 @@ static int INET6_setroute(int action, int options, char **args)
 		if (!strcmp(*args, "device") || !strcmp(*args, "dev")) {
 			args++;
 			if (!*args)
-				show_usage();
+				bb_show_usage();
 		} else if (args[1])
-			show_usage();
+			bb_show_usage();
 
 		devname = *args;
 		args++;
@@ -493,7 +493,7 @@ void displayroutes(int noresolve, int netstatfmt)
 
 	char sdest[16], sgw[16];
 
-	FILE *fp = xfopen("/proc/net/route", "r");
+	FILE *fp = bb_xfopen("/proc/net/route", "r");
 
 	if (noresolve)
 		noresolve = 0x0fff;
@@ -515,7 +515,7 @@ void displayroutes(int noresolve, int netstatfmt)
 			if (sscanf(buff + ifl + 1, "%lx%lx%X%d%d%d%lx%d%d%d",
 					   &d, &g, &flgs, &ref, &use, &metric, &m, &mtu, &win,
 					   &ir) != 10) {
-				error_msg_and_die("Unsuported kernel route format\n");
+				bb_error_msg_and_die("Unsuported kernel route format\n");
 			}
 			ifl = 0;	/* parse flags */
 			if (flgs & RTF_UP) {
@@ -570,7 +570,7 @@ static void INET6_displayroutes(int noresolve)
 
 	char addr6p[8][5], saddr6p[8][5], naddr6p[8][5];
 
-	FILE *fp = xfopen("/proc/net/ipv6_route", "r");
+	FILE *fp = bb_xfopen("/proc/net/ipv6_route", "r");
 
 	flags[0] = 'U';
 
@@ -598,7 +598,7 @@ static void INET6_displayroutes(int noresolve)
 				   naddr6p[0], naddr6p[1], naddr6p[2], naddr6p[3],
 				   naddr6p[4], naddr6p[5], naddr6p[6], naddr6p[7],
 				   &metric, &use, &refcnt, &iflags, iface) != 31) {
-			error_msg_and_die("Unsuported kernel route format\n");
+			bb_error_msg_and_die("Unsuported kernel route format\n");
 		}
 
 		ifl = 1;		/* parse flags */
@@ -673,7 +673,7 @@ int route_main(int argc, char **argv)
 				break;
 #endif
 			default:
-				show_usage();
+				bb_show_usage();
 			}
 		}
 
@@ -694,7 +694,7 @@ int route_main(int argc, char **argv)
 		else if (strcmp(argv[1], "flush") == 0)
 			what = RTACTION_FLUSH;
 		else
-			show_usage();
+			bb_show_usage();
 	}
 
 #ifdef CONFIG_FEATURE_IPV6
diff --git a/networking/telnet.c b/networking/telnet.c
index 0c794b62f..8f2573c27 100644
--- a/networking/telnet.c
+++ b/networking/telnet.c
@@ -604,7 +604,7 @@ extern int telnet_main(int argc, char** argv)
 	G.termios_raw = G.termios_def;
 	cfmakeraw(&G.termios_raw);
 	
-	if (argc < 2)	show_usage();
+	if (argc < 2)	bb_show_usage();
 	port = (argc > 2)? argv[2] : "23";
 	
 	host = argv[1];
diff --git a/networking/telnetd.c b/networking/telnetd.c
index 8634a4233..077194cfd 100644
--- a/networking/telnetd.c
+++ b/networking/telnetd.c
@@ -1,4 +1,4 @@
-/* $Id: telnetd.c,v 1.4 2003/01/22 21:09:48 bug1 Exp $
+/* $Id: telnetd.c,v 1.5 2003/03/19 09:12:39 mjn3 Exp $
  *
  * Simple telnet server
  * Bjorn Wesen, Axis Communications AB (bjornw@axis.com)
@@ -380,12 +380,12 @@ telnetd_main(int argc, char **argv)
 				break;
 #endif /* CONFIG_FEATURE_TELNETD_INETD */
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
 	if (access(loginpath, X_OK) < 0) {
-		error_msg_and_die ("'%s' unavailable.", loginpath);
+		bb_error_msg_and_die ("'%s' unavailable.", loginpath);
 	}
 
 	argv_init[0] = loginpath;
@@ -400,7 +400,7 @@ telnetd_main(int argc, char **argv)
 
 	master_fd = socket(AF_INET, SOCK_STREAM, 0);
 	if (master_fd < 0) {
-		perror_msg_and_die("socket");
+		bb_perror_msg_and_die("socket");
 	}
 	(void)setsockopt(master_fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
 
@@ -411,15 +411,15 @@ telnetd_main(int argc, char **argv)
 	sa.sin_port = htons(portnbr);
 
 	if (bind(master_fd, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
-		perror_msg_and_die("bind");
+		bb_perror_msg_and_die("bind");
 	}
 
 	if (listen(master_fd, 1) < 0) {
-		perror_msg_and_die("listen");
+		bb_perror_msg_and_die("listen");
 	}
 
 	if (daemon(0, 0) < 0)
-		perror_msg_and_die("daemon");
+		bb_perror_msg_and_die("daemon");
 
 
 	maxfd = master_fd;
diff --git a/networking/tftp.c b/networking/tftp.c
index 378ba2fef..a33b5c21e 100644
--- a/networking/tftp.c
+++ b/networking/tftp.c
@@ -60,7 +60,7 @@
 #define TFTP_ERROR 5
 #define TFTP_OACK  6
 
-static const char *tftp_error_msg[] = {
+static const char *tftp_bb_error_msg[] = {
 	"Undefined error",
 	"File not found",
 	"Access violation",
@@ -86,7 +86,7 @@ static int tftp_blocksize_check(int blocksize, int bufsize)
 
         if ((bufsize && (blocksize > bufsize)) || 
 	    (blocksize < 8) || (blocksize > 65464)) {
-	        error_msg("bad blocksize");
+	        bb_error_msg("bad blocksize");
 	        return 0;
 	}
 
@@ -169,7 +169,7 @@ static inline int tftp(const int cmd, const struct hostent *host,
 	tftp_bufsize += 4;
 
 	if ((socketfd = socket(PF_INET, SOCK_DGRAM, 0)) < 0) {
-		perror_msg("socket");
+		bb_perror_msg("socket");
 		return EXIT_FAILURE;
 	}
 
@@ -223,7 +223,7 @@ static inline int tftp(const int cmd, const struct hostent *host,
 			}
 
 			if (too_long || ((&buf[tftp_bufsize - 1] - cp) < 6)) {
-				error_msg("too long remote-filename");
+				bb_error_msg("too long remote-filename");
 				break;
 			}
 
@@ -239,7 +239,7 @@ static inline int tftp(const int cmd, const struct hostent *host,
 			if (len != TFTP_BLOCKSIZE_DEFAULT) {
 
 			        if ((&buf[tftp_bufsize - 1] - cp) < 15) {
-				        error_msg("too long remote-filename");
+				        bb_error_msg("too long remote-filename");
 					break;
 				}
 
@@ -270,7 +270,7 @@ static inline int tftp(const int cmd, const struct hostent *host,
 				len = read(localfd, cp, tftp_bufsize - 4);
 
 				if (len < 0) {
-					perror_msg("read");
+					bb_perror_msg("read");
 					break;
 				}
 
@@ -298,7 +298,7 @@ static inline int tftp(const int cmd, const struct hostent *host,
 #endif
 			if (sendto(socketfd, buf, len, 0,
 					(struct sockaddr *) &sa, sizeof(sa)) < 0) {
-				perror_msg("send");
+				bb_perror_msg("send");
 				len = -1;
 				break;
 			}
@@ -325,7 +325,7 @@ static inline int tftp(const int cmd, const struct hostent *host,
 						(struct sockaddr *) &from, &fromlen);
 
 				if (len < 0) {
-					perror_msg("recvfrom");
+					bb_perror_msg("recvfrom");
 					break;
 				}
 
@@ -343,18 +343,18 @@ static inline int tftp(const int cmd, const struct hostent *host,
 				timeout = bb_tftp_num_retries;
 
 			case 0:
-				error_msg("timeout");
+				bb_error_msg("timeout");
 
 				if (timeout == 0) {
 					len = -1;
-					error_msg("last timeout");
+					bb_error_msg("last timeout");
 				} else {
 					timeout--;
 				}
 				break;
 
 			default:
-				perror_msg("select");
+				bb_perror_msg("select");
 				len = -1;
 			}
 
@@ -380,14 +380,14 @@ static inline int tftp(const int cmd, const struct hostent *host,
 			if (buf[4] != '\0') {
 				msg = &buf[4];
 				buf[tftp_bufsize - 1] = '\0';
-			} else if (tmp < (sizeof(tftp_error_msg) 
+			} else if (tmp < (sizeof(tftp_bb_error_msg) 
 					  / sizeof(char *))) {
 
-				msg = (char *) tftp_error_msg[tmp];
+				msg = (char *) tftp_bb_error_msg[tmp];
 			}
 
 			if (msg) {
-				error_msg("server says: %s", msg);
+				bb_error_msg("server says: %s", msg);
 			}
 
 			break;
@@ -429,11 +429,11 @@ static inline int tftp(const int cmd, const struct hostent *host,
 				 }
 				 /* FIXME:
 				  * we should send ERROR 8 */
-				 error_msg("bad server option");
+				 bb_error_msg("bad server option");
 				 break;
 			 }
 
-			 error_msg("warning: blksize not supported by server"
+			 bb_error_msg("warning: blksize not supported by server"
 				   " - reverting to 512");
 
 			 tftp_bufsize = TFTP_BLOCKSIZE_DEFAULT + 4;
@@ -447,7 +447,7 @@ static inline int tftp(const int cmd, const struct hostent *host,
 				len = write(localfd, &buf[4], len - 4);
 
 				if (len < 0) {
-					perror_msg("write");
+					bb_perror_msg("write");
 					break;
 				}
 
@@ -538,16 +538,16 @@ int tftp_main(int argc, char **argv)
 			break;
 #endif
 		case 'l': 
-			localfile = xstrdup(optarg);
+			localfile = bb_xstrdup(optarg);
 			break;
 		case 'r':
-			remotefile = xstrdup(optarg);
+			remotefile = bb_xstrdup(optarg);
 			break;
 		}
 	}
 
 	if ((cmd == 0) || (optind == argc)) {
-		show_usage();
+		bb_show_usage();
 	}
 	if(localfile && strcmp(localfile, "-") == 0) {
 	    fd = fileno((cmd==tftp_cmd_get)? stdout : stdin);
@@ -560,7 +560,7 @@ int tftp_main(int argc, char **argv)
 	    fd = open(localfile, flags, 0644);
 	}
 	if (fd < 0) {
-		perror_msg_and_die("local file");
+		bb_perror_msg_and_die("local file");
 	}
 
 	host = xgethostbyname(argv[optind]);
diff --git a/networking/traceroute.c b/networking/traceroute.c
index a9cad4baf..be9ea1d95 100644
--- a/networking/traceroute.c
+++ b/networking/traceroute.c
@@ -448,7 +448,7 @@ traceroute_main(int argc, char *argv[])
 		case 'm':
 			max_ttl = atoi(optarg);
 			if (max_ttl <= 1)
-				error_msg_and_die("max ttl must be >1.");
+				bb_error_msg_and_die("max ttl must be >1.");
 			break;
 		case 'n':
 			nflag++;
@@ -456,12 +456,12 @@ traceroute_main(int argc, char *argv[])
 		case 'p':
 			port = atoi(optarg);
 			if (port < 1)
-				error_msg_and_die("port must be >0.");
+				bb_error_msg_and_die("port must be >0.");
 			break;
 		case 'q':
 			nprobes = atoi(optarg);
 			if (nprobes < 1)
-				error_msg_and_die("nprobes must be >0.");
+				bb_error_msg_and_die("nprobes must be >0.");
 			break;
 		case 'r':
 			options |= SO_DONTROUTE;
@@ -476,7 +476,7 @@ traceroute_main(int argc, char *argv[])
 		case 't':
 			tos = atoi(optarg);
 			if (tos < 0 || tos > 255)
-				error_msg_and_die("tos must be 0 to 255.");
+				bb_error_msg_and_die("tos must be 0 to 255.");
 			break;
 		case 'v':
 #ifdef CONFIG_FEATURE_TRACEROUTE_VERBOSE
@@ -486,16 +486,16 @@ traceroute_main(int argc, char *argv[])
 		case 'w':
 			waittime = atoi(optarg);
 			if (waittime <= 1)
-				error_msg_and_die("wait must be >1 sec.");
+				bb_error_msg_and_die("wait must be >1 sec.");
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	argc -= optind;
 	argv += optind;
 
 	if (argc < 1)
-		show_usage();
+		bb_show_usage();
 
 	setlinebuf (stdout);
 
@@ -507,7 +507,7 @@ traceroute_main(int argc, char *argv[])
 	if (*++argv)
 		datalen = atoi(*argv);
 	if (datalen < 0 || datalen >= MAXPACKET - sizeof(struct opacket))
-		error_msg_and_die("packet size must be 0 <= s < %d.",
+		bb_error_msg_and_die("packet size must be 0 <= s < %d.",
 		    MAXPACKET - sizeof(struct opacket));
 	datalen += sizeof(struct opacket);
 	outpacket = (struct opacket *)xmalloc((unsigned)datalen);
@@ -520,7 +520,7 @@ traceroute_main(int argc, char *argv[])
 	ident = (getpid() & 0xffff) | 0x8000;
 
 	if ((sndsock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
-		perror_msg_and_die(can_not_create_raw_socket);
+		bb_perror_msg_and_die(bb_msg_can_not_create_raw_socket);
 
 	s = create_icmp_socket();
 
@@ -535,12 +535,12 @@ traceroute_main(int argc, char *argv[])
 #ifdef SO_SNDBUF
 	if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *)&datalen,
 		       sizeof(datalen)) < 0)
-		perror_msg_and_die("SO_SNDBUF");
+		bb_perror_msg_and_die("SO_SNDBUF");
 #endif
 #ifdef IP_HDRINCL
 	if (setsockopt(sndsock, IPPROTO_IP, IP_HDRINCL, (char *)&on,
 		       sizeof(on)) < 0)
-		perror_msg_and_die("IP_HDRINCL");
+		bb_perror_msg_and_die("IP_HDRINCL");
 #endif
 #ifdef CONFIG_FEATURE_TRACEROUTE_SO_DEBUG
 	if (options & SO_DEBUG)
@@ -556,11 +556,11 @@ traceroute_main(int argc, char *argv[])
 		from.sin_family = AF_INET;
 		from.sin_addr.s_addr = inet_addr(source);
 		if (from.sin_addr.s_addr == -1)
-			error_msg_and_die("unknown host %s", source);
+			bb_error_msg_and_die("unknown host %s", source);
 		outpacket->ip.ip_src = from.sin_addr;
 #ifndef IP_HDRINCL
 		if (bind(sndsock, (struct sockaddr *)&from, sizeof(from)) < 0)
-			perror_msg_and_die("bind");
+			bb_perror_msg_and_die("bind");
 #endif
 	}
 
diff --git a/networking/udhcp/dhcpc.c b/networking/udhcp/dhcpc.c
index fdcd17f79..c97e422e2 100644
--- a/networking/udhcp/dhcpc.c
+++ b/networking/udhcp/dhcpc.c
@@ -81,7 +81,7 @@ struct client_config_t client_config = {
 };
 
 #ifndef IN_BUSYBOX
-static void __attribute__ ((noreturn)) show_usage(void)
+static void __attribute__ ((noreturn)) bb_show_usage(void)
 {
 	printf(
 "Usage: udhcpc [OPTIONS]\n\n"
@@ -104,7 +104,7 @@ static void __attribute__ ((noreturn)) show_usage(void)
 	exit(0);
 }
 #else
-extern void show_usage(void) __attribute__ ((noreturn));
+extern void bb_show_usage(void) __attribute__ ((noreturn));
 #endif
 
 
@@ -298,7 +298,7 @@ int main(int argc, char *argv[])
 			exit_client(0);
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
diff --git a/networking/vconfig.c b/networking/vconfig.c
index 3bd9c3040..d58c375f7 100644
--- a/networking/vconfig.c
+++ b/networking/vconfig.c
@@ -1,3 +1,27 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * vconfig implementation for busybox
+ *
+ * Copyright (C) 2001  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+/* BB_AUDIT SUSv3 N/A */
+
 #include <stdlib.h>
 #include <unistd.h>
 #include <fcntl.h>
@@ -11,29 +35,14 @@
 #define VLAN_GROUP_ARRAY_LEN 4096
 #define SIOCSIFVLAN	0x8983		/* Set 802.1Q VLAN options 	*/
 
-/* This is rather specialized in that we're passing a 'char **' in
- * order to avoid the pointer dereference multiple times in the
- * actual calls below. */
-static unsigned long xstrtoul10(char **str, unsigned long max_val)
-{
-	char *endptr;
-	unsigned long r;
-
-	r = strtoul(str[2], &endptr, 10);
-	if ((r > max_val) || (*endptr != 0)) {
-		show_usage();
-	}
-	return r;
-}
-
 /* On entry, table points to the length of the current string plus
- * nul terminator plus data lenght for the subsequent entry.  The
+ * nul terminator plus data length for the subsequent entry.  The
  * return value is the last data entry for the matching string. */
 static const char *xfind_str(const char *table, const char *str)
 {
 	while (strcasecmp(str, table+1) != 0) {
 		if (!*(table += table[0])) {
-			show_usage();
+			bb_show_usage();
 		}
 	}
 	return table - 1;
@@ -89,12 +98,12 @@ int vconfig_main(int argc, char **argv)
 	int fd;
 
 	if (argc < 3) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	/* Don't bother closing the filedes.  It will be closed on cleanup. */
 	if (open(conf_file_name, O_RDONLY) < 0) { /* Is 802.1q is present? */
-	    perror_msg_and_die("open %s", conf_file_name);
+	    bb_perror_msg_and_die("open %s", conf_file_name);
 	}
 
 	memset(&ifr, 0, sizeof(struct vlan_ioctl_args));
@@ -103,16 +112,17 @@ int vconfig_main(int argc, char **argv)
 	p = xfind_str(cmds+2, *argv);
 	ifr.cmd = *p;
 	if (argc != p[-1]) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	if (ifr.cmd == SET_VLAN_NAME_TYPE_CMD) { /* set_name_type */
 		ifr.u.name_type = *xfind_str(name_types+1, argv[1]);
 	} else {
 		if (strlen(argv[1]) >= IF_NAMESIZE) {
-			error_msg_and_die("if_name >= %d chars\n", IF_NAMESIZE);
+			bb_error_msg_and_die("if_name >= %d chars\n", IF_NAMESIZE);
 		}
 		strcpy(ifr.device1, argv[1]);
+		p = argv[2];
 
 		/* I suppose one could try to combine some of the function calls below,
 		 * since ifr.u.flag, ifr.u.VID, and ifr.u.skb_priority are all same-sized
@@ -120,19 +130,19 @@ int vconfig_main(int argc, char **argv)
 		 * doing so wouldn't save that much space and would also make maintainence
 		 * more of a pain. */
 		if (ifr.cmd == SET_VLAN_FLAG_CMD) { /* set_flag */
-			ifr.u.flag = xstrtoul10(argv, 1);
+			ifr.u.flag = bb_xgetularg10_bnd(p, 0, 1);
 		} else if (ifr.cmd == ADD_VLAN_CMD) { /* add */
-			ifr.u.VID = xstrtoul10(argv, VLAN_GROUP_ARRAY_LEN-1);
+			ifr.u.VID = bb_xgetularg10_bnd(p, 0, VLAN_GROUP_ARRAY_LEN-1);
 		} else if (ifr.cmd != DEL_VLAN_CMD) { /* set_{egress|ingress}_map */
-			ifr.u.skb_priority = xstrtoul10(argv, ULONG_MAX);
-			ifr.vlan_qos = xstrtoul10(argv+1, 7);
+			ifr.u.skb_priority = bb_xgetularg10_bnd(p, 0, ULONG_MAX);
+			ifr.vlan_qos = bb_xgetularg10_bnd(argv[3], 0, 7);
 		}
 	}
 
 	if (((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 		|| (ioctl(fd, SIOCSIFVLAN, &ifr) < 0)
 		) {
-		perror_msg_and_die("socket or ioctl error for %s", *argv);
+		bb_perror_msg_and_die("socket or ioctl error for %s", *argv);
 	}
 
 	return 0;
diff --git a/networking/wget.c b/networking/wget.c
index 7154faa11..d68b16524 100644
--- a/networking/wget.c
+++ b/networking/wget.c
@@ -123,7 +123,7 @@ static char *safe_fgets(char *s, int size, FILE *stream)
 
 #define close_delete_and_die(s...) { \
 	close_and_delete_outfile(output, fname_out, do_continue); \
-	error_msg_and_die(s); }
+	bb_error_msg_and_die(s); }
 
 
 #ifdef CONFIG_FEATURE_WGET_AUTHENTICATION
@@ -140,7 +140,7 @@ char *base64enc(char *p, char *buf, int len) {
 
         while(*p) {
 				if (s >= buf+len-4)
-					error_msg_and_die("buffer overflow");
+					bb_error_msg_and_die("buffer overflow");
                 *(s++) = al[(*p >> 2) & 0x3F];
                 *(s++) = al[((*p << 4) & 0x30) | ((*(p+1) >> 4) & 0x0F)];
                 *s = *(s+1) = '=';
@@ -221,7 +221,7 @@ int wget_main(int argc, char **argv)
 				case LONG_HEADER: {
 					int arglen = strlen(optarg);
 					if(extra_headers_left - arglen - 2 <= 0)
-						error_msg_and_die("extra_headers buffer too small(need %i)", extra_headers_left - arglen);
+						bb_error_msg_and_die("extra_headers buffer too small(need %i)", extra_headers_left - arglen);
 					strcpy(extra_headers_ptr, optarg);
 					extra_headers_ptr += arglen;
 					extra_headers_left -= ( arglen + 2 );
@@ -236,12 +236,12 @@ int wget_main(int argc, char **argv)
 			}
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
 	if (argc - optind != 1)
-			show_usage();
+			bb_show_usage();
 
 	parse_url(argv[optind], &target);
 	server.host = target.host;
@@ -253,7 +253,7 @@ int wget_main(int argc, char **argv)
 	if (!noproxy) {
 		proxy = getenv(target.is_ftp ? "ftp_proxy" : "http_proxy");
 		if (proxy)
-			parse_url(xstrdup(proxy), &server);
+			parse_url(bb_xstrdup(proxy), &server);
 	}
 	
 	/* Guess an output filename */
@@ -262,7 +262,7 @@ int wget_main(int argc, char **argv)
 #ifdef CONFIG_FEATURE_WGET_STATUSBAR
 			curfile = 
 #endif
-			get_last_path_component(target.path);
+			bb_get_last_path_component(target.path);
 		if (fname_out==NULL || strlen(fname_out)<1) {
 			fname_out = 
 #ifdef CONFIG_FEATURE_WGET_STATUSBAR
@@ -274,11 +274,11 @@ int wget_main(int argc, char **argv)
 			fname_out = concat_path_file(dir_prefix, fname_out);
 #ifdef CONFIG_FEATURE_WGET_STATUSBAR
 	} else {
-		curfile = get_last_path_component(fname_out);
+		curfile = bb_get_last_path_component(fname_out);
 #endif
 	}
 	if (do_continue && !fname_out)
-		error_msg_and_die("cannot specify continue (-c) without a filename (-O)");
+		bb_error_msg_and_die("cannot specify continue (-c) without a filename (-O)");
 
 
 	/*
@@ -288,7 +288,7 @@ int wget_main(int argc, char **argv)
 		output = stdout;
 		quiet_flag = TRUE;
 	} else {
-		output = xfopen(fname_out, (do_continue ? "a" : "w"));
+		output = bb_xfopen(fname_out, (do_continue ? "a" : "w"));
 	}
 
 	/*
@@ -296,7 +296,7 @@ int wget_main(int argc, char **argv)
 	 */
 	if (do_continue) {
 		if (fstat(fileno(output), &sbuf) < 0)
-			perror_msg_and_die("fstat()");
+			bb_perror_msg_and_die("fstat()");
 		if (sbuf.st_size > 0)
 			beg_range = sbuf.st_size;
 		else
@@ -399,9 +399,9 @@ read_response:		if (fgets(buf, sizeof(buf), sfp) == NULL)
 				}
 				if (strcasecmp(buf, "location") == 0) {
 					if (s[0] == '/')
-						target.path = xstrdup(s+1);
+						target.path = bb_xstrdup(s+1);
 					else {
-						parse_url(xstrdup(s), &target);
+						parse_url(bb_xstrdup(s), &target);
 						if (!proxy) {
 							server.host = target.host;
 							server.port = target.port;
@@ -419,7 +419,7 @@ read_response:		if (fgets(buf, sizeof(buf), sfp) == NULL)
 		 *  FTP session
 		 */
 		if (! target.user)
-			target.user = xstrdup("anonymous:busybox@");
+			target.user = bb_xstrdup("anonymous:busybox@");
 
 		sfp = open_socket(server.host, server.port);
 		if (ftpcmd(NULL, NULL, sfp, buf) != 220)
@@ -496,7 +496,7 @@ read_response:		if (fgets(buf, sizeof(buf), sfp) == NULL)
 	do {
 		while ((filesize > 0 || !got_clen) && (n = safe_fread(buf, 1, chunked ? (filesize > sizeof(buf) ? sizeof(buf) : filesize) : sizeof(buf), dfp)) > 0) {
 			if (safe_fwrite(buf, 1, n, output) != n)
-				perror_msg_and_die("write error");
+				bb_perror_msg_and_die("write error");
 #ifdef CONFIG_FEATURE_WGET_STATUSBAR
 		statbytes+=n;
 #endif
@@ -512,7 +512,7 @@ read_response:		if (fgets(buf, sizeof(buf), sfp) == NULL)
 		}
 
 	if (n == 0 && ferror(dfp))
-		perror_msg_and_die("network read error");
+		bb_perror_msg_and_die("network read error");
 	} while (chunked);
 #ifdef CONFIG_FEATURE_WGET_STATUSBAR
 	if (quiet_flag==FALSE)
@@ -521,7 +521,7 @@ read_response:		if (fgets(buf, sizeof(buf), sfp) == NULL)
 	if (!proxy && target.is_ftp) {
 		fclose(dfp);
 		if (ftpcmd(NULL, NULL, sfp, buf) != 226)
-			error_msg_and_die("ftp error: %s", buf+4);
+			bb_error_msg_and_die("ftp error: %s", buf+4);
 		ftpcmd("QUIT", NULL, sfp, buf);
 	}
 	exit(EXIT_SUCCESS);
@@ -541,14 +541,14 @@ void parse_url(char *url, struct host_info *h)
 		h->host = url + 6;
 		h->is_ftp = 1;
 	} else
-		error_msg_and_die("not an http or ftp url: %s", url);
+		bb_error_msg_and_die("not an http or ftp url: %s", url);
 
 	sp = strchr(h->host, '/');
 	if (sp != NULL) {
 		*sp++ = '\0';
 		h->path = sp;
 	} else
-		h->path = xstrdup("");
+		h->path = bb_xstrdup("");
 
 	up = strrchr(h->host, '@');
 	if (up != NULL) {
@@ -580,7 +580,7 @@ FILE *open_socket(char *host, int port)
 	 * Get the server onto a stdio stream.
 	 */
 	if ((fp = fdopen(fd, "r+")) == NULL)
-		perror_msg_and_die("fdopen()");
+		bb_perror_msg_and_die("fdopen()");
 
 	return fp;
 }
@@ -609,7 +609,7 @@ char *gethdr(char *buf, size_t bufsiz, FILE *fp, int *istrunc)
 
 	/* verify we are at the end of the header name */
 	if (*s != ':')
-		error_msg_and_die("bad header line: %s", buf);
+		bb_error_msg_and_die("bad header line: %s", buf);
 
 	/* locate the start of the header value */
 	for (*s++ = '\0' ; *s == ' ' || *s == '\t' ; ++s)
@@ -646,7 +646,7 @@ static int ftpcmd(char *s1, char *s2, FILE *fp, char *buf)
 	do {
 		p = fgets(buf, 510, fp);
 		if (!p)
-			perror_msg_and_die("fgets()");
+			bb_perror_msg_and_die("fgets()");
 	} while (! isdigit(buf[0]) || buf[3] != ' ');
 	
 	return atoi(buf);
@@ -824,7 +824,7 @@ progressmeter(int flag)
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- *	$Id: wget.c,v 1.52 2003/03/11 18:03:39 andersen Exp $
+ *	$Id: wget.c,v 1.53 2003/03/19 09:12:39 mjn3 Exp $
  */
 
 
diff --git a/procps/free.c b/procps/free.c
index 4a5469b10..2f520e418 100644
--- a/procps/free.c
+++ b/procps/free.c
@@ -63,7 +63,7 @@ extern int free_main(int argc, char **argv)
 	}
 
 	if (argc > 1 && **(argv + 1) == '-')
-		show_usage();
+		bb_show_usage();
 
 	printf("%6s%13s%13s%13s%13s%13s\n", "", "total", "used", "free", 
 			"shared", "buffers");
diff --git a/procps/kill.c b/procps/kill.c
index c7a3c7f72..3d6fe80cb 100644
--- a/procps/kill.c
+++ b/procps/kill.c
@@ -44,7 +44,7 @@ extern int kill_main(int argc, char **argv)
 
 #ifdef CONFIG_KILLALL
 	/* Figure out what we are trying to do here */
-	whichApp = (strcmp(applet_name, "killall") == 0)? KILLALL : KILL; 
+	whichApp = (strcmp(bb_applet_name, "killall") == 0)? KILLALL : KILL; 
 #else
 	whichApp = KILL;
 #endif
@@ -54,7 +54,7 @@ extern int kill_main(int argc, char **argv)
 	argv++;
 	/* Parse any options */
 	if (argc < 1)
-		show_usage();
+		bb_show_usage();
 
 	while (argc > 0 && **argv == '-') {
 		while (*++(*argv)) {
@@ -87,11 +87,11 @@ extern int kill_main(int argc, char **argv)
 					}
 					return EXIT_SUCCESS;
 				case '-':
-					show_usage();
+					bb_show_usage();
 				default:
 					name = u_signal_names(*argv, &sig, 0);
 					if(name==NULL)
-						error_msg_and_die( "bad signal name: %s", *argv);
+						bb_error_msg_and_die( "bad signal name: %s", *argv);
 					argc--;
 					argv++;
 					goto do_it_now;
@@ -109,10 +109,10 @@ do_it_now:
 			int pid;
 
 			if (!isdigit(**argv))
-				perror_msg_and_die( "Bad PID");
+				bb_perror_msg_and_die( "Bad PID");
 			pid = strtol(*argv, NULL, 0);
 			if (kill(pid, sig) != 0) {
-				perror_msg( "Could not kill pid '%d'", pid);
+				bb_perror_msg( "Could not kill pid '%d'", pid);
 				errors++;
 			}
 			argv++;
@@ -130,7 +130,7 @@ do_it_now:
 			if (*pidList <= 0) {
 				errors++;
 				if (quiet==0)
-					error_msg( "%s: no process killed", *argv);
+					bb_error_msg( "%s: no process killed", *argv);
 				} else {
 					long *pl;
 
@@ -140,7 +140,7 @@ do_it_now:
 						if (kill(*pl, sig) != 0) {
 							errors++;
 							if (quiet==0)
-								perror_msg( "Could not kill pid '%ld'", *pl);
+								bb_perror_msg( "Could not kill pid '%ld'", *pl);
 						}
 					}
 			}
diff --git a/procps/pidof.c b/procps/pidof.c
index 8cd1a91c8..d77f7f02b 100644
--- a/procps/pidof.c
+++ b/procps/pidof.c
@@ -46,7 +46,7 @@ extern int pidof_main(int argc, char **argv)
 				single_flag = 1;
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
diff --git a/procps/renice.c b/procps/renice.c
index ec35bdcde..a81156eea 100644
--- a/procps/renice.c
+++ b/procps/renice.c
@@ -32,7 +32,7 @@ extern int renice_main(int argc, char **argv)
 {
 	int prio, status = EXIT_SUCCESS;
 	
-	if (argc < 3)	show_usage();
+	if (argc < 3)	bb_show_usage();
 		
 	prio = atoi(*++argv);
 	if (prio > 20)		prio = 20;
@@ -45,7 +45,7 @@ extern int renice_main(int argc, char **argv)
 		if (setpriority(PRIO_PROCESS, ps, prio) == 0) {
 			printf("%d: old priority %d, new priority %d\n", ps, oldp, prio );
 		} else {
-			perror_msg("%d: setpriority", ps);
+			bb_perror_msg("%d: setpriority", ps);
 			status = EXIT_FAILURE;
 		}
 	}
diff --git a/procps/top.c b/procps/top.c
index 4204deaf2..b70a42a72 100644
--- a/procps/top.c
+++ b/procps/top.c
@@ -155,11 +155,11 @@ static unsigned long Hertz;
 
 #define FILE_TO_BUF(filename, fd) do{                           \
     if (fd == -1 && (fd = open(filename, O_RDONLY)) == -1) {    \
-	perror_msg_and_die("/proc not be mounted?");            \
+	bb_perror_msg_and_die("/proc not be mounted?");            \
     }                                                           \
     lseek(fd, 0L, SEEK_SET);                                    \
     if ((local_n = read(fd, buf, sizeof buf - 1)) < 0) {        \
-	perror_msg_and_die("%s", filename);                     \
+	bb_perror_msg_and_die("%s", filename);                     \
     }                                                           \
     buf[local_n] = '\0';                                        \
 }while(0)
@@ -167,7 +167,7 @@ static unsigned long Hertz;
 #define FILE_TO_BUF2(filename, fd) do{                          \
     lseek(fd, 0L, SEEK_SET);                                    \
     if ((local_n = read(fd, buf, sizeof buf - 1)) < 0) {        \
-	perror_msg_and_die("%s", filename);                     \
+	bb_perror_msg_and_die("%s", filename);                     \
     }                                                           \
     buf[local_n] = '\0';                                        \
 }while(0)
@@ -313,19 +313,19 @@ static unsigned long display_generic(void)
 	unsigned long total, used, mfree, shared, buffers, cached;
 
 	/* read memory info */
-	fp = xfopen("meminfo", "r");
+	fp = bb_xfopen("meminfo", "r");
 	fgets(buf, sizeof(buf), fp);	/* skip first line */
 
 	if (fscanf(fp, "Mem: %lu %lu %lu %lu %lu %lu",
 		   &total, &used, &mfree, &shared, &buffers, &cached) != 6) {
-		error_msg_and_die("failed to read '%s'", "meminfo");
+		bb_error_msg_and_die("failed to read '%s'", "meminfo");
 	}
 	fclose(fp);
 	
 	/* read load average */
-	fp = xfopen("loadavg", "r");
+	fp = bb_xfopen("loadavg", "r");
 	if (fscanf(fp, "%f %f %f", &avg1, &avg2, &avg3) != 3) {
-		error_msg_and_die("failed to read '%s'", "loadavg");
+		bb_error_msg_and_die("failed to read '%s'", "loadavg");
 	}
 	fclose(fp);
 
@@ -447,7 +447,7 @@ int top_main(int argc, char **argv)
 		    interval = atoi(optarg);
 		    break;
 		default:
-		    show_usage();
+		    bb_show_usage();
 	    }
 	}
 
@@ -461,7 +461,7 @@ int top_main(int argc, char **argv)
 #endif
 	/* change to /proc */
 	if (chdir("/proc") < 0) {
-		perror_msg_and_die("chdir('/proc')");
+		bb_perror_msg_and_die("chdir('/proc')");
 	}
 #if defined CONFIG_FEATURE_USE_TERMIOS
 	tcgetattr(0, (void *) &initial_settings);
@@ -508,7 +508,7 @@ int top_main(int argc, char **argv)
 			memcpy(top + n, p, sizeof(procps_status_t));
 		}
 		if (ntop == 0) {
-		perror_msg_and_die("scandir('/proc')");
+		bb_perror_msg_and_die("scandir('/proc')");
 	}
 #ifdef FEATURE_CPU_USAGE_PERCENTAGE
 		if(!Hertz) {
diff --git a/shell/ash.c b/shell/ash.c
index 828a88872..fb65c2da0 100644
--- a/shell/ash.c
+++ b/shell/ash.c
@@ -1329,13 +1329,13 @@ static void setalias(char *name, char *val)
 		if (!(ap->flag & ALIASINUSE)) {
 			free(ap->val);
 		}
-		ap->val = xstrdup(val);
+		ap->val = bb_xstrdup(val);
 		ap->flag &= ~ALIASDEAD;
 	} else {
 		/* not found */
 		ap = xmalloc(sizeof(struct alias));
-		ap->name = xstrdup(name);
-		ap->val = xstrdup(val);
+		ap->name = bb_xstrdup(name);
+		ap->val = bb_xstrdup(val);
 		ap->flag = 0;
 		ap->next = 0;
 		*app = ap;
@@ -1829,7 +1829,7 @@ static void setpwd(const char *val, int setold)
 	if (!val)
 		getpwd();
 	else
-		curdir = simplify_path(val);
+		curdir = bb_simplify_path(val);
 	if (cated)
 		free(cated);
 	INTON;
@@ -3285,7 +3285,7 @@ static void tryexec(char *cmd, char **argv, char **envp)
 	char *name = cmd;
 
 #ifdef CONFIG_FEATURE_SH_APPLETS_ALWAYS_WIN
-	name = get_last_path_component(name);
+	name = bb_get_last_path_component(name);
 	if(find_applet_by_name(name) != NULL)
 		flg_bb = 1;
 #else
@@ -7552,7 +7552,7 @@ static int dotcmd(int argc, char **argv)
 	exitstatus = 0;
 
 	for (sp = cmdenviron; sp; sp = sp->next)
-		setvareq(xstrdup(sp->text), VSTRFIXED | VTEXTFIXED);
+		setvareq(bb_xstrdup(sp->text), VSTRFIXED | VTEXTFIXED);
 
 	if (argc >= 2) {	/* That's what SVR2 does */
 		char *fullname;
@@ -7950,7 +7950,7 @@ static int umaskcmd(int argc, char **argv)
 			umask(mask);
 		} else {
 			mask = ~mask & 0777;
-			if (!parse_mode(ap, &mask)) {
+			if (!bb_parse_mode(ap, &mask)) {
 				error("Illegal mode: %s", ap);
 			}
 			umask(~mask & 0777);
@@ -8795,7 +8795,7 @@ static void setparam(char **argv)
 	for (nparam = 0; argv[nparam]; nparam++);
 	ap = newparam = xmalloc((nparam + 1) * sizeof *ap);
 	while (*argv) {
-		*ap++ = xstrdup(*argv++);
+		*ap++ = bb_xstrdup(*argv++);
 	}
 	*ap = NULL;
 	freeparam(&shellparam);
@@ -11429,7 +11429,7 @@ static void opentrace()
 #else
 	strcpy(s, "./trace");
 #endif							/* not_this_way */
-	if ((tracefile = wfopen(s, "a")) == NULL)
+	if ((tracefile = bb_wfopen(s, "a")) == NULL)
 		return;
 #ifdef O_APPEND
 	if ((flags = fcntl(fileno(tracefile), F_GETFL, 0)) >= 0)
@@ -11482,7 +11482,7 @@ static int trapcmd(int argc, char **argv)
 			if (action[0] == '-' && action[1] == '\0')
 				action = NULL;
 			else
-				action = xstrdup(action);
+				action = bb_xstrdup(action);
 		}
 		free(trap[signo]);
 		trap[signo] = action;
@@ -11700,7 +11700,7 @@ static void initvar()
 			vpp = hashvar(ip->text);
 			vp->next = *vpp;
 			*vpp = vp;
-			vp->text = xstrdup(ip->text);
+			vp->text = bb_xstrdup(ip->text);
 			vp->flags = ip->flags;
 			vp->func = ip->func;
 		}
@@ -11713,7 +11713,7 @@ static void initvar()
 		vpp = hashvar("PS1=$ ");
 		vps1.next = *vpp;
 		*vpp = &vps1;
-		vps1.text = xstrdup(geteuid()? "PS1=$ " : "PS1=# ");
+		vps1.text = bb_xstrdup(geteuid()? "PS1=$ " : "PS1=# ");
 		vps1.flags = VSTRFIXED | VTEXTFIXED;
 	}
 #endif
@@ -11833,7 +11833,7 @@ static void listsetvar(struct strlist *mylist)
 
 	INTOFF;
 	for (lp = mylist; lp; lp = lp->next) {
-		setvareq(xstrdup(lp->text), 0);
+		setvareq(bb_xstrdup(lp->text), 0);
 	}
 	INTON;
 }
@@ -11996,7 +11996,7 @@ static void mklocal(char *name)
 		vp = *findvar(vpp, name);
 		if (vp == NULL) {
 			if (strchr(name, '='))
-				setvareq(xstrdup(name), VSTRFIXED);
+				setvareq(bb_xstrdup(name), VSTRFIXED);
 			else
 				setvar(name, NULL, VSTRFIXED);
 			vp = *vpp;	/* the new variable */
@@ -12007,7 +12007,7 @@ static void mklocal(char *name)
 			lvp->flags = vp->flags;
 			vp->flags |= VSTRFIXED | VTEXTFIXED;
 			if (strchr(name, '='))
-				setvareq(xstrdup(name), 0);
+				setvareq(bb_xstrdup(name), 0);
 		}
 	}
 	lvp->vp = vp;
@@ -12243,7 +12243,7 @@ int letcmd(int argc, char **argv)
 			return 0;
 		}
 		snprintf(p, 12, "%ld", result);
-		setvar(argv[1], xstrdup(p), 0);
+		setvar(argv[1], bb_xstrdup(p), 0);
 	} else if (argc >= 3)
 		synerror("invalid operand");
 	return !result;
diff --git a/shell/cmdedit.c b/shell/cmdedit.c
index 2ea61614d..3cbdce0ef 100644
--- a/shell/cmdedit.c
+++ b/shell/cmdedit.c
@@ -330,7 +330,7 @@ static void parse_prompt(const char *prmt_ptr)
 	char *pbuf;
 
 	if (!pwd_buf) {
-		pwd_buf=(char *)unknown;
+		pwd_buf=(char *)bb_msg_unknown;
 	}
 
 	while (*prmt_ptr) {
@@ -341,7 +341,7 @@ static void parse_prompt(const char *prmt_ptr)
 			const char *cp = prmt_ptr;
 			int l;
 			
-			c = process_escape_sequence(&prmt_ptr);
+			c = bb_process_escape_sequence(&prmt_ptr);
 			if(prmt_ptr==cp) {
 			  if (*cp == 0)
 				break;
@@ -430,7 +430,7 @@ static void parse_prompt(const char *prmt_ptr)
 		if (flg_not_length == ']')
 			sub_len++;
 	}
-	if(pwd_buf!=(char *)unknown)
+	if(pwd_buf!=(char *)bb_msg_unknown)
 		free(pwd_buf);
 	cmdedit_prompt = prmt_mem_ptr;
 	cmdedit_prmt_len = prmt_len - sub_len;
@@ -520,8 +520,8 @@ static void cmdedit_init(void)
 		my_euid = geteuid();
 		entry = getpwuid(my_euid);
 		if (entry) {
-			user_buf = xstrdup(entry->pw_name);
-			home_pwd_buf = xstrdup(entry->pw_dir);
+			user_buf = bb_xstrdup(entry->pw_name);
+			home_pwd_buf = bb_xstrdup(entry->pw_dir);
 		}
 #endif
 
@@ -598,7 +598,7 @@ static char **username_tab_completion(char *ud, int *num_matches)
 			/* Null usernames should result in all users as possible completions. */
 			if ( /*!userlen || */ !strncmp(ud, entry->pw_name, userlen)) {
 
-                               bb_asprintf(&temp, "~%s/", entry->pw_name);
+                               bb_xasprintf(&temp, "~%s/", entry->pw_name);
 				matches = xrealloc(matches, (nm + 1) * sizeof(char *));
 
 				matches[nm++] = temp;
@@ -647,7 +647,7 @@ static int path_parse(char ***p, int flags)
 	*p = xmalloc(npth * sizeof(char *));
 
 	tmp = pth;
-	(*p)[0] = xstrdup(tmp);
+	(*p)[0] = bb_xstrdup(tmp);
 	npth = 1;			/* count words is + 1 count ':' */
 
 	for (;;) {
@@ -1071,7 +1071,7 @@ static void input_tab(int *lastWasTab)
 			qsort(matches, num_matches, sizeof(char *), match_compare);
 
 			/* find minimal match */
-			tmp = xstrdup(matches[0]);
+			tmp = bb_xstrdup(matches[0]);
 			for (tmp1 = tmp; *tmp1; tmp1++)
 				for (len_found = 1; len_found < num_matches; len_found++)
 					if (matches[len_found][(tmp1 - tmp)] != *tmp1) {
@@ -1132,7 +1132,7 @@ static void get_previous_history(void)
 {
 	if(command_ps[0] != 0 || history[cur_history] == 0) {
 		free(history[cur_history]);
-		history[cur_history] = xstrdup(command_ps);
+		history[cur_history] = bb_xstrdup(command_ps);
 	}
 	cur_history--;
 }
@@ -1166,12 +1166,11 @@ extern void load_history ( const char *fromfile )
 	if (( fp = fopen ( fromfile, "r" ))) {
 	
 		for ( hi = 0; hi < MAX_HISTORY; ) {
-			char * hl = get_line_from_file(fp);
+			char * hl = bb_get_chomped_line_from_file(fp);
 			int l;
 
 			if(!hl)
 				break;
-			chomp(hl);
 			l = strlen(hl);
 			if(l >= BUFSIZ)
 				hl[BUFSIZ-1] = 0;
@@ -1500,7 +1499,7 @@ rewrite_line:
 			for(i = 0; i < (MAX_HISTORY-1); i++)
 				history[i] = history[i+1];
 		}
-		history[i++] = xstrdup(command);
+		history[i++] = bb_xstrdup(command);
 		cur_history = i;
 		n_history = i;
 #if defined(CONFIG_FEATURE_SH_FANCY_PROMPT)
@@ -1535,7 +1534,7 @@ rewrite_line:
 
 #ifdef TEST
 
-const char *applet_name = "debug stuff usage";
+const char *bb_applet_name = "debug stuff usage";
 const char *memory_exhausted = "Memory exhausted";
 
 #ifdef CONFIG_FEATURE_NONPRINTABLE_INVERSE_PUT
diff --git a/shell/hush.c b/shell/hush.c
index e20bf7a06..94b29c03d 100644
--- a/shell/hush.c
+++ b/shell/hush.c
@@ -110,7 +110,7 @@
 #include "busybox.h"
 #include "cmdedit.h"
 #else
-#define applet_name "hush"
+#define bb_applet_name "hush"
 #include "standalone.h"
 #define hush_main main
 #undef CONFIG_FEATURE_SH_FANCY_PROMPT
@@ -320,7 +320,7 @@ static inline void debug_printf(const char *format, ...) { }
 #define final_printf debug_printf
 
 static void __syntax(char *file, int line) {
-	error_msg("syntax error %s:%d", file, line);
+	bb_error_msg("syntax error %s:%d", file, line);
 }
 #define syntax() __syntax(__FILE__, __LINE__)
 
@@ -441,11 +441,11 @@ static struct built_in_command bltins[] = {
 
 static const char *set_cwd(void)
 {
-	if(cwd==unknown)
+	if(cwd==bb_msg_unknown)
 		cwd = NULL;     /* xgetcwd(arg) called free(arg) */
 	cwd = xgetcwd((char *)cwd);
 	if (!cwd)
-		cwd = unknown;
+		cwd = bb_msg_unknown;
 	return cwd;
 }
 
@@ -548,7 +548,7 @@ static int builtin_export(struct child_prog *child)
 		}
 	}
 	if (res<0)
-		perror_msg("export");
+		bb_perror_msg("export");
 	else if(res==0)
 		res = set_local_var(name, 1);
 	else
@@ -573,12 +573,12 @@ static int builtin_fg_bg(struct child_prog *child)
 			}
 		}
 		if (!pi) {
-			error_msg("%s: no current job", child->argv[0]);
+			bb_error_msg("%s: no current job", child->argv[0]);
 			return EXIT_FAILURE;
 		}
 	} else {
 		if (sscanf(child->argv[1], "%%%d", &jobnum) != 1) {
-			error_msg("%s: bad argument '%s'", child->argv[0], child->argv[1]);
+			bb_error_msg("%s: bad argument '%s'", child->argv[0], child->argv[1]);
 			return EXIT_FAILURE;
 		}
 		for (pi = job_list; pi; pi = pi->next) {
@@ -587,7 +587,7 @@ static int builtin_fg_bg(struct child_prog *child)
 			}
 		}
 		if (!pi) {
-			error_msg("%s: %d: no such job", child->argv[0], jobnum);
+			bb_error_msg("%s: %d: no such job", child->argv[0], jobnum);
 			return EXIT_FAILURE;
 		}
 	}
@@ -605,7 +605,7 @@ static int builtin_fg_bg(struct child_prog *child)
 		if (i == ESRCH) {
 			remove_bg_job(pi);
 		} else {
-			perror_msg("kill (SIGCONT)");
+			bb_perror_msg("kill (SIGCONT)");
 		}
 	}
 
@@ -728,7 +728,7 @@ static int builtin_source(struct child_prog *child)
 	/* XXX search through $PATH is missing */
 	input = fopen(child->argv[1], "r");
 	if (!input) {
-		error_msg("Couldn't open file '%s'", child->argv[1]);
+		bb_error_msg("Couldn't open file '%s'", child->argv[1]);
 		return EXIT_FAILURE;
 	}
 
@@ -996,7 +996,7 @@ static void mark_closed(int fd)
 {
 	struct close_me *tmp;
 	if (close_me_head == NULL || close_me_head->fd != fd)
-		error_msg_and_die("corrupt close_me");
+		bb_error_msg_and_die("corrupt close_me");
 	tmp = close_me_head;
 	close_me_head = close_me_head->next;
 	free(tmp);
@@ -1029,7 +1029,7 @@ static int setup_redirects(struct child_prog *prog, int squirrel[])
 			if (openfd < 0) {
 			/* this could get lost if stderr has been redirected, but
 			   bash and ash both lose it as well (though zsh doesn't!) */
-				perror_msg("error opening %s", redir->word.gl_pathv[0]);
+				bb_perror_msg("error opening %s", redir->word.gl_pathv[0]);
 				return 1;
 			}
 		} else {
@@ -1125,14 +1125,14 @@ static void pseudo_exec(struct child_prog *child)
 #ifdef CONFIG_FEATURE_SH_APPLETS_ALWAYS_WIN
 			/* Following discussions from November 2000 on the busybox mailing
 			 * list, the default configuration, (without
-			 * get_last_path_component()) lets the user force use of an
+			 * bb_get_last_path_component()) lets the user force use of an
 			 * external command by specifying the full (with slashes) filename.
 			 * If you enable CONFIG_FEATURE_SH_APPLETS_ALWAYS_WIN, then applets
 			 * _aways_ override external commands, so if you want to run
 			 * /bin/cat, it will use BusyBox cat even if /bin/cat exists on the
 			 * filesystem and is _not_ busybox.  Some systems may want this,
 			 * most do not.  */
-			name = get_last_path_component(name);
+			name = bb_get_last_path_component(name);
 #endif
 			/* Count argc for use in a second... */
 			for(argc_l=0;*argv_l!=NULL; argv_l++, argc_l++);
@@ -1143,7 +1143,7 @@ static void pseudo_exec(struct child_prog *child)
 #endif
 		debug_printf("exec of %s\n",child->argv[0]);
 		execvp(child->argv[0],child->argv);
-		perror_msg("couldn't exec: %s",child->argv[0]);
+		bb_perror_msg("couldn't exec: %s",child->argv[0]);
 		_exit(1);
 	} else if (child->group) {
 		debug_printf("runtime nesting to group\n");
@@ -1292,11 +1292,11 @@ static int checkjobs(struct pipe* fg_pipe)
 	}
 
 	if (childpid == -1 && errno != ECHILD)
-		perror_msg("waitpid");
+		bb_perror_msg("waitpid");
 
 	/* move the shell to the foreground */
 	//if (interactive && tcsetpgrp(shell_terminal, getpgid(0)))
-	//	perror_msg("tcsetpgrp-2");
+	//	bb_perror_msg("tcsetpgrp-2");
 	return -1;
 }
 
@@ -1381,7 +1381,7 @@ static int run_pipe_real(struct pipe *pi)
 				 * variable. */
 				int export_me=0;
 				char *name, *value;
-				name = xstrdup(child->argv[i]);
+				name = bb_xstrdup(child->argv[i]);
 				debug_printf("Local environment set: %s\n", name);
 				value = strchr(name, '=');
 				if (value)
@@ -1441,7 +1441,7 @@ static int run_pipe_real(struct pipe *pi)
 
 		/* pipes are inserted between pairs of commands */
 		if ((i + 1) < pi->num_progs) {
-			if (pipe(pipefds)<0) perror_msg_and_die("pipe");
+			if (pipe(pipefds)<0) bb_perror_msg_and_die("pipe");
 			nextout = pipefds[1];
 		} else {
 			nextout=1;
@@ -1626,11 +1626,11 @@ static int run_list_real(struct pipe *pi)
 			if (interactive) {
 				/* move the new process group into the foreground */
 				if (tcsetpgrp(shell_terminal, pi->pgrp) && errno != ENOTTY)
-					perror_msg("tcsetpgrp-3");
+					bb_perror_msg("tcsetpgrp-3");
 				rcode = checkjobs(pi);
 				/* move the shell to the foreground */
 				if (tcsetpgrp(shell_terminal, getpgid(0)) && errno != ENOTTY)
-					perror_msg("tcsetpgrp-4");
+					bb_perror_msg("tcsetpgrp-4");
 			} else {
 				rcode = checkjobs(pi);
 			}
@@ -1825,9 +1825,9 @@ static int xglob(o_string *dest, int flags, glob_t *pglob)
 		debug_printf("globhack returned %d\n",gr);
 	}
 	if (gr == GLOB_NOSPACE)
-		error_msg_and_die("out of memory during glob");
+		bb_error_msg_and_die("out of memory during glob");
 	if (gr != 0) { /* GLOB_ABORTED ? */
-		error_msg("glob(3) error %d",gr);
+		bb_error_msg("glob(3) error %d",gr);
 	}
 	/* globprint(glob_target); */
 	return gr;
@@ -1881,7 +1881,7 @@ static int set_local_var(const char *s, int flg_export)
 				result++;
 		} else {
 			if(cur->flg_read_only) {
-				error_msg("%s: readonly variable", name);
+				bb_error_msg("%s: readonly variable", name);
 				result = -1;
 			} else {
 				if(flg_export>0 || cur->flg_export>1)
@@ -1935,7 +1935,7 @@ static void unset_local_var(const char *name)
 		if(cur!=0) {
 			struct variables *next = top_vars;
 			if(cur->flg_read_only) {
-				error_msg("%s: readonly variable", name);
+				bb_error_msg("%s: readonly variable", name);
 				return;
 			} else {
 				if(cur->flg_export)
@@ -2139,7 +2139,7 @@ static int done_word(o_string *dest, struct p_context *ctx)
 	if (ctx->pending_redirect) {
 		ctx->pending_redirect=NULL;
 		if (glob_target->gl_pathc != 1) {
-			error_msg("ambiguous redirect");
+			bb_error_msg("ambiguous redirect");
 			return 1;
 		}
 	} else {
@@ -2231,7 +2231,7 @@ static int redirect_dup_num(struct in_str *input)
 	}
 	if (ok) return d;
 
-	error_msg("ambiguous redirect");
+	bb_error_msg("ambiguous redirect");
 	return -2;
 }
 
@@ -2267,14 +2267,14 @@ FILE *generate_stream_from_list(struct pipe *head)
 	FILE *pf;
 #if 1
 	int pid, channel[2];
-	if (pipe(channel)<0) perror_msg_and_die("pipe");
+	if (pipe(channel)<0) bb_perror_msg_and_die("pipe");
 #if !defined(__UCLIBC__) || defined(__UCLIBC_HAS_MMU__)
 	pid=fork();
 #else
 	pid=vfork();
 #endif
 	if (pid<0) {
-		perror_msg_and_die("fork");
+		bb_perror_msg_and_die("fork");
 	} else if (pid==0) {
 		close(channel[0]);
 		if (channel[1] != 1) {
@@ -2450,7 +2450,7 @@ static int handle_dollar(o_string *dest, struct p_context *ctx, struct in_str *i
 		case '-':
 		case '_':
 			/* still unhandled, but should be eventually */
-			error_msg("unhandled syntax: $%c",ch);
+			bb_error_msg("unhandled syntax: $%c",ch);
 			return 1;
 			break;
 		default:
@@ -2811,7 +2811,7 @@ int hush_main(int argc, char **argv)
 						"   or: sh -c command [args]...\n\n");
 				exit(EXIT_FAILURE);
 #else
-				show_usage();
+				bb_show_usage();
 #endif
 		}
 	}
@@ -2845,12 +2845,12 @@ int hush_main(int argc, char **argv)
 	debug_printf("\nrunning script '%s'\n", argv[optind]);
 	global_argv = argv+optind;
 	global_argc = argc-optind;
-	input = xfopen(argv[optind], "r");
+	input = bb_xfopen(argv[optind], "r");
 	opt = parse_file_outer(input);
 
 #ifdef CONFIG_FEATURE_CLEAN_UP
 	fclose(input);
-	if (cwd && cwd != unknown)
+	if (cwd && cwd != bb_msg_unknown)
 		free((char*)cwd);
 	{
 		struct variables *cur, *tmp;
diff --git a/shell/lash.c b/shell/lash.c
index 35929898e..8f864b355 100644
--- a/shell/lash.c
+++ b/shell/lash.c
@@ -246,7 +246,7 @@ static int builtin_cd(struct child_prog *child)
 	}
 	cwd = xgetcwd((char *)cwd);
 	if (!cwd)
-		cwd = unknown;
+		cwd = bb_msg_unknown;
 	return EXIT_SUCCESS;
 }
 
@@ -284,12 +284,12 @@ static int builtin_fg_bg(struct child_prog *child)
 			}
 		}
 		if (!job) {
-			error_msg("%s: no current job", child->argv[0]);
+			bb_error_msg("%s: no current job", child->argv[0]);
 			return EXIT_FAILURE;
 		}
 	} else {
 		if (sscanf(child->argv[1], "%%%d", &jobnum) != 1) {
-			error_msg("%s: bad argument '%s'", child->argv[0], child->argv[1]);
+			bb_error_msg("%s: bad argument '%s'", child->argv[0], child->argv[1]);
 			return EXIT_FAILURE;
 		}
 		for (job = child->family->job_list->head; job; job = job->next) {
@@ -298,7 +298,7 @@ static int builtin_fg_bg(struct child_prog *child)
 			}
 		}
 		if (!job) {
-			error_msg("%s: %d: no such job", child->argv[0], jobnum);
+			bb_error_msg("%s: %d: no such job", child->argv[0], jobnum);
 			return EXIT_FAILURE;
 		}
 	}
@@ -320,7 +320,7 @@ static int builtin_fg_bg(struct child_prog *child)
 		if (i == ESRCH) {
 			remove_job(&job_list, job);
 		} else {
-			perror_msg("kill (SIGCONT)");
+			bb_perror_msg("kill (SIGCONT)");
 		}
 	}
 
@@ -371,7 +371,7 @@ static int builtin_pwd(struct child_prog *dummy)
 {
 	cwd = xgetcwd((char *)cwd);
 	if (!cwd)
-		cwd = unknown;
+		cwd = bb_msg_unknown;
 	puts(cwd);
 	return EXIT_SUCCESS;
 }
@@ -489,7 +489,7 @@ static void mark_closed(int fd)
 {
 	struct close_me *tmp;
 	if (close_me_head == NULL || close_me_head->fd != fd)
-		error_msg_and_die("corrupt close_me");
+		bb_error_msg_and_die("corrupt close_me");
 	tmp = close_me_head;
 	close_me_head = close_me_head->next;
 	free(tmp);
@@ -599,7 +599,7 @@ static void checkjobs(struct jobset *j_list)
 	}
 
 	if (childpid == -1 && errno != ECHILD)
-		perror_msg("waitpid");
+		bb_perror_msg("waitpid");
 }
 
 /* squirrel != NULL means we squirrel away copies of stdin, stdout,
@@ -628,7 +628,7 @@ static int setup_redirects(struct child_prog *prog, int squirrel[])
 		if (openfd < 0) {
 			/* this could get lost if stderr has been redirected, but
 			   bash and ash both lose it as well (though zsh doesn't!) */
-			perror_msg("error opening %s", redir->filename);
+			bb_perror_msg("error opening %s", redir->filename);
 			return 1;
 		}
 
@@ -803,7 +803,7 @@ static int expand_arguments(char *command)
 	while( command && command[ix]) {
 		if (command[ix] == '\\') {
 			const char *tmp = command+ix+1;
-			command[ix] = process_escape_sequence(  &tmp );
+			command[ix] = bb_process_escape_sequence(  &tmp );
 			memmove(command+ix + 1, tmp, strlen(tmp)+1);
 		}
 		ix++;
@@ -816,7 +816,7 @@ static int expand_arguments(char *command)
 
 	/* We need a clean copy, so strsep can mess up the copy while
 	 * we write stuff into the original (in a minute) */
-	cmd = cmd_copy = xstrdup(command);
+	cmd = cmd_copy = bb_xstrdup(command);
 	*command = '\0';
 	for (ix = 0, tmpcmd = cmd; 
 			(tmpcmd = strsep_space(cmd, &ix)) != NULL; cmd += ix, ix=0) {
@@ -829,13 +829,13 @@ static int expand_arguments(char *command)
 		if (retval == GLOB_NOSPACE) {
 			/* Mem may have been allocated... */
 			globfree (&expand_result);
-			error_msg(out_of_space);
+			bb_error_msg(out_of_space);
 			return FALSE;
 		} else if (retval != 0) {
 			/* Some other error.  GLOB_NOMATCH shouldn't
 			 * happen because of the GLOB_NOCHECK flag in 
 			 * the glob call. */
-			error_msg("syntax error");
+			bb_error_msg("syntax error");
 			return FALSE;
 		} else {
 			/* Convert from char** (one word per string) to a simple char*,
@@ -843,7 +843,7 @@ static int expand_arguments(char *command)
 			for (i=0; i < expand_result.gl_pathc; i++) {
 				length=strlen(expand_result.gl_pathv[i]);
 				if (total_length+length+1 >= BUFSIZ) {
-					error_msg(out_of_space);
+					bb_error_msg(out_of_space);
 					return FALSE;
 				}
 				strcat(command+total_length, " ");
@@ -930,7 +930,7 @@ static int expand_arguments(char *command)
 			int subst_len = strlen(var);
 			int trail_len = strlen(src);
 			if (dst+subst_len+trail_len >= command+BUFSIZ) {
-				error_msg(out_of_space);
+				bb_error_msg(out_of_space);
 				return FALSE;
 			}
 			/* Move stuff to the end of the string to accommodate
@@ -1006,7 +1006,7 @@ static int parse_command(char **command_ptr, struct job *job, int *inbg)
 			if (*src == '\\') {
 				src++;
 				if (!*src) {
-					error_msg("character expected after \\");
+					bb_error_msg("character expected after \\");
 					free_job(job);
 					return 1;
 				}
@@ -1090,7 +1090,7 @@ static int parse_command(char **command_ptr, struct job *job, int *inbg)
 					chptr++;
 
 				if (!*chptr) {
-					error_msg("file name expected after %c", *(src-1));
+					bb_error_msg("file name expected after %c", *(src-1));
 					free_job(job);
 					job->num_progs=0;
 					return 1;
@@ -1109,7 +1109,7 @@ static int parse_command(char **command_ptr, struct job *job, int *inbg)
 				if (*prog->argv[argc_l] || saw_quote)
 					argc_l++;
 				if (!argc_l) {
-					error_msg("empty command in pipe");
+					bb_error_msg("empty command in pipe");
 					free_job(job);
 					job->num_progs=0;
 					return 1;
@@ -1136,7 +1136,7 @@ static int parse_command(char **command_ptr, struct job *job, int *inbg)
 					src++;
 
 				if (!*src) {
-					error_msg("empty command in pipe");
+					bb_error_msg("empty command in pipe");
 					free_job(job);
 					job->num_progs=0;
 					return 1;
@@ -1155,7 +1155,7 @@ static int parse_command(char **command_ptr, struct job *job, int *inbg)
 			case '\\':
 				src++;
 				if (!*src) {
-					error_msg("character expected after \\");
+					bb_error_msg("character expected after \\");
 					free_job(job);
 					return 1;
 				}
@@ -1217,7 +1217,7 @@ static int pseudo_exec(struct child_prog *child)
 	/* Check if the command matches any of the forking builtins. */
 	for (x = bltins_forking; x->cmd; x++) {
 		if (strcmp(child->argv[0], x->cmd) == 0) {
-			applet_name=x->cmd;
+			bb_applet_name=x->cmd;
 			_exit (x->function(child));
 		}
 	}
@@ -1225,7 +1225,7 @@ static int pseudo_exec(struct child_prog *child)
 	/* Check if the command matches any busybox internal
 	 * commands ("applets") here.  Following discussions from
 	 * November 2000 on busybox@busybox.net, don't use
-	 * get_last_path_component().  This way explicit (with
+	 * bb_get_last_path_component().  This way explicit (with
 	 * slashes) filenames will never be interpreted as an
 	 * applet, just like with builtins.  This way the user can
 	 * override an applet with an explicit filename reference.
@@ -1241,7 +1241,7 @@ static int pseudo_exec(struct child_prog *child)
 	 * /bin/cat exists on the filesystem and is _not_ busybox.
 	 * Some systems want this, others do not.  Choose wisely.  :-)
 	 */
-	name = get_last_path_component(name);
+	name = bb_get_last_path_component(name);
 #endif
 
 	{
@@ -1255,7 +1255,7 @@ static int pseudo_exec(struct child_prog *child)
 
 	execvp(child->argv[0], child->argv);
 
-	/* Do not use perror_msg_and_die() here, since we must not 
+	/* Do not use bb_perror_msg_and_die() here, since we must not 
 	 * call exit() but should call _exit() instead */
 	fprintf(stderr, "%s: %m\n", child->argv[0]);
 	_exit(EXIT_FAILURE);
@@ -1299,7 +1299,7 @@ static void insert_job(struct job *newjob, int inbg)
 		/* move the new process group into the foreground */
 		/* suppress messages when run from /linuxrc mag@sysgo.de */
 		if (tcsetpgrp(shell_terminal, newjob->pgrp) && errno != ENOTTY)
-			perror_msg("tcsetpgrp");
+			bb_perror_msg("tcsetpgrp");
 	}
 }
 
@@ -1317,7 +1317,7 @@ static int run_command(struct job *newjob, int inbg, int outpipe[2])
 		child = & (newjob->progs[i]);
 
 		if ((i + 1) < newjob->num_progs) {
-			if (pipe(pipefds)<0) perror_msg_and_die("pipe");
+			if (pipe(pipefds)<0) bb_perror_msg_and_die("pipe");
 			nextout = pipefds[1];
 		} else {
 			if (outpipe[1]!=-1) {
@@ -1464,7 +1464,7 @@ static int busy_loop(FILE * input)
 
 			if (waitpid(job_list.fg->progs[i].pid, &status, WUNTRACED)<0) {
 				if (errno != ECHILD) {
-					perror_msg_and_die("waitpid(%d)",job_list.fg->progs[i].pid);
+					bb_perror_msg_and_die("waitpid(%d)",job_list.fg->progs[i].pid);
 				}
 			}
 
@@ -1496,7 +1496,7 @@ static int busy_loop(FILE * input)
 				/* move the shell to the foreground */
 				/* suppress messages when run from /linuxrc mag@sysgo.de */
 				if (tcsetpgrp(shell_terminal, getpgrp()) && errno != ENOTTY)
-					perror_msg("tcsetpgrp"); 
+					bb_perror_msg("tcsetpgrp"); 
 			}
 		}
 	}
@@ -1504,7 +1504,7 @@ static int busy_loop(FILE * input)
 
 	/* return controlling TTY back to parent process group before exiting */
 	if (tcsetpgrp(shell_terminal, parent_pgrp) && errno != ENOTTY)
-		perror_msg("tcsetpgrp");
+		bb_perror_msg("tcsetpgrp");
 
 	/* return exit status if called with "-c" */
 	if (input == NULL && WIFEXITED(status))
@@ -1517,7 +1517,7 @@ static int busy_loop(FILE * input)
 #ifdef CONFIG_FEATURE_CLEAN_UP
 void free_memory(void)
 {
-	if (cwd && cwd!=unknown) {
+	if (cwd && cwd!=bb_msg_unknown) {
 		free((char*)cwd);
 	}
 	if (local_pending_command)
@@ -1594,8 +1594,8 @@ int lash_main(int argc_l, char **argv_l)
 			case 'c':
 				input = NULL;
 				if (local_pending_command != 0)
-					error_msg_and_die("multiple -c arguments");
-				local_pending_command = xstrdup(argv[optind]);
+					bb_error_msg_and_die("multiple -c arguments");
+				local_pending_command = bb_xstrdup(argv[optind]);
 				optind++;
 				argv = argv+optind;
 				break;
@@ -1603,7 +1603,7 @@ int lash_main(int argc_l, char **argv_l)
 				interactive = TRUE;
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 	/* A shell is interactive if the `-i' flag was given, or if all of
@@ -1627,14 +1627,14 @@ int lash_main(int argc_l, char **argv_l)
 #endif
 	} else if (local_pending_command==NULL) {
 		//printf( "optind=%d  argv[optind]='%s'\n", optind, argv[optind]);
-		input = xfopen(argv[optind], "r");
+		input = bb_xfopen(argv[optind], "r");
 		mark_open(fileno(input));  /* be lazy, never mark this closed */
 	}
 
 	/* initialize the cwd -- this is never freed...*/
 	cwd = xgetcwd(0);
 	if (!cwd)
-		cwd = unknown;
+		cwd = bb_msg_unknown;
 
 #ifdef CONFIG_FEATURE_CLEAN_UP
 	atexit(free_memory);
diff --git a/shell/msh.c b/shell/msh.c
index 53f643de1..aad6bbf35 100644
--- a/shell/msh.c
+++ b/shell/msh.c
@@ -2838,7 +2838,7 @@ char *c, **v, **envp;
 #ifdef CONFIG_FEATURE_SH_STANDALONE_SHELL
 	char *name = c;
 #ifdef CONFIG_FEATURE_SH_APPLETS_ALWAYS_WIN
-	name = get_last_path_component(name);
+	name = bb_get_last_path_component(name);
 #endif
 	optind = 1;
 	if (find_applet_by_name(name)) {
@@ -2876,7 +2876,7 @@ char *c, **v, **envp;
 			return("no Shell");
 
 		case ENOMEM:
-			return((char*)memory_exhausted);
+			return((char*)bb_msg_memory_exhausted);
 
 		case E2BIG:
 			return("argument list too long");
@@ -3883,7 +3883,7 @@ int quoted;
 		;
 	if (i < 0) {
 		closepipe(pf);
-		err((char*)memory_exhausted);
+		err((char*)bb_msg_memory_exhausted);
 		return(0);
 	}
 	if (i != 0) {
diff --git a/sysklogd/klogd.c b/sysklogd/klogd.c
index 4132eb68e..b76a52ff7 100644
--- a/sysklogd/klogd.c
+++ b/sysklogd/klogd.c
@@ -136,12 +136,12 @@ extern int klogd_main(int argc, char **argv)
 		switch (opt) {
 		case 'c':
 			if ((optarg == NULL) || (optarg[1] != '\0')) {
-				show_usage();
+				bb_show_usage();
 			}
 			/* Valid levels are between 1 and 8 */
 			console_log_level = *optarg - '1';
 			if (console_log_level > 7) {
-				show_usage();
+				bb_show_usage();
 			}
 			console_log_level++;
 			
@@ -150,16 +150,16 @@ extern int klogd_main(int argc, char **argv)
 			doFork = FALSE;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
 	if (doFork) {
 #if !defined(__UCLIBC__) || defined(__UCLIBC_HAS_MMU__)
 		if (daemon(0, 1) < 0)
-			perror_msg_and_die("daemon");
+			bb_perror_msg_and_die("daemon");
 #else
-		error_msg_and_die("daemon not supported");
+		bb_error_msg_and_die("daemon not supported");
 #endif
 	}
 	doKlogd(console_log_level);
diff --git a/sysklogd/logger.c b/sysklogd/logger.c
index bb63975e7..1b55bf589 100644
--- a/sysklogd/logger.c
+++ b/sysklogd/logger.c
@@ -89,14 +89,14 @@ static int pencode(char *s)
 		*s = '\0';
 		fac = decode(save, facilitynames);
 		if (fac < 0)
-			error_msg_and_die("unknown facility name: %s", save);
+			bb_error_msg_and_die("unknown facility name: %s", save);
 		*s++ = '.';
 	} else {
 		s = save;
 	}
 	lev = decode(s, prioritynames);
 	if (lev < 0)
-		error_msg_and_die("unknown priority name: %s", save);
+		bb_error_msg_and_die("unknown priority name: %s", save);
 	return ((lev & LOG_PRIMASK) | (fac & LOG_FACMASK));
 }
 
@@ -124,7 +124,7 @@ extern int logger_main(int argc, char **argv)
 				safe_strncpy(name, optarg, sizeof(name));
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
diff --git a/sysklogd/logread.c b/sysklogd/logread.c
index ecdf2f579..ae8dbae3a 100644
--- a/sysklogd/logread.c
+++ b/sysklogd/logread.c
@@ -87,7 +87,7 @@ extern int logread_main(int argc, char **argv)
 	
 	/* no options, no getopt */
 	if (argc > 1)
-		show_usage();
+		bb_show_usage();
 	
 	// handle intrrupt signal
 	if (setjmp(jmp_env)) goto output_end;
diff --git a/sysklogd/syslogd.c b/sysklogd/syslogd.c
index 1c58a64f8..b912f5f8f 100644
--- a/sysklogd/syslogd.c
+++ b/sysklogd/syslogd.c
@@ -123,7 +123,7 @@ static int circular_logging = FALSE;
 static inline void sem_up(int semid)
 {
 	if (semop(semid, SMwup, 1) == -1) {
-		perror_msg_and_die("semop[SMwup]");
+		bb_perror_msg_and_die("semop[SMwup]");
 	}
 }
 
@@ -133,7 +133,7 @@ static inline void sem_up(int semid)
 static inline void sem_down(int semid)
 {
 	if (semop(semid, SMwdn, 3) == -1) {
-		perror_msg_and_die("semop[SMwdn]");
+		bb_perror_msg_and_die("semop[SMwdn]");
 	}
 }
 
@@ -157,11 +157,11 @@ void ipcsyslog_init(void)
 {
 	if (buf == NULL) {
 		if ((shmid = shmget(KEY_ID, shm_size, IPC_CREAT | 1023)) == -1) {
-			perror_msg_and_die("shmget");
+			bb_perror_msg_and_die("shmget");
 		}
 
 		if ((buf = shmat(shmid, NULL, 0)) == NULL) {
-			perror_msg_and_die("shmat");
+			bb_perror_msg_and_die("shmat");
 		}
 
 		buf->size = data_size;
@@ -171,10 +171,10 @@ void ipcsyslog_init(void)
 		if ((s_semid = semget(KEY_ID, 2, IPC_CREAT | IPC_EXCL | 1023)) == -1) {
 			if (errno == EEXIST) {
 				if ((s_semid = semget(KEY_ID, 2, 0)) == -1) {
-					perror_msg_and_die("semget");
+					bb_perror_msg_and_die("semget");
 				}
 			} else {
-				perror_msg_and_die("semget");
+				bb_perror_msg_and_die("semget");
 			}
 		}
 	} else {
@@ -471,7 +471,7 @@ static void init_RemoteLog(void)
 	remotefd = socket(AF_INET, SOCK_DGRAM, 0);
 
 	if (remotefd < 0) {
-		error_msg_and_die("cannot create socket");
+		bb_error_msg_and_die("cannot create socket");
 	}
 
 	hostinfo = xgethostbyname(RemoteHost);
@@ -484,7 +484,7 @@ static void init_RemoteLog(void)
 	 * for future operations
 	 */
 	if (0 != (connect(remotefd, (struct sockaddr *) &remoteaddr, len))) {
-		error_msg_and_die("cannot connect to remote host %s:%d", RemoteHost,
+		bb_error_msg_and_die("cannot connect to remote host %s:%d", RemoteHost,
 						  RemotePort);
 	}
 
@@ -521,17 +521,17 @@ static void doSyslogd(void)
 	sunx.sun_family = AF_UNIX;
 	strncpy(sunx.sun_path, lfile, sizeof(sunx.sun_path));
 	if ((sock_fd = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0) {
-		perror_msg_and_die("Couldn't get file descriptor for socket "
+		bb_perror_msg_and_die("Couldn't get file descriptor for socket "
 						   _PATH_LOG);
 	}
 
 	addrLength = sizeof(sunx.sun_family) + strlen(sunx.sun_path);
 	if (bind(sock_fd, (struct sockaddr *) &sunx, addrLength) < 0) {
-		perror_msg_and_die("Could not connect to socket " _PATH_LOG);
+		bb_perror_msg_and_die("Could not connect to socket " _PATH_LOG);
 	}
 
 	if (chmod(lfile, 0666) < 0) {
-		perror_msg_and_die("Could not set permission on " _PATH_LOG);
+		bb_perror_msg_and_die("Could not set permission on " _PATH_LOG);
 	}
 #ifdef CONFIG_FEATURE_IPC_SYSLOG
 	if (circular_logging == TRUE) {
@@ -557,7 +557,7 @@ static void doSyslogd(void)
 				/* alarm may have happened. */
 				continue;
 			}
-			perror_msg_and_die("select error");
+			bb_perror_msg_and_die("select error");
 		}
 
 		if (FD_ISSET(sock_fd, &fds)) {
@@ -569,7 +569,7 @@ static void doSyslogd(void)
 			if ((i = recv(sock_fd, tmpbuf, BUFSIZ, 0)) > 0) {
 				serveConnection(tmpbuf, i);
 			} else {
-				perror_msg_and_die("UNIX socket error");
+				bb_perror_msg_and_die("UNIX socket error");
 			}
 			RELEASE_CONFIG_BUFFER(tmpbuf);
 		}				/* FD_ISSET() */
@@ -598,11 +598,11 @@ extern int syslogd_main(int argc, char **argv)
 			break;
 #endif
 		case 'O':
-			logFilePath = xstrdup(optarg);
+			logFilePath = bb_xstrdup(optarg);
 			break;
 #ifdef CONFIG_FEATURE_REMOTE_LOG
 		case 'R':
-			RemoteHost = xstrdup(optarg);
+			RemoteHost = bb_xstrdup(optarg);
 			if ((p = strchr(RemoteHost, ':'))) {
 				RemotePort = atoi(p + 1);
 				*p = '\0';
@@ -619,7 +619,7 @@ extern int syslogd_main(int argc, char **argv)
 			break;
 #endif
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
@@ -640,7 +640,7 @@ extern int syslogd_main(int argc, char **argv)
 
 #if ! defined(__uClinux__)
 	if ((doFork == TRUE) && (daemon(0, 1) < 0)) {
-		perror_msg_and_die("daemon");
+		bb_perror_msg_and_die("daemon");
 	}
 #endif
 	doSyslogd();
diff --git a/util-linux/dmesg.c b/util-linux/dmesg.c
index aa8eb95c9..fb1639ace 100644
--- a/util-linux/dmesg.c
+++ b/util-linux/dmesg.c
@@ -42,7 +42,7 @@ int dmesg_main(int argc, char **argv)
 	int lastc;
 	int cmd = 3;
 
-	while ((i = getopt(argc, argv, "cn:s:")) != EOF) {
+	while ((i = getopt(argc, argv, "cn:s:")) > 0) {
 		switch (i) {
 			case 'c':
 				cmd = 4;
@@ -58,12 +58,12 @@ int dmesg_main(int argc, char **argv)
 				bufsize = bb_xgetlarg(optarg, 10, 4096, 512*1024);
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
 	if (optind < argc) {
-		show_usage();
+		bb_show_usage();
 	}
 
 	if (cmd == 8) {
@@ -98,5 +98,5 @@ all_done:
 #endif
 	return EXIT_SUCCESS;
 die_the_death:
-	perror_msg_and_die(NULL);
+	bb_perror_nomsg_and_die();
 }
diff --git a/util-linux/fbset.c b/util-linux/fbset.c
index 9423abc09..afd9e64be 100644
--- a/util-linux/fbset.c
+++ b/util-linux/fbset.c
@@ -194,7 +194,7 @@ static int readmode(struct fb_var_screeninfo *base, const char *fn,
 	char buf[256];
 	char *p = buf;
 
-	f = xfopen(fn, "r");
+	f = bb_xfopen(fn, "r");
 	while (!feof(f)) {
 		fgets(buf, sizeof(buf), f);
 		if ((p = strstr(buf, "mode ")) || (p = strstr(buf, "mode\t"))) {
@@ -279,7 +279,7 @@ static int readmode(struct fb_var_screeninfo *base, const char *fn,
 		}
 	}
 #else
-	error_msg( "mode reading not compiled in");
+	bb_error_msg( "mode reading not compiled in");
 #endif
 	return 0;
 }
@@ -350,7 +350,7 @@ extern int fbset_main(int argc, char **argv)
 		for (i = 0; g_cmdoptions[i].name; i++) {
 			if (!strcmp(thisarg, g_cmdoptions[i].name)) {
 				if (argc - 1 < g_cmdoptions[i].param_count)
-					show_usage();
+					bb_show_usage();
 				switch (g_cmdoptions[i].code) {
 				case CMD_FB:
 					fbdev = argv[1];
@@ -399,18 +399,18 @@ extern int fbset_main(int argc, char **argv)
 				mode = *argv;
 				g_options |= OPT_READMODE;
 			} else {
-				show_usage();
+				bb_show_usage();
 			}
 		}
 	}
 
 	if ((fh = open(fbdev, O_RDONLY)) < 0)
-		perror_msg_and_die("fbset(open)");
+		bb_perror_msg_and_die("fbset(open)");
 	if (ioctl(fh, FBIOGET_VSCREENINFO, &var))
-		perror_msg_and_die("fbset(ioctl)");
+		bb_perror_msg_and_die("fbset(ioctl)");
 	if (g_options & OPT_READMODE) {
 		if (!readmode(&var, modefile, mode)) {
-			error_msg("Unknown video mode `%s'", mode);
+			bb_error_msg("Unknown video mode `%s'", mode);
 			return EXIT_FAILURE;
 		}
 	}
@@ -418,7 +418,7 @@ extern int fbset_main(int argc, char **argv)
 	setmode(&var, &varset);
 	if (g_options & OPT_CHANGE)
 		if (ioctl(fh, FBIOPUT_VSCREENINFO, &var))
-			perror_msg_and_die("fbset(ioctl)");
+			bb_perror_msg_and_die("fbset(ioctl)");
 	showmode(&var);
 	/* Don't close the file, as exiting will take care of that */
 	/* close(fh); */
diff --git a/util-linux/fdflush.c b/util-linux/fdflush.c
index 0756ddfbf..c3fcf3325 100644
--- a/util-linux/fdflush.c
+++ b/util-linux/fdflush.c
@@ -25,6 +25,7 @@
 #include <sys/ioctl.h>
 #include <fcntl.h>
 #include <stdlib.h>
+#include <unistd.h>
 #include "busybox.h"
 
 /* From <linux/fd.h> */
@@ -35,22 +36,19 @@ extern int fdflush_main(int argc, char **argv)
 	int fd, result;
 
 	if (argc <= 1)
-		show_usage();
-	if ((fd = open(*(++argv), 0)) < 0)
-		goto die_the_death;
+		bb_show_usage();
+
+	fd = bb_xopen(argv[1], 0);
 
 	result = ioctl(fd, FDFLUSH, 0);
 #ifdef CONFIG_FEATURE_CLEAN_UP
 	close(fd);
 #endif
 	if (result) {
-		goto die_the_death;
+		bb_perror_nomsg_and_die();
 	}
 
 	/* Don't bother closing.  Exit does
 	 * that, so we can save a few bytes */
 	return EXIT_SUCCESS;
-
-die_the_death:
-	perror_msg_and_die(NULL);
 }
diff --git a/util-linux/fdisk.c b/util-linux/fdisk.c
index 696e64c7d..71fbe074e 100644
--- a/util-linux/fdisk.c
+++ b/util-linux/fdisk.c
@@ -5655,7 +5655,7 @@ tryprocpt(void) {
 	char line[100], ptname[100], devname[120], *s;
 	int ma, mi, sz;
 
-	procpt = wfopen(PROC_PARTITIONS, "r");
+	procpt = bb_wfopen(PROC_PARTITIONS, "r");
 
 	while (fgets(line, sizeof(line), procpt)) {
 		if (sscanf (line, " %d %d %d %[^\n ]",
@@ -5711,7 +5711,7 @@ int fdisk_main(int argc, char **argv) {
 			sector_size = atoi(optarg);
 			if (sector_size != 512 && sector_size != 1024 &&
 			    sector_size != 2048)
-				show_usage();
+				bb_show_usage();
 			sector_offset = 2;
 			user_set_sector_size = 1;
 			break;
@@ -5746,7 +5746,7 @@ int fdisk_main(int argc, char **argv) {
 			printf("fdisk v" UTIL_LINUX_VERSION "\n");
 			return 0;
 		default:
-			show_usage();
+			bb_show_usage();
 		}
 	}
 
@@ -5794,7 +5794,7 @@ int fdisk_main(int argc, char **argv) {
 
 		opts = argc - optind;
 		if (opts <= 0)
-			show_usage();
+			bb_show_usage();
 
 		for (j = optind; j < argc; j++) {
 			disk_device = argv[j];
@@ -5816,7 +5816,7 @@ int fdisk_main(int argc, char **argv) {
 	if (argc-optind == 1)
 		disk_device = argv[optind];
 	else
-		show_usage();
+		bb_show_usage();
 
 	get_boot(fdisk);
 
diff --git a/util-linux/freeramdisk.c b/util-linux/freeramdisk.c
index dd7700c06..9276a6c40 100644
--- a/util-linux/freeramdisk.c
+++ b/util-linux/freeramdisk.c
@@ -41,17 +41,17 @@ freeramdisk_main(int argc, char **argv)
 	FILE *f;
 
 	if (argc != 2) {
-		show_usage();
+		bb_show_usage();
 	}
 
-	f = xfopen(argv[1], "r+");
+	f = bb_xfopen(argv[1], "r+");
 	
 	result = ioctl(fileno(f), BLKFLSBUF);
 #ifdef CONFIG_FEATURE_CLEAN_UP
 	fclose(f);
 #endif
 	if (result < 0) {
-		perror_msg_and_die("failed ioctl on %s", argv[1]);
+		bb_perror_msg_and_die("failed ioctl on %s", argv[1]);
 	}
 
 	/* Don't bother closing.  Exit does
diff --git a/util-linux/fsck_minix.c b/util-linux/fsck_minix.c
index d332b6b0a..3a691476e 100644
--- a/util-linux/fsck_minix.c
+++ b/util-linux/fsck_minix.c
@@ -279,7 +279,7 @@ static void leave(int status)
 
 static void die(const char *str)
 {
-	error_msg("%s", str);
+	bb_error_msg("%s", str);
 	leave(8);
 }
 
@@ -1344,7 +1344,7 @@ extern int fsck_minix_main(int argc, char **argv)
 		argv++;
 		if (argv[0][0] != '-') {
 			if (device_name)
-				show_usage();
+				bb_show_usage();
 			else
 				device_name = argv[0];
 		} else
@@ -1374,11 +1374,11 @@ extern int fsck_minix_main(int argc, char **argv)
 					force = 1;
 					break;
 				default:
-					show_usage();
+					bb_show_usage();
 				}
 	}
 	if (!device_name)
-		show_usage();
+		bb_show_usage();
 	check_mount();				/* trying to check a mounted filesystem? */
 	if (repair && !automatic) {
 		if (!isatty(0) || !isatty(1))
@@ -1399,7 +1399,7 @@ extern int fsck_minix_main(int argc, char **argv)
 	 * flags and whether or not the -f switch was specified on the 
 	 * command line.
 	 */
-	printf("%s, %s\n", applet_name, program_version);
+	printf("%s, %s\n", bb_applet_name, program_version);
 	if (!(Super.s_state & MINIX_ERROR_FS) &&
 		(Super.s_state & MINIX_VALID_FS) && !force) {
 		if (repair)
diff --git a/util-linux/getopt.c b/util-linux/getopt.c
index e126d7b6e..25eeab69b 100644
--- a/util-linux/getopt.c
+++ b/util-linux/getopt.c
@@ -37,7 +37,7 @@
  *     <misiek@misiek.eu.org>)
  * Ported to Busybox - Alfred M. Szmidt <ams@trillian.itslinux.org>
  *  Removed --version/-V and --help/-h in
- *  Removed prase_error(), using error_msg() from Busybox instead
+ *  Removed prase_error(), using bb_error_msg() from Busybox instead
  *  Replaced our_malloc with xmalloc and our_realloc with xrealloc
  *
  */
@@ -95,7 +95,7 @@ const char *normalize(const char *arg)
         free(BUFFER);
 
         if (!quote) { /* Just copy arg */
-               BUFFER=xstrdup(arg);
+               BUFFER=bb_xstrdup(arg);
                 return BUFFER;
         }
 
@@ -224,7 +224,7 @@ void add_longopt(const char *name,int has_arg)
                 long_options[long_options_nr-1].has_arg=has_arg;
                 long_options[long_options_nr-1].flag=NULL;
                 long_options[long_options_nr-1].val=LONG_OPT;
-               long_options[long_options_nr-1].name=xstrdup(name);
+               long_options[long_options_nr-1].name=bb_xstrdup(name);
         }
         long_options_nr++;
 }
@@ -254,7 +254,7 @@ void add_long_options(char *options)
                                         arg_opt=required_argument;
                                 }
                                 if (tlen == 0)
-                                        error_msg("empty long option after -l or --long argument");
+                                        bb_error_msg("empty long option after -l or --long argument");
                         }
                         add_longopt(tokptr,arg_opt);
                 }
@@ -273,7 +273,7 @@ void set_shell(const char *new_shell)
         else if (!strcmp(new_shell,"csh"))
                 shell=TCSH;
         else
-                error_msg("unknown shell after -s or --shell argument");
+                bb_error_msg("unknown shell after -s or --shell argument");
 }
 
 
@@ -322,7 +322,7 @@ int getopt_main(int argc, char *argv[])
                         printf(" --\n");
                        return 0;
                 } else
-                        error_msg_and_die("missing optstring argument");
+                        bb_error_msg_and_die("missing optstring argument");
         }
 
         if (argv[1][0] != '-' || compatible) {
@@ -340,14 +340,14 @@ int getopt_main(int argc, char *argv[])
                         break;
                 case 'o':
                        free(optstr);
-                       optstr=xstrdup(optarg);
+                       optstr=bb_xstrdup(optarg);
                         break;
                 case 'l':
                         add_long_options(optarg);
                         break;
                 case 'n':
                        free(name);
-                       name=xstrdup(optarg);
+                       name=bb_xstrdup(optarg);
                         break;
                 case 'q':
                         quiet_errors=1;
@@ -364,14 +364,14 @@ int getopt_main(int argc, char *argv[])
                         quote=0;
                         break;
                 default:
-                        show_usage();
+                        bb_show_usage();
                 }
 
         if (!optstr) {
                 if (optind >= argc)
-                        error_msg_and_die("missing optstring argument");
+                        bb_error_msg_and_die("missing optstring argument");
                 else {
-                       optstr=xstrdup(argv[optind]);
+                       optstr=bb_xstrdup(argv[optind]);
                         optind++;
                 }
         }
diff --git a/util-linux/hexdump.c b/util-linux/hexdump.c
index 33648f918..1858b08d4 100644
--- a/util-linux/hexdump.c
+++ b/util-linux/hexdump.c
@@ -25,115 +25,92 @@
 #include <getopt.h>
 #include <stdlib.h>
 #include <string.h>
-#include "dump.h"
 #include "busybox.h"
+#include "dump.h"
 
-extern off_t skip;                      /* bytes to skip */
-
-extern FS *fshead;				/* head of format strings */
-extern int blocksize;				/* data block size */
-extern int length;			/* max bytes to read */
-
-void addfile(char *name)
+static void bb_dump_addfile(char *name)
 {
 	register char *p;
 	FILE *fp;
-	int ch;
-	char buf[2048 + 1];
+	char *buf;
 
-	if (!(fp = fopen(name, "r"))) {
-		error_msg_and_die("hexdump: can't read %s.\n", name);
-	}
-	while (fgets(buf, sizeof(buf), fp)) {
-		if (!(p = index(buf, '\n'))) {
-			error_msg("hexdump: line too long.\n");
-			while ((ch = getchar()) != '\n' && ch != EOF);
-			continue;
-		}
-		*p = '\0';
-		for (p = buf; *p && isspace(*p); ++p);
-		if (!*p || *p == '#') {
-			continue;
+	fp = bb_xfopen(name, "r");
+
+	while ((buf = bb_get_chomped_line_from_file(fp)) != NULL) {
+		p = (char *) bb_skip_whitespace(buf);
+
+		if (*p && (*p != '#')) {
+			bb_dump_add(p);
 		}
-		add(p);
+		free(buf);
 	}
-	(void)fclose(fp);
+	fclose(fp);
 }
 
+static const char * const add_strings[] = {
+			"\"%07.7_ax \" 16/1 \"%03o \" \"\\n\"",		/* b */
+			"\"%07.7_ax \" 16/1 \"%3_c \" \"\\n\"",		/* c */
+			"\"%07.7_ax \" 8/2 \"  %05u \" \"\\n\"",	/* d */
+			"\"%07.7_ax \" 8/2 \" %06o \" \"\\n\"",		/* o */
+			"\"%07.7_ax \" 8/2 \"   %04x \" \"\\n\"",	/* x */
+};
+
+static const char add_first[] = "\"%07.7_Ax\n\"";
+
+static const char hexdump_opts[] = "bcdoxe:f:n:s:v";
+
+static const struct suffix_mult suffixes[] = {
+	{"b",  512 },
+	{"k",  1024 },
+	{"m",  1024*1024 },
+	{NULL, 0 }
+};
+
 int hexdump_main(int argc, char **argv)
 {
 //	register FS *tfs;
-	char *p;
+	const char *p;
 	int ch;
-	extern enum _vflag vflag;
-	vflag = FIRST;
-	length = -1;
 
-	while ((ch = getopt(argc, argv, "bcde:f:n:os:vx")) != EOF) {
-		switch (ch) {
-		case 'b':
-			add("\"%07.7_Ax\n\"");
-			add("\"%07.7_ax \" 16/1 \"%03o \" \"\\n\"");
-			break;
-		case 'c':
-			add("\"%07.7_Ax\n\"");
-			add("\"%07.7_ax \" 16/1 \"%3_c \" \"\\n\"");
-			break;
-		case 'd':
-			add("\"%07.7_Ax\n\"");
-			add("\"%07.7_ax \" 8/2 \"  %05u \" \"\\n\"");
-			break;
-		case 'e':
-			add(optarg);
-			break;
-		case 'f':
-			addfile(optarg);
-			break;
-		case 'n':
-			if ((length = atoi(optarg)) < 0) {
-				error_msg_and_die("hexdump: bad length value.\n");
-			}
-			break;
-		case 'o':
-			add("\"%07.7_Ax\n\"");
-			add("\"%07.7_ax \" 8/2 \" %06o \" \"\\n\"");
-			break;
-		case 's':
-			if ((skip = strtol(optarg, &p, 0)) < 0) {
-				error_msg_and_die("hexdump: bad skip value.\n");
-			}
-			switch(*p) {
-				case 'b':
-					skip *= 512;
-					break;
-				case 'k':
-					skip *= 1024;
-					break;
-				case 'm':
-					skip *= 1048576;
-					break;
+	bb_dump_vflag = FIRST;
+	bb_dump_length = -1;
+
+	while ((ch = getopt(argc, argv, hexdump_opts)) > 0) {
+		if ((p = strchr(hexdump_opts, ch)) != NULL) {
+			if ((p - hexdump_opts) < 5) {
+				bb_dump_add(add_first);
+				bb_dump_add(add_strings[(int)(p - hexdump_opts)]);
+			} else {
+				/* Sae a little bit of space below by omitting the 'else's. */
+				if (ch == 'e') {
+					bb_dump_add(optarg);
+				} /* else */
+				if (ch == 'f') {
+					bb_dump_addfile(optarg);
+				} /* else */
+				if (ch == 'n') {
+					bb_dump_length = bb_xgetularg10_bnd(optarg, 0, INT_MAX);
+				} /* else */
+				if (ch == 's') {
+					bb_dump_skip = bb_xgetularg_bnd_sfx(optarg, 10, 0, LONG_MAX, suffixes);
+				} /* else */
+				if (ch == 'v') {
+					bb_dump_vflag = ALL;
+				}
 			}
-			break;
-		case 'v':
-			vflag = ALL;
-			break;
-		case 'x':
-			add("\"%07.7_Ax\n\"");
-			add("\"%07.7_ax \" 8/2 \"   %04x \" \"\\n\"");
-			break;
-		case '?':
-			show_usage();
+		} else {
+			bb_show_usage();
 		}
 	}
 
-	if (!fshead) {
-		add("\"%07.7_Ax\n\"");
-		add("\"%07.7_ax \" 8/2 \"%04x \" \"\\n\"");
+	if (!bb_dump_fshead) {
+		bb_dump_add(add_first);
+		bb_dump_add("\"%07.7_ax \" 8/2 \"%04x \" \"\\n\"");
 	}
 
 	argv += optind;
 
-	return(dump(argv));
+	return(bb_dump_dump(argv));
 }
 /*
  * Copyright (c) 1989 The Regents of the University of California.
diff --git a/util-linux/hwclock.c b/util-linux/hwclock.c
index 815b60b21..2eee3cfdb 100644
--- a/util-linux/hwclock.c
+++ b/util-linux/hwclock.c
@@ -77,11 +77,11 @@ time_t read_rtc ( int utc )
 
 	if (( rtc = open ( "/dev/rtc", O_RDONLY )) < 0 ) {
 		if (( rtc = open ( "/dev/misc/rtc", O_RDONLY )) < 0 )
-			perror_msg_and_die ( "Could not access RTC" );
+			bb_perror_msg_and_die ( "Could not access RTC" );
 	}
  	memset ( &tm, 0, sizeof( struct tm ));
 	if ( ioctl ( rtc, RTC_RD_TIME, &tm ) < 0 )
-		perror_msg_and_die ( "Could not read time from RTC" );
+		bb_perror_msg_and_die ( "Could not read time from RTC" );
 	tm. tm_isdst = -1; // not known
 	
 	close ( rtc );
@@ -111,7 +111,7 @@ void write_rtc ( time_t t, int utc )
 
 	if (( rtc = open ( "/dev/rtc", O_WRONLY )) < 0 ) {
 		if (( rtc = open ( "/dev/misc/rtc", O_WRONLY )) < 0 )
-			perror_msg_and_die ( "Could not access RTC" );
+			bb_perror_msg_and_die ( "Could not access RTC" );
 	}
  	
  	printf ( "1\n" );
@@ -122,7 +122,7 @@ void write_rtc ( time_t t, int utc )
  	printf ( "2\n") ;
  	
 	if ( ioctl ( rtc, RTC_SET_TIME, &tm ) < 0 )
-		perror_msg_and_die ( "Could not set the RTC time" );
+		bb_perror_msg_and_die ( "Could not set the RTC time" );
 	
 	close ( rtc );
 }
@@ -138,7 +138,7 @@ int show_clock ( int utc )
 	
 	safe_strncpy ( buffer, ctime ( &t ), sizeof( buffer ));
 	if ( buffer [0] )
-		buffer [xstrlen ( buffer ) - 1] = 0;
+		buffer [bb_strlen ( buffer ) - 1] = 0;
 	
 	//printf ( "%s  %.6f seconds %s\n", buffer, 0.0, utc ? "" : ( ptm-> tm_isdst ? tzname [1] : tzname [0] ));
 	printf ( "%s  %.6f seconds\n", buffer, 0.0 );
@@ -154,7 +154,7 @@ int to_sys_clock ( int utc )
 	tv. tv_sec = read_rtc ( utc );
 
 	if ( settimeofday ( &tv, &tz ))
-		perror_msg_and_die ( "settimeofday() failed" );
+		bb_perror_msg_and_die ( "settimeofday() failed" );
 
 	return 0;
 }
@@ -165,7 +165,7 @@ int from_sys_clock ( int utc )
 	struct timezone tz = { 0, 0 };
 
 	if ( gettimeofday ( &tv, &tz ))
-		perror_msg_and_die ( "gettimeofday() failed" );
+		bb_perror_msg_and_die ( "gettimeofday() failed" );
 
 	write_rtc ( tv. tv_sec, utc );
 	return 0;
@@ -181,7 +181,7 @@ int check_utc ( void )
 		char buffer [128];
 	
 		while ( fgets ( buffer, sizeof( buffer ), f )) {
-			int len = xstrlen ( buffer );
+			int len = bb_strlen ( buffer );
 			
 			while ( len && isspace ( buffer [len - 1] ))
 				len--;
@@ -238,7 +238,7 @@ extern int hwclock_main ( int argc, char **argv )
 			utc_arg = 1;
 			break;
 		default:
-			show_usage();
+			bb_show_usage();
 			break;
 		}
 	}
diff --git a/util-linux/losetup.c b/util-linux/losetup.c
index bfeb6b274..e2ea538d5 100644
--- a/util-linux/losetup.c
+++ b/util-linux/losetup.c
@@ -39,16 +39,16 @@ losetup_main (int argc, char **argv)
 	break;
 
       case 'o':
-	offset = parse_number (optarg, NULL);
+	offset = bb_xparse_number (optarg, NULL);
 	break;
 
       default:
-	show_usage ();
+	bb_show_usage();
       }
 
   if ((delete && (offset || optind + 1 != argc))
       || (!delete && optind + 2 != argc))
-    show_usage ();
+    bb_show_usage();
 
   if (delete)
     return del_loop (argv[optind]) ? EXIT_SUCCESS : EXIT_FAILURE;
diff --git a/util-linux/mkfs_minix.c b/util-linux/mkfs_minix.c
index 94f29e55d..75a909e6b 100644
--- a/util-linux/mkfs_minix.c
+++ b/util-linux/mkfs_minix.c
@@ -268,7 +268,7 @@ extern inline void check_mount(void)
 	if (!mnt)
 		return;
 
-	error_msg_and_die("%s is mounted; will not make a filesystem here!", device_name);
+	bb_error_msg_and_die("%s is mounted; will not make a filesystem here!", device_name);
 }
 
 static long valid_offset(int fd, int offset)
@@ -307,7 +307,7 @@ extern inline int get_size(const char *file)
 	long size;
 
 	if ((fd = open(file, O_RDWR)) < 0)
-		perror_msg_and_die("%s", file);
+		bb_perror_msg_and_die("%s", file);
 	if (ioctl(fd, BLKGETSIZE, &size) >= 0) {
 		close(fd);
 		return (size * 512);
@@ -325,28 +325,28 @@ extern inline void write_tables(void)
 	Super.s_state &= ~MINIX_ERROR_FS;
 
 	if (lseek(DEV, 0, SEEK_SET))
-		error_msg_and_die("seek to boot block failed in write_tables");
+		bb_error_msg_and_die("seek to boot block failed in write_tables");
 	if (512 != write(DEV, boot_block_buffer, 512))
-		error_msg_and_die("unable to clear boot sector");
+		bb_error_msg_and_die("unable to clear boot sector");
 	if (BLOCK_SIZE != lseek(DEV, BLOCK_SIZE, SEEK_SET))
-		error_msg_and_die("seek failed in write_tables");
+		bb_error_msg_and_die("seek failed in write_tables");
 	if (BLOCK_SIZE != write(DEV, super_block_buffer, BLOCK_SIZE))
-		error_msg_and_die("unable to write super-block");
+		bb_error_msg_and_die("unable to write super-block");
 	if (IMAPS * BLOCK_SIZE != write(DEV, inode_map, IMAPS * BLOCK_SIZE))
-		error_msg_and_die("unable to write inode map");
+		bb_error_msg_and_die("unable to write inode map");
 	if (ZMAPS * BLOCK_SIZE != write(DEV, zone_map, ZMAPS * BLOCK_SIZE))
-		error_msg_and_die("unable to write zone map");
+		bb_error_msg_and_die("unable to write zone map");
 	if (INODE_BUFFER_SIZE != write(DEV, inode_buffer, INODE_BUFFER_SIZE))
-		error_msg_and_die("unable to write inodes");
+		bb_error_msg_and_die("unable to write inodes");
 
 }
 
 static void write_block(int blk, char *buffer)
 {
 	if (blk * BLOCK_SIZE != lseek(DEV, blk * BLOCK_SIZE, SEEK_SET))
-		error_msg_and_die("seek failed in write_block");
+		bb_error_msg_and_die("seek failed in write_block");
 	if (BLOCK_SIZE != write(DEV, buffer, BLOCK_SIZE))
-		error_msg_and_die("write failed in write_block");
+		bb_error_msg_and_die("write failed in write_block");
 }
 
 static int get_free_block(void)
@@ -354,7 +354,7 @@ static int get_free_block(void)
 	int blk;
 
 	if (used_good_blocks + 1 >= MAX_GOOD_BLOCKS)
-		error_msg_and_die("too many bad blocks");
+		bb_error_msg_and_die("too many bad blocks");
 	if (used_good_blocks)
 		blk = good_blocks_table[used_good_blocks - 1] + 1;
 	else
@@ -362,7 +362,7 @@ static int get_free_block(void)
 	while (blk < ZONES && zone_in_use(blk))
 		blk++;
 	if (blk >= ZONES)
-		error_msg_and_die("not enough good blocks");
+		bb_error_msg_and_die("not enough good blocks");
 	good_blocks_table[used_good_blocks] = blk;
 	used_good_blocks++;
 	return blk;
@@ -428,7 +428,7 @@ extern inline void make_bad_inode(void)
 				goto end_bad;
 		}
 	}
-	error_msg_and_die("too many bad blocks");
+	bb_error_msg_and_die("too many bad blocks");
   end_bad:
 	if (ind)
 		write_block(ind, (char *) ind_block);
@@ -478,7 +478,7 @@ extern inline void make_bad_inode2(void)
 		}
 	}
 	/* Could make triple indirect block here */
-	error_msg_and_die("too many bad blocks");
+	bb_error_msg_and_die("too many bad blocks");
   end_bad:
 	if (ind)
 		write_block(ind, (char *) ind_block);
@@ -579,7 +579,7 @@ extern inline void setup_tables(void)
 	 * /sbin/mkfs.minix -i 200 test.fs
 	 * */
 	if (i >= 999) {
-		error_msg_and_die("unable to allocate buffers for maps");
+		bb_error_msg_and_die("unable to allocate buffers for maps");
 	}
 	FIRSTZONE = NORM_FIRSTZONE;
 	inode_map = xmalloc(IMAPS * BLOCK_SIZE);
@@ -610,7 +610,7 @@ extern inline long do_check(char *buffer, int try, unsigned int current_block)
 	/* Seek to the correct loc. */
 	if (lseek(DEV, current_block * BLOCK_SIZE, SEEK_SET) !=
 		current_block * BLOCK_SIZE) {
-		error_msg_and_die("seek failed during testing of blocks");
+		bb_error_msg_and_die("seek failed during testing of blocks");
 	}
 
 
@@ -650,7 +650,7 @@ static void check_blocks(void)
 	while (currently_testing < ZONES) {
 		if (lseek(DEV, currently_testing * BLOCK_SIZE, SEEK_SET) !=
 			currently_testing * BLOCK_SIZE)
-			error_msg_and_die("seek failed in check_blocks");
+			bb_error_msg_and_die("seek failed in check_blocks");
 		try = TEST_BUFFER_BLOCKS;
 		if (currently_testing + try > ZONES)
 			try = ZONES - currently_testing;
@@ -659,7 +659,7 @@ static void check_blocks(void)
 		if (got == try)
 			continue;
 		if (currently_testing < FIRSTZONE)
-			error_msg_and_die("bad blocks before data-area: cannot make fs");
+			bb_error_msg_and_die("bad blocks before data-area: cannot make fs");
 		mark_zone(currently_testing);
 		badblocks++;
 		currently_testing++;
@@ -675,7 +675,7 @@ static void get_list_blocks(char *filename)
 	FILE *listfile;
 	unsigned long blockno;
 
-	listfile = xfopen(filename, "r");
+	listfile = bb_xfopen(filename, "r");
 	while (!feof(listfile)) {
 		fscanf(listfile, "%ld\n", &blockno);
 		mark_zone(blockno);
@@ -696,10 +696,10 @@ extern int mkfs_minix_main(int argc, char **argv)
 	int stopIt=FALSE;
 
 	if (INODE_SIZE * MINIX_INODES_PER_BLOCK != BLOCK_SIZE)
-		error_msg_and_die("bad inode size");
+		bb_error_msg_and_die("bad inode size");
 #ifdef CONFIG_FEATURE_MINIX2
 	if (INODE_SIZE2 * MINIX2_INODES_PER_BLOCK != BLOCK_SIZE)
-		error_msg_and_die("bad inode size");
+		bb_error_msg_and_die("bad inode size");
 #endif
 	
 	/* Parse options */
@@ -725,7 +725,7 @@ extern int mkfs_minix_main(int argc, char **argv)
 							}
 							req_nr_inodes = strtoul(cp, &tmp, 0);
 							if (*tmp)
-								show_usage();
+								bb_show_usage();
 							stopIt=TRUE;
 							break;
 						}
@@ -749,13 +749,13 @@ extern int mkfs_minix_main(int argc, char **argv)
 							}
 							i = strtoul(cp, &tmp, 0);
 							if (*tmp)
-								show_usage();
+								bb_show_usage();
 							if (i == 14)
 								magic = MINIX_SUPER_MAGIC;
 							else if (i == 30)
 								magic = MINIX_SUPER_MAGIC2;
 							else 
-								show_usage();
+								bb_show_usage();
 							namelen = i;
 							dirsize = i + 2;
 							stopIt=TRUE;
@@ -765,7 +765,7 @@ extern int mkfs_minix_main(int argc, char **argv)
 #ifdef CONFIG_FEATURE_MINIX2
 						version2 = 1;
 #else
-						error_msg("%s: not compiled with minix v2 support",
+						bb_error_msg("%s: not compiled with minix v2 support",
 								device_name);
 						exit(-1);
 #endif
@@ -774,7 +774,7 @@ extern int mkfs_minix_main(int argc, char **argv)
 					case 'h':
 					default:
 goodbye:
-						show_usage();
+						bb_show_usage();
 				}
 			}
 		} else {
@@ -792,7 +792,7 @@ goodbye:
 	if (device_name && !BLOCKS)
 		BLOCKS = get_size(device_name) / 1024;
 	if (!device_name || BLOCKS < 10) {
-		show_usage();
+		bb_show_usage();
 	}
 #ifdef CONFIG_FEATURE_MINIX2
 	if (version2) {
@@ -816,13 +816,13 @@ goodbye:
 	strcpy(tmp + 2, ".badblocks");
 	DEV = open(device_name, O_RDWR);
 	if (DEV < 0)
-		error_msg_and_die("unable to open %s", device_name);
+		bb_error_msg_and_die("unable to open %s", device_name);
 	if (fstat(DEV, &statbuf) < 0)
-		error_msg_and_die("unable to stat %s", device_name);
+		bb_error_msg_and_die("unable to stat %s", device_name);
 	if (!S_ISBLK(statbuf.st_mode))
 		check = 0;
 	else if (statbuf.st_rdev == 0x0300 || statbuf.st_rdev == 0x0340)
-		error_msg_and_die("will not try to make filesystem on '%s'", device_name);
+		bb_error_msg_and_die("will not try to make filesystem on '%s'", device_name);
 	setup_tables();
 	if (check)
 		check_blocks();
diff --git a/util-linux/mkswap.c b/util-linux/mkswap.c
index de10ba71f..15db392d2 100644
--- a/util-linux/mkswap.c
+++ b/util-linux/mkswap.c
@@ -87,7 +87,7 @@ static inline void init_signature_page(void)
 
 #ifdef PAGE_SIZE
 	if (pagesize != PAGE_SIZE)
-		error_msg("Assuming pages of size %d", pagesize);
+		bb_error_msg("Assuming pages of size %d", pagesize);
 #endif
 	signature_page = (int *) xmalloc(pagesize);
 	memset(signature_page, 0, pagesize);
@@ -185,7 +185,7 @@ static inline void page_bad(int page)
 		bit_test_and_clear(signature_page, page);
 	else {
 		if (badpages == MAX_BADPAGES)
-			error_msg_and_die("too many bad pages");
+			bb_error_msg_and_die("too many bad pages");
 		p->badpages[badpages] = page;
 	}
 	badpages++;
@@ -206,7 +206,7 @@ static void check_blocks(void)
 		}
 		if (do_seek && lseek(DEV, current_page * pagesize, SEEK_SET) !=
 			current_page * pagesize)
-			error_msg_and_die("seek failed in check_blocks");
+			bb_error_msg_and_die("seek failed in check_blocks");
 		if ((do_seek = (pagesize != read(DEV, buffer, pagesize)))) {
 			page_bad(current_page++);
 			continue;
@@ -255,7 +255,7 @@ static long get_size(const char *file)
 	long size;
 
 	if ((fd = open(file, O_RDONLY)) < 0)
-		perror_msg_and_die("%s", file);
+		bb_perror_msg_and_die("%s", file);
 	if (ioctl(fd, BLKGETSIZE, &size) >= 0) {
 		int sectors_per_page = pagesize / 512;
 
@@ -287,7 +287,7 @@ int mkswap_main(int argc, char **argv)
 
 				PAGES = strtol(argv[0], &tmp, 0) / blocks_per_page;
 				if (*tmp)
-					show_usage();
+					bb_show_usage();
 			} else
 				device_name = argv[0];
 		} else {
@@ -302,19 +302,19 @@ int mkswap_main(int argc, char **argv)
 				version = atoi(argv[0] + 2);
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 			}
 		}
 	}
 	if (!device_name) {
-		error_msg("error: Nowhere to set up swap on?");
-		show_usage();
+		bb_error_msg("error: Nowhere to set up swap on?");
+		bb_show_usage();
 	}
 	sz = get_size(device_name);
 	if (!PAGES) {
 		PAGES = sz;
 	} else if (PAGES > sz && !force) {
-		error_msg("error: size %ld is larger than device size %d",
+		bb_error_msg("error: size %ld is larger than device size %d",
 				PAGES * (pagesize / 1024), sz * (pagesize / 1024));
 		return EXIT_FAILURE;
 	}
@@ -330,13 +330,13 @@ int mkswap_main(int argc, char **argv)
 			version = 1;
 	}
 	if (version != 0 && version != 1) {
-		error_msg("error: unknown version %d", version);
-		show_usage();
+		bb_error_msg("error: unknown version %d", version);
+		bb_show_usage();
 	}
 	if (PAGES < 10) {
-		error_msg("error: swap area needs to be at least %ldkB",
+		bb_error_msg("error: swap area needs to be at least %ldkB",
 				(long) (10 * pagesize / 1024));
-		show_usage();
+		bb_show_usage();
 	}
 #if 0
 	maxpages = ((version == 0) ? V0_MAX_PAGES : V1_MAX_PAGES);
@@ -353,17 +353,17 @@ int mkswap_main(int argc, char **argv)
 #endif
 	if (PAGES > maxpages) {
 		PAGES = maxpages;
-		error_msg("warning: truncating swap area to %ldkB",
+		bb_error_msg("warning: truncating swap area to %ldkB",
 				PAGES * pagesize / 1024);
 	}
 
 	DEV = open(device_name, O_RDWR);
 	if (DEV < 0 || fstat(DEV, &statbuf) < 0)
-		perror_msg_and_die("%s", device_name);
+		bb_perror_msg_and_die("%s", device_name);
 	if (!S_ISBLK(statbuf.st_mode))
 		check = 0;
 	else if (statbuf.st_rdev == 0x0300 || statbuf.st_rdev == 0x0340)
-		error_msg_and_die("Will not try to make swapdevice on '%s'", device_name);
+		bb_error_msg_and_die("Will not try to make swapdevice on '%s'", device_name);
 
 #ifdef __sparc__
 	if (!force && version == 0) {
@@ -372,13 +372,13 @@ int mkswap_main(int argc, char **argv)
 		unsigned short *q, sum;
 
 		if (read(DEV, buffer, 512) != 512)
-			error_msg_and_die("fatal: first page unreadable");
+			bb_error_msg_and_die("fatal: first page unreadable");
 		if (buffer[508] == 0xDA && buffer[509] == 0xBE) {
 			q = (unsigned short *) (buffer + 510);
 			for (sum = 0; q >= (unsigned short *) buffer;)
 				sum ^= *q--;
 			if (!sum) {
-				error_msg("Device '%s' contains a valid Sun disklabel.\n"
+				bb_error_msg("Device '%s' contains a valid Sun disklabel.\n"
 "This probably means creating v0 swap would destroy your partition table\n"
 "No swap created. If you really want to create swap v0 on that device, use\n"
 "the -f option to force it.", device_name);
@@ -391,7 +391,7 @@ int mkswap_main(int argc, char **argv)
 	if (version == 0 || check)
 		check_blocks();
 	if (version == 0 && !bit_test_and_clear(signature_page, 0))
-		error_msg_and_die("fatal: first page unreadable");
+		bb_error_msg_and_die("fatal: first page unreadable");
 	if (version == 1) {
 		p->version = version;
 		p->last_page = PAGES - 1;
@@ -400,23 +400,23 @@ int mkswap_main(int argc, char **argv)
 
 	goodpages = PAGES - badpages - 1;
 	if (goodpages <= 0)
-		error_msg_and_die("Unable to set up swap-space: unreadable");
+		bb_error_msg_and_die("Unable to set up swap-space: unreadable");
 	printf("Setting up swapspace version %d, size = %ld bytes\n",
 		   version, (long) (goodpages * pagesize));
 	write_signature((version == 0) ? "SWAP-SPACE" : "SWAPSPACE2");
 
 	offset = ((version == 0) ? 0 : 1024);
 	if (lseek(DEV, offset, SEEK_SET) != offset)
-		error_msg_and_die("unable to rewind swap-device");
+		bb_error_msg_and_die("unable to rewind swap-device");
 	if (write(DEV, (char *) signature_page + offset, pagesize - offset)
 		!= pagesize - offset)
-		error_msg_and_die("unable to write signature page");
+		bb_error_msg_and_die("unable to write signature page");
 
 	/*
 	 * A subsequent swapon() will fail if the signature
 	 * is not actually on disk. (This is a kernel bug.)
 	 */
 	if (fsync(DEV))
-		error_msg_and_die("fsync failed");
+		bb_error_msg_and_die("fsync failed");
 	return EXIT_SUCCESS;
 }
diff --git a/util-linux/more.c b/util-linux/more.c
index c26e4fe54..ff0557d22 100644
--- a/util-linux/more.c
+++ b/util-linux/more.c
@@ -81,7 +81,7 @@ extern int more_main(int argc, char **argv)
 	if(isatty(fileno(stdout))) {
 		cin = fopen(CURRENT_TTY, "r");
 		if (!cin)
-			cin = xfopen(CONSOLE_DEV, "r");
+			cin = bb_xfopen(CONSOLE_DEV, "r");
 		please_display_more_prompt = 0;
 #ifdef CONFIG_FEATURE_USE_TERMIOS
 		getTermSettings(fileno(cin), &initial_settings);
@@ -105,7 +105,7 @@ extern int more_main(int argc, char **argv)
 		if (argc == 0) {
 			file = stdin;
 		} else
-			file = wfopen(*argv, "r");
+			file = bb_wfopen(*argv, "r");
 		if(file==0)
 			goto loop;
 			
diff --git a/util-linux/mount.c b/util-linux/mount.c
index b3e945ce3..d02005600 100644
--- a/util-linux/mount.c
+++ b/util-linux/mount.c
@@ -86,8 +86,6 @@ extern int umount2(__const char *__special_file, int __flags);
 
 extern int sysfs(int option, unsigned int fs_index, char *buf);
 
-extern const char mtab_file[];	/* Defined in utility.c */
-
 struct mount_options {
 	const char *name;
 	unsigned long and;
@@ -136,20 +134,20 @@ do_mount(char *specialfile, char *dir, char *filesystemtype, long flags,
 
 			specialfile = find_unused_loop_device();
 			if (specialfile == NULL) {
-				error_msg_and_die("Could not find a spare loop device");
+				bb_error_msg_and_die("Could not find a spare loop device");
 			}
 			if (set_loop(specialfile, lofile, 0, &loro)) {
-				error_msg_and_die("Could not setup loop device");
+				bb_error_msg_and_die("Could not setup loop device");
 			}
 			if (!(flags & MS_RDONLY) && loro) {	/* loop is ro, but wanted rw */
-				error_msg("WARNING: loop device is read-only");
+				bb_error_msg("WARNING: loop device is read-only");
 				flags |= MS_RDONLY;
 			}
 		}
 #endif
 		status = mount(specialfile, dir, filesystemtype, flags, string_flags);
 		if (status < 0 && errno == EROFS) {
-			error_msg("%s is write-protected, mounting read-only",
+			bb_error_msg("%s is write-protected, mounting read-only",
 					  specialfile);
 			status = mount(specialfile, dir, filesystemtype, flags |=
 						   MS_RDONLY, string_flags);
@@ -181,7 +179,7 @@ do_mount(char *specialfile, char *dir, char *filesystemtype, long flags,
 #endif
 
 	if (errno == EPERM) {
-		error_msg_and_die("permission denied. Are you root?");
+		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 	}
 
 	return (FALSE);
@@ -268,7 +266,7 @@ static int mount_one(char *blockDevice, char *directory, char *filesystemType,
 
 					filesystemType = buf;
 
-					if (xstrlen(filesystemType)) {
+					if (bb_strlen(filesystemType)) {
 						status =
 							do_mount(blockDevice, directory, filesystemType,
 									 flags | MS_MGC_VAL, string_flags,
@@ -284,7 +282,7 @@ static int mount_one(char *blockDevice, char *directory, char *filesystemType,
 		}
 
 		if ((!f || read_proc) && !status) {
-			f = xfopen("/proc/filesystems", "r");
+			f = bb_xfopen("/proc/filesystems", "r");
 
 			while (fgets(buf, sizeof(buf), f) != NULL) {
 				filesystemType = buf;
@@ -319,7 +317,7 @@ static int mount_one(char *blockDevice, char *directory, char *filesystemType,
 
 	if (!status) {
 		if (whineOnErrors) {
-			perror_msg("Mounting %s on %s failed", blockDevice, directory);
+			bb_perror_msg("Mounting %s on %s failed", blockDevice, directory);
 		}
 		return (FALSE);
 	}
@@ -328,7 +326,7 @@ static int mount_one(char *blockDevice, char *directory, char *filesystemType,
 
 static void show_mounts(char *onlytype)
 {
-	FILE *mountTable = setmntent(mtab_file, "r");
+	FILE *mountTable = setmntent(bb_path_mtab_file, "r");
 
 	if (mountTable) {
 		struct mntent *m;
@@ -351,7 +349,7 @@ static void show_mounts(char *onlytype)
 		}
 		endmntent(mountTable);
 	} else {
-		perror_msg_and_die("%s", mtab_file);
+		bb_perror_msg_and_die(bb_path_mtab_file);
 	}
 	exit(EXIT_SUCCESS);
 }
@@ -359,7 +357,7 @@ static void show_mounts(char *onlytype)
 extern int mount_main(int argc, char **argv)
 {
 	struct stat statbuf;
-	char *string_flags = xstrdup("");
+	char *string_flags = bb_xstrdup("");
 	char *extra_opts;
 	int flags = 0;
 	char *filesystemType = "auto";
@@ -413,7 +411,7 @@ extern int mount_main(int argc, char **argv)
 	if (optind < argc) {
 		/* if device is a filename get its real path */
 		if (stat(argv[optind], &statbuf) == 0) {
-			char *tmp = simplify_path(argv[optind]);
+			char *tmp = bb_simplify_path(argv[optind]);
 
 			safe_strncpy(device, tmp, PATH_MAX);
 		} else {
@@ -422,13 +420,13 @@ extern int mount_main(int argc, char **argv)
 	}
 
 	if (optind + 1 < argc)
-		directory = simplify_path(argv[optind + 1]);
+		directory = bb_simplify_path(argv[optind + 1]);
 
 	if (all || optind + 1 == argc) {
 		f = setmntent("/etc/fstab", "r");
 
 		if (f == NULL)
-			perror_msg_and_die("\nCannot read /etc/fstab");
+			bb_perror_msg_and_die("\nCannot read /etc/fstab");
 
 		while ((m = getmntent(f)) != NULL) {
 			if (!all && (optind + 1 == argc)
@@ -452,7 +450,7 @@ extern int mount_main(int argc, char **argv)
 
 			strcpy(device, m->mnt_fsname);
 			strcpy(directory, m->mnt_dir);
-			filesystemType = xstrdup(m->mnt_type);
+			filesystemType = bb_xstrdup(m->mnt_type);
 		  singlemount:
 			extra_opts = string_flags;
 			rc = EXIT_SUCCESS;
@@ -462,7 +460,7 @@ extern int mount_main(int argc, char **argv)
 				if (nfsmount
 					(device, directory, &flags, &extra_opts, &string_flags,
 					 1)) {
-					perror_msg("nfsmount failed");
+					bb_perror_msg("nfsmount failed");
 					rc = EXIT_FAILURE;
 				}
 			}
diff --git a/util-linux/nfsmount.c b/util-linux/nfsmount.c
index ba14aa6bc..0edfdf34a 100644
--- a/util-linux/nfsmount.c
+++ b/util-linux/nfsmount.c
@@ -357,7 +357,7 @@ int nfsmount(const char *spec, const char *node, int *flags,
 	msock = fsock = -1;
 	mclient = NULL;
 	if (strlen(spec) >= sizeof(hostdir)) {
-		error_msg("excessively long host:dir argument");
+		bb_error_msg("excessively long host:dir argument");
 		goto fail;
 	}
 	strcpy(hostdir, spec);
@@ -369,10 +369,10 @@ int nfsmount(const char *spec, const char *node, int *flags,
 		   until they can be fully supported. (mack@sgi.com) */
 		if ((s = strchr(hostdir, ','))) {
 			*s = '\0';
-			error_msg("warning: multiple hostnames not supported");
+			bb_error_msg("warning: multiple hostnames not supported");
 		}
 	} else {
-		error_msg("directory to mount not in host:dir format");
+		bb_error_msg("directory to mount not in host:dir format");
 		goto fail;
 	}
 
@@ -382,11 +382,11 @@ int nfsmount(const char *spec, const char *node, int *flags,
 #endif
 	{
 		if ((hp = gethostbyname(hostname)) == NULL) {
-			herror_msg("%s", hostname);
+			bb_herror_msg("%s", hostname);
 			goto fail;
 		} else {
 			if (hp->h_length > sizeof(struct in_addr)) {
-				error_msg("got bad hp->h_length");
+				bb_error_msg("got bad hp->h_length");
 				hp->h_length = sizeof(struct in_addr);
 			}
 			memcpy(&server_addr.sin_addr,
@@ -403,12 +403,12 @@ int nfsmount(const char *spec, const char *node, int *flags,
 	if (!old_opts)
 		old_opts = "";
 	if (strlen(old_opts) + strlen(s) + 10 >= sizeof(new_opts)) {
-		error_msg("excessively long option argument");
+		bb_error_msg("excessively long option argument");
 		goto fail;
 	}
 	sprintf(new_opts, "%s%saddr=%s",
 		old_opts, *old_opts ? "," : "", s);
-	*extra_opts = xstrdup(new_opts);
+	*extra_opts = bb_xstrdup(new_opts);
 
 	/* Set default options.
 	 * rsize/wsize (and bsize, for ver >= 3) are left 0 in order to
@@ -476,7 +476,7 @@ int nfsmount(const char *spec, const char *node, int *flags,
 			else if (!strcmp(opt, "mountport"))
 			        mountport = val;
 			else if (!strcmp(opt, "mounthost"))
-			        mounthost=xstrndup(opteq+1,
+			        mounthost=bb_xstrndup(opteq+1,
 						  strcspn(opteq+1," \t\n\r,"));
 			else if (!strcmp(opt, "mountprog"))
 				mountprog = val;
@@ -563,11 +563,11 @@ int nfsmount(const char *spec, const char *node, int *flags,
 		data.flags |= (nolock ? NFS_MOUNT_NONLM : 0);
 #endif
 	if (nfsvers > MAX_NFSPROT) {
-		error_msg("NFSv%d not supported!", nfsvers);
+		bb_error_msg("NFSv%d not supported!", nfsvers);
 		return 0;
 	}
 	if (mountvers > MAX_NFSPROT) {
-		error_msg("NFSv%d not supported!", nfsvers);
+		bb_error_msg("NFSv%d not supported!", nfsvers);
 		return 0;
 	}
 	if (nfsvers && !mountvers)
@@ -627,11 +627,11 @@ int nfsmount(const char *spec, const char *node, int *flags,
 	    mount_server_addr.sin_addr.s_addr = inet_addr(hostname);
 	  } else {
 		  if ((hp = gethostbyname(mounthost)) == NULL) {
-			  herror_msg("%s", mounthost);
+			  bb_herror_msg("%s", mounthost);
 			  goto fail;
 		  } else {
 			  if (hp->h_length > sizeof(struct in_addr)) {
-				  error_msg("got bad hp->h_length?");
+				  bb_error_msg("got bad hp->h_length?");
 				  hp->h_length = sizeof(struct in_addr);
 			  }
 			  mount_server_addr.sin_family = AF_INET;
@@ -753,7 +753,7 @@ int nfsmount(const char *spec, const char *node, int *flags,
 		if (!bg)
 		        goto fail;
 		if (!running_bg) {
-			prev_bg_host = xstrdup(hostname);
+			prev_bg_host = bb_xstrdup(hostname);
 			if (retry > 0)
 				retval = EX_BG;
 			goto fail;
@@ -766,7 +766,7 @@ int nfsmount(const char *spec, const char *node, int *flags,
 
 	if (nfsvers == 2) {
 		if (status.nfsv2.fhs_status != 0) {
-			error_msg("%s:%s failed, reason given by server: %s",
+			bb_error_msg("%s:%s failed, reason given by server: %s",
 				hostname, pathname,
 				nfs_strerror(status.nfsv2.fhs_status));
 			goto fail;
@@ -784,7 +784,7 @@ int nfsmount(const char *spec, const char *node, int *flags,
 #if NFS_MOUNT_VERSION >= 4
 		fhandle3 *my_fhandle;
 		if (status.nfsv3.fhs_status != 0) {
-			error_msg("%s:%s failed, reason given by server: %s",
+			bb_error_msg("%s:%s failed, reason given by server: %s",
 				hostname, pathname,
 				nfs_strerror(status.nfsv3.fhs_status));
 			goto fail;
diff --git a/util-linux/pivot_root.c b/util-linux/pivot_root.c
index ba26b9c58..39453a261 100644
--- a/util-linux/pivot_root.c
+++ b/util-linux/pivot_root.c
@@ -16,10 +16,10 @@ extern int pivot_root(const char * new_root,const char * put_old);
 int pivot_root_main(int argc, char **argv)
 {
     if (argc != 3)
-        show_usage();
+        bb_show_usage();
 
 	if (pivot_root(argv[1],argv[2]) < 0)
-		perror_msg_and_die("pivot_root");
+		bb_perror_msg_and_die("pivot_root");
 
     return EXIT_SUCCESS;
 
diff --git a/util-linux/rdate.c b/util-linux/rdate.c
index df7d7bbc4..3c3b152a2 100644
--- a/util-linux/rdate.c
+++ b/util-linux/rdate.c
@@ -49,7 +49,7 @@ static time_t askremotedate(const char *host)
 	fd = xconnect(host, port);
 
 	if (read(fd, (void *)&nett, 4) != 4)    /* read time from server */
-		error_msg_and_die("%s did not send the complete time", host);
+		bb_error_msg_and_die("%s did not send the complete time", host);
 
 	close(fd);
 
@@ -83,18 +83,18 @@ int rdate_main(int argc, char **argv)
 				setdate = 0;
 				break;
 			default:
-				show_usage();
+				bb_show_usage();
 		}
 	}
 
 	if (optind == argc)
-		show_usage();
+		bb_show_usage();
 
 	remote_time = askremotedate(argv[optind]);
 
 	if (setdate) {
 		if (stime(&remote_time) < 0)
-			perror_msg_and_die("Could not set time of day");
+			bb_perror_msg_and_die("Could not set time of day");
 	}
 
 	if (printdate)
diff --git a/util-linux/swaponoff.c b/util-linux/swaponoff.c
index 918a5bc0e..b323cb10a 100644
--- a/util-linux/swaponoff.c
+++ b/util-linux/swaponoff.c
@@ -51,13 +51,13 @@ static int swap_enable_disable(const char *device)
 	struct stat st;
 
 	if (stat(device, &st) < 0) {
-		perror_msg_and_die("cannot stat %s");
+		bb_perror_msg_and_die("cannot stat %s", device);
 	}
 
 	/* test for holes */
 	if (S_ISREG(st.st_mode)) {
 		if (st.st_blocks * 512 < st.st_size) {
-			error_msg_and_die("swap file has holes");
+			bb_error_msg_and_die("swap file has holes");
 		}
 	}
 
@@ -67,7 +67,7 @@ static int swap_enable_disable(const char *device)
 		status = swapoff(device);
 
 	if (status != 0) {
-		perror_msg("%s", device);
+		bb_perror_msg("%s", device);
 		return EXIT_FAILURE;
 	}
 	return EXIT_SUCCESS;
@@ -80,7 +80,7 @@ static int do_em_all(void)
 	int err = 0;
 
 	if (f == NULL)
-		perror_msg_and_die("/etc/fstab");
+		bb_perror_msg_and_die("/etc/fstab");
 	while ((m = getmntent(f)) != NULL) {
 		if (strcmp(m->mnt_type, MNTTYPE_SWAP)==0) {
 			if(swap_enable_disable(m->mnt_fsname) == EXIT_FAILURE)
@@ -94,7 +94,7 @@ static int do_em_all(void)
 
 extern int swap_on_off_main(int argc, char **argv)
 {
-	if (applet_name[5] == 'f') { /* "swapoff" */
+	if (bb_applet_name[5] == 'f') { /* "swapoff" */
 		whichApp = SWAPOFF_APP;
 	}
 
@@ -113,7 +113,7 @@ extern int swap_on_off_main(int argc, char **argv)
 					struct stat statBuf;
 
 					if (stat("/etc/fstab", &statBuf) < 0)
-						error_msg_and_die("/etc/fstab file missing");
+						bb_error_msg_and_die("/etc/fstab file missing");
 				}
 				return do_em_all();
 				break;
@@ -124,5 +124,5 @@ extern int swap_on_off_main(int argc, char **argv)
 	return swap_enable_disable(*argv);
 
   usage_and_exit:
-	show_usage();
+	bb_show_usage();
 }
diff --git a/util-linux/umount.c b/util-linux/umount.c
index 391d245a8..1d3e89301 100644
--- a/util-linux/umount.c
+++ b/util-linux/umount.c
@@ -67,7 +67,6 @@ static int useMtab = TRUE;
 #endif
 static int umountAll = FALSE;
 static int doRemount = FALSE;
-extern const char mtab_file[];	/* Defined in utility.c */
 
 
 
@@ -87,8 +86,8 @@ static void mtab_read(void)
 	if (mtab_cache != NULL)
 		return;
 
-	if ((fp = setmntent(mtab_file, "r")) == NULL) {
-		error_msg("Cannot open %s", mtab_file);
+	if ((fp = setmntent(bb_path_mtab_file, "r")) == NULL) {
+		bb_error_msg("Cannot open %s", bb_path_mtab_file);
 		return;
 	}
 	while ((e = getmntent(fp))) {
@@ -185,7 +184,7 @@ static int do_umount(const char *name)
 	if (status != 0 && doForce) {
 		status = umount2(blockDevice, MNT_FORCE);
 		if (status != 0) {
-			error_msg_and_die("forced umount of %s failed!", blockDevice);
+			bb_error_msg_and_die("forced umount of %s failed!", blockDevice);
 		}
 	}
 #endif
@@ -193,9 +192,9 @@ static int do_umount(const char *name)
 		status = mount(blockDevice, name, NULL,
 					   MS_MGC_VAL | MS_REMOUNT | MS_RDONLY, NULL);
 		if (status == 0) {
-			error_msg("%s busy - remounted read-only", blockDevice);
+			bb_error_msg("%s busy - remounted read-only", blockDevice);
 		} else {
-			error_msg("Cannot remount %s read-only", blockDevice);
+			bb_error_msg("Cannot remount %s read-only", blockDevice);
 		}
 	}
 	if (status == 0) {
@@ -221,7 +220,7 @@ static int umount_all(void)
 		if (!do_umount(mountpt)) {
 			/* Don't bother retrying the umount on busy devices */
 			if (errno == EBUSY) {
-				perror_msg("%s", mountpt);
+				bb_perror_msg("%s", mountpt);
 				status = FALSE;
 				continue;
 			}
@@ -241,7 +240,7 @@ extern int umount_main(int argc, char **argv)
 	char path[PATH_MAX];
 
 	if (argc < 2) {
-		show_usage();
+		bb_show_usage();
 	}
 #ifdef CONFIG_FEATURE_CLEAN_UP
 	atexit(mtab_free);
@@ -275,7 +274,7 @@ extern int umount_main(int argc, char **argv)
 			case 'v':
 				break; /* ignore -v */
 			default:
-				show_usage();
+				bb_show_usage();
 			}
 	}
 
@@ -287,9 +286,9 @@ extern int umount_main(int argc, char **argv)
 			return EXIT_FAILURE;
 	}
 	if (realpath(*argv, path) == NULL)
-		perror_msg_and_die("%s", path);
+		bb_perror_msg_and_die("%s", path);
 	if (do_umount(path))
 		return EXIT_SUCCESS;
-	perror_msg_and_die("%s", *argv);
+	bb_perror_msg_and_die("%s", *argv);
 }
 