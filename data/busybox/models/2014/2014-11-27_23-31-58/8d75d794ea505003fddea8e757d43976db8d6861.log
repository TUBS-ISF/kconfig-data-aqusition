"2014-11-27 23:31:58 +0100"
diff --git a/Config.in b/Config.in
index b83beb52d..285fe0a19 100644
--- a/Config.in
+++ b/Config.in
@@ -264,6 +264,18 @@ config PAM
 	  Use PAM in some busybox applets (currently login and httpd) instead
 	  of direct access to password database.
 
+config FEATURE_USE_SENDFILE
+	bool "Use sendfile system call"
+	default y
+	help
+	  When enabled, busybox will use the kernel sendfile() function
+	  instead of read/write loops to copy data between file descriptors
+	  (for example, cp command does this a lot).
+	  If sendfile() doesn't work, copying code falls back to read/write
+	  loop. sendfile() was originally implemented for faster I/O
+	  from files to sockets, but since Linux 2.6.33 it was extended
+	  to work for many more file types.
+
 config LONG_OPTS
 	bool "Support for --long-options"
 	default y
diff --git a/libbb/copyfd.c b/libbb/copyfd.c
index eda2747f9..7e3531903 100644
--- a/libbb/copyfd.c
+++ b/libbb/copyfd.c
@@ -8,6 +8,20 @@
  */
 
 #include "libbb.h"
+#if ENABLE_FEATURE_USE_SENDFILE
+# include <sys/sendfile.h>
+#else
+# define sendfile(a,b,c,d) (-1)
+#endif
+
+/*
+ * We were using 0x7fff0000 as sendfile chunk size, but it
+ * was seen to cause largish delays when user tries to ^C a file copy.
+ * Let's use a saner size.
+ * Note: needs to be >= max(CONFIG_FEATURE_COPYBUF_KB),
+ * or else "copy to eof" code will use neddlesly short reads.
+ */
+#define SENDFILE_BIGBUF (16*1024*1024)
 
 /* Used by NOFORK applets (e.g. cat) - must not use xmalloc.
  * size < 0 means "ignore write errors", used by tar --to-command
@@ -18,12 +32,13 @@ static off_t bb_full_fd_action(int src_fd, int dst_fd, off_t size)
 	int status = -1;
 	off_t total = 0;
 	bool continue_on_write_error = 0;
-#if CONFIG_FEATURE_COPYBUF_KB <= 4
+	ssize_t sendfile_sz;
+#if CONFIG_FEATURE_COPYBUF_KB > 4
+	char *buffer = buffer; /* for compiler */
+	int buffer_size = 0;
+#else
 	char buffer[CONFIG_FEATURE_COPYBUF_KB * 1024];
 	enum { buffer_size = sizeof(buffer) };
-#else
-	char *buffer;
-	int buffer_size;
 #endif
 
 	if (size < 0) {
@@ -31,46 +46,58 @@ static off_t bb_full_fd_action(int src_fd, int dst_fd, off_t size)
 		continue_on_write_error = 1;
 	}
 
-#if CONFIG_FEATURE_COPYBUF_KB > 4
-	if (size > 0 && size <= 4 * 1024)
-		goto use_small_buf;
-	/* We want page-aligned buffer, just in case kernel is clever
-	 * and can do page-aligned io more efficiently */
-	buffer = mmap(NULL, CONFIG_FEATURE_COPYBUF_KB * 1024,
-			PROT_READ | PROT_WRITE,
-			MAP_PRIVATE | MAP_ANON,
-			/* ignored: */ -1, 0);
-	buffer_size = CONFIG_FEATURE_COPYBUF_KB * 1024;
-	if (buffer == MAP_FAILED) {
- use_small_buf:
-		buffer = alloca(4 * 1024);
-		buffer_size = 4 * 1024;
-	}
-#endif
-
 	if (src_fd < 0)
 		goto out;
 
+	sendfile_sz = !ENABLE_FEATURE_USE_SENDFILE
+		? 0
+		: SENDFILE_BIGBUF;
 	if (!size) {
-		size = buffer_size;
+		size = SENDFILE_BIGBUF;
 		status = 1; /* copy until eof */
 	}
 
 	while (1) {
 		ssize_t rd;
 
-		rd = safe_read(src_fd, buffer, size > buffer_size ? buffer_size : size);
-
-		if (!rd) { /* eof - all done */
-			status = 0;
-			break;
+		if (sendfile_sz) {
+			rd = sendfile(dst_fd, src_fd, NULL,
+				size > sendfile_sz ? sendfile_sz : size);
+			if (rd >= 0)
+				goto read_ok;
+			sendfile_sz = 0; /* do not try sendfile anymore */
+		}
+#if CONFIG_FEATURE_COPYBUF_KB > 4
+		if (buffer_size == 0) {
+			if (size > 0 && size <= 4 * 1024)
+				goto use_small_buf;
+			/* We want page-aligned buffer, just in case kernel is clever
+			 * and can do page-aligned io more efficiently */
+			buffer = mmap(NULL, CONFIG_FEATURE_COPYBUF_KB * 1024,
+					PROT_READ | PROT_WRITE,
+					MAP_PRIVATE | MAP_ANON,
+					/* ignored: */ -1, 0);
+			buffer_size = CONFIG_FEATURE_COPYBUF_KB * 1024;
+			if (buffer == MAP_FAILED) {
+ use_small_buf:
+				buffer = alloca(4 * 1024);
+				buffer_size = 4 * 1024;
+			}
 		}
+#endif
+		rd = safe_read(src_fd, buffer,
+			size > buffer_size ? buffer_size : size);
 		if (rd < 0) {
 			bb_perror_msg(bb_msg_read_error);
 			break;
 		}
+ read_ok:
+		if (!rd) { /* eof - all done */
+			status = 0;
+			break;
+		}
 		/* dst_fd == -1 is a fake, else... */
-		if (dst_fd >= 0) {
+		if (dst_fd >= 0 && !sendfile_sz) {
 			ssize_t wr = full_write(dst_fd, buffer, rd);
 			if (wr < rd) {
 				if (!continue_on_write_error) {
@@ -92,10 +119,8 @@ static off_t bb_full_fd_action(int src_fd, int dst_fd, off_t size)
 	}
  out:
 
-#if CONFIG_FEATURE_COPYBUF_KB > 4
-	if (buffer_size != 4 * 1024)
+	if (buffer_size > 4 * 1024)
 		munmap(buffer, buffer_size);
-#endif
 	return status ? -1 : total;
 }
 
diff --git a/networking/Config.src b/networking/Config.src
index e56646917..15a696876 100644
--- a/networking/Config.src
+++ b/networking/Config.src
@@ -181,14 +181,6 @@ config FEATURE_HTTPD_RANGES
 	  "Range: bytes=NNN-[MMM]" header. Allows for resuming interrupted
 	  downloads, seeking in multimedia players etc.
 
-config FEATURE_HTTPD_USE_SENDFILE
-	bool "Use sendfile system call"
-	default y
-	depends on HTTPD
-	help
-	  When enabled, httpd will use the kernel sendfile() function
-	  instead of read/write loop.
-
 config FEATURE_HTTPD_SETUID
 	bool "Enable -u <user> option"
 	default y
diff --git a/networking/httpd.c b/networking/httpd.c
index 621d9cddc..9cf080401 100644
--- a/networking/httpd.c
+++ b/networking/httpd.c
@@ -133,7 +133,7 @@
 # include <security/pam_appl.h>
 # include <security/pam_misc.h>
 #endif
-#if ENABLE_FEATURE_HTTPD_USE_SENDFILE
+#if ENABLE_FEATURE_USE_SENDFILE
 # include <sys/sendfile.h>
 #endif
 /* amount of buffering in a pipe */
@@ -1624,7 +1624,7 @@ static NOINLINE void send_file_and_exit(const char *url, int what)
 #endif
 	if (what & SEND_HEADERS)
 		send_headers(HTTP_OK);
-#if ENABLE_FEATURE_HTTPD_USE_SENDFILE
+#if ENABLE_FEATURE_USE_SENDFILE
 	{
 		off_t offset = range_start;
 		while (1) {
@@ -1654,7 +1654,7 @@ static NOINLINE void send_file_and_exit(const char *url, int what)
 			break;
 	}
 	if (count < 0) {
- IF_FEATURE_HTTPD_USE_SENDFILE(fin:)
+ IF_FEATURE_USE_SENDFILE(fin:)
 		if (verbose > 1)
 			bb_perror_msg("error");
 	}