"2002-12-05 08:41:41 +0000"
diff --git a/.cvsignore b/.cvsignore
index 9150aa544..4e4f5863e 100644
--- a/.cvsignore
+++ b/.cvsignore
@@ -3,3 +3,5 @@ busybox.links
 _install
 .config
 .menuconfig.log
+.config.cmd
+.config.old
diff --git a/Makefile b/Makefile
index d61d945a6..69ab48ec3 100644
--- a/Makefile
+++ b/Makefile
@@ -17,34 +17,27 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 #
 
-TOPDIR:= $(shell /bin/pwd)/
-include $(TOPDIR).config
-include $(TOPDIR)Rules.mak
-SUBDIRS:=applets archival archival/libunarchive console-tools debianutils \
+#--------------------------------------------------------------
+# You shouldn't need to mess with anything beyond this point...
+#--------------------------------------------------------------
+noconfig_targets := menuconfig config oldconfig randconfig \
+	defconfig allyesconfig allnoconfig clean distclean \
+	release tags
+TOPDIR=./
+include Rules.mak
+
+DIRS:=applets archival archival/libunarchive console-tools debianutils \
 	editors fileutils findutils init miscutils modutils networking \
 	networking/libiproute networking/udhcp procps loginutils shell \
 	shellutils sysklogd textutils util-linux libbb libpwdgrp
 
-all:    do-it-all
+ifdef include_config
 
-#
-# Make "config" the default target if there is no configuration file or
-# "depend" the target if there is no top-level dependency information.
-ifeq (.config,$(wildcard .config))
-include .config
-ifeq (.depend,$(wildcard .depend))
-include .depend 
-do-it-all:      busybox busybox.links #doc
-include $(patsubst %,%/Makefile.in, $(SUBDIRS))
-else
-CONFIGURATION = depend
-do-it-all:      depend
-endif
-else
-CONFIGURATION = menuconfig
-do-it-all:      menuconfig
-endif
+all: busybox busybox.links #doc
 
+# In this section, we need .config
+-include .config.cmd
+include $(patsubst %,%/Makefile.in, $(DIRS))
 
 busybox: depend $(libraries-y)
 	$(CC) $(LDFLAGS) -o $@ $(libraries-y) $(LIBRARIES)
@@ -124,92 +117,88 @@ docs/busybox/busyboxdocumentation.html: docs/busybox.sgml
 	- mkdir -p docs
 	(cd docs/busybox.net; sgmltools -b html ../busybox.sgml)
 
-
-
 # The nifty new buildsystem stuff
-$(TOPDIR)scripts/mkdep: scripts/mkdep.c
+scripts/mkdep: scripts/mkdep.c
 	$(HOSTCC) $(HOSTCFLAGS) -o scripts/mkdep scripts/mkdep.c
 
-$(TOPDIR)scripts/split-include: scripts/split-include.c
+scripts/split-include: scripts/split-include.c
 	$(HOSTCC) $(HOSTCFLAGS) -o scripts/split-include scripts/split-include.c
 
-$(TOPDIR).depend: $(TOPDIR)scripts/mkdep
+.depend: scripts/mkdep
 	rm -f .depend .hdepend;
-	mkdir -p $(TOPDIR)include/config;
+	mkdir -p include/config;
 	$(HOSTCC) $(HOSTCFLAGS) -o scripts/mkdep scripts/mkdep.c
-	scripts/mkdep -I $(TOPDIR)include -- \
-		`find $(TOPDIR) -name \*.c -print` >> .depend;
-	scripts/mkdep -I $(TOPDIR)include -- \
-		`find $(TOPDIR) -name \*.h -print` >> .hdepend;
-	$(MAKE) $(patsubst %,_sfdep_%,$(SUBDIRS)) _FASTDEP_ALL_SUB_DIRS="$(SUBDIRS)" ;
-	@ echo -e "\n\nNow run 'make' to build BusyBox\n\n"
-
-depend dep: $(TOPDIR)include/config.h $(TOPDIR).depend
+	scripts/mkdep -I include -- \
+		`find . -name \*.c -print` >> .depend;
+	scripts/mkdep -I include -- \
+		`find . -name \*.h -print` >> .hdepend;
+	$(MAKE) $(patsubst %,_sfdep_%,$(DIRS)) _FASTDEP_ALL_SUB_DIRS="$(DIRS)" ;
 
-BB_SHELL := ${shell if [ -x "$$BASH" ]; then echo $$BASH; \
-	else if [ -x /bin/bash ]; then echo /bin/bash; \
-	else echo sh; fi ; fi}
+depend dep: include/config.h .depend
 
-include/config/MARKER: depend $(TOPDIR)scripts/split-include
+include/config/MARKER: depend scripts/split-include
 	scripts/split-include include/config.h include/config
 	@ touch include/config/MARKER
 
-$(TOPDIR)include/config.h:
-	@if [ ! -f $(TOPDIR)include/config.h ] ; then \
-		make oldconfig; \
+include/config.h: .config
+	@if [ ! -x ./scripts/config/conf ] ; then \
+	    make -C scripts/config; \
 	fi;
+	@./scripts/config/conf -o sysdeps/$(TARGET_OS)/Config.in
 
-$(TOPDIR).config:
-	@if [ ! -f $(TOPDIR).config ] ; then \
-	    cp $(TOPDIR)sysdeps/$(TARGET_OS)/defconfig $(TOPDIR).config; \
-	fi;
+%.o: %.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c -o $@ $<
 
-menuconfig: $(TOPDIR).config
-	mkdir -p $(TOPDIR)include/config
-	$(MAKE) -C scripts/lxdialog all
-	$(BB_SHELL) scripts/Menuconfig sysdeps/$(TARGET_OS)/config.in
+finished2:
+	@echo
+	@echo Finished installing...
+	@echo
 
-config: $(TOPDIR).config
-	mkdir -p $(TOPDIR)include/config
-	$(BB_SHELL) scripts/Configure sysdeps/$(TARGET_OS)/config.in
+else # ifdef include_config
 
-oldconfig: $(TOPDIR).config
-	mkdir -p $(TOPDIR)include/config
-	$(BB_SHELL) scripts/Configure -d sysdeps/$(TARGET_OS)/config.in
+all: menuconfig
 
+ifeq ($(filter-out $(noconfig_targets),$(MAKECMDGOALS)),)
+# Targets which don't need .config
 
-ifdef CONFIGURATION
-..$(CONFIGURATION):
-	@echo
-	@echo "You have a bad or nonexistent" .$(CONFIGURATION) ": running 'make" $(CONFIGURATION)"'"
-	@echo
-	$(MAKE) $(CONFIGURATION)
-	@echo
-	@echo "Successful. Try re-making (ignore the error that follows)"
-	@echo
-	exit 1
+# configuration
+# ---------------------------------------------------------------------------
 
-dummy:
+scripts/config/conf scripts/config/mconf:
+	make -C scripts/config
+	-@if [ ! -f .config ] ; then \
+		cp sysdeps/$(TARGET_OS)/defconfig .config; \
+	fi
 
-else
+menuconfig: scripts/config/mconf
+	@./scripts/config/mconf sysdeps/$(TARGET_OS)/Config.in
 
-dummy:
+config: scripts/config/conf
+	@./scripts/config/conf sysdeps/$(TARGET_OS)/Config.in
 
-endif
+oldconfig: scripts/config/conf
+	@./scripts/config/conf -o sysdeps/$(TARGET_OS)/Config.in
 
+randconfig: scripts/config/conf
+	@./scripts/config/conf -r sysdeps/$(TARGET_OS)/Config.in
 
-%.o: %.c
-	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -c -o $@ $<
+allyesconfig: scripts/config/conf
+	@./scripts/config/conf -y sysdeps/$(TARGET_OS)/Config.in
+
+allnoconfig: scripts/config/conf
+	@./scripts/config/conf -n sysdeps/$(TARGET_OS)/Config.in
 
+defconfig: scripts/config/conf
+	@./scripts/config/conf -d sysdeps/$(TARGET_OS)/Config.in
 
-# Testing...
-test tests:
-	# old way of doing it
-	#cd tests && $(MAKE) all
-	# new way of doing it
+test tests: busybox
+	# Note that 'tests' is depricated.  Use 'make check' instead
+	# To use the nice new testsuite....
 	cd tests && ./tester.sh
 
-# Cleanup
+check: busybox
+	cd testsuite && ./runtest
+
 clean:
 	- $(MAKE) -C tests clean
 	- $(MAKE) -C scripts/lxdialog clean
@@ -227,10 +216,9 @@ clean:
 	- find . -name \*.a -exec rm -f {} \;
 
 distclean: clean
-	- rm -f busybox 
-	- cd tests && $(MAKE) distclean
+	rm -f .config .config.old .config.cmd
 
-dist release: distclean doc
+release: distclean #doc
 	cd ..;					\
 	rm -rf busybox-$(VERSION);		\
 	cp -a busybox busybox-$(VERSION);	\
@@ -247,13 +235,14 @@ dist release: distclean doc
 						\
 	tar -cvzf busybox-$(VERSION).tar.gz busybox-$(VERSION)/;
 
+tags:
+	ctags -R .
 
 
-.PHONY: tags check depend
+endif # ifeq ($(filter-out $(noconfig_targets),$(MAKECMDGOALS)),)
+endif # ifdef include_config
 
-tags:
-	ctags -R .
+.PHONY: dummy subdirs release distclean clean config oldconfig \
+	menuconfig tags check test tests depend
 
-check: busybox
-	cd testsuite && ./runtest
 
diff --git a/Rules.mak b/Rules.mak
index 56c4025b2..58c03b6e8 100644
--- a/Rules.mak
+++ b/Rules.mak
@@ -17,68 +17,25 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 #
 
+#--------------------------------------------------------
 PROG      := busybox
 VERSION   := 0.61.pre
 BUILDTIME := $(shell TZ=UTC date -u "+%Y.%m.%d-%H:%M%z")
-HOSTCC    := gcc
-HOSTCFLAGS:= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 
 
-# What OS are you compiling busybox for?  This allows you to include
-# OS specific things, syscall overrides, etc.
-TARGET_OS:=linux
-
+#--------------------------------------------------------
 # With a modern GNU make(1) (highly recommended, that's what all the
 # developers use), all of the following configuration values can be
 # overridden at the command line.  For example:
 #   make CROSS=powerpc-linux- BB_SRC_DIR=$HOME/busybox PREFIX=/mnt/app
+#--------------------------------------------------------
 
-# If you want to add some simple compiler switches (like -march=i686),
-# especially from the command line, use this instead of CFLAGS directly.
-# For optimization overrides, it's better still to set OPTIMIZATION.
-CFLAGS_EXTRA:=#-Werror
- 
-# If you want a static binary, turn this on.
-DOSTATIC:=false
-
-# Set the following to `true' to make a debuggable build.
-# Leave this set to `false' for production use.
-DODEBUG:=false
-
-# This enables compiling with dmalloc ( http://dmalloc.com/ )
-# which is an excellent public domain mem leak and malloc problem
-# detector.  To enable dmalloc, before running busybox you will
-# want to first set up your environment.
-# eg: `export DMALLOC_OPTIONS=debug=0x34f47d83,inter=100,log=logfile`
-# The debug= value is generated using the following command
-# dmalloc -p log-stats -p log-non-free -p log-bad-space -p log-elapsed-time \
-#      -p check-fence -p check-heap -p check-lists -p check-blank \
-#      -p check-funcs -p realloc-copy -p allow-free-null
-# Do not enable this for production builds...
-DODMALLOC:=false
-
-# Electric-fence is another very useful malloc debugging library.
-# Do not enable this for production builds...
-DOEFENCE:=false
-
-# If you want large file summit support, turn this on.
-# This has no effect if you don't have a kernel with lfs
-# support, and a system with libc-2.1.3 or later.
-# Some of the programs that can benefit from lfs support
-# are dd, gzip, mount, tar, and mkfs_minix.
-# LFS allows you to use the above programs for files
-# larger than 2GB!
-DOLFS:=false
-
-# If you have a "pristine" source directory, point BB_SRC_DIR to it.
-# Experimental and incomplete; tell the mailing list
-# <busybox@busybox.net> if you do or don't like it so far.
-BB_SRC_DIR:=
-
-# If you are running a cross compiler, you may want to set CROSS
-# to something more interesting, like "arm-linux-".
-CROSS:=
-CC             := $(CROSS)gcc
+# If you are running a cross compiler, you will want to set 'CROSS'
+# to something more interesting...  Target architecture is determined
+# by asking the CC compiler what arch it compiles things for, so unless
+# your compiler is broken, you should not need to specify TARGET_ARCH
+CROSS           =$(subst ",, $(strip $(CROSS_COMPILER_PREFIX)))
+CC             = $(CROSS)gcc
 AR             := $(CROSS)ar
 AS             := $(CROSS)as
 LD             := $(CROSS)ld
@@ -86,12 +43,24 @@ NM             := $(CROSS)nm
 STRIP          := $(CROSS)strip
 CPP            := $(CC) -E
 MAKEFILES      := $(TOPDIR).config
-export VERSION BUILDTIME TOPDIR HOSTCC HOSTCFLAGS CROSS CC AR AS LD NM STRIP CPP
 
+# What OS are you compiling busybox for?  This allows you to include
+# OS specific things, syscall overrides, etc.
+TARGET_OS:=linux
+
+# Select the compiler needed to build binaries for your development system
+HOSTCC    := gcc
+HOSTCFLAGS:= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 
-# To compile vs uClibc, just use the compiler wrapper built by uClibc...
-# Everything should compile and work as expected these days...
-#CC:=/usr/i386-linux-uclibc/bin/i386-uclibc-gcc
+# If you want to add some simple compiler switches (like -march=i686),
+# especially from the command line, use this instead of CFLAGS directly.
+# For optimization overrides, it's better still to set OPTIMIZATION.
+CFLAGS_EXTRA=$(subst ",, $(strip $(EXTRA_CFLAGS_OPTIONS)))
+ 
+# If you have a "pristine" source directory, point BB_SRC_DIR to it.
+# Experimental and incomplete; tell the mailing list
+# <busybox@busybox.net> if you do or don't like it so far.
+BB_SRC_DIR:=
 
 # To compile vs some other alternative libc, you may need to use/adjust
 # the following lines to meet your needs...
@@ -115,7 +84,10 @@ WARNINGS:=-Wall -Wstrict-prototypes -Wshadow
 CFLAGS:=-I$(TOPDIR)include
 ARFLAGS:=-r
 
-TARGET_ARCH:=${shell $(CC) -dumpmachine | sed -e s'/-.*//' \
+#--------------------------------------------------------
+export VERSION BUILDTIME TOPDIR HOSTCC HOSTCFLAGS CROSS CC AR AS LD NM STRIP CPP
+ifeq ($(strip $(TARGET_ARCH)),)
+TARGET_ARCH:=$(shell $(CC) -dumpmachine | sed -e s'/-.*//' \
 		-e 's/i.86/i386/' \
 		-e 's/sparc.*/sparc/' \
 		-e 's/arm.*/arm/g' \
@@ -123,8 +95,18 @@ TARGET_ARCH:=${shell $(CC) -dumpmachine | sed -e s'/-.*//' \
 		-e 's/ppc/powerpc/g' \
 		-e 's/v850.*/v850/g' \
 		-e 's/sh[234]/sh/' \
-		-e 's/mips.*/mips/' \
-		}
+		-e 's/mips-.*/mips/' \
+		-e 's/mipsel-.*/mipsel/' \
+		-e 's/cris.*/cris/' \
+		)
+endif
+
+# Pull in the user's uClibc configuration
+ifeq ($(filter $(noconfig_targets),$(MAKECMDGOALS)),)
+include_config := 1
+-include $(TOPDIR).config
+endif
+
 # A nifty macro to make testing gcc features easier
 check_gcc=$(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; \
 	then echo "$(1)"; else echo "$(2)"; fi)
@@ -159,24 +141,20 @@ OPTIMIZATIONS:=$(OPTIMIZATION) -fomit-frame-pointer
 # prone to casual user adjustment.
 # 
 
-ifeq ($(strip $(DOLFS)),true)
+ifeq ($(strip $(DOLFS)),y)
     # For large file summit support
     CFLAGS+=-D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64
 endif
-ifeq ($(strip $(DODMALLOC)),true)
+ifeq ($(strip $(DODMALLOC)),y)
     # For testing mem leaks with dmalloc
     CFLAGS+=-DDMALLOC
     LIBRARIES:=-ldmalloc
-    # Force debug=true, since this is useless when not debugging...
-    DODEBUG:=true
 else
-    ifeq ($(strip $(DOEFENCE)),true)
+    ifeq ($(strip $(DOEFENCE)),y)
 	LIBRARIES:=-lefence
-	# Force debug=true, since this is useless when not debugging...
-	DODEBUG:=true
     endif
 endif
-ifeq ($(strip $(DODEBUG)),true)
+ifeq ($(strip $(DODEBUG)),y)
     CFLAGS  +=$(WARNINGS) -g -D_GNU_SOURCE
     LDFLAGS +=-Wl,-warn-common
     STRIPCMD:=/bin/true -Not_stripping_since_we_are_debugging
@@ -185,7 +163,7 @@ else
     LDFLAGS += -s -Wl,-warn-common
     STRIPCMD:=$(STRIP) --remove-section=.note --remove-section=.comment
 endif
-ifeq ($(strip $(DOSTATIC)),true)
+ifeq ($(strip $(DOSTATIC)),y)
     LDFLAGS += --static
 endif
 
@@ -203,8 +181,6 @@ ifneq ($(strip $(BB_SRC_DIR)),)
     VPATH:=$(BB_SRC_DIR)
 endif
 
-CFLAGS    += -DBB_VER='"$(VERSION)"'
-CFLAGS    += -DBB_BT='"$(BUILDTIME)"'
 OBJECTS:=$(APPLET_SOURCES:.c=.o) busybox.o usage.o applets.o
 CFLAGS    += $(CROSS_CFLAGS)
 ifdef BB_INIT_SCRIPT
diff --git a/archival/Config.in b/archival/Config.in
new file mode 100644
index 000000000..ecef07f7c
--- /dev/null
+++ b/archival/Config.in
@@ -0,0 +1,158 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Archival Utilities"
+
+config CONFIG_AR
+	bool "ar"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_AR_LONG_FILENAMES
+	bool "  Enable support for long filenames (not need for debs)"
+	default n
+	depends on CONFIG_AR
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_BUNZIP2
+	bool "bunzip2"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_CPIO
+	bool "cpio"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_DPKG
+	bool "dpkg"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_DPKG_DEB
+	bool "dpkg_deb"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_DPKG_DEB_EXTRACT_ONLY
+	bool "  extract only (-x)"
+	default n
+	depends on CONFIG_DPKG_DEB
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_DEB_TAR_GZ
+	bool "  gzip debian packages (normal)"
+	default y if CONFIG_DPKG || CONFIG_DPKG_DEB
+	depends on CONFIG_DPKG || CONFIG_DPKG_DEB
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_DEB_TAR_BZ2
+	bool "  bzip2 debian packages"
+	default n
+	depends on CONFIG_DPKG || CONFIG_DPKG_DEB
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_GUNZIP
+	bool "gunzip"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_GUNZIP_UNCOMPRESS
+	bool "  Uncompress support"
+	default n
+	depends on CONFIG_GUNZIP
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_GZIP
+	bool "gzip"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_RPM2CPIO
+	bool "rpm2cpio"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_TAR
+	bool "tar"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TAR_CREATE
+	bool "  Enable archive creation"
+	default y
+	depends on CONFIG_TAR
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TAR_BZIP2
+	bool "  Enable -j option to handle .tar.bz2 files"
+	default n
+	depends on CONFIG_TAR
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TAR_EXCLUDE
+	bool "  Enable -X and --exclude options (exclude files)"
+	default n
+	depends on CONFIG_TAR
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TAR_GZIP
+	bool "  Enable -z option"
+	default y
+	depends on CONFIG_TAR
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TAR_OLD_FORMAT
+	bool "  Enable support for old tar header format"
+	default n
+	depends on CONFIG_TAR
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_GNUTAR_LONG_FILENAME
+	bool "  Enable support for GNU long filenames"
+	default y
+	depends on CONFIG_TAR
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_UNARCHIVE_TAPE
+	bool "  Enable tape drive support"
+	default n
+	depends on CONFIG_TAR || CONFIG_CPIO
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_UNCOMPRESS
+	bool "uncompress"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_UNZIP
+	bool "unzip"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
diff --git a/archival/config.in b/archival/config.in
deleted file mode 100644
index 05e6dcae4..000000000
--- a/archival/config.in
+++ /dev/null
@@ -1,45 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Archival Utilities'
-
-bool 'ar'	    CONFIG_AR
-if [ "$CONFIG_AR" = "y" ] ; then
-    bool '  Enable support for long filenames (not need for debs)'	CONFIG_FEATURE_AR_LONG_FILENAMES
-fi
-bool 'bunzip2'	    CONFIG_BUNZIP2
-bool 'cpio'	    CONFIG_CPIO
-bool 'dpkg'	    CONFIG_DPKG
-bool 'dpkg_deb'	    CONFIG_DPKG_DEB
-if [ "$CONFIG_DPKG_DEB" = "y" ] ; then
-    bool '  extract only (-x)'	CONFIG_FEATURE_DPKG_DEB_EXTRACT_ONLY
-fi
-if [ "$CONFIG_DPKG" = "y" ] || [ "$CONFIG_DPKG_DEB" = "y" ] ; then
-    comment 'Common dpkg/dpkg-deb options'
-    bool '  gzip debian packages (normal)'      CONFIG_FEATURE_DEB_TAR_GZ
-    bool '  bzip2 debian packages'              CONFIG_FEATURE_DEB_TAR_BZ2
-fi
-bool 'gunzip'	    CONFIG_GUNZIP
-if [ "$CONFIG_GUNZIP" = "y" ]; then
-    bool '  Uncompress support'		CONFIG_FEATURE_GUNZIP_UNCOMPRESS
-fi
-bool 'gzip'	    CONFIG_GZIP
-bool 'rpm2cpio'     CONFIG_RPM2CPIO
-bool 'tar'	    CONFIG_TAR
-if [ "$CONFIG_TAR" = "y" ] ; then
-    bool '  Enable archive creation'	CONFIG_FEATURE_TAR_CREATE
-    bool '  Enable -j option to handle .tar.bz2 files'	CONFIG_FEATURE_TAR_BZIP2
-    bool '  Enable -X and --exclude options (exclude files)'	CONFIG_FEATURE_TAR_EXCLUDE
-    bool '  Enable -z option'	CONFIG_FEATURE_TAR_GZIP
-    bool '  Enable support for old tar header format'	CONFIG_FEATURE_TAR_OLD_FORMAT
-    bool '  Enable support for GNU long filenames' CONFIG_FEATURE_GNUTAR_LONG_FILENAME
-fi
-if [ "$CONFIG_CPIO" = "y" -o "$CONFIG_TAR" = "y" ] ; then
-    bool '  Enable tape drive support' CONFIG_FEATURE_UNARCHIVE_TAPE
-fi
-bool 'uncompress'   CONFIG_UNCOMPRESS
-bool 'unzip'	    CONFIG_UNZIP
-endmenu
diff --git a/console-tools/Config.in b/console-tools/Config.in
new file mode 100644
index 000000000..f10bf7578
--- /dev/null
+++ b/console-tools/Config.in
@@ -0,0 +1,68 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Console Utilities"
+
+config CONFIG_CHVT
+	bool "chvt"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_CLEAR
+	bool "clear"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_DEALLOCVT
+	bool "deallocvt"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_DUMPKMAP
+	bool "dumpkmap"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_LOADACM
+	bool "loadacm"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_LOADFONT
+	bool "loadfont"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_LOADKMAP
+	bool "loadkmap"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_OPENVT
+	bool "openvt"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_RESET
+	bool "reset"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_SETKEYCODES
+	bool "setkeycodes"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
diff --git a/console-tools/config.in b/console-tools/config.in
deleted file mode 100644
index 2ea96aec4..000000000
--- a/console-tools/config.in
+++ /dev/null
@@ -1,19 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Console Utilities'
-bool 'chvt'	    CONFIG_CHVT
-bool 'clear'	    CONFIG_CLEAR
-bool 'deallocvt'    CONFIG_DEALLOCVT
-bool 'dumpkmap'	    CONFIG_DUMPKMAP
-bool 'loadacm'	    CONFIG_LOADACM
-bool 'loadfont'	    CONFIG_LOADFONT
-bool 'loadkmap'	    CONFIG_LOADKMAP
-bool 'openvt'	    CONFIG_OPENVT
-bool 'reset'	    CONFIG_RESET
-bool 'setkeycodes'  CONFIG_SETKEYCODES
-
-endmenu
diff --git a/debianutils/Config.in b/debianutils/Config.in
new file mode 100644
index 000000000..9f6d840cf
--- /dev/null
+++ b/debianutils/Config.in
@@ -0,0 +1,33 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Debian Utilities"
+
+config CONFIG_MKTEMP
+	bool "mktemp"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_READLINK
+	bool "readlink"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_RUN_PARTS
+	bool "run-parts"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_WHICH
+	bool "which"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
+
diff --git a/debianutils/config.in b/debianutils/config.in
deleted file mode 100644
index 7b1d92991..000000000
--- a/debianutils/config.in
+++ /dev/null
@@ -1,15 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Debian Utilities'
-
-bool 'mktemp'	    CONFIG_MKTEMP
-bool 'readlink'	    CONFIG_READLINK
-bool 'run-parts'    CONFIG_RUN_PARTS
-bool 'which'	    CONFIG_WHICH
-
-endmenu
-
diff --git a/editors/Config.in b/editors/Config.in
new file mode 100644
index 000000000..4f2817598
--- /dev/null
+++ b/editors/Config.in
@@ -0,0 +1,104 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Editors"
+
+config CONFIG_AWK
+	bool "awk"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_AWK_MATH
+	bool "  Enable math functions (requires libm)"
+	default y
+	depends on CONFIG_AWK
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_SED
+	bool "sed"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_VI
+	bool "vi"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_VI_COLON
+	bool "  Enable \":\" colon commands (no \"ex\" mode)"
+	default y
+	depends on CONFIG_VI
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_VI_YANKMARK
+	bool "  Enable yank/put commands and mark cmds"
+	default y
+	depends on CONFIG_VI
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_VI_SEARCH
+	bool "  Enable search and replace cmds"
+	default y
+	depends on CONFIG_VI
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_VI_USE_SIGNALS
+	bool "  Catch signals"
+	default y
+	depends on CONFIG_VI
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_VI_DOT_CMD
+	bool "  Remember previous cmd and \".\" cmd"
+	default y
+	depends on CONFIG_VI
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_VI_READONLY
+	bool "  Enable -R option and \"view\" mode"
+	default y
+	depends on CONFIG_VI
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_VI_SETOPTS
+	bool "  Enable set-able options, ai ic showmatch"
+	default y
+	depends on CONFIG_VI
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_VI_SET
+	bool "  Support for :set"
+	default y
+	depends on CONFIG_VI
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_VI_WIN_RESIZE
+	bool "  Handle window resize"
+	default y
+	depends on CONFIG_VI
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_VI_OPTIMIZE_CURSOR
+	bool "  Optimize cursor movement"
+	default y
+	depends on CONFIG_VI
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
+
diff --git a/editors/config.in b/editors/config.in
deleted file mode 100644
index 54e1a90e9..000000000
--- a/editors/config.in
+++ /dev/null
@@ -1,28 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Editors'
-
-bool 'awk'	    CONFIG_AWK
-if [ "$CONFIG_AWK" = "y" ]; then
-    bool '  Enable math functions (requires libm)'      CONFIG_FEATURE_AWK_MATH
-fi
-bool 'sed'	    CONFIG_SED
-bool 'vi'	    CONFIG_VI
-if [ "$CONFIG_VI" = "y" ]; then
-    bool '  Enable ":" colon commands (no "ex" mode)'	CONFIG_FEATURE_VI_COLON
-    bool '  Enable yank/put commands and mark cmds'	CONFIG_FEATURE_VI_YANKMARK
-    bool '  Enable search and replace cmds'		CONFIG_FEATURE_VI_SEARCH
-    bool '  Catch signals'				CONFIG_FEATURE_VI_USE_SIGNALS
-    bool '  Remember previous cmd and "." cmd'		CONFIG_FEATURE_VI_DOT_CMD
-    bool '  Enable -R option and "view" mode'		CONFIG_FEATURE_VI_READONLY
-    bool '  Enable set-able options, ai ic showmatch'	CONFIG_FEATURE_VI_SETOPTS
-    bool '  Support for :set'				CONFIG_FEATURE_VI_SET
-    bool '  Handle window resize'			CONFIG_FEATURE_VI_WIN_RESIZE
-    bool '  Optimize cursor movement'			CONFIG_FEATURE_VI_OPTIMIZE_CURSOR
-fi
-endmenu
-
diff --git a/findutils/Config.in b/findutils/Config.in
new file mode 100644
index 000000000..42400ffb8
--- /dev/null
+++ b/findutils/Config.in
@@ -0,0 +1,70 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Finding Utilities"
+
+config CONFIG_FIND
+	bool "find"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_FIND_MTIME
+	bool "  Enable modified time matching (-mtime) option"
+	default y
+	depends on CONFIG_FIND
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_FIND_PERM
+	bool "  Enable permissions matching (-perm) option"
+	default y
+	depends on CONFIG_FIND
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_FIND_TYPE
+	bool "  Enable filetype matching (-type) option"
+	default y
+	depends on CONFIG_FIND
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_FIND_XDEV
+	bool "  Enable stay in filesystem (-xdev) option"
+	default y
+	depends on CONFIG_FIND
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_GREP
+	bool "grep"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_GREP_EGREP_ALIAS
+	bool "  Support extended regular expressions (egrep & grep -E)"
+	default y
+	depends on CONFIG_GREP
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_GREP_CONTEXT
+	bool "  Enable before and after context flags (-A, -B and -C)"
+	default y
+	depends on CONFIG_GREP
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_XARGS
+	bool "xargs"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+
+endmenu
+
diff --git a/findutils/config.in b/findutils/config.in
deleted file mode 100644
index 41a23c00a..000000000
--- a/findutils/config.in
+++ /dev/null
@@ -1,23 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Finding Utilities'
-
-bool 'find'	    CONFIG_FIND
-if [ "$CONFIG_FIND" = "y" ] ; then
-    bool '  Enable modified time matching (-mtime) option' CONFIG_FEATURE_FIND_MTIME
-    bool '  Enable permissions matching (-perm) option' CONFIG_FEATURE_FIND_PERM
-    bool '  Enable filetype matching (-type) option' CONFIG_FEATURE_FIND_TYPE
-    bool '  Enable stay in filesystem (-xdev) option' CONFIG_FEATURE_FIND_XDEV
-fi
-bool 'grep'	    CONFIG_GREP
-if [ "$CONFIG_GREP" = "y" ] ; then
-    bool '  Support extended regular expressions (egrep & grep -E)'		CONFIG_FEATURE_GREP_EGREP_ALIAS
-    bool '  Enable before and after context flags (-A, -B and -C)' 	CONFIG_FEATURE_GREP_CONTEXT
-fi
-bool 'xargs'	    CONFIG_XARGS
-endmenu
-
diff --git a/init/Config.in b/init/Config.in
new file mode 100644
index 000000000..90173c552
--- /dev/null
+++ b/init/Config.in
@@ -0,0 +1,78 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Init Utilities"
+
+config CONFIG_INIT
+	bool "init"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_USE_INITTAB
+	bool "  Support reading an inittab file?"
+	default y
+	depends on CONFIG_INIT
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_INITRD
+	bool "  Support running init from within an initrd?"
+	default y
+	depends on CONFIG_INIT
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_INIT_COREDUMPS
+	bool "  Support dumping core for child processes (debugging only)?"
+	default y
+	depends on CONFIG_INIT
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_EXTRA_QUIET
+	bool "  Should init be _extra_ quiet on boot?"
+	default y
+	depends on CONFIG_INIT
+	help
+	  Please submit a patch to add help text for this item.
+
+# Some apps that are meaningless without BusyBox running as init
+config CONFIG_HALT
+	bool "halt"
+	default y
+	depends on CONFIG_INIT
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_POWEROFF
+	bool "poweroff"
+	default y
+	depends on CONFIG_INIT
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_REBOOT
+	bool "reboot"
+	default y
+	depends on CONFIG_INIT
+	help
+	  Please submit a patch to add help text for this item.
+
+# Should start-stop-daemon be moved under debianutils?
+config CONFIG_START_STOP_DAEMON
+	bool "start-stop-daemon"
+	default y
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_MESG
+	bool "mesg"
+	default y
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
+
diff --git a/init/config.in b/init/config.in
deleted file mode 100644
index 3688eaa10..000000000
--- a/init/config.in
+++ /dev/null
@@ -1,27 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Init Utilities'
-
-
-bool 'init'	    CONFIG_INIT
-if [ "$CONFIG_INIT" = "y" ]; then
-    bool '  Support reading an inittab file?'				    CONFIG_FEATURE_USE_INITTAB
-    bool '  Support running init from within an initrd?'		    CONFIG_FEATURE_INITRD
-    bool '  Support dumping core for child processes (debugging only)?'	    CONFIG_FEATURE_INIT_COREDUMPS
-    bool '  Should init be _extra_ quiet on boot?'			    CONFIG_FEATURE_EXTRA_QUIET
-
-    # Some more apps that are meaningless without BusyBox running as init
-    bool 'halt'			    CONFIG_HALT
-    bool 'poweroff'		    CONFIG_POWEROFF
-    bool 'reboot'		    CONFIG_REBOOT
-fi
-
-bool 'start-stop-daemon'	    CONFIG_START_STOP_DAEMON
-bool 'mesg'			    CONFIG_MESG
-	
-endmenu
-
diff --git a/loginutils/Config.in b/loginutils/Config.in
new file mode 100644
index 000000000..15727d290
--- /dev/null
+++ b/loginutils/Config.in
@@ -0,0 +1,97 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Login/Password Management Utilities"
+
+config CONFIG_USE_BB_PWD_GRP
+	bool "Use internal password and group functions rather than system functions"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_ADDGROUP
+	bool "addgroup"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_DELGROUP
+	bool "delgroup"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_ADDUSER
+	bool "adduser"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_DELUSER
+	bool "deluser"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_GETTY
+	bool "getty"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_LOGIN
+	bool "login"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SECURETTY
+	bool "  Support for /etc/securetty"
+	default y
+	depends on CONFIG_LOGIN
+	help
+	  Please submit a patch to add help text for this item.
+
+
+config CONFIG_PASSWD
+	bool "passwd"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_SU
+	bool "su"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SHADOWPASSWDS
+	bool "Support for shadow passwords"
+	default y
+	depends on CONFIG_ADDUSER || CONFIG_DELUSER || CONFIG_LOGIN || CONFIG_SU
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_USE_BB_SHADOW
+	bool "  Use busybox shadow password functions"
+	default n
+	depends on CONFIG_USE_BB_PWD_GRP && CONFIG_FEATURE_SHADOWPASSWDS
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_SULOGIN
+	bool "sulogin"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_VLOCK
+	bool "vlock"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
+
diff --git a/loginutils/config.in b/loginutils/config.in
deleted file mode 100644
index 6280ff2a6..000000000
--- a/loginutils/config.in
+++ /dev/null
@@ -1,32 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Login/Password Management Utilities'
-
-
-bool 'Use internal password and group functions instead of the system functions'	CONFIG_USE_BB_PWD_GRP
-bool 'addgroup'			CONFIG_ADDGROUP
-bool 'delgroup'			CONFIG_DELGROUP
-bool 'adduser'			CONFIG_ADDUSER
-bool 'deluser'			CONFIG_DELUSER
-bool 'getty'			CONFIG_GETTY
-bool 'login'			CONFIG_LOGIN
-if [ "$CONFIG_LOGIN" = "y" ]; then
-	bool '  Support for /etc/securetty'		CONFIG_FEATURE_SECURETTY
-fi
-bool 'passwd'			CONFIG_PASSWD
-bool 'su'			CONFIG_SU
-if [ "$CONFIG_ADDUSER" = "y" -o "$CONFIG_DELUSER" = "y" -o "$CONFIG_LOGIN" = "y" -o "$CONFIG_SU" = "y" ]; then
-    bool '  Support for shadow passwords'		CONFIG_FEATURE_SHADOWPASSWDS
-    if [ "$CONFIG_USE_BB_PWD_GRP" = "y" -a  "$CONFIG_FEATURE_SHADOWPASSWDS" = "y" ]; then
-       bool '  Use busybox shadow password functions'			CONFIG_USE_BB_SHADOW
-    fi
-fi
-bool 'sulogin'			CONFIG_SULOGIN
-bool 'vlock'			CONFIG_VLOCK
-
-endmenu
-
diff --git a/miscutils/Config.in b/miscutils/Config.in
new file mode 100644
index 000000000..23de1dd16
--- /dev/null
+++ b/miscutils/Config.in
@@ -0,0 +1,75 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Miscellaneous Utilities"
+
+config CONFIG_ADJTIMEX
+	bool "adjtimex"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_CROND
+	bool "crond"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_CRONTAB
+	bool "crontab"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_DC
+	bool "dc"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_DUTMP
+	bool "dutmp"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_MAKEDEVS
+	bool "makedevs"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_MT
+	bool "mt"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_STRINGS
+	bool "strings"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_TIME
+	bool "time"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_UPDATE
+	bool "update"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_WATCHDOG
+	bool "watchdog"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
+
diff --git a/miscutils/config.in b/miscutils/config.in
deleted file mode 100644
index 063e02b36..000000000
--- a/miscutils/config.in
+++ /dev/null
@@ -1,22 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Miscellaneous Utilities'
-
-bool 'adjtimex'	    CONFIG_ADJTIMEX
-bool 'crond'        CONFIG_CROND
-bool 'crontab'      CONFIG_CRONTAB
-bool 'dc'	    CONFIG_DC
-bool 'dutmp'	    CONFIG_DUTMP
-bool 'makedevs'	    CONFIG_MAKEDEVS
-bool 'mt'	    CONFIG_MT
-bool 'strings'	    CONFIG_STRINGS
-bool 'time'	    CONFIG_TIME
-bool 'update'	    CONFIG_UPDATE
-bool 'watchdog'	    CONFIG_WATCHDOG
-
-endmenu
-
diff --git a/modutils/Config.in b/modutils/Config.in
new file mode 100644
index 000000000..9af0ad6dc
--- /dev/null
+++ b/modutils/Config.in
@@ -0,0 +1,84 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Module Utilities"
+
+config CONFIG_INSMOD
+	bool "insmod"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_OLD_MODULE_INTERFACE
+	bool "  Support older (pre 2.1) Linux kernels"
+	default n
+	depends on CONFIG_INSMOD
+	help
+	  Please submit a patch to add help text for this item.
+
+if CONFIG_INSMOD && !CONFIG_FEATURE_OLD_MODULE_INTERFACE
+    config CONFIG_FEATURE_NEW_MODULE_INTERFACE
+	    default y
+    comment "  Support new (post 2.1) Linux kernels (Forced enabled)"
+endif
+
+if CONFIG_FEATURE_OLD_MODULE_INTERFACE
+config CONFIG_FEATURE_NEW_MODULE_INTERFACE
+	bool "  Support new (post 2.1) Linux kernels"
+	default y
+	depends on CONFIG_INSMOD
+	help
+	  Please submit a patch to add help text for this item.
+endif
+
+config CONFIG_FEATURE_INSMOD_VERSION_CHECKING
+	bool "  Module version checking"
+	default n
+	depends on CONFIG_INSMOD
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_INSMOD_LOADINKMEM
+	bool "  In kernel memory optimization (uClinux only)"
+	default n
+	depends on CONFIG_INSMOD
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_LSMOD
+	bool "lsmod"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_QUERY_MODULE_INTERFACE
+	bool "  Support lsmod query_module interface (add 638 bytes)"
+	default y
+	depends on CONFIG_LSMOD && CONFIG_FEATURE_NEW_MODULE_INTERFACE
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_MODPROBE
+	bool "modprobe"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_RMMOD
+	bool "rmmod"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_CHECK_TAINTED_MODULE
+	bool "Support tainted module checking with new kernels"
+	default y
+	depends on CONFIG_INSMOD || CONFIG_LSMOD
+	help
+	  Please submit a patch to add help text for this item.
+
+
+endmenu
+
diff --git a/modutils/config.in b/modutils/config.in
deleted file mode 100644
index 10b0a9c33..000000000
--- a/modutils/config.in
+++ /dev/null
@@ -1,37 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Module Utilities'
-
-
-bool 'insmod'	    CONFIG_INSMOD
-bool 'lsmod'	    CONFIG_LSMOD
-bool 'modprobe'	    CONFIG_MODPROBE
-bool 'rmmod'	    CONFIG_RMMOD
-
-if [ "$CONFIG_INSMOD" = "y" ]; then
-    comment 'Module support options'
-    bool 'Support for older (pre 2.1) Linux kernels'		CONFIG_FEATURE_OLD_MODULE_INTERFACE
-    if [ "$CONFIG_FEATURE_OLD_MODULE_INTERFACE" = "n" ] ; then
-	    define_bool CONFIG_FEATURE_NEW_MODULE_INTERFACE	y
-    fi
-    bool 'Support for new (post 2.1) kernels'			CONFIG_FEATURE_NEW_MODULE_INTERFACE
-    bool 'Support module version checking'			CONFIG_FEATURE_INSMOD_VERSION_CHECKING
-    bool 'Support image in kernel memory optimization (uClinux only)'		CONFIG_FEATURE_INSMOD_LOADINKMEM
-fi
-
-if [ "$CONFIG_LSMOD" = "y" ]; then
-	if [ "$CONFIG_FEATURE_NEW_MODULE_INTERFACE" = "y" ]; then
-		bool 'Support lsmod query_module interface (add 638 bytes)'     CONFIG_FEATURE_QUERY_MODULE_INTERFACE
-	fi
-fi
-
-if [ "$CONFIG_INSMOD" = "y" -o "$CONFIG_LSMOD" = "y" ]; then
-	bool 'Support tainted module checking with new kernels'  CONFIG_FEATURE_CHECK_TAINTED_MODULE
-fi
-
-endmenu
-
diff --git a/networking/Config.in b/networking/Config.in
new file mode 100644
index 000000000..0ff3f52bc
--- /dev/null
+++ b/networking/Config.in
@@ -0,0 +1,332 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Networking Utilities"
+
+config CONFIG_FEATURE_IPV6
+	bool "Enable IPv6 support"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_HOSTNAME
+	bool "hostname"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_IFCONFIG
+	bool "ifconfig"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_IFCONFIG_STATUS
+	bool "  Enable status reporting output (+7k)"
+	default y
+	depends on CONFIG_IFCONFIG
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_IFCONFIG_SLIP
+	bool "  Enable slip-specific options \"keepalive\" and \"outfill\""
+	default n
+	depends on CONFIG_IFCONFIG
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
+	bool "  Enable options \"mem_start\", \"io_addr\", and \"irq\""
+	default n
+	depends on CONFIG_IFCONFIG
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_IFCONFIG_HW
+	bool "  Enable option \"hw\" (ether only)"
+	default y
+	depends on CONFIG_IFCONFIG
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS
+	bool "  Set the broadcast automatically"
+	default n
+	depends on CONFIG_IFCONFIG
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_IFUPDOWN
+	bool "ifupdown"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_IFUPDOWN_IPV4
+	bool "  Enable support for IPv4"
+	default y
+	depends on CONFIG_IFUPDOWN
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_IFUPDOWN_IPV6
+	bool "  Enable support for IPv6 (requires ip command)"
+	default n
+	depends on CONFIG_IFUPDOWN
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_IFUPDOWN_IPX
+	bool "  Enable support for IPX (requires ipx_interface command)"
+	default n
+	depends on CONFIG_IFUPDOWN
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_IP
+	bool "ip"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+if CONFIG_IP && CONFIG_IPADDR
+	config CONFIG_FEATURE_IP_ADDRESS
+		default y
+	comment "  address (forced enabled for ipaddr)"
+endif
+if ! (CONFIG_IP && CONFIG_IPADDR)
+	config CONFIG_FEATURE_IP_ADDRESS
+		bool "  address"
+		default n
+		depends on CONFIG_IP
+		help
+		  Please submit a patch to add help text for this item.
+endif
+
+if CONFIG_IP && CONFIG_IPLINK
+	config CONFIG_FEATURE_IP_LINK
+		default y
+	comment "  link (forced enabled for iplink)"
+endif
+if !(CONFIG_IP && CONFIG_IPLINK)
+	config CONFIG_FEATURE_IP_LINK
+		bool "  link"
+		default y
+		depends on CONFIG_IP
+		help
+		  Please submit a patch to add help text for this item.
+endif
+
+if CONFIG_IP && CONFIG_IPROUTE
+	config CONFIG_FEATURE_IP_ROUTE
+		default y
+	comment "  route (forced enabled for iproute)"
+endif
+if !(CONFIG_IP && CONFIG_IPROUTE)
+	config CONFIG_FEATURE_IP_ROUTE
+		bool "  route"
+		default y
+		depends on CONFIG_IP
+		help
+		  Please submit a patch to add help text for this item.
+endif
+
+if CONFIG_IP && CONFIG_IPTUNNEL
+	config CONFIG_FEATURE_IP_TUNNEL
+		default y
+	comment "  tunnel (forced enabled for iptunnel)"
+endif
+if !(CONFIG_IP && CONFIG_IPTUNNEL)
+	config CONFIG_FEATURE_IP_TUNNEL
+		bool "  tunnel"
+		default y
+		depends on CONFIG_IP
+		help
+		  Please submit a patch to add help text for this item.
+endif
+
+config CONFIG_IPCALC
+	bool "ipcalc"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_IPCALC_FANCY
+	bool "  Fancy IPCALC, more options, adds 300 bytes"
+	default y
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_IPADDR
+	bool "ipaddr"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_IPLINK
+	bool "iplink"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_IPROUTE
+	bool "iproute"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_IPTUNNEL
+	bool "iptunnel"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_NC
+	bool "nc"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_NETSTAT
+	bool "netstat"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_NSLOOKUP
+	bool "nslookup"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_PING
+	bool "ping"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_FANCY_PING
+	bool "  Enable fancy ping output"
+	default y
+	depends on CONFIG_PING
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_PING6
+	bool "ping6"
+	default n
+	depends on CONFIG_FEATURE_IPV6
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_FANCY_PING6
+	bool "  Enable fancy ping6 output"
+	default y
+	depends on CONFIG_PING6
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_ROUTE
+	bool "route"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_TELNET
+	bool "telnet"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TELNET_TTYPE
+	bool "  Pass TERM type to remote host"
+	default y
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_TELNETD
+	bool "telnetd"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_TFTP
+	bool "tftp"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TFTP_GET
+	bool "  Enable \"get\" command"
+	default y
+	depends on CONFIG_TFTP
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TFTP_PUT
+	bool "  Enable \"put\" command"
+	default y
+	depends on CONFIG_TFTP
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TFTP_BLOCKSIZE
+	bool "  Enable \"blocksize\" command"
+	default n
+	depends on CONFIG_TFTP
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TFTP_DEBUG
+	bool "  Enable debug"
+	default y
+	depends on CONFIG_TFTP
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_TRACEROUTE
+	bool "traceroute"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TRACEROUTE_VERBOSE
+	bool "  Enable verbose output"
+	default y
+	depends on CONFIG_TRACEROUTE
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_TRACEROUTE_SO_DEBUG
+	bool "  Enable SO_DEBUG option"
+	default y
+	depends on CONFIG_TRACEROUTE
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_WGET
+	bool "wget"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_WGET_STATUSBAR
+	bool "  Enable a nifty process meter (+2k)"
+	default y
+	depends on CONFIG_WGET
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_WGET_AUTHENTICATION
+	bool "  Enable HTTP authentication"
+	default y
+	depends on CONFIG_WGET
+	help
+	  Please submit a patch to add help text for this item.
+
+source networking/udhcp/Config.in
+
+endmenu
+
diff --git a/networking/config.in b/networking/config.in
deleted file mode 100644
index de5b92064..000000000
--- a/networking/config.in
+++ /dev/null
@@ -1,92 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Networking Utilities'
-
-bool 'Enable IPv6 support'						CONFIG_FEATURE_IPV6
-bool 'hostname'	    CONFIG_HOSTNAME
-bool 'ifconfig'	    CONFIG_IFCONFIG
-if [ "$CONFIG_IFCONFIG" = "y" ]; then
-    bool '  Enable status reporting output (+7k)'					CONFIG_FEATURE_IFCONFIG_STATUS  
-    bool '  Enable slip-specific options "keepalive" and "outfill"'	CONFIG_FEATURE_IFCONFIG_SLIP
-    bool '  Enable options "mem_start", "io_addr", and "irq"'		CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
-    bool '  Enable option "hw" (ether only)'						CONFIG_FEATURE_IFCONFIG_HW 
-    bool '  Set the broadcast automatically'					CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS
-fi
-bool 'ifupdown'	    CONFIG_IFUPDOWN
-if [ "$CONFIG_IFUPDOWN" = "y" ]; then
-    bool '  Enable support for IPv4'	CONFIG_FEATURE_IFUPDOWN_IPV4
-    bool '  Enable support for IPv6 (requires ip command)' CONFIG_FEATURE_IFUPDOWN_IPV6
-    bool '  Enable support for IPX (requires ipx_interface command)' CONFIG_FEATURE_IFUPDOWN_IPX
-fi
-bool 'ip'	    CONFIG_IP
-if [ "$CONFIG_IP" = "y" ]; then
-    bool '  address'		CONFIG_FEATURE_IP_ADDRESS
-    bool '  link'		CONFIG_FEATURE_IP_LINK
-    bool '  route'		CONFIG_FEATURE_IP_ROUTE
-    bool '  tunnel'		CONFIG_FEATURE_IP_TUNNEL
-fi
-bool 'ipcalc'	    CONFIG_IPCALC
-if [ "$CONFIG_IPCALC" = "y" ]; then
-    bool '  Fancy IPCALC, more options, adds 300 bytes'	CONFIG_FEATURE_IPCALC_FANCY
-fi
-bool 'ipaddr'		CONFIG_IPADDR
-if [ "$CONFIG_IP" = "y" ] && [ "$CONFIG_IPADDR" = "y" ]; then
-	define_bool	CONFIG_FEATURE_IP_ADDRESS	y
-fi
-bool 'iplink'		CONFIG_IPLINK
-if [ "$CONFIG_IP" = "y" ] && [ "$CONFIG_IPLINK" = "y" ]; then
-	define_bool	CONFIG_FEATURE_IP_LINK	y
-fi
-bool 'iproute'		CONFIG_IPROUTE
-if [ "$CONFIG_IP" = "y" ] && [ "$CONFIG_IPROUTE" = "y" ]; then
-	define_bool	CONFIG_FEATURE_IP_ROUTE	y
-fi
-bool 'iptunnel'		CONFIG_IPTUNNEL
-if [ "$CONFIG_IP" = "y" ] && [ "$CONFIG_IPTUNNEL" = "y" ]; then
-	define_bool	CONFIG_FEATURE_IP_TUNNEL	y
-fi
-bool 'nc'			CONFIG_NC
-bool 'netstat'	    CONFIG_NETSTAT
-bool 'nslookup'	    CONFIG_NSLOOKUP
-bool 'ping'			CONFIG_PING
-if [ "$CONFIG_PING" = "y" ]; then
-    bool '  Enable fancy ping output'		CONFIG_FEATURE_FANCY_PING
-fi
-if [ "$CONFIG_FEATURE_IPV6" = "y" ]; then
-    bool 'ping6'	    CONFIG_PING6
-    if [ "$CONFIG_PING6" = "y" ]; then
-        bool '  Enable fancy ping6 output'		CONFIG_FEATURE_FANCY_PING6
-    fi
-fi
-bool 'route'	    CONFIG_ROUTE
-bool 'telnet'	    CONFIG_TELNET
-if [ "$CONFIG_TELNET" = "y" ]; then
-    bool '  Pass TERM type to remote host'		CONFIG_FEATURE_TELNET_TTYPE
-fi
-bool 'telnetd'      CONFIG_TELNETD
-bool 'tftp'	    CONFIG_TFTP
-if [ "$CONFIG_TFTP" = "y" ]; then
-    bool '  Enable "get" command'			CONFIG_FEATURE_TFTP_GET
-    bool '  Enable "put" command'			CONFIG_FEATURE_TFTP_PUT
-    bool '  Enable "blocksize" option'		CONFIG_FEATURE_TFTP_BLOCKSIZE
-    bool '  Enable debug'					CONFIG_FEATURE_TFTP_DEBUG
-fi
-bool 'traceroute'   CONFIG_TRACEROUTE
-if [ "$CONFIG_TRACEROUTE" = "y" ]; then
-    bool '  Enable verbose output'			CONFIG_FEATURE_TRACEROUTE_VERBOSE
-    bool '  Enable SO_DEBUG option'	CONFIG_FEATURE_TRACEROUTE_SO_DEBUG
-fi
-bool 'wget'	    CONFIG_WGET
-if [ "$CONFIG_WGET" = "y" ]; then
-    bool '  Enable a nifty process meter (+2k)'	CONFIG_FEATURE_WGET_STATUSBAR
-	bool '  Enable HTTP authentication'			CONFIG_FEATURE_WGET_AUTHENTICATION
-fi
-
-source networking/udhcp/config.in
-
-endmenu
-
diff --git a/networking/udhcp/Config.in b/networking/udhcp/Config.in
new file mode 100644
index 000000000..5baaa6a49
--- /dev/null
+++ b/networking/udhcp/Config.in
@@ -0,0 +1,42 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "udhcp Server/Client"
+
+config CONFIG_UDHCPD
+	bool "udhcp Server (udhcpd)"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_UDHCPC
+	bool "udhcp Client (udhcpc)"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_DUMPLEASES
+	bool "Lease display utility (dumpleases)"
+	default n
+	depends on CONFIG_UDHCPD
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_UDHCP_SYSLOG
+	bool "  Log udhcp messages to syslog (instead of stdout)"
+	default n
+	depends on CONFIG_UDHCPD || CONFIG_UDHCPC
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_UDHCP_DEBUG
+	bool "  Compile udhcp with noisy debugging messages"
+	default n
+	depends on CONFIG_UDHCPD || CONFIG_UDHCPC
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
+
diff --git a/networking/udhcp/Makefile.in b/networking/udhcp/Makefile.in
index d76715baa..0b94d9c8f 100644
--- a/networking/udhcp/Makefile.in
+++ b/networking/udhcp/Makefile.in
@@ -44,3 +44,9 @@ libraries-y+=$(UDHCP_DIR)$(UDHCP_AR)
 $(UDHCP_DIR)$(UDHCP_AR): $(patsubst %,$(UDHCP_DIR)%, $(UDHCP-y))
 	$(AR) -ro $@ $(patsubst %,$(UDHCP_DIR)%, $(UDHCP-y))
 
+$(UDHCP_DIR)dhcpc.o: $(UDHCP_DIR)dhcpc.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -DCOMBINED_BINARY -c $< -o $@
+
+$(UDHCP_DIR)dhcpd.o: $(UDHCP_DIR)dhcpd.c
+	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -DCOMBINED_BINARY -c $< -o $@
+
diff --git a/networking/udhcp/config.in b/networking/udhcp/config.in
deleted file mode 100644
index ede632a8a..000000000
--- a/networking/udhcp/config.in
+++ /dev/null
@@ -1,18 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'udhcp Server/Client'
-
-bool 'udhcp Server (udhcpd)'			CONFIG_UDHCPD
-bool 'udhcp Client (udhcpc)'			CONFIG_UDHCPC
-bool 'Lease display utility (dumpleases)'	CONFIG_DUMPLEASES
-if [ "$CONFIG_UDHCPD" = "y" -o "$CONFIG_UDHCPC" = "y" ]; then
-    bool '  Log udhcp messages to syslog (instead of stdout)' CONFIG_FEATURE_UDHCP_SYSLOG
-    bool '  Compile udhcp with noisy debugging messages' CONFIG_FEATURE_UDHCP_DEBUG  
-fi
-
-endmenu
-
diff --git a/procps/Config.in b/procps/Config.in
new file mode 100644
index 000000000..dc8c2f22e
--- /dev/null
+++ b/procps/Config.in
@@ -0,0 +1,72 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Process Utilities"
+
+config CONFIG_FREE
+	bool "free"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+if CONFIG_KILLALL
+	config CONFIG_KILL
+		default y
+	comment "kill (forced enabled for killall)"
+endif
+if !CONFIG_KILLALL
+	config CONFIG_KILL
+		bool "kill"
+		default n
+		help
+		  Please submit a patch to add help text for this item.
+endif
+
+config CONFIG_KILLALL
+	bool "killall"
+	default n
+	depends on CONFIG_KILL
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_PIDOF
+	bool "pidof"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_PS
+	bool "ps"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_RENICE
+	bool "renice"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_TOP
+	bool "top"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config FEATURE_CPU_USAGE_PERCENTAGE
+	bool "  Support show CPU usage percentage (add 2k bytes)"
+	default y
+	depends on CONFIG_TOP
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_UPTIME
+	bool "uptime"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
+
diff --git a/procps/config.in b/procps/config.in
deleted file mode 100644
index 966b11524..000000000
--- a/procps/config.in
+++ /dev/null
@@ -1,27 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Process Utilities'
-
-bool 'free'	    CONFIG_FREE
-bool 'kill'	    CONFIG_KILL
-bool 'killall'      CONFIG_KILLALL
-if [ "$CONFIG_KILLALL" = "y" -a "$CONFIG_KILL" = "n" ] ; then
-    define_bool CONFIG_KILL	y
-fi
-bool 'pidof'	    CONFIG_PIDOF
-bool 'ps'	    CONFIG_PS
-if [ "$CONFIG_PS" = "y" ] ; then
-    bool '  Use devps instead of /proc (needs a patched kernel)'	CONFIG_FEATURE_USE_DEVPS_PATCH
-fi
-bool 'renice'	    CONFIG_RENICE
-bool 'top'	    CONFIG_TOP
-if [ "$CONFIG_TOP" = "y" ] ; then
-    bool '  Support show CPU usage percentage (add 2k bytes)'        FEATURE_CPU_USAGE_PERCENTAGE
-fi
-bool 'uptime'	    CONFIG_UPTIME
-endmenu
-
diff --git a/scripts/Configure b/scripts/Configure
deleted file mode 100644
index 0a73a6493..000000000
--- a/scripts/Configure
+++ /dev/null
@@ -1,705 +0,0 @@
-#! /bin/sh
-#
-# This script is used to configure BusyBox.
-#
-# It was inspired by the challenge in the original Configure script
-# to ``do something better'', combined with the actual need to ``do
-# something better'' because the old configure script wasn't flexible
-# enough.
-#
-# Raymond Chen was the original author of Configure.
-# Michael Elizabeth Chastain (mec@shout.net) is the current maintainer.
-#
-# 050793 - use IFS='@' to get around a bug in a pre-version of bash-1.13
-# with an empty IFS.
-#
-# 030995 (storner@osiris.ping.dk) - added support for tri-state answers,
-# for selecting modules to compile.
-#
-# 180995 Bernhard Kaindl (bkaindl@ping.at) - added dummy functions for
-# use with a config.in modified for make menuconfig.
-#
-# 301195 (boldt@math.ucsb.edu) - added help text support
-#
-# 281295 Paul Gortmaker - make tri_state functions collapse to boolean
-# if module support is not enabled.
-#
-# 010296 Aaron Ucko (ucko@vax1.rockhurst.edu) - fix int and hex to accept
-# arbitrary ranges
-#
-# 150296 Dick Streefland (dicks@tasking.nl) - report new configuration
-# items and ask for a value even when doing a "make oldconfig"
-#
-# 200396 Tom Dyas (tdyas@eden.rutgers.edu) - when the module option is
-# chosen for an item, define the macro <option_name>_MODULE
-#
-# 090397 Axel Boldt (boldt@math.ucsb.edu) - avoid ? and + in regular 
-# expressions for GNU expr since version 1.15 and up use \? and \+.
-#
-# 300397 Phil Blundell (pjb27@cam.ac.uk) - added support for min/max 
-# arguments to "int", allow dep_tristate to take a list of dependencies
-# rather than just one.
-#
-# 090398 Axel Boldt (boldt@math.ucsb.edu) - allow for empty lines in help
-# texts.
-#
-# 102598 Michael Chastain (mec@shout.net) - put temporary files in
-# current directory, not in /tmp.
-#
-# 24 January 1999, Michael Elizabeth Chastain, <mec@shout.net>
-# - Improve the exit message (Jeff Ronne).
-#
-# 7 October 2000, Ghozlane Toumi, <gtoumi@messel.emse.fr>
-# added switches for "random" , "all yes" and "all modules"
-#
-
-#
-# Make sure we're really running bash.
-#
-# I would really have preferred to write this script in a language with
-# better string handling, but alas, bash is the only scripting language
-# that I can be reasonable sure everybody has on their linux machine.
-#
-[ -z "$BASH" ] && { echo "Configure requires bash" 1>&2; exit 1; }
-
-# Disable filename globbing once and for all.
-# Enable function cacheing.
-set -f -h
-
-#
-# Dummy functions for use with a config.in modified for menuconf
-#
-function mainmenu_option () {
-	:
-}
-function mainmenu_name () {
-	:
-}
-function endmenu () {
-	:
-}
-
-#
-# returns a random number between 1 and $1
-#
-function rnd () {
-	rnd=$[ $RANDOM  %  $1 + 1 ]
-}
-
-#
-# randomly chose a number in a config list (LIST_CONFIG_NAME)
-# or in a range ( MIN_CONFIG_NAME MAX_CONFIG_NAME )
-# ONLY if there is no forced default (and we are in an "auto" mode)
-# we are limited by the range of values taken by  "$RANDOM"
-#
-#       rndval CONFIG_NAME
-#
-
-function rndval () {
-	[ "$AUTO" != "yes" -o -n "$old" ] && return
-	def_list=$(eval echo "\${LIST_$1}")
-	def_min=$(eval echo "\${MIN_$1}")
-	def_max=$(eval echo "\${MAX_$1}")
-
-	if [ -n "$def_list" ]; then
-	  set -- $(echo $def_list | sed 's/,/ /g')
-	  rnd $#
-	  while [ $rnd -le $# ] ; do
-	    def=$1
-	    shift
-	  done
-	  return
-	fi
-	if [ -n "$def_min" -a -n "$def_max" ]; then
-	  rnd $[ $def_max - $def_min ]
-	  def=$[ $def_min + $rnd ]
-	fi
-}
-
-#
-# help prints the corresponding help text from Configure.help to stdout
-#
-#       help variable
-#
-function help () {
-  if [ -f docs/Configure.help ]
-  then
-     #first escape regexp special characters in the argument:
-     var=$(echo "$1"|sed 's/[][\/.^$*]/\\&/g')
-     #now pick out the right help text:
-     text=$(sed -n "/^$var[ 	]*\$/,\${
-			/^$var[ 	]*\$/c\\
-${var}:\\
-
-			/^#/b
-			/^[^ 	]/q
-			/<file:\\([^>]*\\)>/s//\\1/g
-			p
-		    }" docs/Configure.help)
-     if [ -z "$text" ]
-     then
-	  echo; echo "  Sorry, no help available for this option yet.";echo
-     else
-	  (echo; echo "$text") | ${PAGER:-more}
-     fi
-  else
-     echo;
-     echo "  Can't access the file docs/Configure.help which"
-     echo "  should contain the help texts."
-     echo
-  fi
-}
-
-
-#
-# readln reads a line into $ans.
-#
-#	readln prompt default oldval
-#
-function readln () {
-	if [ "$AUTO" = "yes" ]; then 
-		echo -n "$1"
-		ans=$2
-		echo $ans
-	elif [ "$DEFAULT" = "-d" -a -n "$3" ]; then
-		echo "$1"
-		ans=$2
-	else
-		echo -n "$1"
-		[ -z "$3" ] && echo -n "(NEW) "
-		IFS='@' read ans || exit 1
-		[ -z "$ans" ] && ans=$2
-	fi
-}
-
-#
-# comment does some pretty-printing
-#
-#	comment 'xxx'
-# 
-function comment () {
-	echo "*"; echo "* $1" ; echo "*"
-	(echo "" ; echo "#"; echo "# $1" ; echo "#") >>$CONFIG
-	(echo "" ; echo "/*"; echo " * $1" ; echo " */") >>$CONFIG_H
-}
-
-#
-# define_bool sets the value of a boolean argument
-#
-#	define_bool define value
-#
-function define_bool () {
-	define_tristate $1 $2
-}
-
-function define_tristate () {
-	case "$2" in
-	 "y")
-		echo "$1=y" >>$CONFIG
-		echo "#define $1 1" >>$CONFIG_H
-		;;
-
-	 "m")
-		echo "$1=m" >>$CONFIG
-		echo "#undef  $1" >>$CONFIG_H
-		echo "#define $1_MODULE 1" >>$CONFIG_H
-		;;
-
-	 "n")
-		echo "# $1 is not set" >>$CONFIG
-		echo "#undef  $1" >>$CONFIG_H
-		;;
-	esac
-	eval "$1=$2"
-}
-
-#
-# bool processes a boolean argument
-#
-#	bool question define
-#
-function bool () {
-	old=$(eval echo "\${$2}")
-	def=${old:-'n'}
-	if [ "$AUTO" = "yes" -a -z "$old" ]; then
-	  if [ "$RND" = "-r" ]; then
-	    rnd 2
-	    case $rnd in
-	      "1") def="y" ;;
-	      "2") def="n" ;;
-	    esac
-	  else
-	    def=$DEF_ANS;
-	  fi
-	fi
-	case "$def" in
-	 "y" | "m") defprompt="Y/n/?"
-	      def="y"
-	      ;;
-	 "n") defprompt="N/y/?"
-	      ;;
-	esac
-	while :; do
-	  readln "$1 ($2) [$defprompt] " "$def" "$old"
-	  case "$ans" in
-	    [yY] | [yY]es ) define_bool "$2" "y"
-			    break;;
-	    [nN] | [nN]o )  define_bool "$2" "n"
-			    break;;
-	    * )             help "$2"
-			    ;;
-	  esac
-	done
-}
-
-#
-# tristate processes a tristate argument
-#
-#	tristate question define
-#
-function tristate () {
-	if [ "$CONFIG_MODULES" != "y" ]; then
-	  bool "$1" "$2"
-	else 
-	  old=$(eval echo "\${$2}")
-	  def=${old:-'n'}
-	  if [ "$AUTO" = "yes" -a -z "$old" ]; then
-	     if [ "$RND" = "-r" ]; then 
-	      rnd 3
-	      case $rnd in
-	        "1") def="y" ;;
-	        "2") def="n" ;;
-	        "3") def="m" ;;
-	      esac
-	    else
-	      def=$DEF_ANS
-	    fi
-	  fi
-	  case "$def" in
-	   "y") defprompt="Y/m/n/?"
-		;;
-	   "m") defprompt="M/n/y/?"
-		;;
-	   "n") defprompt="N/y/m/?"
-		;;
-	  esac
-	  while :; do
-	    readln "$1 ($2) [$defprompt] " "$def" "$old"
-	    case "$ans" in
-	      [yY] | [yY]es ) define_tristate "$2" "y"
-			      break ;;
-	      [nN] | [nN]o )  define_tristate "$2" "n"
-			      break ;;
-	      [mM] )          define_tristate "$2" "m"
-			      break ;;
-	      * )             help "$2"
-			      ;;
-	    esac
-	  done
-	fi
-}
-
-#
-# dep_tristate processes a tristate argument that depends upon
-# another option or options.  If any of the options we depend upon is a
-# module, then the only allowable options are M or N.  If all are Y, then
-# this is a normal tristate.  This is used in cases where modules
-# are nested, and one module requires the presence of something
-# else in the kernel.
-#
-#	dep_tristate question define default ...
-#
-function dep_tristate () {
-	old=$(eval echo "\${$2}")
-	def=${old:-'n'}
-	ques=$1
-	var=$2
-	need_module=0
-	shift 2
-	while [ $# -gt 0 ]; do
-	  case "$1" in
- 	    n)
-	      define_tristate "$var" "n"
-	      return
-	      ;;
-	    m)
-	      need_module=1
-	      ;;
-	  esac
-	  shift
-	done
-
-	if [ $need_module = 1 ]; then
-	   if [ "$CONFIG_MODULES" = "y" ]; then
-		if [ "$AUTO" = "yes" -a -z "$old" ]; then
-		   if [ "$RND" = "-r" ]; then
-		      rnd 2
-		      case $rnd in
-			"1") def="m" ;;
-			"2") def="n" ;;
-		      esac
-		   else
-		      def=$DEF_ANS
-		   fi
-		fi
-		case "$def" in
-		 "y" | "m") defprompt="M/n/?"
-		      def="m"
-		      ;;
-		 "n") defprompt="N/m/?"
-		      ;;
-		esac
-		while :; do
-		  readln "$ques ($var) [$defprompt] " "$def" "$old"
-		  case "$ans" in
-		      [nN] | [nN]o )  define_tristate "$var" "n"
-				      break ;;
-		      [mM] )          define_tristate "$var" "m"
-				      break ;;
-		      [yY] | [yY]es ) echo 
-   echo "  This answer is not allowed, because it is not consistent with"
-   echo "  your other choices."
-   echo "  This driver depends on another one which you chose to compile"
-   echo "  as a module. This means that you can either compile this one"
-   echo "  as a module as well (with M) or leave it out altogether (N)."
-				      echo
-				      ;;
-		      * )             help "$var"
-				      ;;
-		  esac
-		done
-	   fi
-	else
-	   tristate "$ques" "$var"
-	fi
-}
-
-function dep_bool () {
-	ques=$1
-	var=$2
-	shift 2
-	while [ $# -gt 0 ]; do
-	  case "$1" in
-	    m | n)
-	      define_bool "$var" "n"
-	      return
-	      ;;
-	  esac
-	  shift
-	done
-
-	bool "$ques" "$var"
-}
-
-function dep_mbool () {
-	ques=$1
-	var=$2
-	shift 2
-	while [ $# -gt 0 ]; do
-	  case "$1" in
-	    n)
-	      define_bool "$var" "n"
-	      return
-	      ;;
-	  esac
-	  shift
-	done
-
-	bool "$ques" "$var"
-}
-
-#
-# define_int sets the value of a integer argument
-#
-#	define_int define value
-#
-function define_int () {
-	echo "$1=$2" >>$CONFIG
-	echo "#define $1 ($2)" >>$CONFIG_H
-	eval "$1=$2"
-}
-
-#
-# int processes an integer argument with optional limits
-#
-#	int question define default [min max]
-#
-function int () {
-	old=$(eval echo "\${$2}")
-	def=${old:-$3}
-	if [ $# -gt 3 ]; then
-	  min=$4
-	else
-	  min=-10000000    # !!
-	fi
-	if [ $# -gt 4 ]; then
-	  max=$5
-	else
-	  max=10000000     # !!
-	fi
-	rndval $2
-	while :; do
-	  readln "$1 ($2) [$def] " "$def" "$old"
-	  if expr \( \( $ans + 0 \) \>= $min \) \& \( $ans \<= $max \) >/dev/null 2>&1 ; then
-            define_int "$2" "$ans"
-	    break
-          else
-	    help "$2"
-          fi
-	done
-}
-
-#
-# define_hex sets the value of a hexadecimal argument
-#
-#	define_hex define value
-#
-function define_hex () {
-	echo "$1=$2" >>$CONFIG
-	echo "#define $1 0x${2#*[x,X]}" >>$CONFIG_H
-	eval "$1=$2"
-}
-
-#
-# hex processes an hexadecimal argument
-#
-#	hex question define default
-#
-function hex () {
-	old=$(eval echo "\${$2}")
-	def=${old:-$3}
-	def=${def#*[x,X]}
-	rndval $2
-	while :; do
-	  readln "$1 ($2) [$def] " "$def" "$old"
-	  ans=${ans#*[x,X]}
-	  if expr "$ans" : '[0-9a-fA-F][0-9a-fA-F]*$' > /dev/null; then
-	    define_hex "$2" "$ans"
-	    break
-	  else
-	    help "$2"
-	  fi
-	done
-}
-
-#
-# define_string sets the value of a string argument
-#
-#	define_string define value
-#
-function define_string () {
-	echo "$1=\"$2\"" >>$CONFIG
-	echo "#define $1 \"$2\"" >>$CONFIG_H
-	eval "$1=\"$2\""
-}
-
-#
-# string processes a string argument
-#
-#	string question define default
-#
-function string () {
-	old=$(eval echo "\${$2}")
-	def=${old:-$3}
-	while :; do
-          if [ "$old" = "?" ]; then
-             readln "$1 ($2) [$def] " "$def" ""
-          else
-	     readln "$1 ($2) [$def] " "$def" "$old"
-          fi
-	  if [ "$ans" = "?" ]; then
-	    help "$2"
-	  else
-	    break
-	  fi
-	done
-	define_string "$2" "$ans"
-}
-#
-# choice processes a choice list (1-out-of-n)
-#
-#	choice question choice-list default
-#
-# The choice list has a syntax of:
-#	NAME WHITESPACE VALUE { WHITESPACE NAME WHITESPACE VALUE }
-# The user may enter any unique prefix of one of the NAMEs and
-# choice will define VALUE as if it were a boolean option.
-# VALUE must be in all uppercase.  Normally, VALUE is of the
-# form CONFIG_<something>.  Thus, if the user selects <something>,
-# the CPP symbol CONFIG_<something> will be defined and the
-# shell variable CONFIG_<something> will be set to "y".
-#
-function choice () {
-	question="$1"
-	choices="$2"
-	old=
-	def=$3
-
-	# determine default answer:
-	names=""
-	set -- $choices
-	firstvar=$2
-	while [ -n "$2" ]; do
-		if [ -n "$names" ]; then
-			names="$names, $1"
-		else
-			names="$1"
-		fi
-		if [ "$(eval echo \"\${$2}\")" = "y" ]; then
-			old=$1
-			def=$1
-		fi
-		shift; shift
-	done
-
-	if [ "$RND" = "-r" -a -z "$old" ] ; then 
-	  set -- $choices
-	  rnd $#
-	  while [ $rnd -le $# ] ; do 
-	    def=$1
-	    shift ; shift
-	  done
-	fi
-
-	val=""
-	while [ -z "$val" ]; do
-		ambg=n
-		readln "$question ($names) [$def] " "$def" "$old"
-		ans=$(echo $ans | tr a-z A-Z)
-		set -- $choices
-		while [ -n "$1" ]; do
-			name=$(echo $1 | tr a-z A-Z)
-			case "$name" in
-				"$ans"* | */"$ans"* )
-					case "$name" in
-						"$ans" | */"$ans"/* | \
-						"$ans"/* | */"$ans" )
-							val="$2"
-							break # exact match
-						;;
-					esac
-					if [ -n "$val" ]; then
-						echo;echo \
-		"  Sorry, \"$ans\" is ambiguous; please enter a longer string."
-						echo
-						val=""
-						ambg=y
-						break
-					else
-						val="$2"
-					fi;;
-			esac
-			shift; shift
-		done
-		if [ "$val" = "" -a "$ambg" = "n" ]; then
-			help "$firstvar"
-		fi
-	done
-	set -- $choices
-	while [ -n "$2" ]; do
-		if [ "$2" = "$val" ]; then
-			echo "  defined $val"
-			define_bool "$2" "y"
-		else
-			define_bool "$2" "n"
-		fi
-		shift; shift
-	done
-}
-
-CONFIG=.tmpconfig
-CONFIG_H=.tmpconfig.h
-FORCE_DEFAULT=.force_default
-trap "rm -f $CONFIG $CONFIG_H ; exit 1" 1 2
-
-#
-# Make sure we start out with a clean slate.
-#
-echo "#" > $CONFIG
-echo "# Automatically generated make config: don't edit" >> $CONFIG
-echo "#" >> $CONFIG
-
-echo "/*" > $CONFIG_H
-echo " * Automatically generated C config: don't edit" >> $CONFIG_H
-echo " */" >> $CONFIG_H
-echo "#define AUTOCONF_INCLUDED" >> $CONFIG_H
-
-DEFAULT=""
-if [ "$1" = "-d" ] ; then
-	DEFAULT="-d"
-	shift
-fi
-
-RND=""
-DEF_ANS=""
-AUTO=""
-case "$1" in 
-	-r) RND="-r" ; AUTO="yes" ; shift ;;
-	-y) DEF_ANS="y" ; AUTO="yes" ; shift ;;
-	-m) DEF_ANS="m" ; AUTO="yes" ; shift ;;
-	-n) DEF_ANS="n" ; AUTO="yes" ; shift ;;
-esac
-
-CONFIG_IN=./config.in
-if [ "$1" != "" ] ; then
-	CONFIG_IN=$1
-fi
-
-DEFAULTS=sysdeps/$TARGET_OS/defconfig
-if [ -f .config ]; then
-  DEFAULTS=.config
-fi
-
-if [ "$AUTO" != "yes" ]; then
-  if [ -f $DEFAULTS ]; then
-    echo "#"
-    echo "# Using defaults found in" $DEFAULTS
-    echo "#"
-    . $DEFAULTS
-    sed -e 's/# \(CONFIG_[^ ]*\) is not.*/\1=n/' <$DEFAULTS >.config-is-not.$$
-    . .config-is-not.$$
-    rm .config-is-not.$$
-  else
-    echo "#"
-    echo "# No defaults found"
-    echo "#"
-  fi
-else
-  if [ -f $FORCE_DEFAULT ]; then
-    echo "#"
-    echo "# Forcing defaults found in $FORCE_DEFAULT"
-    echo "#"
-    sed -e '
-s/# \(CONFIG_[^ ]*\) is not.*/\1=n/;
-s/# range \(CONFIG_[^ ]*\) \([^ ][^ ]*\) \([^ ][^ ]*\)/MIN_\1=\2; MAX_\1=\3/;
-s/# list \(CONFIG_[^ ]*\) \([^ ][^ ]*\)/LIST_\1=\2/
-' <$FORCE_DEFAULT >.default_val.$$
-    . .default_val.$$
-    rm .default_val.$$
-  else
-    echo "#"
-    echo "# No defaults found"
-    echo "#"
-  fi 
-fi
-
-. $CONFIG_IN
-
-rm -f .config.old
-if [ -f .config ]; then
-	mv .config .config.old
-fi
-mv .tmpconfig .config
-mv .tmpconfig.h include/config.h
-
-echo
-echo "*** End of BusyBox configuration."
-echo "*** Check the top-level Makefile for additional configuration."
-if [ ! -f .hdepend -o "$CONFIG_MODVERSIONS" = "y" ] ; then
-    echo "*** Next, you must run 'make dep'."
-else
-    echo "*** Next, you may run 'make', or 'make install'."
-fi
-echo
-
-exit 0
diff --git a/scripts/Menuconfig b/scripts/Menuconfig
deleted file mode 100644
index 30d06ee29..000000000
--- a/scripts/Menuconfig
+++ /dev/null
@@ -1,1287 +0,0 @@
-#! /bin/sh
-#
-# This script is used to configure BusyBox.
-#
-# It was inspired by a desire to not have to hit <enter> 9 million times
-# or startup the X server just to change a single kernel parameter.  
-#
-# This script attempts to parse the configuration files, which are
-# scattered throughout the kernel source tree, and creates a temporary
-# set of mini scripts which are in turn used to create nested menus and
-# radiolists.
-#
-# It uses a very modified/mutilated version of the "dialog" utility
-# written by Savio Lam (lam836@cs.cuhk.hk). Savio is not responsible
-# for this script or the version of dialog used by this script.
-# Please do not contact him with questions. The official version of 
-# dialog is available at sunsite.unc.edu or a sunsite mirror.
-#
-# Portions of this script were borrowed from the original Configure
-# script.
-#
-# William Roadcap was the original author of Menuconfig.
-# Michael Elizabeth Chastain (mec@shout.net) is the current maintainer.
-#
-# 070497 Bernhard Kaindl (bkaindl@netway.at) - get default values for
-# new bool, tristate and dep_tristate parameters from the defconfig file.
-# new configuration parameters are marked with '(NEW)' as in make config.
-#
-# 180697 Bernhard Kaindl (bkaindl@netway.at) - added the needed support
-# for string options. They are handled like the int and hex options.
-#
-# 081297 Pavel Machek (pavel@atrey.karlin.mff.cuni.cz) - better error 
-# handling
-#
-# 131197 Michael Chastain (mec@shout.net) - output all lines for a
-# choice list, not just the selected one.  This makes the output
-# the same as Configure output, which is important for smart config
-# dependencies.
-#
-# 101297 Michael Chastain (mec@shout.net) - remove sound driver cruft.
-#
-# 221297 Michael Chastain (mec@shout.net) - make define_bool actually
-# define its arguments so that later tests on them work right.
-#
-# 160198 Michael Chastain (mec@shout.net) - fix bug with 'c' command
-# (complement existing value) when used on virgin uninitialized variables.
-#
-# 090398 Axel Boldt (boldt@math.ucsb.edu) - allow for empty lines in help
-# texts.
-#
-# 12 Dec 1998, Michael Elizabeth Chastain (mec@shout.net)
-# Remove a /tmp security hole in get_def (also makes it faster).
-# Give uninitialized variables canonical values rather than null value.
-# Change a lot of places to call set_x_info uniformly.
-# Take out message about preparing version (old sound driver cruft).
-#
-# 13 Dec 1998, Riley H Williams <rhw@memalpha.cx>
-# When an error occurs, actually display the error message as well as
-# our comments thereon.
-#
-# 31 Dec 1998, Michael Elizabeth Chastain (mec@shout.net)
-# Fix mod_bool to honor $CONFIG_MODULES.
-# Fix dep_tristate to call define_bool when dependency is "n".
-#
-# 02 January 1999, Michael Elizabeth Chastain (mec@shout.net)
-# Blow away lxdialog.scrltmp on entry to activate_menu.  This protects
-# against people who use commands like ' ' to select menus.
-#
-# 24 January 1999, Michael Elizabeth Chastain, <mec@shout.net>
-# - Improve the exit message (Jeff Ronne).
-#
-# 06 July 1999, Andrzej M. Krzysztofowicz, <ankry@mif.pg.gda.pl>
-# - Support for multiple conditions in dep_tristate().
-# - Implemented new functions: define_tristate(), define_int(), define_hex(),
-#   define_string(), dep_bool().
-# 
-# 22 October 2001, Erik Andersen <andersee@debian.org>
-# - Adjusted for busybox (modified hard coded kernel specific paths, 
-#   and everything to do with modules (tristates, modbools, etc).
-
-
-#
-# Change this to TRUE if you prefer all options listed
-# in a single menu rather than the standard menu hierarchy.
-#
-single_menu_mode=
-
-#
-# Make sure we're really running bash.
-#
-[ -z "$BASH" ] && { echo "Menuconfig requires bash" 1>&2; exit 1; }
-
-#
-# Cache function definitions, turn off posix compliance
-#
-set -h +o posix
-
-
-
-# Given a configuration variable, set the global variable $x to its value,
-# and the global variable $info to the string " (NEW)" if this is a new
-# variable.
-#
-# This function looks for: (1) the current value, or (2) the default value
-# from the arch-dependent defconfig file, or (3) a default passed by the caller.
-
-function set_x_info () {
-    eval x=\$$1
-    if [ -z "$x" ]; then
-	eval `sed -n -e 's/# \(.*\) is not set.*/\1=n/' -e "/^$1=/p" sysdeps/$TARGET_OS/defconfig`
-	eval x=\${$1:-"$2"}
-	eval $1=$x
-	eval INFO_$1="' (NEW)'"
-    fi
-    eval info="\$INFO_$1"
-}
-
-#
-# Load the functions used by the config.in files.
-#
-# I do this because these functions must be redefined depending
-# on whether they are being called for interactive use or for
-# saving a configuration to a file.
-#
-# Thank the heavens bash supports nesting function definitions.
-#
-load_functions () {
-
-#
-# Additional comments
-#
-function comment () {
-	comment_ctr=$[ comment_ctr + 1 ]
-	echo -ne "': $comment_ctr' '--- $1' " >>MCmenu
-}
-
-#
-# Define a boolean to a specific value.
-#
-function define_bool () {
-	eval $1=$2
-}
-
-function define_hex () {
-	eval $1=$2
-}
-
-function define_int () {
-	eval $1=$2
-}
-
-function define_string () {
-	eval $1="$2"
-}
-
-#
-# Create a boolean (Yes/No) function for our current menu
-# which calls our local bool function.
-#
-function bool () {
-	set_x_info "$2" "n"
-
-	case $x in
-	y|m)	flag="*" ;;
-	n)	flag=" " ;;
-	esac
-
-	echo -ne "'$2' '[$flag] $1$info' " >>MCmenu
-
-	echo -e "function $2 () { l_bool '$2' \"\$1\" ;}\n" >>MCradiolists
-}
-
-#
-#   Same as above, but now only Y and N are allowed as dependency
-#   (i.e. third and next arguments).
-#
-function dep_bool () {
-	ques="$1"
-	var="$2"
-	dep=y
-	shift 2
-	while [ $# -gt 0 ]; do
-		if [ "$1" = y ]; then
-			shift
-		else
-			dep=n
-			shift $#
-		fi
-	done
-	if [ "$dep" = y ]; then
-	    bool "$ques" "$var"
-	else 
-	    define_bool "$var" n
-	fi
-}
-
-function dep_mbool () {
-	ques="$1"
-	var="$2"
-	dep=y
-	shift 2
-	while [ $# -gt 0 ]; do
-		if [ "$1" = y -o "$1" = m ]; then
-			shift
-		else
-			dep=n
-			shift $#
-		fi
-	done
-	if [ "$dep" = y ]; then
-	    bool "$ques" "$var"
-	else 
-	    define_bool "$var" n
-	fi
-}
-
-#
-# Add a menu item which will call our local int function.
-# 
-function int () {
-	set_x_info "$2" "$3"
-
-	echo -ne "'$2' '($x) $1$info' " >>MCmenu
-
-	echo -e "function $2 () { l_int '$1' '$2' '$3' '$x' ;}" >>MCradiolists
-}
-
-#
-# Add a menu item which will call our local hex function.
-# 
-function hex () {
-	set_x_info "$2" "$3"
-	x=${x##*[x,X]}
-
-	echo -ne "'$2' '($x) $1$info' " >>MCmenu
-
-	echo -e "function $2 () { l_hex '$1' '$2' '$3' '$x' ;}" >>MCradiolists
-}
-
-#
-# Add a menu item which will call our local string function.
-# 
-function string () {
-	set_x_info "$2" "$3"
-
-	echo -ne "'$2' '     $1: \"$x\"$info' " >>MCmenu
-
-	echo -e "function $2 () { l_string '$1' '$2' '$3' '$x' ;}" >>MCradiolists
-}
-
-#
-# Add a menu item which will call our local One-of-Many choice list.
-#
-function choice () {
-	#
-	# Need to remember params cause they're gonna get reset.
-	#
-	title=$1
-	choices=$2
-	default=$3
-	current=
-
-	#
-	# Find out if one of the choices is already set.
-	# If it's not then make it the default.
-	#
-	set -- $choices
-	firstchoice=$2
-
-	while [ -n "$2" ]
-	do
-		if eval [ "_\$$2" = "_y" ]
-		then
-			current=$1
-			break
-		fi
-		shift ; shift
-	done
-
-	: ${current:=$default}
-
-	echo -ne "'$firstchoice' '($current) $title' " >>MCmenu
-
-	echo -e "
-	function $firstchoice () \
-		{ l_choice '$title' \"$choices\" \"$current\" ;}" >>MCradiolists
-}
-
-} # END load_functions()
-
-
-
-
-
-#
-# Extract available help for an option from Configure.help
-# and send it to standard output.
-#
-# Most of this function was borrowed from the original kernel
-# Configure script.
-#
-function extract_help () {
-  if [ -f docs/Configure.help ]
-  then
-     #first escape regexp special characters in the argument:
-     var=$(echo "$1"|sed 's/[][\/.^$*]/\\&/g')
-     #now pick out the right help text:
-     text=$(sed -n "/^$var[ 	]*\$/,\${
-                        /^$var[ 	]*\$/c\\
-${var}:\\
-
-                        /^#/b
-                        /^[^ 	]/q
-                        s/^  //
-			/<file:\\([^>]*\\)>/s//\\1/g
-                        p
-		    }" docs/Configure.help)
-
-     if [ -z "$text" ]
-     then
-          echo "There is no help available for this option."
-	  return 1
-     else
-	  echo "$text"
-     fi
-  else
-	 echo "There is no help available for this option."
-         return 1
-  fi
-}
-
-#
-# Activate a help dialog.
-#
-function help () {
-	if extract_help $1 >help.out
-	then
-		$DIALOG	--backtitle "$backtitle" --title "$2"\
-			--textbox help.out $ROWS $COLS
-	else
-		$DIALOG	--backtitle "$backtitle" \
-			--textbox help.out $ROWS $COLS
-	fi
-	rm -f help.out
-}
-
-#
-# Show the README file.
-#
-function show_readme () {
-	$DIALOG --backtitle "$backtitle" \
-		--textbox scripts/README.Menuconfig $ROWS $COLS
-}
-
-#
-# Begin building the dialog menu command and Initialize the 
-# Radiolist function file.
-#
-function menu_name () {
-	echo -ne "$DIALOG --title '$1'\
-			--backtitle '$backtitle' \
-			--menu '$menu_instructions' \
-			$ROWS $COLS $((ROWS-10)) \
-			'$default' " >MCmenu
-	>MCradiolists
-}
-
-#
-# Add a submenu option to the menu currently under construction.
-#
-function submenu () {
-	echo -ne "'activate_menu $2' '$1  --->' " >>MCmenu
-}
-
-#
-# Handle a boolean (Yes/No) option.
-#
-function l_bool () {
-	if [ -n "$2" ]
-	then
-		case "$2" in
-		y|m)	eval $1=y ;;
-		c)	eval x=\$$1
-		   	case $x in
-		   	y) eval $1=n ;;
-		   	n) eval $1=y ;;
-			*) eval $1=y ;;
-		   	esac ;;
-		*)	eval $1=n ;;
-		esac
-	else
-		echo -ne "\007"
-	fi
-}
-
-#
-# Create a dialog for entering an integer into a option.
-#
-function l_int () {
-	while true
-	do
-		if $DIALOG --title "$1" \
-			--backtitle "$backtitle" \
-			--inputbox "$inputbox_instructions_int" \
-			10 75 "$4" 2>MCdialog.out
-		then
-			answer="`cat MCdialog.out`"
-			answer="${answer:-$3}"
-
-			# Semantics of + and ? in GNU expr changed, so
-			# we avoid them:
-			if expr "$answer" : '0$' '|' "$answer" : '[1-9][0-9]*$' '|' "$answer" : '-[1-9][0-9]*$' >/dev/null
-			then
-				eval $2="$answer"
-			else
-				eval $2="$3"
-				echo -en "\007"
-				${DIALOG} --backtitle "$backtitle" \
-					--infobox "You have made an invalid entry." 3 43
-				sleep 2
-			fi
-
-			break
-		fi
-
-		help "$2" "$1"
-	done
-}
-
-#
-# Create a dialog for entering a hexadecimal into an option.
-#
-function l_hex () {
-	while true
-	do
-		if $DIALOG --title "$1" \
-			--backtitle "$backtitle" \
-			--inputbox "$inputbox_instructions_hex" \
-			10 75 "$4" 2>MCdialog.out
-		then
-			answer="`cat MCdialog.out`"
-			answer="${answer:-$3}"
-			answer="${answer##*[x,X]}"
-
-			if expr "$answer" : '[0-9a-fA-F][0-9a-fA-F]*$' >/dev/null
-			then
-				eval $2="$answer"
-			else
-				eval $2="$3"
-				echo -en "\007"
-				${DIALOG} --backtitle "$backtitle" \
-					--infobox "You have made an invalid entry." 3 43
-				sleep 2
-			fi
-
-			break
-		fi
-
-		help "$2" "$1"
-	done
-}
-
-#
-# Create a dialog for entering a string into an option.
-#
-function l_string () {
-	while true
-	do
-		if $DIALOG --title "$1" \
-			--backtitle "$backtitle" \
-			--inputbox "$inputbox_instructions_string" \
-			10 75 "$4" 2>MCdialog.out
-		then
-			answer="`cat MCdialog.out`"
-			answer="${answer:-$3}"
-
-			#
-			# Someone may add a nice check for the entered
-			# string here...
-			#
-			eval $2=\"$answer\"
-
-			break
-		fi
-
-		help "$2" "$1"
-	done
-}
-
-
-#
-# Handle a one-of-many choice list.
-#
-function l_choice () {
-	#
-	# Need to remember params cause they're gonna get reset.
-	#
-	title="$1"
-	choices="$2"
-	current="$3"
-        chosen=
-
-	#
-	# Scan current value of choices and set radiolist switches.
-	#
-	list=
-	set -- $choices
-	firstchoice=$2
-	while [ -n "$2" ]
-	do
-		case "$1" in
-		"$current"*)	if [ -z "$chosen" ]; then
-					list="$list $2 $1 ON "
-					chosen=1
-				else
-					list="$list $2 $1 OFF "
-				fi  ;;
-		*)		list="$list $2 $1 OFF " ;;
-		esac
-			
-		shift ; shift
-	done
-
-	while true
-	do
-		if $DIALOG --title "$title" \
-			--backtitle "$backtitle" \
-			--radiolist "$radiolist_instructions" \
-			15 70 6 $list 2>MCdialog.out
-		then
-			choice=`cat MCdialog.out`
-			break
-		fi
-
-		help "$firstchoice" "$title"
-	done
-
-	#
-	# Now set the boolean value of each option based on
-	# the selection made from the radiolist.
-	#
-	set -- $choices
-	while [ -n "$2" ]
-	do
-		if [ "$2" = "$choice" ]
-		then
-			eval $2="y"
-		else
-			eval $2="n"
-		fi
-		
-		shift ; shift
-	done
-}
-
-#
-# Call awk, and watch for error codes, etc.
-#
-function callawk () {
-awk "$1" || echo "Awk died with error code $?. Giving up." || exit 1
-}
-
-#
-# A faster awk based recursive parser. (I hope)
-#
-function parser1 () {
-callawk '
-BEGIN {
-	menu_no = 0
-	comment_is_option = 0
-	parser("'$CONFIG_IN'","MCmenu0")
-}
-
-function parser(ifile,menu) {
-
-	while (getline <ifile) {
-		if ($1 == "mainmenu_option") {
-			comment_is_option = "1"
-		}
-		else if ($1 == "comment" && comment_is_option == "1") {
-			comment_is_option= "0"
-			sub($1,"",$0)
-			++menu_no
-
-			printf("submenu %s MCmenu%s\n", $0, menu_no) >>menu
-
-			newmenu = sprintf("MCmenu%d", menu_no);
-			printf( "function MCmenu%s () {\n"\
-				"default=$1\n"\
-				"menu_name %s\n",\
-				 menu_no, $0) >newmenu
-
-			parser(ifile, newmenu)
-		}
-		else if ($0 ~ /^#|\$MAKE|mainmenu_name/) {
-			printf("") >>menu
-		}
-		else if ($1 ~ "endmenu") {
-			printf("}\n") >>menu
-			return
-		} 
-		else if ($1 == "source") {
-			parser($2,menu)
-		}
-		else {
-			print >>menu
-		}
-	}
-}'
-}
-
-#
-# Secondary parser for single menu mode.
-#
-function parser2 () {
-callawk '
-BEGIN {
-	parser("'$CONFIG_IN'","MCmenu0")
-}
-
-function parser(ifile,menu) {
-
-	while (getline <ifile) {
-		if ($0 ~ /^#|$MAKE|mainmenu_name/) {
-			printf("") >>menu
-		}
-		else if ($1 ~ /mainmenu_option|endmenu/) {
-			printf("") >>menu
-		} 
-		else if ($1 == "source") {
-			parser($2,menu)
-		}
-		else {
-			print >>menu
-		}
-	}
-}'
-}
-
-#
-# Parse all the config.in files into mini scripts.
-#
-function parse_config_files () {
-	rm -f MCmenu*
-
-	echo "function MCmenu0 () {" >MCmenu0
-	echo 'default=$1' >>MCmenu0
-	echo "menu_name 'Main Menu'" >>MCmenu0
-
-	if [ "_$single_menu_mode" = "_TRUE" ]
-	then
-		parser2
-	else
-		parser1
-	fi
-
-	echo "comment ''"	>>MCmenu0
-	echo "g_alt_config" 	>>MCmenu0
-	echo "s_alt_config" 	>>MCmenu0
-
-	echo "}" >>MCmenu0
-
-	#
-	# These mini scripts must be sourced into the current
-	# environment in order for all of this to work.  Leaving
-	# them on the disk as executables screws up the recursion
-	# in activate_menu(), among other things.  Once they are
-	# sourced we can discard them.
-	#
-	for i in MCmenu*
-	do
-		echo -n "."
-		source ./$i
-	done
-	rm -f MCmenu*
-}
-
-#
-# This is the menu tree's bootstrap.
-#
-# Executes the parsed menus on demand and creates a set of functions,
-# one per configuration option.  These functions will in turn execute
-# dialog commands or recursively call other menus.
-#
-function activate_menu () {
-	rm -f lxdialog.scrltmp
-	while true
-	do
-		comment_ctr=0		#So comment lines get unique tags
-
-		$1 "$default" 2> MCerror #Create the lxdialog menu & functions
-
-		if [ "$?" != "0" ]
-		then
-			clear
-			cat <<EOM
-
-Menuconfig has encountered a possible error in one of BusyBox's
-configuration files and is unable to continue.  Here is the error
-report:
-
-EOM
-			sed 's/^/ Q> /' MCerror
-			cat <<EOM
-
-Please report this to the maintainer <mec@shout.net>.  You may also
-send a problem report to <busybox@busybox.net>.
-
-Please indicate the BusyBox version you are trying to configure and
-which menu you were trying to enter when this error occurred.
-
-EOM
-			cleanup
-			exit 1
-		fi
-		rm -f MCerror
-
-		. ./MCradiolists		#Source the menu's functions
-
-		. ./MCmenu 2>MCdialog.out	#Activate the lxdialog menu
-		ret=$?
-
-		read selection <MCdialog.out
-
-		case "$ret" in
-		0|3|4|5|6)
-			defaults="$selection$defaults"  #pseudo stack
-			case "$ret" in
-			0) eval $selection   ;;
-			3) eval $selection y ;;
-			4) eval $selection n ;;
-			5) eval $selection m ;;
-			6) eval $selection c ;;
-			esac
-			default="${defaults%%*}" defaults="${defaults#*}"
-			;;
-		2)	
-			default="${selection%%\ *}"
-
-			case "$selection" in
-			*"-->"*|*"alt_config"*)
-				show_readme ;;
-			*)
-				eval help $selection ;;
-			esac
-			;;
-		255|1)
-			break
-			;;
-		139)
-			stty sane
-			clear
-			cat <<EOM
-
-There seems to be a problem with the lxdialog companion utility which is
-built prior to running Menuconfig.  Usually this is an indicator that you
-have upgraded/downgraded your ncurses libraries and did not remove the 
-old ncurses header file(s) in /usr/include or /usr/include/ncurses.
-
-It is VERY important that you have only one set of ncurses header files
-and that those files are properly version matched to the ncurses libraries 
-installed on your machine.
-
-You may also need to rebuild lxdialog.  This can be done by moving to
-the /usr/src/linux/scripts/lxdialog directory and issuing the 
-"make clean all" command.
-
-If you have verified that your ncurses install is correct, you may email
-the maintainer <andersen@codepoet.org> or post a message to
-<busybox@busybox.net> for additional assistance. 
-
-EOM
-			cleanup
-			exit 139
-			;;
-		esac
-	done
-}
-
-#
-# Create a menu item to load an alternate configuration file.
-#
-g_alt_config () {
-	echo -n "get_alt_config 'Load an Alternate Configuration File' "\
-		>>MCmenu
-}
-
-#
-# Get alternate config file name and load the 
-# configuration from it.
-#
-get_alt_config () {
-	set -f ## Switch file expansion OFF
-
-	while true
-	do
-		ALT_CONFIG="${ALT_CONFIG:-$DEFAULTS}"
-
-		$DIALOG --backtitle "$backtitle" \
-			--inputbox "\
-Enter the name of the configuration file you wish to load.  \
-Accept the name shown to restore the configuration you \
-last retrieved.  Leave blank to abort."\
-			11 55 "$ALT_CONFIG" 2>MCdialog.out
-
-		if [ "$?" = "0" ]
-		then
-			ALT_CONFIG=`cat MCdialog.out`
-
-			[ "_" = "_$ALT_CONFIG" ] && break
-
-			if eval [ -r "$ALT_CONFIG" ]
-			then
-				eval load_config_file "$ALT_CONFIG"
-				break
-			else
-				echo -ne "\007"
-				$DIALOG	--backtitle "$backtitle" \
-					--infobox "File does not exist!"  3 38
-				sleep 2
-			fi
-		else
-			cat <<EOM >help.out
-
-For various reasons, one may wish to keep several different BusyBox
-configurations available on a single machine.  
-
-If you have saved a previous configuration in a file other than the
-busybox default, entering the name of the file here will allow you
-to modify that configuration.
-
-If you are uncertain, then you have probably never used alternate 
-configuration files.  You should therefor leave this blank to abort.
-
-EOM
-			$DIALOG	--backtitle "$backtitle"\
-				--title "Load Alternate Configuration"\
-				--textbox help.out $ROWS $COLS
-		fi
-	done
-
-	set +f ## Switch file expansion ON
-	rm -f help.out MCdialog.out
-}
-
-#
-# Create a menu item to store an alternate config file.
-#
-s_alt_config () {
-	echo -n "save_alt_config 'Save Configuration to an Alternate File' "\
-		 >>MCmenu
-}
-
-#
-# Get an alternate config file name and save the current
-# configuration to it.
-#
-save_alt_config () {
-	set -f  ## Switch file expansion OFF
-			
-	while true
-	do
-		$DIALOG --backtitle "$backtitle" \
-			--inputbox "\
-Enter a filename to which this configuration should be saved \
-as an alternate.  Leave blank to abort."\
-			10 55 "$ALT_CONFIG" 2>MCdialog.out
-
-		if [ "$?" = "0" ]
-		then
-			ALT_CONFIG=`cat MCdialog.out`
-
-			[ "_" = "_$ALT_CONFIG" ] && break
-
-			if eval touch $ALT_CONFIG 2>/dev/null
-			then
-				eval save_configuration $ALT_CONFIG
-				load_functions  ## RELOAD
-				break
-			else
-				echo -ne "\007"
-				$DIALOG	--backtitle "$backtitle" \
-					--infobox "Can't create file!  Probably a nonexistent directory." 3 60
-				sleep 2
-			fi
-		else
-			cat <<EOM >help.out
-
-For various reasons, one may wish to keep different BusyBox
-configurations available on a single machine.  
-
-Entering a file name here will allow you to later retrieve, modify
-and use the current configuration as an alternate to whatever 
-configuration options you have selected at that time.
-
-If you are uncertain what all this means then you should probably
-leave this blank.
-EOM
-			$DIALOG	--backtitle "$backtitle"\
-				--title "Save Alternate Configuration"\
-				--textbox help.out $ROWS $COLS
-		fi
-	done
-
-	set +f  ## Switch file expansion ON
-	rm -f help.out MCdialog.out
-}
-
-#
-# Load config options from a file.
-# Converts all "# OPTION is not set" lines to "OPTION=n" lines
-#
-function load_config_file () {
-	awk '
-	  /# .* is not set.*/ { printf("%s=n\n", $2) }
-	! /# .* is not set.*/ { print }
-	' $1 >.tmpconfig
-
-	source ./.tmpconfig
-	rm -f .tmpconfig
-}
-
-#
-# Just what it says.
-#
-save_configuration () {
-        echo
-	echo -n "Saving your BusyBox configuration."
-
-	#
-	# Now, let's redefine the configuration functions for final
-	# output to the config files.
-	#
-	# Nested function definitions, YIPEE!
-	#
-	function bool () {
-		set_x_info "$2" "n"
-		eval define_bool "$2" "$x"
-	}
-
-	function dep_bool () {
-		set_x_info "$2" "n"
-		var="$2"
-		shift 2
-		while [ $# -gt 0 ]; do
-			if   [ "$1" = y ]; then
-				shift
-			else 
-				x=n; shift $#
-			fi
-		done
-		define_bool "$var" "$x"
-	}
-
-	function int () {
-		set_x_info "$2" "$3"
-		echo "$2=$x" 		>>$CONFIG
-		echo "#define $2 ($x)"	>>$CONFIG_H
-	}
-
-	function hex () {
-		set_x_info "$2" "$3"
-		echo "$2=$x" 			 >>$CONFIG
-		echo "#define $2 0x${x##*[x,X]}" >>$CONFIG_H
-	}
-
-	function string () {
-		set_x_info "$2" "$3"
-		echo "$2=\"$x\"" 			 >>$CONFIG
-		echo "#define $2 \"$x\""	>>$CONFIG_H
-	}
-
-	function define_hex () {
-		eval $1="$2"
-               	echo "$1=$2"			>>$CONFIG
-		echo "#define $1 0x${2##*[x,X]}"	>>$CONFIG_H
-	}
-
-	function define_int () {
-		eval $1="$2"
-		echo "$1=$2" 			>>$CONFIG
-		echo "#define $1 ($2)"		>>$CONFIG_H
-	}
-
-	function define_string () {
-		eval $1="$2"
-		echo "$1=\"$2\""		>>$CONFIG
-		echo "#define $1 \"$2\""	>>$CONFIG_H
-	}
-
-	function define_bool () {
-		define_tristate "$1" "$2"
-	}
-
-	function define_tristate () {
-		eval $1="$2"
-
-   		case "$2" in
-         	y)
-                	echo "$1=y" 		>>$CONFIG
-                	echo "#define $1 1"	>>$CONFIG_H
-                	;;
-
-         	n)
-			echo "# $1 is not set"	>>$CONFIG
-                	echo "#undef  $1"	>>$CONFIG_H
-                	;;
-        	esac
-	}
-
-	function choice () {
-		#
-		# Find the first choice that's already set to 'y'
-		#
-		choices="$2"
-		default="$3"
-		current=
-		chosen=
-
-		set -- $choices
-		while [ -n "$2" ]
-		do
-			if eval [ "_\$$2" = "_y" ]
-			then
-				current=$1
-				break
-			fi
-			shift ; shift
-		done
-
-		#
-		# Use the default if none were set.  
-		#
-		: ${current:=$default}
-
-		#
-		# Output all choices (to be compatible with other configs).
-		#
-		set -- $choices
-		while [ -n "$2" ]
-		do
-			case "$1" in
-			"$current"*)	if [ -z "$chosen" ]; then
-						define_bool "$2" "y"
-						chosen=1
-					else
-						define_bool "$2" "n"
-					fi ;;
-			*)		define_bool "$2" "n" ;;
-			esac
-			shift ; shift
-		done
-	}
-
-	function mainmenu_name () {
-		:
-	}
-
-	function mainmenu_option () {
-		comment_is_option=TRUE
-	}
-
-	function endmenu () {
-		:
-	}
-
-	function comment () {
-		if [ "$comment_is_option" ]
-		then
-			comment_is_option=
-			echo        >>$CONFIG
-			echo "#"    >>$CONFIG
-			echo "# $1" >>$CONFIG
-			echo "#"    >>$CONFIG
-
-			echo         >>$CONFIG_H
-			echo "/*"    >>$CONFIG_H
-			echo " * $1" >>$CONFIG_H
-			echo " */"   >>$CONFIG_H
-		fi
-	}
-
-	echo -n "."
-
-	DEF_CONFIG="${1:-.config}"
-	DEF_CONFIG_H="include/config.h"
-
-	CONFIG=.tmpconfig
-	CONFIG_H=.tmpconfig.h
-
-	echo "#" >$CONFIG
-	echo "# Automatically generated by make menuconfig: don't edit" >>$CONFIG
-	echo "#" >>$CONFIG
-
-	echo "/*" >$CONFIG_H
-	echo " * Automatically generated by make menuconfig: don't edit" >>$CONFIG_H
-	echo " */" >>$CONFIG_H
-	echo "#define AUTOCONF_INCLUDED" >> $CONFIG_H
-
-	echo -n "."
-	if . $CONFIG_IN >>.menuconfig.log 2>&1
-	then
-		if [ "$DEF_CONFIG" = ".config" ]
-		then
-			mv $CONFIG_H $DEF_CONFIG_H
-		fi
-
-		if [ -f "$DEF_CONFIG" ]
-		then
-			rm -f ${DEF_CONFIG}.old
-			mv $DEF_CONFIG ${DEF_CONFIG}.old
-		fi
-
-		mv $CONFIG $DEF_CONFIG
-			
-		return 0
-	else
-		return 1
-	fi
-}
-
-#
-# Remove temporary files
-#
-cleanup () {
-	cleanup1
-	cleanup2
-}
-
-cleanup1 () {
-	rm -f MCmenu* MCradiolists MCdialog.out help.out
-}
-
-cleanup2 () {
-	rm -f .tmpconfig .tmpconfig.h
-}
-
-set_geometry () {
-	# Some distributions export these with incorrect values
-	# which can really screw up some ncurses programs.
-	LINES=  COLUMNS=
-
-	ROWS=${1:-24}  COLS=${2:-80} 
-
-	# Just in case the nasty rlogin bug returns.
-	#
-	[ $ROWS = 0 ] && ROWS=24
-	[ $COLS = 0 ] && COLS=80
-
-	if [ $ROWS -lt 19 -o $COLS -lt 80 ]
-	then
-		echo -e "\n\007Your display is too small to run Menuconfig!"
-		echo "It must be at least 19 lines by 80 columns."
-		exit 1
-	fi 
-
-	ROWS=$((ROWS-4))  COLS=$((COLS-5))
-}
-
-
-set_geometry `stty size 2>/dev/null`
-
-menu_instructions="\
-Enabling options will increase the size of busybox.  \
-Arrow keys navigate the menu.  \
-Pressing <Enter> selects submenus --->.  \
-Highlighted letters are hotkeys.  \
-Pressing <Y> includes, and <N> excludes.  \
-Press <Esc><Esc> to exit, <?> for Help.  \
-Legend: [*] built-in  [ ] excluded"
-
-
-radiolist_instructions="\
-Use the arrow keys to navigate this window or \
-press the hotkey of the item you wish to select \
-followed by the <SPACE BAR>.
-Press <?> for additional information about this option."
-
-inputbox_instructions_int="\
-Please enter a decimal value. \
-Fractions will not be accepted.  \
-Use the <TAB> key to move from the input field to the buttons below it."
-
-inputbox_instructions_hex="\
-Please enter a hexadecimal value. \
-Use the <TAB> key to move from the input field to the buttons below it."
-
-inputbox_instructions_string="\
-Please enter a string value. \
-Use the <TAB> key to move from the input field to the buttons below it."
-
-DIALOG="./scripts/lxdialog/lxdialog"
-
-bb_version="${VERSION}"
-backtitle="BusyBox v$bb_version Configuration"
-
-trap "cleanup ; exit 1" 1 2 15
-
-
-#
-# Locate default files.
-#
-CONFIG_IN=./config.in
-if [ "$1" != "" ] ; then
-	CONFIG_IN=$1
-fi
-
-DEFAULTS=sysdeps/$TARGET_OS/defconfig
-if [ -f .config ]; then
-  DEFAULTS=.config
-fi
-
-if [ -f $DEFAULTS ]
-then
-  echo "Using defaults found in" $DEFAULTS
-  load_config_file $DEFAULTS
-else
-  echo "No defaults found"
-fi
-
-
-# Fresh new log.
->.menuconfig.log
-
-# Load the functions used by the config.in files.
-echo -n "Preparing scripts: functions" 
-load_functions
-
-if [ ! -e $CONFIG_IN ]
-then
-	echo "Your main config.in file ($CONFIG_IN) does not exist"
-	exit 1
-fi
-
-if [ ! -x $DIALOG ]
-then
-	echo "Your lxdialog utility does not exist"
-	exit 1
-fi
-
-#
-# Read config.in files and parse them into one shell function per menu.
-#
-echo -n ", parsing"
-parse_config_files $CONFIG_IN
-
-echo "done."
-#
-# Start the ball rolling from the top.
-#
-activate_menu MCmenu0
-
-#
-# All done!
-#
-cleanup1
-
-#
-# Confirm and Save
-#
-if $DIALOG --backtitle "$backtitle" \
-	   --yesno "Do you wish to save your new BusyBox configuration?" 5 60
-then
-	save_configuration
-	echo
-	echo
-	echo "*** End of BusyBox configuration."
-	echo "*** Check the top-level Makefile for additional configuration."
-	if [ ! -f .hdepend ] ; then
-	    echo "*** Next, you must run 'make dep'."
-	else
-	    echo "*** Next, you should run 'make' or 'make install'."
-	fi
-	echo
-else
-	echo
-    	echo 
-	echo Your BusyBox configuration changes were NOT saved.
-	echo
-fi
-
-# Remove log if empty.
-if [ ! -s .menuconfig.log ] ; then
-	rm -f .menuconfig.log
-fi
-
-exit 0
diff --git a/scripts/config/.cvsignore b/scripts/config/.cvsignore
new file mode 100644
index 000000000..e8bf7a75b
--- /dev/null
+++ b/scripts/config/.cvsignore
@@ -0,0 +1,8 @@
+conf
+mconf
+lkc_defs.h
+lex.zconf.c
+zconf.tab.h
+zconf.tab.c
+lex.backup
+zconf.output
diff --git a/scripts/config/Kconfig-language.txt b/scripts/config/Kconfig-language.txt
new file mode 100644
index 000000000..a3037ffcf
--- /dev/null
+++ b/scripts/config/Kconfig-language.txt
@@ -0,0 +1,255 @@
+Introduction
+------------
+
+The configuration database is collection of configuration options
+organized in a tree structure:
+
+	+- Code maturity level options
+	|  +- Prompt for development and/or incomplete code/drivers
+	+- General setup
+	|  +- Networking support
+	|  +- System V IPC
+	|  +- BSD Process Accounting
+	|  +- Sysctl support
+	+- Loadable module support
+	|  +- Enable loadable module support
+	|     +- Set version information on all module symbols
+	|     +- Kernel module loader
+	+- ...
+
+Every entry has its own dependencies. These dependencies are used
+to determine the visible of an entry. Any child entry is only
+visible if its parent entry is also visible.
+
+Menu entries
+------------
+
+Most entries define a config option, all other entries help to organize
+them. A single configuration option is defined like this:
+
+config MODVERSIONS
+	bool "Set version information on all module symbols"
+	depends MODULES
+	help
+	  Usually, modules have to be recompiled whenever you switch to a new
+	  kernel.  ...
+
+Every line starts with a key word and can be followed by multiple
+arguments.  "config" starts a new config entry. The following lines
+define attributes for this config option. Attributes can be the type of
+the config option, input prompt, dependencies, help text and default
+values. A config option can be defined multiple times with the same
+name, but every definition can have only a single input prompt and the
+type must not conflict.
+
+Menu attributes
+---------------
+
+A menu entry can have a number of attributes. Not all of them are
+applicable everywhere (see syntax).
+
+- type definition: "bool"/"tristate"/"string"/"hex"/"integer"
+  Every config option must have a type. There are only two basic types:
+  tristate and string, the other types base on these two. The type
+  definition optionally accepts an input prompt, so these two examples
+  are equivalent:
+
+	bool "Networking support"
+  and
+	bool
+	prompt "Networking support"
+
+- input prompt: "prompt" <prompt> ["if" <expr>]
+  Every menu entry can have at most one prompt, which is used to display
+  to the user. Optionally dependencies only for this prompt can be added
+  with "if".
+
+- default value: "default" <symbol> ["if" <expr>]
+  A config option can have any number of default values. If multiple
+  default values are visible, only the first defined one is active.
+  Default values are not limited to the menu entry, where they are
+  defined, this means the default can be defined somewhere else or be
+  overriden by an earlier definition.
+  The default value is only assigned to the config symbol if no other
+  value was set by the user (via the input prompt above). If an input
+  prompt is visible the default value is presented to the user and can
+  be overridden by him.
+  Optionally dependencies only for this default value can be added with
+  "if".
+
+- dependencies: "depends on"/"requires" <expr>
+  This defines a dependency for this menu entry. If multiple
+  dependencies are defined they are connected with '&&'. Dependencies
+  are applied to all other options within this menu entry (which also
+  accept "if" expression), so these two examples are equivalent:
+
+	bool "foo" if BAR
+	default y if BAR
+  and
+	depends on BAR
+	bool "foo"
+	default y
+
+- help text: "help"
+  This defines a help text. The end of the help text is determined by
+  the level indentation, this means it ends at the first line which has
+  a smaller indentation than the first line of the help text.
+
+
+Menu dependencies
+-----------------
+
+Dependencies define the visibility of a menu entry and can also reduce
+the input range of tristate symbols. The tristate logic used in the
+expressions uses one more state than normal boolean logic to express the
+module state. Dependency expressions have the following syntax:
+
+<expr> ::= <symbol>                             (1)
+           <symbol> '=' <symbol>                (2)
+           <symbol> '!=' <symbol>               (3)
+           '(' <expr> ')'                       (4)
+           '!' <expr>                           (5)
+           <expr> '||' <expr>                   (6)
+           <expr> '&&' <expr>                   (7)
+
+Expressions are listed in decreasing order of precedence. 
+
+(1) Convert the symbol into an expression. Boolean and tristate symbols
+    are simply converted into the respective expression values. All
+    other symbol types result in 'n'.
+(2) If the values of both symbols are equal, it returns 'y',
+    otherwise 'n'.
+(3) If the values of both symbols are equal, it returns 'n',
+    otherwise 'y'.
+(4) Returns the value of the expression. Used to override precedence.
+(5) Returns the result of (2-/expr/).
+(6) Returns the result of min(/expr/, /expr/).
+(7) Returns the result of max(/expr/, /expr/).
+
+An expression can have a value of 'n', 'm' or 'y' (or 0, 1, 2
+respectively for calculations). A menu entry becomes visible when it's
+expression evaluates to 'm' or 'y'.
+
+There are two type of symbols: constant and nonconstant symbols.
+Nonconstant symbols are the most common ones and are defined with the
+'config' statement. Nonconstant symbols consist entirely of alphanumeric
+characters or underscores.
+Constant symbols are only part of expressions. Constant symbols are
+always surrounded by single or double quotes. Within the quote any
+other character is allowed and the quotes can be escaped using '\'.
+
+Menu structure
+--------------
+
+The position of a menu entry in the tree is determined in two ways. First
+it can be specified explicitely:
+
+menu "Network device support"
+	depends NET
+
+config NETDEVICES
+	...
+
+endmenu
+
+All entries within the "menu" ... "endmenu" block become a submenu of
+"Network device support". All subentries inherit the dependencies from
+the menu entry, e.g. this means the dependency "NET" is added to the
+dependency list of the config option NETDEVICES.
+
+The other way to generate the menu structure is done by analyzing the
+dependencies. If a menu entry somehow depends on the previous entry, it
+can be made a submenu of it. First the the previous (parent) symbol must
+be part of the dependency list and then one of these two condititions
+must be true:
+- the child entry must become invisible, if the parent is set to 'n'
+- the child entry must only be visible, if the parent is visible
+
+config MODULES
+	bool "Enable loadable module support"
+
+config MODVERSIONS
+	bool "Set version information on all module symbols"
+	depends MODULES
+
+comment "module support disabled"
+	depends !MODULES
+
+MODVERSIONS directly depends on MODULES, this means it's only visible if
+MODULES is different from 'n'. The comment on the other hand is always
+visible when MODULES it's visible (the (empty) dependency of MODULES is
+also part of the comment dependencies).
+
+
+Kconfig syntax
+--------------
+
+The configuration file describes a series of menu entries, where every
+line starts with a keyword (except help texts). The following keywords
+end a menu entry:
+- config
+- choice/endchoice
+- comment
+- menu/endmenu
+- if/endif
+- source
+The first four also start the definition of a menu entry.
+
+config:
+
+	"config" <symbol>
+	<config options>
+
+This defines a config symbol <symbol> and accepts any of above
+attributes as options.
+
+choices:
+
+	"choice"
+	<choice options>
+	<choice block>
+	"endchoice"
+
+This defines a choice group and accepts any of above attributes as
+options. A choice can only be of type bool or tristate, while a boolean
+choice only allows a single config entry to be selected, a tristate
+choice also allows any number of config entries to be set to 'm'. This
+can be used if multiple drivers for a single hardware exists and only a
+single driver can be compiled/loaded into the kernel, but all drivers
+can be compiled as modules.
+A choice accepts another option "optional", which allows to set the
+choice to 'n' and no entry needs to be selected.
+
+comment:
+
+	"comment" <prompt>
+	<comment options>
+
+This defines a comment which is displayed to the user during the
+configuration process and is also echoed to the output files. The only
+possible options are dependencies.
+
+menu:
+
+	"menu" <prompt>
+	<menu options>
+	<menu block>
+	"endmenu"
+
+This defines a menu block, see "Menu structure" above for more
+information. The only possible options are dependencies.
+
+if:
+
+	"if" <expr>
+	<if block>
+	"endif"
+
+This defines an if block. The dependency expression <expr> is appended
+to all enclosed menu entries.
+
+source:
+
+	"source" <prompt>
+
+This reads the specified configuration file. This file is always parsed.
diff --git a/scripts/config/Makefile b/scripts/config/Makefile
new file mode 100644
index 000000000..d43c8b14f
--- /dev/null
+++ b/scripts/config/Makefile
@@ -0,0 +1,102 @@
+# Makefile for BusyBox
+#
+# Copyright (C) 2002 Erik Andersen <andersen@codepoet.org>
+
+TOPDIR=../../
+include $(TOPDIR)Rules.mak
+
+
+all: ncurses conf mconf
+
+#HOSTCFLAGS=-Wall -g -O0
+LIBS = -lncurses
+ifeq (/usr/include/ncurses/ncurses.h, $(wildcard /usr/include/ncurses/ncurses.h))
+	HOSTCFLAGS += -I/usr/include/ncurses -DCURSES_LOC="<ncurses.h>"
+else
+ifeq (/usr/include/ncurses/curses.h, $(wildcard /usr/include/ncurses/curses.h))
+	HOSTCFLAGS += -I/usr/include/ncurses -DCURSES_LOC="<ncurses/curses.h>"
+else
+ifeq (/usr/include/ncurses.h, $(wildcard /usr/include/ncurses.h))
+	HOSTCFLAGS += -DCURSES_LOC="<ncurses.h>"
+else
+	HOSTCFLAGS += -DCURSES_LOC="<curses.h>"
+endif
+endif
+endif
+
+
+CONF_SRC  =conf.c zconf.tab.c
+MCONF_SRC =mconf.c zconf.tab.c
+LXDLG_SRC =checklist.c menubox.c textbox.c yesno.c inputbox.c util.c msgbox.c
+CONF_OBJS =$(patsubst %.c,%.o, $(CONF_SRC))
+MCONF_OBJS=$(patsubst %.c,%.o, $(MCONF_SRC))
+LXDLG_OBJS=$(patsubst %.c,%.o, $(LXDLG_SRC))
+
+conf: $(CONF_OBJS) 
+	$(HOSTCC) $(HOSTCFLAGS) $(NATIVE_LDFLAGS) $^ -o $@
+
+mconf: $(MCONF_OBJS) $(LXDLG_OBJS)
+	$(HOSTCC) $(HOSTCFLAGS) $(NATIVE_LDFLAGS) $^ -o $@ $(LIBS)
+
+lkc_deps:=lkc.h lkc_proto.h lkc_defs.h expr.h zconf.tab.h
+
+conf.o: conf.c $(lkc_deps)
+
+mconf.o: mconf.c $(lkc_deps)
+
+zconf.tab.o: zconf.tab.c lex.zconf.c confdata.c expr.c symbol.c menu.c $(lkc_deps)
+
+lex.zconf.o: lex.zconf.c $(lkc_deps)
+
+%.o : %.c
+	$(HOSTCC) $(HOSTCFLAGS) -I. -c $< -o $@
+
+lkc_defs.h: lkc_proto.h
+	@sed < $< > $@ 's/P(\([^,]*\),.*/#define \1 (\*\1_p)/'
+
+###
+# The following requires flex/bison
+# By default we use the _shipped versions, uncomment the 
+# following line if you are modifying the flex/bison src.
+#LKC_GENPARSER := 1
+
+ifdef LKC_GENPARSER
+
+%.tab.c %.tab.h: %.y
+	bison -t -d -v -b $* -p $(notdir $*) $<
+
+lex.%.c: %.l
+	flex -P$(notdir $*) -o$@ $<
+else
+
+lex.zconf.c: lex.zconf.c_shipped
+	cp lex.zconf.c_shipped lex.zconf.c
+
+zconf.tab.c: zconf.tab.c_shipped
+	cp zconf.tab.c_shipped zconf.tab.c
+
+zconf.tab.h: zconf.tab.h_shipped
+	cp zconf.tab.h_shipped zconf.tab.h
+endif
+
+.PHONY: ncurses
+
+ncurses:
+	@echo "main() {}" > lxtemp.c
+	@if $(HOSTCC) lxtemp.c $(LIBS) ; then \
+		rm -f lxtemp.c a.out; \
+	else \
+		rm -f lxtemp.c; \
+		echo -e "\007" ;\
+		echo ">> Unable to find the Ncurses libraries." ;\
+		echo ">>" ;\
+		echo ">> You must have Ncurses installed in order" ;\
+		echo ">> to use 'make menuconfig'" ;\
+		echo ;\
+		exit 1 ;\
+	fi
+
+clean:
+	rm -f *.o *~ core $(TARGETS) $(MCONF_OBJS) $(CONF_OBJS) \
+		conf mconf zconf.tab.c zconf.tab.h lex.zconf.c lkc_defs.h
+
diff --git a/scripts/lxdialog/checklist.c b/scripts/config/checklist.c
similarity index 91%
rename from scripts/lxdialog/checklist.c
rename to scripts/config/checklist.c
index 4f78688ed..c4a9289b9 100644
--- a/scripts/lxdialog/checklist.c
+++ b/scripts/config/checklist.c
@@ -118,7 +118,8 @@ print_buttons( WINDOW *dialog, int height, int width, int selected)
  */
 int
 dialog_checklist (const char *title, const char *prompt, int height, int width,
-	int list_height, int item_no, const char * const * items, int flag)
+	int list_height, int item_no, struct dialog_list_item ** items,
+	int flag)
 	
 {
     int i, x, y, box_x, box_y;
@@ -137,7 +138,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 
     /* Initializes status */
     for (i = 0; i < item_no; i++) {
-	status[i] = !strcasecmp (items[i * 3 + 2], "on");
+	status[i] = items[i]->selected;
 	if (!choice && status[i])
             choice = i;
     }
@@ -195,7 +196,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
     /* Find length of longest item in order to center checklist */
     check_x = 0;
     for (i = 0; i < item_no; i++) 
-	check_x = MAX (check_x, + strlen (items[i * 3 + 1]) + 4);
+	check_x = MAX (check_x, + strlen (items[i]->name) + 4);
 
     check_x = (list_width - check_x) / 2;
     item_x = check_x + 4;
@@ -207,7 +208,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 
     /* Print the list */
     for (i = 0; i < max_choice; i++) {
-	print_item (list, items[(scroll+i) * 3 + 1],
+	print_item (list, items[scroll + i]->name,
 		    status[i+scroll], i, i == choice);
     }
 
@@ -224,7 +225,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 	key = wgetch (dialog);
 
     	for (i = 0; i < max_choice; i++)
-            if (toupper(key) == toupper(items[(scroll+i)*3+1][0]))
+            if (toupper(key) == toupper(items[scroll + i]->name[0]))
                 break;
 
 
@@ -237,14 +238,14 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 		    /* Scroll list down */
 		    if (list_height > 1) {
 			/* De-highlight current first item */
-			print_item (list, items[scroll * 3 + 1],
+			print_item (list, items[scroll]->name,
 					status[scroll], 0, FALSE);
 			scrollok (list, TRUE);
 			wscrl (list, -1);
 			scrollok (list, FALSE);
 		    }
 		    scroll--;
-		    print_item (list, items[scroll * 3 + 1],
+		    print_item (list, items[scroll]->name,
 				status[scroll], 0, TRUE);
 		    wnoutrefresh (list);
 
@@ -263,7 +264,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 		    /* Scroll list up */
 		    if (list_height > 1) {
 			/* De-highlight current last item before scrolling up */
-			print_item (list, items[(scroll + max_choice - 1) * 3 + 1],
+			print_item (list, items[scroll + max_choice - 1]->name,
 				    status[scroll + max_choice - 1],
 				    max_choice - 1, FALSE);
 			scrollok (list, TRUE);
@@ -271,7 +272,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 			scrollok (list, FALSE);
 		    }
 		    scroll++;
-		    print_item (list, items[(scroll + max_choice - 1) * 3 + 1],
+		    print_item (list, items[scroll + max_choice - 1]->name,
 				status[scroll + max_choice - 1],
 				max_choice - 1, TRUE);
 		    wnoutrefresh (list);
@@ -287,11 +288,11 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 	    }
 	    if (i != choice) {
 		/* De-highlight current item */
-		print_item (list, items[(scroll + choice) * 3 + 1],
+		print_item (list, items[scroll + choice]->name,
 			    status[scroll + choice], choice, FALSE);
 		/* Highlight new item */
 		choice = i;
-		print_item (list, items[(scroll + choice) * 3 + 1],
+		print_item (list, items[scroll + choice]->name,
 			    status[scroll + choice], choice, TRUE);
 		wnoutrefresh (list);
 		wrefresh (dialog);
@@ -330,7 +331,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 			    status[i] = 0;
 			status[scroll + choice] = 1;
 			for (i = 0; i < max_choice; i++)
-			    print_item (list, items[(scroll + i) * 3 + 1],
+			    print_item (list, items[scroll + i]->name,
 					status[scroll + i], i, i == choice);
 		    }
 		}
@@ -338,14 +339,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 		wrefresh (dialog);
             
 		for (i = 0; i < item_no; i++) {
-		    if (status[i]) {
-			if (flag == FLAG_CHECK) {
-			    fprintf (stderr, "\"%s\" ", items[i * 3]);
-			} else {
-			    fprintf (stderr, "%s", items[i * 3]);
-			}
-
-		    }
+			items[i]->selected = status[i];
 		}
             }
 	    delwin (dialog);
diff --git a/scripts/lxdialog/colors.h b/scripts/config/colors.h
similarity index 100%
rename from scripts/lxdialog/colors.h
rename to scripts/config/colors.h
diff --git a/scripts/config/conf.c b/scripts/config/conf.c
new file mode 100644
index 000000000..884175e54
--- /dev/null
+++ b/scripts/config/conf.c
@@ -0,0 +1,566 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <sys/stat.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+static void conf(struct menu *menu);
+static void check_conf(struct menu *menu);
+
+enum {
+	ask_all,
+	ask_new,
+	ask_silent,
+	set_default,
+	set_yes,
+	set_mod,
+	set_no,
+	set_random
+} input_mode = ask_all;
+
+static int indent = 1;
+static int valid_stdin = 1;
+static int conf_cnt;
+static char line[128];
+static struct menu *rootEntry;
+
+static char nohelp_text[] = "Sorry, no help available for this option yet.\n";
+
+#if 0
+static void printc(int ch)
+{
+	static int sep = 0;
+
+	if (!sep) {
+		putchar('[');
+		sep = 1;
+	} else if (ch)
+		putchar('/');
+	if (!ch) {
+		putchar(']');
+		putchar(' ');
+		sep = 0;
+	} else
+		putchar(ch);
+}
+#endif
+
+static void printo(const char *o)
+{
+	static int sep = 0;
+
+	if (!sep) {
+		putchar('(');
+		sep = 1;
+	} else if (o) {
+		putchar(',');
+		putchar(' ');
+	}
+	if (!o) {
+		putchar(')');
+		putchar(' ');
+		sep = 0;
+	} else
+		printf("%s", o);
+}
+
+static void strip(char *str)
+{
+	char *p = str;
+	int l;
+
+	while ((isspace((int)*p)))
+		p++;
+	l = strlen(p);
+	if (p != str)
+		memmove(str, p, l + 1);
+	if (!l)
+		return;
+	p = str + l - 1;
+	while ((isspace((int)*p)))
+		*p-- = 0;
+}
+
+static void conf_askvalue(struct symbol *sym, const char *def)
+{
+	enum symbol_type type = sym_get_type(sym);
+	tristate val;
+
+	if (!sym_has_value(sym))
+		printf("(NEW) ");
+
+	line[0] = '\n';
+	line[1] = 0;
+
+	switch (input_mode) {
+	case ask_new:
+	case ask_silent:
+		if (sym_has_value(sym)) {
+			printf("%s\n", def);
+			return;
+		}
+		if (!valid_stdin && input_mode == ask_silent) {
+			printf("aborted!\n\n");
+			printf("Console input/output is redirected. ");
+			printf("Run 'make oldconfig' to update configuration.\n\n");
+			exit(1);
+		}
+	case ask_all:
+		fflush(stdout);
+		fgets(line, 128, stdin);
+		return;
+	case set_default:
+		printf("%s\n", def);
+		return;
+	default:
+		break;
+	}
+
+	switch (type) {
+	case S_INT:
+	case S_HEX:
+	case S_STRING:
+		printf("%s\n", def);
+		return;
+	default:
+		;
+	}
+	switch (input_mode) {
+	case set_yes:
+		if (sym_tristate_within_range(sym, yes)) {
+			line[0] = 'y';
+			line[1] = '\n';
+			line[2] = 0;
+			break;
+		}
+	case set_mod:
+		if (type == S_TRISTATE) {
+			if (sym_tristate_within_range(sym, mod)) {
+				line[0] = 'm';
+				line[1] = '\n';
+				line[2] = 0;
+				break;
+			}
+		} else {
+			if (sym_tristate_within_range(sym, yes)) {
+				line[0] = 'y';
+				line[1] = '\n';
+				line[2] = 0;
+				break;
+			}
+		}
+	case set_no:
+		if (sym_tristate_within_range(sym, no)) {
+			line[0] = 'n';
+			line[1] = '\n';
+			line[2] = 0;
+			break;
+		}
+	case set_random:
+		do {
+			val = (tristate)(random() % 3);
+		} while (!sym_tristate_within_range(sym, val));
+		switch (val) {
+		case no: line[0] = 'n'; break;
+		case mod: line[0] = 'm'; break;
+		case yes: line[0] = 'y'; break;
+		}
+		line[1] = '\n';
+		line[2] = 0;
+		break;
+	default:
+		break;
+	}
+	printf("%s", line);
+}
+
+int conf_string(struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	const char *def, *help;
+
+	while (1) {
+		printf("%*s%s ", indent - 1, "", menu->prompt->text);
+		printf("(%s) ", sym->name);
+		def = sym_get_string_value(sym);
+		if (sym_get_string_value(sym))
+			printf("[%s] ", def);
+		conf_askvalue(sym, def);
+		switch (line[0]) {
+		case '\n':
+			break;
+		case '?':
+			/* print help */
+			if (line[1] == 0) {
+				help = nohelp_text;
+				if (menu->sym->help)
+					help = menu->sym->help;
+				printf("\n%s\n", menu->sym->help);
+				def = NULL;
+				break;
+			}
+		default:
+			line[strlen(line)-1] = 0;
+			def = line;
+		}
+		if (def && sym_set_string_value(sym, def))
+			return 0;
+	}
+}
+
+static int conf_sym(struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	int type;
+	tristate oldval, newval;
+	const char *help;
+
+	while (1) {
+		printf("%*s%s ", indent - 1, "", menu->prompt->text);
+		if (sym->name)
+			printf("(%s) ", sym->name);
+		type = sym_get_type(sym);
+		putchar('[');
+		oldval = sym_get_tristate_value(sym);
+		switch (oldval) {
+		case no:
+			putchar('N');
+			break;
+		case mod:
+			putchar('M');
+			break;
+		case yes:
+			putchar('Y');
+			break;
+		}
+		if (oldval != no && sym_tristate_within_range(sym, no))
+			printf("/n");
+		if (oldval != mod && sym_tristate_within_range(sym, mod))
+			printf("/m");
+		if (oldval != yes && sym_tristate_within_range(sym, yes))
+			printf("/y");
+		if (sym->help)
+			printf("/?");
+		printf("] ");
+		conf_askvalue(sym, sym_get_string_value(sym));
+		strip(line);
+
+		switch (line[0]) {
+		case 'n':
+		case 'N':
+			newval = no;
+			if (!line[1] || !strcmp(&line[1], "o"))
+				break;
+			continue;
+		case 'm':
+		case 'M':
+			newval = mod;
+			if (!line[1])
+				break;
+			continue;
+		case 'y':
+		case 'Y':
+			newval = yes;
+			if (!line[1] || !strcmp(&line[1], "es"))
+				break;
+			continue;
+		case 0:
+			newval = oldval;
+			break;
+		case '?':
+			goto help;
+		default:
+			continue;
+		}
+		if (sym_set_tristate_value(sym, newval))
+			return 0;
+help:
+		help = nohelp_text;
+		if (sym->help)
+			help = sym->help;
+		printf("\n%s\n", help);
+	}
+}
+
+static int conf_choice(struct menu *menu)
+{
+	struct symbol *sym, *def_sym;
+	struct menu *cmenu, *def_menu;
+	const char *help;
+	int type, len;
+	bool is_new;
+
+	sym = menu->sym;
+	type = sym_get_type(sym);
+	is_new = !sym_has_value(sym);
+	if (sym_is_changable(sym)) {
+		conf_sym(menu);
+		sym_calc_value(sym);
+		switch (sym_get_tristate_value(sym)) {
+		case no:
+			return 1;
+		case mod:
+			return 0;
+		case yes:
+			break;
+		}
+	} else {
+		sym->def = sym->curr;
+		if (S_TRI(sym->curr) == mod) {
+			printf("%*s%s\n", indent - 1, "", menu_get_prompt(menu));
+			return 0;
+		}
+	}
+
+	while (1) {
+		printf("%*s%s ", indent - 1, "", menu_get_prompt(menu));
+		def_sym = sym_get_choice_value(sym);
+		def_menu = NULL;
+		for (cmenu = menu->list; cmenu; cmenu = cmenu->next) {
+			if (!menu_is_visible(cmenu))
+				continue;
+			printo(menu_get_prompt(cmenu));
+			if (cmenu->sym == def_sym)
+				def_menu = cmenu;
+		}
+		printo(NULL);
+		if (def_menu)
+			printf("[%s] ", menu_get_prompt(def_menu));
+		else {
+			printf("\n");
+			return 1;
+		}
+		switch (input_mode) {
+		case ask_new:
+		case ask_silent:
+		case ask_all:
+			conf_askvalue(sym, menu_get_prompt(def_menu));
+			strip(line);
+			break;
+		default:
+			line[0] = 0;
+			printf("\n");
+		}
+		if (line[0] == '?' && !line[1]) {
+			help = nohelp_text;
+			if (menu->sym->help)
+				help = menu->sym->help;
+			printf("\n%s\n", help);
+			continue;
+		}
+		if (line[0]) {
+			len = strlen(line);
+			line[len] = 0;
+
+			def_menu = NULL;
+			for (cmenu = menu->list; cmenu; cmenu = cmenu->next) {
+				if (!cmenu->sym || !menu_is_visible(cmenu))
+					continue;
+				if (!strncasecmp(line, menu_get_prompt(cmenu), len)) {
+					def_menu = cmenu;
+					break;
+				}
+			}
+		}
+		if (def_menu) {
+			sym_set_choice_value(sym, def_menu->sym);
+			if (def_menu->list) {
+				indent += 2;
+				conf(def_menu->list);
+				indent -= 2;
+			}
+			return 1;
+		}
+	}
+}
+
+static void conf(struct menu *menu)
+{
+	struct symbol *sym;
+	struct property *prop;
+	struct menu *child;
+
+	if (!menu_is_visible(menu))
+		return;
+
+	sym = menu->sym;
+	prop = menu->prompt;
+	if (prop) {
+		const char *prompt;
+
+		switch (prop->type) {
+		case P_MENU:
+			if (input_mode == ask_silent && rootEntry != menu) {
+				check_conf(menu);
+				return;
+			}
+		case P_COMMENT:
+			prompt = menu_get_prompt(menu);
+			if (prompt)
+				printf("%*c\n%*c %s\n%*c\n",
+					indent, '*',
+					indent, '*', prompt,
+					indent, '*');
+		default:
+			;
+		}
+	}
+
+	if (!sym)
+		goto conf_childs;
+
+	if (sym_is_choice(sym)) {
+		conf_choice(menu);
+		if (S_TRI(sym->curr) != mod)
+			return;
+		goto conf_childs;
+	}
+
+	switch (sym->type) {
+	case S_INT:
+	case S_HEX:
+	case S_STRING:
+		conf_string(menu);
+		break;
+	default:
+		conf_sym(menu);
+		break;
+	}
+
+conf_childs:
+	if (sym)
+		indent += 2;
+	for (child = menu->list; child; child = child->next)
+		conf(child);
+	if (sym)
+		indent -= 2;
+}
+
+static void check_conf(struct menu *menu)
+{
+	struct symbol *sym;
+	struct menu *child;
+
+	if (!menu_is_visible(menu))
+		return;
+
+	sym = menu->sym;
+	if (!sym)
+		goto conf_childs;
+
+	if (sym_is_choice(sym)) {
+		if (!sym_has_value(sym)) {
+			if (!conf_cnt++)
+				printf("*\n* Restart config...\n*\n");
+			rootEntry = menu_get_parent_menu(menu);
+			conf(rootEntry);
+		}
+		if (sym_get_tristate_value(sym) != mod)
+			return;
+		goto conf_childs;
+	}
+
+	if (!sym_has_value(sym)) {
+		if (!conf_cnt++)
+			printf("*\n* Restart config...\n*\n");
+		rootEntry = menu_get_parent_menu(menu);
+		conf(rootEntry);
+	}
+
+conf_childs:
+	for (child = menu->list; child; child = child->next)
+		check_conf(child);
+}
+
+int main(int ac, char **av)
+{
+	const char *name;
+	struct stat tmpstat;
+
+	if (ac > 1 && av[1][0] == '-') {
+		switch (av[1][1]) {
+		case 'o':
+			input_mode = ask_new;
+			break;
+		case 's':
+			input_mode = ask_silent;
+			valid_stdin = isatty(0) && isatty(1) && isatty(2);
+			break;
+		case 'd':
+			input_mode = set_default;
+			break;
+		case 'n':
+			input_mode = set_no;
+			break;
+		case 'm':
+			input_mode = set_mod;
+			break;
+		case 'y':
+			input_mode = set_yes;
+			break;
+		case 'r':
+			input_mode = set_random;
+			srandom(time(NULL));
+			break;
+		case 'h':
+		case '?':
+			printf("%s [-o|-s] config\n", av[0]);
+			exit(0);
+		}
+		name = av[2];
+	} else
+		name = av[1];
+	conf_parse(name);
+	//zconfdump(stdout);
+	switch (input_mode) {
+	case set_default:
+		name = conf_get_default_confname();
+		if (conf_read(name)) {
+			printf("***\n"
+				"*** Can't find default configuration \"%s\"!\n"
+				"***\n", name);
+			exit(1);
+		}
+		break;
+	case ask_silent:
+		if (stat(".config", &tmpstat)) {
+			printf("***\n"
+				"*** You have not yet configured BusyBox!\n"
+				"***\n"
+				"*** Please run some configurator (e.g. \"make oldconfig\"\n"
+				"*** or \"make menuconfig\").\n"
+				"***\n");
+			exit(1);
+		}
+	case ask_all:
+	case ask_new:
+		conf_read(NULL);
+		break;
+	default:
+		break;
+	}
+
+	if (input_mode != ask_silent) {
+		rootEntry = &rootmenu;
+		conf(&rootmenu);
+		if (input_mode == ask_all) {
+			input_mode = ask_silent;
+			valid_stdin = 1;
+		}
+	}
+	do {
+		conf_cnt = 0;
+		check_conf(&rootmenu);
+	} while (conf_cnt);
+	conf_write(NULL);
+	return 0;
+}
diff --git a/scripts/config/confdata.c b/scripts/config/confdata.c
new file mode 100644
index 000000000..44835bbfe
--- /dev/null
+++ b/scripts/config/confdata.c
@@ -0,0 +1,371 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ *
+ * Allow 'n' as a symbol value.
+ * 2002-11-05 Petr Baudis <pasky@ucw.cz>
+ */
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+const char conf_def_filename[] = ".config";
+
+const char conf_defname[] = "extra/Configs/Config.$TARGET_ARCH.default";
+
+const char *conf_confnames[] = {
+	".config",
+	conf_defname,
+	NULL,
+};
+
+static char *conf_expand_value(const char *in)
+{
+	struct symbol *sym;
+	const char *src;
+	static char res_value[SYMBOL_MAXLENGTH];
+	char *dst, name[SYMBOL_MAXLENGTH];
+
+	res_value[0] = 0;
+	dst = name;
+	while ((src = strchr(in, '$'))) {
+		strncat(res_value, in, src - in);
+		src++;
+		dst = name;
+		while (isalnum((int)*src) || *src == '_')
+			*dst++ = *src++;
+		*dst = 0;
+		sym = sym_lookup(name, 0);
+		sym_calc_value(sym);
+		strcat(res_value, sym_get_string_value(sym));
+		in = src;
+	}
+	strcat(res_value, in);
+
+	return res_value;
+}
+
+char *conf_get_default_confname(void)
+{
+	return conf_expand_value(conf_defname);
+}
+
+int conf_read(const char *name)
+{
+	FILE *in = NULL;
+	char line[1024];
+	char *p, *p2;
+	int lineno = 0;
+	struct symbol *sym;
+	struct property *prop;
+	struct expr *e;
+	int i;
+
+	if (name) {
+		in = fopen(name, "r");
+	} else {
+		const char **names = conf_confnames;
+		while ((name = *names++)) {
+			name = conf_expand_value(name);
+			in = fopen(name, "r");
+			if (in) {
+				printf("#\n"
+				       "# using defaults found in %s\n"
+				       "#\n", name);
+				break;
+			}
+		}
+	}
+
+	if (!in)
+		return 1;
+
+	for_all_symbols(i, sym) {
+		sym->flags |= SYMBOL_NEW | SYMBOL_CHANGED;
+		sym->flags &= ~SYMBOL_VALID;
+		switch (sym->type) {
+		case S_INT:
+		case S_HEX:
+		case S_STRING:
+			if (S_VAL(sym->def))
+				free(S_VAL(sym->def));
+		default:
+			S_VAL(sym->def) = NULL;
+			S_TRI(sym->def) = no;
+			;
+		}
+	}
+
+	while (fgets(line, sizeof(line), in)) {
+		lineno++;
+		switch (line[0]) {
+		case '\n':
+			break;
+		case ' ':
+			break;
+		case '#':
+			p = strchr(line, ' ');
+			if (!p)
+				continue;
+			*p++ = 0;
+			p = strchr(p, ' ');
+			if (!p)
+				continue;
+			*p++ = 0;
+			if (strncmp(p, "is not set", 10))
+				continue;
+			sym = sym_lookup(line+2, 0);
+			switch (sym->type) {
+			case S_BOOLEAN:
+			case S_TRISTATE:
+				sym->def = symbol_no.curr;
+				sym->flags &= ~SYMBOL_NEW;
+				break;
+			default:
+				;
+			}
+			break;
+		case 'A' ... 'Z':
+			p = strchr(line, '=');
+			if (!p)
+				continue;
+			*p++ = 0;
+			p2 = strchr(p, '\n');
+			if (p2)
+				*p2 = 0;
+			sym = sym_find(line);
+			if (!sym) {
+				fprintf(stderr, "%s:%d: trying to assign nonexistent symbol %s\n", name, lineno, line);
+				break;
+			}
+			switch (sym->type) {
+  			case S_TRISTATE:
+				if (p[0] == 'm') {
+					S_TRI(sym->def) = mod;
+					sym->flags &= ~SYMBOL_NEW;
+					break;
+				}
+			case S_BOOLEAN:
+				if (p[0] == 'y') {
+					S_TRI(sym->def) = yes;
+					sym->flags &= ~SYMBOL_NEW;
+					break;
+				}
+				if (p[0] == 'n') {
+					S_TRI(sym->def) = no;
+					sym->flags &= ~SYMBOL_NEW;
+					break;
+				}
+  				break;
+			case S_STRING:
+				if (*p++ != '"')
+					break;
+				for (p2 = p; (p2 = strpbrk(p2, "\"\\")); p2++) {
+					if (*p2 == '"') {
+						*p2 = 0;
+						break;
+					}
+					memmove(p2, p2 + 1, strlen(p2));
+				}
+			case S_INT:
+			case S_HEX:
+				if (sym_string_valid(sym, p)) {
+					S_VAL(sym->def) = strdup(p);
+					sym->flags &= ~SYMBOL_NEW;
+				} else
+					fprintf(stderr, "%s:%d:symbol value '%s' invalid for %s\n", name, lineno, p, sym->name);
+				break;
+			default:
+				;
+			}
+			if (sym_is_choice_value(sym)) {
+				prop = sym_get_choice_prop(sym);
+				switch (S_TRI(sym->def)) {
+				case mod:
+					if (S_TRI(prop->def->def) == yes)
+						/* warn? */;
+					break;
+				case yes:
+					if (S_TRI(prop->def->def) != no)
+						/* warn? */;
+					S_VAL(prop->def->def) = sym;
+					break;
+				case no:
+					break;
+				}
+				S_TRI(prop->def->def) = S_TRI(sym->def);
+			}
+			break;
+		default:
+			continue;
+		}
+	}
+	fclose(in);
+
+	for_all_symbols(i, sym) {
+		if (!sym_is_choice(sym))
+			continue;
+		prop = sym_get_choice_prop(sym);
+		for (e = prop->dep; e; e = e->left.expr)
+			sym->flags |= e->right.sym->flags & SYMBOL_NEW;
+		sym->flags &= ~SYMBOL_NEW;
+	}
+
+	sym_change_count = 1;
+
+	return 0;
+}
+
+int conf_write(const char *name)
+{
+	FILE *out, *out_h;
+	struct symbol *sym;
+	struct menu *menu;
+	char oldname[128];
+	int type, l;
+	const char *str;
+
+	out = fopen(".tmpconfig", "w");
+	if (!out)
+		return 1;
+	out_h = fopen(".tmpconfig.h", "w");
+	if (!out_h)
+		return 1;
+	fprintf(out, "#\n"
+		     "# Automatically generated make config: don't edit\n"
+		     "#\n");
+	fprintf(out_h, "/*\n"
+		       " * Automatically generated header file: don't edit\n"
+		       " */\n\n"
+		       "#define AUTOCONF_INCLUDED\n\n"
+		       "/* Version Number */\n"
+		       "#define BB_VER \"%s\"\n"
+		       "#define BB_BT \"%s\"\n\n",
+		       getenv("VERSION"),
+		       getenv("BUILDTIME")
+       );
+
+	if (!sym_change_count)
+		sym_clear_all_valid();
+
+	menu = rootmenu.list;
+	while (menu) {
+		sym = menu->sym;
+		if (!sym) {
+			if (!menu_is_visible(menu))
+				goto next;
+			str = menu_get_prompt(menu);
+			fprintf(out, "\n"
+				     "#\n"
+				     "# %s\n"
+				     "#\n", str);
+			fprintf(out_h, "\n"
+				       "/*\n"
+				       " * %s\n"
+				       " */\n", str);
+		} else if (!(sym->flags & SYMBOL_CHOICE)) {
+			sym_calc_value(sym);
+			if (!(sym->flags & SYMBOL_WRITE))
+				goto next;
+			sym->flags &= ~SYMBOL_WRITE;
+			type = sym->type;
+			if (type == S_TRISTATE) {
+				sym_calc_value(modules_sym);
+				if (S_TRI(modules_sym->curr) == no)
+					type = S_BOOLEAN;
+			}
+			switch (type) {
+			case S_BOOLEAN:
+			case S_TRISTATE:
+				switch (sym_get_tristate_value(sym)) {
+				case no:
+					fprintf(out, "# %s is not set\n", sym->name);
+					fprintf(out_h, "#undef %s\n", sym->name);
+					break;
+				case mod:
+#if 0
+					fprintf(out, "%s=m\n", sym->name);
+					fprintf(out_h, "#define __%s__MODULE 1\n", sym->name);
+#endif
+					break;
+				case yes:
+					fprintf(out, "%s=y\n", sym->name);
+					fprintf(out_h, "#define %s 1\n", sym->name);
+					break;
+				}
+				break;
+			case S_STRING:
+				// fix me
+				str = sym_get_string_value(sym);
+				fprintf(out, "%s=\"", sym->name);
+				fprintf(out_h, "#define %s \"", sym->name);
+				do {
+					l = strcspn(str, "\"\\");
+					if (l) {
+						fwrite(str, l, 1, out);
+						fwrite(str, l, 1, out_h);
+					}
+					str += l;
+					while (*str == '\\' || *str == '"') {
+						fprintf(out, "\\%c", *str);
+						fprintf(out_h, "\\%c", *str);
+						str++;
+					}
+				} while (*str);
+				fputs("\"\n", out);
+				fputs("\"\n", out_h);
+				break;
+			case S_HEX:
+				str = sym_get_string_value(sym);
+				if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
+					fprintf(out, "%s=%s\n", sym->name, str);
+					fprintf(out_h, "#define %s 0x%s\n", sym->name, str);
+					break;
+				}
+			case S_INT:
+				str = sym_get_string_value(sym);
+				fprintf(out, "%s=%s\n", sym->name, str);
+				fprintf(out_h, "#define %s %s\n", sym->name, str);
+				break;
+			}
+		}
+
+	next:
+		if (menu->list) {
+			menu = menu->list;
+			continue;
+		}
+		if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+	fclose(out);
+	fclose(out_h);
+
+	if (!name) {
+		rename(".tmpconfig.h", "include/config.h");
+		name = conf_def_filename;
+		file_write_dep(NULL);
+	} else
+		unlink(".tmpconfig.h");
+
+	sprintf(oldname, "%s.old", name);
+	rename(name, oldname);
+	if (rename(".tmpconfig", name))
+		return 1;
+
+	sym_change_count = 0;
+
+	return 0;
+}
diff --git a/scripts/lxdialog/dialog.h b/scripts/config/dialog.h
similarity index 93%
rename from scripts/lxdialog/dialog.h
rename to scripts/config/dialog.h
index 0e30d00d0..8116cee36 100644
--- a/scripts/lxdialog/dialog.h
+++ b/scripts/config/dialog.h
@@ -26,6 +26,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+#ifdef CURSES_LOC
 #include CURSES_LOC
 
 /*
@@ -125,29 +126,35 @@
  * Global variables
  */
 extern bool use_colors;
-extern bool use_shadow;
 
 extern chtype attributes[];
+#endif
+
+extern char *backtitle;
 
-extern const char *backtitle;
+struct dialog_list_item {
+	char *name;
+	int namelen;
+	char *tag;
+	int selected; /* Set to 1 by dialog_*() function. */
+};
 
 /*
  * Function prototypes
  */
-extern void create_rc (const char *filename);
-extern int parse_rc (void);
-
 
 void init_dialog (void);
 void end_dialog (void);
-void attr_clear (WINDOW * win, int height, int width, chtype attr);
 void dialog_clear (void);
+#ifdef CURSES_LOC
+void attr_clear (WINDOW * win, int height, int width, chtype attr);
 void color_setup (void);
 void print_autowrap (WINDOW * win, const char *prompt, int width, int y, int x);
 void print_button (WINDOW * win, const char *label, int y, int x, int selected);
 void draw_box (WINDOW * win, int y, int x, int height, int width, chtype box,
 		chtype border);
 void draw_shadow (WINDOW * win, int y, int x, int height, int width);
+#endif
 
 int first_alpha (const char *string, const char *exempt);
 int dialog_yesno (const char *title, const char *prompt, int height, int width);
@@ -156,14 +163,17 @@ int dialog_msgbox (const char *title, const char *prompt, int height,
 int dialog_textbox (const char *title, const char *file, int height, int width);
 int dialog_menu (const char *title, const char *prompt, int height, int width,
 		int menu_height, const char *choice, int item_no, 
-		const char * const * items);
+		struct dialog_list_item ** items);
 int dialog_checklist (const char *title, const char *prompt, int height,
 		int width, int list_height, int item_no,
-		const char * const * items, int flag);
+		struct dialog_list_item ** items, int flag);
 extern unsigned char dialog_input_result[];
 int dialog_inputbox (const char *title, const char *prompt, int height,
 		int width, const char *init);
 
+struct dialog_list_item *first_sel_item(int item_no,
+		struct dialog_list_item ** items);
+
 /*
  * This is the base for fictitious keys, which activate
  * the buttons.
@@ -173,7 +183,9 @@ int dialog_inputbox (const char *title, const char *prompt, int height,
  *   -- the lowercase are used to signal mouse-enter events (M_EVENT + 'o')
  *   -- uppercase chars are used to invoke the button (M_EVENT + 'O')
  */
+#ifdef CURSES_LOC
 #define M_EVENT (KEY_MAX+1)
+#endif
 
 
 /*
diff --git a/scripts/config/expr.c b/scripts/config/expr.c
new file mode 100644
index 000000000..d1af2a581
--- /dev/null
+++ b/scripts/config/expr.c
@@ -0,0 +1,1054 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+struct expr *expr_alloc_symbol(struct symbol *sym)
+{
+	struct expr *e = malloc(sizeof(*e));
+	memset(e, 0, sizeof(*e));
+	e->type = E_SYMBOL;
+	e->left.sym = sym;
+	return e;
+}
+
+struct expr *expr_alloc_one(enum expr_type type, struct expr *ce)
+{
+	struct expr *e = malloc(sizeof(*e));
+	memset(e, 0, sizeof(*e));
+	e->type = type;
+	e->left.expr = ce;
+	return e;
+}
+
+struct expr *expr_alloc_two(enum expr_type type, struct expr *e1, struct expr *e2)
+{
+	struct expr *e = malloc(sizeof(*e));
+	memset(e, 0, sizeof(*e));
+	e->type = type;
+	e->left.expr = e1;
+	e->right.expr = e2;
+	return e;
+}
+
+struct expr *expr_alloc_comp(enum expr_type type, struct symbol *s1, struct symbol *s2)
+{
+	struct expr *e = malloc(sizeof(*e));
+	memset(e, 0, sizeof(*e));
+	e->type = type;
+	e->left.sym = s1;
+	e->right.sym = s2;
+	return e;
+}
+
+struct expr *expr_alloc_and(struct expr *e1, struct expr *e2)
+{
+	if (!e1)
+		return e2;
+	return e2 ? expr_alloc_two(E_AND, e1, e2) : e1;
+}
+
+struct expr *expr_copy(struct expr *org)
+{
+	struct expr *e;
+
+	if (!org)
+		return NULL;
+
+	e = malloc(sizeof(*org));
+	memcpy(e, org, sizeof(*org));
+	switch (org->type) {
+	case E_SYMBOL:
+		e->left = org->left;
+		break;
+	case E_NOT:
+		e->left.expr = expr_copy(org->left.expr);
+		break;
+	case E_EQUAL:
+	case E_UNEQUAL:
+		e->left.sym = org->left.sym;
+		e->right.sym = org->right.sym;
+		break;
+	case E_AND:
+	case E_OR:
+	case E_CHOICE:
+		e->left.expr = expr_copy(org->left.expr);
+		e->right.expr = expr_copy(org->right.expr);
+		break;
+	default:
+		printf("can't copy type %d\n", e->type);
+		free(e);
+		e = NULL;
+		break;
+	}
+
+	return e;
+}
+
+void expr_free(struct expr *e)
+{
+	if (!e)
+		return;
+
+	switch (e->type) {
+	case E_SYMBOL:
+		break;
+	case E_NOT:
+		expr_free(e->left.expr);
+		return;
+	case E_EQUAL:
+	case E_UNEQUAL:
+		break;
+	case E_OR:
+	case E_AND:
+		expr_free(e->left.expr);
+		expr_free(e->right.expr);
+		break;
+	default:
+		printf("how to free type %d?\n", e->type);
+		break;
+	}
+	free(e);
+}
+
+static int trans_count;
+
+#define e1 (*ep1)
+#define e2 (*ep2)
+
+static void __expr_eliminate_eq(enum expr_type type, struct expr **ep1, struct expr **ep2)
+{
+	if (e1->type == type) {
+		__expr_eliminate_eq(type, &e1->left.expr, &e2);
+		__expr_eliminate_eq(type, &e1->right.expr, &e2);
+		return;
+	}
+	if (e2->type == type) {
+		__expr_eliminate_eq(type, &e1, &e2->left.expr);
+		__expr_eliminate_eq(type, &e1, &e2->right.expr);
+		return;
+	}
+	if (e1->type == E_SYMBOL && e2->type == E_SYMBOL &&
+	    e1->left.sym == e2->left.sym && (e1->left.sym->flags & (SYMBOL_YES|SYMBOL_NO)))
+		return;
+	if (!expr_eq(e1, e2))
+		return;
+	trans_count++;
+	expr_free(e1); expr_free(e2);
+	switch (type) {
+	case E_OR:
+		e1 = expr_alloc_symbol(&symbol_no);
+		e2 = expr_alloc_symbol(&symbol_no);
+		break;
+	case E_AND:
+		e1 = expr_alloc_symbol(&symbol_yes);
+		e2 = expr_alloc_symbol(&symbol_yes);
+		break;
+	default:
+		;
+	}
+}
+
+void expr_eliminate_eq(struct expr **ep1, struct expr **ep2)
+{
+	if (!e1 || !e2 || e1->type != e2->type)
+		return;
+	__expr_eliminate_eq(e1->type, ep1, ep2);
+	e1 = expr_eliminate_yn(e1);
+	e2 = expr_eliminate_yn(e2);
+}
+
+#undef e1
+#undef e2
+
+int expr_eq(struct expr *e1, struct expr *e2)
+{
+	int res, old_count;
+
+	if (e1->type != e2->type)
+		return 0;
+	switch (e1->type) {
+	case E_EQUAL:
+	case E_UNEQUAL:
+		return e1->left.sym == e2->left.sym && e1->right.sym == e2->right.sym;
+	case E_SYMBOL:
+		return e1->left.sym == e2->left.sym;
+	case E_NOT:
+		return expr_eq(e1->left.expr, e2->left.expr);
+	case E_AND:
+	case E_OR:
+		e1 = expr_copy(e1);
+		e2 = expr_copy(e2);
+		old_count = trans_count;
+		expr_eliminate_eq(&e1, &e2);
+		res = (e1->type == E_SYMBOL && e2->type == E_SYMBOL &&
+		       e1->left.sym == e2->left.sym);
+		expr_free(e1);
+		expr_free(e2);
+		trans_count = old_count;
+		return res;
+	case E_CHOICE:
+	case E_NONE:
+		/* panic */;
+	}
+
+	print_expr(0, e1, 0);
+	printf(" = ");
+	print_expr(0, e2, 0);
+	printf(" ?\n");
+
+	return 0;
+}
+
+struct expr *expr_eliminate_yn(struct expr *e)
+{
+	struct expr *tmp;
+
+	if (e) switch (e->type) {
+	case E_AND:
+		e->left.expr = expr_eliminate_yn(e->left.expr);
+		e->right.expr = expr_eliminate_yn(e->right.expr);
+		if (e->left.expr->type == E_SYMBOL) {
+			if (e->left.expr->left.sym == &symbol_no) {
+				expr_free(e->left.expr);
+				expr_free(e->right.expr);
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_no;
+				e->right.expr = NULL;
+				return e;
+			} else if (e->left.expr->left.sym == &symbol_yes) {
+				free(e->left.expr);
+				tmp = e->right.expr;
+				*e = *(e->right.expr);
+				free(tmp);
+				return e;
+			}
+		}
+		if (e->right.expr->type == E_SYMBOL) {
+			if (e->right.expr->left.sym == &symbol_no) {
+				expr_free(e->left.expr);
+				expr_free(e->right.expr);
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_no;
+				e->right.expr = NULL;
+				return e;
+			} else if (e->right.expr->left.sym == &symbol_yes) {
+				free(e->right.expr);
+				tmp = e->left.expr;
+				*e = *(e->left.expr);
+				free(tmp);
+				return e;
+			}
+		}
+		break;
+	case E_OR:
+		e->left.expr = expr_eliminate_yn(e->left.expr);
+		e->right.expr = expr_eliminate_yn(e->right.expr);
+		if (e->left.expr->type == E_SYMBOL) {
+			if (e->left.expr->left.sym == &symbol_no) {
+				free(e->left.expr);
+				tmp = e->right.expr;
+				*e = *(e->right.expr);
+				free(tmp);
+				return e;
+			} else if (e->left.expr->left.sym == &symbol_yes) {
+				expr_free(e->left.expr);
+				expr_free(e->right.expr);
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_yes;
+				e->right.expr = NULL;
+				return e;
+			}
+		}
+		if (e->right.expr->type == E_SYMBOL) {
+			if (e->right.expr->left.sym == &symbol_no) {
+				free(e->right.expr);
+				tmp = e->left.expr;
+				*e = *(e->left.expr);
+				free(tmp);
+				return e;
+			} else if (e->right.expr->left.sym == &symbol_yes) {
+				expr_free(e->left.expr);
+				expr_free(e->right.expr);
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_yes;
+				e->right.expr = NULL;
+				return e;
+			}
+		}
+		break;
+	default:
+		;
+	}
+	return e;
+}
+
+/*
+ * bool FOO!=n => FOO
+ */
+struct expr *expr_trans_bool(struct expr *e)
+{
+	if (!e)
+		return NULL;
+	switch (e->type) {
+	case E_AND:
+	case E_OR:
+	case E_NOT:
+		e->left.expr = expr_trans_bool(e->left.expr);
+		e->right.expr = expr_trans_bool(e->right.expr);
+		break;
+	case E_UNEQUAL:
+		// FOO!=n -> FOO
+		if (e->left.sym->type == S_TRISTATE) {
+			if (e->right.sym == &symbol_no) {
+				e->type = E_SYMBOL;
+				e->right.sym = NULL;
+			}
+		}
+		break;
+	default:
+		;
+	}
+	return e;
+}
+
+/*
+ * e1 || e2 -> ?
+ */
+struct expr *expr_join_or(struct expr *e1, struct expr *e2)
+{
+	struct expr *tmp;
+	struct symbol *sym1, *sym2;
+
+	if (expr_eq(e1, e2))
+		return expr_copy(e1);
+	if (e1->type != E_EQUAL && e1->type != E_UNEQUAL && e1->type != E_SYMBOL && e1->type != E_NOT)
+		return NULL;
+	if (e2->type != E_EQUAL && e2->type != E_UNEQUAL && e2->type != E_SYMBOL && e2->type != E_NOT)
+		return NULL;
+	if (e1->type == E_NOT) {
+		tmp = e1->left.expr;
+		if (tmp->type != E_EQUAL && tmp->type != E_UNEQUAL && tmp->type != E_SYMBOL)
+			return NULL;
+		sym1 = tmp->left.sym;
+	} else
+		sym1 = e1->left.sym;
+	if (e2->type == E_NOT) {
+		if (e2->left.expr->type != E_SYMBOL)
+			return NULL;
+		sym2 = e2->left.expr->left.sym;
+	} else
+		sym2 = e2->left.sym;
+	if (sym1 != sym2)
+		return NULL;
+	if (sym1->type != S_BOOLEAN && sym1->type != S_TRISTATE)
+		return NULL;
+	if (sym1->type == S_TRISTATE) {
+		if (e1->type == E_EQUAL && e2->type == E_EQUAL &&
+		    ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_mod) ||
+		     (e1->right.sym == &symbol_mod && e2->right.sym == &symbol_yes))) {
+			// (a='y') || (a='m') -> (a!='n')
+			return expr_alloc_comp(E_UNEQUAL, sym1, &symbol_no);
+		}
+		if (e1->type == E_EQUAL && e2->type == E_EQUAL &&
+		    ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_no) ||
+		     (e1->right.sym == &symbol_no && e2->right.sym == &symbol_yes))) {
+			// (a='y') || (a='n') -> (a!='m')
+			return expr_alloc_comp(E_UNEQUAL, sym1, &symbol_mod);
+		}
+		if (e1->type == E_EQUAL && e2->type == E_EQUAL &&
+		    ((e1->right.sym == &symbol_mod && e2->right.sym == &symbol_no) ||
+		     (e1->right.sym == &symbol_no && e2->right.sym == &symbol_mod))) {
+			// (a='m') || (a='n') -> (a!='y')
+			return expr_alloc_comp(E_UNEQUAL, sym1, &symbol_yes);
+		}
+	}
+	if (sym1->type == S_BOOLEAN && sym1 == sym2) {
+		if ((e1->type == E_NOT && e1->left.expr->type == E_SYMBOL && e2->type == E_SYMBOL) ||
+		    (e2->type == E_NOT && e2->left.expr->type == E_SYMBOL && e1->type == E_SYMBOL))
+			return expr_alloc_symbol(&symbol_yes);
+	}
+
+	printf("optimize ");
+	print_expr(0, e1, 0);
+	printf(" || ");
+	print_expr(0, e2, 0);
+	printf(" ?\n");
+	return NULL;
+}
+
+struct expr *expr_join_and(struct expr *e1, struct expr *e2)
+{
+	struct expr *tmp;
+	struct symbol *sym1, *sym2;
+
+	if (expr_eq(e1, e2))
+		return expr_copy(e1);
+	if (e1->type != E_EQUAL && e1->type != E_UNEQUAL && e1->type != E_SYMBOL && e1->type != E_NOT)
+		return NULL;
+	if (e2->type != E_EQUAL && e2->type != E_UNEQUAL && e2->type != E_SYMBOL && e2->type != E_NOT)
+		return NULL;
+	if (e1->type == E_NOT) {
+		tmp = e1->left.expr;
+		if (tmp->type != E_EQUAL && tmp->type != E_UNEQUAL && tmp->type != E_SYMBOL)
+			return NULL;
+		sym1 = tmp->left.sym;
+	} else
+		sym1 = e1->left.sym;
+	if (e2->type == E_NOT) {
+		if (e2->left.expr->type != E_SYMBOL)
+			return NULL;
+		sym2 = e2->left.expr->left.sym;
+	} else
+		sym2 = e2->left.sym;
+	if (sym1 != sym2)
+		return NULL;
+	if (sym1->type != S_BOOLEAN && sym1->type != S_TRISTATE)
+		return NULL;
+
+	if ((e1->type == E_SYMBOL && e2->type == E_EQUAL && e2->right.sym == &symbol_yes) ||
+	    (e2->type == E_SYMBOL && e1->type == E_EQUAL && e1->right.sym == &symbol_yes))
+		// (a) && (a='y') -> (a='y')
+		return expr_alloc_comp(E_EQUAL, sym1, &symbol_yes);
+
+	if ((e1->type == E_SYMBOL && e2->type == E_UNEQUAL && e2->right.sym == &symbol_no) ||
+	    (e2->type == E_SYMBOL && e1->type == E_UNEQUAL && e1->right.sym == &symbol_no))
+		// (a) && (a!='n') -> (a)
+		return expr_alloc_symbol(sym1);
+
+	if (sym1->type == S_TRISTATE) {
+		if (e1->type == E_EQUAL && e2->type == E_UNEQUAL) {
+			// (a='b') && (a!='c') -> 'b'='c' ? 'n' : a='b'
+			sym2 = e1->right.sym;
+			if ((e2->right.sym->flags & SYMBOL_CONST) && (sym2->flags & SYMBOL_CONST))
+				return sym2 != e2->right.sym ? expr_alloc_comp(E_EQUAL, sym1, sym2)
+							     : expr_alloc_symbol(&symbol_no);
+		}
+		if (e1->type == E_UNEQUAL && e2->type == E_EQUAL) {
+			// (a='b') && (a!='c') -> 'b'='c' ? 'n' : a='b'
+			sym2 = e2->right.sym;
+			if ((e1->right.sym->flags & SYMBOL_CONST) && (sym2->flags & SYMBOL_CONST))
+				return sym2 != e1->right.sym ? expr_alloc_comp(E_EQUAL, sym1, sym2)
+							     : expr_alloc_symbol(&symbol_no);
+		}
+		if (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&
+			   ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_no) ||
+			    (e1->right.sym == &symbol_no && e2->right.sym == &symbol_yes)))
+			// (a!='y') && (a!='n') -> (a='m')
+			return expr_alloc_comp(E_EQUAL, sym1, &symbol_mod);
+
+		if (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&
+			   ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_mod) ||
+			    (e1->right.sym == &symbol_mod && e2->right.sym == &symbol_yes)))
+			// (a!='y') && (a!='m') -> (a='n')
+			return expr_alloc_comp(E_EQUAL, sym1, &symbol_no);
+
+		if (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&
+			   ((e1->right.sym == &symbol_mod && e2->right.sym == &symbol_no) ||
+			    (e1->right.sym == &symbol_no && e2->right.sym == &symbol_mod)))
+			// (a!='m') && (a!='n') -> (a='m')
+			return expr_alloc_comp(E_EQUAL, sym1, &symbol_yes);
+
+		if ((e1->type == E_SYMBOL && e2->type == E_EQUAL && e2->right.sym == &symbol_mod) ||
+		    (e2->type == E_SYMBOL && e1->type == E_EQUAL && e1->right.sym == &symbol_mod) ||
+		    (e1->type == E_SYMBOL && e2->type == E_UNEQUAL && e2->right.sym == &symbol_yes) ||
+		    (e2->type == E_SYMBOL && e1->type == E_UNEQUAL && e1->right.sym == &symbol_yes))
+			return NULL;
+	}
+	printf("optimize ");
+	print_expr(0, e1, 0);
+	printf(" && ");
+	print_expr(0, e2, 0);
+	printf(" ?\n");
+	return NULL;
+}
+
+static void expr_eliminate_dups1(enum expr_type type, struct expr **ep1, struct expr **ep2)
+{
+#define e1 (*ep1)
+#define e2 (*ep2)
+	struct expr *tmp;
+
+	if (e1->type == type) {
+		expr_eliminate_dups1(type, &e1->left.expr, &e2);
+		expr_eliminate_dups1(type, &e1->right.expr, &e2);
+		return;
+	}
+	if (e2->type == type) {
+		expr_eliminate_dups1(type, &e1, &e2->left.expr);
+		expr_eliminate_dups1(type, &e1, &e2->right.expr);
+		return;
+	}
+	if (e1 == e2)
+		return;
+
+	switch (e1->type) {
+	case E_OR: case E_AND:
+		expr_eliminate_dups1(e1->type, &e1, &e1);
+	default:
+		;
+	}
+
+	switch (type) {
+	case E_OR:
+		tmp = expr_join_or(e1, e2);
+		if (tmp) {
+			expr_free(e1); expr_free(e2);
+			e1 = expr_alloc_symbol(&symbol_no);
+			e2 = tmp;
+			trans_count++;
+		}
+		break;
+	case E_AND:
+		tmp = expr_join_and(e1, e2);
+		if (tmp) {
+			expr_free(e1); expr_free(e2);
+			e1 = expr_alloc_symbol(&symbol_yes);
+			e2 = tmp;
+			trans_count++;
+		}
+		break;
+	default:
+		;
+	}
+#undef e1
+#undef e2
+}
+
+static void expr_eliminate_dups2(enum expr_type type, struct expr **ep1, struct expr **ep2)
+{
+#define e1 (*ep1)
+#define e2 (*ep2)
+	struct expr *tmp, *tmp1, *tmp2;
+
+	if (e1->type == type) {
+		expr_eliminate_dups2(type, &e1->left.expr, &e2);
+		expr_eliminate_dups2(type, &e1->right.expr, &e2);
+		return;
+	}
+	if (e2->type == type) {
+		expr_eliminate_dups2(type, &e1, &e2->left.expr);
+		expr_eliminate_dups2(type, &e1, &e2->right.expr);
+	}
+	if (e1 == e2)
+		return;
+
+	switch (e1->type) {
+	case E_OR:
+		expr_eliminate_dups2(e1->type, &e1, &e1);
+		// (FOO || BAR) && (!FOO && !BAR) -> n
+		tmp1 = expr_transform(expr_alloc_one(E_NOT, expr_copy(e1)));
+		tmp2 = expr_copy(e2);
+		tmp = expr_extract_eq_and(&tmp1, &tmp2);
+		if (expr_is_yes(tmp1)) {
+			expr_free(e1);
+			e1 = expr_alloc_symbol(&symbol_no);
+			trans_count++;
+		}
+		expr_free(tmp2);
+		expr_free(tmp1);
+		expr_free(tmp);
+		break;
+	case E_AND:
+		expr_eliminate_dups2(e1->type, &e1, &e1);
+		// (FOO && BAR) || (!FOO || !BAR) -> y
+		tmp1 = expr_transform(expr_alloc_one(E_NOT, expr_copy(e1)));
+		tmp2 = expr_copy(e2);
+		tmp = expr_extract_eq_or(&tmp1, &tmp2);
+		if (expr_is_no(tmp1)) {
+			expr_free(e1);
+			e1 = expr_alloc_symbol(&symbol_yes);
+			trans_count++;
+		}
+		expr_free(tmp2);
+		expr_free(tmp1);
+		expr_free(tmp);
+		break;
+	default:
+		;
+	}
+#undef e1
+#undef e2
+}
+
+struct expr *expr_eliminate_dups(struct expr *e)
+{
+	int oldcount;
+	if (!e)
+		return e;
+
+	oldcount = trans_count;
+	while (1) {
+		trans_count = 0;
+		switch (e->type) {
+		case E_OR: case E_AND:
+			expr_eliminate_dups1(e->type, &e, &e);
+			expr_eliminate_dups2(e->type, &e, &e);
+		default:
+			;
+		}
+		if (!trans_count)
+			break;
+		e = expr_eliminate_yn(e);
+	}
+	trans_count = oldcount;
+	return e;
+}
+
+struct expr *expr_transform(struct expr *e)
+{
+	struct expr *tmp;
+
+	if (!e)
+		return NULL;
+	switch (e->type) {
+	case E_EQUAL:
+	case E_UNEQUAL:
+	case E_SYMBOL:
+	case E_CHOICE:
+		break;
+	default:
+		e->left.expr = expr_transform(e->left.expr);
+		e->right.expr = expr_transform(e->right.expr);
+	}
+
+	switch (e->type) {
+	case E_EQUAL:
+		if (e->left.sym->type != S_BOOLEAN)
+			break;
+		if (e->right.sym == &symbol_no) {
+			e->type = E_NOT;
+			e->left.expr = expr_alloc_symbol(e->left.sym);
+			e->right.sym = NULL;
+			break;
+		}
+		if (e->right.sym == &symbol_mod) {
+			printf("boolean symbol %s tested for 'm'? test forced to 'n'\n", e->left.sym->name);
+			e->type = E_SYMBOL;
+			e->left.sym = &symbol_no;
+			e->right.sym = NULL;
+			break;
+		}
+		if (e->right.sym == &symbol_yes) {
+			e->type = E_SYMBOL;
+			e->right.sym = NULL;
+			break;
+		}
+		break;
+	case E_UNEQUAL:
+		if (e->left.sym->type != S_BOOLEAN)
+			break;
+		if (e->right.sym == &symbol_no) {
+			e->type = E_SYMBOL;
+			e->right.sym = NULL;
+			break;
+		}
+		if (e->right.sym == &symbol_mod) {
+			printf("boolean symbol %s tested for 'm'? test forced to 'y'\n", e->left.sym->name);
+			e->type = E_SYMBOL;
+			e->left.sym = &symbol_yes;
+			e->right.sym = NULL;
+			break;
+		}
+		if (e->right.sym == &symbol_yes) {
+			e->type = E_NOT;
+			e->left.expr = expr_alloc_symbol(e->left.sym);
+			e->right.sym = NULL;
+			break;
+		}
+		break;
+	case E_NOT:
+		switch (e->left.expr->type) {
+		case E_NOT:
+			// !!a -> a
+			tmp = e->left.expr->left.expr;
+			free(e->left.expr);
+			free(e);
+			e = tmp;
+			e = expr_transform(e);
+			break;
+		case E_EQUAL:
+		case E_UNEQUAL:
+			// !a='x' -> a!='x'
+			tmp = e->left.expr;
+			free(e);
+			e = tmp;
+			e->type = e->type == E_EQUAL ? E_UNEQUAL : E_EQUAL;
+			break;
+		case E_OR:
+			// !(a || b) -> !a && !b
+			tmp = e->left.expr;
+			e->type = E_AND;
+			e->right.expr = expr_alloc_one(E_NOT, tmp->right.expr);
+			tmp->type = E_NOT;
+			tmp->right.expr = NULL;
+			e = expr_transform(e);
+			break;
+		case E_AND:
+			// !(a && b) -> !a || !b
+			tmp = e->left.expr;
+			e->type = E_OR;
+			e->right.expr = expr_alloc_one(E_NOT, tmp->right.expr);
+			tmp->type = E_NOT;
+			tmp->right.expr = NULL;
+			e = expr_transform(e);
+			break;
+		case E_SYMBOL:
+			if (e->left.expr->left.sym == &symbol_yes) {
+				// !'y' -> 'n'
+				tmp = e->left.expr;
+				free(e);
+				e = tmp;
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_no;
+				break;
+			}
+			if (e->left.expr->left.sym == &symbol_mod) {
+				// !'m' -> 'm'
+				tmp = e->left.expr;
+				free(e);
+				e = tmp;
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_mod;
+				break;
+			}
+			if (e->left.expr->left.sym == &symbol_no) {
+				// !'n' -> 'y'
+				tmp = e->left.expr;
+				free(e);
+				e = tmp;
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_yes;
+				break;
+			}
+			break;
+		default:
+			;
+		}
+		break;
+	default:
+		;
+	}
+	return e;
+}
+
+int expr_contains_symbol(struct expr *dep, struct symbol *sym)
+{
+	if (!dep)
+		return 0;
+
+	switch (dep->type) {
+	case E_AND:
+	case E_OR:
+		return expr_contains_symbol(dep->left.expr, sym) ||
+		       expr_contains_symbol(dep->right.expr, sym);
+	case E_SYMBOL:
+		return dep->left.sym == sym;
+	case E_EQUAL:
+	case E_UNEQUAL:
+		return dep->left.sym == sym ||
+		       dep->right.sym == sym;
+	case E_NOT:
+		return expr_contains_symbol(dep->left.expr, sym);
+	default:
+		;
+	}
+	return 0;
+}
+
+bool expr_depends_symbol(struct expr *dep, struct symbol *sym)
+{
+	if (!dep)
+		return false;
+
+	switch (dep->type) {
+	case E_AND:
+		return expr_depends_symbol(dep->left.expr, sym) ||
+		       expr_depends_symbol(dep->right.expr, sym);
+	case E_SYMBOL:
+		return dep->left.sym == sym;
+	case E_EQUAL:
+		if (dep->left.sym == sym) {
+			if (dep->right.sym == &symbol_yes || dep->right.sym == &symbol_mod)
+				return true;
+		}
+		break;
+	case E_UNEQUAL:
+		if (dep->left.sym == sym) {
+			if (dep->right.sym == &symbol_no)
+				return true;
+		}
+		break;
+	default:
+		;
+	}
+ 	return false;
+}
+
+struct expr *expr_extract_eq_and(struct expr **ep1, struct expr **ep2)
+{
+	struct expr *tmp = NULL;
+	expr_extract_eq(E_AND, &tmp, ep1, ep2);
+	if (tmp) {
+		*ep1 = expr_eliminate_yn(*ep1);
+		*ep2 = expr_eliminate_yn(*ep2);
+	}
+	return tmp;
+}
+
+struct expr *expr_extract_eq_or(struct expr **ep1, struct expr **ep2)
+{
+	struct expr *tmp = NULL;
+	expr_extract_eq(E_OR, &tmp, ep1, ep2);
+	if (tmp) {
+		*ep1 = expr_eliminate_yn(*ep1);
+		*ep2 = expr_eliminate_yn(*ep2);
+	}
+	return tmp;
+}
+
+void expr_extract_eq(enum expr_type type, struct expr **ep, struct expr **ep1, struct expr **ep2)
+{
+#define e1 (*ep1)
+#define e2 (*ep2)
+	if (e1->type == type) {
+		expr_extract_eq(type, ep, &e1->left.expr, &e2);
+		expr_extract_eq(type, ep, &e1->right.expr, &e2);
+		return;
+	}
+	if (e2->type == type) {
+		expr_extract_eq(type, ep, ep1, &e2->left.expr);
+		expr_extract_eq(type, ep, ep1, &e2->right.expr);
+		return;
+	}
+	if (expr_eq(e1, e2)) {
+		*ep = *ep ? expr_alloc_two(type, *ep, e1) : e1;
+		expr_free(e2);
+		if (type == E_AND) {
+			e1 = expr_alloc_symbol(&symbol_yes);
+			e2 = expr_alloc_symbol(&symbol_yes);
+		} else if (type == E_OR) {
+			e1 = expr_alloc_symbol(&symbol_no);
+			e2 = expr_alloc_symbol(&symbol_no);
+		}
+	}
+#undef e1
+#undef e2
+}
+
+struct expr *expr_trans_compare(struct expr *e, enum expr_type type, struct symbol *sym)
+{
+	struct expr *e1, *e2;
+
+	if (!e) {
+		e = expr_alloc_symbol(sym);
+		if (type == E_UNEQUAL)
+			e = expr_alloc_one(E_NOT, e);
+		return e;
+	}
+	switch (e->type) {
+	case E_AND:
+		e1 = expr_trans_compare(e->left.expr, E_EQUAL, sym);
+		e2 = expr_trans_compare(e->right.expr, E_EQUAL, sym);
+		if (sym == &symbol_yes)
+			e = expr_alloc_two(E_AND, e1, e2);
+		if (sym == &symbol_no)
+			e = expr_alloc_two(E_OR, e1, e2);
+		if (type == E_UNEQUAL)
+			e = expr_alloc_one(E_NOT, e);
+		return e;
+	case E_OR:
+		e1 = expr_trans_compare(e->left.expr, E_EQUAL, sym);
+		e2 = expr_trans_compare(e->right.expr, E_EQUAL, sym);
+		if (sym == &symbol_yes)
+			e = expr_alloc_two(E_OR, e1, e2);
+		if (sym == &symbol_no)
+			e = expr_alloc_two(E_AND, e1, e2);
+		if (type == E_UNEQUAL)
+			e = expr_alloc_one(E_NOT, e);
+		return e;
+	case E_NOT:
+		return expr_trans_compare(e->left.expr, type == E_EQUAL ? E_UNEQUAL : E_EQUAL, sym);
+	case E_UNEQUAL:
+	case E_EQUAL:
+		if (type == E_EQUAL) {
+			if (sym == &symbol_yes)
+				return expr_copy(e);
+			if (sym == &symbol_mod)
+				return expr_alloc_symbol(&symbol_no);
+			if (sym == &symbol_no)
+				return expr_alloc_one(E_NOT, expr_copy(e));
+		} else {
+			if (sym == &symbol_yes)
+				return expr_alloc_one(E_NOT, expr_copy(e));
+			if (sym == &symbol_mod)
+				return expr_alloc_symbol(&symbol_yes);
+			if (sym == &symbol_no)
+				return expr_copy(e);
+		}
+		break;
+	case E_SYMBOL:
+		return expr_alloc_comp(type, e->left.sym, sym);
+	case E_CHOICE:
+	case E_NONE:
+		/* panic */;
+	}
+	return NULL;
+}
+
+tristate expr_calc_value(struct expr *e)
+{
+	tristate val1, val2;
+	const char *str1, *str2;
+
+	if (!e)
+		return yes;
+
+	switch (e->type) {
+	case E_SYMBOL:
+		sym_calc_value(e->left.sym);
+		return S_TRI(e->left.sym->curr);
+	case E_AND:
+		val1 = expr_calc_value(e->left.expr);
+		val2 = expr_calc_value(e->right.expr);
+		return E_AND(val1, val2);
+	case E_OR:
+		val1 = expr_calc_value(e->left.expr);
+		val2 = expr_calc_value(e->right.expr);
+		return E_OR(val1, val2);
+	case E_NOT:
+		val1 = expr_calc_value(e->left.expr);
+		return E_NOT(val1);
+	case E_EQUAL:
+		sym_calc_value(e->left.sym);
+		sym_calc_value(e->right.sym);
+		str1 = sym_get_string_value(e->left.sym);
+		str2 = sym_get_string_value(e->right.sym);
+		return !strcmp(str1, str2) ? yes : no;
+	case E_UNEQUAL:
+		sym_calc_value(e->left.sym);
+		sym_calc_value(e->right.sym);
+		str1 = sym_get_string_value(e->left.sym);
+		str2 = sym_get_string_value(e->right.sym);
+		return !strcmp(str1, str2) ? no : yes;
+	default:
+		printf("expr_calc_value: %d?\n", e->type);
+		return no;
+	}
+}
+
+int expr_compare_type(enum expr_type t1, enum expr_type t2)
+{
+#if 0
+	return 1;
+#else
+	if (t1 == t2)
+		return 0;
+	switch (t1) {
+	case E_EQUAL:
+	case E_UNEQUAL:
+		if (t2 == E_NOT)
+			return 1;
+	case E_NOT:
+		if (t2 == E_AND)
+			return 1;
+	case E_AND:
+		if (t2 == E_OR)
+			return 1;
+	case E_OR:
+		if (t2 == E_CHOICE)
+			return 1;
+	case E_CHOICE:
+		if (t2 == 0)
+			return 1;
+	default:
+		return -1;
+	}
+	printf("[%dgt%d?]", t1, t2);
+	return 0;
+#endif
+}
+
+void expr_print(struct expr *e, void (*fn)(void *, const char *), void *data, int prevtoken)
+{
+	if (!e) {
+		fn(data, "y");
+		return;
+	}
+
+	if (expr_compare_type(prevtoken, e->type) > 0)
+		fn(data, "(");
+	switch (e->type) {
+	case E_SYMBOL:
+		if (e->left.sym->name)
+			fn(data, e->left.sym->name);
+		else
+			fn(data, "<choice>");
+		break;
+	case E_NOT:
+		fn(data, "!");
+		expr_print(e->left.expr, fn, data, E_NOT);
+		break;
+	case E_EQUAL:
+		fn(data, e->left.sym->name);
+		fn(data, "=");
+		fn(data, e->right.sym->name);
+		break;
+	case E_UNEQUAL:
+		fn(data, e->left.sym->name);
+		fn(data, "!=");
+		fn(data, e->right.sym->name);
+		break;
+	case E_OR:
+		expr_print(e->left.expr, fn, data, E_OR);
+		fn(data, " || ");
+		expr_print(e->right.expr, fn, data, E_OR);
+		break;
+	case E_AND:
+		expr_print(e->left.expr, fn, data, E_AND);
+		fn(data, " && ");
+		expr_print(e->right.expr, fn, data, E_AND);
+		break;
+	case E_CHOICE:
+		if (e->left.expr) {
+			expr_print(e->left.expr, fn, data, E_CHOICE);
+			fn(data, " ^ ");
+		}
+		fn(data, e->right.sym->name);
+		break;
+	default:
+	  {
+		char buf[32];
+		sprintf(buf, "<unknown type %d>", e->type);
+		fn(data, buf);
+		break;
+	  }
+	}
+	if (expr_compare_type(prevtoken, e->type) > 0)
+		fn(data, ")");
+}
+
+static void expr_print_file_helper(void *data, const char *str)
+{
+	fwrite(str, strlen(str), 1, data);
+}
+
+void expr_fprint(struct expr *e, FILE *out)
+{
+	expr_print(e, expr_print_file_helper, out, E_NONE);
+}
+
+void print_expr(int mask, struct expr *e, int prevtoken)
+{
+	if (!(cdebug & mask))
+		return;
+	expr_fprint(e, stdout);
+}
+
diff --git a/scripts/config/expr.h b/scripts/config/expr.h
new file mode 100644
index 000000000..e96d03b5a
--- /dev/null
+++ b/scripts/config/expr.h
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#ifndef EXPR_H
+#define EXPR_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#ifndef __cplusplus
+#include <stdbool.h>
+#endif
+
+struct file {
+	struct file *next;
+	struct file *parent;
+#ifdef CML1
+	struct statement *stmt;
+	struct statement *last_stmt;
+#endif
+	char *name;
+	int lineno;
+	int flags;
+};
+
+#define FILE_BUSY		0x0001
+#define FILE_SCANNED		0x0002
+#define FILE_PRINTED		0x0004
+
+typedef enum tristate {
+	no, mod, yes
+} tristate;
+
+enum expr_type {
+	E_NONE, E_OR, E_AND, E_NOT, E_EQUAL, E_UNEQUAL, E_CHOICE, E_SYMBOL
+};
+
+union expr_data {
+	struct expr *expr;
+	struct symbol *sym;
+};
+
+struct expr {
+#ifdef CML1
+	int token;
+#else
+	enum expr_type type;
+#endif
+	union expr_data left, right;
+};
+
+#define E_TRI(ev)	((ev).tri)
+#define E_EXPR(ev)	((ev).expr)
+#define E_CALC(ev)	(E_TRI(ev) = expr_calc_value(E_EXPR(ev)))
+
+#define E_OR(dep1, dep2)	(((dep1)>(dep2))?(dep1):(dep2))
+#define E_AND(dep1, dep2)	(((dep1)<(dep2))?(dep1):(dep2))
+#define E_NOT(dep)		(2-(dep))
+
+struct expr_value {
+	struct expr *expr;
+	tristate tri;
+};
+
+#define S_VAL(sv)	((sv).value)
+#define S_TRI(sv)	((sv).tri)
+#define S_EQ(sv1, sv2)	(S_VAL(sv1) == S_VAL(sv2) || !strcmp(S_VAL(sv1), S_VAL(sv2)))
+
+struct symbol_value {
+	void *value;
+	tristate tri;
+};
+
+enum symbol_type {
+	S_UNKNOWN, S_BOOLEAN, S_TRISTATE, S_INT, S_HEX, S_STRING, S_OTHER
+};
+
+struct symbol {
+	struct symbol *next;
+	char *name;
+	char *help;
+#ifdef CML1
+	int type;
+#else
+	enum symbol_type type;
+#endif
+	struct symbol_value curr, def;
+	tristate visible;
+	int flags;
+	struct property *prop;
+	struct expr *dep, *dep2;
+	struct menu *menu;
+};
+
+#define for_all_symbols(i, sym) for (i = 0; i < 257; i++) for (sym = symbol_hash[i]; sym; sym = sym->next) if (sym->type != S_OTHER)
+
+#ifdef CML1
+#define SYMBOL_UNKNOWN		S_UNKNOWN
+#define SYMBOL_BOOLEAN		S_BOOLEAN
+#define SYMBOL_TRISTATE		S_TRISTATE
+#define SYMBOL_INT		S_INT
+#define SYMBOL_HEX		S_HEX
+#define SYMBOL_STRING		S_STRING
+#define SYMBOL_OTHER		S_OTHER
+#endif
+
+#define SYMBOL_YES		0x0001
+#define SYMBOL_MOD		0x0002
+#define SYMBOL_NO		0x0004
+#define SYMBOL_CONST		0x0007
+#define SYMBOL_CHECK		0x0008
+#define SYMBOL_CHOICE		0x0010
+#define SYMBOL_CHOICEVAL	0x0020
+#define SYMBOL_PRINTED		0x0040
+#define SYMBOL_VALID		0x0080
+#define SYMBOL_OPTIONAL		0x0100
+#define SYMBOL_WRITE		0x0200
+#define SYMBOL_CHANGED		0x0400
+#define SYMBOL_NEW		0x0800
+#define SYMBOL_AUTO		0x1000
+
+#define SYMBOL_MAXLENGTH	256
+#define SYMBOL_HASHSIZE		257
+#define SYMBOL_HASHMASK		0xff
+
+enum prop_type {
+	P_UNKNOWN, P_PROMPT, P_COMMENT, P_MENU, P_ROOTMENU, P_DEFAULT, P_CHOICE
+};
+
+struct property {
+	struct property *next;
+	struct symbol *sym;
+#ifdef CML1
+	int token;
+#else
+	enum prop_type type;
+#endif
+	const char *text;
+	struct symbol *def;
+	struct expr_value visible;
+	struct expr *dep;
+	struct expr *dep2;
+	struct menu *menu;
+	struct file *file;
+	int lineno;
+#ifdef CML1
+	struct property *next_pos;
+#endif
+};
+
+#define for_all_properties(sym, st, tok) \
+	for (st = sym->prop; st; st = st->next) \
+		if (st->type == (tok))
+#define for_all_prompts(sym, st) for_all_properties(sym, st, P_PROMPT)
+#define for_all_defaults(sym, st) for_all_properties(sym, st, P_DEFAULT)
+#define for_all_choices(sym, st) for_all_properties(sym, st, P_CHOICE)
+
+struct menu {
+	struct menu *next;
+	struct menu *parent;
+	struct menu *list;
+	struct symbol *sym;
+	struct property *prompt;
+	struct expr *dep;
+	//char *help;
+	struct file *file;
+	int lineno;
+	void *data;
+};
+
+#ifndef SWIG
+
+extern struct file *file_list;
+extern struct file *current_file;
+struct file *lookup_file(const char *name);
+
+extern struct symbol symbol_yes, symbol_no, symbol_mod;
+extern struct symbol *modules_sym;
+extern int cdebug;
+extern int print_type;
+struct expr *expr_alloc_symbol(struct symbol *sym);
+#ifdef CML1
+struct expr *expr_alloc_one(int token, struct expr *ce);
+struct expr *expr_alloc_two(int token, struct expr *e1, struct expr *e2);
+struct expr *expr_alloc_comp(int token, struct symbol *s1, struct symbol *s2);
+#else
+struct expr *expr_alloc_one(enum expr_type type, struct expr *ce);
+struct expr *expr_alloc_two(enum expr_type type, struct expr *e1, struct expr *e2);
+struct expr *expr_alloc_comp(enum expr_type type, struct symbol *s1, struct symbol *s2);
+#endif
+struct expr *expr_alloc_and(struct expr *e1, struct expr *e2);
+struct expr *expr_copy(struct expr *org);
+void expr_free(struct expr *e);
+int expr_eq(struct expr *e1, struct expr *e2);
+void expr_eliminate_eq(struct expr **ep1, struct expr **ep2);
+tristate expr_calc_value(struct expr *e);
+struct expr *expr_eliminate_yn(struct expr *e);
+struct expr *expr_trans_bool(struct expr *e);
+struct expr *expr_eliminate_dups(struct expr *e);
+struct expr *expr_transform(struct expr *e);
+int expr_contains_symbol(struct expr *dep, struct symbol *sym);
+bool expr_depends_symbol(struct expr *dep, struct symbol *sym);
+struct expr *expr_extract_eq_and(struct expr **ep1, struct expr **ep2);
+struct expr *expr_extract_eq_or(struct expr **ep1, struct expr **ep2);
+void expr_extract_eq(enum expr_type type, struct expr **ep, struct expr **ep1, struct expr **ep2);
+struct expr *expr_trans_compare(struct expr *e, enum expr_type type, struct symbol *sym);
+
+void expr_fprint(struct expr *e, FILE *out);
+void print_expr(int mask, struct expr *e, int prevtoken);
+
+#ifdef CML1
+static inline int expr_is_yes(struct expr *e)
+{
+	return !e || (e->token == WORD && e->left.sym == &symbol_yes);
+}
+
+static inline int expr_is_no(struct expr *e)
+{
+	return e && (e->token == WORD && e->left.sym == &symbol_no);
+}
+#else
+static inline int expr_is_yes(struct expr *e)
+{
+	return !e || (e->type == E_SYMBOL && e->left.sym == &symbol_yes);
+}
+
+static inline int expr_is_no(struct expr *e)
+{
+	return e && (e->type == E_SYMBOL && e->left.sym == &symbol_no);
+}
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EXPR_H */
diff --git a/scripts/lxdialog/inputbox.c b/scripts/config/inputbox.c
similarity index 100%
rename from scripts/lxdialog/inputbox.c
rename to scripts/config/inputbox.c
diff --git a/scripts/config/lex.zconf.c_shipped b/scripts/config/lex.zconf.c_shipped
new file mode 100644
index 000000000..df102812f
--- /dev/null
+++ b/scripts/config/lex.zconf.c_shipped
@@ -0,0 +1,3280 @@
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_scan_buffer zconf_scan_buffer
+#define yy_scan_string zconf_scan_string
+#define yy_scan_bytes zconf_scan_bytes
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /var/cvs/busybox/scripts/config/lex.zconf.c_shipped,v 1.1 2002/12/05 08:41:07 andersen Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#include <stdio.h>
+#include <errno.h>
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+#ifndef _WIN32
+#include <unistd.h>
+#endif
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+
+extern int yyleng;
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		yyless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		*yy_cp = yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yytext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int yy_size_t;
+
+
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER yy_current_buffer
+
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+
+
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 1;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart YY_PROTO(( FILE *input_file ));
+
+void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void yy_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
+void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+
+YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
+YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
+YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+
+static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
+static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
+static void yy_flex_free YY_PROTO(( void * ));
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+
+
+#define yywrap() 1
+#define YY_SKIP_YYWRAP
+typedef unsigned char YY_CHAR;
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+typedef int yy_state_type;
+extern char *yytext;
+#define yytext_ptr yytext
+static yyconst short yy_nxt[][37] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   18,   19,   20,   21,
+       22,   18,   18,   23,   24,   18,   25,   18,   26,   27,
+       18,   28,   29,   30,   18,   18,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   18,   19,   20,   21,
+       22,   18,   18,   23,   24,   18,   25,   18,   26,   27,
+       18,   28,   29,   30,   18,   18,   16
+
+    },
+
+    {
+       11,   31,   32,   33,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31
+    },
+
+    {
+       11,   31,   32,   33,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31
+    },
+
+    {
+       11,   34,   34,   35,   34,   36,   34,   34,   36,   34,
+       34,   34,   34,   34,   34,   37,   34,   34,   34,   34,
+
+       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
+       34,   34,   34,   34,   34,   34,   34
+    },
+
+    {
+       11,   34,   34,   35,   34,   36,   34,   34,   36,   34,
+       34,   34,   34,   34,   34,   37,   34,   34,   34,   34,
+       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
+       34,   34,   34,   34,   34,   34,   34
+    },
+
+    {
+       11,   38,   38,   39,   40,   41,   38,   42,   41,   43,
+       44,   45,   46,   46,   47,   38,   46,   46,   46,   46,
+       46,   46,   46,   46,   48,   46,   46,   46,   49,   46,
+       46,   46,   46,   46,   46,   46,   50
+
+    },
+
+    {
+       11,   38,   38,   39,   40,   41,   38,   42,   41,   43,
+       44,   45,   46,   46,   47,   38,   46,   46,   46,   46,
+       46,   46,   46,   46,   48,   46,   46,   46,   49,   46,
+       46,   46,   46,   46,   46,   46,   50
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   51,   52,  -13,  -13,   53,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   56,  -18,  -18,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -18
+    },
+
+    {
+       11,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,   56,  -19,  -19,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   57,   56,
+       56,   56,   56,   56,   56,   56,  -19
+
+    },
+
+    {
+       11,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,   56,  -20,  -20,   56,   56,   56,   56,
+       56,   56,   56,   58,   56,   56,   56,   56,   59,   56,
+       56,   56,   56,   56,   56,   56,  -20
+    },
+
+    {
+       11,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,   56,  -21,  -21,   56,   56,   56,   56,
+       60,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -21
+    },
+
+    {
+       11,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,   56,  -22,  -22,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   61,   56,   56,
+       56,   56,   56,   56,   56,   56,  -22
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,   56,  -23,  -23,   56,   56,   56,   56,
+       62,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,   56,  -24,  -24,   56,   56,   56,   56,
+       56,   63,   56,   56,   56,   56,   56,   64,   56,   56,
+       56,   56,   56,   56,   56,   56,  -24
+
+    },
+
+    {
+       11,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,   56,  -25,  -25,   65,   56,   56,   56,
+       66,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -25
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,   56,  -26,  -26,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   67,
+       56,   56,   56,   56,   56,   56,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,   56,  -27,  -27,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   68,   56,   56,   56,   56,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,   56,  -28,  -28,   56,   56,   56,   56,
+       69,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,   56,  -29,  -29,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   70,   56,
+       56,   56,   56,   71,   56,   56,  -29
+
+    },
+
+    {
+       11,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,   56,  -30,  -30,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   72,   56,   56,   56,   56,  -30
+    },
+
+    {
+       11,   73,   73,  -31,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73
+    },
+
+    {
+       11,  -32,   74,   75,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,   76,  -33,  -33,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76
+    },
+
+    {
+       11,   77,   77,   78,   77,  -34,   77,   77,  -34,   77,
+       77,   77,   77,   77,   77,  -34,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,   79,   79,   80,   79,   79,   79,   79,   79,   79,
+       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
+
+       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
+       79,   79,   79,   79,   79,   79,   79
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38
+    },
+
+    {
+       11,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,   81,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41
+    },
+
+    {
+       11,  -42,  -42,  -42,  -42,  -42,  -42,   82,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,   83,   84,   84,  -45,  -45,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -45
+    },
+
+    {
+       11,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,   84,   84,   84,  -46,  -46,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -46
+    },
+
+    {
+       11,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,   84,   84,   84,  -48,  -48,   84,   84,   84,   84,
+       84,   85,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -48
+    },
+
+    {
+       11,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,   84,   84,   84,  -49,  -49,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   86,   84,   84,
+       84,   84,   84,   84,   84,   84,  -49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,   87
+    },
+
+    {
+       11,  -51,   51,   52,  -51,  -51,   53,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,  -56,  -56,   56,  -56,  -56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,  -57,  -57,   56,  -57,  -57,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   88,   56,
+       56,   56,   56,   56,   56,   56,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,   56,  -58,  -58,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   89,   56,
+       56,   56,   56,   56,   56,   56,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,   56,  -59,  -59,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   90,   91,   56,   56,
+       56,   56,   56,   56,   56,   56,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,  -60,  -60,   56,  -60,  -60,   56,   56,   56,   56,
+       56,   92,   56,   56,   56,   56,   56,   56,   56,   93,
+       56,   56,   56,   56,   56,   56,  -60
+    },
+
+    {
+       11,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
+      -61,  -61,  -61,   56,  -61,  -61,   56,   56,   56,   94,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -61
+    },
+
+    {
+       11,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
+      -62,  -62,  -62,   56,  -62,  -62,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   95,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   96,  -62
+    },
+
+    {
+       11,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,
+      -63,  -63,  -63,   56,  -63,  -63,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -63
+    },
+
+    {
+       11,  -64,  -64,  -64,  -64,  -64,  -64,  -64,  -64,  -64,
+      -64,  -64,  -64,   56,  -64,  -64,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   97,   56,   56,  -64
+
+    },
+
+    {
+       11,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,
+      -65,  -65,  -65,   56,  -65,  -65,   56,   56,   56,   56,
+       56,   56,   56,   56,   98,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -65
+    },
+
+    {
+       11,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
+      -66,  -66,  -66,   56,  -66,  -66,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   99,   56,   56,
+       56,   56,   56,   56,   56,   56,  -66
+    },
+
+    {
+       11,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
+      -67,  -67,  -67,   56,  -67,  -67,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  100,   56,   56,  -67
+    },
+
+    {
+       11,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,
+      -68,  -68,  -68,   56,  -68,  -68,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,  101,   56,
+       56,   56,   56,   56,   56,   56,  -68
+    },
+
+    {
+       11,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
+      -69,  -69,  -69,   56,  -69,  -69,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+      102,   56,   56,   56,   56,   56,  -69
+
+    },
+
+    {
+       11,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,
+      -70,  -70,  -70,   56,  -70,  -70,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  103,   56,  -70
+    },
+
+    {
+       11,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,
+      -71,  -71,  -71,   56,  -71,  -71,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,  104,   56,   56,   56,   56,  -71
+    },
+
+    {
+       11,  -72,  -72,  -72,  -72,  -72,  -72,  -72,  -72,  -72,
+      -72,  -72,  -72,   56,  -72,  -72,   56,   56,   56,   56,
+
+       56,   56,   56,   56,  105,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -72
+    },
+
+    {
+       11,   73,   73,  -73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73
+    },
+
+    {
+       11,  -74,   74,   75,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74,  -74,  -74,  -74
+
+    },
+
+    {
+       11,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
+      -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
+      -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
+      -75,  -75,  -75,  -75,  -75,  -75,  -75
+    },
+
+    {
+       11,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
+      -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
+      -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
+      -76,  -76,  -76,  -76,  -76,  -76,  -76
+    },
+
+    {
+       11,   77,   77,   78,   77,  -77,   77,   77,  -77,   77,
+       77,   77,   77,   77,   77,  -77,   77,   77,   77,   77,
+
+       77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77
+    },
+
+    {
+       11,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
+      -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
+      -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
+      -78,  -78,  -78,  -78,  -78,  -78,  -78
+    },
+
+    {
+       11,  -79,  -79,   80,  -79,  -79,  -79,  -79,  -79,  -79,
+      -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,
+      -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,
+      -79,  -79,  -79,  -79,  -79,  -79,  -79
+
+    },
+
+    {
+       11,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,  -80,  -80
+    },
+
+    {
+       11,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81,  -81,  -81,  -81
+    },
+
+    {
+       11,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
+      -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
+
+      -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
+      -82,  -82,  -82,  -82,  -82,  -82,  -82
+    },
+
+    {
+       11,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  106,   84,   84,  -83,  -83,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -83
+    },
+
+    {
+       11,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,   84,   84,   84,  -84,  -84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -84
+
+    },
+
+    {
+       11,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,   84,   84,   84,  -85,  -85,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -85
+    },
+
+    {
+       11,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,   84,   84,   84,  -86,  -86,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -86
+    },
+
+    {
+       11,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+
+      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+      -87,  -87,  -87,  -87,  -87,  -87,  -87
+    },
+
+    {
+       11,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,
+      -88,  -88,  -88,   56,  -88,  -88,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,  107,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -88
+    },
+
+    {
+       11,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,
+      -89,  -89,  -89,   56,  -89,  -89,   56,   56,   56,   56,
+       56,   56,   56,   56,  108,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -89
+
+    },
+
+    {
+       11,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,   56,  -90,  -90,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  109,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -90
+    },
+
+    {
+       11,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,
+      -91,  -91,  -91,   56,  -91,  -91,   56,   56,   56,   56,
+       56,  110,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -91
+    },
+
+    {
+       11,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,
+      -92,  -92,  -92,   56,  -92,  -92,  111,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -92
+    },
+
+    {
+       11,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,   56,  -93,  -93,   56,   56,   56,   56,
+      112,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -93
+    },
+
+    {
+       11,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,
+      -94,  -94,  -94,   56,  -94,  -94,   56,   56,  113,   56,
+       56,   56,   56,   56,  114,   56,  115,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -94
+
+    },
+
+    {
+       11,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,
+      -95,  -95,  -95,   56,  -95,  -95,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,  116,
+       56,   56,   56,   56,   56,   56,  -95
+    },
+
+    {
+       11,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,
+      -96,  -96,  -96,   56,  -96,  -96,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -96
+    },
+
+    {
+       11,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,
+      -97,  -97,  -97,   56,  -97,  -97,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -97
+    },
+
+    {
+       11,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,
+      -98,  -98,  -98,   56,  -98,  -98,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  117,   56,   56,
+       56,   56,   56,   56,   56,   56,  -98
+    },
+
+    {
+       11,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
+      -99,  -99,  -99,   56,  -99,  -99,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  118,   56,  -99
+
+    },
+
+    {
+       11, -100, -100, -100, -100, -100, -100, -100, -100, -100,
+     -100, -100, -100,   56, -100, -100,   56,   56,   56,   56,
+       56,   56,   56,   56,  119,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -100
+    },
+
+    {
+       11, -101, -101, -101, -101, -101, -101, -101, -101, -101,
+     -101, -101, -101,   56, -101, -101,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  120,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -101
+    },
+
+    {
+       11, -102, -102, -102, -102, -102, -102, -102, -102, -102,
+     -102, -102, -102,   56, -102, -102,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  121,   56, -102
+    },
+
+    {
+       11, -103, -103, -103, -103, -103, -103, -103, -103, -103,
+     -103, -103, -103,   56, -103, -103,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,  122,   56,   56,   56,   56, -103
+    },
+
+    {
+       11, -104, -104, -104, -104, -104, -104, -104, -104, -104,
+     -104, -104, -104,   56, -104, -104,   56,   56,   56,   56,
+       56,   56,   56,   56,  123,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -104
+
+    },
+
+    {
+       11, -105, -105, -105, -105, -105, -105, -105, -105, -105,
+     -105, -105, -105,   56, -105, -105,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,  124,   56,   56,   56, -105
+    },
+
+    {
+       11, -106, -106, -106, -106, -106, -106, -106, -106, -106,
+     -106,   84,   84,   84, -106, -106,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84, -106
+    },
+
+    {
+       11, -107, -107, -107, -107, -107, -107, -107, -107, -107,
+     -107, -107, -107,   56, -107, -107,   56,   56,   56,   56,
+
+      125,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -107
+    },
+
+    {
+       11, -108, -108, -108, -108, -108, -108, -108, -108, -108,
+     -108, -108, -108,   56, -108, -108,   56,   56,  126,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -108
+    },
+
+    {
+       11, -109, -109, -109, -109, -109, -109, -109, -109, -109,
+     -109, -109, -109,   56, -109, -109,   56,   56,   56,   56,
+      127,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -109
+
+    },
+
+    {
+       11, -110, -110, -110, -110, -110, -110, -110, -110, -110,
+     -110, -110, -110,   56, -110, -110,   56,   56,   56,   56,
+       56,   56,   56,   56,  128,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -110
+    },
+
+    {
+       11, -111, -111, -111, -111, -111, -111, -111, -111, -111,
+     -111, -111, -111,   56, -111, -111,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  129,   56, -111
+    },
+
+    {
+       11, -112, -112, -112, -112, -112, -112, -112, -112, -112,
+     -112, -112, -112,   56, -112, -112,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,  130,   56,   56,
+       56,   56,   56,   56,   56,   56, -112
+    },
+
+    {
+       11, -113, -113, -113, -113, -113, -113, -113, -113, -113,
+     -113, -113, -113,   56, -113, -113,   56,   56,   56,   56,
+       56,   56,   56,  131,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -113
+    },
+
+    {
+       11, -114, -114, -114, -114, -114, -114, -114, -114, -114,
+     -114, -114, -114,   56, -114, -114,   56,   56,   56,   56,
+       56,  132,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -114
+
+    },
+
+    {
+       11, -115, -115, -115, -115, -115, -115, -115, -115, -115,
+     -115, -115, -115,   56, -115, -115,   56,   56,   56,   56,
+      133,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -115
+    },
+
+    {
+       11, -116, -116, -116, -116, -116, -116, -116, -116, -116,
+     -116, -116, -116,   56, -116, -116,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -116
+    },
+
+    {
+       11, -117, -117, -117, -117, -117, -117, -117, -117, -117,
+     -117, -117, -117,   56, -117, -117,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,  134,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -117
+    },
+
+    {
+       11, -118, -118, -118, -118, -118, -118, -118, -118, -118,
+     -118, -118, -118,   56, -118, -118,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -118
+    },
+
+    {
+       11, -119, -119, -119, -119, -119, -119, -119, -119, -119,
+     -119, -119, -119,   56, -119, -119,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,  135,   56,
+       56,   56,   56,   56,   56,   56, -119
+
+    },
+
+    {
+       11, -120, -120, -120, -120, -120, -120, -120, -120, -120,
+     -120, -120, -120,   56, -120, -120,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,  136,
+       56,   56,   56,   56,   56,   56, -120
+    },
+
+    {
+       11, -121, -121, -121, -121, -121, -121, -121, -121, -121,
+     -121, -121, -121,   56, -121, -121,   56,   56,   56,   56,
+       56,   56,   56,   56,  137,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -121
+    },
+
+    {
+       11, -122, -122, -122, -122, -122, -122, -122, -122, -122,
+     -122, -122, -122,   56, -122, -122,   56,   56,  138,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -122
+    },
+
+    {
+       11, -123, -123, -123, -123, -123, -123, -123, -123, -123,
+     -123, -123, -123,   56, -123, -123,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  139,   56,   56,
+       56,   56,   56,   56,   56,   56, -123
+    },
+
+    {
+       11, -124, -124, -124, -124, -124, -124, -124, -124, -124,
+     -124, -124, -124,   56, -124, -124,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  140,   56,   56, -124
+
+    },
+
+    {
+       11, -125, -125, -125, -125, -125, -125, -125, -125, -125,
+     -125, -125, -125,   56, -125, -125,  141,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -125
+    },
+
+    {
+       11, -126, -126, -126, -126, -126, -126, -126, -126, -126,
+     -126, -126, -126,   56, -126, -126,   56,   56,   56,   56,
+      142,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -126
+    },
+
+    {
+       11, -127, -127, -127, -127, -127, -127, -127, -127, -127,
+     -127, -127, -127,   56, -127, -127,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,  143,   56,   56,
+       56,   56,   56,   56,   56,   56, -127
+    },
+
+    {
+       11, -128, -128, -128, -128, -128, -128, -128, -128, -128,
+     -128, -128, -128,   56, -128, -128,   56,   56,   56,   56,
+       56,   56,  144,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -128
+    },
+
+    {
+       11, -129, -129, -129, -129, -129, -129, -129, -129, -129,
+     -129, -129, -129,   56, -129, -129,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,  145,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -129
+
+    },
+
+    {
+       11, -130, -130, -130, -130, -130, -130, -130, -130, -130,
+     -130, -130, -130,   56, -130, -130,   56,   56,   56,  146,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -130
+    },
+
+    {
+       11, -131, -131, -131, -131, -131, -131, -131, -131, -131,
+     -131, -131, -131,   56, -131, -131,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,  147,   56,
+       56,   56,   56,   56,   56,   56, -131
+    },
+
+    {
+       11, -132, -132, -132, -132, -132, -132, -132, -132, -132,
+     -132, -132, -132,   56, -132, -132,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -132
+    },
+
+    {
+       11, -133, -133, -133, -133, -133, -133, -133, -133, -133,
+     -133, -133, -133,   56, -133, -133,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  148,   56,   56,
+       56,   56,   56,   56,   56,   56, -133
+    },
+
+    {
+       11, -134, -134, -134, -134, -134, -134, -134, -134, -134,
+     -134, -134, -134,   56, -134, -134,   56,   56,   56,   56,
+      149,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -134
+
+    },
+
+    {
+       11, -135, -135, -135, -135, -135, -135, -135, -135, -135,
+     -135, -135, -135,   56, -135, -135,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  150,   56,   56,
+       56,   56,   56,   56,   56,   56, -135
+    },
+
+    {
+       11, -136, -136, -136, -136, -136, -136, -136, -136, -136,
+     -136, -136, -136,   56, -136, -136,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  151,   56,   56, -136
+    },
+
+    {
+       11, -137, -137, -137, -137, -137, -137, -137, -137, -137,
+     -137, -137, -137,   56, -137, -137,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,  152,   56,   56,   56,   56, -137
+    },
+
+    {
+       11, -138, -138, -138, -138, -138, -138, -138, -138, -138,
+     -138, -138, -138,   56, -138, -138,   56,   56,   56,   56,
+      153,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -138
+    },
+
+    {
+       11, -139, -139, -139, -139, -139, -139, -139, -139, -139,
+     -139, -139, -139,   56, -139, -139,   56,   56,   56,   56,
+       56,   56,  154,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -139
+
+    },
+
+    {
+       11, -140, -140, -140, -140, -140, -140, -140, -140, -140,
+     -140, -140, -140,   56, -140, -140,  155,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -140
+    },
+
+    {
+       11, -141, -141, -141, -141, -141, -141, -141, -141, -141,
+     -141, -141, -141,   56, -141, -141,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  156,   56,   56,
+       56,   56,   56,   56,   56,   56, -141
+    },
+
+    {
+       11, -142, -142, -142, -142, -142, -142, -142, -142, -142,
+     -142, -142, -142,   56, -142, -142,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -142
+    },
+
+    {
+       11, -143, -143, -143, -143, -143, -143, -143, -143, -143,
+     -143, -143, -143,   56, -143, -143,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  157,   56,   56, -143
+    },
+
+    {
+       11, -144, -144, -144, -144, -144, -144, -144, -144, -144,
+     -144, -144, -144,   56, -144, -144,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -144
+
+    },
+
+    {
+       11, -145, -145, -145, -145, -145, -145, -145, -145, -145,
+     -145, -145, -145,   56, -145, -145,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  158,   56,   56, -145
+    },
+
+    {
+       11, -146, -146, -146, -146, -146, -146, -146, -146, -146,
+     -146, -146, -146,   56, -146, -146,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,  159,   56,   56,   56, -146
+    },
+
+    {
+       11, -147, -147, -147, -147, -147, -147, -147, -147, -147,
+     -147, -147, -147,   56, -147, -147,   56,   56,   56,   56,
+
+       56,   56,   56,   56,  160,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -147
+    },
+
+    {
+       11, -148, -148, -148, -148, -148, -148, -148, -148, -148,
+     -148, -148, -148,   56, -148, -148,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  161,   56, -148
+    },
+
+    {
+       11, -149, -149, -149, -149, -149, -149, -149, -149, -149,
+     -149, -149, -149,   56, -149, -149,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  162,   56,   56,
+       56,   56,   56,   56,   56,   56, -149
+
+    },
+
+    {
+       11, -150, -150, -150, -150, -150, -150, -150, -150, -150,
+     -150, -150, -150,   56, -150, -150,  163,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -150
+    },
+
+    {
+       11, -151, -151, -151, -151, -151, -151, -151, -151, -151,
+     -151, -151, -151,   56, -151, -151,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -151
+    },
+
+    {
+       11, -152, -152, -152, -152, -152, -152, -152, -152, -152,
+     -152, -152, -152,   56, -152, -152,   56,   56,   56,   56,
+
+      164,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -152
+    },
+
+    {
+       11, -153, -153, -153, -153, -153, -153, -153, -153, -153,
+     -153, -153, -153,   56, -153, -153,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -153
+    },
+
+    {
+       11, -154, -154, -154, -154, -154, -154, -154, -154, -154,
+     -154, -154, -154,   56, -154, -154,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -154
+
+    },
+
+    {
+       11, -155, -155, -155, -155, -155, -155, -155, -155, -155,
+     -155, -155, -155,   56, -155, -155,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  165,   56,   56, -155
+    },
+
+    {
+       11, -156, -156, -156, -156, -156, -156, -156, -156, -156,
+     -156, -156, -156,   56, -156, -156,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -156
+    },
+
+    {
+       11, -157, -157, -157, -157, -157, -157, -157, -157, -157,
+     -157, -157, -157,   56, -157, -157,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -157
+    },
+
+    {
+       11, -158, -158, -158, -158, -158, -158, -158, -158, -158,
+     -158, -158, -158,   56, -158, -158,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -158
+    },
+
+    {
+       11, -159, -159, -159, -159, -159, -159, -159, -159, -159,
+     -159, -159, -159,   56, -159, -159,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -159
+
+    },
+
+    {
+       11, -160, -160, -160, -160, -160, -160, -160, -160, -160,
+     -160, -160, -160,   56, -160, -160,   56,   56,  166,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -160
+    },
+
+    {
+       11, -161, -161, -161, -161, -161, -161, -161, -161, -161,
+     -161, -161, -161,   56, -161, -161,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -161
+    },
+
+    {
+       11, -162, -162, -162, -162, -162, -162, -162, -162, -162,
+     -162, -162, -162,   56, -162, -162,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  167,   56, -162
+    },
+
+    {
+       11, -163, -163, -163, -163, -163, -163, -163, -163, -163,
+     -163, -163, -163,   56, -163, -163,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,  168,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -163
+    },
+
+    {
+       11, -164, -164, -164, -164, -164, -164, -164, -164, -164,
+     -164, -164, -164,   56, -164, -164,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,  169,   56,   56,   56, -164
+
+    },
+
+    {
+       11, -165, -165, -165, -165, -165, -165, -165, -165, -165,
+     -165, -165, -165,   56, -165, -165,   56,   56,   56,   56,
+      170,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -165
+    },
+
+    {
+       11, -166, -166, -166, -166, -166, -166, -166, -166, -166,
+     -166, -166, -166,   56, -166, -166,   56,   56,   56,   56,
+      171,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -166
+    },
+
+    {
+       11, -167, -167, -167, -167, -167, -167, -167, -167, -167,
+     -167, -167, -167,   56, -167, -167,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -167
+    },
+
+    {
+       11, -168, -168, -168, -168, -168, -168, -168, -168, -168,
+     -168, -168, -168,   56, -168, -168,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -168
+    },
+
+    {
+       11, -169, -169, -169, -169, -169, -169, -169, -169, -169,
+     -169, -169, -169,   56, -169, -169,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -169
+
+    },
+
+    {
+       11, -170, -170, -170, -170, -170, -170, -170, -170, -170,
+     -170, -170, -170,   56, -170, -170,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -170
+    },
+
+    {
+       11, -171, -171, -171, -171, -171, -171, -171, -171, -171,
+     -171, -171, -171,   56, -171, -171,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -171
+    },
+
+    } ;
+
+
+static yy_state_type yy_get_previous_state YY_PROTO(( void ));
+static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
+static int yy_get_next_buffer YY_PROTO(( void ));
+static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 55
+#define YY_END_OF_BUFFER 56
+static yyconst short int yy_accept[172] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       56,    5,    4,    3,    2,   29,   30,   28,   28,   28,
+       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
+       54,   51,   53,   46,   50,   49,   48,   44,   41,   35,
+       40,   44,   33,   34,   43,   43,   36,   43,   43,   44,
+        4,    3,    2,    2,    1,   28,   28,   28,   28,   28,
+       28,   28,   15,   28,   28,   28,   28,   28,   28,   28,
+       28,   28,   54,   51,   53,   52,   46,   45,   48,   47,
+       37,   31,   43,   43,   38,   39,   32,   28,   28,   28,
+       28,   28,   28,   28,   28,   26,   25,   28,   28,   28,
+
+       28,   28,   28,   28,   28,   42,   23,   28,   28,   28,
+       28,   28,   28,   28,   28,   14,   28,    7,   28,   28,
+       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
+       28,   16,   28,   28,   28,   28,   28,   28,   28,   28,
+       28,   10,   28,   13,   28,   28,   28,   28,   28,   28,
+       21,   28,    9,   27,   28,   24,   12,   20,   17,   28,
+        8,   28,   28,   28,   28,   28,    6,   19,   18,   22,
+       11
+    } ;
+
+static yyconst int yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   16,   17,   18,   19,
+
+       20,   21,   22,   23,   24,   13,   13,   25,   26,   27,
+       28,   29,   30,   31,   32,   33,   34,   13,   13,   35,
+       13,   13,    1,   36,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "zconf.l"
+#define INITIAL 0
+#define YY_NEVER_INTERACTIVE 1
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#line 5 "zconf.l"
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+#include "zconf.tab.h"
+
+#define START_STRSIZE	16
+
+char *text;
+static char *text_ptr;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static struct buffer *zconf_endfile(void);
+
+void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_ptr = text;
+	text_size = 0;
+	*text_ptr = 0;
+}
+
+void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		text = realloc(text, new_size);
+		text_asize = new_size;
+		text_ptr = text + text_size;
+	}
+	memcpy(text_ptr, str, size);
+	text_ptr += size;
+	text_size += size;
+	*text_ptr = 0;
+}
+
+void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+#line 1719 "lex.zconf.c"
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap YY_PROTO(( void ));
+#else
+extern int yywrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int yy_start_stack_ptr = 0;
+static int yy_start_stack_depth = 0;
+static int *yy_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void yy_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(yyin); \
+	}
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int yylex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+
+#line 71 "zconf.l"
+
+	int str = 0;
+	int ts, i;
+
+#line 1871 "lex.zconf.c"
+
+	if ( yy_init )
+		{
+		yy_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yy_start )
+			yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! yy_current_buffer )
+			yy_current_buffer =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+
+		yy_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yy_start;
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][yy_ec[YY_SC_TO_UI(*yy_cp)]]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+YY_RULE_SETUP
+#line 75 "zconf.l"
+current_file->lineno++;
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 76 "zconf.l"
+
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 78 "zconf.l"
+current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 80 "zconf.l"
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 84 "zconf.l"
+{
+	unput(yytext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+#line 91 "zconf.l"
+BEGIN(PARAM); return T_MAINMENU;
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 92 "zconf.l"
+BEGIN(PARAM); return T_MENU;
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 93 "zconf.l"
+BEGIN(PARAM); return T_ENDMENU;
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 94 "zconf.l"
+BEGIN(PARAM); return T_SOURCE;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 95 "zconf.l"
+BEGIN(PARAM); return T_CHOICE;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 96 "zconf.l"
+BEGIN(PARAM); return T_ENDCHOICE;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 97 "zconf.l"
+BEGIN(PARAM); return T_COMMENT;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 98 "zconf.l"
+BEGIN(PARAM); return T_CONFIG;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 99 "zconf.l"
+BEGIN(PARAM); return T_HELP;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 100 "zconf.l"
+BEGIN(PARAM); return T_IF;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 101 "zconf.l"
+BEGIN(PARAM); return T_ENDIF;
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 102 "zconf.l"
+BEGIN(PARAM); return T_DEPENDS;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 103 "zconf.l"
+BEGIN(PARAM); return T_REQUIRES;
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 104 "zconf.l"
+BEGIN(PARAM); return T_OPTIONAL;
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 105 "zconf.l"
+BEGIN(PARAM); return T_DEFAULT;
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 106 "zconf.l"
+BEGIN(PARAM); return T_PROMPT;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 107 "zconf.l"
+BEGIN(PARAM); return T_TRISTATE;
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 108 "zconf.l"
+BEGIN(PARAM); return T_BOOLEAN;
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 109 "zconf.l"
+BEGIN(PARAM); return T_BOOLEAN;
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 110 "zconf.l"
+BEGIN(PARAM); return T_INT;
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 111 "zconf.l"
+BEGIN(PARAM); return T_HEX;
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 112 "zconf.l"
+BEGIN(PARAM); return T_STRING;
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 113 "zconf.l"
+{
+		alloc_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 118 "zconf.l"
+
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 119 "zconf.l"
+current_file->lineno++; BEGIN(INITIAL);
+	YY_BREAK
+
+
+case 31:
+YY_RULE_SETUP
+#line 123 "zconf.l"
+return T_AND;
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 124 "zconf.l"
+return T_OR;
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 125 "zconf.l"
+return T_OPEN_PAREN;
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 126 "zconf.l"
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 127 "zconf.l"
+return T_NOT;
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 128 "zconf.l"
+return T_EQUAL;
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 129 "zconf.l"
+return T_UNEQUAL;
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 130 "zconf.l"
+return T_IF;
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 131 "zconf.l"
+return T_ON;
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 132 "zconf.l"
+{
+		str = yytext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 137 "zconf.l"
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 138 "zconf.l"
+/* ignore */
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 139 "zconf.l"
+{
+		alloc_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 144 "zconf.l"
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+#line 145 "zconf.l"
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+
+case 45:
+*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
+yy_c_buf_p = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up yytext again */
+YY_RULE_SETUP
+#line 151 "zconf.l"
+{
+		append_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_STRING;
+	}
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 156 "zconf.l"
+{
+		append_string(yytext, yyleng);
+	}
+	YY_BREAK
+case 47:
+*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
+yy_c_buf_p = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up yytext again */
+YY_RULE_SETUP
+#line 159 "zconf.l"
+{
+		append_string(yytext+1, yyleng);
+		zconflval.string = text;
+		return T_STRING;
+	}
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 164 "zconf.l"
+{
+		append_string(yytext+1, yyleng - 1);
+	}
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 167 "zconf.l"
+{
+		if (str == yytext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_STRING;
+		} else
+			append_string(yytext, 1);
+	}
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 175 "zconf.l"
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+#line 180 "zconf.l"
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+
+case 51:
+YY_RULE_SETUP
+#line 186 "zconf.l"
+{
+		ts = 0;
+		for (i = 0; i < yyleng; i++) {
+			if (yytext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+		
+	}
+	YY_BREAK
+case 52:
+*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
+yy_c_buf_p = yy_cp = yy_bp + 1;
+YY_DO_BEFORE_ACTION; /* set up yytext again */
+YY_RULE_SETUP
+#line 209 "zconf.l"
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 214 "zconf.l"
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 218 "zconf.l"
+{
+		append_string(yytext, yyleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+#line 223 "zconf.l"
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+#line 229 "zconf.l"
+{
+	if (current_buf) {
+		zconf_endfile();
+		return T_EOF;
+	}
+	fclose(yyin);
+	yyterminate();
+}
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 238 "zconf.l"
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+#line 2323 "lex.zconf.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between yy_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yy_n_chars = yy_current_buffer->yy_n_chars;
+			yy_current_buffer->yy_input_file = yyin;
+			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yy_c_buf_p;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap() )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yy_c_buf_p =
+					yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yy_c_buf_p =
+				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of yylex */
+
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int yy_get_next_buffer()
+	{
+	register char *dest = yy_current_buffer->yy_ch_buf;
+	register char *source = yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( yy_current_buffer->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = yy_current_buffer;
+
+			int yy_c_buf_p_offset =
+				(int) (yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yy_flex_realloc( (void *) b->yy_ch_buf,
+							 b->yy_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = yy_current_buffer->yy_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+			yy_n_chars, num_to_read );
+
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	if ( yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			yy_current_buffer->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	yy_n_chars += number_to_move;
+	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+static yy_state_type yy_get_previous_state()
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = yy_start;
+
+	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+	}
+
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
+#else
+static yy_state_type yy_try_NUL_trans( yy_current_state )
+yy_state_type yy_current_state;
+#endif
+	{
+	register int yy_is_jam;
+
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void yyunput( int c, register char *yy_bp )
+#else
+static void yyunput( c, yy_bp )
+int c;
+register char *yy_bp;
+#endif
+	{
+	register char *yy_cp = yy_c_buf_p;
+
+	/* undo effects of setting up yytext */
+	*yy_cp = yy_hold_char;
+
+	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = yy_n_chars + 2;
+		register char *dest = &yy_current_buffer->yy_ch_buf[
+					yy_current_buffer->yy_buf_size + 2];
+		register char *source =
+				&yy_current_buffer->yy_ch_buf[number_to_move];
+
+		while ( source > yy_current_buffer->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		yy_current_buffer->yy_n_chars =
+			yy_n_chars = yy_current_buffer->yy_buf_size;
+
+		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+
+	yytext_ptr = yy_bp;
+	yy_hold_char = *yy_cp;
+	yy_c_buf_p = yy_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int yyinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*yy_c_buf_p = yy_hold_char;
+
+	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			/* This was really a NUL. */
+			*yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = yy_c_buf_p - yytext_ptr;
+			++yy_c_buf_p;
+
+			switch ( yy_get_next_buffer() )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/* fall through */
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap() )
+						return EOF;
+
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yy_c_buf_p = yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+	*yy_c_buf_p = '\0';	/* preserve yytext */
+	yy_hold_char = *++yy_c_buf_p;
+
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yyrestart( FILE *input_file )
+#else
+void yyrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! yy_current_buffer )
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+
+	yy_init_buffer( yy_current_buffer, input_file );
+	yy_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void yy_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( yy_current_buffer == new_buffer )
+		return;
+
+	if ( yy_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*yy_c_buf_p = yy_hold_char;
+		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	yy_current_buffer = new_buffer;
+	yy_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yy_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_load_buffer_state( void )
+#else
+void yy_load_buffer_state()
+#endif
+	{
+	yy_n_chars = yy_current_buffer->yy_n_chars;
+	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+	yyin = yy_current_buffer->yy_input_file;
+	yy_hold_char = *yy_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_delete_buffer( YY_BUFFER_STATE b )
+#else
+void yy_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == yy_current_buffer )
+		yy_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yy_flex_free( (void *) b->yy_ch_buf );
+
+	yy_flex_free( (void *) b );
+	}
+
+
+#ifndef _WIN32
+#include <unistd.h>
+#else
+#ifndef YY_ALWAYS_INTERACTIVE
+#ifndef YY_NEVER_INTERACTIVE
+extern int isatty YY_PROTO(( int ));
+#endif
+#endif
+#endif
+
+#ifdef YY_USE_PROTOS
+void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void yy_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->yy_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->yy_is_interactive = 0;
+#else
+	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_flush_buffer( YY_BUFFER_STATE b )
+#else
+void yy_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == yy_current_buffer )
+		yy_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
+#else
+YY_BUFFER_STATE yy_scan_buffer( base, size )
+char *base;
+yy_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
+#else
+YY_BUFFER_STATE yy_scan_string( yy_str )
+yyconst char *yy_str;
+#endif
+	{
+	int len;
+	for ( len = 0; yy_str[len]; ++len )
+		;
+
+	return yy_scan_bytes( yy_str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
+#else
+YY_BUFFER_STATE yy_scan_bytes( bytes, len )
+yyconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) yy_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void yy_push_state( int new_state )
+#else
+static void yy_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yy_start_stack_depth * sizeof( int );
+
+		if ( ! yy_start_stack )
+			yy_start_stack = (int *) yy_flex_alloc( new_size );
+
+		else
+			yy_start_stack = (int *) yy_flex_realloc(
+					(void *) yy_start_stack, new_size );
+
+		if ( ! yy_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state()
+	{
+	if ( --yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yy_start_stack[yy_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state()
+	{
+	return yy_start_stack[yy_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void yy_fatal_error( yyconst char msg[] )
+#else
+static void yy_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		yytext[yyleng] = yy_hold_char; \
+		yy_c_buf_p = yytext + n; \
+		yy_hold_char = *yy_c_buf_p; \
+		*yy_c_buf_p = '\0'; \
+		yyleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef yytext_ptr
+#ifdef YY_USE_PROTOS
+static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
+#else
+static void yy_flex_strncpy( s1, s2, n )
+char *s1;
+yyconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+#ifdef YY_NEED_STRLEN
+#ifdef YY_USE_PROTOS
+static int yy_flex_strlen( yyconst char *s )
+#else
+static int yy_flex_strlen( s )
+yyconst char *s;
+#endif
+	{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_alloc( yy_size_t size )
+#else
+static void *yy_flex_alloc( size )
+yy_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_realloc( void *ptr, yy_size_t size )
+#else
+static void *yy_flex_realloc( ptr, size )
+void *ptr;
+yy_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void yy_flex_free( void *ptr )
+#else
+static void yy_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	yylex();
+	return 0;
+	}
+#endif
+#line 238 "zconf.l"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL); 
+}
+
+void zconf_initscan(const char *name)
+{
+	yyin = fopen(name, "r");
+	if (!yyin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+	current_file->flags = FILE_BUSY;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	yyin = fopen(name, "r");
+	if (!yyin) {
+		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
+		exit(1);
+	}
+	yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	if (file->flags & FILE_BUSY) {
+		printf("recursive scan (%s)?\n", name);
+		exit(1);
+	}
+	if (file->flags & FILE_SCANNED) {
+		printf("file %s already scanned?\n", name);
+		exit(1);
+	}
+	file->flags |= FILE_BUSY;
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static struct buffer *zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file->flags |= FILE_SCANNED;
+	current_file->flags &= ~FILE_BUSY;
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(yyin);
+		yy_delete_buffer(YY_CURRENT_BUFFER);
+		yy_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+
+	return parent;
+}
+
+int zconf_lineno(void)
+{
+	if (current_buf)
+		return current_file->lineno;
+	else
+		return 0;
+}
+
+char *zconf_curname(void)
+{
+	if (current_buf)
+		return current_file->name;
+	else
+		return "<none>";
+}
diff --git a/scripts/config/lkc.h b/scripts/config/lkc.h
new file mode 100644
index 000000000..688945b87
--- /dev/null
+++ b/scripts/config/lkc.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#ifndef LKC_H
+#define LKC_H
+
+#include "expr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef LKC_DIRECT_LINK
+#define P(name,type,arg)	extern type name arg
+#else
+#include "lkc_defs.h"
+#define P(name,type,arg)	extern type (*name ## _p) arg
+#endif
+#include "lkc_proto.h"
+#undef P
+
+void symbol_end(char *help);
+int zconfparse(void);
+void zconfdump(FILE *out);
+
+extern int zconfdebug;
+void zconf_starthelp(void);
+void zconf_initscan(const char *name);
+void zconf_nextfile(const char *name);
+int zconf_lineno(void);
+char *zconf_curname(void);
+
+/* confdata.c */
+extern const char conf_def_filename[];
+extern char conf_filename[];
+
+char *conf_get_default_confname(void);
+
+/* kconfig_load.c */
+void kconfig_load(void);
+
+/* menu.c */
+void menu_init(void);
+void menu_add_menu(void);
+void menu_end_menu(void);
+void menu_add_entry(struct symbol *sym);
+void menu_end_entry(void);
+struct property *create_prop(enum prop_type type);
+void menu_add_dep(struct expr *dep);
+struct property *menu_add_prop(int token, char *prompt, struct symbol *def, struct expr *dep);
+void menu_finalize(struct menu *parent);
+void menu_set_type(int type);
+struct file *file_lookup(const char *name);
+int file_write_dep(const char *name);
+
+extern struct menu *current_entry;
+extern struct menu *current_menu;
+
+/* symbol.c */
+void sym_init(void);
+void sym_clear_all_valid(void);
+
+static inline tristate sym_get_tristate_value(struct symbol *sym)
+{
+	return S_TRI(sym->curr);
+}
+
+
+static inline struct symbol *sym_get_choice_value(struct symbol *sym)
+{
+	return (struct symbol *)S_VAL(sym->curr);
+}
+
+static inline bool sym_set_choice_value(struct symbol *ch, struct symbol *chval)
+{
+	return sym_set_tristate_value(chval, yes);
+}
+
+static inline bool sym_is_choice(struct symbol *sym)
+{
+	return sym->flags & SYMBOL_CHOICE ? true : false;
+}
+
+static inline bool sym_is_choice_value(struct symbol *sym)
+{
+	return sym->flags & SYMBOL_CHOICEVAL ? true : false;
+}
+
+static inline bool sym_is_optional(struct symbol *sym)
+{
+	return sym->flags & SYMBOL_OPTIONAL ? true : false;
+}
+
+static inline bool sym_has_value(struct symbol *sym)
+{
+	//return S_VAL(sym->def) != NULL;
+	return sym->flags & SYMBOL_NEW ? false : true;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LKC_H */
diff --git a/scripts/config/lkc_proto.h b/scripts/config/lkc_proto.h
new file mode 100644
index 000000000..116d7593b
--- /dev/null
+++ b/scripts/config/lkc_proto.h
@@ -0,0 +1,38 @@
+
+/* confdata.c */
+P(conf_parse,void,(const char *name));
+P(conf_read,int,(const char *name));
+P(conf_write,int,(const char *name));
+
+/* menu.c */
+P(rootmenu,struct menu,);
+
+P(menu_is_visible,bool,(struct menu *menu));
+P(menu_get_prompt,const char *,(struct menu *menu));
+P(menu_get_root_menu,struct menu *,(struct menu *menu));
+P(menu_get_parent_menu,struct menu *,(struct menu *menu));
+
+/* symbol.c */
+P(symbol_hash,struct symbol *,[SYMBOL_HASHSIZE]);
+P(sym_change_count,int,);
+
+P(sym_lookup,struct symbol *,(const char *name, int isconst));
+P(sym_find,struct symbol *,(const char *name));
+P(sym_type_name,const char *,(int type));
+P(sym_calc_value,void,(struct symbol *sym));
+P(sym_get_type,int,(struct symbol *sym));
+P(sym_tristate_within_range,bool,(struct symbol *sym,tristate tri));
+P(sym_set_tristate_value,bool,(struct symbol *sym,tristate tri));
+P(sym_toggle_tristate_value,tristate,(struct symbol *sym));
+P(sym_string_valid,bool,(struct symbol *sym, const char *newval));
+P(sym_set_string_value,bool,(struct symbol *sym, const char *newval));
+P(sym_is_changable,bool,(struct symbol *sym));
+P(sym_get_choice_prop,struct property *,(struct symbol *sym));
+P(sym_get_default_prop,struct property *,(struct symbol *sym));
+P(sym_get_string_value,const char *,(struct symbol *sym));
+
+P(prop_get_type_name,const char *,(enum prop_type type));
+
+/* expr.c */
+P(expr_compare_type,int,(enum expr_type t1, enum expr_type t2));
+P(expr_print,void,(struct expr *e, void (*fn)(void *, const char *), void *data, int prevtoken));
diff --git a/scripts/config/mconf.c b/scripts/config/mconf.c
new file mode 100644
index 000000000..476e78adc
--- /dev/null
+++ b/scripts/config/mconf.c
@@ -0,0 +1,669 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ *
+ * Introduced single menu mode (show all sub-menus in one large tree).
+ * 2002-11-06 Petr Baudis <pasky@ucw.cz>
+ *
+ * Directly use liblxdialog library routines.
+ * 2002-11-14 Petr Baudis <pasky@ucw.cz>
+ */
+
+#include <sys/ioctl.h>
+#include <sys/wait.h>
+#include <sys/termios.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include "dialog.h"
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+static const char menu_instructions[] =
+	"Arrow keys navigate the menu.  "
+	"<Enter> selects submenus --->.  "
+	"Highlighted letters are hotkeys.  "
+	"Pressing <Y> selectes a feature, while <N> will exclude a feature.  "
+	"Press <Esc><Esc> to exit, <?> for Help.  "
+	"Legend: [*] feature is selected  [ ] feature is excluded",
+radiolist_instructions[] =
+	"Use the arrow keys to navigate this window or "
+	"press the hotkey of the item you wish to select "
+	"followed by the <SPACE BAR>. "
+	"Press <?> for additional information about this option.",
+inputbox_instructions_int[] =
+	"Please enter a decimal value. "
+	"Fractions will not be accepted.  "
+	"Use the <TAB> key to move from the input field to the buttons below it.",
+inputbox_instructions_hex[] =
+	"Please enter a hexadecimal value. "
+	"Use the <TAB> key to move from the input field to the buttons below it.",
+inputbox_instructions_string[] =
+	"Please enter a string value. "
+	"Use the <TAB> key to move from the input field to the buttons below it.",
+setmod_text[] =
+	"This feature depends on another which has been configured as a module.\n"
+	"As a result, this feature will be built as a module.",
+nohelp_text[] =
+	"There is no help available for this option.\n",
+load_config_text[] =
+	"Enter the name of the configuration file you wish to load.  "
+	"Accept the name shown to restore the configuration you "
+	"last retrieved.  Leave blank to abort.",
+load_config_help[] =
+	"\n"
+	"For various reasons, one may wish to keep several different BusyBox\n"
+	"configurations available on a single machine.\n"
+	"\n"
+	"If you have saved a previous configuration in a file other than the\n"
+	"BusyBox default, entering the name of the file here will allow you\n"
+	"to modify that configuration.\n"
+	"\n"
+	"If you are uncertain, then you have probably never used alternate\n"
+	"configuration files.  You should therefor leave this blank to abort.\n",
+save_config_text[] =
+	"Enter a filename to which this configuration should be saved "
+	"as an alternate.  Leave blank to abort.",
+save_config_help[] =
+	"\n"
+	"For various reasons, one may wish to keep different BusyBox\n"
+	"configurations available on a single machine.\n"
+	"\n"
+	"Entering a file name here will allow you to later retrieve, modify\n"
+	"and use the current configuration as an alternate to whatever\n"
+	"configuration options you have selected at that time.\n"
+	"\n"
+	"If you are uncertain what all this means then you should probably\n"
+	"leave this blank.\n"
+;
+
+static char filename[PATH_MAX+1] = ".config";
+static int indent = 0;
+static struct termios ios_org;
+static int rows, cols;
+static struct menu *current_menu;
+static int child_count;
+static int single_menu_mode;
+
+static struct dialog_list_item *items[16384]; /* FIXME: This ought to be dynamic. */
+static int item_no;
+
+static void conf(struct menu *menu);
+static void conf_choice(struct menu *menu);
+static void conf_string(struct menu *menu);
+static void conf_load(void);
+static void conf_save(void);
+static void show_textbox(const char *title, const char *text, int r, int c);
+static void show_helptext(const char *title, const char *text);
+static void show_help(struct menu *menu);
+static void show_readme(void);
+
+static void init_wsize(void)
+{
+	struct winsize ws;
+
+	if (ioctl(1, TIOCGWINSZ, &ws) == -1) {
+		rows = 24;
+		cols = 80;
+	} else {
+		rows = ws.ws_row;
+		cols = ws.ws_col;
+	}
+
+	if (rows < 19 || cols < 80) {
+		fprintf(stderr, "Your display is too small to run Menuconfig!\n");
+		fprintf(stderr, "It must be at least 19 lines by 80 columns.\n");
+		exit(1);
+	}
+
+	rows -= 4;
+	cols -= 5;
+}
+
+static void cinit(void)
+{
+	item_no = 0;
+}
+
+static void cmake(void)
+{
+	items[item_no] = malloc(sizeof(struct dialog_list_item));
+	memset(items[item_no], 0, sizeof(struct dialog_list_item));
+	items[item_no]->tag = malloc(32); items[item_no]->tag[0] = 0;
+	items[item_no]->name = malloc(512); items[item_no]->name[0] = 0;
+	items[item_no]->namelen = 0;
+	item_no++;
+}
+  
+static int cprint_name(const char *fmt, ...)
+{
+	va_list ap;
+	int res;
+
+	if (!item_no)
+		cmake();
+	va_start(ap, fmt);
+	res = vsnprintf(items[item_no - 1]->name + items[item_no - 1]->namelen,
+			512 - items[item_no - 1]->namelen, fmt, ap);
+	if (res > 0)
+		items[item_no - 1]->namelen += res;
+	va_end(ap);
+
+	return res;
+}
+  
+static int cprint_tag(const char *fmt, ...)
+{
+	va_list ap;
+	int res;
+
+	if (!item_no)
+		cmake();
+	va_start(ap, fmt);
+	res = vsnprintf(items[item_no - 1]->tag, 32, fmt, ap);
+	va_end(ap);
+
+	return res;
+}
+  
+static void cdone(void)
+{
+	int i;
+
+	for (i = 0; i < item_no; i++) {
+		free(items[i]->tag);
+		free(items[i]->name);
+		free(items[i]);
+	}
+
+	item_no = 0;
+}
+
+static void build_conf(struct menu *menu)
+{
+	struct symbol *sym;
+	struct property *prop;
+	struct menu *child;
+	int type, tmp, doint = 2;
+	tristate val;
+	char ch;
+
+	if (!menu_is_visible(menu))
+		return;
+
+	sym = menu->sym;
+	prop = menu->prompt;
+	if (!sym) {
+		if (prop && menu != current_menu) {
+			const char *prompt = menu_get_prompt(menu);
+			switch (prop->type) {
+			case P_MENU:
+				child_count++;
+				cmake();
+				cprint_tag("m%p", menu);
+
+				if (single_menu_mode) {
+					cprint_name("%s%*c%s",
+						menu->data ? "-->" : "++>",
+						indent + 1, ' ', prompt);
+				} else {
+					if (menu->parent != &rootmenu)
+						cprint_name("   %*c", indent + 1, ' ');
+					cprint_name("%s  --->", prompt);
+				}
+
+				if (single_menu_mode && menu->data)
+					goto conf_childs;
+				return;
+			default:
+				if (prompt) {
+					child_count++;
+					cmake();
+					cprint_tag(":%p", menu);
+					cprint_name("---%*c%s", indent + 1, ' ', prompt);
+				}
+			}
+		} else
+			doint = 0;
+		goto conf_childs;
+	}
+
+	cmake();
+	type = sym_get_type(sym);
+	if (sym_is_choice(sym)) {
+		struct symbol *def_sym = sym_get_choice_value(sym);
+		struct menu *def_menu = NULL;
+
+		child_count++;
+		for (child = menu->list; child; child = child->next) {
+			if (menu_is_visible(child) && child->sym == def_sym)
+				def_menu = child;
+		}
+
+		val = sym_get_tristate_value(sym);
+		if (sym_is_changable(sym)) {
+			cprint_tag("t%p", menu);
+			switch (type) {
+			case S_BOOLEAN:
+				cprint_name("[%c]", val == no ? ' ' : '*');
+				break;
+			case S_TRISTATE:
+				switch (val) {
+				case yes: ch = '*'; break;
+				case mod: ch = 'M'; break;
+				default:  ch = ' '; break;
+				}
+				cprint_name("<%c>", ch);
+				break;
+			}
+		} else {
+			cprint_tag("%c%p", def_menu ? 't' : ':', menu);
+			cprint_name("   ");
+		}
+
+		cprint_name("%*c%s", indent + 1, ' ', menu_get_prompt(menu));
+		if (val == yes) {
+			if (def_menu) {
+				cprint_name(" (%s)", menu_get_prompt(def_menu));
+				cprint_name("  --->");
+				if (def_menu->list) {
+					indent += 2;
+					build_conf(def_menu);
+					indent -= 2;
+				}
+			}
+			return;
+		}
+	} else {
+		child_count++;
+		val = sym_get_tristate_value(sym);
+		if (sym_is_choice_value(sym) && val == yes) {
+			cprint_tag(":%p", menu);
+			cprint_name("   ");
+		} else {
+			switch (type) {
+			case S_BOOLEAN:
+				cprint_tag("t%p", menu);
+				cprint_name("[%c]", val == no ? ' ' : '*');
+				break;
+			case S_TRISTATE:
+				cprint_tag("t%p", menu);
+				switch (val) {
+				case yes: ch = '*'; break;
+				case mod: ch = 'M'; break;
+				default:  ch = ' '; break;
+				}
+				cprint_name("<%c>", ch);
+				break;
+			default:
+				cprint_tag("s%p", menu);
+				tmp = cprint_name("(%s)", sym_get_string_value(sym));
+				tmp = indent - tmp + 4;
+				if (tmp < 0)
+					tmp = 0;
+				cprint_name("%*c%s%s", tmp, ' ', menu_get_prompt(menu),
+					sym_has_value(sym) ? "" : " (NEW)");
+				goto conf_childs;
+			}
+		}
+		cprint_name("%*c%s%s", indent + 1, ' ', menu_get_prompt(menu),
+			sym_has_value(sym) ? "" : " (NEW)");
+	}
+
+conf_childs:
+	indent += doint;
+	for (child = menu->list; child; child = child->next)
+		build_conf(child);
+	indent -= doint;
+}
+
+static void conf(struct menu *menu)
+{
+	struct dialog_list_item *active_item = NULL;
+	struct menu *submenu;
+	const char *prompt = menu_get_prompt(menu);
+	struct symbol *sym;
+	char active_entry[40];
+	int stat, type;
+
+	unlink("lxdialog.scrltmp");
+	active_entry[0] = 0;
+	while (1) {
+		indent = 0;
+		child_count = 0;
+  		current_menu = menu;
+		cdone(); cinit();
+		build_conf(menu);
+		if (!child_count)
+			break;
+		if (menu == &rootmenu) {
+			cmake(); cprint_tag(":"); cprint_name("--- ");
+			cmake(); cprint_tag("L"); cprint_name("Load an Alternate Configuration File");
+			cmake(); cprint_tag("S"); cprint_name("Save Configuration to an Alternate File");
+		}
+		dialog_clear();
+		stat = dialog_menu(prompt ? prompt : "Main Menu",
+				menu_instructions, rows, cols, rows - 10,
+				active_entry, item_no, items);
+		if (stat < 0)
+			return;
+
+		if (stat == 1 || stat == 255)
+			break;
+
+		active_item = first_sel_item(item_no, items);
+		if (!active_item)
+			continue;
+		active_item->selected = 0;
+		strncpy(active_entry, active_item->tag, sizeof(active_entry));
+		active_entry[sizeof(active_entry)-1] = 0;
+		type = active_entry[0];
+		if (!type)
+			continue;
+
+		sym = NULL;
+		submenu = NULL;
+		if (sscanf(active_entry + 1, "%p", &submenu) == 1)
+			sym = submenu->sym;
+
+		switch (stat) {
+		case 0:
+			switch (type) {
+			case 'm':
+				if (single_menu_mode)
+					submenu->data = (submenu->data)? NULL : (void *)1;
+				else
+					conf(submenu);
+				break;
+			case 't':
+				if (sym_is_choice(sym) && sym_get_tristate_value(sym) == yes)
+					conf_choice(submenu);
+				break;
+			case 's':
+				conf_string(submenu);
+				break;
+			case 'L':
+				conf_load();
+				break;
+			case 'S':
+				conf_save();
+				break;
+			}
+			break;
+		case 2:
+			if (sym)
+				show_help(submenu);
+			else
+				show_readme();
+			break;
+		case 3:
+			if (type == 't') {
+				if (sym_set_tristate_value(sym, yes))
+					break;
+				if (sym_set_tristate_value(sym, mod))
+					show_textbox(NULL, setmod_text, 6, 74);
+			}
+			break;
+		case 4:
+			if (type == 't')
+				sym_set_tristate_value(sym, no);
+			break;
+		case 5:
+			if (type == 't')
+				sym_set_tristate_value(sym, mod);
+			break;
+		case 6:
+			if (type == 't')
+				sym_toggle_tristate_value(sym);
+			else if (type == 'm')
+				conf(submenu);
+			break;
+		}
+	}
+}
+
+static void show_textbox(const char *title, const char *text, int r, int c)
+{
+	int fd;
+
+	fd = creat(".help.tmp", 0777);
+	write(fd, text, strlen(text));
+	close(fd);
+	while (dialog_textbox(title, ".help.tmp", r, c) < 0)
+		;
+	unlink(".help.tmp");
+}
+
+static void show_helptext(const char *title, const char *text)
+{
+	show_textbox(title, text, rows, cols);
+}
+
+static void show_help(struct menu *menu)
+{
+	const char *help;
+	char *helptext;
+	struct symbol *sym = menu->sym;
+
+	help = sym->help;
+	if (!help)
+		help = nohelp_text;
+	if (sym->name) {
+		helptext = malloc(strlen(sym->name) + strlen(help) + 16);
+		sprintf(helptext, "%s:\n\n%s", sym->name, help);
+		show_helptext(menu_get_prompt(menu), helptext);
+		free(helptext);
+	} else
+		show_helptext(menu_get_prompt(menu), help);
+}
+
+static void show_readme(void)
+{
+	while (dialog_textbox(NULL, "scripts/README.Menuconfig", rows, cols) < 0)
+		;
+}
+
+static void conf_choice(struct menu *menu)
+{
+	const char *prompt = menu_get_prompt(menu);
+	struct menu *child;
+	struct symbol *active;
+
+	while (1) {
+		current_menu = menu;
+		active = sym_get_choice_value(menu->sym);
+		cdone(); cinit();
+		for (child = menu->list; child; child = child->next) {
+			if (!menu_is_visible(child))
+				continue;
+			cmake();
+			cprint_tag("%p", child);
+			cprint_name("%s", menu_get_prompt(child));
+			items[item_no - 1]->selected = (child->sym == active);
+		}
+
+		switch (dialog_checklist(prompt ? prompt : "Main Menu",
+					radiolist_instructions, 15, 70, 6,
+					item_no, items, FLAG_RADIO)) {
+		case 0:
+			if (sscanf(first_sel_item(item_no, items)->tag, "%p", &menu) != 1)
+				break;
+			sym_set_tristate_value(menu->sym, yes);
+			return;
+		case 1:
+			show_help(menu);
+			break;
+		case 255:
+			return;
+		}
+	}
+}
+
+static void conf_string(struct menu *menu)
+{
+	const char *prompt = menu_get_prompt(menu);
+
+	while (1) {
+		char *heading;
+
+		switch (sym_get_type(menu->sym)) {
+		case S_INT:
+			heading = (char *) inputbox_instructions_int;
+			break;
+		case S_HEX:
+			heading = (char *) inputbox_instructions_hex;
+			break;
+		case S_STRING:
+			heading = (char *) inputbox_instructions_string;
+			break;
+		default:
+			heading = "Internal mconf error!";
+			/* panic? */;
+		}
+
+		switch (dialog_inputbox(prompt ? prompt : "Main Menu",
+					heading, 10, 75,
+					sym_get_string_value(menu->sym))) {
+		case 0:
+			if (sym_set_string_value(menu->sym, dialog_input_result))
+				return;
+			show_textbox(NULL, "You have made an invalid entry.", 5, 43);
+			break;
+		case 1:
+			show_help(menu);
+			break;
+		case 255:
+			return;
+		}
+	}
+}
+
+static void conf_load(void)
+{
+	while (1) {
+		switch (dialog_inputbox(NULL, load_config_text, 11, 55,
+					filename)) {
+		case 0:
+			if (!dialog_input_result[0])
+				return;
+			if (!conf_read(dialog_input_result))
+				return;
+			show_textbox(NULL, "File does not exist!", 5, 38);
+			break;
+		case 1:
+			show_helptext("Load Alternate Configuration", load_config_help);
+			break;
+		case 255:
+			return;
+		}
+	}
+}
+
+static void conf_save(void)
+{
+	while (1) {
+		switch (dialog_inputbox(NULL, save_config_text, 11, 55,
+					filename)) {
+		case 0:
+			if (!dialog_input_result[0])
+				return;
+			if (!conf_write(dialog_input_result))
+				return;
+			show_textbox(NULL, "Can't create file!  Probably a nonexistent directory.", 5, 60);
+			break;
+		case 1:
+			show_helptext("Save Alternate Configuration", save_config_help);
+			break;
+		case 255:
+			return;
+		}
+	}
+}
+
+static void conf_cleanup(void)
+{
+	tcsetattr(1, TCSAFLUSH, &ios_org);
+	unlink(".help.tmp");
+	unlink("lxdialog.scrltmp");
+}
+
+static void winch_handler(int sig)
+{
+	struct winsize ws;
+
+	if (ioctl(1, TIOCGWINSZ, &ws) == -1) {
+		rows = 24;
+		cols = 80;
+	} else {
+		rows = ws.ws_row;
+		cols = ws.ws_col;
+	}
+
+	if (rows < 19 || cols < 80) {
+		end_dialog();
+		fprintf(stderr, "Your display is too small to run Menuconfig!\n");
+		fprintf(stderr, "It must be at least 19 lines by 80 columns.\n");
+		exit(1);
+	}
+
+	rows -= 4;
+	cols -= 5;
+
+}
+
+int main(int ac, char **av)
+{
+	int stat;
+	char *mode;
+	struct symbol *sym;
+
+	conf_parse(av[1]);
+	conf_read(NULL);
+
+	backtitle = malloc(128);
+	sym = sym_lookup("VERSION", 0);
+	sym_calc_value(sym);
+	snprintf(backtitle, 128, "BusyBox v%s Configuration",
+		sym_get_string_value(sym));
+
+	mode = getenv("MENUCONFIG_MODE");
+	if (mode) {
+		if (!strcasecmp(mode, "single_menu"))
+			single_menu_mode = 1;
+	}
+  
+	tcgetattr(1, &ios_org);
+	atexit(conf_cleanup);
+	init_wsize();
+	init_dialog();
+	signal(SIGWINCH, winch_handler); 
+	conf(&rootmenu);
+	end_dialog();
+
+	/* Restart dialog to act more like when lxdialog was still separate */
+	init_dialog();
+	do {
+		stat = dialog_yesno(NULL, 
+				"Do you wish to save your new BusyBox configuration?", 5, 60);
+	} while (stat < 0);
+	end_dialog();
+
+	if (stat == 0) {
+		conf_write(NULL);
+		printf("\n\n"
+			"*** End of BusyBox configuration.\n"
+			"*** Check the top-level Makefile for additional configuration options.\n\n");
+	} else
+		printf("\n\nYour BusyBox configuration changes were NOT saved.\n\n");
+
+	return 0;
+}
diff --git a/scripts/config/menu.c b/scripts/config/menu.c
new file mode 100644
index 000000000..3d3b4d19c
--- /dev/null
+++ b/scripts/config/menu.c
@@ -0,0 +1,309 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+struct menu rootmenu;
+struct menu *current_menu, *current_entry;
+static struct menu **last_entry_ptr;
+
+struct file *file_list;
+struct file *current_file;
+
+void menu_init(void)
+{
+	current_entry = current_menu = &rootmenu;
+	last_entry_ptr = &rootmenu.list;
+}
+
+void menu_add_entry(struct symbol *sym)
+{
+	struct menu *menu;
+
+	menu = malloc(sizeof(*menu));
+	memset(menu, 0, sizeof(*menu));
+	menu->sym = sym;
+	menu->parent = current_menu;
+	menu->file = current_file;
+	menu->lineno = zconf_lineno();
+
+	*last_entry_ptr = menu;
+	last_entry_ptr = &menu->next;
+	current_entry = menu;
+}
+
+void menu_end_entry(void)
+{
+}
+
+void menu_add_menu(void)
+{
+	current_menu = current_entry;
+	last_entry_ptr = &current_entry->list;
+}
+
+void menu_end_menu(void)
+{
+	last_entry_ptr = &current_menu->next;
+	current_menu = current_menu->parent;
+}
+
+void menu_add_dep(struct expr *dep)
+{
+	current_entry->dep = expr_alloc_and(current_entry->dep, dep);
+}
+
+void menu_set_type(int type)
+{
+	struct symbol *sym = current_entry->sym;
+
+	if (sym->type == type)
+		return;
+	if (sym->type == S_UNKNOWN) {
+		sym->type = type;
+		return;
+	}
+	fprintf(stderr, "%s:%d: type of '%s' redefined from '%s' to '%s'\n",
+		current_entry->file->name, current_entry->lineno,
+		sym->name ? sym->name : "<choice>", sym_type_name(sym->type), sym_type_name(type));
+}
+
+struct property *create_prop(enum prop_type type)
+{
+	struct property *prop;
+
+	prop = malloc(sizeof(*prop));
+	memset(prop, 0, sizeof(*prop));
+	prop->type = type;
+	prop->file = current_file;
+	prop->lineno = zconf_lineno();
+
+	return prop;
+}
+
+struct property *menu_add_prop(int token, char *prompt, struct symbol *def, struct expr *dep)
+{
+	struct property *prop = create_prop(token);
+	struct property **propp;
+
+	prop->sym = current_entry->sym;
+	prop->menu = current_entry;
+	prop->text = prompt;
+	prop->def = def;
+	E_EXPR(prop->visible) = dep;
+
+	if (prompt)
+		current_entry->prompt = prop;
+
+	/* append property to the prop list of symbol */
+	if (prop->sym) {
+		for (propp = &prop->sym->prop; *propp; propp = &(*propp)->next)
+			;
+		*propp = prop;
+	}
+
+	return prop;
+}
+
+void menu_add_prompt(int token, char *prompt, struct expr *dep)
+{
+	current_entry->prompt = menu_add_prop(token, prompt, NULL, dep);
+}
+
+void menu_add_default(int token, struct symbol *def, struct expr *dep)
+{
+	current_entry->prompt = menu_add_prop(token, NULL, def, dep);
+}
+
+void menu_finalize(struct menu *parent)
+{
+	struct menu *menu, *last_menu;
+	struct symbol *sym;
+	struct property *prop;
+	struct expr *parentdep, *basedep, *dep, *dep2;
+
+	sym = parent->sym;
+	if (parent->list) {
+		if (sym && sym_is_choice(sym)) {
+			/* find the first choice value and find out choice type */
+			for (menu = parent->list; menu; menu = menu->next) {
+				if (menu->sym) {
+					current_entry = parent;
+					menu_set_type(menu->sym->type);
+					current_entry = menu;
+					menu_set_type(sym->type);
+					break;
+				}
+			}
+			parentdep = expr_alloc_symbol(sym);
+		} else if (parent->prompt)
+			parentdep = E_EXPR(parent->prompt->visible);
+		else
+			parentdep = parent->dep;
+
+		for (menu = parent->list; menu; menu = menu->next) {
+			basedep = expr_transform(menu->dep);
+			basedep = expr_alloc_and(expr_copy(parentdep), basedep);
+			basedep = expr_eliminate_dups(basedep);
+			menu->dep = basedep;
+			if (menu->sym)
+				prop = menu->sym->prop;
+			else
+				prop = menu->prompt;
+			for (; prop; prop = prop->next) {
+				if (prop->menu != menu)
+					continue;
+				dep = expr_transform(E_EXPR(prop->visible));
+				dep = expr_alloc_and(expr_copy(basedep), dep);
+				dep = expr_eliminate_dups(dep);
+				if (menu->sym && menu->sym->type != S_TRISTATE)
+					dep = expr_trans_bool(dep);
+				E_EXPR(prop->visible) = dep;
+			}
+		}
+		for (menu = parent->list; menu; menu = menu->next)
+			menu_finalize(menu);
+	} else if (sym && parent->prompt) {
+		basedep = E_EXPR(parent->prompt->visible);
+		basedep = expr_trans_compare(basedep, E_UNEQUAL, &symbol_no);
+		basedep = expr_eliminate_dups(expr_transform(basedep));
+		last_menu = NULL;
+		for (menu = parent->next; menu; menu = menu->next) {
+			dep = menu->prompt ? E_EXPR(menu->prompt->visible) : menu->dep;
+			if (!expr_contains_symbol(dep, sym))
+				break;
+			if (expr_depends_symbol(dep, sym))
+				goto next;
+			dep = expr_trans_compare(dep, E_UNEQUAL, &symbol_no);
+			dep = expr_eliminate_dups(expr_transform(dep));
+			dep2 = expr_copy(basedep);
+			expr_eliminate_eq(&dep, &dep2);
+			expr_free(dep);
+			if (!expr_is_yes(dep2)) {
+				expr_free(dep2);
+				break;
+			}
+			expr_free(dep2);
+		next:
+			menu_finalize(menu);
+			menu->parent = parent;
+			last_menu = menu;
+		}
+		if (last_menu) {
+			parent->list = parent->next;
+			parent->next = last_menu->next;
+			last_menu->next = NULL;
+		}
+	}
+	for (menu = parent->list; menu; menu = menu->next) {
+		if (sym && sym_is_choice(sym) && menu->sym) {
+			menu->sym->flags |= SYMBOL_CHOICEVAL;
+			current_entry = menu;
+			menu_set_type(sym->type);
+			menu_add_prop(P_CHOICE, NULL, parent->sym, NULL);
+			prop = sym_get_choice_prop(parent->sym);
+			//dep = expr_alloc_one(E_CHOICE, dep);
+			//dep->right.sym = menu->sym;
+			prop->dep = expr_alloc_one(E_CHOICE, prop->dep);
+			prop->dep->right.sym = menu->sym;
+		}
+		if (menu->list && (!menu->prompt || !menu->prompt->text)) {
+			for (last_menu = menu->list; ; last_menu = last_menu->next) {
+				last_menu->parent = parent;
+				if (!last_menu->next)
+					break;
+			}
+			last_menu->next = menu->next;
+			menu->next = menu->list;
+			menu->list = NULL;
+		}
+	}
+}
+
+bool menu_is_visible(struct menu *menu)
+{
+	tristate visible;
+
+	if (!menu->prompt)
+		return false;
+	if (menu->sym) {
+		sym_calc_value(menu->sym);
+		visible = E_TRI(menu->prompt->visible);
+	} else
+		visible = E_CALC(menu->prompt->visible);
+	return visible != no;
+}
+
+const char *menu_get_prompt(struct menu *menu)
+{
+	if (menu->prompt)
+		return menu->prompt->text;
+	else if (menu->sym)
+		return menu->sym->name;
+	return NULL;
+}
+
+struct menu *menu_get_root_menu(struct menu *menu)
+{
+	return &rootmenu;
+}
+
+struct menu *menu_get_parent_menu(struct menu *menu)
+{
+	enum prop_type type;
+
+	while (menu != &rootmenu) {
+		menu = menu->parent;
+		type = menu->prompt ? menu->prompt->type : 0;
+		if (type == P_MENU || type == P_ROOTMENU)
+			break;
+	}
+	return menu;
+}
+
+struct file *file_lookup(const char *name)
+{
+	struct file *file;
+
+	for (file = file_list; file; file = file->next) {
+		if (!strcmp(name, file->name))
+			return file;
+	}
+
+	file = malloc(sizeof(*file));
+	memset(file, 0, sizeof(*file));
+	file->name = strdup(name);
+	file->next = file_list;
+	file_list = file;
+	return file;
+}
+
+int file_write_dep(const char *name)
+{
+	struct file *file;
+	FILE *out;
+
+	if (!name)
+		name = ".config.cmd";
+	out = fopen(".config.tmp", "w");
+	if (!out)
+		return 1;
+	fprintf(out, "deps_config := \\\n");
+	for (file = file_list; file; file = file->next) {
+		if (file->next)
+			fprintf(out, "\t%s \\\n", file->name);
+		else
+			fprintf(out, "\t%s\n", file->name);
+	}
+	fprintf(out, "\n.config include/config.h: $(deps_config)\n\n$(deps_config):\n");
+	fclose(out);
+	rename(".config.tmp", name);
+	return 0;
+}
+
diff --git a/scripts/lxdialog/menubox.c b/scripts/config/menubox.c
similarity index 86%
rename from scripts/lxdialog/menubox.c
rename to scripts/config/menubox.c
index a234e9f3b..b9cf4b6a3 100644
--- a/scripts/lxdialog/menubox.c
+++ b/scripts/config/menubox.c
@@ -93,7 +93,7 @@ print_item (WINDOW * win, const char *item, int choice, int selected, int hotkey
     }
     if (selected) {
 	wmove (win, choice, item_x+1);
-	wrefresh (win);
+	wnoutrefresh (win);
     }
 }
 
@@ -165,8 +165,7 @@ print_buttons (WINDOW *win, int height, int width, int selected)
 int
 dialog_menu (const char *title, const char *prompt, int height, int width,
 		int menu_height, const char *current, int item_no,
-		const char * const * items)
-
+		struct dialog_list_item ** items)
 {
     int i, j, x, y, box_x, box_y;
     int key = 0, button = 0, scroll = 0, choice = 0, first_item = 0, max_choice;
@@ -230,8 +229,8 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
      */
     item_x = 0;
     for (i = 0; i < item_no; i++) {
-	item_x = MAX (item_x, MIN(menu_width, strlen (items[i * 2 + 1]) + 2));
-	if (strcmp(current, items[i*2]) == 0) choice = i;
+	item_x = MAX (item_x, MIN(menu_width, strlen (items[i]->name) + 2));
+	if (strcmp(current, items[i]->tag) == 0) choice = i;
     }
 
     item_x = (menu_width - item_x) / 2;
@@ -261,8 +260,8 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 
     /* Print the menu */
     for (i=0; i < max_choice; i++) {
-	print_item (menu, items[(first_item + i) * 2 + 1], i, i == choice,
-                    (items[(first_item + i)*2][0] != ':'));
+	print_item (menu, items[first_item + i]->name, i, i == choice,
+                    (items[first_item + i]->tag[0] != ':'));
     }
 
     wnoutrefresh (menu);
@@ -283,14 +282,14 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 		i = max_choice;
 	else {
         for (i = choice+1; i < max_choice; i++) {
-		j = first_alpha(items[(scroll+i)*2+1], "YyNnMm");
-		if (key == tolower(items[(scroll+i)*2+1][j]))
+		j = first_alpha(items[scroll + i]->name, "YyNnMm>");
+		if (key == tolower(items[scroll + i]->name[j]))
                 	break;
 	}
 	if (i == max_choice)
        		for (i = 0; i < max_choice; i++) {
-			j = first_alpha(items[(scroll+i)*2+1], "YyNnMm");
-			if (key == tolower(items[(scroll+i)*2+1][j]))
+			j = first_alpha(items[scroll + i]->name, "YyNnMm>");
+			if (key == tolower(items[scroll + i]->name[j]))
                 		break;
 		}
 	}
@@ -300,8 +299,8 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
             key == '-' || key == '+' ||
             key == KEY_PPAGE || key == KEY_NPAGE) {
 
-            print_item (menu, items[(scroll+choice)*2+1], choice, FALSE,
-                       (items[(scroll+choice)*2][0] != ':'));
+            print_item (menu, items[scroll + choice]->name, choice, FALSE,
+                       (items[scroll + choice]->tag[0] != ':'));
 
 	    if (key == KEY_UP || key == '-') {
                 if (choice < 2 && scroll) {
@@ -312,15 +311,15 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 
                     scroll--;
 
-                    print_item (menu, items[scroll * 2 + 1], 0, FALSE,
-                               (items[scroll*2][0] != ':'));
+                    print_item (menu, items[scroll * 2]->name, 0, FALSE,
+                               (items[scroll * 2]->tag[0] != ':'));
 		} else
 		    choice = MAX(choice - 1, 0);
 
 	    } else if (key == KEY_DOWN || key == '+')  {
 
-		print_item (menu, items[(scroll+choice)*2+1], choice, FALSE,
-                                (items[(scroll+choice)*2][0] != ':'));
+		print_item (menu, items[scroll + choice]->name, choice, FALSE,
+                                (items[scroll + choice]->tag[0] != ':'));
 
                 if ((choice > max_choice-3) &&
                     (scroll + max_choice < item_no)
@@ -332,9 +331,9 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 
                     scroll++;
 
-                    print_item (menu, items[(scroll+max_choice-1)*2+1],
+                    print_item (menu, items[scroll + max_choice - 1]->name,
                                max_choice-1, FALSE,
-                               (items[(scroll+max_choice-1)*2][0] != ':'));
+                               (items[scroll + max_choice - 1]->tag[0] != ':'));
                 } else
                     choice = MIN(choice+1, max_choice-1);
 
@@ -344,8 +343,8 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
                     if (scroll > 0) {
                 	wscrl (menu, -1);
                 	scroll--;
-                	print_item (menu, items[scroll * 2 + 1], 0, FALSE,
-                	(items[scroll*2][0] != ':'));
+                	print_item (menu, items[scroll * 2]->name, 0, FALSE,
+                	(items[scroll * 2]->tag[0] != ':'));
                     } else {
                         if (choice > 0)
                             choice--;
@@ -360,9 +359,9 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 			scroll(menu);
 			scrollok (menu, FALSE);
                 	scroll++;
-                	print_item (menu, items[(scroll+max_choice-1)*2+1],
+                	print_item (menu, items[scroll + max_choice - 1]->name,
 			            max_choice-1, FALSE,
-			            (items[(scroll+max_choice-1)*2][0] != ':'));
+			            (items[scroll + max_choice - 1]->tag[0] != ':'));
 		    } else {
 			if (choice+1 < max_choice)
 			    choice++;
@@ -372,8 +371,8 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
             } else
                 choice = i;
 
-            print_item (menu, items[(scroll+choice)*2+1], choice, TRUE,
-                       (items[(scroll+choice)*2][0] != ':'));
+            print_item (menu, items[scroll + choice]->name, choice, TRUE,
+                       (items[scroll + choice]->tag[0] != ':'));
 
             print_arrows(dialog, item_no, scroll,
                          box_y, box_x+item_x+1, menu_height);
@@ -405,7 +404,7 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 		fclose(f);
 	    }
 	    delwin (dialog);
-            fprintf(stderr, "%s\n", items[(scroll + choice) * 2]);
+            items[scroll + choice]->selected = 1;
             switch (key) {
             case 's': return 3;
             case 'y': return 3;
@@ -419,13 +418,7 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 	    button = 2;
 	case '\n':
 	    delwin (dialog);
-	    if (button == 2) 
-            	fprintf(stderr, "%s \"%s\"\n", 
-			items[(scroll + choice) * 2],
-			items[(scroll + choice) * 2 + 1] +
-			first_alpha(items[(scroll + choice) * 2 + 1],""));
-	    else
-            	fprintf(stderr, "%s\n", items[(scroll + choice) * 2]);
+	    items[scroll + choice]->selected = 1;
 
 	    remove("lxdialog.scrltmp");
 	    return button;
diff --git a/scripts/lxdialog/msgbox.c b/scripts/config/msgbox.c
similarity index 100%
rename from scripts/lxdialog/msgbox.c
rename to scripts/config/msgbox.c
diff --git a/scripts/config/symbol.c b/scripts/config/symbol.c
new file mode 100644
index 000000000..f2d0015de
--- /dev/null
+++ b/scripts/config/symbol.c
@@ -0,0 +1,629 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/utsname.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+struct symbol symbol_yes = {
+	name: "y",
+	curr: { "y", yes },
+	flags: SYMBOL_YES|SYMBOL_VALID,
+}, symbol_mod = {
+	name: "m",
+	curr: { "m", mod },
+	flags: SYMBOL_MOD|SYMBOL_VALID,
+}, symbol_no = {
+	name: "n",
+	curr: { "n", no },
+	flags: SYMBOL_NO|SYMBOL_VALID,
+}, symbol_empty = {
+	name: "",
+	curr: { "", no },
+	flags: SYMBOL_VALID,
+};
+
+int sym_change_count;
+struct symbol *modules_sym;
+
+void sym_add_default(struct symbol *sym, const char *def)
+{
+	struct property *prop = create_prop(P_DEFAULT);
+	struct property **propp;
+
+	prop->sym = sym;
+	prop->def = sym_lookup(def, 1);
+
+	/* append property to the prop list of symbol */
+	if (prop->sym) {
+		for (propp = &prop->sym->prop; *propp; propp = &(*propp)->next)
+			;
+		*propp = prop;
+	}
+}
+
+void sym_init(void)
+{
+	struct symbol *sym;
+	struct utsname uts;
+	char *p;
+	static bool inited = false;
+
+	if (inited)
+		return;
+	inited = true;
+
+	uname(&uts);
+
+#if 0
+	sym = sym_lookup("ARCH", 0);
+	sym->type = S_STRING;
+	sym->flags |= SYMBOL_AUTO;
+	p = getenv("ARCH");
+	if (p)
+		sym_add_default(sym, p);
+#endif
+
+	sym = sym_lookup("VERSION", 0);
+	sym->type = S_STRING;
+	sym->flags |= SYMBOL_AUTO;
+	p = getenv("VERSION");
+	if (p)
+		sym_add_default(sym, p);
+
+#if 0
+	sym = sym_lookup("UNAME_RELEASE", 0);
+	sym->type = S_STRING;
+	sym->flags |= SYMBOL_AUTO;
+	sym_add_default(sym, uts.release);
+#endif
+
+	sym = sym_lookup("TARGET_ARCH", 0);
+	sym->type = S_STRING;
+	sym->flags |= SYMBOL_AUTO;
+	p = getenv("TARGET_ARCH");
+	if (p)
+		sym_add_default(sym, p);
+}
+
+int sym_get_type(struct symbol *sym)
+{
+	int type = sym->type;
+	if (type == S_TRISTATE) {
+		if (sym_is_choice_value(sym) && sym->visible == yes)
+			type = S_BOOLEAN;
+		else {
+			sym_calc_value(modules_sym);
+			if (S_TRI(modules_sym->curr) == no)
+				type = S_BOOLEAN;
+		}
+	}
+	return type;
+}
+
+const char *sym_type_name(int type)
+{
+	switch (type) {
+	case S_BOOLEAN:
+		return "boolean";
+	case S_TRISTATE:
+		return "tristate";
+	case S_INT:
+		return "integer";
+	case S_HEX:
+		return "hex";
+	case S_STRING:
+		return "string";
+	case S_UNKNOWN:
+		return "unknown";
+	}
+	return "???";
+}
+
+struct property *sym_get_choice_prop(struct symbol *sym)
+{
+	struct property *prop;
+
+	for_all_choices(sym, prop)
+		return prop;
+	return NULL;
+}
+
+struct property *sym_get_default_prop(struct symbol *sym)
+{
+	struct property *prop;
+	tristate visible;
+
+	for_all_defaults(sym, prop) {
+		visible = E_CALC(prop->visible);
+		if (visible != no)
+			return prop;
+	}
+	return NULL;
+}
+
+void sym_calc_visibility(struct symbol *sym)
+{
+	struct property *prop;
+	tristate visible, oldvisible;
+
+	/* any prompt visible? */
+	oldvisible = sym->visible;
+	visible = no;
+	for_all_prompts(sym, prop)
+		visible = E_OR(visible, E_CALC(prop->visible));
+	if (oldvisible != visible) {
+		sym->visible = visible;
+		sym->flags |= SYMBOL_CHANGED;
+	}
+}
+
+void sym_calc_value(struct symbol *sym)
+{
+	struct symbol_value newval, oldval;
+	struct property *prop, *def_prop;
+	struct symbol *def_sym;
+	struct expr *e;
+
+	if (sym->flags & SYMBOL_VALID)
+		return;
+
+	oldval = sym->curr;
+
+	switch (sym->type) {
+	case S_INT:
+	case S_HEX:
+	case S_STRING:
+		newval = symbol_empty.curr;
+		break;
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		newval = symbol_no.curr;
+		break;
+	default:
+		S_VAL(newval) = sym->name;
+		S_TRI(newval) = no;
+		if (sym->flags & SYMBOL_CONST) {
+			goto out;
+		}
+		//newval = symbol_empty.curr;
+		// generate warning somewhere here later
+		//S_TRI(newval) = yes;
+		goto out;
+	}
+	sym->flags |= SYMBOL_VALID;
+	if (!sym_is_choice_value(sym))
+		sym->flags &= ~SYMBOL_WRITE;
+
+	sym_calc_visibility(sym);
+
+	/* set default if recursively called */
+	sym->curr = newval;
+
+	if (sym->visible != no) {
+		sym->flags |= SYMBOL_WRITE;
+		if (!sym_has_value(sym)) {
+			if (!sym_is_choice(sym)) {
+				prop = sym_get_default_prop(sym);
+				if (prop) {
+					sym_calc_value(prop->def);
+					newval = prop->def->curr;
+				}
+			}
+		} else
+			newval = sym->def;
+
+		S_TRI(newval) = E_AND(S_TRI(newval), sym->visible);
+		/* if the symbol is visible and not optionial,
+		 * possibly ignore old user choice. */
+		if (!sym_is_optional(sym) && S_TRI(newval) == no)
+			S_TRI(newval) = sym->visible;
+		if (sym_is_choice_value(sym) && sym->visible == yes) {
+			prop = sym_get_choice_prop(sym);
+			S_TRI(newval) = (S_VAL(prop->def->curr) == sym) ? yes : no;
+		}
+	} else {
+		prop = sym_get_default_prop(sym);
+		if (prop) {
+			sym->flags |= SYMBOL_WRITE;
+			sym_calc_value(prop->def);
+			newval = prop->def->curr;
+		}
+	}
+
+	switch (sym_get_type(sym)) {
+	case S_TRISTATE:
+		if (S_TRI(newval) != mod)
+			break;
+		sym_calc_value(modules_sym);
+		if (S_TRI(modules_sym->curr) == no)
+			S_TRI(newval) = yes;
+		break;
+	case S_BOOLEAN:
+		if (S_TRI(newval) == mod)
+			S_TRI(newval) = yes;
+	}
+
+out:
+	sym->curr = newval;
+
+	if (sym_is_choice(sym) && S_TRI(newval) == yes) {
+		def_sym = S_VAL(sym->def);
+		if (def_sym) {
+			sym_calc_visibility(def_sym);
+			if (def_sym->visible == no)
+				def_sym = NULL;
+		}
+		if (!def_sym) {
+			for_all_defaults(sym, def_prop) {
+				if (E_CALC(def_prop->visible) == no)
+					continue;
+				sym_calc_visibility(def_prop->def);
+				if (def_prop->def->visible != no) {
+					def_sym = def_prop->def;
+					break;
+				}
+			}
+		}
+
+		if (!def_sym) {
+			prop = sym_get_choice_prop(sym);
+			for (e = prop->dep; e; e = e->left.expr) {
+				sym_calc_visibility(e->right.sym);
+				if (e->right.sym->visible != no) {
+					def_sym = e->right.sym;
+					break;
+				}
+			}
+		}
+
+		S_VAL(newval) = def_sym;
+	}
+
+	if (memcmp(&oldval, &newval, sizeof(newval)))
+		sym->flags |= SYMBOL_CHANGED;
+	sym->curr = newval;
+
+	if (sym_is_choice(sym)) {
+		int flags = sym->flags & (SYMBOL_CHANGED | SYMBOL_WRITE);
+		prop = sym_get_choice_prop(sym);
+		for (e = prop->dep; e; e = e->left.expr)
+			e->right.sym->flags |= flags;
+	}
+}
+
+void sym_clear_all_valid(void)
+{
+	struct symbol *sym;
+	int i;
+
+	for_all_symbols(i, sym)
+		sym->flags &= ~SYMBOL_VALID;
+	sym_change_count++;
+}
+
+void sym_set_all_changed(void)
+{
+	struct symbol *sym;
+	int i;
+
+	for_all_symbols(i, sym)
+		sym->flags |= SYMBOL_CHANGED;
+}
+
+bool sym_tristate_within_range(struct symbol *sym, tristate val)
+{
+	int type = sym_get_type(sym);
+
+	if (sym->visible == no)
+		return false;
+
+	if (type != S_BOOLEAN && type != S_TRISTATE)
+		return false;
+
+	switch (val) {
+	case no:
+		if (sym_is_choice_value(sym) && sym->visible == yes)
+			return false;
+		return sym_is_optional(sym);
+	case mod:
+		if (sym_is_choice_value(sym) && sym->visible == yes)
+			return false;
+		return type == S_TRISTATE;
+	case yes:
+		return type == S_BOOLEAN || sym->visible == yes;
+	}
+	return false;
+}
+
+bool sym_set_tristate_value(struct symbol *sym, tristate val)
+{
+	tristate oldval = sym_get_tristate_value(sym);
+
+	if (oldval != val && !sym_tristate_within_range(sym, val))
+		return false;
+
+	if (sym->flags & SYMBOL_NEW) {
+		sym->flags &= ~SYMBOL_NEW;
+		sym->flags |= SYMBOL_CHANGED;
+	}
+	if (sym_is_choice_value(sym) && val == yes) {
+		struct property *prop = sym_get_choice_prop(sym);
+
+		S_VAL(prop->def->def) = sym;
+		prop->def->flags &= ~SYMBOL_NEW;
+	}
+
+	S_TRI(sym->def) = val;
+	if (oldval != val) {
+		sym_clear_all_valid();
+		if (sym == modules_sym)
+			sym_set_all_changed();
+	}
+
+	return true;
+}
+
+tristate sym_toggle_tristate_value(struct symbol *sym)
+{
+	tristate oldval, newval;
+
+	oldval = newval = sym_get_tristate_value(sym);
+	do {
+		switch (newval) {
+		case no:
+			newval = mod;
+			break;
+		case mod:
+			newval = yes;
+			break;
+		case yes:
+			newval = no;
+			break;
+		}
+		if (sym_set_tristate_value(sym, newval))
+			break;
+	} while (oldval != newval);
+	return newval;
+}
+
+bool sym_string_valid(struct symbol *sym, const char *str)
+{
+	char ch;
+
+	switch (sym->type) {
+	case S_STRING:
+		return true;
+	case S_INT:
+		ch = *str++;
+		if (ch == '-')
+			ch = *str++;
+		if (!isdigit((int)ch))
+			return false;
+		if (ch == '0' && *str != 0)
+			return false;
+		while ((ch = *str++)) {
+			if (!isdigit((int)ch))
+				return false;
+		}
+		return true;
+	case S_HEX:
+		if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))
+			str += 2;
+		ch = *str++;
+		do {
+			if (!isxdigit((int)ch))
+				return false;
+		} while ((ch = *str++));
+		return true;
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		switch (str[0]) {
+		case 'y':
+		case 'Y':
+			return sym_tristate_within_range(sym, yes);
+		case 'm':
+		case 'M':
+			return sym_tristate_within_range(sym, mod);
+		case 'n':
+		case 'N':
+			return sym_tristate_within_range(sym, no);
+		}
+		return false;
+	default:
+		return false;
+	}
+}
+
+bool sym_set_string_value(struct symbol *sym, const char *newval)
+{
+	const char *oldval;
+	char *val;
+	int size;
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		switch (newval[0]) {
+		case 'y':
+		case 'Y':
+			return sym_set_tristate_value(sym, yes);
+		case 'm':
+		case 'M':
+			return sym_set_tristate_value(sym, mod);
+		case 'n':
+		case 'N':
+			return sym_set_tristate_value(sym, no);
+		}
+		return false;
+	default:
+		;
+	}
+
+	if (!sym_string_valid(sym, newval))
+		return false;
+
+	if (sym->flags & SYMBOL_NEW) {
+		sym->flags &= ~SYMBOL_NEW;
+		sym->flags |= SYMBOL_CHANGED;
+	}
+
+	oldval = S_VAL(sym->def);
+	size = strlen(newval) + 1;
+	if (sym->type == S_HEX && (newval[0] != '0' || (newval[1] != 'x' && newval[1] != 'X'))) {
+		size += 2;
+		S_VAL(sym->def) = val = malloc(size);
+		*val++ = '0';
+		*val++ = 'x';
+	} else if (!oldval || strcmp(oldval, newval))
+		S_VAL(sym->def) = val = malloc(size);
+	else
+		return true;
+
+	strcpy(val, newval);
+	free((void *)oldval);
+	sym_clear_all_valid();
+
+	return true;
+}
+
+const char *sym_get_string_value(struct symbol *sym)
+{
+	tristate val;
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		val = sym_get_tristate_value(sym);
+		switch (val) {
+		case no:
+			return "n";
+		case mod:
+			return "m";
+		case yes:
+			return "y";
+		}
+		break;
+	default:
+		;
+	}
+	return (const char *)S_VAL(sym->curr);
+}
+
+bool sym_is_changable(struct symbol *sym)
+{
+	if (sym->visible == no)
+		return false;
+	/* at least 'n' and 'y'/'m' is selectable */
+	if (sym_is_optional(sym))
+		return true;
+	/* no 'n', so 'y' and 'm' must be selectable */
+	if (sym_get_type(sym) == S_TRISTATE && sym->visible == yes)
+		return true;
+	return false;
+}
+
+struct symbol *sym_lookup(const char *name, int isconst)
+{
+	struct symbol *symbol;
+	const char *ptr;
+	char *new_name;
+	int hash = 0;
+
+	//printf("lookup: %s -> ", name);
+	if (name) {
+		if (name[0] && !name[1]) {
+			switch (name[0]) {
+			case 'y': return &symbol_yes;
+			case 'm': return &symbol_mod;
+			case 'n': return &symbol_no;
+			}
+		}
+		for (ptr = name; *ptr; ptr++)
+			hash += *ptr;
+		hash &= 0xff;
+
+		for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
+			if (!strcmp(symbol->name, name)) {
+				if ((isconst && symbol->flags & SYMBOL_CONST) ||
+				    (!isconst && !(symbol->flags & SYMBOL_CONST))) {
+					//printf("h:%p\n", symbol);
+					return symbol;
+				}
+			}
+		}
+		new_name = strdup(name);
+	} else {
+		new_name = NULL;
+		hash = 256;
+	}
+
+	symbol = malloc(sizeof(*symbol));
+	memset(symbol, 0, sizeof(*symbol));
+	symbol->name = new_name;
+	symbol->type = S_UNKNOWN;
+	symbol->flags = SYMBOL_NEW;
+	if (isconst)
+		symbol->flags |= SYMBOL_CONST;
+
+	symbol->next = symbol_hash[hash];
+	symbol_hash[hash] = symbol;
+
+	//printf("n:%p\n", symbol);
+	return symbol;
+}
+
+struct symbol *sym_find(const char *name)
+{
+	struct symbol *symbol = NULL;
+	const char *ptr;
+	int hash = 0;
+
+	if (!name)
+		return NULL;
+
+	if (name[0] && !name[1]) {
+		switch (name[0]) {
+		case 'y': return &symbol_yes;
+		case 'm': return &symbol_mod;
+		case 'n': return &symbol_no;
+		}
+	}
+	for (ptr = name; *ptr; ptr++)
+		hash += *ptr;
+	hash &= 0xff;
+
+	for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
+		if (!strcmp(symbol->name, name) &&
+		    !(symbol->flags & SYMBOL_CONST))
+				break;
+	}
+
+	return symbol;
+}
+
+const char *prop_get_type_name(enum prop_type type)
+{
+	switch (type) {
+	case P_PROMPT:
+		return "prompt";
+	case P_COMMENT:
+		return "comment";
+	case P_MENU:
+		return "menu";
+	case P_ROOTMENU:
+		return "rootmenu";
+	case P_DEFAULT:
+		return "default";
+	case P_CHOICE:
+		return "choice";
+	default:
+		return "unknown";
+	}
+}
diff --git a/scripts/lxdialog/textbox.c b/scripts/config/textbox.c
similarity index 99%
rename from scripts/lxdialog/textbox.c
rename to scripts/config/textbox.c
index ecf55410e..8fe907718 100644
--- a/scripts/lxdialog/textbox.c
+++ b/scripts/config/textbox.c
@@ -317,7 +317,7 @@ dialog_textbox (const char *title, const char *file, int height, int width)
     delwin (dialog);
     free (buf);
     close (fd);
-    return -1;			/* ESC pressed */
+    return 1;			/* ESC pressed */
 }
 
 /*
diff --git a/scripts/lxdialog/util.c b/scripts/config/util.c
similarity index 97%
rename from scripts/lxdialog/util.c
rename to scripts/config/util.c
index b3a7af9d2..d20730b88 100644
--- a/scripts/lxdialog/util.c
+++ b/scripts/config/util.c
@@ -25,7 +25,7 @@
 /* use colors by default? */
 bool use_colors = 1;
 
-const char *backtitle = NULL;
+char *backtitle = NULL;
 
 const char *dialog_result;
 
@@ -357,3 +357,19 @@ first_alpha(const char *string, const char *exempt)
 
 	return 0;
 }
+
+/*
+ * Get the first selected item in the dialog_list_item list.
+ */
+struct dialog_list_item *
+first_sel_item(int item_no, struct dialog_list_item ** items)
+{
+	int i;
+
+	for (i = 0; i < item_no; i++) {
+		if (items[i]->selected)
+			return items[i];
+	}
+
+	return NULL;
+}
diff --git a/scripts/lxdialog/yesno.c b/scripts/config/yesno.c
similarity index 100%
rename from scripts/lxdialog/yesno.c
rename to scripts/config/yesno.c
diff --git a/scripts/config/zconf.l b/scripts/config/zconf.l
new file mode 100644
index 000000000..a412bf411
--- /dev/null
+++ b/scripts/config/zconf.l
@@ -0,0 +1,332 @@
+%option backup nostdinit noyywrap never-interactive full ecs
+%option 8bit backup nodefault perf-report perf-report
+%x COMMAND HELP STRING PARAM
+%{
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+#include "zconf.tab.h"
+
+#define START_STRSIZE	16
+
+char *text;
+static char *text_ptr;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static struct buffer *zconf_endfile(void);
+
+void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_ptr = text;
+	text_size = 0;
+	*text_ptr = 0;
+}
+
+void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		text = realloc(text, new_size);
+		text_asize = new_size;
+		text_ptr = text + text_size;
+	}
+	memcpy(text_ptr, str, size);
+	text_ptr += size;
+	text_size += size;
+	*text_ptr = 0;
+}
+
+void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+%}
+
+ws	[ \n\t]
+n	[A-Za-z0-9_]
+
+%%
+	int str = 0;
+	int ts, i;
+
+[ \t]*#.*\n	current_file->lineno++;
+[ \t]*#.*
+
+[ \t]*\n	current_file->lineno++; return T_EOL;
+
+[ \t]+	{
+	BEGIN(COMMAND);
+}
+
+.	{
+	unput(yytext[0]);
+	BEGIN(COMMAND);
+}
+
+
+<COMMAND>{
+	"mainmenu"		BEGIN(PARAM); return T_MAINMENU;
+	"menu"			BEGIN(PARAM); return T_MENU;
+	"endmenu"		BEGIN(PARAM); return T_ENDMENU;
+	"source"		BEGIN(PARAM); return T_SOURCE;
+	"choice"		BEGIN(PARAM); return T_CHOICE;
+	"endchoice"		BEGIN(PARAM); return T_ENDCHOICE;
+	"comment"		BEGIN(PARAM); return T_COMMENT;
+	"config"		BEGIN(PARAM); return T_CONFIG;
+	"help"			BEGIN(PARAM); return T_HELP;
+	"if"			BEGIN(PARAM); return T_IF;
+	"endif"			BEGIN(PARAM); return T_ENDIF;
+	"depends"		BEGIN(PARAM); return T_DEPENDS;
+	"requires"		BEGIN(PARAM); return T_REQUIRES;
+	"optional"		BEGIN(PARAM); return T_OPTIONAL;
+	"default"		BEGIN(PARAM); return T_DEFAULT;
+	"prompt"		BEGIN(PARAM); return T_PROMPT;
+	"tristate"		BEGIN(PARAM); return T_TRISTATE;
+	"bool"			BEGIN(PARAM); return T_BOOLEAN;
+	"boolean"		BEGIN(PARAM); return T_BOOLEAN;
+	"int"			BEGIN(PARAM); return T_INT;
+	"hex"			BEGIN(PARAM); return T_HEX;
+	"string"		BEGIN(PARAM); return T_STRING;
+	{n}+	{
+		alloc_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	.
+	\n	current_file->lineno++; BEGIN(INITIAL);
+}
+
+<PARAM>{
+	"&&"	return T_AND;
+	"||"	return T_OR;
+	"("	return T_OPEN_PAREN;
+	")"	return T_CLOSE_PAREN;
+	"!"	return T_NOT;
+	"="	return T_EQUAL;
+	"!="	return T_UNEQUAL;
+	"if"	return T_IF;
+	"on"	return T_ON;
+	\"|\'	{
+		str = yytext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	\n	BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	---	/* ignore */
+	({n}|[-/.])+	{
+		alloc_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	.
+	<<EOF>> {
+		BEGIN(INITIAL);
+	}
+}
+
+<STRING>{
+	[^'"\\\n]+/\n	{
+		append_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_STRING;
+	}
+	[^'"\\\n]+	{
+		append_string(yytext, yyleng);
+	}
+	\\.?/\n	{
+		append_string(yytext+1, yyleng);
+		zconflval.string = text;
+		return T_STRING;
+	}
+	\\.?	{
+		append_string(yytext+1, yyleng);
+	}
+	\'|\"	{
+		if (str == yytext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_STRING;
+		} else
+			append_string(yytext, 1);
+	}
+	\n	{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	<<EOF>>	{
+		BEGIN(INITIAL);
+	}
+}
+
+<HELP>{
+	[ \t]+	{
+		ts = 0;
+		for (i = 0; i < yyleng; i++) {
+			if (yytext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+		
+	}
+	\n/[^ \t\n] {
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	[ \t]*\n	{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	[^ \t\n].* {
+		append_string(yytext, yyleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	<<EOF>>	{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+}
+
+<<EOF>>	{
+	if (current_buf) {
+		zconf_endfile();
+		return T_EOF;
+	}
+	fclose(yyin);
+	yyterminate();
+}
+
+%%
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL); 
+}
+
+void zconf_initscan(const char *name)
+{
+	yyin = fopen(name, "r");
+	if (!yyin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+	current_file->flags = FILE_BUSY;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	yyin = fopen(name, "r");
+	if (!yyin) {
+		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
+		exit(1);
+	}
+	yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	if (file->flags & FILE_BUSY) {
+		printf("recursive scan (%s)?\n", name);
+		exit(1);
+	}
+	if (file->flags & FILE_SCANNED) {
+		printf("file %s already scanned?\n", name);
+		exit(1);
+	}
+	file->flags |= FILE_BUSY;
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static struct buffer *zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file->flags |= FILE_SCANNED;
+	current_file->flags &= ~FILE_BUSY;
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(yyin);
+		yy_delete_buffer(YY_CURRENT_BUFFER);
+		yy_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+
+	return parent;
+}
+
+int zconf_lineno(void)
+{
+	if (current_buf)
+		return current_file->lineno;
+	else
+		return 0;
+}
+
+char *zconf_curname(void)
+{
+	if (current_buf)
+		return current_file->name;
+	else
+		return "<none>";
+}
diff --git a/scripts/config/zconf.tab.c_shipped b/scripts/config/zconf.tab.c_shipped
new file mode 100644
index 000000000..33b2b6f84
--- /dev/null
+++ b/scripts/config/zconf.tab.c_shipped
@@ -0,0 +1,2017 @@
+/* A Bison parser, made from zconf.y, by GNU bison 1.75.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Written by Richard Stallman by simplifying the original so called
+   ``semantic'' parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON	1
+
+/* Pure parsers.  */
+#define YYPURE	0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* If NAME_PREFIX is specified substitute the variables and functions
+   names.  */
+#define yyparse zconfparse
+#define yylex   zconflex
+#define yyerror zconferror
+#define yylval  zconflval
+#define yychar  zconfchar
+#define yydebug zconfdebug
+#define yynerrs zconfnerrs
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_HELP = 266,
+     T_HELPTEXT = 267,
+     T_IF = 268,
+     T_ENDIF = 269,
+     T_DEPENDS = 270,
+     T_REQUIRES = 271,
+     T_OPTIONAL = 272,
+     T_PROMPT = 273,
+     T_DEFAULT = 274,
+     T_TRISTATE = 275,
+     T_BOOLEAN = 276,
+     T_INT = 277,
+     T_HEX = 278,
+     T_WORD = 279,
+     T_STRING = 280,
+     T_UNEQUAL = 281,
+     T_EOF = 282,
+     T_EOL = 283,
+     T_CLOSE_PAREN = 284,
+     T_OPEN_PAREN = 285,
+     T_ON = 286,
+     T_OR = 287,
+     T_AND = 288,
+     T_EQUAL = 289,
+     T_NOT = 290
+   };
+#endif
+#define T_MAINMENU 258
+#define T_MENU 259
+#define T_ENDMENU 260
+#define T_SOURCE 261
+#define T_CHOICE 262
+#define T_ENDCHOICE 263
+#define T_COMMENT 264
+#define T_CONFIG 265
+#define T_HELP 266
+#define T_HELPTEXT 267
+#define T_IF 268
+#define T_ENDIF 269
+#define T_DEPENDS 270
+#define T_REQUIRES 271
+#define T_OPTIONAL 272
+#define T_PROMPT 273
+#define T_DEFAULT 274
+#define T_TRISTATE 275
+#define T_BOOLEAN 276
+#define T_INT 277
+#define T_HEX 278
+#define T_WORD 279
+#define T_STRING 280
+#define T_UNEQUAL 281
+#define T_EOF 282
+#define T_EOL 283
+#define T_CLOSE_PAREN 284
+#define T_OPEN_PAREN 285
+#define T_ON 286
+#define T_OR 287
+#define T_AND 288
+#define T_EQUAL 289
+#define T_NOT 290
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 1 "zconf.y"
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(int token, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[257];
+
+#define YYERROR_VERBOSE
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+#ifndef YYSTYPE
+#line 33 "zconf.y"
+typedef union {
+	int token;
+	char *string;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+} yystype;
+/* Line 193 of /usr/share/bison/yacc.c.  */
+#line 190 "zconf.tab.c"
+# define YYSTYPE yystype
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+#ifndef YYLTYPE
+typedef struct yyltype
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+} yyltype;
+# define YYLTYPE yyltype
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+
+/* Copy the second part of user declarations.  */
+#line 83 "zconf.y"
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+
+/* Line 213 of /usr/share/bison/yacc.c.  */
+#line 215 "zconf.tab.c"
+
+#if ! defined (yyoverflow) || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# if YYSTACK_USE_ALLOCA
+#  define YYSTACK_ALLOC alloca
+# else
+#  ifndef YYSTACK_USE_ALLOCA
+#   if defined (alloca) || defined (_ALLOCA_H)
+#    define YYSTACK_ALLOC alloca
+#   else
+#    ifdef __GNUC__
+#     define YYSTACK_ALLOC __builtin_alloca
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+# else
+#  if defined (__STDC__) || defined (__cplusplus)
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   define YYSIZE_T size_t
+#  endif
+#  define YYSTACK_ALLOC malloc
+#  define YYSTACK_FREE free
+# endif
+#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+      + YYSTACK_GAP_MAX)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  register YYSIZE_T yyi;		\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];	\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
+
+#endif
+
+#if defined (__STDC__) || defined (__cplusplus)
+   typedef signed char yysigned_char;
+#else
+   typedef short yysigned_char;
+#endif
+
+/* YYFINAL -- State number of the termination state. */
+#define YYFINAL  2
+#define YYLAST   151
+
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals. */
+#define YYNNTS  39
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  96
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  145
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   290
+
+#define YYTRANSLATE(X) \
+  ((unsigned)(X) <= YYMAXUTOK ? yytranslate[X] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const unsigned char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const unsigned short yyprhs[] =
+{
+       0,     0,     3,     4,     7,     9,    11,    13,    17,    19,
+      21,    23,    26,    28,    30,    32,    34,    36,    39,    43,
+      44,    48,    52,    55,    58,    61,    64,    67,    70,    73,
+      77,    81,    83,    87,    89,    94,    97,    98,   102,   106,
+     109,   112,   116,   118,   121,   122,   125,   128,   130,   136,
+     140,   141,   144,   147,   150,   153,   157,   159,   164,   167,
+     168,   171,   174,   177,   181,   184,   187,   190,   194,   197,
+     200,   201,   205,   208,   212,   215,   218,   219,   221,   225,
+     227,   229,   231,   233,   235,   237,   239,   240,   243,   245,
+     249,   253,   257,   260,   264,   268,   270
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const yysigned_char yyrhs[] =
+{
+      37,     0,    -1,    -1,    37,    38,    -1,    39,    -1,    47,
+      -1,    58,    -1,     3,    69,    71,    -1,     5,    -1,    14,
+      -1,     8,    -1,     1,    71,    -1,    53,    -1,    63,    -1,
+      41,    -1,    61,    -1,    71,    -1,    10,    24,    -1,    40,
+      28,    42,    -1,    -1,    42,    43,    28,    -1,    42,    67,
+      28,    -1,    42,    65,    -1,    42,    28,    -1,    20,    68,
+      -1,    21,    68,    -1,    22,    68,    -1,    23,    68,    -1,
+      25,    68,    -1,    18,    69,    72,    -1,    19,    74,    72,
+      -1,     7,    -1,    44,    28,    48,    -1,    70,    -1,    45,
+      50,    46,    28,    -1,    45,    50,    -1,    -1,    48,    49,
+      28,    -1,    48,    67,    28,    -1,    48,    65,    -1,    48,
+      28,    -1,    18,    69,    72,    -1,    17,    -1,    19,    74,
+      -1,    -1,    50,    39,    -1,    13,    73,    -1,    70,    -1,
+      51,    28,    54,    52,    28,    -1,    51,    28,    54,    -1,
+      -1,    54,    39,    -1,    54,    58,    -1,    54,    47,    -1,
+       4,    69,    -1,    55,    28,    66,    -1,    70,    -1,    56,
+      59,    57,    28,    -1,    56,    59,    -1,    -1,    59,    39,
+      -1,    59,    58,    -1,    59,    47,    -1,    59,     1,    28,
+      -1,     6,    69,    -1,    60,    28,    -1,     9,    69,    -1,
+      62,    28,    66,    -1,    11,    28,    -1,    64,    12,    -1,
+      -1,    66,    67,    28,    -1,    66,    28,    -1,    15,    31,
+      73,    -1,    15,    73,    -1,    16,    73,    -1,    -1,    69,
+      -1,    69,    13,    73,    -1,    24,    -1,    25,    -1,     5,
+      -1,     8,    -1,    14,    -1,    28,    -1,    27,    -1,    -1,
+      13,    73,    -1,    74,    -1,    74,    34,    74,    -1,    74,
+      26,    74,    -1,    30,    73,    29,    -1,    35,    73,    -1,
+      73,    32,    73,    -1,    73,    33,    73,    -1,    24,    -1,
+      25,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const unsigned short yyrline[] =
+{
+       0,    88,    88,    89,    92,    93,    94,    95,    96,    97,
+      98,    99,   102,   104,   105,   106,   107,   113,   121,   127,
+     129,   130,   131,   132,   135,   141,   147,   153,   159,   165,
+     171,   179,   188,   194,   202,   204,   210,   212,   213,   214,
+     215,   218,   224,   230,   237,   239,   244,   254,   262,   264,
+     270,   272,   273,   274,   279,   286,   292,   300,   302,   308,
+     310,   311,   312,   313,   316,   322,   329,   336,   343,   349,
+     356,   357,   358,   361,   366,   371,   379,   381,   385,   390,
+     391,   394,   395,   396,   399,   400,   402,   403,   406,   407,
+     408,   409,   410,   411,   412,   415,   416
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE
+/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU", 
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG", 
+  "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS", "T_REQUIRES", 
+  "T_OPTIONAL", "T_PROMPT", "T_DEFAULT", "T_TRISTATE", "T_BOOLEAN", 
+  "T_INT", "T_HEX", "T_WORD", "T_STRING", "T_UNEQUAL", "T_EOF", "T_EOL", 
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_ON", "T_OR", "T_AND", "T_EQUAL", 
+  "T_NOT", "$accept", "input", "block", "common_block", 
+  "config_entry_start", "config_stmt", "config_option_list", 
+  "config_option", "choice", "choice_entry", "choice_end", "choice_stmt", 
+  "choice_option_list", "choice_option", "choice_block", "if", "if_end", 
+  "if_stmt", "if_block", "menu", "menu_entry", "menu_end", "menu_stmt", 
+  "menu_block", "source", "source_stmt", "comment", "comment_stmt", 
+  "help_start", "help", "depends_list", "depends", "prompt_stmt_opt", 
+  "prompt", "end", "nl_or_eof", "if_expr", "expr", "symbol", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const unsigned short yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const unsigned char yyr1[] =
+{
+       0,    36,    37,    37,    38,    38,    38,    38,    38,    38,
+      38,    38,    39,    39,    39,    39,    39,    40,    41,    42,
+      42,    42,    42,    42,    43,    43,    43,    43,    43,    43,
+      43,    44,    45,    46,    47,    47,    48,    48,    48,    48,
+      48,    49,    49,    49,    50,    50,    51,    52,    53,    53,
+      54,    54,    54,    54,    55,    56,    57,    58,    58,    59,
+      59,    59,    59,    59,    60,    61,    62,    63,    64,    65,
+      66,    66,    66,    67,    67,    67,    68,    68,    68,    69,
+      69,    70,    70,    70,    71,    71,    72,    72,    73,    73,
+      73,    73,    73,    73,    73,    74,    74
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const unsigned char yyr2[] =
+{
+       0,     2,     0,     2,     1,     1,     1,     3,     1,     1,
+       1,     2,     1,     1,     1,     1,     1,     2,     3,     0,
+       3,     3,     2,     2,     2,     2,     2,     2,     2,     3,
+       3,     1,     3,     1,     4,     2,     0,     3,     3,     2,
+       2,     3,     1,     2,     0,     2,     2,     1,     5,     3,
+       0,     2,     2,     2,     2,     3,     1,     4,     2,     0,
+       2,     2,     2,     3,     2,     2,     2,     3,     2,     2,
+       0,     3,     2,     3,     2,     2,     0,     1,     3,     1,
+       1,     1,     1,     1,     1,     1,     0,     2,     1,     3,
+       3,     3,     2,     3,     3,     1,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const unsigned char yydefact[] =
+{
+       2,     0,     1,     0,     0,     0,     8,     0,    31,    10,
+       0,     0,     0,     9,    85,    84,     3,     4,     0,    14,
+       0,    44,     5,     0,    12,     0,    59,     6,     0,    15,
+       0,    13,    16,    11,    79,    80,     0,    54,    64,    66,
+      17,    95,    96,     0,     0,    46,    88,    19,    36,    35,
+      50,    70,     0,    65,    70,     7,     0,    92,     0,     0,
+       0,     0,    18,    32,    81,    82,    83,    45,     0,    33,
+      49,    55,     0,    60,    62,     0,    61,    56,    67,    91,
+      93,    94,    90,    89,     0,     0,     0,     0,     0,    76,
+      76,    76,    76,    76,    23,     0,     0,    22,     0,    42,
+       0,     0,    40,     0,    39,     0,    34,    51,    53,     0,
+      52,    47,    72,     0,    63,    57,    68,     0,    74,    75,
+      86,    86,    24,    77,    25,    26,    27,    28,    20,    69,
+      21,    86,    43,    37,    38,    48,    71,    73,     0,    29,
+      30,     0,    41,    87,    78
+};
+
+/* YYDEFGOTO[NTERM-NUM]. */
+static const short yydefgoto[] =
+{
+      -1,     1,    16,    17,    18,    19,    62,    95,    20,    21,
+      68,    22,    63,   103,    49,    23,   109,    24,    70,    25,
+      26,    75,    27,    52,    28,    29,    30,    31,    96,    97,
+      71,   113,   122,   123,    69,    32,   139,    45,    46
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -120
+static const short yypact[] =
+{
+    -120,    17,  -120,    41,    48,    48,  -120,    48,  -120,  -120,
+      48,   -11,    40,  -120,  -120,  -120,  -120,  -120,    13,  -120,
+      23,  -120,  -120,    66,  -120,    72,  -120,  -120,    77,  -120,
+      81,  -120,  -120,  -120,  -120,  -120,    41,  -120,  -120,  -120,
+    -120,  -120,  -120,    40,    40,    57,    59,  -120,  -120,    98,
+    -120,  -120,    49,  -120,  -120,  -120,     7,  -120,    40,    40,
+      67,    67,    99,   117,  -120,  -120,  -120,  -120,    85,  -120,
+      74,    18,    88,  -120,  -120,    95,  -120,  -120,    18,  -120,
+      96,  -120,  -120,  -120,   102,    36,    40,    48,    67,    48,
+      48,    48,    48,    48,  -120,   103,   129,  -120,   114,  -120,
+      48,    67,  -120,   115,  -120,   116,  -120,  -120,  -120,   118,
+    -120,  -120,  -120,   119,  -120,  -120,  -120,    40,    57,    57,
+     135,   135,  -120,   136,  -120,  -120,  -120,  -120,  -120,  -120,
+    -120,   135,  -120,  -120,  -120,  -120,  -120,    57,    40,  -120,
+    -120,    40,  -120,    57,    57
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yysigned_char yypgoto[] =
+{
+    -120,  -120,  -120,   -38,  -120,  -120,  -120,  -120,  -120,  -120,
+    -120,   -42,  -120,  -120,  -120,  -120,  -120,  -120,  -120,  -120,
+    -120,  -120,   -33,  -120,  -120,  -120,  -120,  -120,  -120,    87,
+      97,    34,    47,    -1,   -23,     2,  -119,   -43,   -53
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, parse error.  */
+#define YYTABLE_NINF -59
+static const short yytable[] =
+{
+      56,    57,   140,    36,    37,    33,    38,    82,    83,    39,
+      74,    67,   142,    40,    73,    80,    81,     2,     3,    76,
+       4,     5,     6,     7,     8,     9,    10,    11,   108,    77,
+      12,    13,   107,    85,    86,   121,    79,   110,    55,    58,
+      59,    47,   118,   119,    14,    15,   112,   111,   132,   -58,
+      72,    48,   -58,     5,    64,     7,     8,    65,    10,    11,
+      41,    42,    12,    66,    41,    42,    43,   117,    14,    15,
+      43,    44,    34,    35,   137,    44,    14,    15,     5,    64,
+       7,     8,    65,    10,    11,    60,   120,    12,    66,    58,
+      59,    41,    42,    61,    50,   143,    98,   105,   144,   131,
+      51,    14,    15,    64,     7,    53,    65,    10,    11,    54,
+      84,    12,    66,   106,    85,    86,   114,    87,    88,    89,
+      90,    91,    92,   115,    93,    14,    15,    94,    84,    59,
+     116,   128,    85,    86,    99,   100,   101,   124,   125,   126,
+     127,   129,   130,   133,   134,   102,   135,   136,   138,   141,
+     104,    78
+};
+
+static const unsigned char yycheck[] =
+{
+      43,    44,   121,     4,     5,     3,     7,    60,    61,    10,
+      52,    49,   131,    24,    52,    58,    59,     0,     1,    52,
+       3,     4,     5,     6,     7,     8,     9,    10,    70,    52,
+      13,    14,    70,    15,    16,    88,    29,    70,    36,    32,
+      33,    28,    85,    86,    27,    28,    28,    70,   101,     0,
+       1,    28,     3,     4,     5,     6,     7,     8,     9,    10,
+      24,    25,    13,    14,    24,    25,    30,    31,    27,    28,
+      30,    35,    24,    25,   117,    35,    27,    28,     4,     5,
+       6,     7,     8,     9,    10,    26,    87,    13,    14,    32,
+      33,    24,    25,    34,    28,   138,    62,    63,   141,   100,
+      28,    27,    28,     5,     6,    28,     8,     9,    10,    28,
+      11,    13,    14,    28,    15,    16,    28,    18,    19,    20,
+      21,    22,    23,    28,    25,    27,    28,    28,    11,    33,
+      28,    28,    15,    16,    17,    18,    19,    90,    91,    92,
+      93,    12,    28,    28,    28,    28,    28,    28,    13,    13,
+      63,    54
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const unsigned char yystos[] =
+{
+       0,    37,     0,     1,     3,     4,     5,     6,     7,     8,
+       9,    10,    13,    14,    27,    28,    38,    39,    40,    41,
+      44,    45,    47,    51,    53,    55,    56,    58,    60,    61,
+      62,    63,    71,    71,    24,    25,    69,    69,    69,    69,
+      24,    24,    25,    30,    35,    73,    74,    28,    28,    50,
+      28,    28,    59,    28,    28,    71,    73,    73,    32,    33,
+      26,    34,    42,    48,     5,     8,    14,    39,    46,    70,
+      54,    66,     1,    39,    47,    57,    58,    70,    66,    29,
+      73,    73,    74,    74,    11,    15,    16,    18,    19,    20,
+      21,    22,    23,    25,    28,    43,    64,    65,    67,    17,
+      18,    19,    28,    49,    65,    67,    28,    39,    47,    52,
+      58,    70,    28,    67,    28,    28,    28,    31,    73,    73,
+      69,    74,    68,    69,    68,    68,    68,    68,    28,    12,
+      28,    69,    74,    28,    28,    28,    28,    73,    13,    72,
+      72,    13,    72,    73,    73
+};
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# if defined (__STDC__) || defined (__cplusplus)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrlab1
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yychar1 = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { 								\
+      yyerror ("syntax error: cannot back up");			\
+      YYERROR;							\
+    }								\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)           \
+  Current.first_line   = Rhs[1].first_line;      \
+  Current.first_column = Rhs[1].first_column;    \
+  Current.last_line    = Rhs[N].last_line;       \
+  Current.last_column  = Rhs[N].last_column;
+#endif
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#define YYLEX	yylex ()
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+# define YYDSYMPRINT(Args)			\
+do {						\
+  if (yydebug)					\
+    yysymprint Args;				\
+} while (0)
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YYDSYMPRINT(Args)
+#endif /* !YYDEBUG */
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#if YYMAXDEPTH == 0
+# undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  register const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+#endif /* !YYERROR_VERBOSE */
+
+
+
+#if YYDEBUG
+/*-----------------------------.
+| Print this symbol on YYOUT.  |
+`-----------------------------*/
+
+static void
+#if defined (__STDC__) || defined (__cplusplus)
+yysymprint (FILE* yyout, int yytype, YYSTYPE yyvalue)
+#else
+yysymprint (yyout, yytype, yyvalue)
+    FILE* yyout;
+    int yytype;
+    YYSTYPE yyvalue;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvalue;
+
+  if (yytype < YYNTOKENS)
+    {
+      YYFPRINTF (yyout, "token %s (", yytname[yytype]);
+# ifdef YYPRINT
+      YYPRINT (yyout, yytoknum[yytype], yyvalue);
+# endif
+    }
+  else
+    YYFPRINTF (yyout, "nterm %s (", yytname[yytype]);
+
+  switch (yytype)
+    {
+      default:
+        break;
+    }
+  YYFPRINTF (yyout, ")");
+}
+#endif /* YYDEBUG. */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+#if defined (__STDC__) || defined (__cplusplus)
+yydestruct (int yytype, YYSTYPE yyvalue)
+#else
+yydestruct (yytype, yyvalue)
+    int yytype;
+    YYSTYPE yyvalue;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvalue;
+
+  switch (yytype)
+    {
+      default:
+        break;
+    }
+}
+
+
+
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL
+# else
+#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+# endif
+#else /* !YYPARSE_PARAM */
+# define YYPARSE_PARAM_ARG
+# define YYPARSE_PARAM_DECL
+#endif /* !YYPARSE_PARAM */
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+# ifdef YYPARSE_PARAM
+int yyparse (void *);
+# else
+int yyparse (void);
+# endif
+#endif
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of parse errors so far.  */
+int yynerrs;
+
+
+int
+yyparse (YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
+{
+  
+  register int yystate;
+  register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yychar1 = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  short	yyssa[YYINITDEPTH];
+  short *yyss = yyssa;
+  register short *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  register YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule.  */
+  int yylen;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyoverflowlab;
+# else
+      /* Extend the stack our own way.  */
+      if (yystacksize >= YYMAXDEPTH)
+	goto yyoverflowlab;
+      yystacksize *= 2;
+      if (yystacksize > YYMAXDEPTH)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	short *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyssp >= yyss + yystacksize - 1)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  /* Convert token to internal form (in yychar1) for indexing tables with.  */
+
+  if (yychar <= 0)		/* This means end of input.  */
+    {
+      yychar1 = 0;
+      yychar = YYEOF;		/* Don't call YYLEX any more.  */
+
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yychar1 = YYTRANSLATE (yychar);
+
+      /* We have to keep this `#if YYDEBUG', since we use variables
+	 which are defined only if `YYDEBUG' is set.  */
+      YYDPRINTF ((stderr, "Next token is "));
+      YYDSYMPRINT ((stderr, yychar1, yylval));
+      YYDPRINTF ((stderr, "\n"));
+    }
+
+  /* If the proper action on seeing token YYCHAR1 is to reduce or to
+     detect an error, take that action.  */
+  yyn += yychar1;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yychar1)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
+	      yychar, yytname[yychar1]));
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+
+#if YYDEBUG
+  /* We have to keep this `#if YYDEBUG', since we use variables which
+     are defined only if `YYDEBUG' is set.  */
+  if (yydebug)
+    {
+      int yyi;
+
+      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
+		 yyn - 1, yyrline[yyn]);
+
+      /* Print the symbols being reduced, and their result.  */
+      for (yyi = yyprhs[yyn]; yyrhs[yyi] >= 0; yyi++)
+	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
+      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+    }
+#endif
+  switch (yyn)
+    {
+        case 8:
+#line 96 "zconf.y"
+    { zconfprint("unexpected 'endmenu' statement"); }
+    break;
+
+  case 9:
+#line 97 "zconf.y"
+    { zconfprint("unexpected 'endif' statement"); }
+    break;
+
+  case 10:
+#line 98 "zconf.y"
+    { zconfprint("unexpected 'endchoice' statement"); }
+    break;
+
+  case 11:
+#line 99 "zconf.y"
+    { zconfprint("syntax error"); yyerrok; }
+    break;
+
+  case 17:
+#line 114 "zconf.y"
+    {
+	struct symbol *sym = sym_lookup(yyvsp[0].string, 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), yyvsp[0].string);
+}
+    break;
+
+  case 18:
+#line 122 "zconf.y"
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 23:
+#line 133 "zconf.y"
+    { }
+    break;
+
+  case 24:
+#line 136 "zconf.y"
+    {
+	menu_set_type(S_TRISTATE);
+	printd(DEBUG_PARSE, "%s:%d:tristate\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 25:
+#line 142 "zconf.y"
+    {
+	menu_set_type(S_BOOLEAN);
+	printd(DEBUG_PARSE, "%s:%d:boolean\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 26:
+#line 148 "zconf.y"
+    {
+	menu_set_type(S_INT);
+	printd(DEBUG_PARSE, "%s:%d:int\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 27:
+#line 154 "zconf.y"
+    {
+	menu_set_type(S_HEX);
+	printd(DEBUG_PARSE, "%s:%d:hex\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 28:
+#line 160 "zconf.y"
+    {
+	menu_set_type(S_STRING);
+	printd(DEBUG_PARSE, "%s:%d:string\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 29:
+#line 166 "zconf.y"
+    {
+	menu_add_prop(P_PROMPT, yyvsp[-1].string, NULL, yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 30:
+#line 172 "zconf.y"
+    {
+	menu_add_prop(P_DEFAULT, NULL, yyvsp[-1].symbol, yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 31:
+#line 180 "zconf.y"
+    {
+	struct symbol *sym = sym_lookup(NULL, 0);
+	sym->flags |= SYMBOL_CHOICE;
+	menu_add_entry(sym);
+	menu_add_prop(P_CHOICE, NULL, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 32:
+#line 189 "zconf.y"
+    {
+	menu_end_entry();
+	menu_add_menu();
+}
+    break;
+
+  case 33:
+#line 195 "zconf.y"
+    {
+	if (zconf_endtoken(yyvsp[0].token, T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+}
+    break;
+
+  case 35:
+#line 205 "zconf.y"
+    {
+	printf("%s:%d: missing 'endchoice' for this 'choice' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+}
+    break;
+
+  case 41:
+#line 219 "zconf.y"
+    {
+	menu_add_prop(P_PROMPT, yyvsp[-1].string, NULL, yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 42:
+#line 225 "zconf.y"
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 43:
+#line 231 "zconf.y"
+    {
+	menu_add_prop(P_DEFAULT, NULL, yyvsp[0].symbol, NULL);
+	//current_choice->prop->def = ;
+	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 46:
+#line 245 "zconf.y"
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	//current_entry->prompt = menu_add_prop(T_IF, NULL, NULL, );
+	menu_add_dep(yyvsp[0].expr);
+	menu_end_entry();
+	menu_add_menu();
+}
+    break;
+
+  case 47:
+#line 255 "zconf.y"
+    {
+	if (zconf_endtoken(yyvsp[0].token, T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+}
+    break;
+
+  case 49:
+#line 265 "zconf.y"
+    {
+	printf("%s:%d: missing 'endif' for this 'if' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+}
+    break;
+
+  case 54:
+#line 280 "zconf.y"
+    {
+	menu_add_entry(NULL);
+	menu_add_prop(P_MENU, yyvsp[0].string, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 55:
+#line 287 "zconf.y"
+    {
+	menu_end_entry();
+	menu_add_menu();
+}
+    break;
+
+  case 56:
+#line 293 "zconf.y"
+    {
+	if (zconf_endtoken(yyvsp[0].token, T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+}
+    break;
+
+  case 58:
+#line 303 "zconf.y"
+    {
+	printf("%s:%d: missing 'endmenu' for this 'menu' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+}
+    break;
+
+  case 63:
+#line 313 "zconf.y"
+    { zconfprint("invalid menu option"); yyerrok; }
+    break;
+
+  case 64:
+#line 317 "zconf.y"
+    {
+	yyval.string = yyvsp[0].string;
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), yyvsp[0].string);
+}
+    break;
+
+  case 65:
+#line 323 "zconf.y"
+    {
+	zconf_nextfile(yyvsp[-1].string);
+}
+    break;
+
+  case 66:
+#line 330 "zconf.y"
+    {
+	menu_add_entry(NULL);
+	menu_add_prop(P_COMMENT, yyvsp[0].string, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 67:
+#line 337 "zconf.y"
+    {
+	menu_end_entry();
+}
+    break;
+
+  case 68:
+#line 344 "zconf.y"
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+}
+    break;
+
+  case 69:
+#line 350 "zconf.y"
+    {
+	current_entry->sym->help = yyvsp[0].string;
+}
+    break;
+
+  case 72:
+#line 359 "zconf.y"
+    { }
+    break;
+
+  case 73:
+#line 362 "zconf.y"
+    {
+	menu_add_dep(yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 74:
+#line 367 "zconf.y"
+    {
+	menu_add_dep(yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:depends\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 75:
+#line 372 "zconf.y"
+    {
+	menu_add_dep(yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:requires\n", zconf_curname(), zconf_lineno());
+}
+    break;
+
+  case 77:
+#line 382 "zconf.y"
+    {
+	menu_add_prop(P_PROMPT, yyvsp[0].string, NULL, NULL);
+}
+    break;
+
+  case 78:
+#line 386 "zconf.y"
+    {
+	menu_add_prop(P_PROMPT, yyvsp[-2].string, NULL, yyvsp[0].expr);
+}
+    break;
+
+  case 81:
+#line 394 "zconf.y"
+    { yyval.token = T_ENDMENU; }
+    break;
+
+  case 82:
+#line 395 "zconf.y"
+    { yyval.token = T_ENDCHOICE; }
+    break;
+
+  case 83:
+#line 396 "zconf.y"
+    { yyval.token = T_ENDIF; }
+    break;
+
+  case 86:
+#line 402 "zconf.y"
+    { yyval.expr = NULL; }
+    break;
+
+  case 87:
+#line 403 "zconf.y"
+    { yyval.expr = yyvsp[0].expr; }
+    break;
+
+  case 88:
+#line 406 "zconf.y"
+    { yyval.expr = expr_alloc_symbol(yyvsp[0].symbol); }
+    break;
+
+  case 89:
+#line 407 "zconf.y"
+    { yyval.expr = expr_alloc_comp(E_EQUAL, yyvsp[-2].symbol, yyvsp[0].symbol); }
+    break;
+
+  case 90:
+#line 408 "zconf.y"
+    { yyval.expr = expr_alloc_comp(E_UNEQUAL, yyvsp[-2].symbol, yyvsp[0].symbol); }
+    break;
+
+  case 91:
+#line 409 "zconf.y"
+    { yyval.expr = yyvsp[-1].expr; }
+    break;
+
+  case 92:
+#line 410 "zconf.y"
+    { yyval.expr = expr_alloc_one(E_NOT, yyvsp[0].expr); }
+    break;
+
+  case 93:
+#line 411 "zconf.y"
+    { yyval.expr = expr_alloc_two(E_OR, yyvsp[-2].expr, yyvsp[0].expr); }
+    break;
+
+  case 94:
+#line 412 "zconf.y"
+    { yyval.expr = expr_alloc_two(E_AND, yyvsp[-2].expr, yyvsp[0].expr); }
+    break;
+
+  case 95:
+#line 415 "zconf.y"
+    { yyval.symbol = sym_lookup(yyvsp[0].string, 0); free(yyvsp[0].string); }
+    break;
+
+  case 96:
+#line 416 "zconf.y"
+    { yyval.symbol = sym_lookup(yyvsp[0].string, 1); free(yyvsp[0].string); }
+    break;
+
+
+    }
+
+/* Line 1016 of /usr/share/bison/yacc.c.  */
+#line 1565 "zconf.tab.c"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+
+
+#if YYDEBUG
+  if (yydebug)
+    {
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
+    }
+#endif
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
+	{
+	  YYSIZE_T yysize = 0;
+	  int yytype = YYTRANSLATE (yychar);
+	  char *yymsg;
+	  int yyx, yycount;
+
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  for (yyx = yyn < 0 ? -yyn : 0;
+	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
+	  yysize += yystrlen ("parse error, unexpected ") + 1;
+	  yysize += yystrlen (yytname[yytype]);
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
+	    {
+	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[yytype]);
+
+	      if (yycount < 5)
+		{
+		  yycount = 0;
+		  for (yyx = yyn < 0 ? -yyn : 0;
+		       yyx < (int) (sizeof (yytname) / sizeof (char *));
+		       yyx++)
+		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+		      {
+			const char *yyq = ! yycount ? ", expecting " : " or ";
+			yyp = yystpcpy (yyp, yyq);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yycount++;
+		      }
+		}
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
+	    }
+	  else
+	    yyerror ("parse error; also virtual memory exhausted");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror ("parse error");
+    }
+  goto yyerrlab1;
+
+
+/*----------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action.  |
+`----------------------------------------------------*/
+yyerrlab1:
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      /* Return failure if at end of input.  */
+      if (yychar == YYEOF)
+        {
+	  /* Pop the error token.  */
+          YYPOPSTACK;
+	  /* Pop the rest of the stack.  */
+	  while (yyssp > yyss)
+	    {
+	      YYDPRINTF ((stderr, "Error: popping "));
+	      YYDSYMPRINT ((stderr,
+			    yystos[*yyssp],
+			    *yyvsp));
+	      YYDPRINTF ((stderr, "\n"));
+	      yydestruct (yystos[*yyssp], *yyvsp);
+	      YYPOPSTACK;
+	    }
+	  YYABORT;
+        }
+
+      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
+		  yychar, yytname[yychar1]));
+      yydestruct (yychar1, yylval);
+      yychar = YYEMPTY;
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+      YYDPRINTF ((stderr, "Error: popping "));
+      YYDSYMPRINT ((stderr,
+		    yystos[*yyssp], *yyvsp));
+      YYDPRINTF ((stderr, "\n"));
+
+      yydestruct (yystos[yystate], *yyvsp);
+      yyvsp--;
+      yystate = *--yyssp;
+
+
+#if YYDEBUG
+      if (yydebug)
+	{
+	  short *yyssp1 = yyss - 1;
+	  YYFPRINTF (stderr, "Error: state stack now");
+	  while (yyssp1 != yyssp)
+	    YYFPRINTF (stderr, " %d", *++yyssp1);
+	  YYFPRINTF (stderr, "\n");
+	}
+#endif
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  YYDPRINTF ((stderr, "Shifting error token, "));
+
+  *++yyvsp = yylval;
+
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*----------------------------------------------.
+| yyoverflowlab -- parser overflow comes here.  |
+`----------------------------------------------*/
+yyoverflowlab:
+  yyerror ("parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
+}
+
+
+#line 419 "zconf.y"
+
+
+void conf_parse(const char *name)
+{
+	zconf_initscan(name);
+
+	sym_init();
+	menu_init();
+	rootmenu.prompt = menu_add_prop(P_MENU, "BusyBox Configuration", NULL, NULL);
+
+	//zconfdebug = 1;
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	menu_finalize(&rootmenu);
+
+	modules_sym = sym_lookup("MODULES", 0);
+
+	sym_change_count = 1;
+}
+
+const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	}
+	return "<token>";
+} 
+
+static bool zconf_endtoken(int token, int starttoken, int endtoken)
+{
+	if (token != endtoken) {
+		zconfprint("unexpected '%s' within %s block", zconf_tokenname(token), zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconfprint("'%s' in different file than '%s'", zconf_tokenname(token), zconf_tokenname(starttoken));
+		zconfprint("location of the '%s'", zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno(), err);
+}
+
+void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	//sym->flags |= SYMBOL_PRINTED;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "choice\n");
+	else
+		fprintf(out, "config %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+#if 0
+	if (!expr_is_yes(sym->dep)) {
+		fputs("  depends ", out);
+		expr_fprint(sym->dep, out);
+		fputc('\n', out);
+	}
+#endif
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (prop->def) {
+				fputc(' ', out);
+				if (prop->def->flags & SYMBOL_CONST)
+					print_quoted_string(out, prop->def->name);
+				else
+					fputs(prop->def->name, out);
+			}
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs(" if ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			print_quoted_string(out, prop->def->name);
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs(" if ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (sym->help) {
+		int len = strlen(sym->help);
+		while (sym->help[--len] == '\n')
+			sym->help[len] = 0;
+		fprintf(out, "  help\n%s\n", sym->help);
+	}
+	fputc('\n', out);
+}
+
+void zconfdump(FILE *out)
+{
+	//struct file *file;
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			//case T_MAINMENU:
+			//	fputs("\nmainmenu ", out);
+			//	print_quoted_string(out, prop->text);
+			//	fputs("\n", out);
+			//	break;
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			//case T_SOURCE:
+			//	fputs("\nsource ", out);
+			//	print_quoted_string(out, prop->text);
+			//	fputs("\n", out);
+			//	break;
+			//case T_IF:
+			//	fputs("\nif\n", out);
+			default:
+				;
+			}
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs("  depends ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+				fputc('\n', out);
+			}
+			fputs("\n", out);
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "lex.zconf.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
diff --git a/scripts/config/zconf.tab.h_shipped b/scripts/config/zconf.tab.h_shipped
new file mode 100644
index 000000000..3b191ef59
--- /dev/null
+++ b/scripts/config/zconf.tab.h_shipped
@@ -0,0 +1,125 @@
+/* A Bison parser, made from zconf.y, by GNU bison 1.75.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+#ifndef BISON_ZCONF_TAB_H
+# define BISON_ZCONF_TAB_H
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_HELP = 266,
+     T_HELPTEXT = 267,
+     T_IF = 268,
+     T_ENDIF = 269,
+     T_DEPENDS = 270,
+     T_REQUIRES = 271,
+     T_OPTIONAL = 272,
+     T_PROMPT = 273,
+     T_DEFAULT = 274,
+     T_TRISTATE = 275,
+     T_BOOLEAN = 276,
+     T_INT = 277,
+     T_HEX = 278,
+     T_WORD = 279,
+     T_STRING = 280,
+     T_UNEQUAL = 281,
+     T_EOF = 282,
+     T_EOL = 283,
+     T_CLOSE_PAREN = 284,
+     T_OPEN_PAREN = 285,
+     T_ON = 286,
+     T_OR = 287,
+     T_AND = 288,
+     T_EQUAL = 289,
+     T_NOT = 290
+   };
+#endif
+#define T_MAINMENU 258
+#define T_MENU 259
+#define T_ENDMENU 260
+#define T_SOURCE 261
+#define T_CHOICE 262
+#define T_ENDCHOICE 263
+#define T_COMMENT 264
+#define T_CONFIG 265
+#define T_HELP 266
+#define T_HELPTEXT 267
+#define T_IF 268
+#define T_ENDIF 269
+#define T_DEPENDS 270
+#define T_REQUIRES 271
+#define T_OPTIONAL 272
+#define T_PROMPT 273
+#define T_DEFAULT 274
+#define T_TRISTATE 275
+#define T_BOOLEAN 276
+#define T_INT 277
+#define T_HEX 278
+#define T_WORD 279
+#define T_STRING 280
+#define T_UNEQUAL 281
+#define T_EOF 282
+#define T_EOL 283
+#define T_CLOSE_PAREN 284
+#define T_OPEN_PAREN 285
+#define T_ON 286
+#define T_OR 287
+#define T_AND 288
+#define T_EQUAL 289
+#define T_NOT 290
+
+
+
+
+#ifndef YYSTYPE
+#line 33 "zconf.y"
+typedef union {
+	int token;
+	char *string;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+} yystype;
+/* Line 1281 of /usr/share/bison/yacc.c.  */
+#line 118 "zconf.tab.h"
+# define YYSTYPE yystype
+#endif
+
+extern YYSTYPE zconflval;
+
+
+#endif /* not BISON_ZCONF_TAB_H */
+
diff --git a/scripts/config/zconf.y b/scripts/config/zconf.y
new file mode 100644
index 000000000..301d7a896
--- /dev/null
+++ b/scripts/config/zconf.y
@@ -0,0 +1,651 @@
+%{
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(int token, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[257];
+
+#define YYERROR_VERBOSE
+%}
+%expect 36
+
+%union
+{
+	int token;
+	char *string;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+}
+
+%token T_MAINMENU
+%token T_MENU
+%token T_ENDMENU
+%token T_SOURCE
+%token T_CHOICE
+%token T_ENDCHOICE
+%token T_COMMENT
+%token T_CONFIG
+%token T_HELP
+%token <string> T_HELPTEXT
+%token T_IF
+%token T_ENDIF
+%token T_DEPENDS
+%token T_REQUIRES
+%token T_OPTIONAL
+%token T_PROMPT
+%token T_DEFAULT
+%token T_TRISTATE
+%token T_BOOLEAN
+%token T_INT
+%token T_HEX
+%token <string> T_WORD
+%token <string> T_STRING
+%token T_UNEQUAL
+%token T_EOF
+%token T_EOL
+%token T_CLOSE_PAREN
+%token T_OPEN_PAREN
+%token T_ON
+
+%left T_OR
+%left T_AND
+%left T_EQUAL T_UNEQUAL
+%nonassoc T_NOT
+
+%type <string> prompt
+%type <string> source
+%type <symbol> symbol
+%type <expr> expr
+%type <expr> if_expr
+%type <token> end
+
+%{
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+%}
+%%
+input:	  /* empty */
+	| input block
+;
+
+block:	  common_block
+	| choice_stmt
+	| menu_stmt
+	| T_MAINMENU prompt nl_or_eof
+	| T_ENDMENU		{ zconfprint("unexpected 'endmenu' statement"); }
+	| T_ENDIF		{ zconfprint("unexpected 'endif' statement"); }
+	| T_ENDCHOICE		{ zconfprint("unexpected 'endchoice' statement"); }
+	| error nl_or_eof	{ zconfprint("syntax error"); yyerrok; }
+;
+
+common_block:
+	  if_stmt
+	| comment_stmt
+	| config_stmt
+	| source_stmt
+	| nl_or_eof
+;
+
+
+/* config entry */
+
+config_entry_start: T_CONFIG T_WORD
+{
+	struct symbol *sym = sym_lookup($2, 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), $2);
+};
+
+config_stmt: config_entry_start T_EOL config_option_list
+{
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+};
+
+config_option_list:
+	  /* empty */
+	| config_option_list config_option T_EOL
+	| config_option_list depends T_EOL
+	| config_option_list help
+	| config_option_list T_EOL
+{ };
+
+config_option: T_TRISTATE prompt_stmt_opt
+{
+	menu_set_type(S_TRISTATE);
+	printd(DEBUG_PARSE, "%s:%d:tristate\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_BOOLEAN prompt_stmt_opt
+{
+	menu_set_type(S_BOOLEAN);
+	printd(DEBUG_PARSE, "%s:%d:boolean\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_INT prompt_stmt_opt
+{
+	menu_set_type(S_INT);
+	printd(DEBUG_PARSE, "%s:%d:int\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_HEX prompt_stmt_opt
+{
+	menu_set_type(S_HEX);
+	printd(DEBUG_PARSE, "%s:%d:hex\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_STRING prompt_stmt_opt
+{
+	menu_set_type(S_STRING);
+	printd(DEBUG_PARSE, "%s:%d:string\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_PROMPT prompt if_expr
+{
+	menu_add_prop(P_PROMPT, $2, NULL, $3);
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_DEFAULT symbol if_expr
+{
+	menu_add_prop(P_DEFAULT, NULL, $2, $3);
+	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
+};
+
+/* choice entry */
+
+choice: T_CHOICE
+{
+	struct symbol *sym = sym_lookup(NULL, 0);
+	sym->flags |= SYMBOL_CHOICE;
+	menu_add_entry(sym);
+	menu_add_prop(P_CHOICE, NULL, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+};
+
+choice_entry: choice T_EOL choice_option_list
+{
+	menu_end_entry();
+	menu_add_menu();
+};
+
+choice_end: end
+{
+	if (zconf_endtoken($1, T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+};
+
+choice_stmt:
+	  choice_entry choice_block choice_end T_EOL
+	| choice_entry choice_block
+{
+	printf("%s:%d: missing 'endchoice' for this 'choice' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+};
+
+choice_option_list:
+	  /* empty */
+	| choice_option_list choice_option T_EOL
+	| choice_option_list depends T_EOL
+	| choice_option_list help
+	| choice_option_list T_EOL
+;
+
+choice_option: T_PROMPT prompt if_expr
+{
+	menu_add_prop(P_PROMPT, $2, NULL, $3);
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+};
+
+choice_option: T_OPTIONAL
+{
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+};
+
+choice_option: T_DEFAULT symbol
+{
+	menu_add_prop(P_DEFAULT, NULL, $2, NULL);
+	//current_choice->prop->def = $2;
+	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
+};
+
+choice_block:
+	  /* empty */
+	| choice_block common_block
+;
+
+/* if entry */
+
+if: T_IF expr
+{
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	//current_entry->prompt = menu_add_prop(T_IF, NULL, NULL, $2);
+	menu_add_dep($2);
+	menu_end_entry();
+	menu_add_menu();
+};
+
+if_end: end
+{
+	if (zconf_endtoken($1, T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+};
+
+if_stmt:
+	  if T_EOL if_block if_end T_EOL
+	| if T_EOL if_block
+{
+	printf("%s:%d: missing 'endif' for this 'if' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+};
+
+if_block:
+	  /* empty */
+	| if_block common_block
+	| if_block menu_stmt
+	| if_block choice_stmt
+;
+
+/* menu entry */
+
+menu: T_MENU prompt
+{
+	menu_add_entry(NULL);
+	menu_add_prop(P_MENU, $2, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+};
+
+menu_entry: menu T_EOL depends_list
+{
+	menu_end_entry();
+	menu_add_menu();
+};
+
+menu_end: end
+{
+	if (zconf_endtoken($1, T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+};
+
+menu_stmt:
+	  menu_entry menu_block menu_end T_EOL
+	| menu_entry menu_block
+{
+	printf("%s:%d: missing 'endmenu' for this 'menu' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+};
+
+menu_block:
+	  /* empty */
+	| menu_block common_block
+	| menu_block menu_stmt
+	| menu_block choice_stmt
+	| menu_block error T_EOL		{ zconfprint("invalid menu option"); yyerrok; }
+;
+
+source: T_SOURCE prompt
+{
+	$$ = $2;
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), $2);
+};
+
+source_stmt: source T_EOL
+{
+	zconf_nextfile($1);
+};
+
+/* comment entry */
+
+comment: T_COMMENT prompt
+{
+	menu_add_entry(NULL);
+	menu_add_prop(P_COMMENT, $2, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+};
+
+comment_stmt: comment T_EOL depends_list
+{
+	menu_end_entry();
+};
+
+/* help option */
+
+help_start: T_HELP T_EOL
+{
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+};
+
+help: help_start T_HELPTEXT
+{
+	current_entry->sym->help = $2;
+};
+
+/* depends option */
+
+depends_list:	  /* empty */
+		| depends_list depends T_EOL
+		| depends_list T_EOL
+{ };
+
+depends: T_DEPENDS T_ON expr
+{
+	menu_add_dep($3);
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+}
+	| T_DEPENDS expr
+{
+	menu_add_dep($2);
+	printd(DEBUG_PARSE, "%s:%d:depends\n", zconf_curname(), zconf_lineno());
+}
+	| T_REQUIRES expr
+{
+	menu_add_dep($2);
+	printd(DEBUG_PARSE, "%s:%d:requires\n", zconf_curname(), zconf_lineno());
+};
+
+/* prompt statement */
+
+prompt_stmt_opt:
+	  /* empty */
+	| prompt
+{
+	menu_add_prop(P_PROMPT, $1, NULL, NULL);
+}
+	| prompt T_IF expr
+{
+	menu_add_prop(P_PROMPT, $1, NULL, $3);
+};
+
+prompt:	  T_WORD
+	| T_STRING
+;
+
+end:	  T_ENDMENU		{ $$ = T_ENDMENU; }
+	| T_ENDCHOICE		{ $$ = T_ENDCHOICE; }
+	| T_ENDIF		{ $$ = T_ENDIF; }
+;
+
+nl_or_eof:
+	T_EOL | T_EOF;
+
+if_expr:  /* empty */			{ $$ = NULL; }
+	| T_IF expr			{ $$ = $2; }
+;
+
+expr:	  symbol				{ $$ = expr_alloc_symbol($1); }
+	| symbol T_EQUAL symbol			{ $$ = expr_alloc_comp(E_EQUAL, $1, $3); }
+	| symbol T_UNEQUAL symbol		{ $$ = expr_alloc_comp(E_UNEQUAL, $1, $3); }
+	| T_OPEN_PAREN expr T_CLOSE_PAREN	{ $$ = $2; }
+	| T_NOT expr				{ $$ = expr_alloc_one(E_NOT, $2); }
+	| expr T_OR expr			{ $$ = expr_alloc_two(E_OR, $1, $3); }
+	| expr T_AND expr			{ $$ = expr_alloc_two(E_AND, $1, $3); }
+;
+
+symbol:	  T_WORD	{ $$ = sym_lookup($1, 0); free($1); }
+	| T_STRING	{ $$ = sym_lookup($1, 1); free($1); }
+;
+
+%%
+
+void conf_parse(const char *name)
+{
+	zconf_initscan(name);
+
+	sym_init();
+	menu_init();
+	rootmenu.prompt = menu_add_prop(P_MENU, "BusyBox Configuration", NULL, NULL);
+
+	//zconfdebug = 1;
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	menu_finalize(&rootmenu);
+
+	modules_sym = sym_lookup("MODULES", 0);
+
+	sym_change_count = 1;
+}
+
+const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	}
+	return "<token>";
+} 
+
+static bool zconf_endtoken(int token, int starttoken, int endtoken)
+{
+	if (token != endtoken) {
+		zconfprint("unexpected '%s' within %s block", zconf_tokenname(token), zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconfprint("'%s' in different file than '%s'", zconf_tokenname(token), zconf_tokenname(starttoken));
+		zconfprint("location of the '%s'", zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno(), err);
+}
+
+void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	//sym->flags |= SYMBOL_PRINTED;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "choice\n");
+	else
+		fprintf(out, "config %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+#if 0
+	if (!expr_is_yes(sym->dep)) {
+		fputs("  depends ", out);
+		expr_fprint(sym->dep, out);
+		fputc('\n', out);
+	}
+#endif
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (prop->def) {
+				fputc(' ', out);
+				if (prop->def->flags & SYMBOL_CONST)
+					print_quoted_string(out, prop->def->name);
+				else
+					fputs(prop->def->name, out);
+			}
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs(" if ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			print_quoted_string(out, prop->def->name);
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs(" if ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (sym->help) {
+		int len = strlen(sym->help);
+		while (sym->help[--len] == '\n')
+			sym->help[len] = 0;
+		fprintf(out, "  help\n%s\n", sym->help);
+	}
+	fputc('\n', out);
+}
+
+void zconfdump(FILE *out)
+{
+	//struct file *file;
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			//case T_MAINMENU:
+			//	fputs("\nmainmenu ", out);
+			//	print_quoted_string(out, prop->text);
+			//	fputs("\n", out);
+			//	break;
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			//case T_SOURCE:
+			//	fputs("\nsource ", out);
+			//	print_quoted_string(out, prop->text);
+			//	fputs("\n", out);
+			//	break;
+			//case T_IF:
+			//	fputs("\nif\n", out);
+			default:
+				;
+			}
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs("  depends ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+				fputc('\n', out);
+			}
+			fputs("\n", out);
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "lex.zconf.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
diff --git a/scripts/lxdialog/.cvsignore b/scripts/lxdialog/.cvsignore
deleted file mode 100644
index bebf29560..000000000
--- a/scripts/lxdialog/.cvsignore
+++ /dev/null
@@ -1 +0,0 @@
-lxdialog
diff --git a/scripts/lxdialog/BIG.FAT.WARNING b/scripts/lxdialog/BIG.FAT.WARNING
deleted file mode 100644
index a8999d82b..000000000
--- a/scripts/lxdialog/BIG.FAT.WARNING
+++ /dev/null
@@ -1,4 +0,0 @@
-This is NOT the official version of dialog.  This version has been
-significantly modified from the original.  It is for use by the Linux
-kernel configuration script.  Please do not bother Savio Lam with 
-questions about this program.
diff --git a/scripts/lxdialog/Makefile b/scripts/lxdialog/Makefile
deleted file mode 100644
index c29b58d7b..000000000
--- a/scripts/lxdialog/Makefile
+++ /dev/null
@@ -1,48 +0,0 @@
-HOSTCFLAGS += -DLOCALE 
-LIBS = -lncurses
-
-ifeq (/usr/include/ncurses/ncurses.h, $(wildcard /usr/include/ncurses/ncurses.h))
-	HOSTCFLAGS += -I/usr/include/ncurses -DCURSES_LOC="<ncurses.h>"
-else
-ifeq (/usr/include/ncurses/curses.h, $(wildcard /usr/include/ncurses/curses.h))
-	HOSTCFLAGS += -I/usr/include/ncurses -DCURSES_LOC="<ncurses/curses.h>"
-else
-ifeq (/usr/include/ncurses.h, $(wildcard /usr/include/ncurses.h))
-	HOSTCFLAGS += -DCURSES_LOC="<ncurses.h>"
-else
-	HOSTCFLAGS += -DCURSES_LOC="<curses.h>"
-endif
-endif
-endif
-
-
-OBJS = checklist.o menubox.o textbox.o yesno.o inputbox.o \
-       util.o lxdialog.o msgbox.o
-
-%.o: %.c
-	$(HOSTCC) $(HOSTCFLAGS) -c -o $@ $<
-
-all: ncurses lxdialog
-
-lxdialog: $(OBJS)
-	$(HOSTCC) -o lxdialog $(OBJS) $(LIBS)
-
-.PHONY: ncurses
-
-ncurses:
-	@echo "main() {}" > lxtemp.c
-	@if $(HOSTCC) lxtemp.c $(LIBS) ; then \
-		rm -f lxtemp.c a.out; \
-	else \
-		rm -f lxtemp.c; \
-		echo -e "\007" ;\
-		echo ">> Unable to find the Ncurses libraries." ;\
-		echo ">>" ;\
-		echo ">> You must have Ncurses installed in order" ;\
-		echo ">> to use 'make menuconfig'" ;\
-		echo ;\
-		exit 1 ;\
-	fi
-
-clean:
-	rm -f core *.o *~ lxdialog
diff --git a/scripts/lxdialog/Makefile-2.5 b/scripts/lxdialog/Makefile-2.5
deleted file mode 100644
index 665205200..000000000
--- a/scripts/lxdialog/Makefile-2.5
+++ /dev/null
@@ -1,71 +0,0 @@
-lxdialog-hostcflags += -DLOCALE 
-lxdialog-libs = -lncurses
-
-ifeq (/usr/include/ncurses/ncurses.h, $(wildcard /usr/include/ncurses/ncurses.h))
-        lxdialog-hostcflags += -I/usr/include/ncurses -DCURSES_LOC="<ncurses.h>"
-else
-ifeq (/usr/include/ncurses/curses.h, $(wildcard /usr/include/ncurses/curses.h))
-        lxdialog-hostcflags += -I/usr/include/ncurses -DCURSES_LOC="<ncurses/curses.h>"
-else
-ifeq (/usr/include/ncurses.h, $(wildcard /usr/include/ncurses.h))
-        lxdialog-hostcflags += -DCURSES_LOC="<ncurses.h>"
-else
-	lxdialog-hostcflags += -DCURSES_LOC="<curses.h>"
-endif
-endif
-endif
-
-$(tmp_config)lxdialog-ncurses: 
-	@mkdir -p $(lxdialog-objtree)
-	@( \
-	  cd $(lxdialog-objtree) && \
-	  echo "main() {}" > lxtemp.c && \
-	  if $(HOSTCC) -lncurses lxtemp.c ; then \
-		rm -f lxtemp.c a.out && \
-		mkdir -p $(@D) && \
-		touch $@; \
-	  else \
-		rm -f lxtemp.c; \
-		echo -e "\007" ;\
-		echo ">> Unable to find the Ncurses libraries." ;\
-		echo ">>" ;\
-		echo ">> You must have Ncurses installed in order" ;\
-		echo ">> to use 'make menuconfig'" ;\
-		echo ;\
-		exit 1 ;\
-	  fi ; \
-	)
-
-lxdialog-objs   := $(lxdialog-objtree)checklist.o $(lxdialog-objtree)menubox.o \
-                   $(lxdialog-objtree)textbox.o $(lxdialog-objtree)yesno.o \
-                   $(lxdialog-objtree)inputbox.o $(lxdialog-objtree)util.o \
-                   $(lxdialog-objtree)lxdialog.o $(lxdialog-objtree)msgbox.o
-
-$(lxdialog-objtree)checklist.o: $(lxdialog-srctree)checklist.c $(tmp_config)lxdialog-ncurses
-	$(HOSTCC) $(HOSTCFLAGS) $(lxdialog-hostcflags) -c -o $@ $<
-
-$(lxdialog-objtree)menubox.o: $(lxdialog-srctree)menubox.c $(tmp_config)lxdialog-ncurses
-	$(HOSTCC) $(HOSTCFLAGS) $(lxdialog-hostcflags) -c -o $@ $<
-
-$(lxdialog-objtree)textbox.o: $(lxdialog-srctree)textbox.c $(tmp_config)lxdialog-ncurses
-	$(HOSTCC) $(HOSTCFLAGS) $(lxdialog-hostcflags) -c -o $@ $<
-
-$(lxdialog-objtree)yesno.o: $(lxdialog-srctree)yesno.c $(tmp_config)lxdialog-ncurses
-	$(HOSTCC) $(HOSTCFLAGS) $(lxdialog-hostcflags) -c -o $@ $<
-
-$(lxdialog-objtree)inputbox.o: $(lxdialog-srctree)inputbox.c $(tmp_config)lxdialog-ncurses
-	$(HOSTCC) $(HOSTCFLAGS) $(lxdialog-hostcflags) -c -o $@ $<
-
-$(lxdialog-objtree)util.o: $(lxdialog-srctree)util.c $(tmp_config)lxdialog-ncurses
-	$(HOSTCC) $(HOSTCFLAGS) $(lxdialog-hostcflags) -c -o $@ $<
-
-$(lxdialog-objtree)lxdialog.o: $(lxdialog-srctree)lxdialog.c $(tmp_config)lxdialog-ncurses
-	$(HOSTCC) $(HOSTCFLAGS) $(lxdialog-hostcflags) -c -o $@ $<
-
-$(lxdialog-objtree)msgbox.o: $(lxdialog-srctree)msgbox.c $(tmp_config)lxdialog-ncurses
-	$(HOSTCC) $(HOSTCFLAGS) $(lxdialog-hostcflags) -c -o $@ $<
-
-$(lxdialog-objtree)lxdialog: $(lxdialog-objs)
-	$(HOSTCC) -o $@ $(lxdialog-objs) $(lxdialog-libs)
-
-MRPROPER		+= $(lxdialog-objtree)lxdialog
diff --git a/scripts/lxdialog/lxdialog.c b/scripts/lxdialog/lxdialog.c
deleted file mode 100644
index 6f4c1fd4e..000000000
--- a/scripts/lxdialog/lxdialog.c
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- *  dialog - Display simple dialog boxes from shell scripts
- *
- *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
- *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version 2
- *  of the License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include "dialog.h"
-
-static void Usage (const char *name);
-
-typedef int (jumperFn) (const char *title, int argc, const char * const * argv);
-
-struct Mode {
-    char *name;
-    int argmin, argmax, argmod;
-    jumperFn *jumper;
-};
-
-jumperFn j_menu, j_checklist, j_radiolist, j_yesno, j_textbox, j_inputbox;
-jumperFn j_msgbox, j_infobox;
-
-static struct Mode modes[] =
-{
-    {"--menu", 9, 0, 3, j_menu},
-    {"--checklist", 9, 0, 3, j_checklist},
-    {"--radiolist", 9, 0, 3, j_radiolist},
-    {"--yesno",    5,5,1, j_yesno},
-    {"--textbox",  5,5,1, j_textbox},
-    {"--inputbox", 5, 6, 1, j_inputbox},
-    {"--msgbox", 5, 5, 1, j_msgbox},
-    {"--infobox", 5, 5, 1, j_infobox},
-    {NULL, 0, 0, 0, NULL}
-};
-
-static struct Mode *modePtr;
-
-#ifdef LOCALE
-#include <locale.h>
-#endif
-
-int
-main (int argc, const char * const * argv)
-{
-    int offset = 0, clear_screen = 0, end_common_opts = 0, retval;
-    const char *title = NULL;
-
-#ifdef LOCALE
-    (void) setlocale (LC_ALL, "");
-#endif
-
-#ifdef TRACE
-    trace(TRACE_CALLS|TRACE_UPDATE);
-#endif
-    if (argc < 2) {
-	Usage (argv[0]);
-	exit (-1);
-    }
-
-    while (offset < argc - 1 && !end_common_opts) {	/* Common options */
-	if (!strcmp (argv[offset + 1], "--title")) {
-	    if (argc - offset < 3 || title != NULL) {
-		Usage (argv[0]);
-		exit (-1);
-	    } else {
-		title = argv[offset + 2];
-		offset += 2;
-	    }
-        } else if (!strcmp (argv[offset + 1], "--backtitle")) {
-            if (backtitle != NULL) {
-                Usage (argv[0]);
-                exit (-1);
-            } else {
-                backtitle = argv[offset + 2];
-                offset += 2;
-            }
-	} else if (!strcmp (argv[offset + 1], "--clear")) {
-	    if (clear_screen) {	/* Hey, "--clear" can't appear twice! */
-		Usage (argv[0]);
-		exit (-1);
-	    } else if (argc == 2) {	/* we only want to clear the screen */
-		init_dialog ();
-		refresh ();	/* init_dialog() will clear the screen for us */
-		end_dialog ();
-		return 0;
-	    } else {
-		clear_screen = 1;
-		offset++;
-	    }
-	} else			/* no more common options */
-	    end_common_opts = 1;
-    }
-
-    if (argc - 1 == offset) {	/* no more options */
-	Usage (argv[0]);
-	exit (-1);
-    }
-    /* use a table to look for the requested mode, to avoid code duplication */
-
-    for (modePtr = modes; modePtr->name; modePtr++)	/* look for the mode */
-	if (!strcmp (argv[offset + 1], modePtr->name))
-	    break;
-
-    if (!modePtr->name)
-	Usage (argv[0]);
-    if (argc - offset < modePtr->argmin)
-	Usage (argv[0]);
-    if (modePtr->argmax && argc - offset > modePtr->argmax)
-	Usage (argv[0]);
-
-
-
-    init_dialog ();
-    retval = (*(modePtr->jumper)) (title, argc - offset, argv + offset);
-
-    if (clear_screen) {		/* clear screen before exit */
-	attr_clear (stdscr, LINES, COLS, screen_attr);
-	refresh ();
-    }
-    end_dialog();
-
-    exit (retval);
-}
-
-/*
- * Print program usage
- */
-static void
-Usage (const char *name)
-{
-    fprintf (stderr, "\
-\ndialog, by Savio Lam (lam836@cs.cuhk.hk).\
-\n  patched by Stuart Herbert (S.Herbert@shef.ac.uk)\
-\n  modified/gutted for use as a Linux kernel config tool by \
-\n  William Roadcap (roadcapw@cfw.com)\
-\n\
-\n* Display dialog boxes from shell scripts *\
-\n\
-\nUsage: %s --clear\
-\n       %s [--title <title>] [--backtitle <backtitle>] --clear <Box options>\
-\n\
-\nBox options:\
-\n\
-\n  --menu      <text> <height> <width> <menu height> <tag1> <item1>...\
-\n  --checklist <text> <height> <width> <list height> <tag1> <item1> <status1>...\
-\n  --radiolist <text> <height> <width> <list height> <tag1> <item1> <status1>...\
-\n  --textbox   <file> <height> <width>\
-\n  --inputbox  <text> <height> <width> [<init>]\
-\n  --yesno     <text> <height> <width>\
-\n", name, name);
-    exit (-1);
-}
-
-/*
- * These are the program jumpers
- */
-
-int
-j_menu (const char *t, int ac, const char * const * av)
-{
-    return dialog_menu (t, av[2], atoi (av[3]), atoi (av[4]),
-			atoi (av[5]), av[6], (ac - 6) / 2, av + 7);
-}
-
-int
-j_checklist (const char *t, int ac, const char * const * av)
-{
-    return dialog_checklist (t, av[2], atoi (av[3]), atoi (av[4]),
-	atoi (av[5]), (ac - 6) / 3, av + 6, FLAG_CHECK);
-}
-
-int
-j_radiolist (const char *t, int ac, const char * const * av)
-{
-    return dialog_checklist (t, av[2], atoi (av[3]), atoi (av[4]),
-	atoi (av[5]), (ac - 6) / 3, av + 6, FLAG_RADIO);
-}
-
-int
-j_textbox (const char *t, int ac, const char * const * av)
-{
-    return dialog_textbox (t, av[2], atoi (av[3]), atoi (av[4]));
-}
-
-int
-j_yesno (const char *t, int ac, const char * const * av)
-{
-    return dialog_yesno (t, av[2], atoi (av[3]), atoi (av[4]));
-}
-
-int
-j_inputbox (const char *t, int ac, const char * const * av)
-{
-    int ret = dialog_inputbox (t, av[2], atoi (av[3]), atoi (av[4]),
-                            ac == 6 ? av[5] : (char *) NULL);
-    if (ret == 0)
-        fprintf(stderr, dialog_input_result);
-    return ret;
-}
-
-int
-j_msgbox (const char *t, int ac, const char * const * av)
-{
-    return dialog_msgbox (t, av[2], atoi (av[3]), atoi (av[4]), 1);
-}
-
-int
-j_infobox (const char *t, int ac, const char * const * av)
-{
-    return dialog_msgbox (t, av[2], atoi (av[3]), atoi (av[4]), 0);
-}
-
diff --git a/shell/Config.in b/shell/Config.in
new file mode 100644
index 000000000..3f5d53222
--- /dev/null
+++ b/shell/Config.in
@@ -0,0 +1,208 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Bourne Shell"
+
+choice
+	prompt "Choose your default shell"
+	default "ash"
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SH_IS_ASH
+	bool "ash"
+
+config CONFIG_FEATURE_SH_IS_HUSH
+	bool "hush"
+
+config CONFIG_FEATURE_SH_IS_LASH
+	bool "lash"
+
+config CONFIG_FEATURE_SH_IS_MSH
+	bool "msh"
+
+endchoice
+
+if CONFIG_FEATURE_SH_IS_ASH
+	config CONFIG_ASH
+	default y
+
+	comment "ash (forced enabled as default shell)"
+endif
+	
+if !CONFIG_FEATURE_SH_IS_ASH
+config CONFIG_ASH
+	bool "ash"
+	default y
+	help
+	  Please submit a patch to add help text for this item.
+endif
+
+comment "Ash Shell Options"
+	depends on CONFIG_ASH
+
+config CONFIG_ASH_JOB_CONTROL
+	bool "  Enable Job control"
+	default y
+	depends on CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_ASH_ALIAS
+	bool "  Enable alias support"
+	default y
+	depends on CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_ASH_MATH_SUPPORT
+	bool "  Enable Posix math support"
+	default y
+	depends on CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_ASH_GETOPTS
+	bool "  Enable getopt builtin to parse positional parameters"
+	default n
+	depends on CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_ASH_CMDCMD
+	bool "  Enable cmdcmd to override shell builtins"
+	default n
+	depends on CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_ASH_MAIL
+	bool "  Check for new mail on interactive shells"
+	default y
+	depends on CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_ASH_OPTIMIZE_FOR_SIZE
+	bool "  Optimize for size instead of speed"
+	default y
+	depends on CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_COMMAND_SAVEHISTORY
+	bool "  history saving"
+	default n
+	depends on CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+if CONFIG_FEATURE_SH_IS_HUSH
+	config CONFIG_HUSH
+	default y
+
+	comment "hush (forced enabled as default shell)"
+endif
+	
+if !CONFIG_FEATURE_SH_IS_HUSH
+config CONFIG_HUSH
+	bool "hush"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+endif
+
+if CONFIG_FEATURE_SH_IS_LASH
+	config CONFIG_LASH
+	default y
+
+	comment "lash (forced enabled as default shell)"
+endif
+
+if !CONFIG_FEATURE_SH_IS_LASH
+config CONFIG_LASH
+	bool "lash"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+endif
+
+if CONFIG_FEATURE_SH_IS_MSH
+	config CONFIG_MSH
+	default y
+
+	comment "msh (forced enabled as default shell)"
+endif
+
+if !CONFIG_FEATURE_SH_IS_MSH
+config CONFIG_MSH
+	bool "msh"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+endif
+
+
+comment "Bourne Shell Options"
+	depends on CONFIG_MSH || CONFIG_LASH || CONFIG_HUSH || CONFIG_ASH
+
+config CONFIG_FEATURE_COMMAND_EDITING
+	bool "command line editing"
+	default n
+	depends on CONFIG_MSH || CONFIG_LASH || CONFIG_HUSH || CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_COMMAND_TAB_COMPLETION
+	bool "tab completion"
+	default n
+	depends on CONFIG_MSH || CONFIG_LASH || CONFIG_HUSH || CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION
+	bool "username completion"
+	default n
+	depends on CONFIG_MSH || CONFIG_LASH || CONFIG_HUSH || CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_COMMAND_HISTORY
+	int "history size"
+	default 15
+	depends on CONFIG_MSH || CONFIG_LASH || CONFIG_HUSH || CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SH_STANDALONE_SHELL
+	bool "Standalone shell"
+	default n
+	depends on CONFIG_MSH || CONFIG_LASH || CONFIG_HUSH || CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SH_APPLETS_ALWAYS_WIN
+	bool "Standalone shell -- applets always win"
+	default n
+	depends on CONFIG_MSH || CONFIG_LASH || CONFIG_HUSH || CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SH_FANCY_PROMPT
+	bool "Fancy shell prompts"
+	default n
+	depends on CONFIG_MSH || CONFIG_LASH || CONFIG_HUSH || CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SH_EXTRA_QUIET
+	bool "Hide message on interactive shell startup"
+	default n
+	depends on CONFIG_MSH || CONFIG_LASH || CONFIG_HUSH || CONFIG_ASH
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
+
diff --git a/shell/config.in b/shell/config.in
deleted file mode 100644
index cb1365b9d..000000000
--- a/shell/config.in
+++ /dev/null
@@ -1,63 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Bourne Shell'
-
-choice 'Choose your default shell' \
-    "ash                                    CONFIG_FEATURE_SH_IS_ASH  \
-    hush                                    CONFIG_FEATURE_SH_IS_HUSH \
-    lash                                    CONFIG_FEATURE_SH_IS_LASH \
-    msh                                     CONFIG_FEATURE_SH_IS_MSH  \
-    none                                    CONFIG_FEATURE_SH_IS_NONE" \
-    ash
-
-if [ "$CONFIG_FEATURE_SH_IS_ASH" = "y" ] ; then
-	define_bool CONFIG_ASH	y
-fi
-	
-if [ "$CONFIG_FEATURE_SH_IS_HUSH" = "y" ] ; then
-	define_bool CONFIG_HUSH	y
-fi
-
-if [ "$CONFIG_FEATURE_SH_IS_LASH" = "y" ] ; then
-	define_bool CONFIG_LASH	y
-fi
-
-if [ "$CONFIG_FEATURE_SH_IS_MSH" = "y" ] ; then
-	define_bool CONFIG_MSH	y
-fi
-
-bool 'ash'	    CONFIG_ASH
-if [ "$CONFIG_ASH" = "y" ] ; then
-	comment 'Ash Shell Options'
-	bool 'Enable Job control'		CONFIG_ASH_JOB_CONTROL
-	bool 'Enable alias support'		CONFIG_ASH_ALIAS
-	bool 'Enable Posix math support'	CONFIG_ASH_MATH_SUPPORT
-	bool 'Enable getopt builtin to parse positional parameters'		CONFIG_ASH_GETOPTS
-	bool 'Enable cmdcmd to override shell builtins'		CONFIG_ASH_CMDCMD
-	bool 'Check for new mail on interactive shells'		CONFIG_ASH_MAIL
-	bool 'Optimize for size instead of speed'	CONFIG_ASH_OPTIMIZE_FOR_SIZE
-	comment ''
-fi
-
-bool 'hush'	    CONFIG_HUSH
-bool 'lash'	    CONFIG_LASH
-bool 'msh'	    CONFIG_MSH
-
-	
-comment 'Bourne Shell Options'
-bool 'command line editing'		CONFIG_FEATURE_COMMAND_EDITING
-bool 'tab completion'			CONFIG_FEATURE_COMMAND_TAB_COMPLETION
-bool 'username completion'		CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION
-int  'history size'             CONFIG_FEATURE_COMMAND_HISTORY  15
-bool 'history saving (currently only ash)'         CONFIG_FEATURE_COMMAND_SAVEHISTORY
-bool 'Standalone shell'			CONFIG_FEATURE_SH_STANDALONE_SHELL
-bool 'Standalone shell -- applets always win'	CONFIG_FEATURE_SH_APPLETS_ALWAYS_WIN
-bool 'Fancy shell prompts'	CONFIG_FEATURE_SH_FANCY_PROMPT
-bool 'Hide message on interactive shell startup'	CONFIG_FEATURE_SH_EXTRA_QUIET
-
-endmenu
-
diff --git a/sysdeps/linux/Config.in b/sysdeps/linux/Config.in
new file mode 100644
index 000000000..0fa66eac6
--- /dev/null
+++ b/sysdeps/linux/Config.in
@@ -0,0 +1,209 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+mainmenu "BusyBox Configuration"
+
+choice
+	prompt "Buffer allocation policy"
+	default "Allocate with Malloc"
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_BUFFERS_USE_MALLOC
+	bool "Allocate with Malloc"
+
+config CONFIG_FEATURE_BUFFERS_GO_ON_STACK
+	bool "Allocate on the Stack"
+
+config CONFIG_FEATURE_BUFFERS_GO_IN_BSS
+	bool "Allocate in the .bss section"
+
+endchoice
+
+config CONFIG_FEATURE_VERBOSE_USAGE
+	bool "Show verbose applet usage messages"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_INSTALLER
+	bool "Support --install [-s] to install applet links at runtime"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_LOCALE_SUPPORT
+	bool "Enable locale support (system needs locale for this to work)"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_DEVFS
+	bool "Support for devfs"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_DEVPTS
+	bool "Use the devpts filesystem for Unix98 PTYs"
+	default y if CONFIG_FEATURE_DEVFS
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_CLEAN_UP
+	bool "Clean up all memory before exiting (usually not needed)"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SUID
+	bool "Support for SUID/SGID handling"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SUID_CONFIG
+	bool "Runtime SUID/SGID configuration via /etc/busybox.conf"
+	default y if CONFIG_FEATURE_SUID
+	depends on CONFIG_FEATURE_SUID
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SUID_CONFIG_QUIET
+	bool "Suppress warning message if /etc/busybox.conf is not readable"
+	default n
+	depends on CONFIG_FEATURE_SUID_CONFIG
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
+
+menu 'Build Options'
+
+config DOSTATIC
+	bool "Build BusyBox as a static binary (no shared libs)"
+	default n
+	help
+	  If you want to build a static BusyBox binary, which does not 
+	  use or require any shared libraries, then enable this option.  
+
+config DOLFS
+	bool "Build with Large File Support (for accessing files > 2 GB)" 
+	default n
+	help
+	  If you want to build BusyBox with large file support, then enable
+	  this option.  This will have no effect if your kernel or your C
+	  library lacks large file support for large files.  Some of the
+	  programs that can benefit from large file support include dd, gzip,
+	  cp, mount, tar, and many others.  If you want to access files larger
+	  than 2 Gigabytes, enable this option.  Otherwise, leave it set to 'N'.
+
+config USING_CROSS_COMPILER
+	bool "Do you want to build BusyBox with a Cross Compiler?"
+	default n
+	help
+	  Do you want to build BusyBox with a Cross Compiler?  If so,
+	  then enable this option.  Otherwise leave it set to 'N'.
+
+config CROSS_COMPILER_PREFIX
+	string "Cross Compiler prefix"
+	default "/usr/i386-linux-uclibc/bin/i386-uclibc-"
+	depends on USING_CROSS_COMPILER
+	help
+	  If you want to build BusyBox with a cross compiler, then you 
+	  will need to set this to the cross-compiler prefix.  For example,
+	  if my cross-compiler is /usr/i386-linux-uclibc/bin/i386-uclibc-gcc
+	  then I would enter '/usr/i386-linux-uclibc/bin/i386-uclibc-' here,
+	  which will ensure the correct compiler is used.
+
+config EXTRA_CFLAGS_OPTIONS
+	string "Any extra CFLAGS options for the compiler?"
+	default ""
+	help
+	  Do you want to pass any extra CFLAGS options to the compiler as
+	  you build BusyBox? If so, this is the option for you...  For example,
+	  if you want to add some simple compiler switches (like -march=i686),
+	  or check for warnings using -Werror, just those options here.
+
+endmenu
+
+source archival/Config.in
+source console-tools/Config.in
+source debianutils/Config.in
+source editors/Config.in
+source fileutils/Config.in
+source findutils/Config.in
+source init/Config.in
+source loginutils/Config.in
+source miscutils/Config.in
+source modutils/Config.in
+source networking/Config.in
+source procps/Config.in
+source shell/Config.in
+source shellutils/Config.in
+source sysklogd/Config.in
+source textutils/Config.in
+source util-linux/Config.in
+
+menu 'Debugging Options'
+
+config DOSTATIC
+	bool "Build BusyBox as a static binary (no shared libs)"
+	default n
+	help
+	  If you want to build a static BusyBox binary, which does not 
+	  use or require any shared libraries, then enable this option.  
+	  This will make BusyBox be considerable larger, so you should
+	  leave this option false unless you have a good reason (i.e.
+	  your target platform does not support shared libraries, or
+	  you are building an initrd which doesn't need anything but
+	  BusyBox, etc).
+
+	  Most people will leave this set to 'N'.
+
+config DODEBUG
+	bool "Build BusyBox with Debugging symbols"
+	default n
+	help
+	  Say Y here if you wish to compile BusyBox with debugging symbols.
+	  This will allow you to use a debugger to examine BusyBox internals
+	  while applets are running.  This increases the size of the binary 
+	  considerably and should only be used when doing development.
+	  If you are doing development and want to debug BusyBox, answer Y.
+
+	  Otherwise, answer N.
+
+config DODMALLOC
+	bool "Build BusyBox with dmalloc support"
+	default n
+	depends on DODEBUG && !DOEFENCE
+	help
+	  This enables compiling with dmalloc ( http://dmalloc.com/ )
+	  which is an excellent public domain mem leak and malloc problem
+	  detector.  To enable dmalloc, before running busybox you will
+	  want to properly set your environment, for example:
+	    export DMALLOC_OPTIONS=debug=0x34f47d83,inter=100,log=logfile
+	  The 'debug=' value is generated using the following command
+	    dmalloc -p log-stats -p log-non-free -p log-bad-space -p log-elapsed-time \
+	       -p check-fence -p check-heap -p check-lists -p check-blank \
+	       -p check-funcs -p realloc-copy -p allow-free-null
+
+	  This will make BusyBox be considerable larger and run slower, so 
+	  you should leave this option disabled for production use.
+
+config DOEFENCE
+	bool "Build BusyBox with Electric-fence support"
+	default n
+	depends on DODEBUG && !DODMALLOC
+	help
+	  This enables compiling with Electric-fence support.  Electric
+	  fence is another very useful malloc debugging library which used
+	  your computers virtual memory hardware to detect illegal memory 
+	  accesses.  This support will make BusyBox be considerable larger 
+	  and run slower, so you should leave this option disabled unless 
+	  you are hunting a hard to find memory problem.
+
+endmenu
+
diff --git a/sysdeps/linux/config.in b/sysdeps/linux/config.in
deleted file mode 100644
index d33a9826d..000000000
--- a/sysdeps/linux/config.in
+++ /dev/null
@@ -1,49 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-mainmenu_name "BusyBox Configuration"
-
-mainmenu_option next_comment
-comment 'BusyBox general settings'
-choice 'Buffer allocation policy' \
-    "use_malloc	CONFIG_FEATURE_BUFFERS_USE_MALLOC \
-	 on_stack	CONFIG_FEATURE_BUFFERS_GO_ON_STACK \
-	 in_bss		CONFIG_FEATURE_BUFFERS_GO_IN_BSS" use_malloc
-bool 'Show verbose applet usage messages'				CONFIG_FEATURE_VERBOSE_USAGE
-bool 'Support --install [-s] to install applet links at runtime' 	CONFIG_FEATURE_INSTALLER
-bool 'Enable locale support (system needs locale for this to work)'	CONFIG_LOCALE_SUPPORT
-bool 'Support for devfs'						CONFIG_FEATURE_DEVFS
-if [ "$CONFIG_FEATURE_DEVFS" = "y" ]; then
-  define_bool CONFIG_FEATURE_DEVPTS	y
-else
-  bool '  Support for Unix98 PTY filesystem'				CONFIG_FEATURE_DEVPTS
-fi
-bool 'Clean up all memory before exiting (usually not needed)'		CONFIG_FEATURE_CLEAN_UP
-bool 'Support for SUID/SGID handling'  					CONFIG_FEATURE_SUID
-if [ "$CONFIG_FEATURE_SUID" = "y" ]; then
-  bool '  Runtime configuration via /etc/busybox.conf'			CONFIG_FEATURE_SUID_CONFIG
-fi
-if [ "$CONFIG_FEATURE_SUID_CONFIG" = "y" ]; then
-  bool '    Suppress message if config file is not readable'			CONFIG_FEATURE_SUID_CONFIG_QUIET
-fi
-endmenu
-
-source archival/config.in
-source console-tools/config.in
-source debianutils/config.in
-source editors/config.in
-source fileutils/config.in
-source findutils/config.in
-source init/config.in
-source loginutils/config.in
-source miscutils/config.in
-source modutils/config.in
-source networking/config.in
-source procps/config.in
-source shell/config.in
-source shellutils/config.in
-source sysklogd/config.in
-source textutils/config.in
-source util-linux/config.in
-
diff --git a/sysklogd/Config.in b/sysklogd/Config.in
new file mode 100644
index 000000000..5bded0675
--- /dev/null
+++ b/sysklogd/Config.in
@@ -0,0 +1,48 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "System Logging Utilities"
+
+config CONFIG_KLOGD
+	bool "klogd"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_LOGGER
+	bool "logger"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_SYSLOGD
+	bool "syslogd"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_REMOTE_LOG
+	bool "  Remote Log support"
+	default n
+	depends on CONFIG_SYSLOGD
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_IPC_SYSLOG
+	bool "  Circular Buffer support"
+	default n
+	depends on CONFIG_SYSLOGD
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_LOGREAD
+	bool "  logread"
+	default y
+	depends on CONFIG_FEATURE_IPC_SYSLOG
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
+
diff --git a/sysklogd/config.in b/sysklogd/config.in
deleted file mode 100644
index be8b16066..000000000
--- a/sysklogd/config.in
+++ /dev/null
@@ -1,21 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'System Logging Utilities'
-
-bool 'klogd'	    CONFIG_KLOGD
-bool 'logger'	    CONFIG_LOGGER
-bool 'syslogd'	    CONFIG_SYSLOGD
-if [ "$CONFIG_SYSLOGD" = "y" ] ; then
-	bool ' Remote Log support ' CONFIG_FEATURE_REMOTE_LOG
-	bool ' Circular Buffer support ' CONFIG_FEATURE_IPC_SYSLOG
-	if [ "$CONFIG_FEATURE_IPC_SYSLOG" = "y" ] ; then
-		bool '  logread ' CONFIG_LOGREAD
-	fi 
-fi
-
-endmenu
-
diff --git a/util-linux/Config.in b/util-linux/Config.in
new file mode 100644
index 000000000..0c84c77af
--- /dev/null
+++ b/util-linux/Config.in
@@ -0,0 +1,232 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Linux System Utilities"
+
+
+config CONFIG_DMESG
+	bool "dmesg"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FBSET
+	bool "fbset"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_FBSET_FANCY
+	bool "  Turn on extra fbset options"
+	default n
+	depends on CONFIG_FBSET
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_FBSET_READMODE
+	bool "  Turn on fbset readmode support"
+	default n
+	depends on CONFIG_FBSET
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FDFLUSH
+	bool "fdflush"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FDISK
+	bool "fdisk"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_AIX_LABEL
+	bool "  Support AIX disklabels"
+	default n
+	depends on CONFIG_FDISK
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SGI_LABEL
+	bool "  Support SGI disklabels"
+	default n
+	depends on CONFIG_FDISK
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_SUN_LABEL
+	bool "  Support SUN disklabels"
+	default n
+	depends on CONFIG_FDISK
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_OSF_LABEL
+	bool "  Support BSD disklabels"
+	default n
+	depends on CONFIG_FDISK
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_FDISK_ADVANCED
+	bool "  Support expert mode"
+	default n
+	depends on CONFIG_FDISK
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FREERAMDISK
+	bool "freeramdisk"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FSCK_MINIX
+	bool "fsck_minix"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_MKFS_MINIX
+	bool "mkfs_minix"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+comment "Minix filesystem support"
+    depends on CONFIG_FSCK_MINIX || CONFIG_MKFS_MINIX
+
+config CONFIG_FEATURE_MINIX2
+	bool "  Support Minix fs v2 (fsck_minix/mkfs_minix)"
+	default y
+	depends on CONFIG_FSCK_MINIX || CONFIG_MKFS_MINIX
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_GETOPT
+	bool "getopt"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_HEXDUMP
+	bool "hexdump"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_HWCLOCK
+	bool "hwclock"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_HWCLOCK_LONGOPTIONS
+	bool "  Support long options (--hctosys,...)"
+	default n
+	depends on CONFIG_HWCLOCK
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_LOSETUP
+	bool "losetup"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_MKSWAP
+	bool "mkswap"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_MORE
+	bool "more"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_USE_TERMIOS
+	bool "  Use termios to manipulate the screen"
+	default y
+	depends on CONFIG_MORE
+	help
+	  Please submit a patch to add help text for this item.
+
+comment "Common options for ls and more"
+	depends on CONFIG_LS || CONFIG_MORE
+
+config CONFIG_FEATURE_AUTOWIDTH
+	bool "  Calculate terminal & column widths"
+	default y
+	depends on CONFIG_LS || CONFIG_MORE
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_PIVOT_ROOT
+	bool "pivot_root"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_RDATE
+	bool "rdate"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_SWAPONOFF
+	bool "swaponoff"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_MOUNT
+	bool "mount"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_NFSMOUNT
+	bool "  Support mounting nfs file systems"
+	default n
+	depends on CONFIG_MOUNT
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_UMOUNT
+	bool "umount"
+	default n
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_MOUNT_FORCE
+	bool "  Support forced filesystem unmounting"
+	default n
+	depends on CONFIG_UMOUNT
+	help
+	  Please submit a patch to add help text for this item.
+
+comment "Common options for mount/umount"
+	depends on CONFIG_MOUNT || CONFIG_UMOUNT
+
+config CONFIG_FEATURE_MOUNT_LOOP
+	bool "  Support for loop devices"
+	default n
+	depends on CONFIG_MOUNT || CONFIG_UMOUNT
+	help
+	  Please submit a patch to add help text for this item.
+
+config CONFIG_FEATURE_MTAB_SUPPORT
+	bool "  Support for a real /etc/mtab (instead of /proc/mounts)"
+	default n
+	depends on CONFIG_MOUNT || CONFIG_UMOUNT
+	help
+	  Please submit a patch to add help text for this item.
+
+endmenu
+
diff --git a/util-linux/config.in b/util-linux/config.in
deleted file mode 100644
index eee050a05..000000000
--- a/util-linux/config.in
+++ /dev/null
@@ -1,69 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see scripts/kbuild/config-language.txt.
-#
-
-mainmenu_option next_comment
-comment 'Linux System Utilities'
-
-
-bool 'dmesg'		    CONFIG_DMESG
-bool 'fbset'		    CONFIG_FBSET
-if [ "$CONFIG_FBSET" = "y" ]; then
-    bool '  Turn on extra fbset options'	CONFIG_FEATURE_FBSET_FANCY
-    bool '  Turn on fbset readmode support'	CONFIG_FEATURE_FBSET_READMODE
-fi
-bool 'fdflush'		    CONFIG_FDFLUSH
-bool 'fdisk'                CONFIG_FDISK
-if [ "$CONFIG_FDISK" = "y" ]; then
-    bool '  Support AIX disklabels'        CONFIG_FEATURE_AIX_LABEL
-    bool '  Support SGI disklabels'        CONFIG_FEATURE_SGI_LABEL
-    bool '  Support SUN disklabels'        CONFIG_FEATURE_SUN_LABEL
-    bool '  Support BSD disklabels'        CONFIG_FEATURE_OSF_LABEL
-    bool '  Support expert mode'           CONFIG_FEATURE_FDISK_ADVANCED
-fi
-bool 'freeramdisk'	    CONFIG_FREERAMDISK
-bool 'fsck_minix'	    CONFIG_FSCK_MINIX
-bool 'mkfs_minix'	    CONFIG_MKFS_MINIX
-if [ "$CONFIG_FSCK_MINIX" = "y" -o "$CONFIG_MKFS_MINIX" = "y" ]; then
-    comment '  Minix filesystem support'
-    bool '    Support Minix fs v2 (fsck_minix/mkfs_minix)'	CONFIG_FEATURE_MINIX2
-fi
-bool 'getopt'		    CONFIG_GETOPT
-bool 'hexdump'  	    CONFIG_HEXDUMP  
-bool 'hwclock'  	    CONFIG_HWCLOCK  
-if [ "$CONFIG_HWCLOCK" = "y" ]; then
-    bool '  Support long options (--hctosys,...)'		CONFIG_FEATURE_HWCLOCK_LONGOPTIONS
-fi
-bool 'losetup'              CONFIG_LOSETUP
-bool 'mkswap'		    CONFIG_MKSWAP
-bool 'more'		    CONFIG_MORE
-if [ "$CONFIG_MORE" = "y" ]; then
-    bool '  Use termios to manipulate the screen'		CONFIG_FEATURE_USE_TERMIOS
-fi 
-if [ "$CONFIG_LS" = "y" -o "$CONFIG_MORE" = "y" ]; then
-    comment '  Common options for ls and more'
-    bool    '   Calculate terminal & column widths'	CONFIG_FEATURE_AUTOWIDTH
-fi
-bool 'pivot_root'	    CONFIG_PIVOT_ROOT
-bool 'rdate'		    CONFIG_RDATE
-bool 'swaponoff'	    CONFIG_SWAPONOFF
-bool 'mount'		    CONFIG_MOUNT
-if [ "$CONFIG_MOUNT" = "y" ]; then
-    bool '  Support mounting nfs file systems'		    	CONFIG_NFSMOUNT
-    if [ "$CONFIG_FEATURE_USE_DEVPS_PATCH" = "n" ]; then
-	bool '  Use devmtab instead of /proc (needs a patched kernel)'	CONFIG_FEATURE_USE_DEVPS_PATCH
-    fi
-fi
-bool 'umount'		    CONFIG_UMOUNT
-if [ "$CONFIG_UMOUNT" = "y" ]; then
-    bool '  Support forced filesystem unmounting'		CONFIG_FEATURE_MOUNT_FORCE
-fi
-if [ "$CONFIG_MOUNT" = "y" -o "$CONFIG_UMOUNT" = "y" ]; then
-    comment 'Common options for mount/umount'
-    bool '  Support for loop devices'				CONFIG_FEATURE_MOUNT_LOOP
-    bool '  Support for a real /etc/mtab (instead of /proc/mounts)'	CONFIG_FEATURE_MTAB_SUPPORT
-fi
-
-endmenu
-