"2006-08-08 01:39:49 +0000"
diff --git a/include/libbb.h b/include/libbb.h
index 745f8372b..963a0290c 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -407,7 +407,7 @@ extern const char * const bb_default_login_shell;
 #define DEFAULT_SHELL_SHORT_NAME     (bb_default_login_shell+6)
 
 
-extern const char bb_path_mtab_file[];
+extern char bb_path_mtab_file[];
 
 extern int bb_default_error_retval;
 
diff --git a/include/platform.h b/include/platform.h
index 8890d4ffd..ca6f3634f 100644
--- a/include/platform.h
+++ b/include/platform.h
@@ -228,6 +228,35 @@ typedef unsigned long long int  uintmax_t;
 
 #if defined(__linux__)
 #include <sys/mount.h>
+// Make sure we have all the new mount flags we actually try to use.
+#ifndef MS_BIND
+#define MS_BIND        (1<<12)
+#endif
+#ifndef MS_MOVE
+#define MS_MOVE        (1<<13)
+#endif
+#ifndef MS_RECURSIVE
+#define MS_RECURSIVE   (1<<14)
+#endif
+#ifndef MS_SILENT
+#define MS_SILENT      (1<<15)
+#endif
+
+// The shared subtree stuff, which went in around 2.6.15
+#ifndef MS_UNBINDABLE
+#define MS_UNBINDABLE  (1<<17)
+#endif
+#ifndef MS_PRIVATE
+#define MS_PRIVATE     (1<<18)
+#endif
+#ifndef MS_SLAVE
+#define MS_SLAVE       (1<<19)
+#endif
+#ifndef MS_SHARED
+#define MS_SHARED      (1<<20)
+#endif
+
+ 
 #if !defined(BLKSSZGET)
 #define BLKSSZGET _IO(0x12, 104)
 #endif
diff --git a/libbb/mtab_file.c b/libbb/mtab_file.c
index 3821a6806..92bd2394f 100644
--- a/libbb/mtab_file.c
+++ b/libbb/mtab_file.c
@@ -13,8 +13,5 @@
 
 /* Busybox mount uses either /proc/mounts or /etc/mtab to
  * get the list of currently mounted filesystems */
-#if defined(CONFIG_FEATURE_MTAB_SUPPORT)
-const char bb_path_mtab_file[] = "/etc/mtab";
-#else
-const char bb_path_mtab_file[] = "/proc/mounts";
-#endif
+char bb_path_mtab_file[] =	USE_FEATURE_MTAB_SUPPORT("/etc/mtab")
+							SKIP_FEATURE_MTAB_SUPPORT("/proc/mounts");
diff --git a/util-linux/Config.in b/util-linux/Config.in
index 65d670824..2222e5c38 100644
--- a/util-linux/Config.in
+++ b/util-linux/Config.in
@@ -370,7 +370,24 @@ config CONFIG_FEATURE_MOUNT_NFS
 	default n
 	depends on CONFIG_MOUNT
 	help
-	 Enable mounting of NFS file systems.
+	  Enable mounting of NFS file systems.
+
+config CONFIG_FEATURE_MOUNT_FLAGS
+	depends on CONFIG_MOUNT
+	bool "Support lots of -o flags in mount."
+	default y
+	help
+	  Without this, mount only supports ro/rw/remount.  With this, it
+	  supports nosuid, suid, dev, nodev, exec, noexec, sync, async, atime,
+	  noatime, diratime, nodiratime, loud, bind, move, shared, slave,
+	  private, unbindable, rshared, rslave, rprivate, and runbindable.
+
+config CONFIG_FEATURE_MOUNT_FSTAB
+	depends on CONFIG_MOUNT
+	bool "Support /etc/fstab and -a"
+	default y
+	help
+	  Support mount all and looking for files in /etc/fstab.
 
 config CONFIG_PIVOT_ROOT
 	bool "pivot_root"
diff --git a/util-linux/mount.c b/util-linux/mount.c
index d5d3eae17..5d5f487c2 100644
--- a/util-linux/mount.c
+++ b/util-linux/mount.c
@@ -25,17 +25,6 @@
 #include "busybox.h"
 #include <mntent.h>
 
-// These two aren't always defined in old headers
-#ifndef MS_BIND
-#define MS_BIND		4096
-#endif
-#ifndef MS_MOVE
-#define MS_MOVE		8192
-#endif
-#ifndef MS_SILENT
-#define MS_SILENT	32768
-#endif
-
 // Not real flags, but we want to be able to check for this.
 #define MOUNT_NOAUTO    (1<<29)
 #define MOUNT_SWAP      (1<<30)
@@ -43,40 +32,59 @@
  * flags */
 
 struct {
-	const char *name;
+	char *name;
 	long flags;
-} static const mount_options[] = {
-	// NOP flags.
-
-	{"loop", 0},
-	{"defaults", 0},
-	{"quiet", 0},
-
-	// vfs flags
-
-	{"ro", MS_RDONLY},
-	{"rw", ~MS_RDONLY},
-	{"nosuid", MS_NOSUID},
-	{"suid", ~MS_NOSUID},
-	{"dev", ~MS_NODEV},
-	{"nodev", MS_NODEV},
-	{"exec", ~MS_NOEXEC},
-	{"noexec", MS_NOEXEC},
-	{"sync", MS_SYNCHRONOUS},
-	{"async", ~MS_SYNCHRONOUS},
-	{"atime", ~MS_NOATIME},
-	{"noatime", MS_NOATIME},
-	{"diratime", ~MS_NODIRATIME},
-	{"nodiratime", MS_NODIRATIME},
-	{"loud", ~MS_SILENT},
-
-	// action flags
-
-	{"remount", MS_REMOUNT},
-	{"bind", MS_BIND},
-	{"move", MS_MOVE},
-	{"noauto",MOUNT_NOAUTO},
-	{"swap",MOUNT_SWAP}
+} static mount_options[] = {
+	// MS_FLAGS set a bit.  ~MS_FLAGS disable that bit.  0 flags are NOPs.
+
+	USE_FEATURE_MOUNT_LOOP(
+		{"loop", 0},
+	)
+
+	USE_FEATURE_MOUNT_FSTAB(
+		{"defaults", 0},
+		{"quiet", 0},
+		{"noauto",MOUNT_NOAUTO},
+		{"swap",MOUNT_SWAP},
+	)
+
+	USE_FEATURE_MOUNT_FLAGS(
+		// vfs flags
+		{"nosuid", MS_NOSUID},
+		{"suid", ~MS_NOSUID},
+		{"dev", ~MS_NODEV},
+		{"nodev", MS_NODEV},
+		{"exec", ~MS_NOEXEC},
+		{"noexec", MS_NOEXEC},
+		{"sync", MS_SYNCHRONOUS},
+		{"async", ~MS_SYNCHRONOUS},
+		{"atime", ~MS_NOATIME},
+		{"noatime", MS_NOATIME},
+		{"diratime", ~MS_NODIRATIME},
+		{"nodiratime", MS_NODIRATIME},
+		{"loud", ~MS_SILENT},
+
+		// action flags
+
+		{"bind", MS_BIND},
+		{"move", MS_MOVE},
+		{"shared", MS_SHARED},
+		{"slave", MS_SLAVE},
+		{"private", MS_PRIVATE},
+		{"unbindable", MS_UNBINDABLE},
+		{"rshared", MS_SHARED|MS_RECURSIVE},
+		{"rslave", MS_SLAVE|MS_RECURSIVE},
+		{"rprivate", MS_SLAVE|MS_RECURSIVE},
+		{"runbindable", MS_UNBINDABLE|MS_RECURSIVE},
+	)
+
+	// Always understood.
+
+	{"ro", MS_RDONLY},        // vfs flag
+	{"rw", ~MS_RDONLY},       // vfs flag
+	{"remount", MS_REMOUNT},  // action flag
+
+
 };
 
 /* Append mount options to string */
@@ -225,9 +233,8 @@ static int mount_it_now(struct mntent *mp, int vfsflags, char *filteropts)
 
 		for(i=0; mount_options[i].flags != MS_REMOUNT; i++)
 			if (mount_options[i].flags > 0)
-				append_mount_options(&(mp->mnt_opts),
-// Shut up about the darn const.  It's not important.  I don't care.
-						(char *)mount_options[i].name);
+// Shut up about the darn const.  It's not important.  I don't care.  (char *)
+				append_mount_options(&(mp->mnt_opts), mount_options[i].name);
 
 		// Remove trailing / (if any) from directory we mounted on
 
@@ -285,8 +292,8 @@ static int singlemount(struct mntent *mp, int ignore_busy)
 	// Look at the file.  (Not found isn't a failure for remount, or for
 	// a synthetic filesystem like proc or sysfs.)
 
-	if (stat(mp->mnt_fsname, &st));
-	else if (!(vfsflags & (MS_REMOUNT | MS_BIND | MS_MOVE))) {
+	if (!lstat(mp->mnt_fsname, &st) && !(vfsflags & (MS_REMOUNT | MS_BIND | MS_MOVE | MS_SHARED | MS_PRIVATE || MS_SLAVE | MS_UNBINDABLE)))
+	{
 		// Do we need to allocate a loopback device for it?
 
 		if (ENABLE_FEATURE_MOUNT_LOOP && S_ISREG(st.st_mode)) {
@@ -456,7 +463,7 @@ int mount_main(int argc, char **argv)
 	// Open either fstab or mtab
 
 	if (parse_mount_options(cmdopts,0) & MS_REMOUNT)
-		fstabname = (char *)bb_path_mtab_file;  // Again with the evil const.
+		fstabname = bb_path_mtab_file;  // Again with the evil const (char *).
 	else fstabname="/etc/fstab";
 
 	if (!(fstab=setmntent(fstabname,"r")))