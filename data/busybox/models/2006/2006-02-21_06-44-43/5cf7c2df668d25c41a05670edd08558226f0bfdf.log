"2006-02-21 06:44:43 +0000"
diff --git a/Config.in b/Config.in
index 070085b94..e1d5020a7 100644
--- a/Config.in
+++ b/Config.in
@@ -322,6 +322,7 @@ source networking/Config.in
 source procps/Config.in
 source shell/Config.in
 source sysklogd/Config.in
+source libbb/Config.in
 
 menu 'Debugging Options'
 
diff --git a/coreutils/Config.in b/coreutils/Config.in
index ffdc11ced..cd45cc077 100644
--- a/coreutils/Config.in
+++ b/coreutils/Config.in
@@ -315,21 +315,6 @@ config CONFIG_MD5SUM
 	help
 	  md5sum is used to print or check MD5 checksums.
 
-config CONFIG_MD5SUM_SIZE_VS_SPEED
-	int "  Trade Bytes for Speed"
-	default 2
-	range 0 3
-	depends on CONFIG_MD5SUM
-	help
-	  Trade binary size versus speed for the md5sum algorithm.
-	  Approximate values running uClibc and hashing
-	  linux-2.4.4.tar.bz2 were:
-	                    user times (sec)  text size (386)
-	  0 (fastest)         1.1                6144
-	  1                   1.4                5392
-	  2                   3.0                5088
-	  3 (smallest)        5.1                4912
-
 config CONFIG_MKDIR
 	bool "mkdir"
 	default n
diff --git a/coreutils/md5_sha1_sum.c b/coreutils/md5_sha1_sum.c
index 287c2f524..626dcee56 100644
--- a/coreutils/md5_sha1_sum.c
+++ b/coreutils/md5_sha1_sum.c
@@ -15,6 +15,7 @@
 
 #include "busybox.h"
 
+typedef enum { HASH_SHA1, HASH_MD5 } hash_algo_t;
 
 #define FLAG_SILENT	1
 #define FLAG_CHECK	2
@@ -35,39 +36,70 @@ static unsigned char *hash_bin_to_hex(unsigned char *hash_value,
 	return (hex_value);
 }
 
-static uint8_t *hash_file(const char *filename, uint8_t hash_algo)
+static uint8_t *hash_file(const char *filename, hash_algo_t hash_algo)
 {
-	int src_fd = strcmp(filename, "-") == 0 ? STDIN_FILENO :
-		open(filename, O_RDONLY);
-	if (src_fd == -1) {
+	int src_fd, hash_len, count;
+	union _ctx_ {
+		sha1_ctx_t sha1;
+		md5_ctx_t md5;
+	} context;
+	uint8_t *hash_value = NULL;
+	RESERVE_CONFIG_UBUFFER(in_buf, 4096);
+	void (*update)(const void*, size_t, void*);
+	void (*final)(void*, void*);
+	
+	if(strcmp(filename, "-") == 0) {
+		src_fd = STDIN_FILENO;
+	} else if(0 > (src_fd = open(filename, O_RDONLY))) {
 		bb_perror_msg("%s", filename);
 		return NULL;
+	}
+
+	// figure specific hash algorithims
+	if(ENABLE_MD5SUM && hash_algo==HASH_MD5) {
+		md5_begin(&context.md5);
+		update = (void (*)(const void*, size_t, void*))md5_hash;
+		final = (void (*)(void*, void*))md5_end;
+		hash_len = 16;
+	} else if(ENABLE_SHA1SUM && hash_algo==HASH_SHA1) {
+		sha1_begin(&context.sha1);
+		update = (void (*)(const void*, size_t, void*))sha1_hash;
+		final = (void (*)(void*, void*))sha1_end;
+		hash_len = 20;
 	} else {
-		uint8_t *hash_value;
-		RESERVE_CONFIG_UBUFFER(hash_value_bin, 20);
-		hash_value = hash_fd(src_fd, -1, hash_algo, hash_value_bin) != -2 ?
-			hash_bin_to_hex(hash_value_bin, hash_algo == HASH_MD5 ? 16 : 20) :
-			NULL;
-		RELEASE_CONFIG_BUFFER(hash_value_bin);
+		bb_error_msg_and_die("algotithm not supported");
+	}
+	
+
+	while(0 < (count = read(src_fd, in_buf, sizeof in_buf))) {
+		update(in_buf, count, &context);
+	}
+
+	if(count == 0) {
+		final(in_buf, &context);
+		hash_value = hash_bin_to_hex(in_buf, hash_len);
+	}
+	
+	RELEASE_CONFIG_BUFFER(in_buf);
+	
+	if(src_fd != STDIN_FILENO) {
 		close(src_fd);
-		return hash_value;
 	}
+	
+	return hash_value;
 }
 
 /* This could become a common function for md5 as well, by using md5_stream */
-static int hash_files(int argc, char **argv, const uint8_t hash_algo)
+static int hash_files(int argc, char **argv, hash_algo_t hash_algo)
 {
 	int return_value = EXIT_SUCCESS;
 	uint8_t *hash_value;
-
-#ifdef CONFIG_FEATURE_MD5_SHA1_SUM_CHECK
 	unsigned int flags;
 
-	flags = bb_getopt_ulflags(argc, argv, "scw");
-#endif
+	if (ENABLE_FEATURE_MD5_SHA1_SUM_CHECK)
+		flags = bb_getopt_ulflags(argc, argv, "scw");
 
-#ifdef CONFIG_FEATURE_MD5_SHA1_SUM_CHECK
-	if (!(flags & FLAG_CHECK)) {
+	if (ENABLE_FEATURE_MD5_SHA1_SUM_CHECK && !(flags & FLAG_CHECK)) {
 		if (flags & FLAG_SILENT) {
 			bb_error_msg_and_die
 				("the -s option is meaningful only when verifying checksums");
@@ -76,13 +108,12 @@ static int hash_files(int argc, char **argv, const uint8_t hash_algo)
 				("the -w option is meaningful only when verifying checksums");
 		}
 	}
-#endif
 
 	if (argc == optind) {
 		argv[argc++] = "-";
 	}
-#ifdef CONFIG_FEATURE_MD5_SHA1_SUM_CHECK
-	if (flags & FLAG_CHECK) {
+	
+	if (ENABLE_FEATURE_MD5_SHA1_SUM_CHECK && flags & FLAG_CHECK) {
 		FILE *pre_computed_stream;
 		int count_total = 0;
 		int count_failed = 0;
@@ -139,9 +170,7 @@ static int hash_files(int argc, char **argv, const uint8_t hash_algo)
 		if (bb_fclose_nonstdin(pre_computed_stream) == EOF) {
 			bb_perror_msg_and_die("Couldnt close file %s", file_ptr);
 		}
-	} else
-#endif
-	{
+	} else {
 		while (optind < argc) {
 			char *file_ptr = argv[optind++];
 
diff --git a/include/libbb.h b/include/libbb.h
index 9f0c85b03..0ede812a9 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -464,9 +464,29 @@ extern void vfork_daemon_rexec(int nochdir, int noclose,
 extern int get_terminal_width_height(int fd, int *width, int *height);
 extern unsigned long get_ug_id(const char *s, long (*__bb_getxxnam)(const char *));
 
-#define HASH_SHA1	1
-#define HASH_MD5	2
-extern int hash_fd(int fd, const size_t size, const uint8_t hash_algo, uint8_t *hashval);
+typedef struct _sha1_ctx_t_ {
+	uint32_t count[2];
+	uint32_t hash[5];
+	uint32_t wbuf[16];
+} sha1_ctx_t;
+
+void sha1_begin(sha1_ctx_t *ctx);
+void sha1_hash(const void *data, size_t length, sha1_ctx_t *ctx);
+void *sha1_end(void *resbuf, sha1_ctx_t *ctx);
+
+typedef struct _md5_ctx_t_ {
+	uint32_t A;
+	uint32_t B;
+	uint32_t C;
+	uint32_t D;
+	uint32_t total[2];
+	uint32_t buflen;
+	char buffer[128];
+} md5_ctx_t;
+
+void md5_begin(md5_ctx_t *ctx);
+void md5_hash(const void *data, size_t length, md5_ctx_t *ctx);
+void *md5_end(void *resbuf, md5_ctx_t *ctx);
 
 /* busybox.h will include dmalloc later for us, else include it here.  */
 #if !defined _BB_INTERNAL_H_ && defined DMALLOC
diff --git a/include/platform.h b/include/platform.h
index 68c7abbc6..b19621af1 100644
--- a/include/platform.h
+++ b/include/platform.h
@@ -78,4 +78,19 @@
 # endif
 #endif
 
+/* ---- Endian Detection ------------------------------------ */
+#ifndef __APPLE__
+    #include <byteswap.h>
+    #include <endian.h>
+#endif
+
+#ifdef __BIG_ENDIAN__
+    #define BB_BIG_ENDIAN 1
+#elif __BYTE_ORDER == __BIG_ENDIAN
+    #define BB_BIG_ENDIAN 1
+#else 
+    #define BB_BIG_ENDIAN 0
+#endif
+
+
 #endif	/* platform.h	*/
diff --git a/libbb/Config.in b/libbb/Config.in
new file mode 100644
index 000000000..3ddb7d96c
--- /dev/null
+++ b/libbb/Config.in
@@ -0,0 +1,22 @@
+#
+# For a description of the syntax of this configuration file,
+# see scripts/kbuild/config-language.txt.
+#
+
+menu "Busybox Library Tuning"
+
+config CONFIG_MD5_SIZE_VS_SPEED
+	int " MD5: Trade Bytes for Speed"
+	default 2
+	range 0 3
+	help
+	  Trade binary size versus speed for the md5sum algorithm.
+	  Approximate values running uClibc and hashing
+	  linux-2.4.4.tar.bz2 were:
+	                    user times (sec)  text size (386)
+	  0 (fastest)         1.1                6144
+	  1                   1.4                5392
+	  2                   3.0                5088
+	  3 (smallest)        5.1                4912
+
+endmenu
diff --git a/libbb/hash_fd.c b/libbb/md5.c
similarity index 53%
rename from libbb/hash_fd.c
rename to libbb/md5.c
index 39825b378..8cec88535 100644
--- a/libbb/hash_fd.c
+++ b/libbb/md5.c
@@ -1,15 +1,16 @@
 /*
- *  Based on shasum from http://www.netsw.org/crypto/hash/
- *  Majorly hacked up to use Dr Brian Gladman's sha1 code
- *
+ *  md5.c - Compute MD5 checksum of strings according to the
+ *          definition of MD5 in RFC 1321 from April 1992.
+ * 
+ *  Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
+ *  
+ *  Copyright (C) 1995-1999 Free Software Foundation, Inc.
+ *  Copyright (C) 2001 Manuel Novoa III
  *  Copyright (C) 2003 Glenn L. McGrath
  *  Copyright (C) 2003 Erik Andersen
  *
- * Licensed under the GPL v2 or later, see the file LICENSE in this tarball.
+ *  Licensed under the GPL v2 or later, see the file LICENSE in this tarball.
  */
-
-#include <byteswap.h>
-#include <endian.h>
 #include <fcntl.h>
 #include <limits.h>
 #include <stdio.h>
@@ -20,253 +21,14 @@
 
 #include "busybox.h"
 
-
-#ifdef CONFIG_SHA1SUM
-/*
- ---------------------------------------------------------------------------
- Begin Dr. Gladman's sha1 code
- ---------------------------------------------------------------------------
-*/
-
-/*
- ---------------------------------------------------------------------------
- Copyright (c) 2002, Dr Brian Gladman <brg@gladman.me.uk>, Worcester, UK.
- All rights reserved.
-
- LICENSE TERMS
-
- The free distribution and use of this software in both source and binary
- form is allowed (with or without changes) provided that:
-
-   1. distributions of this source code include the above copyright
-      notice, this list of conditions and the following disclaimer;
-
-   2. distributions in binary form include the above copyright
-      notice, this list of conditions and the following disclaimer
-      in the documentation and/or other associated materials;
-
-   3. the copyright holder's name is not used to endorse products
-      built using this software without specific written permission.
-
- ALTERNATIVELY, provided that this notice is retained in full, this product
- may be distributed under the terms of the GNU General Public License (GPL),
- in which case the provisions of the GPL apply INSTEAD OF those given above.
-
- DISCLAIMER
-
- This software is provided 'as is' with no explicit or implied warranties
- in respect of its properties, including, but not limited to, correctness
- and/or fitness for purpose.
- ---------------------------------------------------------------------------
- Issue Date: 10/11/2002
-
- This is a byte oriented version of SHA1 that operates on arrays of bytes
- stored in memory. It runs at 22 cycles per byte on a Pentium P4 processor
-*/
-
-# define SHA1_BLOCK_SIZE  64
-# define SHA1_DIGEST_SIZE 20
-# define SHA1_HASH_SIZE   SHA1_DIGEST_SIZE
-# define SHA2_GOOD        0
-# define SHA2_BAD         1
-
-# define rotl32(x,n) (((x) << n) | ((x) >> (32 - n)))
-
-# if __BYTE_ORDER == __BIG_ENDIAN
-#  define swap_b32(x) (x)
-# elif defined(bswap_32)
-#  define swap_b32(x) bswap_32(x)
+# if CONFIG_MD5_SIZE_VS_SPEED < 0 || CONFIG_MD5_SIZE_VS_SPEED > 3
+# define MD5_SIZE_VS_SPEED 2
 # else
-#  define swap_b32(x) ((rotl32((x), 8) & 0x00ff00ff) | (rotl32((x), 24) & 0xff00ff00))
-# endif /* __BYTE_ORDER */
-
-# define SHA1_MASK   (SHA1_BLOCK_SIZE - 1)
-
-/* reverse byte order in 32-bit words   */
-#define ch(x,y,z)       ((z) ^ ((x) & ((y) ^ (z))))
-#define parity(x,y,z)   ((x) ^ (y) ^ (z))
-#define maj(x,y,z)      (((x) & (y)) | ((z) & ((x) | (y))))
-
-/* A normal version as set out in the FIPS. This version uses   */
-/* partial loop unrolling and is optimised for the Pentium 4    */
-# define rnd(f,k)    \
-    t = a; a = rotl32(a,5) + f(b,c,d) + e + k + w[i]; \
-    e = d; d = c; c = rotl32(b, 30); b = t
-
-/* type to hold the SHA1 context  */
-struct sha1_ctx_t {
-	uint32_t count[2];
-	uint32_t hash[5];
-	uint32_t wbuf[16];
-};
-
-static void sha1_compile(struct sha1_ctx_t *ctx)
-{
-	uint32_t w[80], i, a, b, c, d, e, t;
-
-	/* note that words are compiled from the buffer into 32-bit */
-	/* words in big-endian order so an order reversal is needed */
-	/* here on little endian machines                           */
-	for (i = 0; i < SHA1_BLOCK_SIZE / 4; ++i)
-		w[i] = swap_b32(ctx->wbuf[i]);
-
-	for (i = SHA1_BLOCK_SIZE / 4; i < 80; ++i)
-		w[i] = rotl32(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1);
-
-	a = ctx->hash[0];
-	b = ctx->hash[1];
-	c = ctx->hash[2];
-	d = ctx->hash[3];
-	e = ctx->hash[4];
-
-	for (i = 0; i < 20; ++i) {
-		rnd(ch, 0x5a827999);
-	}
-
-	for (i = 20; i < 40; ++i) {
-		rnd(parity, 0x6ed9eba1);
-	}
-
-	for (i = 40; i < 60; ++i) {
-		rnd(maj, 0x8f1bbcdc);
-	}
-
-	for (i = 60; i < 80; ++i) {
-		rnd(parity, 0xca62c1d6);
-	}
-
-	ctx->hash[0] += a;
-	ctx->hash[1] += b;
-	ctx->hash[2] += c;
-	ctx->hash[3] += d;
-	ctx->hash[4] += e;
-}
-
-static void sha1_begin(struct sha1_ctx_t *ctx)
-{
-	ctx->count[0] = ctx->count[1] = 0;
-	ctx->hash[0] = 0x67452301;
-	ctx->hash[1] = 0xefcdab89;
-	ctx->hash[2] = 0x98badcfe;
-	ctx->hash[3] = 0x10325476;
-	ctx->hash[4] = 0xc3d2e1f0;
-}
-
-/* SHA1 hash data in an array of bytes into hash buffer and call the        */
-/* hash_compile function as required.                                       */
-static void sha1_hash(const void *data, size_t len, void *ctx_v)
-{
-	struct sha1_ctx_t *ctx = (struct sha1_ctx_t *) ctx_v;
-	uint32_t pos = (uint32_t) (ctx->count[0] & SHA1_MASK);
-	uint32_t freeb = SHA1_BLOCK_SIZE - pos;
-	const unsigned char *sp = data;
-
-	if ((ctx->count[0] += len) < len)
-		++(ctx->count[1]);
-
-	while (len >= freeb) {	/* tranfer whole blocks while possible  */
-		memcpy(((unsigned char *) ctx->wbuf) + pos, sp, freeb);
-		sp += freeb;
-		len -= freeb;
-		freeb = SHA1_BLOCK_SIZE;
-		pos = 0;
-		sha1_compile(ctx);
-	}
-
-	memcpy(((unsigned char *) ctx->wbuf) + pos, sp, len);
-}
-
-/* SHA1 Final padding and digest calculation  */
-# if __BYTE_ORDER == __LITTLE_ENDIAN
-static uint32_t mask[4] = { 0x00000000, 0x000000ff, 0x0000ffff, 0x00ffffff };
-static uint32_t bits[4] = { 0x00000080, 0x00008000, 0x00800000, 0x80000000 };
-# else
-static uint32_t mask[4] = { 0x00000000, 0xff000000, 0xffff0000, 0xffffff00 };
-static uint32_t bits[4] = { 0x80000000, 0x00800000, 0x00008000, 0x00000080 };
-# endif /* __BYTE_ORDER */
-
-static void sha1_end(unsigned char hval[], struct sha1_ctx_t *ctx)
-{
-	uint32_t i, cnt = (uint32_t) (ctx->count[0] & SHA1_MASK);
-
-	/* mask out the rest of any partial 32-bit word and then set    */
-	/* the next byte to 0x80. On big-endian machines any bytes in   */
-	/* the buffer will be at the top end of 32 bit words, on little */
-	/* endian machines they will be at the bottom. Hence the AND    */
-	/* and OR masks above are reversed for little endian systems    */
-	ctx->wbuf[cnt >> 2] =
-		(ctx->wbuf[cnt >> 2] & mask[cnt & 3]) | bits[cnt & 3];
-
-	/* we need 9 or more empty positions, one for the padding byte  */
-	/* (above) and eight for the length count.  If there is not     */
-	/* enough space pad and empty the buffer                        */
-	if (cnt > SHA1_BLOCK_SIZE - 9) {
-		if (cnt < 60)
-			ctx->wbuf[15] = 0;
-		sha1_compile(ctx);
-		cnt = 0;
-	} else				/* compute a word index for the empty buffer positions  */
-		cnt = (cnt >> 2) + 1;
-
-	while (cnt < 14)	/* and zero pad all but last two positions      */
-		ctx->wbuf[cnt++] = 0;
-
-	/* assemble the eight byte counter in the buffer in big-endian  */
-	/* format					               */
-
-	ctx->wbuf[14] = swap_b32((ctx->count[1] << 3) | (ctx->count[0] >> 29));
-	ctx->wbuf[15] = swap_b32(ctx->count[0] << 3);
-
-	sha1_compile(ctx);
-
-	/* extract the hash value as bytes in case the hash buffer is   */
-	/* misaligned for 32-bit words                                  */
-
-	for (i = 0; i < SHA1_DIGEST_SIZE; ++i)
-		hval[i] = (unsigned char) (ctx->hash[i >> 2] >> 8 * (~i & 3));
-}
-
-/*
- ---------------------------------------------------------------------------
- End of Dr. Gladman's sha1 code
- ---------------------------------------------------------------------------
-*/
-#endif	/* CONFIG_SHA1 */
-
-
-
-
-
-#ifdef CONFIG_MD5SUM
-/*
- * md5sum.c - Compute MD5 checksum of files or strings according to the
- *            definition of MD5 in RFC 1321 from April 1992.
- *
- * Copyright (C) 1995-1999 Free Software Foundation, Inc.
- * Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
- *
- *
- * June 29, 2001        Manuel Novoa III
- *
- * Added MD5SUM_SIZE_VS_SPEED configuration option.
- *
- * Current valid values, with data from my system for comparison, are:
- *   (using uClibc and running on linux-2.4.4.tar.bz2)
- *                     user times (sec)  text size (386)
- *     0 (fastest)         1.1                6144
- *     1                   1.4                5392
- *     2                   3.0                5088
- *     3 (smallest)        5.1                4912
- */
-
-# if CONFIG_MD5SUM_SIZE_VS_SPEED < 0 || CONFIG_MD5SUM_SIZE_VS_SPEED > 3
-# define MD5SUM_SIZE_VS_SPEED 2
-# else
-# define MD5SUM_SIZE_VS_SPEED CONFIG_MD5SUM_SIZE_VS_SPEED
+# define MD5_SIZE_VS_SPEED CONFIG_MD5_SIZE_VS_SPEED
 # endif
 
 /* Handle endian-ness */
-# if __BYTE_ORDER == __LITTLE_ENDIAN
+# if !BB_BIG_ENDIAN
 #  define SWAP(n) (n)
 # elif defined(bswap_32)
 #  define SWAP(n) bswap_32(n)
@@ -274,27 +36,16 @@ static void sha1_end(unsigned char hval[], struct sha1_ctx_t *ctx)
 #  define SWAP(n) ((n << 24) | ((n&65280)<<8) | ((n&16711680)>>8) | (n>>24))
 # endif
 
-# if MD5SUM_SIZE_VS_SPEED == 0
+# if MD5_SIZE_VS_SPEED == 0
 /* This array contains the bytes used to pad the buffer to the next
    64-byte boundary.  (RFC 1321, 3.1: Step 1)  */
 static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */  };
-# endif	/* MD5SUM_SIZE_VS_SPEED == 0 */
-
-/* Structure to save state of computation between the single steps.  */
-struct md5_ctx_t {
-	uint32_t A;
-	uint32_t B;
-	uint32_t C;
-	uint32_t D;
-	uint32_t total[2];
-	uint32_t buflen;
-	char buffer[128];
-};
+# endif	/* MD5_SIZE_VS_SPEED == 0 */
 
 /* Initialize structure containing state of computation.
  * (RFC 1321, 3.3: Step 3)
  */
-static void md5_begin(struct md5_ctx_t *ctx)
+void md5_begin(md5_ctx_t *ctx)
 {
 	ctx->A = 0x67452301;
 	ctx->B = 0xefcdab89;
@@ -320,14 +71,14 @@ static void md5_begin(struct md5_ctx_t *ctx)
  * starting at BUFFER.
  * It is necessary that LEN is a multiple of 64!!!
  */
-static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx)
+void md5_hash_block(const void *buffer, size_t len, md5_ctx_t *ctx)
 {
 	uint32_t correct_words[16];
 	const uint32_t *words = buffer;
 	size_t nwords = len / sizeof(uint32_t);
 	const uint32_t *endp = words + nwords;
 
-# if MD5SUM_SIZE_VS_SPEED > 0
+# if MD5_SIZE_VS_SPEED > 0
 	static const uint32_t C_array[] = {
 		/* round 1 */
 		0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
@@ -352,22 +103,22 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
 	};
 
 	static const char P_array[] = {
-#  if MD5SUM_SIZE_VS_SPEED > 1
+#  if MD5_SIZE_VS_SPEED > 1
 		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,	/* 1 */
-#  endif	/* MD5SUM_SIZE_VS_SPEED > 1 */
+#  endif	/* MD5_SIZE_VS_SPEED > 1 */
 		1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12,	/* 2 */
 		5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2,	/* 3 */
 		0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9	/* 4 */
 	};
 
-#  if MD5SUM_SIZE_VS_SPEED > 1
+#  if MD5_SIZE_VS_SPEED > 1
 	static const char S_array[] = {
 		7, 12, 17, 22,
 		5, 9, 14, 20,
 		4, 11, 16, 23,
 		6, 10, 15, 21
 	};
-#  endif	/* MD5SUM_SIZE_VS_SPEED > 1 */
+#  endif	/* MD5_SIZE_VS_SPEED > 1 */
 # endif
 
 	uint32_t A = ctx->A;
@@ -391,7 +142,7 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
 		uint32_t C_save = C;
 		uint32_t D_save = D;
 
-# if MD5SUM_SIZE_VS_SPEED > 1
+# if MD5_SIZE_VS_SPEED > 1
 #  define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))
 
 		const uint32_t *pc;
@@ -405,7 +156,7 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
 		}
 		words += 16;
 
-#  if MD5SUM_SIZE_VS_SPEED > 2
+#  if MD5_SIZE_VS_SPEED > 2
 		pc = C_array;
 		pp = P_array;
 		ps = S_array - 4;
@@ -481,7 +232,7 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
 			B = temp;
 		}
 
-#  endif	/* MD5SUM_SIZE_VS_SPEED > 2 */
+#  endif	/* MD5_SIZE_VS_SPEED > 2 */
 # else
 		/* First round: using the given function, the context and a constant
 		   the next context is computed.  Because the algorithms processing
@@ -511,14 +262,14 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
 		   T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
 		 */
 
-#  if MD5SUM_SIZE_VS_SPEED == 1
+#  if MD5_SIZE_VS_SPEED == 1
 		const uint32_t *pc;
 		const char *pp;
 		int i;
-#  endif	/* MD5SUM_SIZE_VS_SPEED */
+#  endif	/* MD5_SIZE_VS_SPEED */
 
 		/* Round 1.  */
-#  if MD5SUM_SIZE_VS_SPEED == 1
+#  if MD5_SIZE_VS_SPEED == 1
 		pc = C_array;
 		for (i = 0; i < 4; i++) {
 			OP(A, B, C, D, 7, *pc++);
@@ -543,7 +294,7 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
 		OP(D, A, B, C, 12, 0xfd987193);
 		OP(C, D, A, B, 17, 0xa679438e);
 		OP(B, C, D, A, 22, 0x49b40821);
-#  endif	/* MD5SUM_SIZE_VS_SPEED == 1 */
+#  endif	/* MD5_SIZE_VS_SPEED == 1 */
 
 		/* For the second to fourth round we have the possibly swapped words
 		   in CORRECT_WORDS.  Redefine the macro to take an additional first
@@ -559,7 +310,7 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
       while (0)
 
 		/* Round 2.  */
-#  if MD5SUM_SIZE_VS_SPEED == 1
+#  if MD5_SIZE_VS_SPEED == 1
 		pp = P_array;
 		for (i = 0; i < 4; i++) {
 			OP(FG, A, B, C, D, (int) (*pp++), 5, *pc++);
@@ -584,10 +335,10 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
 		OP(FG, D, A, B, C, 2, 9, 0xfcefa3f8);
 		OP(FG, C, D, A, B, 7, 14, 0x676f02d9);
 		OP(FG, B, C, D, A, 12, 20, 0x8d2a4c8a);
-#  endif	/* MD5SUM_SIZE_VS_SPEED == 1 */
+#  endif	/* MD5_SIZE_VS_SPEED == 1 */
 
 		/* Round 3.  */
-#  if MD5SUM_SIZE_VS_SPEED == 1
+#  if MD5_SIZE_VS_SPEED == 1
 		for (i = 0; i < 4; i++) {
 			OP(FH, A, B, C, D, (int) (*pp++), 4, *pc++);
 			OP(FH, D, A, B, C, (int) (*pp++), 11, *pc++);
@@ -611,10 +362,10 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
 		OP(FH, D, A, B, C, 12, 11, 0xe6db99e5);
 		OP(FH, C, D, A, B, 15, 16, 0x1fa27cf8);
 		OP(FH, B, C, D, A, 2, 23, 0xc4ac5665);
-#  endif	/* MD5SUM_SIZE_VS_SPEED == 1 */
+#  endif	/* MD5_SIZE_VS_SPEED == 1 */
 
 		/* Round 4.  */
-#  if MD5SUM_SIZE_VS_SPEED == 1
+#  if MD5_SIZE_VS_SPEED == 1
 		for (i = 0; i < 4; i++) {
 			OP(FI, A, B, C, D, (int) (*pp++), 6, *pc++);
 			OP(FI, D, A, B, C, (int) (*pp++), 10, *pc++);
@@ -638,8 +389,8 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
 		OP(FI, D, A, B, C, 11, 10, 0xbd3af235);
 		OP(FI, C, D, A, B, 2, 15, 0x2ad7d2bb);
 		OP(FI, B, C, D, A, 9, 21, 0xeb86d391);
-#  endif	/* MD5SUM_SIZE_VS_SPEED == 1 */
-# endif	/* MD5SUM_SIZE_VS_SPEED > 1 */
+#  endif	/* MD5_SIZE_VS_SPEED == 1 */
+# endif	/* MD5_SIZE_VS_SPEED > 1 */
 
 		/* Add the starting values of the context.  */
 		A += A_save;
@@ -661,7 +412,7 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
  * It is NOT required that LEN is a multiple of 64.
  */
 
-static void md5_hash_bytes(const void *buffer, size_t len, struct md5_ctx_t *ctx)
+static void md5_hash_bytes(const void *buffer, size_t len, md5_ctx_t *ctx)
 {
 	/* When we already have some bits in our internal buffer concatenate
 	   both inputs first.  */
@@ -698,12 +449,12 @@ static void md5_hash_bytes(const void *buffer, size_t len, struct md5_ctx_t *ctx
 	}
 }
 
-static void md5_hash(const void *buffer, size_t length, void *md5_ctx)
+void md5_hash(const void *data, size_t length, md5_ctx_t *ctx)
 {
 	if (length % 64 == 0) {
-		md5_hash_block(buffer, length, md5_ctx);
+		md5_hash_block(data, length, ctx);
 	} else {
-		md5_hash_bytes(buffer, length, md5_ctx);
+		md5_hash_bytes(data, length, ctx);
 	}
 }
 
@@ -715,7 +466,7 @@ static void md5_hash(const void *buffer, size_t length, void *md5_ctx)
  * IMPORTANT: On some systems it is required that RESBUF is correctly
  * aligned for a 32 bits value.
  */
-static void *md5_end(void *resbuf, struct md5_ctx_t *ctx)
+void *md5_end(void *resbuf, md5_ctx_t *ctx)
 {
 	/* Take yet unprocessed bytes into account.  */
 	uint32_t bytes = ctx->buflen;
@@ -727,12 +478,12 @@ static void *md5_end(void *resbuf, struct md5_ctx_t *ctx)
 		++ctx->total[1];
 
 	pad = bytes >= 56 ? 64 + 56 - bytes : 56 - bytes;
-# if MD5SUM_SIZE_VS_SPEED > 0
+# if MD5_SIZE_VS_SPEED > 0
 	memset(&ctx->buffer[bytes], 0, pad);
 	ctx->buffer[bytes] = 0x80;
 # else
 	memcpy(&ctx->buffer[bytes], fillbuf, pad);
-# endif	/* MD5SUM_SIZE_VS_SPEED > 0 */
+# endif	/* MD5_SIZE_VS_SPEED > 0 */
 
 	/* Put the 64-bit file length in *bits* at the end of the buffer.  */
 	*(uint32_t *) & ctx->buffer[bytes + pad] = SWAP(ctx->total[0] << 3);
@@ -756,96 +507,4 @@ static void *md5_end(void *resbuf, struct md5_ctx_t *ctx)
 
 	return resbuf;
 }
-#endif	/* CONFIG_MD5SUM */
-
-
-
-
-extern int hash_fd(int src_fd, const size_t size, const uint8_t hash_algo,
-				   uint8_t * hashval)
-{
-	int result = EXIT_SUCCESS;
-//	size_t hashed_count = 0;
-	size_t blocksize = 0;
-	size_t remaining = size;
-	unsigned char *buffer = NULL;
-	void (*hash_fn_ptr)(const void *, size_t, void *) = NULL;
-	void *cx = NULL;
-
-#ifdef CONFIG_SHA1SUM
-	struct sha1_ctx_t sha1_cx;
-#endif
-#ifdef CONFIG_MD5SUM
-	struct md5_ctx_t md5_cx;
-#endif
-
-
-#ifdef CONFIG_SHA1SUM
-	if (hash_algo == HASH_SHA1) {
-		/* Ensure that BLOCKSIZE is a multiple of 64.  */
-		blocksize = 65536;
-		buffer = xmalloc(blocksize);
-		hash_fn_ptr = sha1_hash;
-		cx = &sha1_cx;
-	}
-#endif
-#ifdef CONFIG_MD5SUM
-	if (hash_algo == HASH_MD5) {
-		blocksize = 4096;
-		buffer = xmalloc(blocksize + 72);
-		hash_fn_ptr = md5_hash;
-		cx = &md5_cx;
-	}
-#endif
-
-	/* Initialize the computation context.  */
-#ifdef CONFIG_SHA1SUM
-	if (hash_algo == HASH_SHA1) {
-		sha1_begin(&sha1_cx);
-	}
-#endif
-#ifdef CONFIG_MD5SUM
-	if (hash_algo == HASH_MD5) {
-		md5_begin(&md5_cx);
-	}
-#endif
-	/* Iterate over full file contents.  */
-	while ((remaining == (size_t) -1) || (remaining > 0)) {
-		size_t read_try;
-		ssize_t read_got;
-
-		if (remaining > blocksize) {
-			read_try = blocksize;
-		} else {
-			read_try = remaining;
-		}
-		read_got = bb_full_read(src_fd, buffer, read_try);
-		if (read_got < 1) {
-			/* count == 0 means short read
-			 * count == -1 means read error */
-			result = read_got - 1;
-			break;
-		}
-		if (remaining != (size_t) -1) {
-			remaining -= read_got;
-		}
-
-		/* Process buffer */
-		hash_fn_ptr(buffer, read_got, cx);
-	}
 
-	/* Finalize and write the hash into our buffer.  */
-#ifdef CONFIG_SHA1SUM
-	if (hash_algo == HASH_SHA1) {
-		sha1_end(hashval, &sha1_cx);
-	}
-#endif
-#ifdef CONFIG_MD5SUM
-	if (hash_algo == HASH_MD5) {
-		md5_end(hashval, &md5_cx);
-	}
-#endif
-
-	free(buffer);
-	return result;
-}
diff --git a/libbb/sha1.c b/libbb/sha1.c
new file mode 100644
index 000000000..f0d952f84
--- /dev/null
+++ b/libbb/sha1.c
@@ -0,0 +1,200 @@
+/*
+ *  Based on shasum from http://www.netsw.org/crypto/hash/
+ *  Majorly hacked up to use Dr Brian Gladman's sha1 code
+ *
+ *  Copyright (C) 2002 Dr Brian Gladman <brg@gladman.me.uk>, Worcester, UK.
+ *  Copyright (C) 2003 Glenn L. McGrath
+ *  Copyright (C) 2003 Erik Andersen
+ *  
+ *  LICENSE TERMS
+ *
+ *  The free distribution and use of this software in both source and binary
+ *  form is allowed (with or without changes) provided that:
+ *
+ *    1. distributions of this source code include the above copyright
+ *       notice, this list of conditions and the following disclaimer;
+ *
+ *    2. distributions in binary form include the above copyright
+ *       notice, this list of conditions and the following disclaimer
+ *       in the documentation and/or other associated materials;
+ *
+ *    3. the copyright holder's name is not used to endorse products
+ *       built using this software without specific written permission.
+ *
+ *  ALTERNATIVELY, provided that this notice is retained in full, this product
+ *  may be distributed under the terms of the GNU General Public License (GPL),
+ *  in which case the provisions of the GPL apply INSTEAD OF those given above.
+ *
+ *  DISCLAIMER
+ *
+ *  This software is provided 'as is' with no explicit or implied warranties
+ *  in respect of its properties, including, but not limited to, correctness
+ *  and/or fitness for purpose.
+ *  ---------------------------------------------------------------------------
+ *  Issue Date: 10/11/2002
+ *
+ *  This is a byte oriented version of SHA1 that operates on arrays of bytes
+ *  stored in memory. It runs at 22 cycles per byte on a Pentium P4 processor
+ */
+
+#include <fcntl.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "busybox.h"
+
+# define SHA1_BLOCK_SIZE  64
+# define SHA1_DIGEST_SIZE 20
+# define SHA1_HASH_SIZE   SHA1_DIGEST_SIZE
+# define SHA2_GOOD        0
+# define SHA2_BAD         1
+
+# define rotl32(x,n) (((x) << n) | ((x) >> (32 - n)))
+
+# define SHA1_MASK   (SHA1_BLOCK_SIZE - 1)
+
+/* reverse byte order in 32-bit words   */
+#define ch(x,y,z)       ((z) ^ ((x) & ((y) ^ (z))))
+#define parity(x,y,z)   ((x) ^ (y) ^ (z))
+#define maj(x,y,z)      (((x) & (y)) | ((z) & ((x) | (y))))
+
+/* A normal version as set out in the FIPS. This version uses   */
+/* partial loop unrolling and is optimised for the Pentium 4    */
+# define rnd(f,k)    \
+    t = a; a = rotl32(a,5) + f(b,c,d) + e + k + w[i]; \
+    e = d; d = c; c = rotl32(b, 30); b = t
+
+
+static void sha1_compile(sha1_ctx_t *ctx)
+{
+	uint32_t w[80], i, a, b, c, d, e, t;
+
+	/* note that words are compiled from the buffer into 32-bit */
+	/* words in big-endian order so an order reversal is needed */
+	/* here on little endian machines                           */
+	for (i = 0; i < SHA1_BLOCK_SIZE / 4; ++i)
+		w[i] = htonl(ctx->wbuf[i]);
+
+	for (i = SHA1_BLOCK_SIZE / 4; i < 80; ++i)
+		w[i] = rotl32(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1);
+
+	a = ctx->hash[0];
+	b = ctx->hash[1];
+	c = ctx->hash[2];
+	d = ctx->hash[3];
+	e = ctx->hash[4];
+
+	for (i = 0; i < 20; ++i) {
+		rnd(ch, 0x5a827999);
+	}
+
+	for (i = 20; i < 40; ++i) {
+		rnd(parity, 0x6ed9eba1);
+	}
+
+	for (i = 40; i < 60; ++i) {
+		rnd(maj, 0x8f1bbcdc);
+	}
+
+	for (i = 60; i < 80; ++i) {
+		rnd(parity, 0xca62c1d6);
+	}
+
+	ctx->hash[0] += a;
+	ctx->hash[1] += b;
+	ctx->hash[2] += c;
+	ctx->hash[3] += d;
+	ctx->hash[4] += e;
+}
+
+void sha1_begin(sha1_ctx_t *ctx)
+{
+	ctx->count[0] = ctx->count[1] = 0;
+	ctx->hash[0] = 0x67452301;
+	ctx->hash[1] = 0xefcdab89;
+	ctx->hash[2] = 0x98badcfe;
+	ctx->hash[3] = 0x10325476;
+	ctx->hash[4] = 0xc3d2e1f0;
+}
+
+/* SHA1 hash data in an array of bytes into hash buffer and call the        */
+/* hash_compile function as required.                                       */
+void sha1_hash(const void *data, size_t length, sha1_ctx_t *ctx)
+{
+	uint32_t pos = (uint32_t) (ctx->count[0] & SHA1_MASK);
+	uint32_t freeb = SHA1_BLOCK_SIZE - pos;
+	const unsigned char *sp = data;
+
+	if ((ctx->count[0] += length) < length)
+		++(ctx->count[1]);
+
+	while (length >= freeb) {	/* tranfer whole blocks while possible  */
+		memcpy(((unsigned char *) ctx->wbuf) + pos, sp, freeb);
+		sp += freeb;
+		length -= freeb;
+		freeb = SHA1_BLOCK_SIZE;
+		pos = 0;
+		sha1_compile(ctx);
+	}
+
+	memcpy(((unsigned char *) ctx->wbuf) + pos, sp, length);
+}
+
+void *sha1_end(void *resbuf, sha1_ctx_t *ctx)
+{
+	/* SHA1 Final padding and digest calculation  */
+	#if BB_BIG_ENDIAN
+		static uint32_t mask[4] = { 0x00000000, 0xff000000, 0xffff0000, 0xffffff00 };
+		static uint32_t bits[4] = { 0x80000000, 0x00800000, 0x00008000, 0x00000080 };
+	#else
+		static uint32_t mask[4] = { 0x00000000, 0x000000ff, 0x0000ffff, 0x00ffffff };
+		static uint32_t bits[4] = { 0x00000080, 0x00008000, 0x00800000, 0x80000000 };
+	#endif /* __BYTE_ORDER */
+
+	uint8_t *hval = resbuf;
+	uint32_t i, cnt = (uint32_t) (ctx->count[0] & SHA1_MASK);
+
+	/* mask out the rest of any partial 32-bit word and then set    */
+	/* the next byte to 0x80. On big-endian machines any bytes in   */
+	/* the buffer will be at the top end of 32 bit words, on little */
+	/* endian machines they will be at the bottom. Hence the AND    */
+	/* and OR masks above are reversed for little endian systems    */
+	ctx->wbuf[cnt >> 2] =
+		(ctx->wbuf[cnt >> 2] & mask[cnt & 3]) | bits[cnt & 3];
+
+	/* we need 9 or more empty positions, one for the padding byte  */
+	/* (above) and eight for the length count.  If there is not     */
+	/* enough space pad and empty the buffer                        */
+	if (cnt > SHA1_BLOCK_SIZE - 9) {
+		if (cnt < 60)
+			ctx->wbuf[15] = 0;
+		sha1_compile(ctx);
+		cnt = 0;
+	} else				/* compute a word index for the empty buffer positions  */
+		cnt = (cnt >> 2) + 1;
+
+	while (cnt < 14)	/* and zero pad all but last two positions      */
+		ctx->wbuf[cnt++] = 0;
+
+	/* assemble the eight byte counter in the buffer in big-endian  */
+	/* format					               */
+
+	ctx->wbuf[14] = htonl((ctx->count[1] << 3) | (ctx->count[0] >> 29));
+	ctx->wbuf[15] = htonl(ctx->count[0] << 3);
+
+	sha1_compile(ctx);
+
+	/* extract the hash value as bytes in case the hash buffer is   */
+	/* misaligned for 32-bit words                                  */
+
+	for (i = 0; i < SHA1_DIGEST_SIZE; ++i)
+		hval[i] = (unsigned char) (ctx->hash[i >> 2] >> 8 * (~i & 3));
+	
+	return resbuf;
+}
+
+