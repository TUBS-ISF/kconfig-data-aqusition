"2006-01-25 00:08:53 +0000"
diff --git a/README b/README
index 27da49587..ae72c4244 100644
--- a/README
+++ b/README
@@ -41,7 +41,7 @@ Using busybox:
   The behavior of busybox is determined by the name it's called under: as
   "cp" it behaves like cp, as "sed" it behaves like sed, and so on.  Called
   as "busybox" it takes the second argument as the name of the applet to
-  run (I.E. "./busybox ls -l /proc"). 
+  run (I.E. "./busybox ls -l /proc").
 
   The "standalone shell" mode is an easy way to try out busybox; this is a
   command shell that calls the builtin applets without needing them to be
diff --git a/applets/busybox.c b/applets/busybox.c
index db78b7ccd..be1f19ad2 100644
--- a/applets/busybox.c
+++ b/applets/busybox.c
@@ -108,7 +108,7 @@ int busybox_main(int argc, char **argv)
 	}
 
 	/* Deal with --help.  (Also print help when called with no arguments) */
-	
+
 	if (argc==1 || !strcmp(argv[1],"--help") ) {
 		if (argc>2) {
 			run_applet_by_name(bb_applet_name=argv[2], 2, argv);
@@ -144,7 +144,7 @@ int busybox_main(int argc, char **argv)
 			exit(0);
 		}
 	} else run_applet_by_name(bb_applet_name=argv[1], argc-1, argv+1);
-	
+
 	bb_error_msg_and_die("applet not found");
 }
 
diff --git a/archival/Config.in b/archival/Config.in
index e7d5debb0..7810c354d 100644
--- a/archival/Config.in
+++ b/archival/Config.in
@@ -47,10 +47,10 @@ config CONFIG_BUNZIP2
 	  is generally considerably better than that achieved by more
 	  conventional LZ77/LZ78-based compressors, and approaches the
 	  performance of the PPM family of statistical compressors.
-	
+
 	  The BusyBox bunzip2 applet is limited to de-compression only.
 	  On an x86 system, this applet adds about 11K.
-	
+
 	  Unless you have a specific application which requires bunzip2, you
 	  should probably say N here.
 
@@ -73,7 +73,7 @@ config CONFIG_DPKG
 	default n
 	help
 	  dpkg is a medium-level tool to install, build, remove and manage Debian packages.
-	
+
 	  This implementation of dpkg has a number of limitations, you should use the
 	  official dpkg if possible.
 
@@ -82,9 +82,9 @@ config CONFIG_DPKG_DEB
 	default n
 	help
 	  dpkg-deb packs, unpacks and provides information about Debian archives.
-	
+
 	  This implementation of dpkg-deb cannot pack archives.
-	
+
 	  Unless you have a specific application which requires dpkg-deb, you should
 	  probably say N here.
 
@@ -228,10 +228,10 @@ config CONFIG_UNLZMA
 	  compression algorithm, and range coding.  Compression
 	  is generally considerably better than that achieved by the bzip2
 	  compressors.
-	
+
 	  The BusyBox unlzma applet is limited to de-compression only.
 	  On an x86 system, this applet adds about 4K.
-	
+
 	  Unless you have a specific application which requires unlzma, you
 	  should probably say N here.
 
@@ -272,7 +272,7 @@ config CONFIG_FEATURE_DEB_TAR_GZ
 	depends on CONFIG_DPKG || CONFIG_DPKG_DEB
 	help
 	  This is the default compression method inside the debian ar file.
-	
+
 	  If you want compatibility with standard .deb's you should say yes here.
 
 config CONFIG_FEATURE_DEB_TAR_BZ2
@@ -282,7 +282,7 @@ config CONFIG_FEATURE_DEB_TAR_BZ2
 	help
 	  This allows dpkg and dpkg-deb to extract deb's that are compressed internally
 	  with bzip2 instead of gzip.
-	
+
 	  You only want this if you are creating your own custom debian packages that
 	  use an internal control.tar.bz2 or data.tar.bz2.
 
@@ -293,7 +293,7 @@ config CONFIG_FEATURE_DEB_TAR_LZMA
 	help
 	  This allows dpkg and dpkg-deb to extract deb's that are compressed
           internally with lzma instead of gzip.
-	
+
 	  You only want this if you are creating your own custom debian
           packages that use an internal control.tar.lzma or data.tar.lzma.
 
diff --git a/archival/ar.c b/archival/ar.c
index 983b5ae2c..05cb231aa 100644
--- a/archival/ar.c
+++ b/archival/ar.c
@@ -61,12 +61,12 @@ extern int ar_main(int argc, char **argv)
 {
 	archive_handle_t *archive_handle;
 	unsigned long opt;
-	static const char msg_unsupported_err[] = 
+	static const char msg_unsupported_err[] =
 			"Archive %s not supported.  Install binutils 'ar'.";
 	char magic[8];
 
 	archive_handle = init_handle();
-	
+
 	/* Prepend '-' to the first argument if required */
 	bb_opt_complementally = "--:p:t:x:-1:?:p--tx:t--px:x--pt";
 	opt = bb_getopt_ulflags(argc, argv, "ptxovcr");
diff --git a/archival/dpkg.c b/archival/dpkg.c
index 5f9f3a76b..7ed17d711 100644
--- a/archival/dpkg.c
+++ b/archival/dpkg.c
@@ -850,7 +850,7 @@ static void write_status_file(deb_file_t **deb_file)
 		}
 
 		tmp_string += 8;
- 		tmp_string += strspn(tmp_string, " \n\t");
+		tmp_string += strspn(tmp_string, " \n\t");
 		package_name = bb_xstrndup(tmp_string, strcspn(tmp_string, "\n\0"));
 		write_flag = FALSE;
 		tmp_string = strstr(control_buffer, "Status:");
@@ -989,8 +989,8 @@ static int package_satisfies_dependency(int package, int depend_type)
 		return 0;
 
 	switch (depend_type) {
-	case EDGE_PRE_DEPENDS: 	return get_status(status_num, 3) == search_name_hashtable("installed");
-	case EDGE_DEPENDS: 	return get_status(status_num, 1) == search_name_hashtable("install");
+	case EDGE_PRE_DEPENDS:	return get_status(status_num, 3) == search_name_hashtable("installed");
+	case EDGE_DEPENDS:	return get_status(status_num, 1) == search_name_hashtable("install");
 	}
 	return 0;
 }
@@ -1078,7 +1078,7 @@ static int check_deps(deb_file_t **deb_file, int deb_start, int dep_max_count)
 			}
 		}
 		i++;
-	}	
+	}
 
 
 	/* Check dependendcies */
@@ -1114,8 +1114,8 @@ static int check_deps(deb_file_t **deb_file, int deb_start, int dep_max_count)
 		 * things which are broken but unrelated to the
 		 * packages that are currently being installed
 		 */
-                if (state_status == search_name_hashtable("installed"))
-                        continue;
+		if (state_status == search_name_hashtable("installed"))
+			continue;
 #endif
 
 		/* This code is tested only for EDGE_DEPENDS, since I
@@ -1125,13 +1125,13 @@ static int check_deps(deb_file_t **deb_file, int deb_start, int dep_max_count)
 		for (j = 0; j < package_node->num_of_edges; j++) {
 			const edge_t *package_edge = package_node->edge[j];
 			unsigned int package_num;
-			
+
 			if ( package_edge->type == EDGE_OR_PRE_DEPENDS ||
-			     package_edge->type == EDGE_OR_DEPENDS ) { 	/* start an EDGE_OR_ list */
+			     package_edge->type == EDGE_OR_DEPENDS ) {	/* start an EDGE_OR_ list */
 				number_of_alternatives = package_edge->version;
 				root_of_alternatives = package_edge;
 				continue;
-			} else if ( number_of_alternatives == 0 ) { 	/* not in the middle of an EDGE_OR_ list */
+			} else if ( number_of_alternatives == 0 ) {	/* not in the middle of an EDGE_OR_ list */
 				number_of_alternatives = 1;
 				root_of_alternatives = NULL;
 			}
@@ -1329,7 +1329,7 @@ static void free_array(char **array)
  */
 static void list_packages(void)
 {
-        int i;
+	int i;
 
 	printf("    Name           Version\n");
 	printf("+++-==============-==============\n");
@@ -1715,7 +1715,7 @@ int dpkg_main(int argc, char **argv)
 
 			if (package_num == -1) {
 				bb_error_msg("Invalid control file in %s", argv[optind]);
-                                optind++;
+				optind++;
 				continue;
 			}
 			deb_file[deb_count]->package = (unsigned int) package_num;
diff --git a/archival/gzip.c b/archival/gzip.c
index 3aa077fbd..1f268dd26 100644
--- a/archival/gzip.c
+++ b/archival/gzip.c
@@ -1031,7 +1031,7 @@ static void fill_window(void)
  */
 #define FLUSH_BLOCK(eof) \
    flush_block(block_start >= 0L ? (char*)&window[(unsigned)block_start] : \
-                (char*)NULL, (long)strstart - block_start, (eof))
+		(char*)NULL, (long)strstart - block_start, (eof))
 
 /* ===========================================================================
  * Same as above, but achieves better compression. We use a lazy
diff --git a/archival/libunarchive/decompress_bunzip2.c b/archival/libunarchive/decompress_bunzip2.c
index 597ec85a3..af3731b15 100644
--- a/archival/libunarchive/decompress_bunzip2.c
+++ b/archival/libunarchive/decompress_bunzip2.c
@@ -51,9 +51,9 @@
 
 /* Constants for Huffman coding */
 #define MAX_GROUPS			6
-#define GROUP_SIZE   		50		/* 64 would have been more efficient */
-#define MAX_HUFCODE_BITS 	20		/* Longest Huffman code allowed */
-#define MAX_SYMBOLS 		258		/* 256 literals + RUNA + RUNB */
+#define GROUP_SIZE			50		/* 64 would have been more efficient */
+#define MAX_HUFCODE_BITS	20		/* Longest Huffman code allowed */
+#define MAX_SYMBOLS			258		/* 256 literals + RUNA + RUNB */
 #define SYMBOL_RUNA			0
 #define SYMBOL_RUNB			1
 
diff --git a/archival/libunarchive/decompress_unlzma.c b/archival/libunarchive/decompress_unlzma.c
index 977cb48d0..62811ddfc 100644
--- a/archival/libunarchive/decompress_unlzma.c
+++ b/archival/libunarchive/decompress_unlzma.c
@@ -50,9 +50,9 @@ typedef struct {
 #define LZMA_LEN_CHOICE_2 (LZMA_LEN_CHOICE + 1)
 #define LZMA_LEN_LOW (LZMA_LEN_CHOICE_2 + 1)
 #define LZMA_LEN_MID (LZMA_LEN_LOW \
-                      + (1 << (LZMA_NUM_POS_BITS_MAX + LZMA_LEN_NUM_LOW_BITS)))
+		      + (1 << (LZMA_NUM_POS_BITS_MAX + LZMA_LEN_NUM_LOW_BITS)))
 #define LZMA_LEN_HIGH (LZMA_LEN_MID \
-                       +(1 << (LZMA_NUM_POS_BITS_MAX + LZMA_LEN_NUM_MID_BITS)))
+		       +(1 << (LZMA_NUM_POS_BITS_MAX + LZMA_LEN_NUM_MID_BITS)))
 #define LZMA_NUM_LEN_PROBS (LZMA_LEN_HIGH + (1 << LZMA_LEN_NUM_HIGH_BITS))
 
 #define LZMA_NUM_STATES 12
@@ -76,11 +76,11 @@ typedef struct {
 #define LZMA_IS_REP_G2 (LZMA_IS_REP_G1 + LZMA_NUM_STATES)
 #define LZMA_IS_REP_0_LONG (LZMA_IS_REP_G2 + LZMA_NUM_STATES)
 #define LZMA_POS_SLOT (LZMA_IS_REP_0_LONG \
-                       + (LZMA_NUM_STATES << LZMA_NUM_POS_BITS_MAX))
+		       + (LZMA_NUM_STATES << LZMA_NUM_POS_BITS_MAX))
 #define LZMA_SPEC_POS (LZMA_POS_SLOT \
-                       +(LZMA_NUM_LEN_TO_POS_STATES << LZMA_NUM_POS_SLOT_BITS))
+		       +(LZMA_NUM_LEN_TO_POS_STATES << LZMA_NUM_POS_SLOT_BITS))
 #define LZMA_ALIGN (LZMA_SPEC_POS \
-                    + LZMA_NUM_FULL_DISTANCES - LZMA_END_POS_MODEL_INDEX)
+		    + LZMA_NUM_FULL_DISTANCES - LZMA_END_POS_MODEL_INDEX)
 #define LZMA_LEN_CODER (LZMA_ALIGN + (1 << LZMA_NUM_ALIGN_BITS))
 #define LZMA_REP_LEN_CODER (LZMA_LEN_CODER + LZMA_NUM_LEN_PROBS)
 #define LZMA_LITERAL (LZMA_REP_LEN_CODER + LZMA_NUM_LEN_PROBS)
diff --git a/archival/libunarchive/get_header_ar.c b/archival/libunarchive/get_header_ar.c
index ebb6f8cbe..e3a71951f 100644
--- a/archival/libunarchive/get_header_ar.c
+++ b/archival/libunarchive/get_header_ar.c
@@ -26,15 +26,15 @@ extern char get_header_ar(archive_handle_t *archive_handle)
 	file_header_t *typed = archive_handle->file_header;
 	union {
 		char raw[60];
-	 	struct {
- 			char name[16];
- 			char date[12];
- 			char uid[6];
- 			char gid[6];
- 			char mode[8];
- 			char size[10];
- 			char magic[2];
- 		} formated;
+		struct {
+			char name[16];
+			char date[12];
+			char uid[6];
+			char gid[6];
+			char mode[8];
+			char size[10];
+			char magic[2];
+		} formated;
 	} ar;
 #ifdef CONFIG_FEATURE_AR_LONG_FILENAMES
 	static char *ar_long_names;
@@ -102,7 +102,7 @@ extern char get_header_ar(archive_handle_t *archive_handle)
 #endif
 	} else {
 		/* short filenames */
-               typed->name = bb_xstrndup(ar.formated.name, 16);
+	       typed->name = bb_xstrndup(ar.formated.name, 16);
 	}
 
 	typed->name[strcspn(typed->name, " /")] = '\0';
diff --git a/archival/libunarchive/get_header_tar.c b/archival/libunarchive/get_header_tar.c
index 659b75d9b..26dfad55f 100644
--- a/archival/libunarchive/get_header_tar.c
+++ b/archival/libunarchive/get_header_tar.c
@@ -20,7 +20,7 @@
  *  References:
  *    GNU tar and star man pages,
  *    Opengroup's ustar interchange format,
- *      	http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html
+ *	http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html
  */
 
 #include <stdio.h>
diff --git a/archival/rpm.c b/archival/rpm.c
index 32d506de0..a80f799a6 100644
--- a/archival/rpm.c
+++ b/archival/rpm.c
@@ -43,7 +43,7 @@
 #define RPM_STRING_ARRAY_TYPE	8
 #define RPM_I18NSTRING_TYPE	9
 
-#define	RPMTAG_NAME  			1000
+#define	RPMTAG_NAME				1000
 #define	RPMTAG_VERSION			1001
 #define	RPMTAG_RELEASE			1002
 #define	RPMTAG_SUMMARY			1004
diff --git a/archival/tar.c b/archival/tar.c
index a4b13b5de..ab4d1f266 100644
--- a/archival/tar.c
+++ b/archival/tar.c
@@ -91,7 +91,7 @@ struct HardLinkInfo {
 struct TarBallInfo {
 	char *fileName;			/* File name of the tarball */
 	int tarFd;				/* Open-for-write file descriptor
-						   	   for the tarball */
+							   for the tarball */
 	struct stat statBuf;	/* Stat info for the tarball, letting
 							   us know the inode and device that the
 							   tarball lives, so we can avoid trying
@@ -569,7 +569,7 @@ static char get_header_tar_Z(archive_handle_t *archive_handle)
 
 	/* do the decompression, and cleanup */
 	if (bb_xread_char(archive_handle->src_fd) != 0x1f ||
-	   	bb_xread_char(archive_handle->src_fd) != 0x9d)
+		bb_xread_char(archive_handle->src_fd) != 0x9d)
 	{
 		bb_error_msg_and_die("Invalid magic");
 	}
@@ -699,7 +699,7 @@ static const struct option tar_long_options[] = {
 # ifdef CONFIG_FEATURE_TAR_COMPRESS
 	{ "compress",			0,	NULL,	'Z' },
 # endif
-	{ 0,                 	0, 0, 0 }
+	{ 0,					0, 0, 0 }
 };
 #else
 #define tar_long_options	0
@@ -713,7 +713,7 @@ int tar_main(int argc, char **argv)
 	const char *tar_filename = "-";
 	unsigned long opt;
 	llist_t *excludes = NULL;
-	
+
 	/* Initialise default values */
 	tar_handle = init_handle();
 	tar_handle->flags = ARCHIVE_CREATE_LEADING_DIRS | ARCHIVE_PRESERVE_DATE | ARCHIVE_EXTRACT_UNCONDITIONAL;
@@ -743,7 +743,7 @@ int tar_main(int argc, char **argv)
 	}
 	if((opt & CTX_EXTRACT) && tar_handle->action_data != data_extract_to_stdout)
 		tar_handle->action_data = data_extract_all;
-		
+
 	if (opt & TAR_OPT_2STDOUT)
 		tar_handle->action_data = data_extract_to_stdout;
 
@@ -843,9 +843,9 @@ int tar_main(int argc, char **argv)
 		int zipMode = 0;
 
 		if (ENABLE_FEATURE_TAR_GZIP && get_header_ptr == get_header_tar_gz)
-		   	zipMode = 1;
+			zipMode = 1;
 		if (ENABLE_FEATURE_TAR_BZIP2 && get_header_ptr == get_header_tar_bz2)
-		   	zipMode = 2;
+			zipMode = 2;
 
 		if ((tar_handle->action_header == header_list) ||
 				(tar_handle->action_header == header_verbose_list))
diff --git a/archival/unzip.c b/archival/unzip.c
index caac716cc..f602db12d 100644
--- a/archival/unzip.c
+++ b/archival/unzip.c
@@ -66,8 +66,8 @@ typedef union {
 		unsigned short method;	/* 4-5 */
 		unsigned short modtime;	/* 6-7 */
 		unsigned short moddate;	/* 8-9 */
-		unsigned int crc32 ATTRIBUTE_PACKED;   	/* 10-13 */
-		unsigned int cmpsize ATTRIBUTE_PACKED; 	/* 14-17 */
+		unsigned int crc32 ATTRIBUTE_PACKED;	/* 10-13 */
+		unsigned int cmpsize ATTRIBUTE_PACKED;	/* 14-17 */
 		unsigned int ucmpsize ATTRIBUTE_PACKED;	/* 18-21 */
 		unsigned short filename_len;	/* 22-23 */
 		unsigned short extra_len;		/* 24-25 */
diff --git a/console-tools/openvt.c b/console-tools/openvt.c
index d9f49bbea..6bdf608c7 100644
--- a/console-tools/openvt.c
+++ b/console-tools/openvt.c
@@ -39,7 +39,7 @@ int openvt_main(int argc, char **argv)
 
 
 	if (argc < 3)
-        bb_show_usage();
+	bb_show_usage();
 
 	/* check for Illegal vt number: < 1 or > 12 */
 	sprintf(vtname, VC_FORMAT,(int)bb_xgetlarg(argv[1], 10, 1, 12));
@@ -56,7 +56,7 @@ int openvt_main(int argc, char **argv)
 		if (setsid() < 0) {
 #endif
 
-			bb_perror_msg_and_die("Unable to set new session");	
+			bb_perror_msg_and_die("Unable to set new session");
 		}
 		close(0);			/* so that new vt becomes stdin */
 
diff --git a/console-tools/setkeycodes.c b/console-tools/setkeycodes.c
index 169d0bb0a..efb6e658f 100644
--- a/console-tools/setkeycodes.c
+++ b/console-tools/setkeycodes.c
@@ -45,7 +45,7 @@ setkeycodes_main(int argc, char** argv)
     if (argc % 2 != 1 || argc < 2) {
       bb_show_usage();
 	}
-	
+
 	fd = get_console_fd();
 
     while (argc > 2) {
diff --git a/coreutils/Config.in b/coreutils/Config.in
index 3b742dc6c..29f73adea 100644
--- a/coreutils/Config.in
+++ b/coreutils/Config.in
@@ -457,8 +457,8 @@ config CONFIG_FEATURE_STAT_FORMAT
 	default n
 	depends on CONFIG_STAT
 	help
-	  Without this, stat will not support the '-c format' option where 
-	  users can pass a custom format string for output.  This adds about 
+	  Without this, stat will not support the '-c format' option where
+	  users can pass a custom format string for output.  This adds about
 	  7k to a nonstatic build on amd64.
 
 config CONFIG_STTY
diff --git a/coreutils/cal.c b/coreutils/cal.c
index 93c5692d0..9368dccf9 100644
--- a/coreutils/cal.c
+++ b/coreutils/cal.c
@@ -45,10 +45,10 @@
 #endif
 
 #define	THURSDAY		4		/* for reformation */
-#define	SATURDAY 		6		/* 1 Jan 1 was a Saturday */
+#define	SATURDAY		6		/* 1 Jan 1 was a Saturday */
 
-#define	FIRST_MISSING_DAY 	639787		/* 3 Sep 1752 */
-#define	NUMBER_MISSING_DAYS 	11		/* 11 day correction */
+#define	FIRST_MISSING_DAY	639787		/* 3 Sep 1752 */
+#define	NUMBER_MISSING_DAYS	11		/* 11 day correction */
 
 #define	MAXDAYS			42		/* max slots in a month array */
 #define	SPACE			-1		/* used in day array */
diff --git a/coreutils/date.c b/coreutils/date.c
index e9ec51044..2d411ab31 100644
--- a/coreutils/date.c
+++ b/coreutils/date.c
@@ -91,23 +91,23 @@ static struct tm *date_conv_ftime(struct tm *tm_time, const char *t_string)
 								&t.tm_min) == 2) {
 		/* no adjustments needed */
 	} else if (t = *tm_time, sscanf(t_string, "%d.%d-%d:%d:%d", &t.tm_mon,
-						&t.tm_mday, &t.tm_hour, 
+						&t.tm_mday, &t.tm_hour,
 						&t.tm_min, &t.tm_sec) == 5) {
 		/* Adjust dates from 1-12 to 0-11 */
 		t.tm_mon -= 1;
 	} else if (t = *tm_time, sscanf(t_string, "%d.%d-%d:%d", &t.tm_mon,
-						&t.tm_mday, 
+						&t.tm_mday,
 						&t.tm_hour, &t.tm_min) == 4) {
 		/* Adjust dates from 1-12 to 0-11 */
 		t.tm_mon -= 1;
 	} else if (t = *tm_time, sscanf(t_string, "%d.%d.%d-%d:%d:%d", &t.tm_year,
-						&t.tm_mon, &t.tm_mday, 
+						&t.tm_mon, &t.tm_mday,
 						&t.tm_hour, &t.tm_min,
 							&t.tm_sec) == 6) {
 		t.tm_year -= 1900;	/* Adjust years */
 		t.tm_mon -= 1;	/* Adjust dates from 1-12 to 0-11 */
 	} else if (t = *tm_time, sscanf(t_string, "%d.%d.%d-%d:%d", &t.tm_year,
-						&t.tm_mon, &t.tm_mday, 
+						&t.tm_mon, &t.tm_mday,
 						&t.tm_hour, &t.tm_min) == 5) {
 		t.tm_year -= 1900;	/* Adjust years */
 		t.tm_mon -= 1;	/* Adjust dates from 1-12 to 0-11 */
@@ -119,9 +119,9 @@ static struct tm *date_conv_ftime(struct tm *tm_time, const char *t_string)
 }
 
 #define DATE_OPT_RFC2822	0x01
-#define DATE_OPT_SET    	0x02
-#define DATE_OPT_UTC    	0x04
-#define DATE_OPT_DATE   	0x08
+#define DATE_OPT_SET		0x02
+#define DATE_OPT_UTC		0x04
+#define DATE_OPT_DATE		0x08
 #define DATE_OPT_REFERENCE	0x10
 #ifdef CONFIG_FEATURE_DATE_ISOFMT
 # define DATE_OPT_TIMESPEC	0x20
diff --git a/coreutils/expr.c b/coreutils/expr.c
index 969d9fff5..a243e75af 100644
--- a/coreutils/expr.c
+++ b/coreutils/expr.c
@@ -365,7 +365,7 @@ static VALUE *eval6 (void)
 		else {
 			v = xmalloc (sizeof(VALUE));
 			v->type = string;
-                       v->u.s = bb_xstrndup(l->u.s + i1->u.i - 1, i2->u.i);
+		       v->u.s = bb_xstrndup(l->u.s + i1->u.i - 1, i2->u.i);
 		}
 		freev (l);
 		freev (i1);
diff --git a/coreutils/install.c b/coreutils/install.c
index a4a96151d..c3d4f8c82 100644
--- a/coreutils/install.c
+++ b/coreutils/install.c
@@ -44,7 +44,7 @@ static const struct option install_long_options[] = {
 	{ "preserve-timestamps",	0,	NULL,	'p' },
 	{ "strip",	0,	NULL,	's' },
 	{ "group",	0,	NULL,	'g' },
-	{ "mode", 	0,	NULL,	'm' },
+	{ "mode",	0,	NULL,	'm' },
 	{ "owner",	0,	NULL,	'o' },
 	{ 0,	0,	0,	0 }
 };
diff --git a/coreutils/libcoreutils/getopt_mk_fifo_nod.c b/coreutils/libcoreutils/getopt_mk_fifo_nod.c
index 7e54fed3e..090fefaee 100644
--- a/coreutils/libcoreutils/getopt_mk_fifo_nod.c
+++ b/coreutils/libcoreutils/getopt_mk_fifo_nod.c
@@ -33,7 +33,7 @@ extern mode_t getopt_mk_fifo_nod(int argc, char **argv)
 
 	bb_getopt_ulflags(argc, argv, "m:", &smode);
 	if(smode) {
-		if (bb_parse_mode(smode, &mode)) 
+		if (bb_parse_mode(smode, &mode))
 			umask(0);
 	}
 	return mode;
diff --git a/coreutils/ls.c b/coreutils/ls.c
index 5042c1298..46ab865dd 100644
--- a/coreutils/ls.c
+++ b/coreutils/ls.c
@@ -173,7 +173,7 @@ static int show_color = 0;
 static const struct option ls_color_opt[] =
 {
 	{"color", optional_argument, NULL, 1},
-        {NULL, 0, NULL, 0}
+	{NULL, 0, NULL, 0}
 };
 
 #define COLOR(mode)	("\000\043\043\043\042\000\043\043"\
@@ -318,7 +318,7 @@ static int count_dirs(struct dnode **dn, int nfiles, int notsubdirs)
 	dirs = 0;
 	for (i = 0; i < nfiles; i++) {
 		if (S_ISDIR(dn[i]->dstat.st_mode)
-			&& (notsubdirs || 
+			&& (notsubdirs ||
 			((dn[i]->name[0] != '.') || (dn[i]->name[1]
 						&& ((dn[i]->name[1] != '.')
 						|| dn[i]->name[2])))))
@@ -747,7 +747,7 @@ static int list_single(struct dnode *dn)
 			{
 				char context[80];
 				int len;
-			
+
 				if (dn->sid) {
 				  /*  I assume sid initilized with NULL  */
 				  len = strlen(dn->sid)+1;
@@ -895,57 +895,57 @@ static const char ls_options[]="Cadil1gnsxAk" \
 
 static const unsigned opt_flags[] = {
 	LIST_SHORT | STYLE_COLUMNS,	/* C */
-	DISP_HIDDEN | DISP_DOT,    	/* a */
-	DISP_NOLIST,               	/* d */
-	LIST_INO,                  	/* i */
-	LIST_LONG | STYLE_LONG,    	/* l - remember LS_DISP_HR in mask! */
-	LIST_SHORT | STYLE_SINGLE, 	/* 1 */
-	0,                         	/* g - ingored */
-	LIST_ID_NUMERIC,           	/* n */
-	LIST_BLOCKS,              	/* s */
-	DISP_ROWS,                	/* x */
-	DISP_HIDDEN,              	/* A */
+	DISP_HIDDEN | DISP_DOT,		/* a */
+	DISP_NOLIST,				/* d */
+	LIST_INO,					/* i */
+	LIST_LONG | STYLE_LONG,		/* l - remember LS_DISP_HR in mask! */
+	LIST_SHORT | STYLE_SINGLE,	/* 1 */
+	0,							/* g - ingored */
+	LIST_ID_NUMERIC,			/* n */
+	LIST_BLOCKS,				/* s */
+	DISP_ROWS,					/* x */
+	DISP_HIDDEN,				/* A */
 #ifdef CONFIG_SELINUX
-	LIST_CONTEXT,             	/* k */
+	LIST_CONTEXT,				/* k */
 #else
-	0,                        	/* k - ingored */
+	0,							/* k - ingored */
 #endif
 #ifdef CONFIG_FEATURE_LS_TIMESTAMPS
 # ifdef CONFIG_FEATURE_LS_SORTFILES
 	TIME_CHANGE | SORT_CTIME,	/* c */
 # else
-	TIME_CHANGE,             	/* c */
+	TIME_CHANGE,				/* c */
 # endif
-	LIST_FULLTIME,           	/* e */
+	LIST_FULLTIME,				/* e */
 # ifdef CONFIG_FEATURE_LS_SORTFILES
-	SORT_MTIME,              	/* t */
+	SORT_MTIME,					/* t */
 # else
-	0,                      	/* t - ignored -- is this correct? */
+	0,							/* t - ignored -- is this correct? */
 # endif
 # ifdef CONFIG_FEATURE_LS_SORTFILES
 	TIME_ACCESS | SORT_ATIME,	/* u */
 # else
-	TIME_ACCESS,             	/* u */
+	TIME_ACCESS,				/* u */
 # endif
 #endif
 #ifdef CONFIG_FEATURE_LS_SORTFILES
-	SORT_SIZE,               	/* S */
-	SORT_EXT,                	/* X */
-	SORT_ORDER_REVERSE,       	/* r */
-	SORT_VERSION,             	/* v */
+	SORT_SIZE,					/* S */
+	SORT_EXT,					/* X */
+	SORT_ORDER_REVERSE,			/* r */
+	SORT_VERSION,				/* v */
 #endif
 #ifdef CONFIG_FEATURE_LS_FILETYPES
 	LIST_FILETYPE | LIST_EXEC,	/* F */
-	LIST_FILETYPE,            	/* p */
+	LIST_FILETYPE,				/* p */
 #endif
 #ifdef CONFIG_FEATURE_LS_FOLLOWLINKS
-	FOLLOW_LINKS,             	/* L */
+	FOLLOW_LINKS,				/* L */
 #endif
 #ifdef CONFIG_FEATURE_LS_RECURSIVE
-	DISP_RECURSIVE,           	/* R */
+	DISP_RECURSIVE,				/* R */
 #endif
 #ifdef CONFIG_FEATURE_HUMAN_READABLE
-	LS_DISP_HR,               	/* h */
+	LS_DISP_HR,					/* h */
 #endif
 #ifdef CONFIG_SELINUX
 	LIST_MODEBITS|LIST_NLINKS|LIST_CONTEXT|LIST_SIZE|LIST_DATE_TIME, /* K */
@@ -1025,7 +1025,7 @@ extern int ls_main(int argc, char **argv)
 	for (i = 0; opt_flags[i] != (1U<<31); i++) {
 		if (opt & (1 << i)) {
 			unsigned int flags = opt_flags[i];
-			
+
 			if (flags & LIST_MASK_TRIGGER) {
 				all_fmt &= ~LIST_MASK;
 			}
@@ -1064,11 +1064,11 @@ extern int ls_main(int argc, char **argv)
 #if CONFIG_FEATURE_LS_COLOR_IS_DEFAULT
 		char *p;
 
-		if ((p = getenv ("LS_COLORS")) != NULL && 
+		if ((p = getenv ("LS_COLORS")) != NULL &&
 			(*p == '\0' || (strcmp(p, "none") == 0))) {
 			;
 		} else if (isatty(STDOUT_FILENO)) {
-		    	show_color = 1;
+			show_color = 1;
 		}
 #endif
 
diff --git a/coreutils/nice.c b/coreutils/nice.c
index b66f9d82d..449184dab 100644
--- a/coreutils/nice.c
+++ b/coreutils/nice.c
@@ -77,7 +77,7 @@ int nice_main(int argc, char **argv)
 			bb_perror_msg_and_die(Xetpriority_msg, 's');
 		}
 	}
-	
+
 	execvp(*argv, argv);		/* Now exec the desired program. */
 
 	/* The exec failed... */
diff --git a/coreutils/printf.c b/coreutils/printf.c
index 697a1c055..1fe68afcb 100644
--- a/coreutils/printf.c
+++ b/coreutils/printf.c
@@ -63,12 +63,12 @@ void multiconvert(char *arg, void *result, converter convert)
 	}
 	if(convert(arg,result)) fprintf(stderr, "%s", arg);
 }
-	
+
 static unsigned long xstrtoul(char *arg)
 {
 	unsigned long result;
 
-	multiconvert(arg,&result, (converter)safe_strtoul);	
+	multiconvert(arg,&result, (converter)safe_strtoul);
 	return result;
 }
 
diff --git a/coreutils/rmdir.c b/coreutils/rmdir.c
index a10e5bb4f..1d6b2cadb 100644
--- a/coreutils/rmdir.c
+++ b/coreutils/rmdir.c
@@ -59,7 +59,7 @@ extern int rmdir_main(int argc, char **argv)
 				/* Path is now just the parent component.  Note that dirname
 				 * returns "." if there are no parents.  We must distinguish
 				 * this from the case of the original path starting with '.'.
-                 */
+		 */
 				if (do_dot || (*path != '.') || path[1]) {
 					continue;
 				}
diff --git a/coreutils/sort.c b/coreutils/sort.c
index ce51bc178..b56a5abb8 100644
--- a/coreutils/sort.c
+++ b/coreutils/sort.c
@@ -156,7 +156,7 @@ static int compare_keys(const void *xarg, const void *yarg)
 
 #ifdef CONFIG_FEATURE_SORT_BIG
 	struct sort_key *key;
-	
+
 	for(key=key_list;!retval && key;key=key->next_key) {
 		flags=(key->flags) ? key->flags : global_flags;
 		/* Chop out and modify key chunks, handling -dfib */
@@ -312,7 +312,7 @@ int sort_main(int argc, char **argv)
 #ifdef CONFIG_FEATURE_SORT_BIG
 	/* if no key, perform alphabetic sort */
     if(!key_list) add_key()->range[0]=1;
-	/* handle -c */	
+	/* handle -c */
 	if(global_flags&FLAG_c) {
 		int j=(global_flags&FLAG_u) ? -1 : 0;
 		for(i=1;i<linecount;i++)
diff --git a/coreutils/stat.c b/coreutils/stat.c
index c17b4d5e8..44289fbaa 100644
--- a/coreutils/stat.c
+++ b/coreutils/stat.c
@@ -44,9 +44,9 @@ static long flags;
 
 static char const *file_type(struct stat const *st)
 {
-	/* See POSIX 1003.1-2001 XCU Table 4-8 lines 17093-17107 
+	/* See POSIX 1003.1-2001 XCU Table 4-8 lines 17093-17107
 	 * for some of these formats.
-	 * To keep diagnostics grammatical in English, the 
+	 * To keep diagnostics grammatical in English, the
 	 * returned string must start with a consonant.
 	 */
 	if (S_ISREG(st->st_mode))  return st->st_size == 0 ? "regular empty file" : "regular file";
@@ -131,8 +131,8 @@ static char const *human_fstype(long f_type)
 
 #ifdef CONFIG_FEATURE_STAT_FORMAT
 /* print statfs info */
-static void print_statfs(char *pformat, size_t buf_len, char m, 
-                         char const *filename, void const *data)
+static void print_statfs(char *pformat, size_t buf_len, char m,
+			 char const *filename, void const *data)
 {
 	struct statfs const *statfsbuf = data;
 
@@ -190,8 +190,8 @@ static void print_statfs(char *pformat, size_t buf_len, char m,
 }
 
 /* print stat info */
-static void print_stat(char *pformat, size_t buf_len, char m, 
-                       char const *filename, void const *data)
+static void print_stat(char *pformat, size_t buf_len, char m,
+		       char const *filename, void const *data)
 {
 #define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
 	struct stat *statbuf = (struct stat *) data;
@@ -326,9 +326,9 @@ static void print_stat(char *pformat, size_t buf_len, char m,
 	}
 }
 
-static void print_it(char const *masterformat, char const *filename, 
-                     void (*print_func) (char *, size_t, char, char const *, void const *), 
-                     void const *data)
+static void print_it(char const *masterformat, char const *filename,
+		     void (*print_func) (char *, size_t, char, char const *, void const *),
+		     void const *data)
 {
 	char *b;
 
diff --git a/coreutils/test.c b/coreutils/test.c
index 3da2daecd..d7bd5a0de 100644
--- a/coreutils/test.c
+++ b/coreutils/test.c
@@ -4,14 +4,14 @@
  *
  * Copyright (c) by a whole pile of folks:
  *
- * 	test(1); version 7-like  --  author Erik Baalbergen
- * 	modified by Eric Gisin to be used as built-in.
- * 	modified by Arnold Robbins to add SVR3 compatibility
- * 	(-x -c -b -p -u -g -k) plus Korn's -L -nt -ot -ef and new -S (socket).
- * 	modified by J.T. Conklin for NetBSD.
- * 	modified by Herbert Xu to be used as built-in in ash.
- * 	modified by Erik Andersen <andersen@codepoet.org> to be used
- * 	in busybox.
+ *	test(1); version 7-like  --  author Erik Baalbergen
+ *	modified by Eric Gisin to be used as built-in.
+ *	modified by Arnold Robbins to add SVR3 compatibility
+ *	(-x -c -b -p -u -g -k) plus Korn's -L -nt -ot -ef and new -S (socket).
+ *	modified by J.T. Conklin for NetBSD.
+ *	modified by Herbert Xu to be used as built-in in ash.
+ *	modified by Erik Andersen <andersen@codepoet.org> to be used
+ *	in busybox.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -28,7 +28,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  * Original copyright notice states:
- * 	"This program is in the Public Domain."
+ *	"This program is in the Public Domain."
  */
 
 #include <sys/types.h>
diff --git a/coreutils/uname.c b/coreutils/uname.c
index a3e52e39f..f6dc0170f 100644
--- a/coreutils/uname.c
+++ b/coreutils/uname.c
@@ -93,7 +93,7 @@ int uname_main(int argc, char **argv)
 	}
 
 #if defined(__sparc__) && defined(__linux__)
- 	if ((fake_sparc != NULL)
+	if ((fake_sparc != NULL)
 		&& ((fake_sparc[0] == 'y')
 			|| (fake_sparc[0] == 'Y'))) {
 		strcpy(uname_info.name.machine, "sparc");
diff --git a/coreutils/uudecode.c b/coreutils/uudecode.c
index b4bcc72e2..da6490a81 100644
--- a/coreutils/uudecode.c
+++ b/coreutils/uudecode.c
@@ -56,7 +56,7 @@ static int read_stduu(FILE *src_stream, FILE *dst_stream)
 			bb_error_msg_and_die("Short file");
 		}
 
- 		while (length > 0) {
+		while (length > 0) {
 			/* Merge four 6 bit chars to three 8 bit chars */
 		    fputc(((line_ptr[0] - 0x20) & 077) << 2 | ((line_ptr[1] - 0x20) & 077) >> 4, dst_stream);
 			line_ptr++;
@@ -65,14 +65,14 @@ static int read_stduu(FILE *src_stream, FILE *dst_stream)
 				break;
 			}
 
-   			fputc(((line_ptr[0] - 0x20) & 077) << 4 | ((line_ptr[1] - 0x20) & 077) >> 2, dst_stream);
+			fputc(((line_ptr[0] - 0x20) & 077) << 4 | ((line_ptr[1] - 0x20) & 077) >> 2, dst_stream);
 			line_ptr++;
 			length--;
 			if (length == 0) {
 				break;
 			}
 
-  			fputc(((line_ptr[0] - 0x20) & 077) << 6 | ((line_ptr[1] - 0x20) & 077), dst_stream);
+			fputc(((line_ptr[0] - 0x20) & 077) << 6 | ((line_ptr[1] - 0x20) & 077), dst_stream);
 			line_ptr += 2;
 			length -= 2;
 		}
@@ -130,10 +130,10 @@ static int read_base64(FILE *src_stream, FILE *dst_stream)
 		/* Merge 6 bit chars to 8 bit */
 	    fputc(translated[0] << 2 | translated[1] >> 4, dst_stream);
 		if (count > 2) {
-	   		fputc(translated[1] << 4 | translated[2] >> 2, dst_stream);
+			fputc(translated[1] << 4 | translated[2] >> 2, dst_stream);
 		}
 		if (count > 3) {
-	  		fputc(translated[2] << 6 | translated[3], dst_stream);
+			fputc(translated[2] << 6 | translated[3], dst_stream);
 		}
 	}
 }
diff --git a/coreutils/who.c b/coreutils/who.c
index 0531326bd..e2ea227eb 100644
--- a/coreutils/who.c
+++ b/coreutils/who.c
@@ -33,49 +33,49 @@ extern int who_main(int argc, char **argv)
     time_t      now, idle;
 
     if (argc > 1)
-        bb_show_usage();
+	bb_show_usage();
 
     setutent();
     devlen = sizeof("/dev/") - 1;
     printf("USER       TTY      IDLE      FROM           HOST\n");
 
     while ((ut = getutent()) != NULL) {
-        char name[40];
+	char name[40];
 
-        if (ut->ut_user[0] && ut->ut_type == USER_PROCESS) {
-            len = strlen(ut->ut_line);
-            if (ut->ut_line[0] == '/') {
-               strncpy(name, ut->ut_line, len);
-               name[len] = '\0';
-               strcpy(ut->ut_line, ut->ut_line + devlen);
-            } else {
-               strcpy(name, "/dev/");
-               strncpy(name+devlen, ut->ut_line, len);
-               name[devlen+len] = '\0';
-            }
+	if (ut->ut_user[0] && ut->ut_type == USER_PROCESS) {
+	    len = strlen(ut->ut_line);
+	    if (ut->ut_line[0] == '/') {
+	       strncpy(name, ut->ut_line, len);
+	       name[len] = '\0';
+	       strcpy(ut->ut_line, ut->ut_line + devlen);
+	    } else {
+	       strcpy(name, "/dev/");
+	       strncpy(name+devlen, ut->ut_line, len);
+	       name[devlen+len] = '\0';
+	    }
 
-            printf("%-10s %-8s ", ut->ut_user, ut->ut_line);
+	    printf("%-10s %-8s ", ut->ut_user, ut->ut_line);
 
-            if (stat(name, &st) == 0) {
-                now = time(NULL);
-                idle = now -  st.st_atime;
+	    if (stat(name, &st) == 0) {
+		now = time(NULL);
+		idle = now -  st.st_atime;
 
-                if (idle < 60)
-                    printf("00:00m    ");
-                else if (idle < (60 * 60))
-                    printf("00:%02dm    ", (int)(idle / 60));
-                else if (idle < (24 * 60 * 60))
-                    printf("%02d:%02dm    ", (int)(idle / (60 * 60)),
-                           (int)(idle % (60 * 60)) / 60);
-                else if (idle < (24 * 60 * 60 * 365))
-                    printf("%03ddays   ", (int)(idle / (24 * 60 * 60)));
-                else
-                    printf("%02dyears   ", (int) (idle / (24 * 60 * 60 * 365)));
-            } else
-                printf("%-8s  ", "?");
+		if (idle < 60)
+		    printf("00:00m    ");
+		else if (idle < (60 * 60))
+		    printf("00:%02dm    ", (int)(idle / 60));
+		else if (idle < (24 * 60 * 60))
+		    printf("%02d:%02dm    ", (int)(idle / (60 * 60)),
+			   (int)(idle % (60 * 60)) / 60);
+		else if (idle < (24 * 60 * 60 * 365))
+		    printf("%03ddays   ", (int)(idle / (24 * 60 * 60)));
+		else
+		    printf("%02dyears   ", (int) (idle / (24 * 60 * 60 * 365)));
+	    } else
+		printf("%-8s  ", "?");
 
-            printf("%-12.12s   %s\n", ctime((time_t*)&(ut->ut_tv.tv_sec)) + 4, ut->ut_host);
-        }
+	    printf("%-12.12s   %s\n", ctime((time_t*)&(ut->ut_tv.tv_sec)) + 4, ut->ut_host);
+	}
     }
     endutent();
 
diff --git a/debianutils/mktemp.c b/debianutils/mktemp.c
index c0d3a365d..64b82815e 100644
--- a/debianutils/mktemp.c
+++ b/debianutils/mktemp.c
@@ -6,7 +6,7 @@
  * Copyright (C) 2000 by Daniel Jacobowitz
  * Written by Daniel Jacobowitz <dan@debian.org>
  *
- * Licensed under the GPL v2 or later, see the file LICENSE in this tarball. 
+ * Licensed under the GPL v2 or later, see the file LICENSE in this tarball.
  */
 
 #include <stdio.h>
@@ -19,7 +19,7 @@
 extern int mktemp_main(int argc, char **argv)
 {
 	unsigned long flags = bb_getopt_ulflags(argc, argv, "dq");
-	
+
 	if (optind + 1 != argc)
 		bb_show_usage();
 
diff --git a/debianutils/run_parts.c b/debianutils/run_parts.c
index 90314354c..862db7a05 100644
--- a/debianutils/run_parts.c
+++ b/debianutils/run_parts.c
@@ -36,10 +36,10 @@
  * broken compatibility because the BusyBox policy doesn't allow them.
  * The supported options are:
  * -t			test. Print the name of the files to be executed, without
- * 				execute them.
+ *				execute them.
  * -a ARG		argument. Pass ARG as an argument the program executed. It can
- * 				be repeated to pass multiple arguments.
- * -u MASK 		umask. Set the umask of the program executed to MASK. */
+ *				be repeated to pass multiple arguments.
+ * -u MASK		umask. Set the umask of the program executed to MASK. */
 
 /* TODO
  * done - convert calls to error in perror... and remove error()
diff --git a/debianutils/start_stop_daemon.c b/debianutils/start_stop_daemon.c
index 2ace0cc8b..aa1b3c7a0 100644
--- a/debianutils/start_stop_daemon.c
+++ b/debianutils/start_stop_daemon.c
@@ -238,7 +238,7 @@ start_stop_daemon_main(int argc, char **argv)
 	opt = bb_getopt_ulflags(argc, argv, "KSbqma:n:s:u:x:p:",
 		&startas, &cmdname, &signame, &userspec, &execname, &pidfile);
 
-	
+
 	quiet = opt & SSD_OPT_QUIET;
 
 	if (signame) {
diff --git a/e2fsprogs/Config.in b/e2fsprogs/Config.in
index 225e5aaaf..91e873e3a 100644
--- a/e2fsprogs/Config.in
+++ b/e2fsprogs/Config.in
@@ -17,7 +17,7 @@ config CONFIG_E2FSCK
 	help
 	  e2fsck is used to check Linux second extended file systems (ext2fs).
 	  e2fsck also supports ext2 filesystems countaining a journal (ext3).
-	  The normal compat symlinks 'fsck.ext2' and 'fsck.ext3' are also 
+	  The normal compat symlinks 'fsck.ext2' and 'fsck.ext3' are also
 	  provided.
 
 config CONFIG_FSCK
@@ -25,7 +25,7 @@ config CONFIG_FSCK
 	default n
 	help
 	  fsck is used to check and optionally repair one or more filesystems.
-	  In actuality, fsck is simply a front-end for the various file system 
+	  In actuality, fsck is simply a front-end for the various file system
 	  checkers (fsck.fstype) available under Linux.
 
 config CONFIG_LSATTR
@@ -38,14 +38,14 @@ config CONFIG_MKE2FS
 	bool "mke2fs"
 	default n
 	help
-	  mke2fs is used to create an ext2/ext3 filesystem.  The normal compat 
+	  mke2fs is used to create an ext2/ext3 filesystem.  The normal compat
 	  symlinks 'mkfs.ext2' and 'mkfs.ext3' are also provided.
 
 config CONFIG_TUNE2FS
 	bool "tune2fs"
 	default n
 	help
-	  tune2fs allows the system administrator to adjust various tunable 
+	  tune2fs allows the system administrator to adjust various tunable
 	  filesystem parameters on Linux ext2/ext3 filesystems.
 
 config CONFIG_E2LABEL
@@ -53,7 +53,7 @@ config CONFIG_E2LABEL
 	default n
 	depends on CONFIG_TUNE2FS
 	help
-	  e2label will display or change the filesystem label on the ext2 
+	  e2label will display or change the filesystem label on the ext2
 	  filesystem located on device.
 
 config CONFIG_FINDFS
@@ -61,7 +61,7 @@ config CONFIG_FINDFS
 	default n
 	depends on CONFIG_TUNE2FS
 	help
-	  findfs will search the disks in the system looking for a filesystem 
+	  findfs will search the disks in the system looking for a filesystem
 	  which has a label matching label or a UUID equal to uuid.
 
 endmenu
diff --git a/e2fsprogs/blkid/blkid.h b/e2fsprogs/blkid/blkid.h
index 3ea94ac80..3bb0e78d8 100644
--- a/e2fsprogs/blkid/blkid.h
+++ b/e2fsprogs/blkid/blkid.h
@@ -34,13 +34,13 @@ typedef struct blkid_struct_dev_iterate *blkid_dev_iterate;
  * Flags for blkid_get_dev
  *
  * BLKID_DEV_CREATE	Create an empty device structure if not found
- * 			in the cache.
+ *			in the cache.
  * BLKID_DEV_VERIFY	Make sure the device structure corresponds
- * 			with reality.
+ *			with reality.
  * BLKID_DEV_FIND	Just look up a device entry, and return NULL
- * 			if it is not found.
+ *			if it is not found.
  * BLKID_DEV_NORMAL	Get a valid device structure, either from the
- * 			cache or by probing the device.
+ *			cache or by probing the device.
  */
 #define BLKID_DEV_FIND		0x0000
 #define BLKID_DEV_CREATE	0x0001
diff --git a/e2fsprogs/blkid/blkid_getsize.c b/e2fsprogs/blkid/blkid_getsize.c
index 9458c08bf..58cc7352a 100644
--- a/e2fsprogs/blkid/blkid_getsize.c
+++ b/e2fsprogs/blkid/blkid_getsize.c
@@ -70,7 +70,7 @@ blkid_loff_t blkid_get_dev_size(int fd)
 {
 	int valid_blkgetsize64 = 1;
 #ifdef __linux__
-	struct 		utsname ut;
+	struct		utsname ut;
 #endif
 	unsigned long long size64;
 	unsigned long size;
diff --git a/e2fsprogs/blkid/cache.c b/e2fsprogs/blkid/cache.c
index 0dd1b6286..87be1269f 100644
--- a/e2fsprogs/blkid/cache.c
+++ b/e2fsprogs/blkid/cache.c
@@ -47,9 +47,9 @@ int blkid_get_cache(blkid_cache *ret_cache, const char *filename)
 	if (!filename)
 		filename = BLKID_CACHE_FILE;
 	cache->bic_filename = blkid_strdup(filename);
-	
+
 	blkid_read_cache(cache);
-	
+
 	*ret_cache = cache;
 	return 0;
 }
@@ -62,7 +62,7 @@ void blkid_put_cache(blkid_cache cache)
 	(void) blkid_flush_cache(cache);
 
 	DBG(DEBUG_CACHE, printf("freeing cache struct\n"));
-	
+
 	/* DEB_DUMP_CACHE(cache); */
 
 	while (!list_empty(&cache->bic_devs)) {
@@ -79,7 +79,7 @@ void blkid_put_cache(blkid_cache cache)
 
 		while (!list_empty(&tag->bit_names)) {
 			blkid_tag bad = list_entry(tag->bit_names.next,
-						   struct blkid_struct_tag, 
+						   struct blkid_struct_tag,
 						   bit_names);
 
 			DBG(DEBUG_CACHE, printf("warning: unfreed tag %s=%s\n",
@@ -90,7 +90,7 @@ void blkid_put_cache(blkid_cache cache)
 	}
 	if (cache->bic_filename)
 		free(cache->bic_filename);
-	
+
 	free(cache);
 }
 
diff --git a/e2fsprogs/blkid/dev.c b/e2fsprogs/blkid/dev.c
index 0e2b4e1bc..d2e468304 100644
--- a/e2fsprogs/blkid/dev.c
+++ b/e2fsprogs/blkid/dev.c
@@ -73,7 +73,7 @@ extern const char *blkid_dev_devname(blkid_dev dev)
  * This series of functions iterate over all devices in a blkid cache
  */
 #define DEV_ITERATE_MAGIC	0x01a5284c
-	
+
 struct blkid_struct_dev_iterate {
 	int			magic;
 	blkid_cache		cache;
diff --git a/e2fsprogs/blkid/devname.c b/e2fsprogs/blkid/devname.c
index b5db29e30..1e016a55d 100644
--- a/e2fsprogs/blkid/devname.c
+++ b/e2fsprogs/blkid/devname.c
@@ -54,7 +54,7 @@ blkid_dev blkid_get_dev(blkid_cache cache, const char *devname, int flags)
 		if (strcmp(tmp->bid_name, devname))
 			continue;
 
-		DBG(DEBUG_DEVNAME, 
+		DBG(DEBUG_DEVNAME,
 		    printf("found devname %s in cache\n", tmp->bid_name));
 		dev = tmp;
 		break;
@@ -113,7 +113,7 @@ static void probe_one(blkid_cache cache, const char *ptname,
 		    dev->bid_devno == devno)
 			goto set_pri;
 
-		if (stat(device, &st) == 0 && S_ISBLK(st.st_mode) && 
+		if (stat(device, &st) == 0 && S_ISBLK(st.st_mode) &&
 		    st.st_rdev == devno) {
 			devname = blkid_strdup(device);
 			break;
diff --git a/e2fsprogs/blkid/devno.c b/e2fsprogs/blkid/devno.c
index 93a57fd86..7d083e76f 100644
--- a/e2fsprogs/blkid/devno.c
+++ b/e2fsprogs/blkid/devno.c
@@ -171,13 +171,13 @@ char *blkid_devno_to_devname(dev_t devno)
 
 	if (!devname) {
 		DBG(DEBUG_DEVNO,
-		    printf("blkid: couldn't find devno 0x%04lx\n", 
+		    printf("blkid: couldn't find devno 0x%04lx\n",
 			   (unsigned long) devno));
 	} else {
 		DBG(DEBUG_DEVNO,
 		    printf("found devno 0x%04Lx as %s\n", devno, devname));
 	}
-	
+
 
 	return devname;
 }
diff --git a/e2fsprogs/blkid/probe.c b/e2fsprogs/blkid/probe.c
index cb21c1070..2aaa50885 100644
--- a/e2fsprogs/blkid/probe.c
+++ b/e2fsprogs/blkid/probe.c
@@ -41,7 +41,7 @@ static int check_mdraid(int fd, unsigned char *ret_uuid)
 	struct mdp_superblock_s *md;
 	blkid_loff_t		offset;
 	char			buf[4096];
-	
+
 	if (fd < 0)
 		return -BLKID_ERR_PARAM;
 
@@ -83,7 +83,7 @@ static void get_ext2_info(blkid_dev dev, unsigned char *buf)
 	struct ext2_super_block *es = (struct ext2_super_block *) buf;
 	const char *label = 0;
 
-	DBG(DEBUG_PROBE, printf("ext2_sb.compat = %08X:%08X:%08X\n", 
+	DBG(DEBUG_PROBE, printf("ext2_sb.compat = %08X:%08X:%08X\n",
 		   blkid_le32(es->s_feature_compat),
 		   blkid_le32(es->s_feature_incompat),
 		   blkid_le32(es->s_feature_ro_compat)));
@@ -95,8 +95,8 @@ static void get_ext2_info(blkid_dev dev, unsigned char *buf)
 	set_uuid(dev, es->s_uuid);
 }
 
-static int probe_ext3(int fd __BLKID_ATTR((unused)), 
-		      blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_ext3(int fd __BLKID_ATTR((unused)),
+		      blkid_cache cache __BLKID_ATTR((unused)),
 		      blkid_dev dev,
 		      const struct blkid_magic *id, unsigned char *buf)
 {
@@ -105,7 +105,7 @@ static int probe_ext3(int fd __BLKID_ATTR((unused)),
 	es = (struct ext2_super_block *)buf;
 
 	/* Distinguish between jbd and ext2/3 fs */
-	if (blkid_le32(es->s_feature_incompat) & 
+	if (blkid_le32(es->s_feature_incompat) &
 	    EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)
 		return -BLKID_ERR_PARAM;
 
@@ -121,8 +121,8 @@ static int probe_ext3(int fd __BLKID_ATTR((unused)),
 	return 0;
 }
 
-static int probe_ext2(int fd __BLKID_ATTR((unused)), 
-		      blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_ext2(int fd __BLKID_ATTR((unused)),
+		      blkid_cache cache __BLKID_ATTR((unused)),
 		      blkid_dev dev,
 		      const struct blkid_magic *id, unsigned char *buf)
 {
@@ -132,7 +132,7 @@ static int probe_ext2(int fd __BLKID_ATTR((unused)),
 	es = (struct ext2_super_block *)buf;
 
 	/* Distinguish between jbd and ext2/3 fs */
-	if (blkid_le32(es->s_feature_incompat) & 
+	if (blkid_le32(es->s_feature_incompat) &
 	    EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)
 		return -BLKID_ERR_PARAM;
 
@@ -141,10 +141,10 @@ static int probe_ext2(int fd __BLKID_ATTR((unused)),
 	return 0;
 }
 
-static int probe_jbd(int fd __BLKID_ATTR((unused)), 
-		     blkid_cache cache __BLKID_ATTR((unused)), 
-		     blkid_dev dev, 
-		     const struct blkid_magic *id __BLKID_ATTR((unused)), 
+static int probe_jbd(int fd __BLKID_ATTR((unused)),
+		     blkid_cache cache __BLKID_ATTR((unused)),
+		     blkid_dev dev,
+		     const struct blkid_magic *id __BLKID_ATTR((unused)),
 		     unsigned char *buf)
 {
 	struct ext2_super_block *es = (struct ext2_super_block *) buf;
@@ -158,10 +158,10 @@ static int probe_jbd(int fd __BLKID_ATTR((unused)),
 	return 0;
 }
 
-static int probe_vfat(int fd __BLKID_ATTR((unused)), 
-		      blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_vfat(int fd __BLKID_ATTR((unused)),
+		      blkid_cache cache __BLKID_ATTR((unused)),
 		      blkid_dev dev,
-		      const struct blkid_magic *id __BLKID_ATTR((unused)), 
+		      const struct blkid_magic *id __BLKID_ATTR((unused)),
 		      unsigned char *buf)
 {
 	struct vfat_super_block *vs;
@@ -191,10 +191,10 @@ static int probe_vfat(int fd __BLKID_ATTR((unused)),
 	return 0;
 }
 
-static int probe_msdos(int fd __BLKID_ATTR((unused)), 
-		       blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_msdos(int fd __BLKID_ATTR((unused)),
+		       blkid_cache cache __BLKID_ATTR((unused)),
 		       blkid_dev dev,
-		       const struct blkid_magic *id __BLKID_ATTR((unused)), 
+		       const struct blkid_magic *id __BLKID_ATTR((unused)),
 		       unsigned char *buf)
 {
 	struct msdos_super_block *ms = (struct msdos_super_block *) buf;
@@ -223,10 +223,10 @@ static int probe_msdos(int fd __BLKID_ATTR((unused)),
 	return 0;
 }
 
-static int probe_xfs(int fd __BLKID_ATTR((unused)), 
-		     blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_xfs(int fd __BLKID_ATTR((unused)),
+		     blkid_cache cache __BLKID_ATTR((unused)),
 		     blkid_dev dev,
-		     const struct blkid_magic *id __BLKID_ATTR((unused)), 
+		     const struct blkid_magic *id __BLKID_ATTR((unused)),
 		     unsigned char *buf)
 {
 	struct xfs_super_block *xs;
@@ -241,8 +241,8 @@ static int probe_xfs(int fd __BLKID_ATTR((unused)),
 	return 0;
 }
 
-static int probe_reiserfs(int fd __BLKID_ATTR((unused)), 
-			  blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_reiserfs(int fd __BLKID_ATTR((unused)),
+			  blkid_cache cache __BLKID_ATTR((unused)),
 			  blkid_dev dev,
 			  const struct blkid_magic *id, unsigned char *buf)
 {
@@ -268,10 +268,10 @@ static int probe_reiserfs(int fd __BLKID_ATTR((unused)),
 	return 0;
 }
 
-static int probe_jfs(int fd __BLKID_ATTR((unused)), 
-		     blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_jfs(int fd __BLKID_ATTR((unused)),
+		     blkid_cache cache __BLKID_ATTR((unused)),
 		     blkid_dev dev,
-		     const struct blkid_magic *id __BLKID_ATTR((unused)), 
+		     const struct blkid_magic *id __BLKID_ATTR((unused)),
 		     unsigned char *buf)
 {
 	struct jfs_super_block *js;
@@ -286,10 +286,10 @@ static int probe_jfs(int fd __BLKID_ATTR((unused)),
 	return 0;
 }
 
-static int probe_romfs(int fd __BLKID_ATTR((unused)), 
-		       blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_romfs(int fd __BLKID_ATTR((unused)),
+		       blkid_cache cache __BLKID_ATTR((unused)),
 		       blkid_dev dev,
-		       const struct blkid_magic *id __BLKID_ATTR((unused)), 
+		       const struct blkid_magic *id __BLKID_ATTR((unused)),
 		       unsigned char *buf)
 {
 	struct romfs_super_block *ros;
@@ -340,7 +340,7 @@ static int probe_swap1(int fd,
 	/* arbitrary sanity check.. is there any garbage down there? */
 	if (sws->sws_pad[32] == 0 && sws->sws_pad[33] == 0)  {
 		if (sws->sws_volume[0])
-			blkid_set_tag(dev, "LABEL", sws->sws_volume, 
+			blkid_set_tag(dev, "LABEL", sws->sws_volume,
 				      sizeof(sws->sws_volume));
 		if (sws->sws_uuid[0])
 			set_uuid(dev, sws->sws_uuid);
@@ -354,9 +354,9 @@ static const char
 * const udf_magic[] = { "BEA01", "BOOT2", "CD001", "CDW02", "NSR02",
 		 "NSR03", "TEA01", 0 };
 
-static int probe_udf(int fd, blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_udf(int fd, blkid_cache cache __BLKID_ATTR((unused)),
 		     blkid_dev dev __BLKID_ATTR((unused)),
-		     const struct blkid_magic *id __BLKID_ATTR((unused)), 
+		     const struct blkid_magic *id __BLKID_ATTR((unused)),
 		     unsigned char *buf __BLKID_ATTR((unused)))
 {
 	int j, bs;
@@ -396,10 +396,10 @@ static int probe_udf(int fd, blkid_cache cache __BLKID_ATTR((unused)),
 	return 1;
 }
 
-static int probe_ocfs(int fd __BLKID_ATTR((unused)), 
-		      blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_ocfs(int fd __BLKID_ATTR((unused)),
+		      blkid_cache cache __BLKID_ATTR((unused)),
 		      blkid_dev dev,
-		      const struct blkid_magic *id __BLKID_ATTR((unused)), 
+		      const struct blkid_magic *id __BLKID_ATTR((unused)),
 		      unsigned char *buf)
 {
 	struct ocfs_volume_header ovh;
@@ -414,17 +414,17 @@ static int probe_ocfs(int fd __BLKID_ATTR((unused)),
 		blkid_set_tag(dev,"SEC_TYPE","ocfs1",sizeof("ocfs1"));
 	else if (major >= 9)
 		blkid_set_tag(dev,"SEC_TYPE","ntocfs",sizeof("ntocfs"));
-	
+
 	blkid_set_tag(dev, "LABEL", ovl.label, ocfslabellen(ovl));
 	blkid_set_tag(dev, "MOUNT", ovh.mount, ocfsmountlen(ovh));
 	set_uuid(dev, ovl.vol_id);
 	return 0;
 }
 
-static int probe_ocfs2(int fd __BLKID_ATTR((unused)), 
-		       blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_ocfs2(int fd __BLKID_ATTR((unused)),
+		       blkid_cache cache __BLKID_ATTR((unused)),
 		       blkid_dev dev,
-		       const struct blkid_magic *id __BLKID_ATTR((unused)), 
+		       const struct blkid_magic *id __BLKID_ATTR((unused)),
 		       unsigned char *buf)
 {
 	struct ocfs2_super_block *osb;
@@ -436,10 +436,10 @@ static int probe_ocfs2(int fd __BLKID_ATTR((unused)),
 	return 0;
 }
 
-static int probe_oracleasm(int fd __BLKID_ATTR((unused)), 
-			   blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_oracleasm(int fd __BLKID_ATTR((unused)),
+			   blkid_cache cache __BLKID_ATTR((unused)),
 			   blkid_dev dev,
-			   const struct blkid_magic *id __BLKID_ATTR((unused)), 
+			   const struct blkid_magic *id __BLKID_ATTR((unused)),
 			   unsigned char *buf)
 {
 	struct oracle_asm_disk_label *dl;
@@ -548,13 +548,13 @@ blkid_dev blkid_verify(blkid_cache cache, blkid_dev dev)
 	diff = now - dev->bid_time;
 
 	if ((now < dev->bid_time) ||
-	    (diff < BLKID_PROBE_MIN) || 
+	    (diff < BLKID_PROBE_MIN) ||
 	    (dev->bid_flags & BLKID_BID_FL_VERIFIED &&
 	     diff < BLKID_PROBE_INTERVAL))
 		return dev;
 
 	DBG(DEBUG_PROBE,
-	    printf("need to revalidate %s (time since last check %lu)\n", 
+	    printf("need to revalidate %s (time since last check %lu)\n",
 		   dev->bid_name, diff));
 
 	if (((fd = open(dev->bid_name, O_RDONLY)) < 0) ||
@@ -571,12 +571,12 @@ blkid_dev blkid_verify(blkid_cache cache, blkid_dev dev)
 	}
 
 	memset(bufs, 0, sizeof(bufs));
-	
+
 	/*
 	 * Iterate over the type array.  If we already know the type,
 	 * then try that first.  If it doesn't work, then blow away
 	 * the type information, and try again.
-	 * 
+	 *
 	 */
 try_again:
 	type = 0;
@@ -637,7 +637,7 @@ try_again:
 		blkid_free_dev(dev);
 		return NULL;
 	}
-		
+
 found_type:
 	if (dev && type) {
 		dev->bid_devno = st.st_rdev;
@@ -646,7 +646,7 @@ found_type:
 		cache->bic_flags |= BLKID_BIC_FL_CHANGED;
 
 		blkid_set_tag(dev, "TYPE", type, 0);
-				
+
 		DBG(DEBUG_PROBE, printf("%s: devno 0x%04Lx, type %s\n",
 			   dev->bid_name, st.st_rdev, type));
 	}
@@ -696,7 +696,7 @@ int main(int argc, char **argv)
 		printf("\tlabel is '%s'\n", dev->bid_label);
 	if (dev->bid_uuid)
 		printf("\tuuid is %s\n", dev->bid_uuid);
-	
+
 	blkid_free_dev(dev);
 	return (0);
 }
diff --git a/e2fsprogs/blkid/probe.h b/e2fsprogs/blkid/probe.h
index 10af5d518..530b8efe2 100644
--- a/e2fsprogs/blkid/probe.h
+++ b/e2fsprogs/blkid/probe.h
@@ -18,7 +18,7 @@
 
 struct blkid_magic;
 
-typedef int (*blkid_probe_t)(int fd, blkid_cache cache, blkid_dev dev, 
+typedef int (*blkid_probe_t)(int fd, blkid_cache cache, blkid_dev dev,
 			     const struct blkid_magic *id, unsigned char *buf);
 
 struct blkid_magic {
@@ -222,16 +222,16 @@ struct ocfs_volume_header {
 
 struct ocfs_volume_label {
 	unsigned char	disk_lock[48];
-	unsigned char	label[64];	
+	unsigned char	label[64];
 	unsigned char	label_len[2];
 	unsigned char  vol_id[16];
 	unsigned char  vol_id_len[2];
 };
 
 #define ocfsmajor(o) ((__u32)o.major_version[0] \
-                   + (((__u32) o.major_version[1]) << 8) \
-                   + (((__u32) o.major_version[2]) << 16) \
-                   + (((__u32) o.major_version[3]) << 24))
+		   + (((__u32) o.major_version[1]) << 8) \
+		   + (((__u32) o.major_version[2]) << 16) \
+		   + (((__u32) o.major_version[3]) << 24))
 #define ocfslabellen(o)	((__u32)o.label_len[0] + (((__u32) o.label_len[1]) << 8))
 #define ocfsmountlen(o)	((__u32)o.mount_len[0] + (((__u32) o.mount_len[1])<<8))
 
@@ -334,7 +334,7 @@ _INLINE_ __u64 blkid_swab64(__u64 val)
 	return (blkid_swab32(val >> 32) |
 		(((__u64) blkid_swab32(val & 0xFFFFFFFFUL)) << 32));
 }
-#endif 
+#endif
 
 
 
diff --git a/e2fsprogs/blkid/read.c b/e2fsprogs/blkid/read.c
index 78464145d..08a3162f3 100644
--- a/e2fsprogs/blkid/read.c
+++ b/e2fsprogs/blkid/read.c
@@ -302,7 +302,7 @@ static int parse_tag(blkid_cache cache, blkid_dev dev, char **cp)
 		return ret;
 
 	/* Some tags are stored directly in the device struct */
-	if (!strcmp(name, "DEVNO")) 
+	if (!strcmp(name, "DEVNO"))
 		dev->bid_devno = STRTOULL(value, 0, 0);
 	else if (!strcmp(name, "PRI"))
 		dev->bid_pri = strtol(value, 0, 0);
@@ -389,7 +389,7 @@ void blkid_read_cache(blkid_cache cache)
 					cache->bic_filename));
 		goto errout;
 	}
-	
+
 	DBG(DEBUG_CACHE, printf("reading cache file %s\n",
 				cache->bic_filename));
 
diff --git a/e2fsprogs/blkid/resolve.c b/e2fsprogs/blkid/resolve.c
index 625782d44..591b63057 100644
--- a/e2fsprogs/blkid/resolve.c
+++ b/e2fsprogs/blkid/resolve.c
@@ -69,7 +69,7 @@ char *blkid_get_devname(blkid_cache cache, const char *token,
 
 	if (!token)
 		return NULL;
-	
+
 	if (!cache) {
 		if (blkid_get_cache(&c, NULL) < 0)
 			return NULL;
@@ -125,7 +125,7 @@ int main(int argc, char **argv)
 		fprintf(stderr, "Couldn't get blkid cache\n");
 		exit(1);
 	}
-	
+
 	if (argv[2]) {
 		value = blkid_get_tag_value(cache, argv[1], argv[2]);
 		printf("%s has tag %s=%s\n", argv[2], argv[1],
diff --git a/e2fsprogs/blkid/save.c b/e2fsprogs/blkid/save.c
index 3fba2450a..cc406ebfb 100644
--- a/e2fsprogs/blkid/save.c
+++ b/e2fsprogs/blkid/save.c
@@ -176,7 +176,7 @@ int main(int argc, char **argv)
 		exit(1);
 	}
 	cache->bic_filename = blkid_strdup(argv[1]);
-	
+
 	if ((ret = blkid_flush_cache(cache)) < 0) {
 		fprintf(stderr, "error (%d) saving cache\n", ret);
 		exit(1);
diff --git a/e2fsprogs/blkid/tag.c b/e2fsprogs/blkid/tag.c
index 699d0fb46..e2c785cf0 100644
--- a/e2fsprogs/blkid/tag.c
+++ b/e2fsprogs/blkid/tag.c
@@ -96,7 +96,7 @@ static blkid_tag blkid_find_head_cache(blkid_cache cache, const char *type)
 
 /*
  * Set a tag on an existing device.
- * 
+ *
  * If value is NULL, then delete the tagsfrom the device.
  */
 int blkid_set_tag(blkid_dev dev, const char *name,
@@ -131,7 +131,7 @@ int blkid_set_tag(blkid_dev dev, const char *name,
 		t->bit_dev = dev;
 
 		list_add_tail(&t->bit_tags, &dev->bid_tags);
-		
+
 		if (dev->bid_cache) {
 			head = blkid_find_head_cache(dev->bid_cache,
 						     t->bit_name);
@@ -151,7 +151,7 @@ int blkid_set_tag(blkid_dev dev, const char *name,
 			list_add_tail(&t->bit_names, &head->bit_names);
 		}
 	}
-	
+
 	/* Link common tags directly to the device struct */
 	if (!strcmp(name, "TYPE"))
 		dev->bid_type = val;
@@ -159,7 +159,7 @@ int blkid_set_tag(blkid_dev dev, const char *name,
 		dev->bid_label = val;
 	else if (!strcmp(name, "UUID"))
 		dev->bid_uuid = val;
-		
+
 	if (dev->bid_cache)
 		dev->bid_cache->bic_flags |= BLKID_BIC_FL_CHANGED;
 	return 0;
@@ -235,7 +235,7 @@ errout:
  * This series of functions iterate over all tags in a device
  */
 #define TAG_ITERATE_MAGIC	0x01a5284c
-	
+
 struct blkid_struct_tag_iterate {
 	int			magic;
 	blkid_dev		dev;
@@ -260,7 +260,7 @@ extern int blkid_tag_next(blkid_tag_iterate iter,
 			  const char **type, const char **value)
 {
 	blkid_tag tag;
-	
+
 	*type = 0;
 	*value = 0;
 	if (!iter || iter->magic != TAG_ITERATE_MAGIC ||
@@ -303,9 +303,9 @@ extern blkid_dev blkid_find_dev_with_tag(blkid_cache cache,
 		return NULL;
 
 	blkid_read_cache(cache);
-	
+
 	DBG(DEBUG_TAG, printf("looking for %s=%s in cache\n", type, value));
-	
+
 try_again:
 	pri = -1;
 	dev = 0;
@@ -313,7 +313,7 @@ try_again:
 
 	if (head) {
 		list_for_each(p, &head->bit_names) {
-			blkid_tag tmp = list_entry(p, struct blkid_struct_tag, 
+			blkid_tag tmp = list_entry(p, struct blkid_struct_tag,
 						   bit_names);
 
 			if (!strcmp(tmp->bit_val, value) &&
diff --git a/e2fsprogs/chattr.c b/e2fsprogs/chattr.c
index 66838e642..c39003821 100644
--- a/e2fsprogs/chattr.c
+++ b/e2fsprogs/chattr.c
@@ -161,8 +161,8 @@ skip_setflags:
 		iterate_on_dir(name, chattr_dir_proc, NULL);
 }
 
-static int chattr_dir_proc(const char *dir_name, struct dirent *de, 
-                           void *private EXT2FS_ATTR((unused)))
+static int chattr_dir_proc(const char *dir_name, struct dirent *de,
+			   void *private EXT2FS_ATTR((unused)))
 {
 	/*if (strcmp(de->d_name, ".") && strcmp(de->d_name, "..")) {*/
 	if (de->d_name[0] == '.' && (de->d_name[1] == '\0' || \
diff --git a/e2fsprogs/e2fsck.c b/e2fsprogs/e2fsck.c
index b31b19414..1c97cf4bb 100644
--- a/e2fsprogs/e2fsck.c
+++ b/e2fsprogs/e2fsck.c
@@ -11797,8 +11797,8 @@ static int count_tags(struct buffer_head *bh, int size)
 
 
 /* Make sure we wrap around the log correctly! */
-#define wrap(journal, var)                                              \
-do {                                                                    \
+#define wrap(journal, var)					      \
+do {					                            \
 	if (var >= (journal)->j_last)                                   \
 		var -= ((journal)->j_last - (journal)->j_first);        \
 } while (0)
diff --git a/e2fsprogs/e2p/feature.c b/e2fsprogs/e2p/feature.c
index fe6016102..0a9058384 100644
--- a/e2fsprogs/e2p/feature.c
+++ b/e2fsprogs/e2p/feature.c
@@ -1,11 +1,11 @@
 /*
  * feature.c --- convert between features and strings
- * 
+ *
  * Copyright (C) 1999  Theodore Ts'o <tytso@mit.edu>
- * 
+ *
  * This file can be redistributed under the terms of the GNU Library General
  * Public License
- * 
+ *
  */
 
 #include <stdio.h>
diff --git a/e2fsprogs/e2p/fgetsetversion.c b/e2fsprogs/e2p/fgetsetversion.c
index dcf127c26..8227ab3be 100644
--- a/e2fsprogs/e2p/fgetsetversion.c
+++ b/e2fsprogs/e2p/fgetsetversion.c
@@ -33,11 +33,11 @@
 #define OPEN_FLAGS (O_RDONLY|O_NONBLOCK)
 #endif
 
-/* 
+/*
    To do fsetversion:     unsigned long *ptr_version must be set to NULL.
-                      and unsigned long version must be set to a value   
+		      and unsigned long version must be set to a value
    To do fgetversion:     unsigned long *ptr_version must NOT be set to NULL
-                      and unsigned long version is ignored.
+		      and unsigned long version is ignored.
 	TITO.
 */
 
diff --git a/e2fsprogs/e2p/hashstr.c b/e2fsprogs/e2p/hashstr.c
index c4b3f9fd5..705f63ae0 100644
--- a/e2fsprogs/e2p/hashstr.c
+++ b/e2fsprogs/e2p/hashstr.c
@@ -1,11 +1,11 @@
 /*
  * feature.c --- convert between features and strings
- * 
+ *
  * Copyright (C) 1999  Theodore Ts'o <tytso@mit.edu>
- * 
+ *
  * This file can be redistributed under the terms of the GNU Library General
  * Public License
- * 
+ *
  */
 
 #include <stdio.h>
diff --git a/e2fsprogs/e2p/ls.c b/e2fsprogs/e2p/ls.c
index 71f8f5126..0c91345e1 100644
--- a/e2fsprogs/e2p/ls.c
+++ b/e2fsprogs/e2p/ls.c
@@ -6,7 +6,7 @@
  *                                 Universite Pierre et Marie Curie (Paris VI)
  *
  * Copyright (C) 1995, 1996, 1997  Theodore Ts'o <tytso@mit.edu>
- * 
+ *
  * This file can be redistributed under the terms of the GNU Library General
  * Public License
  */
@@ -190,11 +190,11 @@ void list_super2(struct ext2_super_block * sb, FILE *f)
 		"Block size:               %u\n"
 		"Fragment size:            %u\n",
 		str, sb->s_inodes_count, sb->s_blocks_count, sb->s_r_blocks_count,
-		sb->s_free_blocks_count, sb->s_free_inodes_count, 
+		sb->s_free_blocks_count, sb->s_free_inodes_count,
 		sb->s_first_data_block, EXT2_BLOCK_SIZE(sb), EXT2_FRAG_SIZE(sb));
 	free(str);
 	if (sb->s_reserved_gdt_blocks)
-		fprintf(f, "Reserved GDT blocks:      %u\n", 
+		fprintf(f, "Reserved GDT blocks:      %u\n",
 			sb->s_reserved_gdt_blocks);
 	fprintf(f,
 		"Blocks per group:         %u\n"
diff --git a/e2fsprogs/e2p/mntopts.c b/e2fsprogs/e2p/mntopts.c
index 562a9ccc1..b27f78ed9 100644
--- a/e2fsprogs/e2p/mntopts.c
+++ b/e2fsprogs/e2p/mntopts.c
@@ -1,11 +1,11 @@
 /*
  * mountopts.c --- convert between default mount options and strings
- * 
+ *
  * Copyright (C) 2002  Theodore Ts'o <tytso@mit.edu>
- * 
+ *
  * This file can be redistributed under the terms of the GNU Library General
  * Public License
- * 
+ *
  */
 
 #include <stdio.h>
diff --git a/e2fsprogs/e2p/ostype.c b/e2fsprogs/e2p/ostype.c
index 1084abde2..46230631e 100644
--- a/e2fsprogs/e2p/ostype.c
+++ b/e2fsprogs/e2p/ostype.c
@@ -11,10 +11,10 @@
 #include <string.h>
 
 static const char * const os_tab[] =
-	{ "Linux", 
-	  "Hurd", 
-	  "Masix", 
-	  "FreeBSD", 
+	{ "Linux",
+	  "Hurd",
+	  "Masix",
+	  "FreeBSD",
 	  "Lites",
 	  0 };
 
@@ -53,7 +53,7 @@ int e2p_string2os(char *str)
 #ifdef TEST_PROGRAM
 int main(int argc, char **argv)
 {
-	char 	*s;
+	char	*s;
 	int	i, os;
 
 	for (i=0; i <= EXT2_OS_LITES; i++) {
diff --git a/e2fsprogs/e2p/parse_num.c b/e2fsprogs/e2p/parse_num.c
index 3910e70de..81c160544 100644
--- a/e2fsprogs/e2p/parse_num.c
+++ b/e2fsprogs/e2p/parse_num.c
@@ -1,8 +1,8 @@
 /*
- * parse_num.c		- Parse the number of blocks 
+ * parse_num.c		- Parse the number of blocks
  *
  * Copyright (C) 2004,2005  Theodore Ts'o <tytso@mit.edu>
- * 
+ *
  * This file can be redistributed under the terms of the GNU Library General
  * Public License
  */
@@ -18,25 +18,25 @@ unsigned long parse_num_blocks(const char *arg, int log_block_size)
 
 	num = strtoull(arg, &p, 0);
 
-	if (p[0] && p[1]) 
+	if (p[0] && p[1])
 		return 0;
 
 	switch (*p) {		/* Using fall-through logic */
-	case 'T': case 't': 
+	case 'T': case 't':
 		num <<= 10;
-	case 'G': case 'g': 
+	case 'G': case 'g':
 		num <<= 10;
-	case 'M': case 'm': 
+	case 'M': case 'm':
 		num <<= 10;
-	case 'K': case 'k': 
-		num >>= log_block_size; 
+	case 'K': case 'k':
+		num >>= log_block_size;
 		break;
-	case 's': 
+	case 's':
 		num >>= 1;
 		break;
 	case '\0':
 		break;
-	default: 
+	default:
 		return 0;
 	}
 	return num;
diff --git a/e2fsprogs/e2p/pf.c b/e2fsprogs/e2p/pf.c
index 2194ac6bf..da8357a46 100644
--- a/e2fsprogs/e2p/pf.c
+++ b/e2fsprogs/e2p/pf.c
@@ -41,7 +41,7 @@ static const struct flags_name flags_array[] = {
 	{ EXT2_ECOMPR_FL, "E", "Compression_Error" },
 #endif
 	{ EXT3_JOURNAL_DATA_FL, "j", "Journaled_Data" },
-	{ EXT2_INDEX_FL, "I", "Indexed_direcctory" }, 
+	{ EXT2_INDEX_FL, "I", "Indexed_direcctory" },
 	{ EXT2_NOTAIL_FL, "t", "No_Tailmerging" },
 	{ EXT2_TOPDIR_FL, "T", "Top_of_Directory_Hierarchies" },
 	{ 0, NULL, NULL }
diff --git a/e2fsprogs/e2p/uuid.c b/e2fsprogs/e2p/uuid.c
index 9feca4cfa..cb4ec8072 100644
--- a/e2fsprogs/e2p/uuid.c
+++ b/e2fsprogs/e2p/uuid.c
@@ -19,7 +19,7 @@ struct uuid {
 /* Returns 1 if the uuid is the NULL uuid */
 int e2p_is_null_uuid(void *uu)
 {
-	__u8 	*cp;
+	__u8	*cp;
 	int	i;
 
 	for (i=0, cp = uu; i < 16; i++)
@@ -42,7 +42,7 @@ static void e2p_unpack_uuid(void *in, struct uuid *uu)
 	tmp = *ptr++;
 	tmp = (tmp << 8) | *ptr++;
 	uu->time_mid = tmp;
-	
+
 	tmp = *ptr++;
 	tmp = (tmp << 8) | *ptr++;
 	uu->time_hi_and_version = tmp;
diff --git a/e2fsprogs/ext2fs/alloc.c b/e2fsprogs/ext2fs/alloc.c
index 7385123b8..d56ef2566 100644
--- a/e2fsprogs/ext2fs/alloc.c
+++ b/e2fsprogs/ext2fs/alloc.c
@@ -7,7 +7,7 @@
  * This file may be redistributed under the terms of the GNU Public
  * License.
  * %End-Header%
- * 
+ *
  */
 
 #include <stdio.h>
@@ -32,7 +32,7 @@
  *
  * Should have a special policy for directories.
  */
-errcode_t ext2fs_new_inode(ext2_filsys fs, ext2_ino_t dir, 
+errcode_t ext2fs_new_inode(ext2_filsys fs, ext2_ino_t dir,
 			   int mode EXT2FS_ATTR((unused)),
 			   ext2fs_inode_bitmap map, ext2_ino_t *ret)
 {
@@ -41,13 +41,13 @@ errcode_t ext2fs_new_inode(ext2_filsys fs, ext2_ino_t dir,
 	ext2_ino_t	start_inode;
 
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
-	
+
 	if (!map)
 		map = fs->inode_map;
 	if (!map)
 		return EXT2_ET_NO_INODE_BITMAP;
-	
-	if (dir > 0) 
+
+	if (dir > 0)
 		dir_group = (dir - 1) / EXT2_INODES_PER_GROUP(fs->super);
 
 	start_inode = (dir_group * EXT2_INODES_PER_GROUP(fs->super)) + 1;
@@ -62,7 +62,7 @@ errcode_t ext2fs_new_inode(ext2_filsys fs, ext2_ino_t dir,
 		if (i > fs->super->s_inodes_count)
 			i = EXT2_FIRST_INODE(fs->super);
 	} while (i != start_inode);
-	
+
 	if (ext2fs_test_inode_bitmap(map, i))
 		return EXT2_ET_INODE_ALLOC_FAIL;
 	*ret = i;
@@ -131,7 +131,7 @@ errcode_t ext2fs_alloc_block(ext2_filsys fs, blk_t goal,
 	retval = io_channel_write_blk(fs->io, block, 1, block_buf);
 	if (retval)
 		goto fail;
-	
+
 	ext2fs_block_alloc_stats(fs, block, +1);
 	*ret = block;
 	return 0;
diff --git a/e2fsprogs/ext2fs/alloc_sb.c b/e2fsprogs/ext2fs/alloc_sb.c
index ef40b938f..aa2cd0568 100644
--- a/e2fsprogs/ext2fs/alloc_sb.c
+++ b/e2fsprogs/ext2fs/alloc_sb.c
@@ -1,5 +1,5 @@
 /*
- * alloc_sb.c --- Allocate the superblock and block group descriptors for a 
+ * alloc_sb.c --- Allocate the superblock and block group descriptors for a
  * newly initialized filesystem.  Used by mke2fs when initializing a filesystem
  *
  * Copyright (C) 1994, 1995, 1996, 2003 Theodore Ts'o.
@@ -27,20 +27,20 @@
 #include "ext2_fs.h"
 #include "ext2fs.h"
 
-int ext2fs_reserve_super_and_bgd(ext2_filsys fs, 
+int ext2fs_reserve_super_and_bgd(ext2_filsys fs,
 				 dgrp_t group,
 				 ext2fs_block_bitmap bmap)
 {
 	blk_t	super_blk, old_desc_blk, new_desc_blk;
 	int	j, old_desc_blocks, num_blocks;
 
-	num_blocks = ext2fs_super_and_bgd_loc(fs, group, &super_blk, 
+	num_blocks = ext2fs_super_and_bgd_loc(fs, group, &super_blk,
 					      &old_desc_blk, &new_desc_blk, 0);
 
 	if (fs->super->s_feature_incompat & EXT2_FEATURE_INCOMPAT_META_BG)
 		old_desc_blocks = fs->super->s_first_meta_bg;
 	else
-		old_desc_blocks = 
+		old_desc_blocks =
 			fs->desc_blocks + fs->super->s_reserved_gdt_blocks;
 
 	if (super_blk || (group == 0))
diff --git a/e2fsprogs/ext2fs/alloc_stats.c b/e2fsprogs/ext2fs/alloc_stats.c
index 4088f7b87..32aa0b6bc 100644
--- a/e2fsprogs/ext2fs/alloc_stats.c
+++ b/e2fsprogs/ext2fs/alloc_stats.c
@@ -7,7 +7,7 @@
  * This file may be redistributed under the terms of the GNU Public
  * License.
  * %End-Header%
- * 
+ *
  */
 
 #include <stdio.h>
diff --git a/e2fsprogs/ext2fs/alloc_tables.c b/e2fsprogs/ext2fs/alloc_tables.c
index 0326321be..10f1f95a4 100644
--- a/e2fsprogs/ext2fs/alloc_tables.c
+++ b/e2fsprogs/ext2fs/alloc_tables.c
@@ -36,14 +36,14 @@ errcode_t ext2fs_allocate_group_table(ext2_filsys fs, dgrp_t group,
 
 	group_blk = fs->super->s_first_data_block +
 		(group * fs->super->s_blocks_per_group);
-	
+
 	last_blk = group_blk + fs->super->s_blocks_per_group;
 	if (last_blk >= fs->super->s_blocks_count)
 		last_blk = fs->super->s_blocks_count - 1;
 
 	if (!bmap)
 		bmap = fs->block_map;
-	
+
 	/*
 	 * Allocate the block and inode bitmaps, if necessary
 	 */
@@ -59,7 +59,7 @@ errcode_t ext2fs_allocate_group_table(ext2_filsys fs, dgrp_t group,
 	if (!fs->group_desc[group].bg_block_bitmap) {
 		retval = ext2fs_get_free_blocks(fs, start_blk, last_blk,
 						1, bmap, &new_blk);
-		if (retval == EXT2_ET_BLOCK_ALLOC_FAIL) 
+		if (retval == EXT2_ET_BLOCK_ALLOC_FAIL)
 			retval = ext2fs_get_free_blocks(fs, group_blk,
 					last_blk, 1, bmap, &new_blk);
 		if (retval)
@@ -71,7 +71,7 @@ errcode_t ext2fs_allocate_group_table(ext2_filsys fs, dgrp_t group,
 	if (!fs->group_desc[group].bg_inode_bitmap) {
 		retval = ext2fs_get_free_blocks(fs, start_blk, last_blk,
 						1, bmap, &new_blk);
-		if (retval == EXT2_ET_BLOCK_ALLOC_FAIL) 
+		if (retval == EXT2_ET_BLOCK_ALLOC_FAIL)
 			retval = ext2fs_get_free_blocks(fs, group_blk,
 					last_blk, 1, bmap, &new_blk);
 		if (retval)
@@ -96,11 +96,11 @@ errcode_t ext2fs_allocate_group_table(ext2_filsys fs, dgrp_t group,
 		fs->group_desc[group].bg_inode_table = new_blk;
 	}
 
-	
+
 	return 0;
 }
 
-	
+
 
 errcode_t ext2fs_allocate_tables(ext2_filsys fs)
 {
diff --git a/e2fsprogs/ext2fs/badblocks.c b/e2fsprogs/ext2fs/badblocks.c
index 4b76ef032..d82041126 100644
--- a/e2fsprogs/ext2fs/badblocks.c
+++ b/e2fsprogs/ext2fs/badblocks.c
@@ -1,6 +1,6 @@
 /*
  * badblocks.c --- routines to manipulate the bad block structure
- * 
+ *
  * Copyright (C) 1994, 1995, 1996 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -34,7 +34,7 @@ static errcode_t make_u32_list(int size, int num, __u32 *list,
 {
 	ext2_u32_list	bb;
 	errcode_t	retval;
-	
+
 	retval = ext2fs_get_mem(sizeof(struct ext2_struct_u32_list), &bb);
 	if (retval)
 		return retval;
@@ -54,7 +54,7 @@ static errcode_t make_u32_list(int size, int num, __u32 *list,
 	*ret = bb;
 	return 0;
 }
-	
+
 
 /*
  * This procedure creates an empty u32 list.
@@ -79,7 +79,7 @@ errcode_t ext2fs_badblocks_list_create(ext2_badblocks_list *ret, int size)
 errcode_t ext2fs_u32_copy(ext2_u32_list src, ext2_u32_list *dest)
 {
 	errcode_t	retval;
-	
+
 	retval = make_u32_list(src->size, src->num, src->list, dest);
 	if (retval)
 		return retval;
@@ -271,11 +271,11 @@ int ext2fs_u32_list_iterate(ext2_u32_iterate iter, __u32 *blk)
 
 	if (bb->magic != EXT2_ET_MAGIC_BADBLOCKS_LIST)
 		return 0;
-	
+
 	if (iter->ptr < bb->num) {
 		*blk = bb->list[iter->ptr++];
 		return 1;
-	} 
+	}
 	*blk = 0;
 	return 0;
 }
diff --git a/e2fsprogs/ext2fs/bb_compat.c b/e2fsprogs/ext2fs/bb_compat.c
index 40f734368..5a158b34c 100644
--- a/e2fsprogs/ext2fs/bb_compat.c
+++ b/e2fsprogs/ext2fs/bb_compat.c
@@ -1,6 +1,6 @@
 /*
  * bb_compat.c --- compatibility badblocks routines
- * 
+ *
  * Copyright (C) 1997 Theodore Ts'o.
  *
  * %Begin-Header%
diff --git a/e2fsprogs/ext2fs/bb_inode.c b/e2fsprogs/ext2fs/bb_inode.c
index dd8e7c319..9af117d8f 100644
--- a/e2fsprogs/ext2fs/bb_inode.c
+++ b/e2fsprogs/ext2fs/bb_inode.c
@@ -1,12 +1,12 @@
 /*
  * bb_inode.c --- routines to update the bad block inode.
- * 
+ *
  * WARNING: This routine modifies a lot of state in the filesystem; if
  * this routine returns an error, the bad block inode may be in an
  * inconsistent state.
- * 
+ *
  * Copyright (C) 1994, 1995 Theodore Ts'o.
- * 
+ *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
  * License.
@@ -49,7 +49,7 @@ static int clear_bad_block_proc(ext2_filsys fs, blk_t *block_nr,
 				e2_blkcnt_t blockcnt,
 				blk_t ref_block, int ref_offset,
 				void *priv_data);
-	
+
 /*
  * Given a bad blocks bitmap, update the bad blocks inode to reflect
  * the map.
@@ -57,14 +57,14 @@ static int clear_bad_block_proc(ext2_filsys fs, blk_t *block_nr,
 errcode_t ext2fs_update_bb_inode(ext2_filsys fs, ext2_badblocks_list bb_list)
 {
 	errcode_t			retval;
-	struct set_badblock_record 	rec;
+	struct set_badblock_record	rec;
 	struct ext2_inode		inode;
-	
+
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	if (!fs->block_map)
 		return EXT2_ET_NO_BLOCK_BITMAP;
-	
+
 	rec.bad_block_count = 0;
 	rec.ind_blocks_size = rec.ind_blocks_ptr = 0;
 	rec.max_ind_blocks = 10;
@@ -78,9 +78,9 @@ errcode_t ext2fs_update_bb_inode(ext2_filsys fs, ext2_badblocks_list bb_list)
 		goto cleanup;
 	memset(rec.block_buf, 0, fs->blocksize);
 	rec.err = 0;
-	
+
 	/*
-	 * First clear the old bad blocks (while saving the indirect blocks) 
+	 * First clear the old bad blocks (while saving the indirect blocks)
 	 */
 	retval = ext2fs_block_iterate2(fs, EXT2_BAD_INO,
 				       BLOCK_FLAG_DEPTH_TRAVERSE, 0,
@@ -91,7 +91,7 @@ errcode_t ext2fs_update_bb_inode(ext2_filsys fs, ext2_badblocks_list bb_list)
 		retval = rec.err;
 		goto cleanup;
 	}
-	
+
 	/*
 	 * Now set the bad blocks!
 	 *
@@ -108,22 +108,22 @@ errcode_t ext2fs_update_bb_inode(ext2_filsys fs, ext2_badblocks_list bb_list)
 					       BLOCK_FLAG_APPEND, 0,
 					       set_bad_block_proc, &rec);
 		ext2fs_badblocks_list_iterate_end(rec.bb_iter);
-		if (retval) 
+		if (retval)
 			goto cleanup;
 		if (rec.err) {
 			retval = rec.err;
 			goto cleanup;
 		}
 	}
-	
+
 	/*
 	 * Update the bad block inode's mod time and block count
-	 * field.  
+	 * field.
 	 */
 	retval = ext2fs_read_inode(fs, EXT2_BAD_INO, &inode);
 	if (retval)
 		goto cleanup;
-	
+
 	inode.i_atime = inode.i_mtime = time(0);
 	if (!inode.i_ctime)
 		inode.i_ctime = time(0);
@@ -133,7 +133,7 @@ errcode_t ext2fs_update_bb_inode(ext2_filsys fs, ext2_badblocks_list bb_list)
 	retval = ext2fs_write_inode(fs, EXT2_BAD_INO, &inode);
 	if (retval)
 		goto cleanup;
-	
+
 cleanup:
 	ext2fs_free_mem(&rec.ind_blocks);
 	ext2fs_free_mem(&rec.block_buf);
@@ -158,7 +158,7 @@ static int clear_bad_block_proc(ext2_filsys fs, blk_t *block_nr,
 	struct set_badblock_record *rec = (struct set_badblock_record *)
 		priv_data;
 	errcode_t	retval;
-	unsigned long 	old_size;
+	unsigned long	old_size;
 
 	if (!*block_nr)
 		return 0;
@@ -176,7 +176,7 @@ static int clear_bad_block_proc(ext2_filsys fs, blk_t *block_nr,
 		if (rec->ind_blocks_size >= rec->max_ind_blocks) {
 			old_size = rec->max_ind_blocks * sizeof(blk_t);
 			rec->max_ind_blocks += 10;
-			retval = ext2fs_resize_mem(old_size, 
+			retval = ext2fs_resize_mem(old_size,
 				   rec->max_ind_blocks * sizeof(blk_t),
 				   &rec->ind_blocks);
 			if (retval) {
@@ -192,12 +192,12 @@ static int clear_bad_block_proc(ext2_filsys fs, blk_t *block_nr,
 	 * Mark the block as unused, and update accounting information
 	 */
 	ext2fs_block_alloc_stats(fs, *block_nr, -1);
-	
+
 	*block_nr = 0;
 	return BLOCK_CHANGED;
 }
 
-	
+
 /*
  * Helper function for update_bb_inode()
  *
@@ -250,12 +250,12 @@ static int set_bad_block_proc(ext2_filsys fs, blk_t *block_nr,
 			return BLOCK_ABORT;
 		}
 	}
-	
+
 	/*
 	 * Update block counts
 	 */
 	ext2fs_block_alloc_stats(fs, blk, +1);
-	
+
 	*block_nr = blk;
 	return BLOCK_CHANGED;
 }
diff --git a/e2fsprogs/ext2fs/bitmaps.c b/e2fsprogs/ext2fs/bitmaps.c
index 7edd28d7b..932c345fa 100644
--- a/e2fsprogs/ext2fs/bitmaps.c
+++ b/e2fsprogs/ext2fs/bitmaps.c
@@ -35,7 +35,7 @@ static errcode_t make_bitmap(__u32 start, __u32 end, __u32 real_end,
 	errcode_t		retval;
 	size_t			size;
 
-	retval = ext2fs_get_mem(sizeof(struct ext2fs_struct_generic_bitmap), 
+	retval = ext2fs_get_mem(sizeof(struct ext2fs_struct_generic_bitmap),
 				&bitmap);
 	if (retval)
 		return retval;
@@ -106,7 +106,7 @@ void ext2fs_set_bitmap_padding(ext2fs_generic_bitmap map)
 		ext2fs_set_bit(j, map->bitmap);
 
 	return;
-}	
+}
 
 errcode_t ext2fs_allocate_inode_bitmap(ext2_filsys fs,
 				       const char *descr,
@@ -128,11 +128,11 @@ errcode_t ext2fs_allocate_inode_bitmap(ext2_filsys fs,
 						descr, &bitmap);
 	if (retval)
 		return retval;
-	
+
 	bitmap->magic = EXT2_ET_MAGIC_INODE_BITMAP;
 	bitmap->fs = fs;
 	bitmap->base_error_code = EXT2_ET_BAD_INODE_MARK;
-	
+
 	*ret = bitmap;
 	return 0;
 }
@@ -151,9 +151,9 @@ errcode_t ext2fs_allocate_block_bitmap(ext2_filsys fs,
 
 	start = fs->super->s_first_data_block;
 	end = fs->super->s_blocks_count-1;
-	real_end = (EXT2_BLOCKS_PER_GROUP(fs->super)  
+	real_end = (EXT2_BLOCKS_PER_GROUP(fs->super)
 		    * fs->group_desc_count)-1 + start;
-	
+
 	retval = ext2fs_allocate_generic_bitmap(start, end, real_end,
 						descr, &bitmap);
 	if (retval)
@@ -162,7 +162,7 @@ errcode_t ext2fs_allocate_block_bitmap(ext2_filsys fs,
 	bitmap->magic = EXT2_ET_MAGIC_BLOCK_BITMAP;
 	bitmap->fs = fs;
 	bitmap->base_error_code = EXT2_ET_BAD_BLOCK_MARK;
-	
+
 	*ret = bitmap;
 	return 0;
 }
@@ -171,7 +171,7 @@ errcode_t ext2fs_fudge_inode_bitmap_end(ext2fs_inode_bitmap bitmap,
 					ext2_ino_t end, ext2_ino_t *oend)
 {
 	EXT2_CHECK_MAGIC(bitmap, EXT2_ET_MAGIC_INODE_BITMAP);
-	
+
 	if (end > bitmap->real_end)
 		return EXT2_ET_FUDGE_INODE_BITMAP_END;
 	if (oend)
@@ -184,7 +184,7 @@ errcode_t ext2fs_fudge_block_bitmap_end(ext2fs_block_bitmap bitmap,
 					blk_t end, blk_t *oend)
 {
 	EXT2_CHECK_MAGIC(bitmap, EXT2_ET_MAGIC_BLOCK_BITMAP);
-	
+
 	if (end > bitmap->real_end)
 		return EXT2_ET_FUDGE_BLOCK_BITMAP_END;
 	if (oend)
diff --git a/e2fsprogs/ext2fs/bitops.c b/e2fsprogs/ext2fs/bitops.c
index 207c44d92..e44e10cf4 100644
--- a/e2fsprogs/ext2fs/bitops.c
+++ b/e2fsprogs/ext2fs/bitops.c
@@ -1,7 +1,7 @@
 /*
  * bitops.c --- Bitmap frobbing code.  See bitops.h for the inlined
- * 	routines.
- * 
+ *	routines.
+ *
  * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
  *
  * %Begin-Header%
diff --git a/e2fsprogs/ext2fs/bitops.h b/e2fsprogs/ext2fs/bitops.h
index b6446efa2..4dba050c8 100644
--- a/e2fsprogs/ext2fs/bitops.h
+++ b/e2fsprogs/ext2fs/bitops.h
@@ -1,14 +1,14 @@
 /*
  * bitops.h --- Bitmap frobbing code.  The byte swapping routines are
- * 	also included here.
- * 
+ *	also included here.
+ *
  * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
  *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
  * License.
  * %End-Header%
- * 
+ *
  * i386 bitops operations taken from <asm/bitops.h>, Copyright 1992,
  * Linus Torvalds.
  */
diff --git a/e2fsprogs/ext2fs/block.c b/e2fsprogs/ext2fs/block.c
index 7685680df..18be2a5e8 100644
--- a/e2fsprogs/ext2fs/block.c
+++ b/e2fsprogs/ext2fs/block.c
@@ -1,6 +1,6 @@
 /*
  * block.c --- iterate over all blocks in an inode
- * 
+ *
  * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -59,7 +59,7 @@ static int block_iterate_ind(blk_t *ind_block, blk_t ref_block,
 		ret |= BLOCK_ERROR;
 		return ret;
 	}
-	ctx->errcode = ext2fs_read_ind_block(ctx->fs, *ind_block, 
+	ctx->errcode = ext2fs_read_ind_block(ctx->fs, *ind_block,
 					     ctx->ind_buf);
 	if (ctx->errcode) {
 		ret |= BLOCK_ERROR;
@@ -71,7 +71,7 @@ static int block_iterate_ind(blk_t *ind_block, blk_t ref_block,
 	if (ctx->flags & BLOCK_FLAG_APPEND) {
 		for (i = 0; i < limit; i++, ctx->bcount++, block_nr++) {
 			flags = (*ctx->func)(ctx->fs, block_nr, ctx->bcount,
-					     *ind_block, offset, 
+					     *ind_block, offset,
 					     ctx->priv_data);
 			changed	|= flags;
 			if (flags & BLOCK_ABORT) {
@@ -85,7 +85,7 @@ static int block_iterate_ind(blk_t *ind_block, blk_t ref_block,
 			if (*block_nr == 0)
 				continue;
 			flags = (*ctx->func)(ctx->fs, block_nr, ctx->bcount,
-					     *ind_block, offset, 
+					     *ind_block, offset,
 					     ctx->priv_data);
 			changed	|= flags;
 			if (flags & BLOCK_ABORT) {
@@ -109,7 +109,7 @@ static int block_iterate_ind(blk_t *ind_block, blk_t ref_block,
 				    ref_offset, ctx->priv_data);
 	return ret;
 }
-	
+
 static int block_iterate_dind(blk_t *dind_block, blk_t ref_block,
 			      int ref_offset, struct block_context *ctx)
 {
@@ -133,7 +133,7 @@ static int block_iterate_dind(blk_t *dind_block, blk_t ref_block,
 		ret |= BLOCK_ERROR;
 		return ret;
 	}
-	ctx->errcode = ext2fs_read_ind_block(ctx->fs, *dind_block, 
+	ctx->errcode = ext2fs_read_ind_block(ctx->fs, *dind_block,
 					     ctx->dind_buf);
 	if (ctx->errcode) {
 		ret |= BLOCK_ERROR;
@@ -185,7 +185,7 @@ static int block_iterate_dind(blk_t *dind_block, blk_t ref_block,
 				    ref_offset, ctx->priv_data);
 	return ret;
 }
-	
+
 static int block_iterate_tind(blk_t *tind_block, blk_t ref_block,
 			      int ref_offset, struct block_context *ctx)
 {
@@ -209,7 +209,7 @@ static int block_iterate_tind(blk_t *tind_block, blk_t ref_block,
 		ret |= BLOCK_ERROR;
 		return ret;
 	}
-	ctx->errcode = ext2fs_read_ind_block(ctx->fs, *tind_block, 
+	ctx->errcode = ext2fs_read_ind_block(ctx->fs, *tind_block,
 					     ctx->tind_buf);
 	if (ctx->errcode) {
 		ret |= BLOCK_ERROR;
@@ -259,10 +259,10 @@ static int block_iterate_tind(blk_t *tind_block, blk_t ref_block,
 		ret |= (*ctx->func)(ctx->fs, tind_block,
 				    BLOCK_COUNT_TIND, ref_block,
 				    ref_offset, ctx->priv_data);
-	
+
 	return ret;
 }
-	
+
 errcode_t ext2fs_block_iterate2(ext2_filsys fs,
 				ext2_ino_t ino,
 				int	flags,
@@ -338,7 +338,7 @@ errcode_t ext2fs_block_iterate2(ext2_filsys fs,
 				goto abort_exit;
 		}
 	}
-	
+
 	/*
 	 * Iterate over normal data blocks
 	 */
@@ -427,7 +427,7 @@ errcode_t ext2fs_block_iterate(ext2_filsys fs,
 			       void *priv_data)
 {
 	struct xlate xl;
-	
+
 	xl.real_private = priv_data;
 	xl.func = func;
 
diff --git a/e2fsprogs/ext2fs/bmap.c b/e2fsprogs/ext2fs/bmap.c
index e84004476..45d49f929 100644
--- a/e2fsprogs/ext2fs/bmap.c
+++ b/e2fsprogs/ext2fs/bmap.c
@@ -25,14 +25,14 @@
 #endif
 
 extern errcode_t ext2fs_bmap(ext2_filsys fs, ext2_ino_t ino,
-			     struct ext2_inode *inode, 
+			     struct ext2_inode *inode,
 			     char *block_buf, int bmap_flags,
 			     blk_t block, blk_t *phys_blk);
 
 #define inode_bmap(inode, nr) ((inode)->i_block[(nr)])
 
-static _BMAP_INLINE_ errcode_t block_ind_bmap(ext2_filsys fs, int flags, 
-					      blk_t ind, char *block_buf, 
+static _BMAP_INLINE_ errcode_t block_ind_bmap(ext2_filsys fs, int flags,
+					      blk_t ind, char *block_buf,
 					      int *blocks_alloc,
 					      blk_t nr, blk_t *ret_blk)
 {
@@ -95,17 +95,17 @@ static _BMAP_INLINE_ errcode_t block_ind_bmap(ext2_filsys fs, int flags,
 }
 
 static _BMAP_INLINE_ errcode_t block_dind_bmap(ext2_filsys fs, int flags,
-					       blk_t dind, char *block_buf, 
+					       blk_t dind, char *block_buf,
 					       int *blocks_alloc,
 					       blk_t nr, blk_t *ret_blk)
 {
 	blk_t		b;
 	errcode_t	retval;
 	blk_t		addr_per_block;
-	
+
 	addr_per_block = (blk_t) fs->blocksize >> 2;
 
-	retval = block_ind_bmap(fs, flags & ~BMAP_SET, dind, block_buf, 
+	retval = block_ind_bmap(fs, flags & ~BMAP_SET, dind, block_buf,
 				blocks_alloc, nr / addr_per_block, &b);
 	if (retval)
 		return retval;
@@ -115,17 +115,17 @@ static _BMAP_INLINE_ errcode_t block_dind_bmap(ext2_filsys fs, int flags,
 }
 
 static _BMAP_INLINE_ errcode_t block_tind_bmap(ext2_filsys fs, int flags,
-					       blk_t tind, char *block_buf, 
+					       blk_t tind, char *block_buf,
 					       int *blocks_alloc,
 					       blk_t nr, blk_t *ret_blk)
 {
 	blk_t		b;
 	errcode_t	retval;
 	blk_t		addr_per_block;
-	
+
 	addr_per_block = (blk_t) fs->blocksize >> 2;
 
-	retval = block_dind_bmap(fs, flags & ~BMAP_SET, tind, block_buf, 
+	retval = block_dind_bmap(fs, flags & ~BMAP_SET, tind, block_buf,
 				 blocks_alloc, nr / addr_per_block, &b);
 	if (retval)
 		return retval;
@@ -179,7 +179,7 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ext2_ino_t ino, struct ext2_inode *inode,
 
 		*phys_blk = inode_bmap(inode, block);
 		b = block ? inode_bmap(inode, block-1) : 0;
-		
+
 		if ((*phys_blk == 0) && (bmap_flags & BMAP_ALLOC)) {
 			retval = ext2fs_alloc_block(fs, b, block_buf, &b);
 			if (retval)
@@ -190,7 +190,7 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ext2_ino_t ino, struct ext2_inode *inode,
 		}
 		goto done;
 	}
-	
+
 	/* Indirect block */
 	block -= EXT2_NDIR_BLOCKS;
 	if (block < addr_per_block) {
@@ -203,17 +203,17 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ext2_ino_t ino, struct ext2_inode *inode,
 			}
 
 			b = inode_bmap(inode, EXT2_IND_BLOCK-1);
- 			retval = ext2fs_alloc_block(fs, b, block_buf, &b);
+			retval = ext2fs_alloc_block(fs, b, block_buf, &b);
 			if (retval)
 				goto done;
 			inode_bmap(inode, EXT2_IND_BLOCK) = b;
 			blocks_alloc++;
 		}
-		retval = block_ind_bmap(fs, bmap_flags, b, block_buf, 
+		retval = block_ind_bmap(fs, bmap_flags, b, block_buf,
 					&blocks_alloc, block, phys_blk);
 		goto done;
 	}
-	
+
 	/* Doubly indirect block  */
 	block -= addr_per_block;
 	if (block < addr_per_block * addr_per_block) {
@@ -226,13 +226,13 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ext2_ino_t ino, struct ext2_inode *inode,
 			}
 
 			b = inode_bmap(inode, EXT2_IND_BLOCK);
- 			retval = ext2fs_alloc_block(fs, b, block_buf, &b);
+			retval = ext2fs_alloc_block(fs, b, block_buf, &b);
 			if (retval)
 				goto done;
 			inode_bmap(inode, EXT2_DIND_BLOCK) = b;
 			blocks_alloc++;
 		}
-		retval = block_dind_bmap(fs, bmap_flags, b, block_buf, 
+		retval = block_dind_bmap(fs, bmap_flags, b, block_buf,
 					 &blocks_alloc, block, phys_blk);
 		goto done;
 	}
@@ -254,7 +254,7 @@ errcode_t ext2fs_bmap(ext2_filsys fs, ext2_ino_t ino, struct ext2_inode *inode,
 		inode_bmap(inode, EXT2_TIND_BLOCK) = b;
 		blocks_alloc++;
 	}
-	retval = block_tind_bmap(fs, bmap_flags, b, block_buf, 
+	retval = block_tind_bmap(fs, bmap_flags, b, block_buf,
 				 &blocks_alloc, block, phys_blk);
 done:
 	if (buf)
diff --git a/e2fsprogs/ext2fs/bmove.c b/e2fsprogs/ext2fs/bmove.c
index 0b2ebb183..fb319f8c3 100644
--- a/e2fsprogs/ext2fs/bmove.c
+++ b/e2fsprogs/ext2fs/bmove.c
@@ -1,6 +1,6 @@
 /*
  * bmove.c --- Move blocks around to make way for a particular
- * 	filesystem structure.
+ *	filesystem structure.
  *
  * Copyright (C) 1997 Theodore Ts'o.  This file may be redistributed
  * under the terms of the GNU Public License.
@@ -44,7 +44,7 @@ static int process_block(ext2_filsys fs, blk_t	*block_nr,
 	pb = (struct process_block_struct *) priv_data;
 	block = orig = *block_nr;
 	ret = 0;
-	
+
 	/*
 	 * Let's see if this is one which we need to relocate
 	 */
@@ -98,7 +98,7 @@ errcode_t ext2fs_move_blocks(ext2_filsys fs,
 	struct process_block_struct pb;
 	ext2_inode_scan	scan;
 	char		*block_buf;
-	
+
 	retval = ext2fs_open_inode_scan(fs, 0, &scan);
 	if (retval)
 		return retval;
@@ -107,7 +107,7 @@ errcode_t ext2fs_move_blocks(ext2_filsys fs,
 	pb.error = 0;
 	pb.alloc_map = alloc_map ? alloc_map : fs->block_map;
 	pb.flags = flags;
-	
+
 	retval = ext2fs_get_mem(fs->blocksize * 4, &block_buf);
 	if (retval)
 		return retval;
@@ -131,12 +131,12 @@ errcode_t ext2fs_move_blocks(ext2_filsys fs,
 	retval = ext2fs_get_next_inode(scan, &ino, &inode);
 	if (retval)
 		return retval;
-	
+
 	while (ino) {
 		if ((inode.i_links_count == 0) ||
 		    !ext2fs_inode_has_valid_blocks(&inode))
 			goto next;
-		
+
 		pb.ino = ino;
 		pb.inode = &inode;
 
diff --git a/e2fsprogs/ext2fs/brel.h b/e2fsprogs/ext2fs/brel.h
index be97243ca..a7f977658 100644
--- a/e2fsprogs/ext2fs/brel.h
+++ b/e2fsprogs/ext2fs/brel.h
@@ -1,6 +1,6 @@
 /*
  * brel.h
- * 
+ *
  * Copyright (C) 1996, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -47,7 +47,7 @@ struct ext2_block_relocation_table {
 	 * Initialize for iterating over the block relocation entries.
 	 */
 	errcode_t (*start_iter)(ext2_brel brel);
-	
+
 	/*
 	 * The iterator function for the inode relocation entries.
 	 * Returns an inode number of 0 when out of entries.
diff --git a/e2fsprogs/ext2fs/brel_ma.c b/e2fsprogs/ext2fs/brel_ma.c
index d422bb2e9..4dcfded37 100644
--- a/e2fsprogs/ext2fs/brel_ma.c
+++ b/e2fsprogs/ext2fs/brel_ma.c
@@ -1,6 +1,6 @@
 /*
  * brel_ma.c
- * 
+ *
  * Copyright (C) 1996, 1997 Theodore Ts'o.
  *
  * TODO: rewrite to not use a direct array!!!  (Fortunately this
@@ -48,7 +48,7 @@ errcode_t ext2fs_brel_memarray_create(char *name, blk_t max_block,
 {
 	ext2_brel		brel = 0;
 	errcode_t	retval;
-	struct brel_ma 	*ma = 0;
+	struct brel_ma	*ma = 0;
 	size_t		size;
 
 	*new_brel = 0;
@@ -61,18 +61,18 @@ errcode_t ext2fs_brel_memarray_create(char *name, blk_t max_block,
 	if (retval)
 		goto errout;
 	memset(brel, 0, sizeof(struct ext2_block_relocation_table));
-	
+
 	retval = ext2fs_get_mem(strlen(name)+1, &brel->name);
 	if (retval)
 		goto errout;
 	strcpy(brel->name, name);
-	
+
 	retval = ext2fs_get_mem(sizeof(struct brel_ma), &ma);
 	if (retval)
 		goto errout;
 	memset(ma, 0, sizeof(struct brel_ma));
 	brel->priv_data = ma;
-	
+
 	size = (size_t) (sizeof(struct ext2_block_relocate_entry) *
 			 (max_block+1));
 	retval = ext2fs_get_mem(size, &ma->entries);
@@ -91,7 +91,7 @@ errcode_t ext2fs_brel_memarray_create(char *name, blk_t max_block,
 	brel->move = bma_move;
 	brel->delete = bma_delete;
 	brel->free = bma_free;
-	
+
 	*new_brel = brel;
 	return 0;
 
@@ -103,7 +103,7 @@ errout:
 static errcode_t bma_put(ext2_brel brel, blk_t old,
 			struct ext2_block_relocate_entry *ent)
 {
-	struct brel_ma 	*ma;
+	struct brel_ma	*ma;
 
 	ma = brel->priv_data;
 	if (old > ma->max_block)
@@ -115,7 +115,7 @@ static errcode_t bma_put(ext2_brel brel, blk_t old,
 static errcode_t bma_get(ext2_brel brel, blk_t old,
 			struct ext2_block_relocate_entry *ent)
 {
-	struct brel_ma 	*ma;
+	struct brel_ma	*ma;
 
 	ma = brel->priv_data;
 	if (old > ma->max_block)
@@ -135,7 +135,7 @@ static errcode_t bma_start_iter(ext2_brel brel)
 static errcode_t bma_next(ext2_brel brel, blk_t *old,
 			  struct ext2_block_relocate_entry *ent)
 {
-	struct brel_ma 	*ma;
+	struct brel_ma	*ma;
 
 	ma = brel->priv_data;
 	while (++brel->current < ma->max_block) {
@@ -151,7 +151,7 @@ static errcode_t bma_next(ext2_brel brel, blk_t *old,
 
 static errcode_t bma_move(ext2_brel brel, blk_t old, blk_t new)
 {
-	struct brel_ma 	*ma;
+	struct brel_ma	*ma;
 
 	ma = brel->priv_data;
 	if ((old > ma->max_block) || (new > ma->max_block))
@@ -165,7 +165,7 @@ static errcode_t bma_move(ext2_brel brel, blk_t old, blk_t new)
 
 static errcode_t bma_delete(ext2_brel brel, blk_t old)
 {
-	struct brel_ma 	*ma;
+	struct brel_ma	*ma;
 
 	ma = brel->priv_data;
 	if (old > ma->max_block)
@@ -178,7 +178,7 @@ static errcode_t bma_delete(ext2_brel brel, blk_t old)
 
 static errcode_t bma_free(ext2_brel brel)
 {
-	struct brel_ma 	*ma;
+	struct brel_ma	*ma;
 
 	if (!brel)
 		return 0;
diff --git a/e2fsprogs/ext2fs/check_desc.c b/e2fsprogs/ext2fs/check_desc.c
index 2a754c7f6..eab8c7bc8 100644
--- a/e2fsprogs/ext2fs/check_desc.c
+++ b/e2fsprogs/ext2fs/check_desc.c
@@ -1,6 +1,6 @@
 /*
  * check_desc.c --- Check the group descriptors of an ext2 filesystem
- * 
+ *
  * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -61,7 +61,7 @@ errcode_t ext2fs_check_desc(ext2_filsys fs)
 		    ((fs->group_desc[i].bg_inode_table +
 		      fs->inode_blocks_per_group) >= next))
 			return EXT2_ET_GDESC_BAD_INODE_TABLE;
-		
+
 		block = next;
 	}
 	return 0;
diff --git a/e2fsprogs/ext2fs/closefs.c b/e2fsprogs/ext2fs/closefs.c
index 23e6332db..da0016b0e 100644
--- a/e2fsprogs/ext2fs/closefs.c
+++ b/e2fsprogs/ext2fs/closefs.c
@@ -1,6 +1,6 @@
 /*
  * closefs.c --- close an ext2 filesystem
- * 
+ *
  * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -45,7 +45,7 @@ int ext2fs_bg_has_super(ext2_filsys fs, int group_block)
 	return 0;
 }
 
-int ext2fs_super_and_bgd_loc(ext2_filsys fs, 
+int ext2fs_super_and_bgd_loc(ext2_filsys fs,
 			     dgrp_t group,
 			     blk_t *ret_super_blk,
 			     blk_t *ret_old_desc_blk,
@@ -63,7 +63,7 @@ int ext2fs_super_and_bgd_loc(ext2_filsys fs,
 	if (fs->super->s_feature_incompat & EXT2_FEATURE_INCOMPAT_META_BG)
 		old_desc_blocks = fs->super->s_first_meta_bg;
 	else
-		old_desc_blocks = 
+		old_desc_blocks =
 			fs->desc_blocks + fs->super->s_reserved_gdt_blocks;
 
 	if (group == fs->group_desc_count-1) {
@@ -100,7 +100,7 @@ int ext2fs_super_and_bgd_loc(ext2_filsys fs,
 			numblocks--;
 		}
 	}
-		
+
 	numblocks -= 2 + fs->inode_blocks_per_group;
 
 	if (ret_super_blk)
@@ -188,7 +188,7 @@ static errcode_t write_backup_super(ext2_filsys fs, dgrp_t group,
 				    struct ext2_super_block *super_shadow)
 {
 	dgrp_t	sgrp = group;
-	
+
 	if (sgrp > ((1 << 16) - 1))
 		sgrp = (1 << 16) - 1;
 #ifdef EXT2FS_ENABLE_SWAPFS
@@ -198,7 +198,7 @@ static errcode_t write_backup_super(ext2_filsys fs, dgrp_t group,
 #endif
 		fs->super->s_block_group_nr = sgrp;
 
-	return io_channel_write_blk(fs->io, group_block, -SUPERBLOCK_SIZE, 
+	return io_channel_write_blk(fs->io, group_block, -SUPERBLOCK_SIZE,
 				    super_shadow);
 }
 
@@ -217,7 +217,7 @@ errcode_t ext2fs_flush(ext2_filsys fs)
 	dgrp_t		j;
 	struct ext2_group_desc *s, *t;
 #endif
-	
+
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	fs_state = fs->super->s_state;
@@ -252,7 +252,7 @@ errcode_t ext2fs_flush(ext2_filsys fs)
 	super_shadow = fs->super;
 	group_shadow = fs->group_desc;
 #endif
-	
+
 	/*
 	 * If this is an external journal device, don't write out the
 	 * block group descriptors or any of the backup superblocks
@@ -289,7 +289,7 @@ errcode_t ext2fs_flush(ext2_filsys fs)
 		blk_t	super_blk, old_desc_blk, new_desc_blk;
 		int	meta_bg;
 
-		ext2fs_super_and_bgd_loc(fs, i, &super_blk, &old_desc_blk, 
+		ext2fs_super_and_bgd_loc(fs, i, &super_blk, &old_desc_blk,
 					 &new_desc_blk, &meta_bg);
 
 		if (!(fs->flags & EXT2_FLAG_MASTER_SB_ONLY) &&i && super_blk) {
@@ -300,7 +300,7 @@ errcode_t ext2fs_flush(ext2_filsys fs)
 		}
 		if (fs->flags & EXT2_FLAG_SUPER_ONLY)
 			continue;
-		if ((old_desc_blk) && 
+		if ((old_desc_blk) &&
 		    (!(fs->flags & EXT2_FLAG_MASTER_SB_ONLY) || (i == 0))) {
 			retval = io_channel_write_blk(fs->io,
 			      old_desc_blk, old_desc_blocks, group_ptr);
@@ -365,7 +365,7 @@ errout:
 errcode_t ext2fs_close(ext2_filsys fs)
 {
 	errcode_t	retval;
-	
+
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	if (fs->flags & EXT2_FLAG_DIRTY) {
diff --git a/e2fsprogs/ext2fs/cmp_bitmaps.c b/e2fsprogs/ext2fs/cmp_bitmaps.c
index 51cc3d0a5..fa45a4331 100644
--- a/e2fsprogs/ext2fs/cmp_bitmaps.c
+++ b/e2fsprogs/ext2fs/cmp_bitmaps.c
@@ -30,7 +30,7 @@ errcode_t ext2fs_compare_block_bitmap(ext2fs_block_bitmap bm1,
 				      ext2fs_block_bitmap bm2)
 {
 	blk_t	i;
-	
+
 	EXT2_CHECK_MAGIC(bm1, EXT2_ET_MAGIC_BLOCK_BITMAP);
 	EXT2_CHECK_MAGIC(bm2, EXT2_ET_MAGIC_BLOCK_BITMAP);
 
@@ -52,7 +52,7 @@ errcode_t ext2fs_compare_inode_bitmap(ext2fs_inode_bitmap bm1,
 				      ext2fs_inode_bitmap bm2)
 {
 	ext2_ino_t	i;
-	
+
 	EXT2_CHECK_MAGIC(bm1, EXT2_ET_MAGIC_INODE_BITMAP);
 	EXT2_CHECK_MAGIC(bm2, EXT2_ET_MAGIC_INODE_BITMAP);
 
diff --git a/e2fsprogs/ext2fs/dblist.c b/e2fsprogs/ext2fs/dblist.c
index d5833d728..0cf5698fa 100644
--- a/e2fsprogs/ext2fs/dblist.c
+++ b/e2fsprogs/ext2fs/dblist.c
@@ -1,13 +1,13 @@
 /*
  * dblist.c -- directory block list functions
- * 
+ *
  * Copyright 1997 by Theodore Ts'o
- * 
+ *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
  * License.
  * %End-Header%
- * 
+ *
  */
 
 #include <stdio.h>
@@ -33,7 +33,7 @@ errcode_t ext2fs_get_num_dirs(ext2_filsys fs, ext2_ino_t *ret_num_dirs)
 	ext2_ino_t	num_dirs, max_dirs;
 
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
-	
+
 	num_dirs = 0;
 	max_dirs = fs->super->s_inodes_per_group;
 	for (i = 0; i < fs->group_desc_count; i++) {
@@ -88,7 +88,7 @@ static errcode_t make_dblist(ext2_filsys fs, ext2_ino_t size, ext2_ino_t count,
 	retval = ext2fs_get_mem(len, &dblist->list);
 	if (retval)
 		goto cleanup;
-	
+
 	if (list)
 		memcpy(dblist->list, list, len);
 	else
@@ -155,10 +155,10 @@ errcode_t ext2fs_copy_dblist(ext2_dblist src, ext2_dblist *dest)
 errcode_t ext2fs_add_dir_block(ext2_dblist dblist, ext2_ino_t ino, blk_t blk,
 			       int blockcnt)
 {
-	struct ext2_db_entry 	*new_entry;
+	struct ext2_db_entry	*new_entry;
 	errcode_t		retval;
 	unsigned long		old_size;
-	
+
 	EXT2_CHECK_MAGIC(dblist, EXT2_ET_MAGIC_DBLIST);
 
 	if (dblist->count >= dblist->size) {
@@ -189,7 +189,7 @@ errcode_t ext2fs_set_dir_block(ext2_dblist dblist, ext2_ino_t ino, blk_t blk,
 			       int blockcnt)
 {
 	dgrp_t			i;
-	
+
 	EXT2_CHECK_MAGIC(dblist, EXT2_ET_MAGIC_DBLIST);
 
 	for (i=0; i < dblist->count; i++) {
@@ -225,7 +225,7 @@ errcode_t ext2fs_dblist_iterate(ext2_dblist dblist,
 {
 	ext2_ino_t	i;
 	int		ret;
-	
+
 	EXT2_CHECK_MAGIC(dblist, EXT2_ET_MAGIC_DBLIST);
 
 	if (!dblist->sorted)
@@ -247,7 +247,7 @@ static EXT2_QSORT_TYPE dir_block_cmp(const void *a, const void *b)
 
 	if (db_a->blk != db_b->blk)
 		return (int) (db_a->blk - db_b->blk);
-	
+
 	if (db_a->ino != db_b->ino)
 		return (int) (db_a->ino - db_b->ino);
 
diff --git a/e2fsprogs/ext2fs/dblist_dir.c b/e2fsprogs/ext2fs/dblist_dir.c
index f2e17a61d..20b1cde46 100644
--- a/e2fsprogs/ext2fs/dblist_dir.c
+++ b/e2fsprogs/ext2fs/dblist_dir.c
@@ -2,12 +2,12 @@
  * dblist_dir.c --- iterate by directory entry
  *
  * Copyright 1997 by Theodore Ts'o
- * 
+ *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
  * License.
  * %End-Header%
- * 
+ *
  */
 
 #include <stdio.h>
@@ -54,7 +54,7 @@ errcode_t ext2fs_dblist_dir_iterate(ext2_dblist dblist,
 	ctx.errcode = 0;
 
 	retval = ext2fs_dblist_iterate(dblist, db_dir_proc, &ctx);
-	
+
 	if (!block_buf)
 		ext2fs_free_mem(&ctx.buf);
 	if (retval)
@@ -69,7 +69,7 @@ static int db_dir_proc(ext2_filsys fs, struct ext2_db_entry *db_info,
 
 	ctx = (struct dir_context *) priv_data;
 	ctx->dir = db_info->ino;
-	
+
 	return ext2fs_process_dir_block(fs, &db_info->blk,
 					db_info->blockcnt, 0, 0, priv_data);
 }
diff --git a/e2fsprogs/ext2fs/dir_iterate.c b/e2fsprogs/ext2fs/dir_iterate.c
index 003c0a3bd..df820feaa 100644
--- a/e2fsprogs/ext2fs/dir_iterate.c
+++ b/e2fsprogs/ext2fs/dir_iterate.c
@@ -1,6 +1,6 @@
 /*
  * dir_iterate.c --- ext2fs directory iteration operations
- * 
+ *
  * Copyright (C) 1993, 1994, 1994, 1995, 1996, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -32,7 +32,7 @@
 static int ext2fs_validate_entry(char *buf, int offset, int final_offset)
 {
 	struct ext2_dir_entry *dirent;
-	
+
 	while (offset < final_offset) {
 		dirent = (struct ext2_dir_entry *)(buf + offset);
 		offset += dirent->rec_len;
@@ -59,13 +59,13 @@ errcode_t ext2fs_dir_iterate2(ext2_filsys fs,
 {
 	struct		dir_context	ctx;
 	errcode_t	retval;
-	
+
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	retval = ext2fs_check_directory(fs, dir);
 	if (retval)
 		return retval;
-	
+
 	ctx.dir = dir;
 	ctx.flags = flags;
 	if (block_buf)
@@ -106,7 +106,7 @@ static int xlate_func(ext2_ino_t dir EXT2FS_ATTR((unused)),
 	return (*xl->func)(dirent, offset, blocksize, buf, xl->real_private);
 }
 
-extern errcode_t ext2fs_dir_iterate(ext2_filsys fs, 
+extern errcode_t ext2fs_dir_iterate(ext2_filsys fs,
 			      ext2_ino_t dir,
 			      int flags,
 			      char *block_buf,
@@ -118,7 +118,7 @@ extern errcode_t ext2fs_dir_iterate(ext2_filsys fs,
 			      void *priv_data)
 {
 	struct xlate xl;
-	
+
 	xl.real_private = priv_data;
 	xl.func = func;
 
@@ -151,7 +151,7 @@ int ext2fs_process_dir_block(ext2_filsys fs,
 		return 0;
 
 	entry = blockcnt ? DIRENT_OTHER_FILE : DIRENT_DOT_FILE;
-	
+
 	ctx->errcode = ext2fs_read_dir_block(fs, *blocknr, ctx->buf);
 	if (ctx->errcode)
 		return BLOCK_ABORT;
@@ -177,18 +177,18 @@ int ext2fs_process_dir_block(ext2_filsys fs,
 				  ctx->priv_data);
 		if (entry < DIRENT_OTHER_FILE)
 			entry++;
-			
+
 		if (ret & DIRENT_CHANGED)
 			changed++;
 		if (ret & DIRENT_ABORT) {
 			do_abort++;
 			break;
 		}
-next:		
- 		if (next_real_entry == offset)
+next:
+		if (next_real_entry == offset)
 			next_real_entry += dirent->rec_len;
- 
- 		if (ctx->flags & DIRENT_FLAG_INCLUDE_REMOVED) {
+
+		if (ctx->flags & DIRENT_FLAG_INCLUDE_REMOVED) {
 			size = ((dirent->name_len & 0xFF) + 11) & ~3;
 
 			if (dirent->rec_len != size)  {
diff --git a/e2fsprogs/ext2fs/dirblock.c b/e2fsprogs/ext2fs/dirblock.c
index 5d66ad194..9f82b5002 100644
--- a/e2fsprogs/ext2fs/dirblock.c
+++ b/e2fsprogs/ext2fs/dirblock.c
@@ -1,6 +1,6 @@
 /*
  * dirblock.c --- directory block routines.
- * 
+ *
  * Copyright (C) 1995, 1996 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -28,9 +28,9 @@ errcode_t ext2fs_read_dir_block2(ext2_filsys fs, blk_t block,
 	unsigned int	name_len, rec_len;
 #ifdef EXT2FS_ENABLE_SWAPFS
 	unsigned int do_swap;
-#endif	
+#endif
 
- 	retval = io_channel_read_blk(fs->io, block, 1, buf);
+	retval = io_channel_read_blk(fs->io, block, 1, buf);
 	if (retval)
 		return retval;
 #ifdef EXT2FS_ENABLE_SWAPFS
@@ -110,16 +110,16 @@ errcode_t ext2fs_write_dir_block2(ext2_filsys fs, blk_t block,
 			dirent->rec_len = ext2fs_swab16(dirent->rec_len);
 			dirent->name_len = ext2fs_swab16(dirent->name_len);
 		}
-#ifdef WORDS_BIGENDIAN 
+#ifdef WORDS_BIGENDIAN
 		if (flags & EXT2_DIRBLOCK_V2_STRUCT)
 			dirent->name_len = ext2fs_swab16(dirent->name_len);
 #endif
 	}
- 	retval = io_channel_write_blk(fs->io, block, 1, buf);
+	retval = io_channel_write_blk(fs->io, block, 1, buf);
 	ext2fs_free_mem(&buf);
 	return retval;
 #else
- 	return io_channel_write_blk(fs->io, block, 1, (char *) inbuf);
+	return io_channel_write_blk(fs->io, block, 1, (char *) inbuf);
 #endif
 }
 
diff --git a/e2fsprogs/ext2fs/dirhash.c b/e2fsprogs/ext2fs/dirhash.c
index 4d18593f5..39678a628 100644
--- a/e2fsprogs/ext2fs/dirhash.c
+++ b/e2fsprogs/ext2fs/dirhash.c
@@ -2,7 +2,7 @@
  * dirhash.c -- Calculate the hash of a directory entry
  *
  * Copyright (c) 2001  Daniel Phillips
- * 
+ *
  * Copyright (c) 2002 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -25,7 +25,7 @@
  * (see Applied Cryptography, 2nd edition, p448).
  *
  * Jeremy Fitzhardinge <jeremy@zip.com.au> 1998
- * 
+ *
  * This code is made available under the terms of the GPL
  */
 #define DELTA 0x9E3779B9
@@ -37,10 +37,10 @@ static void TEA_transform(__u32 buf[4], __u32 const in[])
 	__u32	a = in[0], b = in[1], c = in[2], d = in[3];
 	int	n = 16;
 
-	do {							
-		sum += DELTA;					
-		b0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);	
-		b1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);	
+	do {
+		sum += DELTA;
+		b0 += ((b1 << 4)+a) ^ (b1+sum) ^ ((b1 >> 5)+b);
+		b1 += ((b0 << 4)+c) ^ (b0+sum) ^ ((b0 >> 5)+d);
 	} while(--n);
 
 	buf[0] += b0;
@@ -121,7 +121,7 @@ static ext2_dirhash_t dx_hack_hash (const char *name, int len)
 	__u32 hash0 = 0x12a3fe2d, hash1 = 0x37abe8f9;
 	while (len--) {
 		__u32 hash = hash1 + (hash0 ^ (*name++ * 7152373));
-		
+
 		if (hash & 0x80000000) hash -= 0x7fffffff;
 		hash1 = hash0;
 		hash0 = hash;
@@ -160,11 +160,11 @@ static void str2hashbuf(const char *msg, int len, __u32 *buf, int num)
  * Returns the hash of a filename.  If len is 0 and name is NULL, then
  * this function can be used to test whether or not a hash version is
  * supported.
- * 
+ *
  * The seed is an 4 longword (32 bits) "secret" which can be used to
  * uniquify a hash.  If the seed is all zero's, then some default seed
  * may be used.
- * 
+ *
  * A particular hash version specifies whether or not the seed is
  * represented, and whether or not the returned hash is 32 bits or 64
  * bits.  32 bit hashes will return 0 for the minor hash.
@@ -178,7 +178,7 @@ errcode_t ext2fs_dirhash(int version, const char *name, int len,
 	__u32	minor_hash = 0;
 	const char	*p;
 	int		i;
-	__u32 		in[8], buf[4];
+	__u32		in[8], buf[4];
 
 	/* Initialize the default seed for the hash checksum functions */
 	buf[0] = 0x67452301;
@@ -195,7 +195,7 @@ errcode_t ext2fs_dirhash(int version, const char *name, int len,
 		if (i < 4)
 			memcpy(buf, seed, sizeof(buf));
 	}
-		
+
 	switch (version) {
 	case EXT2_HASH_LEGACY:
 		hash = dx_hack_hash(name, len);
diff --git a/e2fsprogs/ext2fs/dupfs.c b/e2fsprogs/ext2fs/dupfs.c
index f8919c222..2009ef701 100644
--- a/e2fsprogs/ext2fs/dupfs.c
+++ b/e2fsprogs/ext2fs/dupfs.c
@@ -1,6 +1,6 @@
 /*
  * dupfs.c --- duplicate a ext2 filesystem handle
- * 
+ *
  * Copyright (C) 1997, 1998, 2001, 2003, 2005 by Theodore Ts'o.
  *
  * %Begin-Header%
@@ -25,7 +25,7 @@ errcode_t ext2fs_dup_handle(ext2_filsys src, ext2_filsys *dest)
 	errcode_t	retval;
 
 	EXT2_CHECK_MAGIC(src, EXT2_ET_MAGIC_EXT2FS_FILSYS);
-	
+
 	retval = ext2fs_get_mem(sizeof(struct struct_ext2_filsys), &fs);
 	if (retval)
 		return retval;
@@ -91,6 +91,6 @@ errcode_t ext2fs_dup_handle(ext2_filsys src, ext2_filsys *dest)
 errout:
 	ext2fs_free(fs);
 	return retval;
-	
+
 }
 
diff --git a/e2fsprogs/ext2fs/e2image.h b/e2fsprogs/ext2fs/e2image.h
index e12b7d69b..c05d43e22 100644
--- a/e2fsprogs/ext2fs/e2image.h
+++ b/e2fsprogs/ext2fs/e2image.h
@@ -1,10 +1,10 @@
 /*
  * e2image.h --- header file describing the ext2 image format
- * 
+ *
  * Copyright (C) 2000 Theodore Ts'o.
  *
  * Note: this uses the POSIX IO interfaces, unlike most of the other
- * functions in this library.  So sue me.  
+ * functions in this library.  So sue me.
  *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
@@ -24,7 +24,7 @@ struct ext2_image_hdr {
 	char	fs_uuid[16];	/* UUID of filesystem */
 	__u32	fs_blocksize;	/* Block size of the filesystem */
 	__u32	fs_reserved[8];
-	
+
 	__u32	image_device;	/* Device number of image file */
 	__u32	image_inode;	/* Inode number of image file */
 	__u32	image_time;	/* Time of image creation */
@@ -37,15 +37,15 @@ struct ext2_image_hdr {
 	__u32	offset_reserved[8];
 };
 
-	
-	
-	
-	
-	
-	
-	
-	
-	
-	
-	
-	
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/e2fsprogs/ext2fs/expanddir.c b/e2fsprogs/ext2fs/expanddir.c
index 10a5149cf..c148b93aa 100644
--- a/e2fsprogs/ext2fs/expanddir.c
+++ b/e2fsprogs/ext2fs/expanddir.c
@@ -1,6 +1,6 @@
 /*
  * expand.c --- expand an ext2fs directory
- * 
+ *
  * Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999  Theodore Ts'o.
  *
  * %Begin-Header%
@@ -36,7 +36,7 @@ static int expand_dir_proc(ext2_filsys	fs,
 	static blk_t	last_blk = 0;
 	char		*block;
 	errcode_t	retval;
-	
+
 	if (*blocknr) {
 		last_blk = *blocknr;
 		return 0;
@@ -62,7 +62,7 @@ static int expand_dir_proc(ext2_filsys	fs,
 		}
 		memset(block, 0, fs->blocksize);
 		retval = io_channel_write_blk(fs->io, new_blk, 1, block);
-	}	
+	}
 	if (retval) {
 		es->err = retval;
 		return BLOCK_ABORT;
@@ -83,7 +83,7 @@ errcode_t ext2fs_expand_dir(ext2_filsys fs, ext2_ino_t dir)
 	errcode_t	retval;
 	struct expand_dir_struct es;
 	struct ext2_inode	inode;
-	
+
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	if (!(fs->flags & EXT2_FLAG_RW))
@@ -95,11 +95,11 @@ errcode_t ext2fs_expand_dir(ext2_filsys fs, ext2_ino_t dir)
 	retval = ext2fs_check_directory(fs, dir);
 	if (retval)
 		return retval;
-	
+
 	es.done = 0;
 	es.err = 0;
 	es.newblocks = 0;
-	
+
 	retval = ext2fs_block_iterate2(fs, dir, BLOCK_FLAG_APPEND,
 				       0, expand_dir_proc, &es);
 
@@ -114,7 +114,7 @@ errcode_t ext2fs_expand_dir(ext2_filsys fs, ext2_ino_t dir)
 	retval = ext2fs_read_inode(fs, dir, &inode);
 	if (retval)
 		return retval;
-	
+
 	inode.i_size += fs->blocksize;
 	inode.i_blocks += (fs->blocksize / 512) * es.newblocks;
 
diff --git a/e2fsprogs/ext2fs/ext2_fs.h b/e2fsprogs/ext2fs/ext2_fs.h
index 7a9890320..400587324 100644
--- a/e2fsprogs/ext2fs/ext2_fs.h
+++ b/e2fsprogs/ext2fs/ext2_fs.h
@@ -231,9 +231,9 @@ struct ext2_dx_countlimit {
 #define EXT2_IMAGIC_FL			0x00002000
 #define EXT3_JOURNAL_DATA_FL		0x00004000 /* file data should be journaled */
 #define EXT2_NOTAIL_FL			0x00008000 /* file tail should not be merged */
-#define EXT2_DIRSYNC_FL 		0x00010000 /* Synchronous directory modifications */
+#define EXT2_DIRSYNC_FL			0x00010000 /* Synchronous directory modifications */
 #define EXT2_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
-#define EXT3_EXTENTS_FL 		0x00080000 /* Inode uses extents */
+#define EXT3_EXTENTS_FL			0x00080000 /* Inode uses extents */
 #define EXT2_RESERVED_FL		0x80000000 /* reserved for ext2 lib */
 
 #define EXT2_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */
@@ -501,12 +501,12 @@ struct ext2_super_block {
 	__u32	s_last_orphan;		/* start of list of inodes to delete */
 	__u32	s_hash_seed[4];		/* HTREE hash seed */
 	__u8	s_def_hash_version;	/* Default hash version to use */
-	__u8	s_jnl_backup_type; 	/* Default type of journal backup */
+	__u8	s_jnl_backup_type;	/* Default type of journal backup */
 	__u16	s_reserved_word_pad;
 	__u32	s_default_mount_opts;
 	__u32	s_first_meta_bg;	/* First metablock group */
 	__u32	s_mkfs_time;		/* When the filesystem was created */
-	__u32	s_jnl_blocks[17]; 	/* Backup of the journal inode */
+	__u32	s_jnl_blocks[17];	/* Backup of the journal inode */
 	__u32	s_reserved[172];	/* Padding to the end of the block */
 };
 
@@ -585,7 +585,7 @@ struct ext2_super_block {
 #define EXT2_DEFM_XATTR_USER	0x0004
 #define EXT2_DEFM_ACL		0x0008
 #define EXT2_DEFM_UID16		0x0010
-#define EXT3_DEFM_JMODE		0x0060 
+#define EXT3_DEFM_JMODE		0x0060
 #define EXT3_DEFM_JMODE_DATA	0x0020
 #define EXT3_DEFM_JMODE_ORDERED	0x0040
 #define EXT3_DEFM_JMODE_WBACK	0x0060
diff --git a/e2fsprogs/ext2fs/ext2fs.h b/e2fsprogs/ext2fs/ext2fs.h
index e2e86579b..7d2a43695 100644
--- a/e2fsprogs/ext2fs/ext2fs.h
+++ b/e2fsprogs/ext2fs/ext2fs.h
@@ -1,6 +1,6 @@
 /*
  * ext2fs.h --- ext2fs
- * 
+ *
  * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -46,7 +46,7 @@ extern "C" {
  * 1032 bytes long).
  */
 #define SUPERBLOCK_OFFSET	1024
-#define SUPERBLOCK_SIZE 	1024
+#define SUPERBLOCK_SIZE		1024
 
 /*
  * The last ext2fs revision level that this version of the library is
@@ -87,7 +87,7 @@ typedef struct struct_ext2_filsys *ext2_filsys;
 
 struct ext2fs_struct_generic_bitmap {
 	errcode_t	magic;
-	ext2_filsys 	fs;
+	ext2_filsys	fs;
 	__u32		start, end;
 	__u32		real_end;
 	char	*	description;
@@ -96,8 +96,8 @@ struct ext2fs_struct_generic_bitmap {
 	__u32		reserved[7];
 };
 
-#define EXT2FS_MARK_ERROR 	0
-#define EXT2FS_UNMARK_ERROR 	1
+#define EXT2FS_MARK_ERROR	0
+#define EXT2FS_UNMARK_ERROR	1
 #define EXT2FS_TEST_ERROR	2
 
 typedef struct ext2fs_struct_generic_bitmap *ext2fs_generic_bitmap;
@@ -194,7 +194,7 @@ struct struct_ext2_filsys {
 	io_channel			io;
 	int				flags;
 	char *				device_name;
-	struct ext2_super_block	* 	super;
+	struct ext2_super_block	*	super;
 	unsigned int			blocksize;
 	int				fragsize;
 	dgrp_t				group_desc_count;
@@ -250,7 +250,7 @@ struct struct_ext2_filsys {
  * This is used by ext2fs_expand_dir() to be able to add a new block
  * to an inode.  It can also be used for programs that want to be able
  * to deal with files that contain "holes".
- * 
+ *
  * BLOCK_FLAG_TRAVERSE indicates that the iterator function for the
  * indirect, doubly indirect, etc. blocks should be called after all
  * of the blocks containined in the indirect blocks are processed.
@@ -282,7 +282,7 @@ struct struct_ext2_filsys {
 /*
  * Flags for ext2fs_move_blocks
  */
-#define EXT2_BMOVE_GET_DBLIST	0x0001	
+#define EXT2_BMOVE_GET_DBLIST	0x0001
 #define EXT2_BMOVE_DEBUG	0x0002
 #endif
 
@@ -457,7 +457,7 @@ extern errcode_t ext2fs_alloc_block(ext2_filsys fs, blk_t goal,
 				    char *block_buf, blk_t *ret);
 
 /* alloc_sb.c */
-extern int ext2fs_reserve_super_and_bgd(ext2_filsys fs, 
+extern int ext2fs_reserve_super_and_bgd(ext2_filsys fs,
 					dgrp_t group,
 					ext2fs_block_bitmap bmap);
 
@@ -567,7 +567,7 @@ errcode_t ext2fs_block_iterate2(ext2_filsys fs,
 
 /* bmap.c */
 extern errcode_t ext2fs_bmap(ext2_filsys fs, ext2_ino_t ino,
-			     struct ext2_inode *inode, 
+			     struct ext2_inode *inode,
 			     char *block_buf, int bmap_flags,
 			     blk_t block, blk_t *phys_blk);
 
@@ -587,7 +587,7 @@ extern errcode_t ext2fs_check_desc(ext2_filsys fs);
 extern errcode_t ext2fs_close(ext2_filsys fs);
 extern errcode_t ext2fs_flush(ext2_filsys fs);
 extern int ext2fs_bg_has_super(ext2_filsys fs, int group_block);
-extern int ext2fs_super_and_bgd_loc(ext2_filsys fs, 
+extern int ext2fs_super_and_bgd_loc(ext2_filsys fs,
 				    dgrp_t group,
 				    blk_t *ret_super_blk,
 				    blk_t *ret_old_desc_blk,
@@ -652,7 +652,7 @@ extern errcode_t ext2fs_dirhash(int version, const char *name, int len,
 
 
 /* dir_iterate.c */
-extern errcode_t ext2fs_dir_iterate(ext2_filsys fs, 
+extern errcode_t ext2fs_dir_iterate(ext2_filsys fs,
 			      ext2_ino_t dir,
 			      int flags,
 			      char *block_buf,
@@ -662,7 +662,7 @@ extern errcode_t ext2fs_dir_iterate(ext2_filsys fs,
 					  char	*buf,
 					  void	*priv_data),
 			      void *priv_data);
-extern errcode_t ext2fs_dir_iterate2(ext2_filsys fs, 
+extern errcode_t ext2fs_dir_iterate2(ext2_filsys fs,
 			      ext2_ino_t dir,
 			      int flags,
 			      char *block_buf,
@@ -751,10 +751,10 @@ extern errcode_t ext2fs_initialize(const char *name, int flags,
 
 /* icount.c */
 extern void ext2fs_free_icount(ext2_icount_t icount);
-extern errcode_t ext2fs_create_icount2(ext2_filsys fs, int flags, 
+extern errcode_t ext2fs_create_icount2(ext2_filsys fs, int flags,
 				       unsigned int size,
 				       ext2_icount_t hint, ext2_icount_t *ret);
-extern errcode_t ext2fs_create_icount(ext2_filsys fs, int flags, 
+extern errcode_t ext2fs_create_icount(ext2_filsys fs, int flags,
 				      unsigned int size,
 				      ext2_icount_t *ret);
 extern errcode_t ext2fs_icount_fetch(ext2_icount_t icount, ext2_ino_t ino,
@@ -770,9 +770,9 @@ errcode_t ext2fs_icount_validate(ext2_icount_t icount, FILE *);
 
 /* inode.c */
 extern errcode_t ext2fs_flush_icache(ext2_filsys fs);
-extern errcode_t ext2fs_get_next_inode_full(ext2_inode_scan scan, 
+extern errcode_t ext2fs_get_next_inode_full(ext2_inode_scan scan,
 					    ext2_ino_t *ino,
-					    struct ext2_inode *inode, 
+					    struct ext2_inode *inode,
 					    int bufsize);
 extern errcode_t ext2fs_open_inode_scan(ext2_filsys fs, int buffer_blocks,
 				  ext2_inode_scan *ret_scan);
@@ -791,12 +791,12 @@ extern void ext2fs_set_inode_callback
 extern int ext2fs_inode_scan_flags(ext2_inode_scan scan, int set_flags,
 				   int clear_flags);
 extern errcode_t ext2fs_read_inode_full(ext2_filsys fs, ext2_ino_t ino,
-					struct ext2_inode * inode, 
+					struct ext2_inode * inode,
 					int bufsize);
 extern errcode_t ext2fs_read_inode (ext2_filsys fs, ext2_ino_t ino,
 			    struct ext2_inode * inode);
 extern errcode_t ext2fs_write_inode_full(ext2_filsys fs, ext2_ino_t ino,
-					 struct ext2_inode * inode, 
+					 struct ext2_inode * inode,
 					 int bufsize);
 extern errcode_t ext2fs_write_inode(ext2_filsys fs, ext2_ino_t ino,
 			    struct ext2_inode * inode);
@@ -807,12 +807,12 @@ extern errcode_t ext2fs_check_directory(ext2_filsys fs, ext2_ino_t ino);
 
 /* inode_io.c */
 extern io_manager inode_io_manager;
-extern errcode_t ext2fs_inode_io_intern(ext2_filsys fs, ext2_ino_t ino, 
+extern errcode_t ext2fs_inode_io_intern(ext2_filsys fs, ext2_ino_t ino,
 					char **name);
 extern errcode_t ext2fs_inode_io_intern2(ext2_filsys fs, ext2_ino_t ino,
 					 struct ext2_inode *inode,
 					 char **name);
-	
+
 /* ismounted.c */
 extern errcode_t ext2fs_check_if_mounted(const char *file, int *mount_flags);
 extern errcode_t ext2fs_check_mount_point(const char *device, int *mount_flags,
@@ -852,11 +852,11 @@ extern errcode_t ext2fs_add_journal_inode(ext2_filsys fs, blk_t size,
 extern errcode_t ext2fs_open(const char *name, int flags, int superblock,
 			     unsigned int block_size, io_manager manager,
 			     ext2_filsys *ret_fs);
-extern errcode_t ext2fs_open2(const char *name, const char *io_options, 
-			      int flags, int superblock, 
+extern errcode_t ext2fs_open2(const char *name, const char *io_options,
+			      int flags, int superblock,
 			      unsigned int block_size, io_manager manager,
 			      ext2_filsys *ret_fs);
-extern blk_t ext2fs_descriptor_block_loc(ext2_filsys fs, blk_t group_block, 
+extern blk_t ext2fs_descriptor_block_loc(ext2_filsys fs, blk_t group_block,
 					 dgrp_t i);
 errcode_t ext2fs_get_data_io(ext2_filsys fs, io_channel *old_io);
 errcode_t ext2fs_set_data_io(ext2_filsys fs, io_channel new_io);
@@ -877,14 +877,14 @@ extern errcode_t ext2fs_read_bb_inode(ext2_filsys fs,
 				      ext2_badblocks_list *bb_list);
 
 /* read_bb_file.c */
-extern errcode_t ext2fs_read_bb_FILE2(ext2_filsys fs, FILE *f, 
+extern errcode_t ext2fs_read_bb_FILE2(ext2_filsys fs, FILE *f,
 				      ext2_badblocks_list *bb_list,
 				      void *priv_data,
 				      void (*invalid)(ext2_filsys fs,
 						      blk_t blk,
 						      char *badstr,
 						      void *priv_data));
-extern errcode_t ext2fs_read_bb_FILE(ext2_filsys fs, FILE *f, 
+extern errcode_t ext2fs_read_bb_FILE(ext2_filsys fs, FILE *f,
 				     ext2_badblocks_list *bb_list,
 				     void (*invalid)(ext2_filsys fs,
 						     blk_t blk));
@@ -904,7 +904,7 @@ extern errcode_t ext2fs_copy_bitmap(ext2fs_generic_bitmap src,
 				    ext2fs_generic_bitmap *dest);
 
 /* swapfs.c */
-extern void ext2fs_swap_ext_attr(char *to, char *from, int bufsize, 
+extern void ext2fs_swap_ext_attr(char *to, char *from, int bufsize,
 				 int has_header);
 extern void ext2fs_swap_super(struct ext2_super_block * super);
 extern void ext2fs_swap_group_desc(struct ext2_group_desc *gdp);
diff --git a/e2fsprogs/ext2fs/ext2fsP.h b/e2fsprogs/ext2fs/ext2fsP.h
index eea32d632..90b081232 100644
--- a/e2fsprogs/ext2fs/ext2fsP.h
+++ b/e2fsprogs/ext2fs/ext2fsP.h
@@ -1,6 +1,6 @@
 /*
  * ext2fsP.h --- private header file for ext2 library
- * 
+ *
  * Copyright (C) 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -78,7 +78,7 @@ struct ext2_inode_cache_ent {
 
 /* Function prototypes */
 
-extern int ext2fs_process_dir_block(ext2_filsys  	fs,
+extern int ext2fs_process_dir_block(ext2_filsys		fs,
 				    blk_t		*blocknr,
 				    e2_blkcnt_t		blockcnt,
 				    blk_t		ref_block,
diff --git a/e2fsprogs/ext2fs/ext2fs_inline.c b/e2fsprogs/ext2fs/ext2fs_inline.c
index f14e7b22f..2fa9a9ed2 100644
--- a/e2fsprogs/ext2fs/ext2fs_inline.c
+++ b/e2fsprogs/ext2fs/ext2fs_inline.c
@@ -1,6 +1,6 @@
 /*
  * ext2fs.h --- ext2fs
- * 
+ *
  * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -36,7 +36,7 @@ errcode_t ext2fs_free_mem(void *ptr)
 	*pp = 0;
 	return 0;
 }
-	
+
 /*
  *  Resize memory
  */
@@ -154,7 +154,7 @@ blk_t ext2fs_inode_data_blocks(ext2_filsys fs,
 					struct ext2_inode *inode)
 {
        return inode->i_blocks -
-              (inode->i_file_acl ? fs->blocksize >> 9 : 0);
+	      (inode->i_file_acl ? fs->blocksize >> 9 : 0);
 }
 
 
@@ -179,7 +179,7 @@ __u32 ext2fs_swab32(__u32 val)
 int ext2fs_find_first_bit_set(void * addr, unsigned size)
 {
 	char	*cp = (unsigned char *) addr;
-	int 	res = 0, d0;
+	int	res = 0, d0;
 
 	if (!size)
 		return 0;
@@ -191,7 +191,7 @@ int ext2fs_find_first_bit_set(void * addr, unsigned size)
 	d0 = ffs(*cp);
 	if (d0 == 0)
 		return size;
-	
+
 	return res + d0 - 1;
 }
 
@@ -199,10 +199,10 @@ int ext2fs_find_next_bit_set (void * addr, int size, int offset)
 {
 	unsigned char * p;
 	int set = 0, bit = offset & 7, res = 0, d0;
-	
+
 	res = offset >> 3;
 	p = ((unsigned char *) addr) + res;
-	
+
 	if (bit) {
 		set = ffs(*p & ~((1 << bit) - 1));
 		if (set)
@@ -245,35 +245,35 @@ int ext2fs_mark_block_bitmap(ext2fs_block_bitmap bitmap,
 int ext2fs_unmark_block_bitmap(ext2fs_block_bitmap bitmap,
 					 blk_t block)
 {
-	return ext2fs_unmark_generic_bitmap((ext2fs_generic_bitmap) bitmap, 
+	return ext2fs_unmark_generic_bitmap((ext2fs_generic_bitmap) bitmap,
 					    block);
 }
 
 int ext2fs_test_block_bitmap(ext2fs_block_bitmap bitmap,
 				       blk_t block)
 {
-	return ext2fs_test_generic_bitmap((ext2fs_generic_bitmap) bitmap, 
+	return ext2fs_test_generic_bitmap((ext2fs_generic_bitmap) bitmap,
 					  block);
 }
 
 int ext2fs_mark_inode_bitmap(ext2fs_inode_bitmap bitmap,
 				       ext2_ino_t inode)
 {
-	return ext2fs_mark_generic_bitmap((ext2fs_generic_bitmap) bitmap, 
+	return ext2fs_mark_generic_bitmap((ext2fs_generic_bitmap) bitmap,
 					  inode);
 }
 
 int ext2fs_unmark_inode_bitmap(ext2fs_inode_bitmap bitmap,
 					 ext2_ino_t inode)
 {
-	return ext2fs_unmark_generic_bitmap((ext2fs_generic_bitmap) bitmap, 
+	return ext2fs_unmark_generic_bitmap((ext2fs_generic_bitmap) bitmap,
 				     inode);
 }
 
 int ext2fs_test_inode_bitmap(ext2fs_inode_bitmap bitmap,
 				       ext2_ino_t inode)
 {
-	return ext2fs_test_generic_bitmap((ext2fs_generic_bitmap) bitmap, 
+	return ext2fs_test_generic_bitmap((ext2fs_generic_bitmap) bitmap,
 					  inode);
 }
 
@@ -286,7 +286,7 @@ void ext2fs_fast_mark_block_bitmap(ext2fs_block_bitmap bitmap,
 				   bitmap->description);
 		return;
 	}
-#endif	
+#endif
 	ext2fs_set_bit(block - bitmap->start, bitmap->bitmap);
 }
 
@@ -415,7 +415,7 @@ void ext2fs_mark_block_bitmap_range(ext2fs_block_bitmap bitmap,
 					     blk_t block, int num)
 {
 	int	i;
-	
+
 	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
 		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_MARK, block,
 				   bitmap->description);
@@ -429,14 +429,14 @@ void ext2fs_fast_mark_block_bitmap_range(ext2fs_block_bitmap bitmap,
 						  blk_t block, int num)
 {
 	int	i;
-	
+
 #ifdef EXT2FS_DEBUG_FAST_OPS
 	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
 		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_MARK, block,
 				   bitmap->description);
 		return;
 	}
-#endif	
+#endif
 	for (i=0; i < num; i++)
 		ext2fs_set_bit(block + i - bitmap->start, bitmap->bitmap);
 }
@@ -445,7 +445,7 @@ void ext2fs_unmark_block_bitmap_range(ext2fs_block_bitmap bitmap,
 					       blk_t block, int num)
 {
 	int	i;
-	
+
 	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
 		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_UNMARK, block,
 				   bitmap->description);
@@ -459,14 +459,14 @@ void ext2fs_fast_unmark_block_bitmap_range(ext2fs_block_bitmap bitmap,
 						    blk_t block, int num)
 {
 	int	i;
-	
+
 #ifdef EXT2FS_DEBUG_FAST_OPS
 	if ((block < bitmap->start) || (block+num-1 > bitmap->end)) {
 		ext2fs_warn_bitmap(EXT2_ET_BAD_BLOCK_UNMARK, block,
 				   bitmap->description);
 		return;
 	}
-#endif	
+#endif
 	for (i=0; i < num; i++)
 		ext2fs_clear_bit(block + i - bitmap->start, bitmap->bitmap);
 }
diff --git a/e2fsprogs/ext2fs/ext_attr.c b/e2fsprogs/ext2fs/ext_attr.c
index 08211c316..10b8bfd9d 100644
--- a/e2fsprogs/ext2fs/ext_attr.c
+++ b/e2fsprogs/ext2fs/ext_attr.c
@@ -1,6 +1,6 @@
 /*
  * ext_attr.c --- extended attribute blocks
- * 
+ *
  * Copyright (C) 2001 Andreas Gruenbacher, <a.gruenbacher@computer.org>
  *
  * Copyright (C) 2002 Theodore Ts'o.
@@ -27,7 +27,7 @@ errcode_t ext2fs_read_ext_attr(ext2_filsys fs, blk_t block, void *buf)
 {
 	errcode_t	retval;
 
- 	retval = io_channel_read_blk(fs->io, block, 1, buf);
+	retval = io_channel_read_blk(fs->io, block, 1, buf);
 	if (retval)
 		return retval;
 #ifdef EXT2FS_ENABLE_SWAPFS
@@ -55,7 +55,7 @@ errcode_t ext2fs_write_ext_attr(ext2_filsys fs, blk_t block, void *inbuf)
 	} else
 #endif
 		write_buf = (char *) inbuf;
- 	retval = io_channel_write_blk(fs->io, block, 1, write_buf);
+	retval = io_channel_write_blk(fs->io, block, 1, write_buf);
 	if (buf)
 		ext2fs_free_mem(&buf);
 	if (!retval)
diff --git a/e2fsprogs/ext2fs/fileio.c b/e2fsprogs/ext2fs/fileio.c
index 3e42cbc32..669e80c65 100644
--- a/e2fsprogs/ext2fs/fileio.c
+++ b/e2fsprogs/ext2fs/fileio.c
@@ -1,6 +1,6 @@
 /*
  * fileio.c --- Simple file I/O routines
- * 
+ *
  * Copyright (C) 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -20,14 +20,14 @@
 
 struct ext2_file {
 	errcode_t		magic;
-	ext2_filsys 		fs;
+	ext2_filsys		fs;
 	ext2_ino_t		ino;
 	struct ext2_inode	inode;
-	int 			flags;
+	int			flags;
 	__u64			pos;
 	blk_t			blockno;
 	blk_t			physblock;
-	char 			*buf;
+	char			*buf;
 };
 
 #define BMAP_BUFFER (file->buf + fs->blocksize)
@@ -36,7 +36,7 @@ errcode_t ext2fs_file_open2(ext2_filsys fs, ext2_ino_t ino,
 			    struct ext2_inode *inode,
 			    int flags, ext2_file_t *ret)
 {
-	ext2_file_t 	file;
+	ext2_file_t	file;
 	errcode_t	retval;
 
 	/*
@@ -50,7 +50,7 @@ errcode_t ext2fs_file_open2(ext2_filsys fs, ext2_ino_t ino,
 	retval = ext2fs_get_mem(sizeof(struct ext2_file), &file);
 	if (retval)
 		return retval;
-	
+
 	memset(file, 0, sizeof(struct ext2_file));
 	file->magic = EXT2_ET_MAGIC_EXT2_FILE;
 	file->fs = fs;
@@ -64,14 +64,14 @@ errcode_t ext2fs_file_open2(ext2_filsys fs, ext2_ino_t ino,
 		if (retval)
 			goto fail;
 	}
-	
+
 	retval = ext2fs_get_mem(fs->blocksize * 3, &file->buf);
 	if (retval)
 		goto fail;
 
 	*ret = file;
 	return 0;
-	
+
 fail:
 	if (file->buf)
 		ext2fs_free_mem(&file->buf);
@@ -103,7 +103,7 @@ errcode_t ext2fs_file_flush(ext2_file_t file)
 {
 	errcode_t	retval;
 	ext2_filsys fs;
-	
+
 	EXT2_CHECK_MAGIC(file, EXT2_ET_MAGIC_EXT2_FILE);
 	fs = file->fs;
 
@@ -176,7 +176,7 @@ static errcode_t load_buffer(ext2_file_t file, int dontfill)
 		if (!dontfill) {
 			if (file->physblock) {
 				retval = io_channel_read_blk(fs->io,
-							     file->physblock, 
+							     file->physblock,
 							     1, file->buf);
 				if (retval)
 					return retval;
@@ -187,16 +187,16 @@ static errcode_t load_buffer(ext2_file_t file, int dontfill)
 	}
 	return 0;
 }
-	
+
 
 errcode_t ext2fs_file_close(ext2_file_t file)
 {
 	errcode_t	retval;
-	
+
 	EXT2_CHECK_MAGIC(file, EXT2_ET_MAGIC_EXT2_FILE);
 
 	retval = ext2fs_file_flush(file);
-	
+
 	if (file->buf)
 		ext2fs_free_mem(&file->buf);
 	ext2fs_free_mem(&file);
@@ -232,14 +232,14 @@ errcode_t ext2fs_file_read(ext2_file_t file, void *buf,
 		left = EXT2_I_SIZE(&file->inode) - file->pos ;
 		if (c > left)
 			c = left;
-	
+
 		memcpy(ptr, file->buf+start, c);
 		file->pos += c;
 		ptr += c;
 		count += c;
 		wanted -= c;
 	}
-	
+
 fail:
 	if (got)
 		*got = count;
@@ -265,7 +265,7 @@ errcode_t ext2fs_file_write(ext2_file_t file, const void *buf,
 		retval = sync_buffer_position(file);
 		if (retval)
 			goto fail;
-		
+
 		start = file->pos % fs->blocksize;
 		c = fs->blocksize - start;
 		if (c > nbytes)
@@ -286,7 +286,7 @@ errcode_t ext2fs_file_write(ext2_file_t file, const void *buf,
 		count += c;
 		nbytes -= c;
 	}
-	
+
 fail:
 	if (written)
 		*written = count;
@@ -318,7 +318,7 @@ errcode_t ext2fs_file_lseek(ext2_file_t file, ext2_off_t offset,
 {
 	__u64		loffset, ret_loffset;
 	errcode_t	retval;
-	
+
 	loffset = offset;
 	retval = ext2fs_file_llseek(file, loffset, whence, &ret_loffset);
 	if (ret_pos)
@@ -354,14 +354,14 @@ ext2_off_t ext2fs_file_get_size(ext2_file_t file)
 
 /*
  * This function sets the size of the file, truncating it if necessary
- * 
+ *
  * XXX still need to call truncate
  */
 errcode_t ext2fs_file_set_size(ext2_file_t file, ext2_off_t size)
 {
 	errcode_t	retval;
 	EXT2_CHECK_MAGIC(file, EXT2_ET_MAGIC_EXT2_FILE);
-	
+
 	file->inode.i_size = size;
 	file->inode.i_size_high = 0;
 	if (file->ino) {
@@ -370,7 +370,7 @@ errcode_t ext2fs_file_set_size(ext2_file_t file, ext2_off_t size)
 			return retval;
 	}
 
-	/* 
+	/*
 	 * XXX truncate inode if necessary
 	 */
 
diff --git a/e2fsprogs/ext2fs/finddev.c b/e2fsprogs/ext2fs/finddev.c
index c459c0833..552aa79c3 100644
--- a/e2fsprogs/ext2fs/finddev.c
+++ b/e2fsprogs/ext2fs/finddev.c
@@ -1,7 +1,7 @@
 /*
  * finddev.c -- this routine attempts to find a particular device in
- * 	/dev
- * 
+ *	/dev
+ *
  * Copyright (C) 2000 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -124,7 +124,7 @@ char *ext2fs_find_block_device(dev_t device)
 	add_to_dirlist("/devices", &list);
 	add_to_dirlist("/devfs", &list);
 	add_to_dirlist("/dev", &list);
-	
+
 	while (list) {
 		current = list;
 		list = list->next;
@@ -150,7 +150,7 @@ char *ext2fs_find_block_device(dev_t device)
 	return ret_path;
 }
 
-	
+
 #ifdef DEBUG
 int main(int argc, char** argv)
 {
@@ -194,5 +194,5 @@ int main(int argc, char** argv)
 	}
 	return 0;
 }
-	
+
 #endif
diff --git a/e2fsprogs/ext2fs/flushb.c b/e2fsprogs/ext2fs/flushb.c
index 18827955f..9f04647ec 100644
--- a/e2fsprogs/ext2fs/flushb.c
+++ b/e2fsprogs/ext2fs/flushb.c
@@ -1,7 +1,7 @@
 /*
  * flushb.c --- Hides system-dependent information for both syncing a
- * 	device to disk and to flush any buffers from disk cache.
- * 
+ *	device to disk and to flush any buffers from disk cache.
+ *
  * Copyright (C) 2000 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -29,7 +29,7 @@
 #include "ext2fs.h"
 
 /*
- * For Linux, define BLKFLSBUF and FDFLUSH if necessary, since 
+ * For Linux, define BLKFLSBUF and FDFLUSH if necessary, since
  * not all portable header file does so for us.  This really should be
  * fixed in the glibc header files.  (Recent glibcs appear to define
  * BLKFLSBUF in sys/mount.h, but FDFLUSH still doesn't seem to be
diff --git a/e2fsprogs/ext2fs/freefs.c b/e2fsprogs/ext2fs/freefs.c
index 029ffaae1..3fd51f257 100644
--- a/e2fsprogs/ext2fs/freefs.c
+++ b/e2fsprogs/ext2fs/freefs.c
@@ -1,6 +1,6 @@
 /*
  * freefs.c --- free an ext2 filesystem
- * 
+ *
  * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -52,7 +52,7 @@ void ext2fs_free(ext2_filsys fs)
 
 	if (fs->icache)
 		ext2fs_free_inode_cache(fs->icache);
-	
+
 	fs->magic = 0;
 
 	ext2fs_free_mem(&fs);
diff --git a/e2fsprogs/ext2fs/gen_bitmap.c b/e2fsprogs/ext2fs/gen_bitmap.c
index 700affa19..3f15ce6a7 100644
--- a/e2fsprogs/ext2fs/gen_bitmap.c
+++ b/e2fsprogs/ext2fs/gen_bitmap.c
@@ -1,6 +1,6 @@
 /*
  * gen_bitmap.c --- Generic bitmap routines that used to be inlined.
- * 
+ *
  * Copyright (C) 2001 Theodore Ts'o.
  *
  * %Begin-Header%
diff --git a/e2fsprogs/ext2fs/get_pathname.c b/e2fsprogs/ext2fs/get_pathname.c
index 23f593f67..594090da0 100644
--- a/e2fsprogs/ext2fs/get_pathname.c
+++ b/e2fsprogs/ext2fs/get_pathname.c
@@ -1,6 +1,6 @@
 /*
  * get_pathname.c --- do directry/inode -> name translation
- * 
+ *
  * Copyright (C) 1993, 1994, 1995 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -8,14 +8,14 @@
  * License.
  * %End-Header%
  *
- * 	ext2fs_get_pathname(fs, dir, ino, name)
+ *	ext2fs_get_pathname(fs, dir, ino, name)
+ *
+ *	This function translates takes two inode numbers into a
+ *	string, placing the result in <name>.  <dir> is the containing
+ *	directory inode, and <ino> is the inode number itself.  If
+ *	<ino> is zero, then ext2fs_get_pathname will return pathname
+ *	of the the directory <dir>.
  *
- * 	This function translates takes two inode numbers into a
- * 	string, placing the result in <name>.  <dir> is the containing
- * 	directory inode, and <ino> is the inode number itself.  If
- * 	<ino> is zero, then ext2fs_get_pathname will return pathname
- * 	of the the directory <dir>.
- * 
  */
 
 #include <stdio.h>
@@ -65,8 +65,8 @@ static int get_pathname_proc(struct ext2_dir_entry *dirent,
 	return 0;
 }
 
-static errcode_t ext2fs_get_pathname_int(ext2_filsys fs, ext2_ino_t dir, 
-					 ext2_ino_t ino, int maxdepth, 
+static errcode_t ext2fs_get_pathname_int(ext2_filsys fs, ext2_ino_t dir,
+					 ext2_ino_t ino, int maxdepth,
 					 char *buf, char **name)
 {
 	struct get_pathname_struct gp;
@@ -93,7 +93,7 @@ static errcode_t ext2fs_get_pathname_int(ext2_filsys fs, ext2_ino_t dir,
 	gp.parent = 0;
 	gp.name = 0;
 	gp.errcode = 0;
-	
+
 	retval = ext2fs_dir_iterate(fs, dir, 0, buf, get_pathname_proc, &gp);
 	if (retval)
 		goto cleanup;
@@ -110,15 +110,15 @@ static errcode_t ext2fs_get_pathname_int(ext2_filsys fs, ext2_ino_t dir,
 		*name = parent_name;
 		return 0;
 	}
-	
-	if (gp.name) 
+
+	if (gp.name)
 		retval = ext2fs_get_mem(strlen(parent_name)+strlen(gp.name)+2,
 					&ret);
 	else
 		retval = ext2fs_get_mem(strlen(parent_name)+5, &ret);
 	if (retval)
 		goto cleanup;
-	
+
 	ret[0] = 0;
 	if (parent_name[1])
 		strcat(ret, parent_name);
@@ -130,7 +130,7 @@ static errcode_t ext2fs_get_pathname_int(ext2_filsys fs, ext2_ino_t dir,
 	*name = ret;
 	ext2fs_free_mem(&parent_name);
 	retval = 0;
-	
+
 cleanup:
 	if (gp.name)
 		ext2fs_free_mem(&gp.name);
@@ -153,5 +153,5 @@ errcode_t ext2fs_get_pathname(ext2_filsys fs, ext2_ino_t dir, ext2_ino_t ino,
 	retval = ext2fs_get_pathname_int(fs, dir, ino, 32, buf, name);
 	ext2fs_free_mem(&buf);
 	return retval;
-	
+
 }
diff --git a/e2fsprogs/ext2fs/getsectsize.c b/e2fsprogs/ext2fs/getsectsize.c
index 77a9e3da7..b561660ba 100644
--- a/e2fsprogs/ext2fs/getsectsize.c
+++ b/e2fsprogs/ext2fs/getsectsize.c
@@ -1,6 +1,6 @@
 /*
  * getsectsize.c --- get the sector size of a device.
- * 
+ *
  * Copyright (C) 1995, 1995 Theodore Ts'o.
  * Copyright (C) 2003 VMware, Inc.
  *
diff --git a/e2fsprogs/ext2fs/getsize.c b/e2fsprogs/ext2fs/getsize.c
index 036d9260c..bfafdf2ba 100644
--- a/e2fsprogs/ext2fs/getsize.c
+++ b/e2fsprogs/ext2fs/getsize.c
@@ -1,11 +1,11 @@
 /*
  * getsize.c --- get the size of a partition.
- * 
+ *
  * Copyright (C) 1995, 1995 Theodore Ts'o.
  * Copyright (C) 2003 VMware, Inc.
  *
  * Windows version of ext2fs_get_device_size by Chris Li, VMware.
- * 
+ *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
  * License.
@@ -75,10 +75,10 @@ errcode_t ext2fs_get_device_size(const char *file, int blocksize,
 	DWORD filesize;
 #endif /* HAVE_GET_FILE_SIZE_EX */
 
-	dev = CreateFile(file, GENERIC_READ, 
+	dev = CreateFile(file, GENERIC_READ,
 			 FILE_SHARE_READ | FILE_SHARE_WRITE ,
-                	 NULL,  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,  NULL); 
- 
+			 NULL,  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,  NULL);
+
 	if (dev == INVALID_HANDLE_VALUE)
 		return EBADF;
 	if (DeviceIoControl(dev, IOCTL_DISK_GET_PARTITION_INFO,
@@ -87,7 +87,7 @@ errcode_t ext2fs_get_device_size(const char *file, int blocksize,
 			    &retbytes, NULL)) {
 
 		*retblocks = pi.PartitionLength.QuadPart / blocksize;
-	
+
 	} else if (DeviceIoControl(dev, IOCTL_DISK_GET_DRIVE_GEOMETRY,
 				&gi, sizeof(DISK_GEOMETRY),
 				&gi, sizeof(DISK_GEOMETRY),
@@ -137,7 +137,7 @@ errcode_t ext2fs_get_device_size(const char *file, int blocksize,
 	int	fd;
 	int valid_blkgetsize64 = 1;
 #ifdef __linux__
-	struct 		utsname ut;
+	struct		utsname ut;
 #endif
 	unsigned long long size64;
 	unsigned long	size;
@@ -272,7 +272,7 @@ int main(int argc, char **argv)
 {
 	blk_t	blocks;
 	int	retval;
-	
+
 	if (argc < 2) {
 		fprintf(stderr, "Usage: %s device\n", argv[0]);
 		exit(1);
diff --git a/e2fsprogs/ext2fs/icount.c b/e2fsprogs/ext2fs/icount.c
index 59977928b..01677775f 100644
--- a/e2fsprogs/ext2fs/icount.c
+++ b/e2fsprogs/ext2fs/icount.c
@@ -81,19 +81,19 @@ errcode_t ext2fs_create_icount2(ext2_filsys fs, int flags, unsigned int size,
 		if (hint->size > size)
 			size = (size_t) hint->size;
 	}
-	
+
 	retval = ext2fs_get_mem(sizeof(struct ext2_icount), &icount);
 	if (retval)
 		return retval;
 	memset(icount, 0, sizeof(struct ext2_icount));
 
-	retval = ext2fs_allocate_inode_bitmap(fs, 0, 
+	retval = ext2fs_allocate_inode_bitmap(fs, 0,
 					      &icount->single);
 	if (retval)
 		goto errout;
 
 	if (flags & EXT2_ICOUNT_OPT_INCREMENT) {
-		retval = ext2fs_allocate_inode_bitmap(fs, 0, 
+		retval = ext2fs_allocate_inode_bitmap(fs, 0,
 						      &icount->multiple);
 		if (retval)
 			goto errout;
@@ -113,7 +113,7 @@ errcode_t ext2fs_create_icount2(ext2_filsys fs, int flags, unsigned int size,
 			goto errout;
 		icount->size += fs->super->s_inodes_count / 50;
 	}
-	
+
 	bytes = (size_t) (icount->size * sizeof(struct ext2_icount_el));
 #if 0
 	printf("Icount allocated %d entries, %d bytes.\n",
@@ -148,7 +148,7 @@ errout:
 	return(retval);
 }
 
-errcode_t ext2fs_create_icount(ext2_filsys fs, int flags, 
+errcode_t ext2fs_create_icount(ext2_filsys fs, int flags,
 			       unsigned int size,
 			       ext2_icount_t *ret)
 {
@@ -157,12 +157,12 @@ errcode_t ext2fs_create_icount(ext2_filsys fs, int flags,
 
 /*
  * insert_icount_el() --- Insert a new entry into the sorted list at a
- * 	specified position.
+ *	specified position.
  */
 static struct ext2_icount_el *insert_icount_el(ext2_icount_t icount,
 					    ext2_ino_t ino, int pos)
 {
-	struct ext2_icount_el 	*el;
+	struct ext2_icount_el	*el;
 	errcode_t		retval;
 	ext2_ino_t			new_size = 0;
 	int			num;
@@ -170,14 +170,14 @@ static struct ext2_icount_el *insert_icount_el(ext2_icount_t icount,
 	if (icount->count >= icount->size) {
 		if (icount->count) {
 			new_size = icount->list[(unsigned)icount->count-1].ino;
-			new_size = (ext2_ino_t) (icount->count * 
+			new_size = (ext2_ino_t) (icount->count *
 				((float) icount->num_inodes / new_size));
 		}
 		if (new_size < (icount->size + 100))
 			new_size = icount->size + 100;
 #if 0
 		printf("Reallocating icount %d entries...\n", new_size);
-#endif	
+#endif
 		retval = ext2fs_resize_mem((size_t) icount->size *
 					   sizeof(struct ext2_icount_el),
 					   (size_t) new_size *
@@ -203,8 +203,8 @@ static struct ext2_icount_el *insert_icount_el(ext2_icount_t icount,
 
 /*
  * get_icount_el() --- given an inode number, try to find icount
- * 	information in the sorted list.  If the create flag is set,
- * 	and we can't find an entry, create one in the sorted list.
+ *	information in the sorted list.  If the create flag is set,
+ *	and we can't find an entry, create one in the sorted list.
  */
 static struct ext2_icount_el *get_icount_el(ext2_icount_t icount,
 					    ext2_ino_t ino, int create)
@@ -222,7 +222,7 @@ static struct ext2_icount_el *get_icount_el(ext2_icount_t icount,
 	}
 	if (icount->count == 0)
 		return 0;
-	
+
 	if (icount->cursor >= icount->count)
 		icount->cursor = 0;
 	if (ino == icount->list[icount->cursor].ino)
@@ -247,7 +247,7 @@ static struct ext2_icount_el *get_icount_el(ext2_icount_t icount,
 				range = 0;
 			else if (ino > highval)
 				range = 1;
-			else 
+			else
 				range = ((float) (ino - lowval)) /
 					(highval - lowval);
 			mid = low + ((int) (range * (high-low)));
@@ -276,7 +276,7 @@ errcode_t ext2fs_icount_validate(ext2_icount_t icount, FILE *out)
 	errcode_t	ret = 0;
 	unsigned int	i;
 	const char *bad = "bad icount";
-	
+
 	EXT2_CHECK_MAGIC(icount, EXT2_ET_MAGIC_ICOUNT);
 
 	if (icount->count > icount->size) {
@@ -297,7 +297,7 @@ errcode_t ext2fs_icount_validate(ext2_icount_t icount, FILE *out)
 errcode_t ext2fs_icount_fetch(ext2_icount_t icount, ext2_ino_t ino, __u16 *ret)
 {
 	struct ext2_icount_el	*el;
-	
+
 	EXT2_CHECK_MAGIC(icount, EXT2_ET_MAGIC_ICOUNT);
 
 	if (!ino || (ino > icount->num_inodes))
@@ -413,7 +413,7 @@ errcode_t ext2fs_icount_decrement(ext2_icount_t icount, ext2_ino_t ino,
 	if (icount->multiple &&
 	    !ext2fs_test_inode_bitmap(icount->multiple, ino))
 		return EXT2_ET_INVALID_ARGUMENT;
-	
+
 	el = get_icount_el(icount, ino, 0);
 	if (!el || el->count == 0)
 		return EXT2_ET_INVALID_ARGUMENT;
diff --git a/e2fsprogs/ext2fs/imager.c b/e2fsprogs/ext2fs/imager.c
index 3f2826b82..00eb71723 100644
--- a/e2fsprogs/ext2fs/imager.c
+++ b/e2fsprogs/ext2fs/imager.c
@@ -1,11 +1,11 @@
 /*
  * image.c --- writes out the critical parts of the filesystem as a
- * 	flat file.
+ *	flat file.
  *
  * Copyright (C) 2000 Theodore Ts'o.
  *
  * Note: this uses the POSIX IO interfaces, unlike most of the other
- * functions in this library.  So sue me.  
+ * functions in this library.  So sue me.
  *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
@@ -67,7 +67,7 @@ errcode_t ext2fs_image_inode_write(ext2_filsys fs, int fd, int flags)
 	errcode_t	retval;
 
 	buf = xmalloc(fs->blocksize * BUF_BLOCKS);
-	
+
 	for (group = 0; group < fs->group_desc_count; group++) {
 		blk = fs->group_desc[(unsigned)group].bg_inode_table;
 		if (!blk)
@@ -127,7 +127,7 @@ errout:
 /*
  * Read in the inode table and stuff it into place
  */
-errcode_t ext2fs_image_inode_read(ext2_filsys fs, int fd, 
+errcode_t ext2fs_image_inode_read(ext2_filsys fs, int fd,
 				  int flags EXT2FS_ATTR((unused)))
 {
 	unsigned int	group, c, left;
@@ -137,7 +137,7 @@ errcode_t ext2fs_image_inode_read(ext2_filsys fs, int fd,
 	errcode_t	retval;
 
 	buf = xmalloc(fs->blocksize * BUF_BLOCKS);
-	
+
 	for (group = 0; group < fs->group_desc_count; group++) {
 		blk = fs->group_desc[(unsigned)group].bg_inode_table;
 		if (!blk) {
@@ -161,7 +161,7 @@ errcode_t ext2fs_image_inode_read(ext2_filsys fs, int fd,
 			retval = io_channel_write_blk(fs->io, blk, c, buf);
 			if (retval)
 				goto errout;
-			
+
 			blk += c;
 			left -= c;
 		}
@@ -176,7 +176,7 @@ errout:
 /*
  * Write out superblock and group descriptors
  */
-errcode_t ext2fs_image_super_write(ext2_filsys fs, int fd, 
+errcode_t ext2fs_image_super_write(ext2_filsys fs, int fd,
 				   int flags EXT2FS_ATTR((unused)))
 {
 	char		*buf, *cp;
@@ -213,7 +213,7 @@ errcode_t ext2fs_image_super_write(ext2_filsys fs, int fd,
 		retval = EXT2_ET_SHORT_WRITE;
 		goto errout;
 	}
-	
+
 	retval = 0;
 
 errout:
@@ -224,7 +224,7 @@ errout:
 /*
  * Read the superblock and group descriptors and overwrite them.
  */
-errcode_t ext2fs_image_super_read(ext2_filsys fs, int fd, 
+errcode_t ext2fs_image_super_read(ext2_filsys fs, int fd,
 				  int flags EXT2FS_ATTR((unused)))
 {
 	char		*buf;
@@ -368,7 +368,7 @@ errcode_t ext2fs_image_bitmap_read(ext2_filsys fs, int fd, int flags)
 		goto errout;
 	}
 	memcpy(ptr, buf, size);
-	
+
 	retval = 0;
 errout:
 	if (buf)
diff --git a/e2fsprogs/ext2fs/ind_block.c b/e2fsprogs/ext2fs/ind_block.c
index c9fd86aae..3e6cdc138 100644
--- a/e2fsprogs/ext2fs/ind_block.c
+++ b/e2fsprogs/ext2fs/ind_block.c
@@ -1,8 +1,8 @@
 /*
  * ind_block.c --- indirect block I/O routines
- * 
- * Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 
- * 	2001, 2002, 2003, 2004, 2005 by  Theodore Ts'o.
+ *
+ * Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+ *	2001, 2002, 2003, 2004, 2005 by  Theodore Ts'o.
  *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
diff --git a/e2fsprogs/ext2fs/initialize.c b/e2fsprogs/ext2fs/initialize.c
index 82cd9f1da..3d326b577 100644
--- a/e2fsprogs/ext2fs/initialize.c
+++ b/e2fsprogs/ext2fs/initialize.c
@@ -1,9 +1,9 @@
 /*
  * initialize.c --- initialize a filesystem handle given superblock
- * 	parameters.  Used by mke2fs when initializing a filesystem.
- * 
+ *	parameters.  Used by mke2fs when initializing a filesystem.
+ *
  * Copyright (C) 1994, 1995, 1996 Theodore Ts'o.
- * 
+ *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
  * License.
@@ -36,7 +36,7 @@
 #if defined(__FreeBSD__) &&	defined(EXT2_OS_FREEBSD)
 #define CREATOR_OS EXT2_OS_FREEBSD
 #else
-#if defined(LITES) 	   &&	defined(EXT2_OS_LITES)
+#if defined(LITES)	   &&	defined(EXT2_OS_LITES)
 #define CREATOR_OS EXT2_OS_LITES
 #else
 #define CREATOR_OS EXT2_OS_LINUX /* by default */
@@ -44,13 +44,13 @@
 #endif /* defined(__FreeBSD__) && defined(EXT2_OS_FREEBSD) */
 #endif /* defined(__GNU__)     && defined(EXT2_OS_HURD) */
 #endif /* defined(__linux__)   && defined(EXT2_OS_LINUX) */
-	
+
 /*
  * Note we override the kernel include file's idea of what the default
  * check interval (never) should be.  It's a good idea to check at
  * least *occasionally*, specially since servers will never rarely get
  * to reboot, since Linux is so robust these days.  :-)
- * 
+ *
  * 180 days (six months) seems like a good value.
  */
 #ifdef EXT2_DFL_CHECKINTERVAL
@@ -108,11 +108,11 @@ errcode_t ext2fs_initialize(const char *name, int flags,
 
 	if (!param || !param->s_blocks_count)
 		return EXT2_ET_INVALID_ARGUMENT;
-	
+
 	retval = ext2fs_get_mem(sizeof(struct struct_ext2_filsys), &fs);
 	if (retval)
 		return retval;
-	
+
 	memset(fs, 0, sizeof(struct struct_ext2_filsys));
 	fs->magic = EXT2_ET_MAGIC_EXT2FS_FILSYS;
 	fs->flags = flags | EXT2_FLAG_RW;
@@ -181,7 +181,7 @@ errcode_t ext2fs_initialize(const char *name, int flags,
 	if (super->s_blocks_per_group > EXT2_MAX_BLOCKS_PER_GROUP(super))
 		super->s_blocks_per_group = EXT2_MAX_BLOCKS_PER_GROUP(super);
 	super->s_frags_per_group = super->s_blocks_per_group * frags_per_block;
-	
+
 	super->s_blocks_count = param->s_blocks_count;
 	super->s_r_blocks_count = param->s_r_blocks_count;
 	if (super->s_r_blocks_count >= param->s_blocks_count) {
@@ -222,7 +222,7 @@ retry:
 	 */
 	if (super->s_inodes_count < EXT2_FIRST_INODE(super)+1)
 		super->s_inodes_count = EXT2_FIRST_INODE(super)+1;
-	
+
 	/*
 	 * There should be at least as many inodes as the user
 	 * requested.  Figure out how many inodes per group that
@@ -332,12 +332,12 @@ retry:
 	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
 	if (retval)
 		goto cleanup;
-	
+
 	sprintf(buf, "block bitmap for %s", fs->device_name);
 	retval = ext2fs_allocate_block_bitmap(fs, buf, &fs->block_map);
 	if (retval)
 		goto cleanup;
-	
+
 	sprintf(buf, "inode bitmap for %s", fs->device_name);
 	retval = ext2fs_allocate_inode_bitmap(fs, buf, &fs->inode_map);
 	if (retval)
@@ -369,14 +369,14 @@ retry:
 		fs->group_desc[i].bg_free_inodes_count =
 			fs->super->s_inodes_per_group;
 		fs->group_desc[i].bg_used_dirs_count = 0;
-		
+
 		group_block += super->s_blocks_per_group;
 	}
-	
+
 	ext2fs_mark_super_dirty(fs);
 	ext2fs_mark_bb_dirty(fs);
 	ext2fs_mark_ib_dirty(fs);
-	
+
 	io_channel_set_blksize(fs->io, fs->blocksize);
 
 	*ret_fs = fs;
diff --git a/e2fsprogs/ext2fs/inline.c b/e2fsprogs/ext2fs/inline.c
index 5833b1d9d..9c3a6c0d3 100644
--- a/e2fsprogs/ext2fs/inline.c
+++ b/e2fsprogs/ext2fs/inline.c
@@ -1,8 +1,8 @@
 /*
  * inline.c --- Includes the inlined functions defined in the header
- * 	files as standalone functions, in case the application program
- * 	is compiled with inlining turned off.
- * 
+ *	files as standalone functions, in case the application program
+ *	is compiled with inlining turned off.
+ *
  * Copyright (C) 1993, 1994 Theodore Ts'o.
  *
  * %Begin-Header%
diff --git a/e2fsprogs/ext2fs/inode.c b/e2fsprogs/ext2fs/inode.c
index 30580bf6d..e50bece40 100644
--- a/e2fsprogs/ext2fs/inode.c
+++ b/e2fsprogs/ext2fs/inode.c
@@ -1,6 +1,6 @@
 /*
  * inode.c --- utility routines to read and write inodes
- * 
+ *
  * Copyright (C) 1993, 1994, 1995, 1996, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -59,7 +59,7 @@ struct ext2_struct_inode_scan {
 errcode_t ext2fs_flush_icache(ext2_filsys fs)
 {
 	int	i;
-	
+
 	if (!fs->icache)
 		return 0;
 
@@ -73,7 +73,7 @@ errcode_t ext2fs_flush_icache(ext2_filsys fs)
 static errcode_t create_icache(ext2_filsys fs)
 {
 	errcode_t	retval;
-	
+
 	if (fs->icache)
 		return 0;
 	retval = ext2fs_get_mem(sizeof(struct ext2_inode_cache), &fs->icache);
@@ -146,7 +146,7 @@ errcode_t ext2fs_open_inode_scan(ext2_filsys fs, int buffer_blocks,
 		group_desc[scan->current_group].bg_inode_table;
 	scan->inodes_left = EXT2_INODES_PER_GROUP(scan->fs->super);
 	scan->blocks_left = scan->fs->inode_blocks_per_group;
-	retval = ext2fs_get_mem((size_t) (scan->inode_buffer_blocks * 
+	retval = ext2fs_get_mem((size_t) (scan->inode_buffer_blocks *
 					  fs->blocksize),
 				&scan->inode_buffer);
 	scan->done_group = 0;
@@ -172,7 +172,7 @@ void ext2fs_close_inode_scan(ext2_inode_scan scan)
 {
 	if (!scan || (scan->magic != EXT2_ET_MAGIC_INODE_SCAN))
 		return;
-	
+
 	ext2fs_free_mem(&scan->inode_buffer);
 	scan->inode_buffer = NULL;
 	ext2fs_free_mem(&scan->temp_buffer);
@@ -190,7 +190,7 @@ void ext2fs_set_inode_callback(ext2_inode_scan scan,
 {
 	if (!scan || (scan->magic != EXT2_ET_MAGIC_INODE_SCAN))
 		return;
-	
+
 	scan->done_group = done_group;
 	scan->done_group_data = done_group_data;
 }
@@ -217,7 +217,7 @@ static errcode_t get_next_blockgroup(ext2_inode_scan scan)
 {
 	scan->current_group++;
 	scan->groups_left--;
-			
+
 	scan->current_block = scan->fs->
 		group_desc[scan->current_group].bg_inode_table;
 
@@ -335,7 +335,7 @@ static errcode_t get_next_blocks(ext2_inode_scan scan)
 		if (retval)
 			return retval;
 	}
-		
+
 	if ((scan->scan_flags & EXT2_SF_BAD_INODE_BLK) ||
 	    (scan->current_block == 0)) {
 		memset(scan->inode_buffer, 0,
@@ -367,7 +367,7 @@ static errcode_t get_next_blocks(ext2_inode_scan scan)
 static inline int is_empty_scan(ext2_inode_scan scan)
 {
 	int	i;
-	
+
 	if (scan->bytes_left == 0)
 		return 0;
 
@@ -383,7 +383,7 @@ errcode_t ext2fs_get_next_inode_full(ext2_inode_scan scan, ext2_ino_t *ino,
 {
 	errcode_t	retval;
 	int		extra_bytes = 0;
-	
+
 	EXT2_CHECK_MAGIC(scan, EXT2_ET_MAGIC_INODE_SCAN);
 
 	/*
@@ -416,7 +416,7 @@ errcode_t ext2fs_get_next_inode_full(ext2_inode_scan scan, ext2_ino_t *ino,
 		} else
 			return EXT2_ET_MISSING_INODE_TABLE;
 	}
-	
+
 
 	/*
 	 * Have we run out of space in the inode buffer?  If so, we
@@ -449,9 +449,9 @@ errcode_t ext2fs_get_next_inode_full(ext2_inode_scan scan, ext2_ino_t *ino,
 #ifdef EXT2FS_ENABLE_SWAPFS
 		if ((scan->fs->flags & EXT2_FLAG_SWAP_BYTES) ||
 		    (scan->fs->flags & EXT2_FLAG_SWAP_BYTES_READ))
-			ext2fs_swap_inode_full(scan->fs, 
+			ext2fs_swap_inode_full(scan->fs,
 				(struct ext2_inode_large *) inode,
-				(struct ext2_inode_large *) scan->temp_buffer, 
+				(struct ext2_inode_large *) scan->temp_buffer,
 				0, bufsize);
 		else
 #endif
@@ -463,7 +463,7 @@ errcode_t ext2fs_get_next_inode_full(ext2_inode_scan scan, ext2_ino_t *ino,
 #ifdef EXT2FS_ENABLE_SWAPFS
 		if ((scan->fs->flags & EXT2_FLAG_SWAP_BYTES) ||
 		    (scan->fs->flags & EXT2_FLAG_SWAP_BYTES_READ))
-			ext2fs_swap_inode_full(scan->fs, 
+			ext2fs_swap_inode_full(scan->fs,
 				(struct ext2_inode_large *) inode,
 				(struct ext2_inode_large *) scan->ptr,
 				0, bufsize);
@@ -495,10 +495,10 @@ errcode_t ext2fs_get_next_inode(ext2_inode_scan scan, ext2_ino_t *ino,
 errcode_t ext2fs_read_inode_full(ext2_filsys fs, ext2_ino_t ino,
 				 struct ext2_inode * inode, int bufsize)
 {
-	unsigned long 	group, block, block_nr, offset;
-	char 		*ptr;
+	unsigned long	group, block, block_nr, offset;
+	char		*ptr;
 	errcode_t	retval;
-	int 		clen, i, inodes_per_block, length;
+	int		clen, i, inodes_per_block, length;
 	io_channel	io;
 
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
@@ -541,7 +541,7 @@ errcode_t ext2fs_read_inode_full(ext2_filsys fs, ext2_ino_t ino,
 		block = offset >> EXT2_BLOCK_SIZE_BITS(fs->super);
 		if (!fs->group_desc[(unsigned)group].bg_inode_table)
 			return EXT2_ET_MISSING_INODE_TABLE;
-		block_nr = fs->group_desc[(unsigned)group].bg_inode_table + 
+		block_nr = fs->group_desc[(unsigned)group].bg_inode_table +
 			block;
 		io = fs->io;
 	}
@@ -577,8 +577,8 @@ errcode_t ext2fs_read_inode_full(ext2_filsys fs, ext2_ino_t ino,
 #ifdef EXT2FS_ENABLE_SWAPFS
 	if ((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
 	    (fs->flags & EXT2_FLAG_SWAP_BYTES_READ))
-		ext2fs_swap_inode_full(fs, (struct ext2_inode_large *) inode, 
-				       (struct ext2_inode_large *) inode, 
+		ext2fs_swap_inode_full(fs, (struct ext2_inode_large *) inode,
+				       (struct ext2_inode_large *) inode,
 				       0, length);
 #endif
 
@@ -587,7 +587,7 @@ errcode_t ext2fs_read_inode_full(ext2_filsys fs, ext2_ino_t ino,
 		fs->icache->cache_size;
 	fs->icache->cache[fs->icache->cache_last].ino = ino;
 	fs->icache->cache[fs->icache->cache_last].inode = *inode;
-	
+
 	return 0;
 }
 
@@ -629,7 +629,7 @@ errcode_t ext2fs_write_inode_full(ext2_filsys fs, ext2_ino_t ino,
 		if (retval)
 			return retval;
 	}
-		
+
 	if (!(fs->flags & EXT2_FLAG_RW))
 		return EXT2_ET_RO_FILSYS;
 
@@ -649,13 +649,13 @@ errcode_t ext2fs_write_inode_full(ext2_filsys fs, ext2_ino_t ino,
 #ifdef EXT2FS_ENABLE_SWAPFS
 	if ((fs->flags & EXT2_FLAG_SWAP_BYTES) ||
 	    (fs->flags & EXT2_FLAG_SWAP_BYTES_WRITE))
-		ext2fs_swap_inode_full(fs, w_inode, 
-				       (struct ext2_inode_large *) inode, 
+		ext2fs_swap_inode_full(fs, w_inode,
+				       (struct ext2_inode_large *) inode,
 				       1, bufsize);
 	else
 #endif
 		memcpy(w_inode, inode, bufsize);
-	
+
 	group = (ino - 1) / EXT2_INODES_PER_GROUP(fs->super);
 	offset = ((ino - 1) % EXT2_INODES_PER_GROUP(fs->super)) *
 		EXT2_INODE_SIZE(fs->super);
@@ -685,11 +685,11 @@ errcode_t ext2fs_write_inode_full(ext2_filsys fs, ext2_ino_t ino,
 			fs->icache->buffer_blk = block_nr;
 		}
 
-	
-		memcpy((char *) fs->icache->buffer + (unsigned) offset, 
+
+		memcpy((char *) fs->icache->buffer + (unsigned) offset,
 		       ptr, clen);
 
-		retval = io_channel_write_blk(fs->io, block_nr, 1, 
+		retval = io_channel_write_blk(fs->io, block_nr, 1,
 					      fs->icache->buffer);
 		if (retval)
 			goto errout;
@@ -699,7 +699,7 @@ errcode_t ext2fs_write_inode_full(ext2_filsys fs, ext2_ino_t ino,
 		length -= clen;
 		block_nr++;
 	}
-		
+
 	fs->flags |= EXT2_FLAG_CHANGED;
 errout:
 	if (w_inode && w_inode != &temp_inode)
@@ -714,7 +714,7 @@ errcode_t ext2fs_write_inode(ext2_filsys fs, ext2_ino_t ino,
 				       sizeof(struct ext2_inode));
 }
 
-/* 
+/*
  * This function should be called when writing a new inode.  It makes
  * sure that extra part of large inodes is initialized properly.
  */
@@ -722,7 +722,7 @@ errcode_t ext2fs_write_new_inode(ext2_filsys fs, ext2_ino_t ino,
 				 struct ext2_inode *inode)
 {
 	struct ext2_inode	*buf;
-	int 			size = EXT2_INODE_SIZE(fs->super);
+	int			size = EXT2_INODE_SIZE(fs->super);
 	struct ext2_inode_large	*large_inode;
 
 	if (size == sizeof(struct ext2_inode))
@@ -735,19 +735,19 @@ errcode_t ext2fs_write_new_inode(ext2_filsys fs, ext2_ino_t ino,
 	*buf = *inode;
 
 	large_inode = (struct ext2_inode_large *) buf;
-	large_inode->i_extra_isize = sizeof(struct ext2_inode_large) - 
+	large_inode->i_extra_isize = sizeof(struct ext2_inode_large) -
 		EXT2_GOOD_OLD_INODE_SIZE;
 
 	return ext2fs_write_inode_full(fs, ino, buf, size);
 }
 
- 
+
 errcode_t ext2fs_get_blocks(ext2_filsys fs, ext2_ino_t ino, blk_t *blocks)
 {
 	struct ext2_inode	inode;
 	int			i;
 	errcode_t		retval;
-	
+
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	if (ino > fs->super->s_inodes_count)
@@ -769,7 +769,7 @@ errcode_t ext2fs_check_directory(ext2_filsys fs, ext2_ino_t ino)
 {
 	struct	ext2_inode	inode;
 	errcode_t		retval;
-	
+
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	if (ino > fs->super->s_inodes_count)
diff --git a/e2fsprogs/ext2fs/inode_io.c b/e2fsprogs/ext2fs/inode_io.c
index b5c08b90a..deaa95562 100644
--- a/e2fsprogs/ext2fs/inode_io.c
+++ b/e2fsprogs/ext2fs/inode_io.c
@@ -1,6 +1,6 @@
 /*
  * inode_io.c --- This is allows an inode in an ext2 filesystem image
- * 	to be accessed via the I/O manager interface.
+ *	to be accessed via the I/O manager interface.
  *
  * Copyright (C) 2002 Theodore Ts'o.
  *
@@ -35,7 +35,7 @@ struct inode_private_data {
 	char				name[32];
 	ext2_file_t			file;
 	ext2_filsys			fs;
-	ext2_ino_t 			ino;
+	ext2_ino_t			ino;
 	struct ext2_inode		inode;
 	int				flags;
 	struct inode_private_data	*next;
@@ -75,7 +75,7 @@ errcode_t ext2fs_inode_io_intern2(ext2_filsys fs, ext2_ino_t ino,
 				  struct ext2_inode *inode,
 				  char **name)
 {
-	struct inode_private_data 	*data;
+	struct inode_private_data	*data;
 	errcode_t			retval;
 
 	if ((retval = ext2fs_get_mem(sizeof(struct inode_private_data),
@@ -150,7 +150,7 @@ static errcode_t inode_open(const char *name, int flags, io_channel *channel)
 				   &data->file);
 	if (retval)
 		goto cleanup;
-		
+
 	*channel = io;
 	return 0;
 
@@ -176,7 +176,7 @@ static errcode_t inode_close(io_channel channel)
 		return 0;
 
 	retval = ext2fs_file_close(data->file);
-	
+
 	ext2fs_free_mem(&channel->private_data);
 	if (channel->name)
 		ext2fs_free_mem(&channel->name);
@@ -255,12 +255,12 @@ static errcode_t inode_write_byte(io_channel channel, unsigned long offset,
 }
 
 /*
- * Flush data buffers to disk.  
+ * Flush data buffers to disk.
  */
 static errcode_t inode_flush(io_channel channel)
 {
 	struct inode_private_data *data;
-	
+
 	EXT2_CHECK_MAGIC(channel, EXT2_ET_MAGIC_IO_CHANNEL);
 	data = (struct inode_private_data *) channel->private_data;
 	EXT2_CHECK_MAGIC(data, EXT2_ET_MAGIC_INODE_IO_CHANNEL);
diff --git a/e2fsprogs/ext2fs/io_manager.c b/e2fsprogs/ext2fs/io_manager.c
index e50d7e414..3d0987bc1 100644
--- a/e2fsprogs/ext2fs/io_manager.c
+++ b/e2fsprogs/ext2fs/io_manager.c
@@ -61,8 +61,8 @@ errcode_t io_channel_write_byte(io_channel channel, unsigned long offset,
 {
 	EXT2_CHECK_MAGIC(channel, EXT2_ET_MAGIC_IO_CHANNEL);
 
-	if (channel->manager->write_byte) 
-		return channel->manager->write_byte(channel, offset, 
+	if (channel->manager->write_byte)
+		return channel->manager->write_byte(channel, offset,
 						    count, data);
 
 	return EXT2_ET_UNIMPLEMENTED;
diff --git a/e2fsprogs/ext2fs/irel.h b/e2fsprogs/ext2fs/irel.h
index 9b943ced1..45e031beb 100644
--- a/e2fsprogs/ext2fs/irel.h
+++ b/e2fsprogs/ext2fs/irel.h
@@ -1,6 +1,6 @@
 /*
  * irel.h
- * 
+ *
  * Copyright (C) 1996, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
diff --git a/e2fsprogs/ext2fs/irel_ma.c b/e2fsprogs/ext2fs/irel_ma.c
index eedbe55c8..d9e73f73c 100644
--- a/e2fsprogs/ext2fs/irel_ma.c
+++ b/e2fsprogs/ext2fs/irel_ma.c
@@ -1,6 +1,6 @@
 /*
  * irel_ma.c
- * 
+ *
  * Copyright (C) 1996, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -64,7 +64,7 @@ errcode_t ext2fs_irel_memarray_create(char *name, ext2_ino_t max_inode,
 {
 	ext2_irel		irel = 0;
 	errcode_t	retval;
-	struct irel_ma 	*ma = 0;
+	struct irel_ma	*ma = 0;
 	size_t		size;
 
 	*new_irel = 0;
@@ -77,18 +77,18 @@ errcode_t ext2fs_irel_memarray_create(char *name, ext2_ino_t max_inode,
 	if (retval)
 		goto errout;
 	memset(irel, 0, sizeof(struct ext2_inode_relocation_table));
-	
+
 	retval = ext2fs_get_mem(strlen(name)+1, &irel->name);
 	if (retval)
 		goto errout;
 	strcpy(irel->name, name);
-	
+
 	retval = ext2fs_get_mem(sizeof(struct irel_ma), &ma);
 	if (retval)
 		goto errout;
 	memset(ma, 0, sizeof(struct irel_ma));
 	irel->priv_data = ma;
-	
+
 	size = (size_t) (sizeof(ext2_ino_t) * (max_inode+1));
 	retval = ext2fs_get_mem(size, &ma->orig_map);
 	if (retval)
@@ -124,7 +124,7 @@ errcode_t ext2fs_irel_memarray_create(char *name, ext2_ino_t max_inode,
 	irel->move = ima_move;
 	irel->delete = ima_delete;
 	irel->free = ima_free;
-	
+
 	*new_irel = irel;
 	return 0;
 
@@ -137,7 +137,7 @@ static errcode_t ima_put(ext2_irel irel, ext2_ino_t old,
 			struct ext2_inode_relocate_entry *ent)
 {
 	struct inode_reference_entry	*ref_ent;
-	struct irel_ma 			*ma;
+	struct irel_ma			*ma;
 	errcode_t			retval;
 	size_t				size, old_size;
 
@@ -153,7 +153,7 @@ static errcode_t ima_put(ext2_irel irel, ext2_ino_t old,
 		ent->orig = old;
 	else
 		ent->orig = ma->entries[(unsigned) old].orig;
-	
+
 	/*
 	 * If max_refs has changed, reallocate the refs array
 	 */
@@ -176,7 +176,7 @@ static errcode_t ima_put(ext2_irel irel, ext2_ino_t old,
 static errcode_t ima_get(ext2_irel irel, ext2_ino_t old,
 			struct ext2_inode_relocate_entry *ent)
 {
-	struct irel_ma 	*ma;
+	struct irel_ma	*ma;
 
 	ma = irel->priv_data;
 	if (old > ma->max_inode)
@@ -190,7 +190,7 @@ static errcode_t ima_get(ext2_irel irel, ext2_ino_t old,
 static errcode_t ima_get_by_orig(ext2_irel irel, ext2_ino_t orig, ext2_ino_t *old,
 			struct ext2_inode_relocate_entry *ent)
 {
-	struct irel_ma 	*ma;
+	struct irel_ma	*ma;
 	ext2_ino_t	ino;
 
 	ma = irel->priv_data;
@@ -213,7 +213,7 @@ static errcode_t ima_start_iter(ext2_irel irel)
 static errcode_t ima_next(ext2_irel irel, ext2_ino_t *old,
 			 struct ext2_inode_relocate_entry *ent)
 {
-	struct irel_ma 	*ma;
+	struct irel_ma	*ma;
 
 	ma = irel->priv_data;
 	while (++irel->current < ma->max_inode) {
@@ -230,7 +230,7 @@ static errcode_t ima_next(ext2_irel irel, ext2_ino_t *old,
 static errcode_t ima_add_ref(ext2_irel irel, ext2_ino_t ino,
 			     struct ext2_inode_reference *ref)
 {
-	struct irel_ma 	*ma;
+	struct irel_ma	*ma;
 	size_t		size;
 	struct inode_reference_entry *ref_ent;
 	struct ext2_inode_relocate_entry *ent;
@@ -242,12 +242,12 @@ static errcode_t ima_add_ref(ext2_irel irel, ext2_ino_t ino,
 
 	ref_ent = ma->ref_entries + (unsigned) ino;
 	ent = ma->entries + (unsigned) ino;
-	
+
 	/*
 	 * If the inode reference array doesn't exist, create it.
 	 */
 	if (ref_ent->refs == 0) {
-		size = (size_t) ((sizeof(struct ext2_inode_reference) * 
+		size = (size_t) ((sizeof(struct ext2_inode_reference) *
 				  ent->max_refs));
 		retval = ext2fs_get_mem(size, &ref_ent->refs);
 		if (retval)
@@ -265,7 +265,7 @@ static errcode_t ima_add_ref(ext2_irel irel, ext2_ino_t ino,
 
 static errcode_t ima_start_iter_ref(ext2_irel irel, ext2_ino_t ino)
 {
-	struct irel_ma 	*ma;
+	struct irel_ma	*ma;
 
 	ma = irel->priv_data;
 	if (ino > ma->max_inode)
@@ -280,11 +280,11 @@ static errcode_t ima_start_iter_ref(ext2_irel irel, ext2_ino_t ino)
 static errcode_t ima_next_ref(ext2_irel irel,
 			      struct ext2_inode_reference *ref)
 {
-	struct irel_ma 	*ma;
+	struct irel_ma	*ma;
 	struct inode_reference_entry *ref_ent;
 
 	ma = irel->priv_data;
-	
+
 	ref_ent = ma->ref_entries + ma->ref_current;
 
 	if ((ref_ent->refs == NULL) ||
@@ -300,19 +300,19 @@ static errcode_t ima_next_ref(ext2_irel irel,
 
 static errcode_t ima_move(ext2_irel irel, ext2_ino_t old, ext2_ino_t new)
 {
-	struct irel_ma 	*ma;
+	struct irel_ma	*ma;
 
 	ma = irel->priv_data;
 	if ((old > ma->max_inode) || (new > ma->max_inode))
 		return EXT2_ET_INVALID_ARGUMENT;
 	if (ma->entries[(unsigned) old].new == 0)
 		return ENOENT;
-	
+
 	ma->entries[(unsigned) new] = ma->entries[(unsigned) old];
 	if (ma->ref_entries[(unsigned) new].refs)
 		ext2fs_free_mem(&ma->ref_entries[(unsigned) new].refs);
 	ma->ref_entries[(unsigned) new] = ma->ref_entries[(unsigned) old];
-	
+
 	ma->entries[(unsigned) old].new = 0;
 	ma->ref_entries[(unsigned) old].num = 0;
 	ma->ref_entries[(unsigned) old].refs = 0;
@@ -323,19 +323,19 @@ static errcode_t ima_move(ext2_irel irel, ext2_ino_t old, ext2_ino_t new)
 
 static errcode_t ima_delete(ext2_irel irel, ext2_ino_t old)
 {
-	struct irel_ma 	*ma;
+	struct irel_ma	*ma;
 
 	ma = irel->priv_data;
 	if (old > ma->max_inode)
 		return EXT2_ET_INVALID_ARGUMENT;
 	if (ma->entries[(unsigned) old].new == 0)
 		return ENOENT;
-	
+
 	ma->entries[old].new = 0;
 	if (ma->ref_entries[(unsigned) old].refs)
 		ext2fs_free_mem(&ma->ref_entries[(unsigned) old].refs);
 	ma->orig_map[ma->entries[(unsigned) old].orig] = 0;
-	
+
 	ma->ref_entries[(unsigned) old].num = 0;
 	ma->ref_entries[(unsigned) old].refs = 0;
 	return 0;
@@ -343,7 +343,7 @@ static errcode_t ima_delete(ext2_irel irel, ext2_ino_t old)
 
 static errcode_t ima_free(ext2_irel irel)
 {
-	struct irel_ma 	*ma;
+	struct irel_ma	*ma;
 	ext2_ino_t	ino;
 
 	if (!irel)
diff --git a/e2fsprogs/ext2fs/ismounted.c b/e2fsprogs/ext2fs/ismounted.c
index 3f2241d23..2395ccaed 100644
--- a/e2fsprogs/ext2fs/ismounted.c
+++ b/e2fsprogs/ext2fs/ismounted.c
@@ -1,6 +1,6 @@
 /*
  * ismounted.c --- Check to see if the filesystem was mounted
- * 
+ *
  * Copyright (C) 1995,1996,1997,1998,1999,2000 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -38,17 +38,17 @@
 /*
  * Helper function which checks a file in /etc/mtab format to see if a
  * filesystem is mounted.  Returns an error if the file doesn't exist
- * or can't be opened.  
+ * or can't be opened.
  */
-static errcode_t check_mntent_file(const char *mtab_file, const char *file, 
+static errcode_t check_mntent_file(const char *mtab_file, const char *file,
 				   int *mount_flags, char *mtpt, int mtlen)
 {
-	struct mntent 	*mnt;
+	struct mntent	*mnt;
 	struct stat	st_buf;
 	errcode_t	retval = 0;
 	dev_t		file_dev=0, file_rdev=0;
 	ino_t		file_ino=0;
-	FILE 		*f;
+	FILE		*f;
 	int		fd;
 
 	*mount_flags = 0;
@@ -103,7 +103,7 @@ static errcode_t check_mntent_file(const char *mtab_file, const char *file,
 	}
 #ifndef __GNU__ /* The GNU hurd is deficient; what else is new? */
 	/* Validate the entry in case /etc/mtab is out of date */
-	/* 
+	/*
 	 * We need to be paranoid, because some broken distributions
 	 * (read: Slackware) don't initialize /etc/mtab before checking
 	 * all of the non-root filesystems on the disk.
@@ -128,7 +128,7 @@ static errcode_t check_mntent_file(const char *mtab_file, const char *file,
 	}
 #endif /* __GNU__ */
 	*mount_flags = EXT2_MF_MOUNTED;
-	
+
 #ifdef MNTOPT_RO
 	/* Check to see if the ro option is set */
 	if (hasmntopt(mnt, MNTOPT_RO))
@@ -145,7 +145,7 @@ static errcode_t check_mntent_file(const char *mtab_file, const char *file,
 	 */
 	if (!strcmp(mnt->mnt_dir, "/")) {
 is_root:
-#define TEST_FILE "/.ismount-test-file"		
+#define TEST_FILE "/.ismount-test-file"
 		*mount_flags |= EXT2_MF_ISROOT;
 		fd = open(TEST_FILE, O_RDWR|O_CREAT);
 		if (fd < 0) {
@@ -184,7 +184,7 @@ static errcode_t check_mntent(const char *file, int *mount_flags,
 #endif /* MOUNTED */
 	retval = check_mntent_file(MOUNTED, file, mount_flags, mtpt, mtlen);
 	return retval;
-#else 
+#else
 	*mount_flags = 0;
 	return 0;
 #endif /* defined(MOUNTED) || defined(_PATH_MOUNTED) */
@@ -197,31 +197,31 @@ static errcode_t check_getmntinfo(const char *file, int *mount_flags,
 				  char *mtpt, int mtlen)
 {
 	struct statfs *mp;
-        int    len, n;
-        const  char   *s1;
+	int    len, n;
+	const  char   *s1;
 	char	*s2;
 
-        n = getmntinfo(&mp, MNT_NOWAIT);
-        if (n == 0)
+	n = getmntinfo(&mp, MNT_NOWAIT);
+	if (n == 0)
 		return errno;
 
-        len = sizeof(_PATH_DEV) - 1;
-        s1 = file;
-        if (strncmp(_PATH_DEV, s1, len) == 0)
-                s1 += len;
- 
+	len = sizeof(_PATH_DEV) - 1;
+	s1 = file;
+	if (strncmp(_PATH_DEV, s1, len) == 0)
+		s1 += len;
+
 	*mount_flags = 0;
-        while (--n >= 0) {
-                s2 = mp->f_mntfromname;
-                if (strncmp(_PATH_DEV, s2, len) == 0) {
-                        s2 += len - 1;
-                        *s2 = 'r';
-                }
-                if (strcmp(s1, s2) == 0 || strcmp(s1, &s2[1]) == 0) {
+	while (--n >= 0) {
+		s2 = mp->f_mntfromname;
+		if (strncmp(_PATH_DEV, s2, len) == 0) {
+			s2 += len - 1;
+			*s2 = 'r';
+		}
+		if (strcmp(s1, s2) == 0 || strcmp(s1, &s2[1]) == 0) {
 			*mount_flags = EXT2_MF_MOUNTED;
 			break;
 		}
-                ++mp;
+		++mp;
 	}
 	if (mtpt)
 		strncpy(mtpt, mp->f_mntonname, mtlen);
@@ -270,7 +270,7 @@ static int is_swap_device(const char *file)
 			ret++;
 			break;
 		}
-#endif 	/* __GNU__ */
+#endif	/* __GNU__ */
 	}
 	fclose(f);
 	return ret;
@@ -296,7 +296,7 @@ errcode_t ext2fs_check_mount_point(const char *device, int *mount_flags,
 	}
 #ifdef HAVE_MNTENT_H
 	return check_mntent(device, mount_flags, mtpt, mtlen);
-#else 
+#else
 #ifdef HAVE_GETMNTINFO
 	return check_getmntinfo(device, mount_flags, mtpt, mtlen);
 #else
@@ -312,7 +312,7 @@ errcode_t ext2fs_check_mount_point(const char *device, int *mount_flags,
 /*
  * ext2fs_check_if_mounted() sets the mount_flags EXT2_MF_MOUNTED,
  * EXT2_MF_READONLY, and EXT2_MF_ROOT
- * 
+ *
  */
 errcode_t ext2fs_check_if_mounted(const char *file, int *mount_flags)
 {
@@ -324,7 +324,7 @@ int main(int argc, char **argv)
 {
 	int	retval, mount_flags;
 	char	mntpt[80];
-	
+
 	if (argc < 2) {
 		fprintf(stderr, "Usage: %s device\n", argv[0]);
 		exit(1);
@@ -347,12 +347,12 @@ int main(int argc, char **argv)
 
 	if (mount_flags & EXT2_MF_READONLY)
 		printf("\t%s is read-only.\n", argv[1]);
-	
+
 	if (mount_flags & EXT2_MF_ISROOT)
 		printf("\t%s is the root filesystem.\n", argv[1]);
 	if (mntpt[0])
 		printf("\t%s is mounted on %s.\n", argv[1], mntpt);
-	
+
 	exit(0);
 }
 #endif /* DEBUG */
diff --git a/e2fsprogs/ext2fs/jfs_dat.h b/e2fsprogs/ext2fs/jfs_dat.h
index d6ad9c489..8ec5d3841 100644
--- a/e2fsprogs/ext2fs/jfs_dat.h
+++ b/e2fsprogs/ext2fs/jfs_dat.h
@@ -1,6 +1,6 @@
 /*
  * jfs_dat.h --- stripped down header file which only contains the JFS
- * 	on-disk data structures
+ *	on-disk data structures
  */
 
 #define JFS_MAGIC_NUMBER 0xc03b3998U /* The first 4 bytes of /dev/random! */
@@ -9,7 +9,7 @@
  * On-disk structures
  */
 
-/* 
+/*
  * Descriptor block types:
  */
 
@@ -28,8 +28,8 @@ typedef struct journal_header_s
 } journal_header_t;
 
 
-/* 
- * The block tag: used to describe a single buffer in the journal 
+/*
+ * The block tag: used to describe a single buffer in the journal
  */
 typedef struct journal_block_tag_s
 {
@@ -55,10 +55,10 @@ typedef struct journal_superblock_s
 	__u32		s_blocksize;	/* journal device blocksize */
 	__u32		s_maxlen;	/* total blocks in journal file */
 	__u32		s_first;	/* first block of log information */
-	
+
 	/* Dynamic information describing the current state of the log */
 	__u32		s_sequence;	/* first commit ID expected in log */
 	__u32		s_start;	/* blocknr of start of log */
-	
+
 } journal_superblock_t;
 
diff --git a/e2fsprogs/ext2fs/kernel-jbd.h b/e2fsprogs/ext2fs/kernel-jbd.h
index d0efdb3f7..8a5de5e3e 100644
--- a/e2fsprogs/ext2fs/kernel-jbd.h
+++ b/e2fsprogs/ext2fs/kernel-jbd.h
@@ -1,6 +1,6 @@
 /*
  * linux/include/linux/jbd.h
- * 
+ *
  * Written by Stephen C. Tweedie <sct@redhat.com>
  *
  * Copyright 1998-2000 Red Hat, Inc --- All Rights Reserved
@@ -51,7 +51,7 @@ extern int journal_enable_debug;
 		if ((n) <= journal_enable_debug) {			\
 			printk (KERN_DEBUG "(%s, %d): %s: ",		\
 				__FILE__, __LINE__, __FUNCTION__);	\
-		  	printk (f, ## a);				\
+			printk (f, ## a);				\
 		}							\
 	} while (0)
 #else
@@ -59,7 +59,7 @@ extern int journal_enable_debug;
 #define jbd_debug(f, a...)	/**/
 #else
 #define jbd_debug(f, ...)	/**/
-#endif	
+#endif
 #endif
 #else
 #define jbd_debug(x)		/* AIX doesn't do STDC */
@@ -88,7 +88,7 @@ typedef struct journal_s	journal_t;	/* Journal control structure */
  * On-disk structures
  */
 
-/* 
+/*
  * Descriptor block types:
  */
 
@@ -109,8 +109,8 @@ typedef struct journal_header_s
 } journal_header_t;
 
 
-/* 
- * The block tag: used to describe a single buffer in the journal 
+/*
+ * The block tag: used to describe a single buffer in the journal
  */
 typedef struct journal_block_tag_s
 {
@@ -118,9 +118,9 @@ typedef struct journal_block_tag_s
 	__u32		t_flags;	/* See below */
 } journal_block_tag_t;
 
-/* 
+/*
  * The revoke descriptor: used on disk to describe a series of blocks to
- * be revoked from the log 
+ * be revoked from the log
  */
 typedef struct journal_revoke_header_s
 {
@@ -149,7 +149,7 @@ typedef struct journal_superblock_s
 	__u32	s_blocksize;		/* journal device blocksize */
 	__u32	s_maxlen;		/* total blocks in journal file */
 	__u32	s_first;		/* first block of log information */
-	
+
 /* 0x0018 */
 	/* Dynamic information describing the current state of the log */
 	__u32	s_sequence;		/* first commit ID expected in log */
@@ -161,17 +161,17 @@ typedef struct journal_superblock_s
 
 /* 0x0024 */
 	/* Remaining fields are only valid in a version-2 superblock */
-	__u32	s_feature_compat; 	/* compatible feature set */
-	__u32	s_feature_incompat; 	/* incompatible feature set */
-	__u32	s_feature_ro_compat; 	/* readonly-compatible feature set */
+	__u32	s_feature_compat;	/* compatible feature set */
+	__u32	s_feature_incompat;	/* incompatible feature set */
+	__u32	s_feature_ro_compat;	/* readonly-compatible feature set */
 /* 0x0030 */
 	__u8	s_uuid[16];		/* 128-bit uuid for journal */
 
 /* 0x0040 */
 	__u32	s_nr_users;		/* Nr of filesystems sharing log */
-	
+
 	__u32	s_dynsuper;		/* Blocknr of dynamic superblock copy*/
-	
+
 /* 0x0048 */
 	__u32	s_max_transaction;	/* Limit of journal blocks per trans.*/
 	__u32	s_max_trans_data;	/* Limit of data blocks per trans. */
@@ -276,7 +276,7 @@ struct jbd_revoke_table_s;
  * the transaction, so that at all times we know how many buffers the
  * outstanding updates on a transaction might possibly touch. */
 
-struct handle_s 
+struct handle_s
 {
 	/* Which compound transaction is this update a part of? */
 	transaction_t	      * h_transaction;
@@ -314,14 +314,14 @@ struct handle_s
  * flushed to home for finished transactions.
  */
 
-struct transaction_s 
+struct transaction_s
 {
 	/* Pointer to the journal for this transaction. */
 	journal_t *		t_journal;
-	
+
 	/* Sequence number for this transaction */
 	tid_t			t_tid;
-	
+
 	/* Transaction's current state */
 	enum {
 		T_RUNNING,
@@ -329,74 +329,74 @@ struct transaction_s
 		T_RUNDOWN,
 		T_FLUSH,
 		T_COMMIT,
-		T_FINISHED 
+		T_FINISHED
 	}			t_state;
 
 	/* Where in the log does this transaction's commit start? */
 	unsigned long		t_log_start;
-	
+
 	/* Doubly-linked circular list of all inodes owned by this
-           transaction */	/* AKPM: unused */
+	   transaction */	/* AKPM: unused */
 	struct inode *		t_ilist;
-	
+
 	/* Number of buffers on the t_buffers list */
 	int			t_nr_buffers;
-	
+
 	/* Doubly-linked circular list of all buffers reserved but not
-           yet modified by this transaction */
+	   yet modified by this transaction */
 	struct journal_head *	t_reserved_list;
-	
+
 	/* Doubly-linked circular list of all metadata buffers owned by this
-           transaction */
+	   transaction */
 	struct journal_head *	t_buffers;
-	
+
 	/*
 	 * Doubly-linked circular list of all data buffers still to be
 	 * flushed before this transaction can be committed.
 	 * Protected by journal_datalist_lock.
 	 */
 	struct journal_head *	t_sync_datalist;
-	
+
 	/*
 	 * Doubly-linked circular list of all writepage data buffers
 	 * still to be written before this transaction can be committed.
 	 * Protected by journal_datalist_lock.
 	 */
 	struct journal_head *	t_async_datalist;
-	
+
 	/* Doubly-linked circular list of all forget buffers (superceded
-           buffers which we can un-checkpoint once this transaction
-           commits) */
+	   buffers which we can un-checkpoint once this transaction
+	   commits) */
 	struct journal_head *	t_forget;
-	
+
 	/*
 	 * Doubly-linked circular list of all buffers still to be
 	 * flushed before this transaction can be checkpointed.
 	 */
 	/* Protected by journal_datalist_lock */
 	struct journal_head *	t_checkpoint_list;
-	
+
 	/* Doubly-linked circular list of temporary buffers currently
-           undergoing IO in the log */
+	   undergoing IO in the log */
 	struct journal_head *	t_iobuf_list;
-	
+
 	/* Doubly-linked circular list of metadata buffers being
-           shadowed by log IO.  The IO buffers on the iobuf list and the
-           shadow buffers on this list match each other one for one at
-           all times. */
+	   shadowed by log IO.  The IO buffers on the iobuf list and the
+	   shadow buffers on this list match each other one for one at
+	   all times. */
 	struct journal_head *	t_shadow_list;
-	
+
 	/* Doubly-linked circular list of control buffers being written
-           to the log. */
+	   to the log. */
 	struct journal_head *	t_log_list;
-	
+
 	/* Number of outstanding updates running on this transaction */
 	int			t_updates;
 
 	/* Number of buffers reserved for use by all handles in this
 	 * transaction handle but not yet modified. */
 	int			t_outstanding_credits;
-	
+
 	/*
 	 * Forward and backward links for the circular list of all
 	 * transactions awaiting checkpoint.
@@ -415,7 +415,7 @@ struct transaction_s
 
 /* The journal_t maintains all of the journaling state information for a
  * single filesystem.  It is linked to from the fs superblock structure.
- * 
+ *
  * We use the journal_t to keep track of all outstanding transaction
  * activity on the filesystem, and to manage the state of the log
  * writing process. */
@@ -428,7 +428,7 @@ struct journal_s
 	/* Is there an outstanding uncleared error on the journal (from
 	 * a prior abort)? */
 	int			j_errno;
-	
+
 	/* The superblock buffer */
 	struct buffer_head *	j_sb_buffer;
 	journal_superblock_t *	j_superblock;
@@ -438,49 +438,49 @@ struct journal_s
 
 	/* Number of processes waiting to create a barrier lock */
 	int			j_barrier_count;
-	
+
 	/* The barrier lock itself */
 	struct semaphore	j_barrier;
-	
+
 	/* Transactions: The current running transaction... */
 	transaction_t *		j_running_transaction;
-	
+
 	/* ... the transaction we are pushing to disk ... */
 	transaction_t *		j_committing_transaction;
-	
+
 	/* ... and a linked circular list of all transactions waiting
 	 * for checkpointing. */
 	/* Protected by journal_datalist_lock */
 	transaction_t *		j_checkpoint_transactions;
 
 	/* Wait queue for waiting for a locked transaction to start
-           committing, or for a barrier lock to be released */
+	   committing, or for a barrier lock to be released */
 	wait_queue_head_t	j_wait_transaction_locked;
-	
+
 	/* Wait queue for waiting for checkpointing to complete */
 	wait_queue_head_t	j_wait_logspace;
-	
+
 	/* Wait queue for waiting for commit to complete */
 	wait_queue_head_t	j_wait_done_commit;
-	
+
 	/* Wait queue to trigger checkpointing */
 	wait_queue_head_t	j_wait_checkpoint;
-	
+
 	/* Wait queue to trigger commit */
 	wait_queue_head_t	j_wait_commit;
-	
+
 	/* Wait queue to wait for updates to complete */
 	wait_queue_head_t	j_wait_updates;
 
 	/* Semaphore for locking against concurrent checkpoints */
-	struct semaphore 	j_checkpoint_sem;
+	struct semaphore	j_checkpoint_sem;
 
 	/* The main journal lock, used by lock_journal() */
 	struct semaphore	j_sem;
-		
+
 	/* Journal head: identifies the first unused block in the journal. */
 	unsigned long		j_head;
-	
+
 	/* Journal tail: identifies the oldest still-used block in the
 	 * journal. */
 	unsigned long		j_tail;
@@ -546,12 +546,12 @@ struct journal_s
 	struct list_head	j_all_journals;
 
 	/* The revoke table: maintains the list of revoked blocks in the
-           current transaction. */
+	   current transaction. */
 	struct jbd_revoke_table_s *j_revoke;
 };
 
-/* 
- * Journal flag definitions 
+/*
+ * Journal flag definitions
  */
 #define JFS_UNMOUNT	0x001	/* Journal thread is being destroyed */
 #define JFS_ABORT	0x002	/* Journaling has been aborted for errors. */
@@ -559,7 +559,7 @@ struct journal_s
 #define JFS_FLUSHED	0x008	/* The journal superblock has been flushed */
 #define JFS_LOADED	0x010	/* The journal superblock has been loaded */
 
-/* 
+/*
  * Function declarations for the journaling transaction and buffer
  * management
  */
@@ -589,7 +589,7 @@ extern void journal_insert_checkpoint(struct journal_head *, transaction_t *);
 extern void __journal_insert_checkpoint(struct journal_head *,transaction_t *);
 
 /* Buffer IO */
-extern int 
+extern int
 journal_write_metadata_buffer(transaction_t	  *transaction,
 			      struct journal_head  *jh_in,
 			      struct journal_head **jh_out,
@@ -603,7 +603,7 @@ extern void		__wait_on_journal (journal_t *);
  *
  * We need to lock the journal during transaction state changes so that
  * nobody ever tries to take a handle on the running transaction while
- * we are in the middle of moving it to the commit phase.  
+ * we are in the middle of moving it to the commit phase.
  *
  * Note that the locking is completely interrupt unsafe.  We never touch
  * journal structures from interrupts.
@@ -637,7 +637,7 @@ static inline handle_t *journal_current_handle(void)
 /* The journaling code user interface:
  *
  * Create and destroy handles
- * Register buffer modifications against the current transaction. 
+ * Register buffer modifications against the current transaction.
  */
 
 extern handle_t *journal_start(journal_t *, int nblocks);
@@ -665,11 +665,11 @@ extern journal_t * journal_init_dev(kdev_t dev, kdev_t fs_dev,
 				int start, int len, int bsize);
 extern journal_t * journal_init_inode (struct inode *);
 extern int	   journal_update_format (journal_t *);
-extern int	   journal_check_used_features 
+extern int	   journal_check_used_features
 		   (journal_t *, unsigned long, unsigned long, unsigned long);
-extern int	   journal_check_available_features 
+extern int	   journal_check_available_features
 		   (journal_t *, unsigned long, unsigned long, unsigned long);
-extern int	   journal_set_features 
+extern int	   journal_set_features
 		   (journal_t *, unsigned long, unsigned long, unsigned long);
 extern int	   journal_create     (journal_t *);
 extern int	   journal_load       (journal_t *journal);
@@ -747,7 +747,7 @@ do {								      \
  * bit, when set, indicates that we have had a fatal error somewhere,
  * either inside the journaling layer or indicated to us by the client
  * (eg. ext3), and that we and should not commit any further
- * transactions.  
+ * transactions.
  */
 
 static inline int is_journal_aborted(journal_t *journal)
@@ -770,7 +770,7 @@ static inline void journal_abort_handle(handle_t *handle)
 /* Not all architectures define BUG() */
 #ifndef BUG
 #define BUG() do { \
-        printk("kernel BUG at %s:%d!\n", __FILE__, __LINE__); \
+	printk("kernel BUG at %s:%d!\n", __FILE__, __LINE__); \
 	* ((char *) 0) = 0; \
  } while (0)
 #endif /* BUG */
@@ -826,7 +826,7 @@ extern int journal_blocks_per_page(struct inode *inode);
 #define BJ_LogCtl	7	/* Buffer contains log descriptors */
 #define BJ_Reserved	8	/* Buffer is reserved for access by journal */
 #define BJ_Types	9
- 
+
 extern int jbd_blocks_per_page(struct inode *inode);
 
 #ifdef __KERNEL__
diff --git a/e2fsprogs/ext2fs/kernel-list.h b/e2fsprogs/ext2fs/kernel-list.h
index 24e6ab4a1..fa62ff138 100644
--- a/e2fsprogs/ext2fs/kernel-list.h
+++ b/e2fsprogs/ext2fs/kernel-list.h
@@ -29,7 +29,7 @@ struct list_head {
 #endif
 
 /*
- * Insert a new entry between two known consecutive entries. 
+ * Insert a new entry between two known consecutive entries.
  *
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
@@ -107,6 +107,6 @@ static __inline__ void list_splice(struct list_head *list, struct list_head *hea
 	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
 
 #define list_for_each(pos, head) \
-        for (pos = (head)->next; pos != (head); pos = pos->next)
+	for (pos = (head)->next; pos != (head); pos = pos->next)
 
 #endif
diff --git a/e2fsprogs/ext2fs/link.c b/e2fsprogs/ext2fs/link.c
index 5e0f4f3c0..281ad065f 100644
--- a/e2fsprogs/ext2fs/link.c
+++ b/e2fsprogs/ext2fs/link.c
@@ -1,6 +1,6 @@
 /*
  * link.c --- create links in a ext2fs directory
- * 
+ *
  * Copyright (C) 1993, 1994 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -25,7 +25,7 @@ struct link_struct  {
 	int		flags;
 	int		done;
 	struct ext2_super_block *sb;
-};	
+};
 
 static int link_proc(struct ext2_dir_entry *dirent,
 		     int	offset,
@@ -94,7 +94,7 @@ static int link_proc(struct ext2_dir_entry *dirent,
 #ifdef __TURBOC__
  #pragma argsused
 #endif
-errcode_t ext2fs_link(ext2_filsys fs, ext2_ino_t dir, const char *name, 
+errcode_t ext2fs_link(ext2_filsys fs, ext2_ino_t dir, const char *name,
 		      ext2_ino_t ino, int flags)
 {
 	errcode_t		retval;
diff --git a/e2fsprogs/ext2fs/lookup.c b/e2fsprogs/ext2fs/lookup.c
index 1745f33ab..9cb97f1b5 100644
--- a/e2fsprogs/ext2fs/lookup.c
+++ b/e2fsprogs/ext2fs/lookup.c
@@ -1,6 +1,6 @@
 /*
  * lookup.c --- ext2fs directory lookup operations
- * 
+ *
  * Copyright (C) 1993, 1994, 1994, 1995 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -23,7 +23,7 @@ struct lookup_struct  {
 	int		len;
 	ext2_ino_t	*inode;
 	int		found;
-};	
+};
 
 #ifdef __TURBOC__
  #pragma argsused
diff --git a/e2fsprogs/ext2fs/mkdir.c b/e2fsprogs/ext2fs/mkdir.c
index 81e7aea58..bf46e5050 100644
--- a/e2fsprogs/ext2fs/mkdir.c
+++ b/e2fsprogs/ext2fs/mkdir.c
@@ -1,6 +1,6 @@
 /*
  * mkdir.c --- make a directory in the filesystem
- * 
+ *
  * Copyright (C) 1994, 1995 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -94,7 +94,7 @@ errcode_t ext2fs_mkdir(ext2_filsys fs, ext2_ino_t parent, ext2_ino_t inum,
 	retval = ext2fs_write_dir_block(fs, blk, block);
 	if (retval)
 		goto cleanup;
-	retval = ext2fs_write_new_inode(fs, ino, &inode); 
+	retval = ext2fs_write_new_inode(fs, ino, &inode);
 	if (retval)
 		goto cleanup;
 
@@ -125,7 +125,7 @@ errcode_t ext2fs_mkdir(ext2_filsys fs, ext2_ino_t parent, ext2_ino_t inum,
 		if (retval)
 			goto cleanup;
 	}
-	
+
 	/*
 	 * Update accounting....
 	 */
diff --git a/e2fsprogs/ext2fs/mkjournal.c b/e2fsprogs/ext2fs/mkjournal.c
index b748918b6..0a9ae7a4d 100644
--- a/e2fsprogs/ext2fs/mkjournal.c
+++ b/e2fsprogs/ext2fs/mkjournal.c
@@ -2,7 +2,7 @@
  * mkjournal.c --- make a journal for a filesystem
  *
  * Copyright (C) 2000 Theodore Ts'o.
- * 
+ *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
  * License.
@@ -155,7 +155,7 @@ static int mkjournal_proc(ext2_filsys	fs,
 	blk_t	new_blk;
 	static blk_t	last_blk = 0;
 	errcode_t	retval;
-	
+
 	if (*blocknr) {
 		last_blk = *blocknr;
 		return 0;
@@ -186,7 +186,7 @@ static int mkjournal_proc(ext2_filsys	fs,
 		return (BLOCK_CHANGED | BLOCK_ABORT);
 	else
 		return BLOCK_CHANGED;
-	
+
 }
 
 /*
@@ -202,7 +202,7 @@ static errcode_t write_journal_inode(ext2_filsys fs, ext2_ino_t journal_ino,
 
 	if ((retval = ext2fs_create_journal_superblock(fs, size, flags, &buf)))
 		return retval;
-	
+
 	if ((retval = ext2fs_read_bitmaps(fs)))
 		return retval;
 
@@ -227,7 +227,7 @@ static errcode_t write_journal_inode(ext2_filsys fs, ext2_ino_t journal_ino,
 	if ((retval = ext2fs_read_inode(fs, journal_ino, &inode)))
 		goto errout;
 
- 	inode.i_size += fs->blocksize * size;
+	inode.i_size += fs->blocksize * size;
 	inode.i_blocks += (fs->blocksize / 512) * es.newblocks;
 	inode.i_mtime = inode.i_ctime = time(0);
 	inode.i_links_count = 1;
@@ -262,7 +262,7 @@ errcode_t ext2fs_add_journal_device(ext2_filsys fs, ext2_filsys journal_dev)
 	/* Make sure the device exists and is a block device */
 	if (stat(journal_dev->device_name, &st) < 0)
 		return errno;
-	
+
 	if (!S_ISBLK(st.st_mode))
 		return EXT2_ET_JOURNAL_NOT_BLOCK; /* Must be a block device */
 
@@ -297,7 +297,7 @@ errcode_t ext2fs_add_journal_device(ext2_filsys fs, ext2_filsys journal_dev)
 	/* Writeback the journal superblock */
 	if ((retval = io_channel_write_blk(journal_dev->io, start, -1024, buf)))
 		return retval;
-	
+
 	fs->super->s_journal_inum = 0;
 	fs->super->s_journal_dev = st.st_rdev;
 	memcpy(fs->super->s_journal_uuid, jsb->s_uuid,
@@ -328,7 +328,7 @@ errcode_t ext2fs_add_journal_inode(ext2_filsys fs, blk_t size, int flags)
 		strcat(jfile, "/.journal");
 
 		/*
-		 * If .../.journal already exists, make sure any 
+		 * If .../.journal already exists, make sure any
 		 * immutable or append-only flags are cleared.
 		 */
 #if defined(HAVE_CHFLAGS) && defined(UF_NODUMP)
@@ -350,7 +350,7 @@ errcode_t ext2fs_add_journal_inode(ext2_filsys fs, blk_t size, int flags)
 
 		if ((retval = write_journal_file(fs, jfile, size, flags)))
 			goto errout;
-		
+
 		/* Get inode number of the journal file */
 		if (fstat(fd, &st) < 0)
 			goto errout;
@@ -365,7 +365,7 @@ errcode_t ext2fs_add_journal_inode(ext2_filsys fs, blk_t size, int flags)
 #endif
 		if (retval)
 			goto errout;
-		
+
 		close(fd);
 		journal_ino = st.st_ino;
 	} else {
@@ -374,7 +374,7 @@ errcode_t ext2fs_add_journal_inode(ext2_filsys fs, blk_t size, int flags)
 						  size, flags)))
 			return retval;
 	}
-	
+
 	fs->super->s_journal_inum = journal_ino;
 	fs->super->s_journal_dev = 0;
 	memset(fs->super->s_journal_uuid, 0,
@@ -393,14 +393,14 @@ main(int argc, char **argv)
 {
 	errcode_t	retval;
 	char		*device_name;
-	ext2_filsys 	fs;
+	ext2_filsys	fs;
 
 	if (argc < 2) {
 		fprintf(stderr, "Usage: %s filesystem\n", argv[0]);
 		exit(1);
 	}
 	device_name = argv[1];
-	
+
 	retval = ext2fs_open (device_name, EXT2_FLAG_RW, 0, 0,
 			      unix_io_manager, &fs);
 	if (retval) {
@@ -420,6 +420,6 @@ main(int argc, char **argv)
 	}
 	ext2fs_close(fs);
 	exit(0);
-	
+
 }
 #endif
diff --git a/e2fsprogs/ext2fs/namei.c b/e2fsprogs/ext2fs/namei.c
index 13d13adfe..6ce4bb363 100644
--- a/e2fsprogs/ext2fs/namei.c
+++ b/e2fsprogs/ext2fs/namei.c
@@ -1,6 +1,6 @@
 /*
  * namei.c --- ext2fs directory lookup operations
- * 
+ *
  * Copyright (C) 1993, 1994, 1994, 1995 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -36,7 +36,7 @@ static errcode_t follow_link(ext2_filsys fs, ext2_ino_t root, ext2_ino_t dir,
 #ifdef NAMEI_DEBUG
 	printf("follow_link: root=%lu, dir=%lu, inode=%lu, lc=%d\n",
 	       root, dir, inode, link_count);
-	
+
 #endif
 	retval = ext2fs_read_inode (fs, inode, &ei);
 	if (retval) return retval;
@@ -85,12 +85,12 @@ static errcode_t dir_namei(ext2_filsys fs, ext2_ino_t root, ext2_ino_t dir,
 	errcode_t retval;
 
 	if ((c = *pathname) == '/') {
-        	dir = root;
+		dir = root;
 		pathname++;
 		pathlen--;
 	}
 	while (1) {
-        	thisname = pathname;
+		thisname = pathname;
 		for (len=0; --pathlen >= 0;len++) {
 			c = *(pathname++);
 			if (c == '/')
@@ -100,10 +100,10 @@ static errcode_t dir_namei(ext2_filsys fs, ext2_ino_t root, ext2_ino_t dir,
 			break;
 		retval = ext2fs_lookup (fs, dir, thisname, len, buf, &inode);
 		if (retval) return retval;
-        	retval = follow_link (fs, root, dir, inode,
+		retval = follow_link (fs, root, dir, inode,
 				      link_count, buf, &dir);
-        	if (retval) return retval;
-    	}
+		if (retval) return retval;
+	}
 	*name = thisname;
 	*namelen = len;
 	*res_inode = dir;
@@ -152,13 +152,13 @@ errcode_t ext2fs_namei(ext2_filsys fs, ext2_ino_t root, ext2_ino_t cwd,
 {
 	char *buf;
 	errcode_t retval;
-	
+
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	retval = ext2fs_get_mem(fs->blocksize, &buf);
 	if (retval)
 		return retval;
-	
+
 	retval = open_namei(fs, root, cwd, name, strlen(name), 0, 0,
 			    buf, inode);
 
@@ -171,13 +171,13 @@ errcode_t ext2fs_namei_follow(ext2_filsys fs, ext2_ino_t root, ext2_ino_t cwd,
 {
 	char *buf;
 	errcode_t retval;
-	
+
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	retval = ext2fs_get_mem(fs->blocksize, &buf);
 	if (retval)
 		return retval;
-	
+
 	retval = open_namei(fs, root, cwd, name, strlen(name), 1, 0,
 			    buf, inode);
 
@@ -190,7 +190,7 @@ errcode_t ext2fs_follow_link(ext2_filsys fs, ext2_ino_t root, ext2_ino_t cwd,
 {
 	char *buf;
 	errcode_t retval;
-	
+
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	retval = ext2fs_get_mem(fs->blocksize, &buf);
diff --git a/e2fsprogs/ext2fs/newdir.c b/e2fsprogs/ext2fs/newdir.c
index 3904d9112..27c718ea5 100644
--- a/e2fsprogs/ext2fs/newdir.c
+++ b/e2fsprogs/ext2fs/newdir.c
@@ -1,6 +1,6 @@
 /*
  * newdir.c --- create a new directory block
- * 
+ *
  * Copyright (C) 1994, 1995 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -28,7 +28,7 @@
 errcode_t ext2fs_new_dir_block(ext2_filsys fs, ext2_ino_t dir_ino,
 			       ext2_ino_t parent_ino, char **block)
 {
-	struct ext2_dir_entry 	*dir = NULL;
+	struct ext2_dir_entry	*dir = NULL;
 	errcode_t		retval;
 	char			*buf;
 	int			rec_len;
@@ -65,7 +65,7 @@ errcode_t ext2fs_new_dir_block(ext2_filsys fs, ext2_ino_t dir_ino,
 		dir->name_len = 2 | filetype;
 		dir->name[0] = '.';
 		dir->name[1] = '.';
-		
+
 	}
 	*block = buf;
 	return 0;
diff --git a/e2fsprogs/ext2fs/openfs.c b/e2fsprogs/ext2fs/openfs.c
index e8f16495d..aa603337d 100644
--- a/e2fsprogs/ext2fs/openfs.c
+++ b/e2fsprogs/ext2fs/openfs.c
@@ -1,8 +1,8 @@
 /*
  * openfs.c --- open an ext2 filesystem
- * 
+ *
  * Copyright (C) 1993, 1994, 1995, 1996 Theodore Ts'o.
- * 
+ *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
  * License.
@@ -42,7 +42,7 @@ blk_t ext2fs_descriptor_block_loc(ext2_filsys fs, blk_t group_block, dgrp_t i)
 	bg = (fs->blocksize / sizeof (struct ext2_group_desc)) * i;
 	if (ext2fs_bg_has_super(fs, bg))
 		has_super = 1;
-	ret_blk = (fs->super->s_first_data_block + has_super + 
+	ret_blk = (fs->super->s_first_data_block + has_super +
 		   (bg * fs->super->s_blocks_per_group));
 	/*
 	 * If group_block is not the normal value, we're trying to use
@@ -60,27 +60,27 @@ blk_t ext2fs_descriptor_block_loc(ext2_filsys fs, blk_t group_block, dgrp_t i)
 }
 
 errcode_t ext2fs_open(const char *name, int flags, int superblock,
-		      unsigned int block_size, io_manager manager, 
+		      unsigned int block_size, io_manager manager,
 		      ext2_filsys *ret_fs)
 {
-	return ext2fs_open2(name, 0, flags, superblock, block_size, 
+	return ext2fs_open2(name, 0, flags, superblock, block_size,
 			    manager, ret_fs);
 }
 
 /*
  *  Note: if superblock is non-zero, block-size must also be non-zero.
- * 	Superblock and block_size can be zero to use the default size.
+ *	Superblock and block_size can be zero to use the default size.
  *
  * Valid flags for ext2fs_open()
- * 
- * 	EXT2_FLAG_RW	- Open the filesystem for read/write.
- * 	EXT2_FLAG_FORCE - Open the filesystem even if some of the
+ *
+ *	EXT2_FLAG_RW	- Open the filesystem for read/write.
+ *	EXT2_FLAG_FORCE - Open the filesystem even if some of the
  *				features aren't supported.
  *	EXT2_FLAG_JOURNAL_DEV_OK - Open an ext3 journal device
  */
 errcode_t ext2fs_open2(const char *name, const char *io_options,
 		       int flags, int superblock,
-		       unsigned int block_size, io_manager manager, 
+		       unsigned int block_size, io_manager manager,
 		       ext2_filsys *ret_fs)
 {
 	ext2_filsys	fs;
@@ -93,13 +93,13 @@ errcode_t ext2fs_open2(const char *name, const char *io_options,
 	int j;
 	struct ext2_group_desc *gdp;
 #endif
-	
+
 	EXT2_CHECK_MAGIC(manager, EXT2_ET_MAGIC_IO_MANAGER);
 
 	retval = ext2fs_get_mem(sizeof(struct struct_ext2_filsys), &fs);
 	if (retval)
 		return retval;
-	
+
 	memset(fs, 0, sizeof(struct struct_ext2_filsys));
 	fs->magic = EXT2_ET_MAGIC_EXT2FS_FILSYS;
 	fs->flags = flags;
@@ -113,13 +113,13 @@ errcode_t ext2fs_open2(const char *name, const char *io_options,
 		*cp++ = 0;
 		io_options = cp;
 	}
-		
-	retval = manager->open(fs->device_name, 
+
+	retval = manager->open(fs->device_name,
 			       (flags & EXT2_FLAG_RW) ? IO_FLAG_RW : 0,
 			       &fs->io);
 	if (retval)
 		goto cleanup;
-	if (io_options && 
+	if (io_options &&
 	    (retval = io_channel_set_options(fs->io, io_options)))
 		goto cleanup;
 	fs->image_io = fs->io;
@@ -183,7 +183,7 @@ errcode_t ext2fs_open2(const char *name, const char *io_options,
 		ext2fs_swap_super(fs->super);
 	}
 #endif
-	
+
 	if (fs->super->s_magic != EXT2_SUPER_MAGIC) {
 		retval = EXT2_ET_BAD_MAGIC;
 		goto cleanup;
@@ -215,7 +215,7 @@ errcode_t ext2fs_open2(const char *name, const char *io_options,
 			goto cleanup;
 		}
 	}
-	
+
 	fs->blocksize = EXT2_BLOCK_SIZE(fs->super);
 	if (fs->blocksize == 0) {
 		retval = EXT2_ET_CORRUPT_SUPERBLOCK;
@@ -247,7 +247,7 @@ errcode_t ext2fs_open2(const char *name, const char *io_options,
 		*ret_fs = fs;
 		return 0;
 	}
-	
+
 	/*
 	 * Read group descriptors
 	 */
@@ -296,7 +296,7 @@ cleanup:
 
 /*
  * Set/get the filesystem data I/O channel.
- * 
+ *
  * These functions are only valid if EXT2_FLAG_IMAGE_FILE is true.
  */
 errcode_t ext2fs_get_data_io(ext2_filsys fs, io_channel *old_io)
@@ -322,7 +322,7 @@ errcode_t ext2fs_rewrite_to_io(ext2_filsys fs, io_channel new_io)
 	if ((fs->flags & EXT2_FLAG_IMAGE_FILE) == 0)
 		return EXT2_ET_NOT_IMAGE_FILE;
 	fs->io = fs->image_io = new_io;
-	fs->flags |= EXT2_FLAG_DIRTY | EXT2_FLAG_RW | 
+	fs->flags |= EXT2_FLAG_DIRTY | EXT2_FLAG_RW |
 		EXT2_FLAG_BB_DIRTY | EXT2_FLAG_IB_DIRTY;
 	fs->flags &= ~EXT2_FLAG_IMAGE_FILE;
 	return 0;
diff --git a/e2fsprogs/ext2fs/read_bb.c b/e2fsprogs/ext2fs/read_bb.c
index c717adcd2..226c5375a 100644
--- a/e2fsprogs/ext2fs/read_bb.c
+++ b/e2fsprogs/ext2fs/read_bb.c
@@ -38,16 +38,16 @@ struct read_bb_record {
  #pragma argsused
 #endif
 static int mark_bad_block(ext2_filsys fs, blk_t *block_nr,
-			  e2_blkcnt_t blockcnt EXT2FS_ATTR((unused)), 
+			  e2_blkcnt_t blockcnt EXT2FS_ATTR((unused)),
 			  blk_t ref_block EXT2FS_ATTR((unused)),
-			  int ref_offset EXT2FS_ATTR((unused)), 
+			  int ref_offset EXT2FS_ATTR((unused)),
 			  void *priv_data)
 {
 	struct read_bb_record *rb = (struct read_bb_record *) priv_data;
-	
+
 	if (blockcnt < 0)
 		return 0;
-	
+
 	if ((*block_nr < fs->super->s_first_data_block) ||
 	    (*block_nr >= fs->super->s_blocks_count))
 		return 0;	/* Ignore illegal blocks */
diff --git a/e2fsprogs/ext2fs/read_bb_file.c b/e2fsprogs/ext2fs/read_bb_file.c
index 40c34ee3c..f7851f143 100644
--- a/e2fsprogs/ext2fs/read_bb_file.c
+++ b/e2fsprogs/ext2fs/read_bb_file.c
@@ -29,7 +29,7 @@
 /*
  * Reads a list of bad blocks from  a FILE *
  */
-errcode_t ext2fs_read_bb_FILE2(ext2_filsys fs, FILE *f, 
+errcode_t ext2fs_read_bb_FILE2(ext2_filsys fs, FILE *f,
 			       ext2_badblocks_list *bb_list,
 			       void *priv_data,
 			       void (*invalid)(ext2_filsys fs,
@@ -72,7 +72,7 @@ errcode_t ext2fs_read_bb_FILE2(ext2_filsys fs, FILE *f,
 }
 
 static void call_compat_invalid(ext2_filsys fs, blk_t blk,
-				char *badstr EXT2FS_ATTR((unused)), 
+				char *badstr EXT2FS_ATTR((unused)),
 				void *priv_data)
 {
 	void (*invalid)(ext2_filsys, blk_t);
@@ -86,7 +86,7 @@ static void call_compat_invalid(ext2_filsys fs, blk_t blk,
 /*
  * Reads a list of bad blocks from  a FILE *
  */
-errcode_t ext2fs_read_bb_FILE(ext2_filsys fs, FILE *f, 
+errcode_t ext2fs_read_bb_FILE(ext2_filsys fs, FILE *f,
 			      ext2_badblocks_list *bb_list,
 			      void (*invalid)(ext2_filsys fs, blk_t blk))
 {
diff --git a/e2fsprogs/ext2fs/rs_bitmap.c b/e2fsprogs/ext2fs/rs_bitmap.c
index 46653f0ec..c2e51e021 100644
--- a/e2fsprogs/ext2fs/rs_bitmap.c
+++ b/e2fsprogs/ext2fs/rs_bitmap.c
@@ -53,7 +53,7 @@ errcode_t ext2fs_resize_generic_bitmap(__u32 new_end, __u32 new_real_end,
 		bmap->end = new_end;
 		return 0;
 	}
-	
+
 	size = ((bmap->real_end - bmap->start) / 8) + 1;
 	new_size = ((new_real_end - bmap->start) / 8) + 1;
 
@@ -74,7 +74,7 @@ errcode_t ext2fs_resize_inode_bitmap(__u32 new_end, __u32 new_real_end,
 				     ext2fs_inode_bitmap bmap)
 {
 	errcode_t	retval;
-	
+
 	if (!bmap)
 		return EXT2_ET_INVALID_ARGUMENT;
 
@@ -91,7 +91,7 @@ errcode_t ext2fs_resize_block_bitmap(__u32 new_end, __u32 new_real_end,
 				     ext2fs_block_bitmap bmap)
 {
 	errcode_t	retval;
-	
+
 	if (!bmap)
 		return EXT2_ET_INVALID_ARGUMENT;
 
diff --git a/e2fsprogs/ext2fs/rw_bitmaps.c b/e2fsprogs/ext2fs/rw_bitmaps.c
index b67a92599..ae7b6e0cf 100644
--- a/e2fsprogs/ext2fs/rw_bitmaps.c
+++ b/e2fsprogs/ext2fs/rw_bitmaps.c
@@ -45,7 +45,7 @@ static void ext2fs_swap_bitmap(ext2_filsys fs, char *bitmap, int nbytes)
 {
 	__u32 *p = (__u32 *) bitmap;
 	int n;
-		
+
 	for (n = nbytes / sizeof(__u32); n > 0; --n, ++p)
 		*p = ext2fs_swab32(*p);
 }
@@ -53,7 +53,7 @@ static void ext2fs_swap_bitmap(ext2_filsys fs, char *bitmap, int nbytes)
 
 errcode_t ext2fs_write_inode_bitmap(ext2_filsys fs)
 {
-	dgrp_t 		i;
+	dgrp_t		i;
 	size_t		nbytes;
 	errcode_t	retval;
 	char * inode_bitmap = fs->inode_map->bitmap;
@@ -67,7 +67,7 @@ errcode_t ext2fs_write_inode_bitmap(ext2_filsys fs)
 	if (!inode_bitmap)
 		return 0;
 	nbytes = (size_t) ((EXT2_INODES_PER_GROUP(fs->super)+7) / 8);
-	
+
 	retval = ext2fs_get_mem(fs->blocksize, &bitmap_block);
 	if (retval)
 		return retval;
@@ -95,7 +95,7 @@ errcode_t ext2fs_write_inode_bitmap(ext2_filsys fs)
 
 errcode_t ext2fs_write_block_bitmap (ext2_filsys fs)
 {
-	dgrp_t 		i;
+	dgrp_t		i;
 	unsigned int	j;
 	int		nbytes;
 	unsigned int	nbits;
@@ -195,7 +195,7 @@ static errcode_t read_bitmaps(ext2_filsys fs, int do_inode, int do_block)
 		if (block_bitmap) {
 			blk = (fs->image_header->offset_blockmap /
 			       fs->blocksize);
-			retval = io_channel_read_blk(fs->image_io, blk, 
+			retval = io_channel_read_blk(fs->image_io, blk,
 			     -(block_nbytes * fs->group_desc_count),
 			     block_bitmap);
 			if (retval)
@@ -243,7 +243,7 @@ static errcode_t read_bitmaps(ext2_filsys fs, int do_inode, int do_block)
 		}
 	}
 	return 0;
-	
+
 cleanup:
 	if (do_block) {
 		ext2fs_free_mem(&fs->block_map);
@@ -296,5 +296,5 @@ errcode_t ext2fs_write_bitmaps(ext2_filsys fs)
 			return retval;
 	}
 	return 0;
-}	
+}
 
diff --git a/e2fsprogs/ext2fs/swapfs.c b/e2fsprogs/ext2fs/swapfs.c
index 8a0899515..af8b6eb87 100644
--- a/e2fsprogs/ext2fs/swapfs.c
+++ b/e2fsprogs/ext2fs/swapfs.c
@@ -1,6 +1,6 @@
 /*
  * swapfs.c --- swap ext2 filesystem data structures
- * 
+ *
  * Copyright (C) 1995, 1996, 2002 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -23,7 +23,7 @@
 #ifdef EXT2FS_ENABLE_SWAPFS
 void ext2fs_swap_super(struct ext2_super_block * sb)
 {
-  	int i;
+	int i;
 	sb->s_inodes_count = ext2fs_swab32(sb->s_inodes_count);
 	sb->s_blocks_count = ext2fs_swab32(sb->s_blocks_count);
 	sb->s_r_blocks_count = ext2fs_swab32(sb->s_r_blocks_count);
@@ -108,11 +108,11 @@ void ext2fs_swap_ext_attr(char *to, char *from, int bufsize, int has_header)
 	}
 
 	while ((char *)from_entry < from_end && *(__u32 *)from_entry) {
-		to_entry->e_value_offs  =	
+		to_entry->e_value_offs  =
 			ext2fs_swab16(from_entry->e_value_offs);
-		to_entry->e_value_block =	
+		to_entry->e_value_block =
 			ext2fs_swab32(from_entry->e_value_block);
-		to_entry->e_value_size  =	
+		to_entry->e_value_size  =
 			ext2fs_swab32(from_entry->e_value_size);
 		from_entry = EXT2_EXT_ATTR_NEXT(from_entry);
 		to_entry   = EXT2_EXT_ATTR_NEXT(to_entry);
diff --git a/e2fsprogs/ext2fs/test_io.c b/e2fsprogs/ext2fs/test_io.c
index 6a3b248e9..d4b36532f 100644
--- a/e2fsprogs/ext2fs/test_io.c
+++ b/e2fsprogs/ext2fs/test_io.c
@@ -32,7 +32,7 @@
 
 #define EXT2_CHECK_MAGIC(struct, code) \
 	  if ((struct)->magic != (code)) return (code)
-  
+
 struct test_private_data {
 	int	magic;
 	io_channel real;
@@ -56,7 +56,7 @@ static errcode_t test_write_blk(io_channel channel, unsigned long block,
 static errcode_t test_flush(io_channel channel);
 static errcode_t test_write_byte(io_channel channel, unsigned long offset,
 				 int count, const void *buf);
-static errcode_t test_set_option(io_channel channel, const char *option, 
+static errcode_t test_set_option(io_channel channel, const char *option,
 				 const char *arg);
 
 static struct struct_io_manager struct_test_manager = {
@@ -172,10 +172,10 @@ static errcode_t test_open(const char *name, int flags, io_channel *channel)
 			goto cleanup;
 	} else
 		data->real = 0;
-	data->read_blk = 	test_io_cb_read_blk;
-	data->write_blk = 	test_io_cb_write_blk;
-	data->set_blksize = 	test_io_cb_set_blksize;
-	data->write_byte = 	test_io_cb_write_byte;
+	data->read_blk =	test_io_cb_read_blk;
+	data->write_blk =	test_io_cb_write_blk;
+	data->set_blksize =	test_io_cb_set_blksize;
+	data->write_byte =	test_io_cb_write_byte;
 
 	data->outfile = NULL;
 	if ((value = getenv("TEST_IO_LOGFILE")) != NULL)
@@ -186,7 +186,7 @@ static errcode_t test_open(const char *name, int flags, io_channel *channel)
 	data->flags = 0;
 	if ((value = getenv("TEST_IO_FLAGS")) != NULL)
 		data->flags = strtoul(value, NULL, 0);
-	
+
 	data->block = 0;
 	if ((value = getenv("TEST_IO_BLOCK")) != NULL)
 		data->block = strtoul(value, NULL, 0);
@@ -198,7 +198,7 @@ static errcode_t test_open(const char *name, int flags, io_channel *channel)
 	data->write_abort_count = 0;
 	if ((value = getenv("TEST_IO_WRITE_ABORT")) != NULL)
 		data->write_abort_count = strtoul(value, NULL, 0);
-	
+
 	*channel = io;
 	return 0;
 
@@ -221,13 +221,13 @@ static errcode_t test_close(io_channel channel)
 
 	if (--channel->refcount > 0)
 		return 0;
-	
+
 	if (data->real)
 		retval = io_channel_close(data->real);
 
 	if (data->outfile && data->outfile != stderr)
 		fclose(data->outfile);
-	
+
 	ext2fs_free_mem(&channel->private_data);
 	if (channel->name)
 		ext2fs_free_mem(&channel->name);
@@ -280,7 +280,7 @@ static errcode_t test_read_blk(io_channel channel, unsigned long block,
 			test_dump_block(channel, data, block, buf);
 		if (--data->read_abort_count == 0)
 			test_abort(channel, block);
-	} 
+	}
 	return retval;
 }
 
@@ -339,22 +339,22 @@ static errcode_t test_flush(io_channel channel)
 {
 	struct test_private_data *data;
 	errcode_t	retval = 0;
-	
+
 	EXT2_CHECK_MAGIC(channel, EXT2_ET_MAGIC_IO_CHANNEL);
 	data = (struct test_private_data *) channel->private_data;
 	EXT2_CHECK_MAGIC(data, EXT2_ET_MAGIC_TEST_IO_CHANNEL);
 
 	if (data->real)
 		retval = io_channel_flush(data->real);
-	
+
 	if (data->flags & TEST_FLAG_FLUSH)
 		fprintf(data->outfile, "Test_io: flush() returned %s\n",
 			retval ? error_message(retval) : "OK");
-	
+
 	return retval;
 }
 
-static errcode_t test_set_option(io_channel channel, const char *option, 
+static errcode_t test_set_option(io_channel channel, const char *option,
 				 const char *arg)
 {
 	struct test_private_data *data;
@@ -366,10 +366,10 @@ static errcode_t test_set_option(io_channel channel, const char *option,
 
 
 	if (data->flags & TEST_FLAG_SET_OPTION)
-		fprintf(data->outfile, "Test_io: set_option(%s, %s) ", 
+		fprintf(data->outfile, "Test_io: set_option(%s, %s) ",
 			option, arg);
 	if (data->real && data->real->manager->set_option) {
-		retval = (data->real->manager->set_option)(data->real, 
+		retval = (data->real->manager->set_option)(data->real,
 							   option, arg);
 		if (data->flags & TEST_FLAG_SET_OPTION)
 			fprintf(data->outfile, "returned %s\n",
diff --git a/e2fsprogs/ext2fs/unix_io.c b/e2fsprogs/ext2fs/unix_io.c
index 5bc7a6abe..36b222577 100644
--- a/e2fsprogs/ext2fs/unix_io.c
+++ b/e2fsprogs/ext2fs/unix_io.c
@@ -1,13 +1,13 @@
 /*
  * unix_io.c --- This is the Unix (well, really POSIX) implementation
- * 	of the I/O manager.
+ *	of the I/O manager.
  *
  * Implements a one-block write-through cache.
  *
- * Includes support for Windows NT support under Cygwin. 
+ * Includes support for Windows NT support under Cygwin.
  *
  * Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
- * 	2002 by Theodore Ts'o.
+ *	2002 by Theodore Ts'o.
  *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
@@ -79,7 +79,7 @@ static errcode_t unix_write_blk(io_channel channel, unsigned long block,
 static errcode_t unix_flush(io_channel channel);
 static errcode_t unix_write_byte(io_channel channel, unsigned long offset,
 				int size, const void *data);
-static errcode_t unix_set_option(io_channel channel, const char *option, 
+static errcode_t unix_set_option(io_channel channel, const char *option,
 				 const char *arg);
 
 static void reuse_cache(io_channel channel, struct unix_private_data *data,
@@ -140,7 +140,7 @@ static errcode_t raw_read_blk(io_channel channel,
 		goto error_out;
 	}
 	return 0;
-	
+
 error_out:
 	memset((char *) buf+actual, 0, size-actual);
 	if (channel->read_error)
@@ -168,7 +168,7 @@ static errcode_t raw_read_blk(io_channel channel,
 	location = ((ext2_loff_t) block * channel->block_size) + data->offset;
 #ifdef DEBUG
 	printf("count=%d, size=%d, block=%d, blk_size=%d, location=%lx\n",
-	 		count, size, block, channel->block_size, location);
+			count, size, block, channel->block_size, location);
 #endif
 	if (ext2fs_llseek(data->dev, location, SEEK_SET) != location) {
 		retval = errno ? errno : EXT2_ET_LLSEEK_FAILED;
@@ -227,14 +227,14 @@ static errcode_t raw_write_blk(io_channel channel,
 		retval = errno ? errno : EXT2_ET_LLSEEK_FAILED;
 		goto error_out;
 	}
-	
+
 	actual = write(data->dev, buf, size);
 	if (actual != size) {
 		retval = EXT2_ET_SHORT_WRITE;
 		goto error_out;
 	}
 	return 0;
-	
+
 error_out:
 	if (channel->write_error)
 		retval = (channel->write_error)(channel, block, count, buf,
@@ -254,7 +254,7 @@ static errcode_t alloc_cache(io_channel channel,
 	errcode_t		retval;
 	struct unix_cache	*cache;
 	int			i;
-	
+
 	data->access_time = 0;
 	for (i=0, cache = data->cache; i < CACHE_SIZE; i++, cache++) {
 		cache->block = 0;
@@ -273,7 +273,7 @@ static void free_cache(struct unix_private_data *data)
 {
 	struct unix_cache	*cache;
 	int			i;
-	
+
 	data->access_time = 0;
 	for (i=0, cache = data->cache; i < CACHE_SIZE; i++, cache++) {
 		cache->block = 0;
@@ -298,7 +298,7 @@ static struct unix_cache *find_cached_block(struct unix_private_data *data,
 {
 	struct unix_cache	*cache, *unused_cache, *oldest_cache;
 	int			i;
-	
+
 	unused_cache = oldest_cache = 0;
 	for (i=0, cache = data->cache; i < CACHE_SIZE; i++, cache++) {
 		if (!cache->in_use) {
@@ -345,18 +345,18 @@ static errcode_t flush_cached_blocks(io_channel channel,
 	struct unix_cache	*cache;
 	errcode_t		retval, retval2;
 	int			i;
-	
+
 	retval2 = 0;
 	for (i=0, cache = data->cache; i < CACHE_SIZE; i++, cache++) {
 		if (!cache->in_use)
 			continue;
-		
+
 		if (invalidate)
 			cache->in_use = 0;
-		
+
 		if (!cache->dirty)
 			continue;
-		
+
 		retval = raw_write_blk(channel, data,
 				       cache->block, 1, cache->buf);
 		if (retval)
@@ -376,7 +376,7 @@ static errcode_t unix_open(const char *name, int flags, io_channel *channel)
 	int		open_flags;
 	struct stat	st;
 #ifdef __linux__
-	struct 		utsname ut;
+	struct		utsname ut;
 #endif
 
 	if (name == 0)
@@ -431,7 +431,7 @@ static errcode_t unix_open(const char *name, int flags, io_channel *channel)
 	 * block devices are wrongly getting hit by the filesize
 	 * limit.  This workaround isn't perfect, since it won't work
 	 * if glibc wasn't built against 2.2 header files.  (Sigh.)
-	 * 
+	 *
 	 */
 	if ((flags & IO_FLAG_RW) &&
 	    (uname(&ut) == 0) &&
@@ -442,7 +442,7 @@ static errcode_t unix_open(const char *name, int flags, io_channel *channel)
 	    (fstat(data->dev, &st) == 0) &&
 	    (S_ISBLK(st.st_mode))) {
 		struct rlimit	rlim;
-		
+
 		rlim.rlim_cur = rlim.rlim_max = (unsigned long) RLIM_INFINITY;
 		setrlimit(RLIMIT_FSIZE, &rlim);
 		getrlimit(RLIMIT_FSIZE, &rlim);
@@ -507,7 +507,7 @@ static errcode_t unix_set_blksize(io_channel channel, int blksize)
 		if ((retval = flush_cached_blocks(channel, data, 0)))
 			return retval;
 #endif
-		
+
 		channel->block_size = blksize;
 		free_cache(data);
 		if ((retval = alloc_cache(channel, data)))
@@ -568,7 +568,7 @@ static errcode_t unix_read_blk(io_channel channel, unsigned long block,
 #endif
 		if ((retval = raw_read_blk(channel, data, block, i, cp)))
 			return retval;
-		
+
 		/* Save the results in the cache */
 		for (j=0; j < i; j++) {
 			count--;
@@ -597,7 +597,7 @@ static errcode_t unix_write_blk(io_channel channel, unsigned long block,
 
 #ifdef NO_IO_CACHE
 	return raw_write_blk(channel, data, block, count, buf);
-#else	
+#else
 	/*
 	 * If we're doing an odd-sized write or a very large write,
 	 * flush out the cache completely and then do a direct write.
@@ -616,7 +616,7 @@ static errcode_t unix_write_blk(io_channel channel, unsigned long block,
 	writethrough = channel->flags & CHANNEL_FLAGS_WRITETHROUGH;
 	if (writethrough)
 		retval = raw_write_blk(channel, data, block, count, buf);
-	
+
 	cp = buf;
 	while (count > 0) {
 		cache = find_cached_block(data, block, &reuse);
@@ -655,7 +655,7 @@ static errcode_t unix_write_byte(io_channel channel, unsigned long offset,
 
 	if (lseek(data->dev, offset + data->offset, SEEK_SET) < 0)
 		return errno;
-	
+
 	actual = write(data->dev, buf, size);
 	if (actual != size)
 		return EXT2_ET_SHORT_WRITE;
@@ -664,13 +664,13 @@ static errcode_t unix_write_byte(io_channel channel, unsigned long offset,
 }
 
 /*
- * Flush data buffers to disk.  
+ * Flush data buffers to disk.
  */
 static errcode_t unix_flush(io_channel channel)
 {
 	struct unix_private_data *data;
 	errcode_t retval = 0;
-	
+
 	EXT2_CHECK_MAGIC(channel, EXT2_ET_MAGIC_IO_CHANNEL);
 	data = (struct unix_private_data *) channel->private_data;
 	EXT2_CHECK_MAGIC(data, EXT2_ET_MAGIC_UNIX_IO_CHANNEL);
@@ -682,7 +682,7 @@ static errcode_t unix_flush(io_channel channel)
 	return retval;
 }
 
-static errcode_t unix_set_option(io_channel channel, const char *option, 
+static errcode_t unix_set_option(io_channel channel, const char *option,
 				 const char *arg)
 {
 	struct unix_private_data *data;
diff --git a/e2fsprogs/ext2fs/unlink.c b/e2fsprogs/ext2fs/unlink.c
index e7b2182d2..a6ab53ae8 100644
--- a/e2fsprogs/ext2fs/unlink.c
+++ b/e2fsprogs/ext2fs/unlink.c
@@ -1,6 +1,6 @@
 /*
  * unlink.c --- delete links in a ext2fs directory
- * 
+ *
  * Copyright (C) 1993, 1994, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -25,7 +25,7 @@ struct link_struct  {
 	int		flags;
 	struct ext2_dir_entry *prev;
 	int		done;
-};	
+};
 
 #ifdef __TURBOC__
  #pragma argsused
@@ -56,7 +56,7 @@ static int unlink_proc(struct ext2_dir_entry *dirent,
 			return 0;
 	}
 
-	if (prev) 
+	if (prev)
 		prev->rec_len += dirent->rec_len;
 	else
 		dirent->inode = 0;
@@ -89,7 +89,7 @@ errcode_t ext2fs_unlink(ext2_filsys fs, ext2_ino_t dir,
 	ls.done = 0;
 	ls.prev = 0;
 
-	retval = ext2fs_dir_iterate(fs, dir, DIRENT_FLAG_INCLUDE_EMPTY, 
+	retval = ext2fs_dir_iterate(fs, dir, DIRENT_FLAG_INCLUDE_EMPTY,
 				    0, unlink_proc, &ls);
 	if (retval)
 		return retval;
diff --git a/e2fsprogs/ext2fs/valid_blk.c b/e2fsprogs/ext2fs/valid_blk.c
index 29ff27a7c..d0367e71c 100644
--- a/e2fsprogs/ext2fs/valid_blk.c
+++ b/e2fsprogs/ext2fs/valid_blk.c
@@ -2,12 +2,12 @@
  * valid_blk.c --- does the inode have valid blocks?
  *
  * Copyright 1997 by Theodore Ts'o
- * 
+ *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
  * License.
  * %End-Header%
- * 
+ *
  */
 
 #include <stdio.h>
@@ -33,7 +33,7 @@ int ext2fs_inode_has_valid_blocks(struct ext2_inode *inode)
 	if (!LINUX_S_ISDIR(inode->i_mode) && !LINUX_S_ISREG(inode->i_mode) &&
 	    !LINUX_S_ISLNK(inode->i_mode))
 		return 0;
-	
+
 	/*
 	 * If the symbolic link is a "fast symlink", then the symlink
 	 * target is stored in the block entries.
diff --git a/e2fsprogs/fsck.c b/e2fsprogs/fsck.c
index 848d559bc..af76c4d21 100644
--- a/e2fsprogs/fsck.c
+++ b/e2fsprogs/fsck.c
@@ -104,10 +104,10 @@ struct fsck_instance {
  * assure that we only fsck one partition on a particular drive at any
  * one time.  Otherwise, the disk heads will be seeking all over the
  * place.  If the base device can not be determined, return NULL.
- * 
+ *
  * The base_device() function returns an allocated string which must
  * be freed.
- * 
+ *
  */
 
 
diff --git a/e2fsprogs/lsattr.c b/e2fsprogs/lsattr.c
index e25f36d82..b5ec8ab98 100644
--- a/e2fsprogs/lsattr.c
+++ b/e2fsprogs/lsattr.c
@@ -97,8 +97,8 @@ static void lsattr_args(const char *name)
 	}
 }
 
-static int lsattr_dir_proc(const char *dir_name, struct dirent *de, 
-                           void *private EXT2FS_ATTR((unused)))
+static int lsattr_dir_proc(const char *dir_name, struct dirent *de,
+			   void *private EXT2FS_ATTR((unused)))
 {
 	STRUCT_STAT	st;
 	char *path;
diff --git a/e2fsprogs/mke2fs.c b/e2fsprogs/mke2fs.c
index 9c4f1c4d0..10563e2d9 100644
--- a/e2fsprogs/mke2fs.c
+++ b/e2fsprogs/mke2fs.c
@@ -107,9 +107,9 @@ static const struct mke2fs_defaults settings[] = {
 	{ default_str,	 3, 1024, 8192 },
 	{ "journal",	 0, 4096, 8192 },
 	{ "news",	 0, 4096, 4096 },
-	{ "largefile", 	 0, 4096, 1024 * 1024 },
+	{ "largefile",	 0, 4096, 1024 * 1024 },
 	{ "largefile4",  0, 4096, 4096 * 1024 },
-	{ 0, 		 0,    0, 0},
+	{ 0,		 0,    0, 0},
 };
 
 static void set_fs_defaults(const char *fs_type,
@@ -448,7 +448,7 @@ static void write_inode_tables(ext2_filsys fs)
 		num = fs->inode_blocks_per_group;
 
 		retval = zero_blocks(fs, blk, num, 0, &blk, &num);
-		mke2fs_error_msg_and_die(retval, 
+		mke2fs_error_msg_and_die(retval,
 			"write %d blocks in inode table starting at %d.",
 			num, blk);
 		if (sync_kludge) {
@@ -572,7 +572,7 @@ static void zap_sector(ext2_filsys fs, int sect, int nsect)
 
 static void create_journal_dev(ext2_filsys fs)
 {
-	struct progress_struct 	progress;
+	struct progress_struct	progress;
 	errcode_t		retval;
 	char			*buf;
 	char			*fmt = "%s journal superblock";
@@ -624,7 +624,7 @@ static void show_stats(ext2_filsys fs)
 			os,
 			fs->blocksize, s->s_log_block_size,
 			fs->fragsize, s->s_log_frag_size,
-			s->s_inodes_count, s->s_blocks_count, 
+			s->s_inodes_count, s->s_blocks_count,
 			s->s_r_blocks_count, 100.0 * s->s_r_blocks_count / s->s_blocks_count,
 			s->s_first_data_block);
 	free(os);
@@ -679,7 +679,7 @@ static int set_os(struct ext2_super_block *sb, char *os)
 	if((sb->s_creator_os = e2p_string2os(os)) >= 0) {
 		return 1;
 	} else if (!strcasecmp("GNU", os)) {
- 		sb->s_creator_os = EXT2_OS_HURD;
+		sb->s_creator_os = EXT2_OS_HURD;
 		return 1;
 	}
 	return 0;
@@ -842,7 +842,7 @@ static int PRS(int argc, char *argv[])
 #endif
 
 	/* If called as mkfs.ext3, create a journal inode */
-	if (last_char_is(bb_applet_name, '3')) 
+	if (last_char_is(bb_applet_name, '3'))
 		journal_size = -1;
 
 	while ((c = getopt (argc, argv,
@@ -886,8 +886,8 @@ BLOCKSIZE_ERROR:
 			}
 			break;
 		case 'i':
-			if (safe_strtoi(optarg, &inode_ratio) 
-				|| inode_ratio < EXT2_MIN_BLOCK_SIZE 
+			if (safe_strtoi(optarg, &inode_ratio)
+				|| inode_ratio < EXT2_MIN_BLOCK_SIZE
 				|| inode_ratio > EXT2_MAX_BLOCK_SIZE * 1024) {
 				bb_error_msg_and_die("bad inode ratio %s (min %d/max %d)",
 					optarg, EXT2_MIN_BLOCK_SIZE,
diff --git a/e2fsprogs/tune2fs.c b/e2fsprogs/tune2fs.c
index f23688bc3..f228c56aa 100644
--- a/e2fsprogs/tune2fs.c
+++ b/e2fsprogs/tune2fs.c
@@ -163,7 +163,7 @@ no_valid_journal:
 
 /* Helper function for remove_journal_inode */
 static int release_blocks_proc(ext2_filsys fs, blk_t *blocknr,
-			       int blockcnt EXT2FS_ATTR((unused)), 
+			       int blockcnt EXT2FS_ATTR((unused)),
 			       void *private EXT2FS_ATTR((unused)))
 {
 	blk_t	block;
@@ -187,9 +187,9 @@ static void remove_journal_inode(ext2_filsys fs)
 	ino_t			ino = fs->super->s_journal_inum;
 	char *msg = "to read";
 	char *s = "journal inode";
-	
+
 	retval = ext2fs_read_inode(fs, ino,  &inode);
-	if (retval) 
+	if (retval)
 		goto REMOVE_JOURNAL_INODE_ERROR;
 	if (ino == EXT2_JOURNAL_INO) {
 		retval = ext2fs_read_bitmaps(fs);
@@ -343,13 +343,13 @@ static void add_journal(ext2_filsys fs)
 	return;
 }
 
-/*  
+/*
  * Busybox stuff
  */
 static char * x_blkid_get_devname(const char *token)
 {
 	char * dev_name;
-	
+
 	if (!(dev_name = blkid_get_devname(NULL, token, NULL)))
 		bb_error_msg_and_die("Unable to resolve '%s'", token);
 	return dev_name;
@@ -368,11 +368,11 @@ static void parse_e2label_options(int argc, char ** argv)
 		open_flag = EXT2_FLAG_RW | EXT2_FLAG_JOURNAL_DEV_OK;
 		L_flag = 1;
 		new_label = argv[2];
-	} else 
+	} else
 		print_label++;
 }
 #else
-#define parse_e2label_options(x,y)         
+#define parse_e2label_options(x,y)
 #endif
 
 static time_t parse_time(char *str)
@@ -516,7 +516,7 @@ MOUNTS_COUNT_ERROR:
 				mntopts_cmd = optarg;
 				open_flag = EXT2_FLAG_RW;
 				break;
-				
+
 			case 'O':
 				if (features_cmd) {
 					bb_error_msg_and_die("-O may only be specified once");
@@ -594,7 +594,7 @@ int tune2fs_main(int argc, char **argv)
 
 	if (ENABLE_FEATURE_CLEAN_UP)
 		atexit(clean_up);
-		
+
 	if (ENABLE_FINDFS && (bb_applet_name[0] == 'f')) /* findfs */
 		do_findfs(argc, argv);  /* no return */
 	else if (ENABLE_E2LABEL && (bb_applet_name[0] == 'e')) /* e2label */
@@ -603,7 +603,7 @@ int tune2fs_main(int argc, char **argv)
 		parse_tune2fs_options(argc, argv);  /* tune2fs */
 
 	io_ptr = unix_io_manager;
-	retval = ext2fs_open2(device_name, io_options, open_flag, 
+	retval = ext2fs_open2(device_name, io_options, open_flag,
 			      0, 0, io_ptr, &fs);
 	if (retval)
 		bb_error_msg_and_die("No valid superblock on %s", device_name);
diff --git a/e2fsprogs/util.c b/e2fsprogs/util.c
index 7e9c09234..3902f7ef3 100644
--- a/e2fsprogs/util.c
+++ b/e2fsprogs/util.c
@@ -1,6 +1,6 @@
 /*
  * util.c --- helper functions used by tune2fs and mke2fs
- * 
+ *
  * Copyright 1995, 1996, 1997, 1998, 1999, 2000 by Theodore Ts'o.
  *
  * %Begin-Header%
@@ -99,8 +99,8 @@ void check_mount(const char *device, int force, const char *type)
 		bb_error_msg_and_die("will not make a %s here!", type);
 }
 
-void parse_journal_opts(char **journal_device, int *journal_flags, 
-                        int *journal_size, const char *opts)
+void parse_journal_opts(char **journal_device, int *journal_flags,
+			int *journal_size, const char *opts)
 {
 	char *buf, *token, *next, *p, *arg;
 	int journal_usage = 0;
@@ -118,7 +118,7 @@ void parse_journal_opts(char **journal_device, int *journal_flags,
 		if (p) {
 			*p = 0;
 			next = p+1;
-		} 
+		}
 		arg = strchr(token, '=');
 		if (arg) {
 			*arg = 0;
@@ -155,13 +155,13 @@ void parse_journal_opts(char **journal_device, int *journal_flags,
 			"\tdevice=<journal device>\n\n"
 			"The journal size must be between "
 			"1024 and 102400 filesystem blocks.\n\n");
-}	
+}
 
 /*
  * Determine the number of journal blocks to use, either via
  * user-specified # of megabytes, or via some intelligently selected
  * defaults.
- * 
+ *
  * Find a reasonable journal file size (in blocks) given the number of blocks
  * in the filesystem.  For very small filesystems, it is not reasonable to
  * have a journal that fills more than half of the filesystem.
@@ -214,8 +214,8 @@ void make_journal_device(char *journal_device, ext2_filsys fs, int quiet, int fo
 	io_manager	io_ptr;
 
 	check_plausibility(journal_device, force);
-	check_mount(journal_device, force, "journal");	
-	io_ptr = unix_io_manager;	
+	check_mount(journal_device, force, "journal");
+	io_ptr = unix_io_manager;
 	retval = ext2fs_open(journal_device, EXT2_FLAG_RW|
 					EXT2_FLAG_JOURNAL_DEV_OK, 0,
 					fs->blocksize, io_ptr, &jfs);
@@ -236,7 +236,7 @@ void make_journal_blocks(ext2_filsys fs, int journal_size, int journal_flags, in
 {
 	unsigned long journal_blocks;
 	errcode_t	retval;
-		
+
 	journal_blocks = figure_journal_size(journal_size, fs);
 	if (!journal_blocks) {
 		fs->super->s_feature_compat &=
@@ -259,9 +259,9 @@ char *e2fs_set_sbin_path(void)
 	char *oldpath = getenv("PATH");
 	/* Update our PATH to include /sbin  */
 #define PATH_SET "/sbin"
-	if (oldpath) 
+	if (oldpath)
 		oldpath = bb_xasprintf("%s:%s", PATH_SET, oldpath);
-	 else 
+	 else
 		oldpath = PATH_SET;
 	putenv (oldpath);
 	return oldpath;
diff --git a/e2fsprogs/util.h b/e2fsprogs/util.h
index 24d5e6545..5041046c7 100644
--- a/e2fsprogs/util.h
+++ b/e2fsprogs/util.h
@@ -1,7 +1,7 @@
 /*
  * util.h --- header file defining prototypes for helper functions
  * used by tune2fs and mke2fs
- * 
+ *
  * Copyright 2000 by Theodore Ts'o.
  *
  * %Begin-Header%
diff --git a/e2fsprogs/uuid/compare.c b/e2fsprogs/uuid/compare.c
index 83afeafbf..94c32b1d3 100644
--- a/e2fsprogs/uuid/compare.c
+++ b/e2fsprogs/uuid/compare.c
@@ -2,7 +2,7 @@
  * compare.c --- compare whether or not two UUID's are the same
  *
  * Returns 0 if the two UUID's are different, and 1 if they are the same.
- * 
+ *
  * Copyright (C) 1996, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -18,7 +18,7 @@
  * 3. The name of the author may not be used to endorse or promote
  *    products derived from this software without specific prior
  *    written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
diff --git a/e2fsprogs/uuid/gen_uuid.c b/e2fsprogs/uuid/gen_uuid.c
index 52328cfc4..fca3ebe91 100644
--- a/e2fsprogs/uuid/gen_uuid.c
+++ b/e2fsprogs/uuid/gen_uuid.c
@@ -16,7 +16,7 @@
  * 3. The name of the author may not be used to endorse or promote
  *    products derived from this software without specific prior
  *    written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
@@ -63,8 +63,8 @@
 #include "uuidP.h"
 
 #ifdef HAVE_SRANDOM
-#define srand(x) 	srandom(x)
-#define rand() 		random()
+#define srand(x)	srandom(x)
+#define rand()		random()
 #endif
 
 static int get_random_fd(void)
@@ -111,7 +111,7 @@ static void get_random_bytes(void *buf, int nbytes)
 			lose_counter = 0;
 		}
 	}
-	
+
 	/*
 	 * We do this all the time, but this is the only source of
 	 * randomness if /dev/random/urandom is out to lunch.
@@ -127,12 +127,12 @@ static void get_random_bytes(void *buf, int nbytes)
 static int get_node_id(unsigned char *node_id)
 {
 #ifdef HAVE_NET_IF_H
-	int 		sd;
-	struct ifreq 	ifr, *ifrp;
-	struct ifconf 	ifc;
+	int		sd;
+	struct ifreq	ifr, *ifrp;
+	struct ifconf	ifc;
 	char buf[1024];
 	int		n, i;
-	unsigned char 	*a;
+	unsigned char	*a;
 #ifdef HAVE_NET_IF_DL_H
 	struct sockaddr_dl *sdlp;
 #endif
@@ -140,7 +140,7 @@ static int get_node_id(unsigned char *node_id)
 /*
  * BSD 4.4 defines the size of an ifreq to be
  * max(sizeof(ifreq), sizeof(ifreq.ifr_name)+ifreq.ifr_addr.sa_len
- * However, under earlier systems, sa_len isn't present, so the size is 
+ * However, under earlier systems, sa_len isn't present, so the size is
  * just sizeof(struct ifreq)
  */
 #ifdef HAVE_SA_LEN
@@ -214,9 +214,9 @@ static int get_clock(uint32_t *clock_high, uint32_t *clock_low, uint16_t *ret_cl
 	static int			adjustment = 0;
 	static struct timeval		last = {0, 0};
 	static uint16_t			clock_seq;
-	struct timeval 			tv;
+	struct timeval			tv;
 	unsigned long long		clock_reg;
-	
+
 try_again:
 	gettimeofday(&tv, 0);
 	if ((last.tv_sec == 0) && (last.tv_usec == 0)) {
@@ -240,7 +240,7 @@ try_again:
 		adjustment = 0;
 		last = tv;
 	}
-		
+
 	clock_reg = tv.tv_usec*10 + adjustment;
 	clock_reg += ((unsigned long long) tv.tv_sec)*10000000;
 	clock_reg += (((unsigned long long) 0x01B21DD2) << 32) + 0x13814000;
diff --git a/e2fsprogs/uuid/pack.c b/e2fsprogs/uuid/pack.c
index 1013886e5..9d733f000 100644
--- a/e2fsprogs/uuid/pack.c
+++ b/e2fsprogs/uuid/pack.c
@@ -1,6 +1,6 @@
 /*
  * Internal routine for packing UUID's
- * 
+ *
  * Copyright (C) 1996, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -16,7 +16,7 @@
  * 3. The name of the author may not be used to endorse or promote
  *    products derived from this software without specific prior
  *    written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
diff --git a/e2fsprogs/uuid/parse.c b/e2fsprogs/uuid/parse.c
index 07b894d11..21b29498e 100644
--- a/e2fsprogs/uuid/parse.c
+++ b/e2fsprogs/uuid/parse.c
@@ -1,6 +1,6 @@
 /*
  * parse.c --- UUID parsing
- * 
+ *
  * Copyright (C) 1996, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -16,7 +16,7 @@
  * 3. The name of the author may not be used to endorse or promote
  *    products derived from this software without specific prior
  *    written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
@@ -42,7 +42,7 @@
 int uuid_parse(const char *in, uuid_t uu)
 {
 	struct uuid	uuid;
-	int 		i;
+	int		i;
 	const char	*cp;
 	char		buf[3];
 
@@ -73,7 +73,7 @@ int uuid_parse(const char *in, uuid_t uu)
 		buf[1] = *cp++;
 		uuid.node[i] = strtoul(buf, NULL, 16);
 	}
-	
+
 	uuid_pack(&uuid, uu);
 	return 0;
 }
diff --git a/e2fsprogs/uuid/unpack.c b/e2fsprogs/uuid/unpack.c
index d63589521..8f9c520c1 100644
--- a/e2fsprogs/uuid/unpack.c
+++ b/e2fsprogs/uuid/unpack.c
@@ -1,6 +1,6 @@
 /*
  * Internal routine for unpacking UUID
- * 
+ *
  * Copyright (C) 1996, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -16,7 +16,7 @@
  * 3. The name of the author may not be used to endorse or promote
  *    products derived from this software without specific prior
  *    written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
diff --git a/e2fsprogs/uuid/unparse.c b/e2fsprogs/uuid/unparse.c
index c0e08ef49..a95bbb042 100644
--- a/e2fsprogs/uuid/unparse.c
+++ b/e2fsprogs/uuid/unparse.c
@@ -1,6 +1,6 @@
 /*
  * unparse.c -- convert a UUID to string
- * 
+ *
  * Copyright (C) 1996, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -16,7 +16,7 @@
  * 3. The name of the author may not be used to endorse or promote
  *    products derived from this software without specific prior
  *    written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
@@ -36,10 +36,10 @@
 
 #include "uuidP.h"
 
-static const char *fmt_lower = 
+static const char *fmt_lower =
 	"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x";
 
-static const char *fmt_upper = 
+static const char *fmt_upper =
 	"%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X";
 
 #ifdef UUID_UNPARSE_DEFAULT_UPPER
diff --git a/e2fsprogs/uuid/uuid.h b/e2fsprogs/uuid/uuid.h
index a05f1c690..cd97a5e78 100644
--- a/e2fsprogs/uuid/uuid.h
+++ b/e2fsprogs/uuid/uuid.h
@@ -1,6 +1,6 @@
 /*
  * Public include file for the UUID library
- * 
+ *
  * Copyright (C) 1996, 1997, 1998 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -16,7 +16,7 @@
  * 3. The name of the author may not be used to endorse or promote
  *    products derived from this software without specific prior
  *    written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
@@ -42,8 +42,8 @@
 typedef unsigned char uuid_t[16];
 
 /* UUID Variant definitions */
-#define UUID_VARIANT_NCS 	0
-#define UUID_VARIANT_DCE 	1
+#define UUID_VARIANT_NCS	0
+#define UUID_VARIANT_DCE	1
 #define UUID_VARIANT_MICROSOFT	2
 #define UUID_VARIANT_OTHER	3
 
diff --git a/e2fsprogs/uuid/uuidP.h b/e2fsprogs/uuid/uuidP.h
index d2e1a450a..9d30ce2f8 100644
--- a/e2fsprogs/uuid/uuidP.h
+++ b/e2fsprogs/uuid/uuidP.h
@@ -1,6 +1,6 @@
 /*
  * uuid.h -- private header file for uuids
- * 
+ *
  * Copyright (C) 1996, 1997 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -16,7 +16,7 @@
  * 3. The name of the author may not be used to endorse or promote
  *    products derived from this software without specific prior
  *    written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
diff --git a/e2fsprogs/uuid/uuid_time.c b/e2fsprogs/uuid/uuid_time.c
index d5f992b39..9ff3607d8 100644
--- a/e2fsprogs/uuid/uuid_time.c
+++ b/e2fsprogs/uuid/uuid_time.c
@@ -1,8 +1,8 @@
 /*
  * uuid_time.c --- Interpret the time field from a uuid.  This program
- * 	violates the UUID abstraction barrier by reaching into the guts
+ *	violates the UUID abstraction barrier by reaching into the guts
  *	of a UUID and interpreting it.
- * 
+ *
  * Copyright (C) 1998, 1999 Theodore Ts'o.
  *
  * %Begin-Header%
@@ -18,7 +18,7 @@
  * 3. The name of the author may not be used to endorse or promote
  *    products derived from this software without specific prior
  *    written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
@@ -51,7 +51,7 @@ time_t uuid_time(const uuid_t uu, struct timeval *ret_tv)
 	unsigned long long	clock_reg;
 
 	uuid_unpack(uu, &uuid);
-	
+
 	high = uuid.time_mid | ((uuid.time_hi_and_version & 0xFFF) << 16);
 	clock_reg = uuid.time_low | ((unsigned long long) high << 32);
 
@@ -69,7 +69,7 @@ int uuid_type(const uuid_t uu)
 {
 	struct uuid		uuid;
 
-	uuid_unpack(uu, &uuid);	
+	uuid_unpack(uu, &uuid);
 	return ((uuid.time_hi_and_version >> 12) & 0xF);
 }
 
@@ -78,7 +78,7 @@ int uuid_variant(const uuid_t uu)
 	struct uuid		uuid;
 	int			var;
 
-	uuid_unpack(uu, &uuid);	
+	uuid_unpack(uu, &uuid);
 	var = uuid.clock_seq;
 
 	if ((var & 0x8000) == 0)
@@ -105,7 +105,7 @@ static const char *variant_string(int variant)
 	}
 }
 
-	
+
 int
 main(int argc, char **argv)
 {
@@ -155,7 +155,7 @@ main(int argc, char **argv)
 	}
 	printf("UUID time is: (%ld, %ld): %s\n", tv.tv_sec, tv.tv_usec,
 	       ctime(&time_reg));
-	
+
 	return 0;
 }
 #endif
diff --git a/editors/sed.c b/editors/sed.c
index 2f6fc174c..dcc2ca06b 100644
--- a/editors/sed.c
+++ b/editors/sed.c
@@ -1191,7 +1191,7 @@ extern int sed_main(int argc, char **argv)
 					if(in_place) {
 						struct stat statbuf;
 						int nonstdoutfd;
-						
+
 						outname=bb_xstrndup(argv[i],strlen(argv[i])+6);
 						strcat(outname,"XXXXXX");
 						if(-1==(nonstdoutfd=mkstemp(outname)))
diff --git a/editors/vi.c b/editors/vi.c
index 6689e290b..fddd0a9ea 100644
--- a/editors/vi.c
+++ b/editors/vi.c
@@ -1673,13 +1673,13 @@ static Byte find_range(Byte ** start, Byte ** stop, Byte c)
 		q = dot;
 	} else if (strchr("wW", c)) {
 		do_cmd(c);		// execute movement cmd
- 		// if we are at the next word's first char
- 		// step back one char
- 		// but check the possibilities when it is true
+		// if we are at the next word's first char
+		// step back one char
+		// but check the possibilities when it is true
 		if (dot > text && ((isspace(dot[-1]) && !isspace(dot[0]))
- 				|| (ispunct(dot[-1]) && !ispunct(dot[0]))
- 				|| (isalnum(dot[-1]) && !isalnum(dot[0]))))
-  			dot--;		// move back off of next word
+				|| (ispunct(dot[-1]) && !ispunct(dot[0]))
+				|| (isalnum(dot[-1]) && !isalnum(dot[0]))))
+			dot--;		// move back off of next word
 		if (dot > text && *dot == '\n')
 			dot--;		// stay off NL
 		q = dot;
@@ -2405,7 +2405,7 @@ static Byte *get_input_line(Byte * prompt) // get input line- use "status line"
 		if (c == '\n' || c == '\r' || c == 27)
 			break;		// is this end of input
 		if (c == erase_char || c == 8 || c == 127) {
-		    	// user wants to erase prev char
+			// user wants to erase prev char
 			i--;		// backup to prev char
 			buf[i] = '\0';	// erase the char
 			buf[i + 1] = '\0';	// null terminate buffer
@@ -3754,11 +3754,11 @@ key_cmd_mode:
 		end_cmd_q();	// stop adding to q
 		break;
 	case 't':			// t- move to char prior to next x
-                last_forward_char = get_one_char();
-                do_cmd(';');
-                if (*dot == last_forward_char)
-                        dot_left();
-                last_forward_char= 0;
+		last_forward_char = get_one_char();
+		do_cmd(';');
+		if (*dot == last_forward_char)
+			dot_left();
+		last_forward_char= 0;
 		break;
 	case 'w':			// w- forward a word
 		if (cmdcnt-- > 1) {
@@ -4047,4 +4047,4 @@ static void crash_test()
 	}
 	return;
 }
-#endif                                                  /* CONFIG_FEATURE_VI_CRASHME */
+#endif					          /* CONFIG_FEATURE_VI_CRASHME */
diff --git a/findutils/find.c b/findutils/find.c
index 603c20643..0f2f2144c 100644
--- a/findutils/find.c
+++ b/findutils/find.c
@@ -164,7 +164,7 @@ static int fileAction(const char *fileName, struct stat *statbuf, void* junk)
 		goto no_match;
 	}
 #endif
-	
+
 	puts(fileName);
 no_match:
 	return (TRUE);
@@ -317,7 +317,7 @@ int find_main(int argc, char **argv)
 					break;
 				cmd_string = bb_xasprintf("%s %s", cmd_string, argv[i]);
 			}
-			
+
 			if (*cmd_string == 0)
 				bb_error_msg_and_die(msg_req_arg, "-exec");
 			cmd_string++;
diff --git a/include/usage.h b/include/usage.h
index 99257329c..bff187a3d 100644
--- a/include/usage.h
+++ b/include/usage.h
@@ -873,7 +873,7 @@
 	"\t-s         Don't print or kill anything.\n" \
 	"\t-4         When using port/proto only search IPv4 space\n" \
 	"\t-6         When using port/proto only search IPv6 space\n" \
-	"\t-SIGNAL    When used with -k, this signal will be used to kill\n" 
+	"\t-SIGNAL    When used with -k, this signal will be used to kill\n"
 #define getopt_trivial_usage \
 	"[OPTIONS]..."
 #define getopt_full_usage \
@@ -1873,8 +1873,8 @@
 #ifdef CONFIG_FEATURE_MDEV_CONFIG
 #define mdev_notes_usage \
 	"The mdev config file contains lines that look like:\n" \
-        "  hd[a-z][0-9]* 0:3 660\n\n" \
-        "That's device name (with regex match), uid:gid, and permissions.\n\n" \
+	"  hd[a-z][0-9]* 0:3 660\n\n" \
+	"That's device name (with regex match), uid:gid, and permissions.\n\n" \
 	"Optionally, that can be followed (on the same line) by an asterisk\n" \
 	"and a command line to run after creating the corresponding device(s),\n"\
 	"ala:\n\n" \
diff --git a/init/init.c b/init/init.c
index dcc8bd9ce..337d31c2d 100644
--- a/init/init.c
+++ b/init/init.c
@@ -462,7 +462,7 @@ static pid_t run(const struct init_action *a)
 						break;
 					}
 					/* FIXME handle other errors */
-                }
+		}
 
 				/* See if stealing the controlling tty back is necessary */
 				pgrp = tcgetpgrp(0);
diff --git a/libbb/compare_string_array.c b/libbb/compare_string_array.c
index fc077b309..e4191e35a 100644
--- a/libbb/compare_string_array.c
+++ b/libbb/compare_string_array.c
@@ -17,7 +17,7 @@
 #include <string.h>
 
 /* returns the array number of the string */
-extern int 
+extern int
 compare_string_array(const char * const string_array[], const char *key)
 {
 	int i;
diff --git a/libbb/copy_file.c b/libbb/copy_file.c
index 991fa8f5b..0763b4586 100644
--- a/libbb/copy_file.c
+++ b/libbb/copy_file.c
@@ -119,7 +119,7 @@ int copy_file(const char *source, const char *dest, int flags)
 			status = -1;
 		}
 	} else if (S_ISREG(source_stat.st_mode) || (flags & FILEUTILS_DEREFERENCE))
-   	{
+	{
 		int src_fd;
 		int dst_fd;
 #ifdef CONFIG_FEATURE_PRESERVE_HARDLINKS
diff --git a/libbb/copyfd.c b/libbb/copyfd.c
index 0b850884b..fcae8d3f7 100644
--- a/libbb/copyfd.c
+++ b/libbb/copyfd.c
@@ -32,7 +32,7 @@ static ssize_t bb_full_fd_action(int src_fd, int dst_fd, size_t size)
 	while (!size || total < size)
 	{
 		ssize_t wrote, xread;
-		
+
 		xread = safe_read(src_fd, buffer,
 				(!size || size - total > BUFSIZ) ? BUFSIZ : size - total);
 
@@ -53,7 +53,7 @@ static ssize_t bb_full_fd_action(int src_fd, int dst_fd, size_t size)
 			break;
 		}
 	}
-		
+
 out:
 	RELEASE_CONFIG_BUFFER(buffer);
 
diff --git a/libbb/correct_password.c b/libbb/correct_password.c
index 039379ae1..bb9e7d3cc 100644
--- a/libbb/correct_password.c
+++ b/libbb/correct_password.c
@@ -61,7 +61,7 @@ int correct_password ( const struct passwd *pw )
 	}
 	else
 #endif
-    	correct = pw-> pw_passwd;
+		correct = pw-> pw_passwd;
 
 	if ( correct == 0 || correct[0] == '\0' )
 		return 1;
diff --git a/libbb/dump.c b/libbb/dump.c
index 98f004ff6..7d923083a 100644
--- a/libbb/dump.c
+++ b/libbb/dump.c
@@ -695,7 +695,7 @@ void bb_dump_add(const char *fmt)
 
 	/* start new linked list of format units */
 	/* NOSTRICT */
- 	tfs = (FS *) xcalloc(1,sizeof(FS)); /*DBU:[dave@cray.com] start out NULL */
+	tfs = (FS *) xcalloc(1,sizeof(FS)); /*DBU:[dave@cray.com] start out NULL */
 	if (!bb_dump_fshead) {
 		bb_dump_fshead = tfs;
 	} else {
diff --git a/libbb/hash_fd.c b/libbb/hash_fd.c
index 3445a25a0..39825b378 100644
--- a/libbb/hash_fd.c
+++ b/libbb/hash_fd.c
@@ -212,7 +212,7 @@ static void sha1_end(unsigned char hval[], struct sha1_ctx_t *ctx)
 		ctx->wbuf[cnt++] = 0;
 
 	/* assemble the eight byte counter in the buffer in big-endian  */
-	/* format                                                       */
+	/* format					               */
 
 	ctx->wbuf[14] = swap_b32((ctx->count[1] << 3) | (ctx->count[0] >> 29));
 	ctx->wbuf[15] = swap_b32(ctx->count[0] << 3);
@@ -492,12 +492,12 @@ static void md5_hash_block(const void *buffer, size_t len, struct md5_ctx_t *ctx
 
 #  define OP(a, b, c, d, s, T)	\
       do	\
-        {	\
+	{	\
 	  a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;	\
 	  ++words;	\
 	  CYCLIC (a, s);	\
 	  a += b;	\
-        }	\
+	}	\
       while (0)
 
 		/* It is unfortunate that C does not provide an operator for
diff --git a/libbb/inet_common.c b/libbb/inet_common.c
index 321322d1f..3ff819742 100644
--- a/libbb/inet_common.c
+++ b/libbb/inet_common.c
@@ -206,8 +206,8 @@ int INET6_resolve(const char *name, struct sockaddr_in6 *sin6)
 
 #ifndef IN6_IS_ADDR_UNSPECIFIED
 # define IN6_IS_ADDR_UNSPECIFIED(a) \
-        (((__u32 *) (a))[0] == 0 && ((__u32 *) (a))[1] == 0 && \
-         ((__u32 *) (a))[2] == 0 && ((__u32 *) (a))[3] == 0)
+	(((__u32 *) (a))[0] == 0 && ((__u32 *) (a))[1] == 0 && \
+	 ((__u32 *) (a))[2] == 0 && ((__u32 *) (a))[3] == 0)
 #endif
 
 
diff --git a/libbb/loop.c b/libbb/loop.c
index 6c3144a77..09b2beaa7 100644
--- a/libbb/loop.c
+++ b/libbb/loop.c
@@ -56,7 +56,7 @@ char *query_loop(const char *device)
 	int fd;
 	bb_loop_info loopinfo;
 	char *dev=0;
-	
+
 	if ((fd = open(device, O_RDONLY)) < 0) return 0;
 	if (!ioctl(fd, BB_LOOP_GET_STATUS, &loopinfo))
 		dev=bb_xasprintf("%ld %s", (long) loopinfo.lo_offset,
@@ -64,7 +64,7 @@ char *query_loop(const char *device)
 	close(fd);
 
 	return dev;
-}	
+}
 
 
 int del_loop(const char *device)
@@ -74,7 +74,7 @@ int del_loop(const char *device)
 	if ((fd = open(device, O_RDONLY)) < 0) return 1;
 	rc=ioctl(fd, LOOP_CLR_FD, 0);
 	close(fd);
-	
+
 	return rc;
 }
 
diff --git a/libbb/printf.c b/libbb/printf.c
index 4451273ef..2cba31792 100644
--- a/libbb/printf.c
+++ b/libbb/printf.c
@@ -65,7 +65,7 @@
 /* Using either the original stdio implementation (from dev86) or
  * my original stdio rewrite.  Macros were:
  * #define ferror(fp)	(((fp)->mode&__MODE_ERR) != 0)
- * #define feof(fp)   	(((fp)->mode&__MODE_EOF) != 0)
+ * #define feof(fp)		(((fp)->mode&__MODE_EOF) != 0)
  * #define clearerr(fp)	((fp)->mode &= ~(__MODE_EOF|__MODE_ERR),0)
  */
 #define SET_FERROR_UNLOCKED(S)    ((S)->mode |= __MODE_ERR)
diff --git a/libbb/process_escape_sequence.c b/libbb/process_escape_sequence.c
index 28b1e3697..1b7b6d190 100644
--- a/libbb/process_escape_sequence.c
+++ b/libbb/process_escape_sequence.c
@@ -70,7 +70,7 @@ char bb_process_escape_sequence(const char **ptr)
 		if (d >= base) {
 #ifdef WANT_HEX_ESCAPES
 			if ((base == 16) && (!--num_digits)) {
-/* 				return '\\'; */
+/*				return '\\'; */
 				--q;
 			}
 #endif
diff --git a/libbb/run_shell.c b/libbb/run_shell.c
index 6d084eead..d5dc37b54 100644
--- a/libbb/run_shell.c
+++ b/libbb/run_shell.c
@@ -46,7 +46,7 @@ static security_context_t current_sid=NULL;
 void
 renew_current_security_context(void)
 {
-  if  (current_sid)  
+  if  (current_sid)
     freecon(current_sid);  /* Release old context  */
 
   getcon(&current_sid);  /* update */
@@ -56,7 +56,7 @@ renew_current_security_context(void)
 void
 set_current_security_context(security_context_t sid)
 {
-  if  (current_sid)  
+  if  (current_sid)
     freecon(current_sid);  /* Release old context  */
 
   current_sid=sid;
@@ -84,7 +84,7 @@ void run_shell ( const char *shell, int loginshell, const char *command, const c
 
 	args [0] = bb_get_last_path_component ( bb_xstrdup ( shell ));
 
-	if ( loginshell ) 
+	if ( loginshell )
 		args [0] = bb_xasprintf ("-%s", args [0]);
 
 	if ( command ) {
diff --git a/libbb/setup_environment.c b/libbb/setup_environment.c
index aeb285a53..dfab786d9 100644
--- a/libbb/setup_environment.c
+++ b/libbb/setup_environment.c
@@ -58,7 +58,7 @@ void setup_environment ( const char *shell, int loginshell, int changeenv, const
 		 * to change to that directory.  There is no "default" home
 		 * directory.
 		 * Some systems default to HOME=/
-		 */		
+		 */
 		if ( chdir ( pw-> pw_dir )) {
 			if ( chdir ( "/" )) {
 				syslog ( LOG_WARNING, "unable to cd to %s' for user %s'\n", pw-> pw_dir, pw-> pw_name );
@@ -81,7 +81,7 @@ void setup_environment ( const char *shell, int loginshell, int changeenv, const
 	}
 	else if ( changeenv ) {
 		/* Set HOME, SHELL, and if not becoming a super-user,
-	   	   USER and LOGNAME.  */
+		   USER and LOGNAME.  */
 		xsetenv ( "HOME",  pw-> pw_dir );
 		xsetenv ( "SHELL", shell );
 		if  ( pw-> pw_uid ) {
diff --git a/libbb/xgetlarg.c b/libbb/xgetlarg.c
index f24492bee..f332bb37e 100644
--- a/libbb/xgetlarg.c
+++ b/libbb/xgetlarg.c
@@ -22,7 +22,7 @@ extern long bb_xgetlarg(const char *arg, int base, long lower, long upper)
 	assert(arg!=NULL);
 
 	/* Don't allow leading whitespace.
-	 * Wrap isspace in () to make sure we call the 
+	 * Wrap isspace in () to make sure we call the
 	 * function rather than the macro. */
 	if ((isspace)(*arg)) {
 		bb_show_usage();
diff --git a/libbb/xgetularg.c b/libbb/xgetularg.c
index e90085446..8d793f3d1 100644
--- a/libbb/xgetularg.c
+++ b/libbb/xgetularg.c
@@ -75,7 +75,7 @@ unsigned long bb_xgetularg_bnd_sfx(const char *arg, int base,
 				++e;
 				r *= suffixes->mult;
 				break;
- 			}
+			}
 			++suffixes;
 		}
 	}
diff --git a/libbb/xreadlink.c b/libbb/xreadlink.c
index 49823fa7f..b3e3eda2b 100644
--- a/libbb/xreadlink.c
+++ b/libbb/xreadlink.c
@@ -14,7 +14,7 @@
 #include "libbb.h"
 
 extern char *xreadlink(const char *path)
-{   
+{
 	static const int GROWBY = 80; /* how large we will grow strings by */
 
 	char *buf = NULL;
diff --git a/libpwdgrp/pwd_grp.c b/libpwdgrp/pwd_grp.c
index 18782002d..faf53d7e1 100644
--- a/libpwdgrp/pwd_grp.c
+++ b/libpwdgrp/pwd_grp.c
@@ -220,7 +220,7 @@ int sgetspent_r(const char *string, struct spwd *result_buf,
 
 #ifdef L_getpwnam_r
 #define GETXXKEY_R_FUNC			getpwnam_r
-#define GETXXKEY_R_PARSER   	__parsepwent
+#define GETXXKEY_R_PARSER		__parsepwent
 #define GETXXKEY_R_ENTTYPE		struct passwd
 #define GETXXKEY_R_TEST(ENT)	(!strcmp((ENT)->pw_name, key))
 #define DO_GETXXKEY_R_KEYTYPE	const char *__restrict
@@ -230,7 +230,7 @@ int sgetspent_r(const char *string, struct spwd *result_buf,
 
 #ifdef L_getgrnam_r
 #define GETXXKEY_R_FUNC			getgrnam_r
-#define GETXXKEY_R_PARSER   	__parsegrent
+#define GETXXKEY_R_PARSER		__parsegrent
 #define GETXXKEY_R_ENTTYPE		struct group
 #define GETXXKEY_R_TEST(ENT)	(!strcmp((ENT)->gr_name, key))
 #define DO_GETXXKEY_R_KEYTYPE	const char *__restrict
@@ -240,7 +240,7 @@ int sgetspent_r(const char *string, struct spwd *result_buf,
 
 #ifdef L_getspnam_r
 #define GETXXKEY_R_FUNC			getspnam_r
-#define GETXXKEY_R_PARSER   	__parsespent
+#define GETXXKEY_R_PARSER		__parsespent
 #define GETXXKEY_R_ENTTYPE		struct spwd
 #define GETXXKEY_R_TEST(ENT)	(!strcmp((ENT)->sp_namp, key))
 #define DO_GETXXKEY_R_KEYTYPE	const char *__restrict
@@ -250,7 +250,7 @@ int sgetspent_r(const char *string, struct spwd *result_buf,
 
 #ifdef L_getpwuid_r
 #define GETXXKEY_R_FUNC			getpwuid_r
-#define GETXXKEY_R_PARSER   	__parsepwent
+#define GETXXKEY_R_PARSER		__parsepwent
 #define GETXXKEY_R_ENTTYPE		struct passwd
 #define GETXXKEY_R_TEST(ENT)	((ENT)->pw_uid == key)
 #define DO_GETXXKEY_R_KEYTYPE	uid_t
@@ -260,7 +260,7 @@ int sgetspent_r(const char *string, struct spwd *result_buf,
 
 #ifdef L_getgrgid_r
 #define GETXXKEY_R_FUNC			getgrgid_r
-#define GETXXKEY_R_PARSER   	__parsegrent
+#define GETXXKEY_R_PARSER		__parsegrent
 #define GETXXKEY_R_ENTTYPE		struct group
 #define GETXXKEY_R_TEST(ENT)	((ENT)->gr_gid == key)
 #define DO_GETXXKEY_R_KEYTYPE	gid_t
@@ -442,7 +442,7 @@ void endpwent(void)
 }
 
 
-int getpwent_r(struct passwd *__restrict resultbuf, 
+int getpwent_r(struct passwd *__restrict resultbuf,
 			   char *__restrict buffer, size_t buflen,
 			   struct passwd **__restrict result)
 {
@@ -542,7 +542,7 @@ void endspent(void)
 	UNLOCK;
 }
 
-int getspent_r(struct spwd *resultbuf, char *buffer, 
+int getspent_r(struct spwd *resultbuf, char *buffer,
 			   size_t buflen, struct spwd **result)
 {
 	int rv;
@@ -755,11 +755,11 @@ int putgrent(const struct group *__restrict p, FILE *__restrict f)
 
 static const unsigned char _sp_off[] = {
 	offsetof(struct spwd, sp_lstchg),	/* 2 - not a char ptr */
-	offsetof(struct spwd, sp_min), 		/* 3 - not a char ptr */
+	offsetof(struct spwd, sp_min),		/* 3 - not a char ptr */
 	offsetof(struct spwd, sp_max),		/* 4 - not a char ptr */
-	offsetof(struct spwd, sp_warn), 	/* 5 - not a char ptr */
-	offsetof(struct spwd, sp_inact), 	/* 6 - not a char ptr */
-	offsetof(struct spwd, sp_expire), 	/* 7 - not a char ptr */
+	offsetof(struct spwd, sp_warn),		/* 5 - not a char ptr */
+	offsetof(struct spwd, sp_inact),	/* 6 - not a char ptr */
+	offsetof(struct spwd, sp_expire),	/* 7 - not a char ptr */
 };
 
 int putspent(const struct spwd *p, FILE *stream)
@@ -801,18 +801,18 @@ DO_UNLOCK:
 
 #endif
 /**********************************************************************/
-/* Internal uClibc functions.                                         */
+/* Internal uClibc functions.					 */
 /**********************************************************************/
 #ifdef L___parsepwent
 
 static const unsigned char pw_off[] = {
-	offsetof(struct passwd, pw_name), 	/* 0 */
+	offsetof(struct passwd, pw_name),	/* 0 */
 	offsetof(struct passwd, pw_passwd),	/* 1 */
 	offsetof(struct passwd, pw_uid),	/* 2 - not a char ptr */
-	offsetof(struct passwd, pw_gid), 	/* 3 - not a char ptr */
+	offsetof(struct passwd, pw_gid),	/* 3 - not a char ptr */
 	offsetof(struct passwd, pw_gecos),	/* 4 */
-	offsetof(struct passwd, pw_dir), 	/* 5 */
-	offsetof(struct passwd, pw_shell) 	/* 6 */
+	offsetof(struct passwd, pw_dir),	/* 5 */
+	offsetof(struct passwd, pw_shell)	/* 6 */
 };
 
 int __parsepwent(void *data, char *line)
@@ -825,7 +825,7 @@ int __parsepwent(void *data, char *line)
 	do {
 		p = ((char *) ((struct passwd *) data)) + pw_off[i];
 
-		if ((i & 6) ^ 2) { 	/* i!=2 and i!=3 */
+		if ((i & 6) ^ 2) {	/* i!=2 and i!=3 */
 			*((char **) p) = line;
 			if (i==6) {
 				return 0;
@@ -865,7 +865,7 @@ int __parsepwent(void *data, char *line)
 #ifdef L___parsegrent
 
 static const unsigned char gr_off[] = {
-	offsetof(struct group, gr_name), 	/* 0 */
+	offsetof(struct group, gr_name),	/* 0 */
 	offsetof(struct group, gr_passwd),	/* 1 */
 	offsetof(struct group, gr_gid)		/* 2 - not a char ptr */
 };
@@ -947,7 +947,7 @@ int __parsegrent(void *data, char *line)
 					if (!--i) break;
 					while (*++p) {}
 				} while (1);
-			}				
+			}
 			*members = NULL;
 
 			return 0;
@@ -966,12 +966,12 @@ static const unsigned char sp_off[] = {
 	offsetof(struct spwd, sp_namp),		/* 0 */
 	offsetof(struct spwd, sp_pwdp),		/* 1 */
 	offsetof(struct spwd, sp_lstchg),	/* 2 - not a char ptr */
-	offsetof(struct spwd, sp_min), 		/* 3 - not a char ptr */
+	offsetof(struct spwd, sp_min),		/* 3 - not a char ptr */
 	offsetof(struct spwd, sp_max),		/* 4 - not a char ptr */
-	offsetof(struct spwd, sp_warn), 	/* 5 - not a char ptr */
-	offsetof(struct spwd, sp_inact), 	/* 6 - not a char ptr */
-	offsetof(struct spwd, sp_expire), 	/* 7 - not a char ptr */
-	offsetof(struct spwd, sp_flag) 		/* 8 - not a char ptr */
+	offsetof(struct spwd, sp_warn),		/* 5 - not a char ptr */
+	offsetof(struct spwd, sp_inact),	/* 6 - not a char ptr */
+	offsetof(struct spwd, sp_expire),	/* 7 - not a char ptr */
+	offsetof(struct spwd, sp_flag)		/* 8 - not a char ptr */
 };
 
 int __parsespent(void *data, char * line)
diff --git a/loginutils/Config.in b/loginutils/Config.in
index 89f699850..48bb1fee3 100644
--- a/loginutils/Config.in
+++ b/loginutils/Config.in
@@ -85,7 +85,7 @@ config CONFIG_GETTY
 
 config CONFIG_FEATURE_UTMP
 	bool "  Support utmp file"
-	depends on CONFIG_GETTY || CONFIG_LOGIN || CONFIG_SU || CONFIG_WHO 
+	depends on CONFIG_GETTY || CONFIG_LOGIN || CONFIG_SU || CONFIG_WHO
 	default n
 	help
 	  The file /var/run/utmp is used to track who is currently logged in.
@@ -96,7 +96,7 @@ config CONFIG_FEATURE_WTMP
 	default n
 	select CONFIG_FEATURE_UTMP
 	help
-	  The file /var/run/wtmp is used to track when user's have logged into 
+	  The file /var/run/wtmp is used to track when user's have logged into
 	  and logged out of the system.
 
 config CONFIG_LOGIN
diff --git a/loginutils/addgroup.c b/loginutils/addgroup.c
index 804d6961c..7b68f394e 100644
--- a/loginutils/addgroup.c
+++ b/loginutils/addgroup.c
@@ -163,7 +163,7 @@ int addgroup_main(int argc, char **argv)
 	} else {
 		user = "";
 	}
-	
+
 	if_i_am_not_root();
 
 	/* werk */
diff --git a/loginutils/adduser.c b/loginutils/adduser.c
index a25632e44..716f83069 100644
--- a/loginutils/adduser.c
+++ b/loginutils/adduser.c
@@ -244,7 +244,7 @@ int adduser_main(int argc, char **argv)
 	const char *gecos = default_gecos;
 	const char *home = NULL;
 	const char *shell = DEFAULT_SHELL;
- 	const char *usegroup = NULL;
+	const char *usegroup = NULL;
 	int flags;
 	int setpass = 1;
 	int makehome = 1;
@@ -293,7 +293,7 @@ int adduser_main(int argc, char **argv)
 	if (usegroup) {
 		/* Add user to a group that already exists */
 		pw.pw_gid = bb_xgetgrnam(usegroup);
-		/* exits on error */	
+		/* exits on error */
 	}
 
 	/* grand finale */
diff --git a/loginutils/login.c b/loginutils/login.c
index 21e807615..b2f3166e2 100644
--- a/loginutils/login.c
+++ b/loginutils/login.c
@@ -101,7 +101,7 @@ extern int login_main(int argc, char **argv)
 			if ( optarg != argv[optind-1] )
 				bb_show_usage( );
 
-			if ( !amroot ) 		/* Auth bypass only if real UID is zero */
+			if ( !amroot )		/* Auth bypass only if real UID is zero */
 				bb_error_msg_and_die ( "-f permission denied" );
 
 			safe_strncpy(username, optarg, USERNAME_SIZE);
diff --git a/loginutils/sulogin.c b/loginutils/sulogin.c
index f54939eef..434683299 100644
--- a/loginutils/sulogin.c
+++ b/loginutils/sulogin.c
@@ -53,9 +53,9 @@ extern int sulogin_main(int argc, char **argv)
 	char *device = (char *) 0;
 	const char *name = "root";
 	int timeout = 0;
-	
+
 #define pass bb_common_bufsiz1
-	
+
 	struct passwd pwent;
 	struct passwd *pwd;
 	const char * const *p;
diff --git a/miscutils/Config.in b/miscutils/Config.in
index 4d81dde0d..aed7e5a99 100644
--- a/miscutils/Config.in
+++ b/miscutils/Config.in
@@ -218,14 +218,14 @@ config CONFIG_MAKEDEVS
 	  .
 	  There are two choices for command line behaviour, the interface
 	  as used by LEAF/Linux Router Project, or a device table file.
-	  . 
+	  .
 	  'leaf' is traditionally what busybox follows, it allows multiple
 	  devices of a particluar type to be created per command.
 	  e.g. /dev/hda[0-9]
           Device properties are passed as command line arguments.
 	  .
 	  'table' reads device properties from a file or stdin, allowing
-	  a batch of unrelated devices to be makde with one command. 
+	  a batch of unrelated devices to be makde with one command.
           User/group names are allowed as an alternative to uid/gid.
 
 choice
diff --git a/miscutils/devfsd.c b/miscutils/devfsd.c
index 62d217345..d8a630c04 100644
--- a/miscutils/devfsd.c
+++ b/miscutils/devfsd.c
@@ -121,7 +121,7 @@ struct devfsd_notify_struct
 #define BUFFER_SIZE 16384
 #define DEVFSD_VERSION "1.3.25"
 #define CONFIG_FILE  "/etc/devfsd.conf"
-#define MODPROBE 		"/sbin/modprobe"
+#define MODPROBE		"/sbin/modprobe"
 #define MODPROBE_SWITCH_1 "-k"
 #define MODPROBE_SWITCH_2 "-C"
 #define CONFIG_MODULES_DEVFS "/etc/modules.devfs"
@@ -289,7 +289,7 @@ static struct event_type
 /* Busybox messages */
 
 static const char * const bb_msg_proto_rev			= "protocol revision";
-static const char * const bb_msg_bad_config   		= "bad %s config file: %s";
+static const char * const bb_msg_bad_config		= "bad %s config file: %s";
 static const char * const bb_msg_small_buffer		= "buffer too small";
 static const char * const bb_msg_variable_not_found = "variable: %s not found";
 
@@ -297,16 +297,16 @@ static const char * const bb_msg_variable_not_found = "variable: %s not found";
 static void msg_logger(int pri, const char * fmt, ... )
 {
 	va_list ap;
-	int ret; 
-	
+	int ret;
+
 	va_start(ap, fmt);
-	ret = access ("/dev/log", F_OK); 
+	ret = access ("/dev/log", F_OK);
 	if (ret == 0) {
 		openlog(bb_applet_name, 0, LOG_DAEMON);
 		vsyslog( pri , fmt, ap);
 		/* Man: A trailing newline is added when needed. */
 		closelog();
- 	} 
+	}
 	/* ENABLE_DEVFSD_VERBOSE is always enabled if msg_logger is used */
 	if ((ENABLE_DEVFSD_VERBOSE && ret) || ENABLE_DEBUG) {
 		bb_error_msg(fmt, ap);
@@ -319,28 +319,28 @@ static void msg_logger_and_die(int pri, const char* fmt, ...)
 	va_list ap;
 
 	va_start(ap, fmt);
- 	msg_logger(pri, fmt, ap);
+	msg_logger(pri, fmt, ap);
 	va_end(ap);
 	exit(EXIT_FAILURE);
 }
 
 /* Busybox stuff */
 #if defined(CONFIG_DEVFSD_VERBOSE) || defined(CONFIG_DEBUG)
-#define devfsd_error_msg(fmt, args...)                bb_error_msg(fmt, ## args)  
-#define devfsd_perror_msg_and_die(fmt, args...)       bb_perror_msg_and_die(fmt, ## args)  
-#define devfsd_error_msg_and_die(fmt, args...)        bb_error_msg_and_die(fmt, ## args)  
+#define devfsd_error_msg(fmt, args...)                bb_error_msg(fmt, ## args)
+#define devfsd_perror_msg_and_die(fmt, args...)       bb_perror_msg_and_die(fmt, ## args)
+#define devfsd_error_msg_and_die(fmt, args...)        bb_error_msg_and_die(fmt, ## args)
 #if defined(CONFIG_DEBUG)
 #define debug_msg_logger(x, fmt, args...)             msg_logger(x, fmt, ## args)
 #else
-#define debug_msg_logger(x, fmt, args...)    
+#define debug_msg_logger(x, fmt, args...)
 #endif
 #else
 #define debug_msg_logger(x, fmt, args...)
-#define msg_logger(p, fmt, args...) 
+#define msg_logger(p, fmt, args...)
 #define msg_logger_and_die(p, fmt, args...)           exit(1)
 #define devfsd_perror_msg_and_die(fmt, args...)       exit(1)
 #define devfsd_error_msg_and_die(fmt, args...)        exit(1)
-#define devfsd_error_msg(fmt, args...)   
+#define devfsd_error_msg(fmt, args...)
 #endif
 
 static void do_ioctl_and_die(int fd, int request, unsigned long event_mask_flag)
@@ -451,10 +451,10 @@ int devfsd_main (int argc, char **argv)
 		{
 			if(argv[count][1]=='v' && !argv[count][2]) /* -v */
 					print_version = TRUE;
-			else if(ENABLE_DEVFSD_FG_NP && argv[count][1]=='f' 
+			else if(ENABLE_DEVFSD_FG_NP && argv[count][1]=='f'
 					&& argv[count][2]=='g' && !argv[count][3]) /* -fg */
 					do_daemon = FALSE;
-			else if(ENABLE_DEVFSD_FG_NP && argv[count][1]=='n' 
+			else if(ENABLE_DEVFSD_FG_NP && argv[count][1]=='n'
 					&& argv[count][2]=='p' && !argv[count][3]) /* -np */
 					no_polling = TRUE;
 			else
@@ -470,7 +470,7 @@ int devfsd_main (int argc, char **argv)
 
 	if (chdir (mount_point) != 0)
 		devfsd_perror_msg_and_die(mount_point);
-	
+
 	fd = bb_xopen (".devfsd", O_RDONLY);
 
 	if (fcntl (fd, F_SETFD, FD_CLOEXEC) != 0)
@@ -503,15 +503,15 @@ int devfsd_main (int argc, char **argv)
 	new_action.sa_handler = signal_handler;
 	if (sigaction (SIGHUP, &new_action, NULL) != 0 || sigaction (SIGUSR1, &new_action, NULL) != 0 )
 		devfsd_error_msg_and_die( "sigaction");
-	
+
 	bb_printf("%s v%s  started for %s\n",bb_applet_name, DEVFSD_VERSION, mount_point);
 
-	/*  Set umask so that mknod(2), open(2) and mkdir(2) have complete control 	over permissions  */
+	/*  Set umask so that mknod(2), open(2) and mkdir(2) have complete control over permissions  */
 	umask (0);
 	read_config_file (CONFIG_FILE, FALSE, &event_mask);
 	/*  Do the scan before forking, so that boot scripts see the finished product  */
 	dir_operation(SERVICE,mount_point,0,NULL);
-	
+
 	if (ENABLE_DEVFSD_FG_NP && no_polling)
 		exit (0);
 	if (do_daemon)
@@ -553,7 +553,7 @@ static void read_config_file (char *path, int optional, unsigned long *event_mas
 	char *line=NULL;
 
 	debug_msg_logger(LOG_INFO, "%s: %s", __FUNCTION__, path);
-	
+
 	if (stat (path, &statbuf) == 0 )
 	{
 		/* Don't read 0 length files: ignored */
@@ -564,7 +564,7 @@ static void read_config_file (char *path, int optional, unsigned long *event_mas
 			/* strip last / from dirname so we don't need to check for it later */
 			while( path  && path[1]!='\0' && path[strlen(path)-1] == '/')
 				path[strlen(path) -1] = '\0';
-	
+
 			dir_operation(READ_CONFIG, path, 0, event_mask);
 			return;
 		}
@@ -586,7 +586,7 @@ static void read_config_file (char *path, int optional, unsigned long *event_mas
 	} else {
 read_config_file_err:
 	if(optional ==  0  && errno == ENOENT)
-		msg_logger_and_die(LOG_ERR, "read config file: %s: %m", path);	
+		msg_logger_and_die(LOG_ERR, "read config file: %s: %m", path);
 	}
 	return;
 }   /*  End Function read_config_file   */
@@ -691,7 +691,7 @@ static void process_config_line (const char *line, unsigned long *event_mask)
 			the device name) to the module loading  facility.  In  addition,
 			the /etc/modules.devfs configuration file is used.*/
 			 if (ENABLE_DEVFSD_MODLOAD)
-			 	new->action.what = AC_MODLOAD;
+				new->action.what = AC_MODLOAD;
 			 break;
 		case 6: /* EXECUTE */
 			new->action.what = AC_EXECUTE;
@@ -759,7 +759,7 @@ static int do_servicing (int fd, unsigned long event_mask)
 	unsigned long tmp_event_mask;
 
 	debug_msg_logger(LOG_INFO, __FUNCTION__);
-	
+
 	/*  Tell devfs what events we care about  */
 	tmp_event_mask = event_mask;
 	do_ioctl_and_die(fd, DEVFSDIOC_SET_EVENT_MASK, tmp_event_mask);
@@ -816,9 +816,9 @@ static void service_name (const struct devfsd_notify_struct *info)
 			continue;
 		for (n = 0; (n < MAX_SUBEXPR) && (mbuf[n].rm_so != -1); ++n)
 			/* VOID */;
-		
+
 		debug_msg_logger(LOG_INFO, "%s: action.what %d", __FUNCTION__, entry->action.what);
-		
+
 		switch (entry->action.what)
 		{
 			case AC_PERMISSIONS:
@@ -928,7 +928,7 @@ static void action_execute (const struct devfsd_notify_struct *info,
 
 static void action_copy (const struct devfsd_notify_struct *info,
 			 const struct config_entry_struct *entry,
-                         const regmatch_t *regexpr, unsigned int numexpr)
+			 const regmatch_t *regexpr, unsigned int numexpr)
 /*  [SUMMARY] Copy permissions.
     <info> The devfs change.
     <entry> The config file entry.
@@ -945,9 +945,9 @@ static void action_copy (const struct devfsd_notify_struct *info,
 	int ret = 0;
 
 	debug_msg_logger(LOG_INFO, __FUNCTION__);
-	
+
 	dest_stat.st_mode = 0;
-	
+
 	if ( (info->type == DEVFSD_NOTIFY_CHANGE) && S_ISLNK (info->mode) )
 		return;
 	gv_info.info = info;
@@ -970,7 +970,7 @@ static void action_copy (const struct devfsd_notify_struct *info,
 		new_mode |= S_ISVTX;
 	else if ( (info->type == DEVFSD_NOTIFY_CHANGE) && (dest_stat.st_mode & S_ISVTX) )
 		new_mode |= S_ISVTX;
-	ret = copy_inode (destination, &dest_stat, new_mode, source, &source_stat); 
+	ret = copy_inode (destination, &dest_stat, new_mode, source, &source_stat);
 	if (ENABLE_DEBUG && ret && (errno != EEXIST))
 		debug_msg_logger(LOG_ERR, "copy_inode: %s to %s: %m", source, destination);
 	return;
@@ -1126,7 +1126,7 @@ static int copy_inode (const char *destpath, const struct stat *dest_stat,
 				( dest_len   = readlink (destpath  , dest_link  , STRING_LENGTH - 1) ) < 0 )
 				return (FALSE);
 			source_link[source_len]	= '\0';
-			dest_link[dest_len] 	= '\0';
+			dest_link[dest_len]	= '\0';
 			if ( (source_len != dest_len) || (strcmp (source_link, dest_link) != 0) )
 			{
 				unlink (destpath);
@@ -1224,12 +1224,12 @@ static int get_uid_gid (int flag, const char *string)
 	struct passwd *pw_ent;
 	struct group *grp_ent;
 	static char *msg;
-	
+
 	if (ENABLE_DEVFSD_VERBOSE)
 		msg="user";
 
 	debug_msg_logger(LOG_INFO, __FUNCTION__);
-	
+
 	if(ENABLE_DEBUG && flag != UID && flag != GID)
 		msg_logger_and_die(LOG_ERR,"%s: flag != UID && flag != GID", __FUNCTION__);
 
@@ -1241,7 +1241,7 @@ static int get_uid_gid (int flag, const char *string)
 
 	if ( flag == GID && ( grp_ent = getgrnam (string) ) != NULL )
 		return (grp_ent->gr_gid);
-	else if(ENABLE_DEVFSD_VERBOSE) 
+	else if(ENABLE_DEVFSD_VERBOSE)
 		msg="group";
 
 	if(ENABLE_DEVFSD_VERBOSE)
@@ -1264,7 +1264,7 @@ static mode_t get_mode (const char *string)
 		return strtoul (string, NULL, 8);
 	if (strlen (string) != 9)
 		msg_logger_and_die(LOG_ERR, "bad mode: %s", string);
-	
+
 	mode = 0;
 	i= S_IRUSR;
 	while(i>0)
@@ -1280,7 +1280,7 @@ static mode_t get_mode (const char *string)
 static void signal_handler (int sig)
 {
 	debug_msg_logger(LOG_INFO, __FUNCTION__);
-	
+
 	caught_signal = TRUE;
 	if (sig == SIGHUP)
 		caught_sighup = TRUE;
@@ -1301,7 +1301,7 @@ static const char *get_variable (const char *variable, void *info)
 
 	if (gethostname (hostname, STRING_LENGTH - 1) != 0)
 		msg_logger_and_die(LOG_ERR, "gethostname: %m");
-		
+
 		/* Here on error we should do exit(RV_SYS_ERROR), instead we do exit(EXIT_FAILURE) */
 		hostname[STRING_LENGTH - 1] = '\0';
 
@@ -1442,9 +1442,9 @@ static int make_dir_tree (const char *path)
 static int expand_expression(char *output, unsigned int outsize,
 			      const char *input,
 			      const char *(*get_variable_func)(const char *variable, void *info),
-                              void *info,
-                              const char *devname,
-                              const regmatch_t *ex, unsigned int numexp)
+			      void *info,
+			      const char *devname,
+			      const regmatch_t *ex, unsigned int numexp)
 /*  [SUMMARY] Expand environment variables and regular subexpressions in string.
     <output> The output expanded expression is written here.
     <length> The size of the output buffer.
@@ -1632,7 +1632,7 @@ const char *get_old_name (const char *devname, unsigned int namelen,
 		compat_name = buffer;
 	else
 		return NULL;
-		
+
 	debug_msg_logger(LOG_INFO, "%s: scan_dev_name = %d", __FUNCTION__, i);
 
 	/* 1 == scsi/generic, 3 == scsi/cd, 10 == sbp/ */
@@ -1677,10 +1677,10 @@ const char *get_old_name (const char *devname, unsigned int namelen,
 		indexx = atoi (devname + 5);
 		sprintf (buffer, fmt[i], (devname[4] == 'm') ? 'p' : 't', pty1[indexx >> 4], pty2[indexx & 0x0f]);
 	}
-	
+
 	if(ENABLE_DEBUG && compat_name!=NULL)
 		msg_logger(LOG_INFO, "%s: compat_name  %s", __FUNCTION__, compat_name);
-		
+
 	return (compat_name);
 }   /*  End Function get_old_name  */
 
@@ -1692,7 +1692,7 @@ static char get_old_ide_name (unsigned int major, unsigned int minor)
 */
 {
 	char letter='y';	/* 121 */
-	char c='a'; 		/*  97 */
+	char c='a';		/*  97 */
 	int i=IDE0_MAJOR;
 
 	debug_msg_logger(LOG_INFO, __FUNCTION__);
diff --git a/miscutils/eject.c b/miscutils/eject.c
index 3f1d6ab44..511d8b204 100644
--- a/miscutils/eject.c
+++ b/miscutils/eject.c
@@ -28,7 +28,7 @@
 #include <sys/ioctl.h>
 #include <unistd.h>
 #include <sys/mount.h>
-#include <mntent.h> 
+#include <mntent.h>
 #include "busybox.h"
 
 /* various defines swiped from linux/cdrom.h */
@@ -41,16 +41,16 @@ extern int eject_main(int argc, char **argv)
 	unsigned long flags;
 	char *device;
 	struct mntent *m;
-	
+
 	flags = bb_getopt_ulflags(argc, argv, "t");
 	device=argv[optind] ? : DEFAULT_CDROM;
-	
+
 	if((m = find_mount_point(device, bb_path_mtab_file))) {
 		if(umount(m->mnt_dir))
 			bb_error_msg_and_die("Can't umount");
-		else if(ENABLE_FEATURE_MTAB_SUPPORT) erase_mtab(m->mnt_fsname);	
+		else if(ENABLE_FEATURE_MTAB_SUPPORT) erase_mtab(m->mnt_fsname);
 	}
-	if (ioctl(bb_xopen( device, (O_RDONLY | O_NONBLOCK)), 
+	if (ioctl(bb_xopen( device, (O_RDONLY | O_NONBLOCK)),
 	          ( flags ? CDROMCLOSETRAY : CDROMEJECT)))
 	{
 		bb_perror_msg_and_die(device);
diff --git a/miscutils/hdparm.c b/miscutils/hdparm.c
index 04ce073db..4bf0d45ce 100644
--- a/miscutils/hdparm.c
+++ b/miscutils/hdparm.c
@@ -74,8 +74,8 @@
 #define RW_LONG			22  /* extra bytes in R/W LONG cmd ( < ATA-4)*/
 #define START_FW_REV            23  /* ASCII firmware revision */
 #define LENGTH_FW_REV		 4  /*  4 words (8 bytes or characters) */
-#define START_MODEL    		27  /* ASCII model number */
-#define LENGTH_MODEL    	20  /* 20 words (40 bytes or characters) */
+#define START_MODEL		27  /* ASCII model number */
+#define LENGTH_MODEL		20  /* 20 words (40 bytes or characters) */
 #define SECTOR_XFER_MAX	        47  /* r/w multiple: max sectors xfered */
 #define DWORD_IO		48  /* can do double-word IO (ATA-1 only) */
 #define CAPAB_0			49  /* capabilities */
@@ -121,12 +121,12 @@
 				       in low byte, 0x40 in high byte. */
 #define PSWD_CODE		92  /* master password revision code	*/
 #define HWRST_RSLT		93  /* hardware reset result */
-#define ACOUSTIC  		94  /* acoustic mgmt values ( >= ATA-6) */
+#define ACOUSTIC		94  /* acoustic mgmt values ( >= ATA-6) */
 #define LBA_LSB			100 /* LBA: maximum.  Currently only 48 */
 #define LBA_MID			101 /*      bits are used, but addr 103 */
 #define LBA_48_MSB		102 /*      has been reserved for LBA in */
 #define LBA_64_MSB		103 /*      the future. */
-#define RM_STAT 		127 /* removable media status notification feature set support */
+#define RM_STAT			127 /* removable media status notification feature set support */
 #define SECU_STATUS		128 /* security status */
 #define CFA_PWR_MODE		160 /* CFA power mode 1 */
 #define START_MEDIA             176 /* media serial number */
@@ -229,7 +229,7 @@ static const char * const ata1_cfg_str[] = {			/* word 0 in ATA-1 mode */
  */
 #define STBY_NID_VAL		0x37c8  /*     (a) and     (b) */
 #define STBY_ID_VAL		0x738c	/*     (a) and not (b) */
-#define PWRD_NID_VAL 		0x8c73	/* not (a) and     (b) */
+#define PWRD_NID_VAL		0x8c73	/* not (a) and     (b) */
 #define PWRD_ID_VAL		0xc837	/* not (a) and not (b) */
 
 /* words 47 & 59: sector_xfer_max & sector_xfer_cur */
@@ -237,7 +237,7 @@ static const char * const ata1_cfg_str[] = {			/* word 0 in ATA-1 mode */
 #define MULTIPLE_SETTING_VALID  0x0100  /* 1=multiple sector setting is valid */
 
 /* word 49: capabilities 0 */
-#define STD_STBY  	  	0x2000  /* 1=standard values supported (ATA);
+#define STD_STBY		0x2000  /* 1=standard values supported (ATA);
 					   0=vendor specific values */
 #define IORDY_SUP		0x0800  /* 1=support; 0=may be supported */
 #define IORDY_OFF		0x0400  /* 1=may be disabled */
@@ -255,7 +255,7 @@ static const char * const ata1_cfg_str[] = {			/* word 0 in ATA-1 mode */
 #define MODE			0xff00  /* the mode is in the MSBs */
 
 /* word 53: whats_valid */
-#define OK_W88     	   	0x0004	/* the ultra_dma info is valid */
+#define OK_W88			0x0004	/* the ultra_dma info is valid */
 #define OK_W64_70		0x0002  /* see above for word descriptions */
 #define OK_W54_58		0x0001  /* current cyl, head, sector, cap. info valid */
 
@@ -314,25 +314,25 @@ static const char * const minor_str[] = {				/* word 81 value: */
 #endif
 static const char actual_ver[] = {
 			/* word 81 value: */
-	0,		/* 0x0000	WARNING: 	*/
-	1,		/* 0x0001	WARNING: 	*/
-	1,		/* 0x0002	WARNING: 	*/
-	1,		/* 0x0003	WARNING: 	*/
-	2,		/* 0x0004	WARNING:   This array 		*/
-	2,		/* 0x0005	WARNING:   corresponds 		*/
+	0,		/* 0x0000	WARNING:	*/
+	1,		/* 0x0001	WARNING:	*/
+	1,		/* 0x0002	WARNING:	*/
+	1,		/* 0x0003	WARNING:	*/
+	2,		/* 0x0004	WARNING:   This array		*/
+	2,		/* 0x0005	WARNING:   corresponds		*/
 	3,		/* 0x0006	WARNING:   *exactly*		*/
 	2,		/* 0x0007	WARNING:   to the ATA/		*/
 	3,		/* 0x0008	WARNING:   ATAPI version	*/
-	2,		/* 0x0009	WARNING:   listed in	 	*/
-	3,		/* 0x000a	WARNING:   the 		 	*/
-	3,		/* 0x000b	WARNING:   minor_str 		*/
+	2,		/* 0x0009	WARNING:   listed in		*/
+	3,		/* 0x000a	WARNING:   the			*/
+	3,		/* 0x000b	WARNING:   minor_str		*/
 	3,		/* 0x000c	WARNING:   array		*/
 	4,		/* 0x000d	WARNING:   above.		*/
-	4,		/* 0x000e	WARNING:  			*/
-	4,		/* 0x000f	WARNING:   if you change 	*/
-	4,		/* 0x0010	WARNING:   that one,      	*/
+	4,		/* 0x000e	WARNING:			*/
+	4,		/* 0x000f	WARNING:   if you change	*/
+	4,		/* 0x0010	WARNING:   that one,		*/
 	4,		/* 0x0011	WARNING:   change this one	*/
-	4,		/* 0x0012	WARNING:   too!!!        	*/
+	4,		/* 0x0012	WARNING:   too!!!		*/
 	5,		/* 0x0013	WARNING:	*/
 	4,		/* 0x0014	WARNING:	*/
 	5,		/* 0x0015	WARNING:	*/
@@ -343,7 +343,7 @@ static const char actual_ver[] = {
 	0,		/* 0x001a	WARNING:	*/
 	6,		/* 0x001b	WARNING:	*/
 	6,		/* 0x001c	WARNING:	*/
-	0		/* 0x001d-0xfffe    		*/
+	0		/* 0x001d-0xfffe		*/
 };
 
 /* words 82-84: cmds/feats supported */
@@ -387,7 +387,7 @@ static const char * const cmd_feat_str[] = {
 	"Adv. Power Management feature set",/* word 83 bit  3 */
 	"CFA feature set",			/* word 83 bit  2 */
 	"READ/WRITE DMA QUEUED",		/* word 83 bit  1 */
-	"DOWNLOAD MICROCODE cmd", 		/* word 83 bit  0 */
+	"DOWNLOAD MICROCODE cmd",		/* word 83 bit  0 */
 						/* --------------*/
 	"",					/* word 84 bit 15: !valid bit */
 	"",					/* word 84 bit 14:  valid bit */
@@ -428,7 +428,7 @@ static const char * const cmd_feat_str[] = {
 #define CSEL_VAL		0x0004  /* device num determined by CSEL_VAL */
 
 /* word 127: removable media status notification feature set support */
-#define RM_STAT_BITS 		0x0003
+#define RM_STAT_BITS		0x0003
 #define RM_STAT_SUP		0x0001
 
 /* word 128: security */
@@ -774,7 +774,7 @@ static void identify (uint16_t *id_supplied, const char *devname)
 			like_std = 6;
 		}
 		else if(((std == 4) || (!std && (like_std < 5))) &&
-			((((val[INTEGRITY] 	& SIG) == SIG_VAL) && !chksum) ||
+			((((val[INTEGRITY]	& SIG) == SIG_VAL) && !chksum) ||
 			((	val[HWRST_RSLT] & VALID) == VALID_VAL) ||
 			(((	val[CMDS_SUPP_1] & VALID) == VALID_VAL) &&
 			((	val[CMDS_SUPP_1] & CMDS_W83) > 0x001f)) ) )
@@ -805,14 +805,14 @@ static void identify (uint16_t *id_supplied, const char *devname)
 		if(!std)
 			printf("\n\tLikely used: %u\n",like_std);
 		else if(like_std > std)
-		 	printf("& some of %u\n",like_std);
+			printf("& some of %u\n",like_std);
 		else
 			printf("\n");
 	}
 	else
 	{
 		/* TBD: do CDROM stuff more thoroughly.  For now... */
-	  	kk = 0;
+		kk = 0;
 		if(val[CDR_MINOR] == 9)
 		{
 			kk = 1;
@@ -886,7 +886,7 @@ static void identify (uint16_t *id_supplied, const char *devname)
 		ll = (uint32_t)val[LBA_SECTS_MSB] << 16 | val[LBA_SECTS_LSB];
 		mm = 0; bbbig = 0;
 		if ( (ll > 0x00FBFC10) && (!val[LCYLS]))
-		  	printf("\tCHS addressing not supported\n");
+			printf("\tCHS addressing not supported\n");
 		else
 		{
 			jj = val[WHATS_VALID] & OK_W54_58;
@@ -915,9 +915,9 @@ static void identify (uint16_t *id_supplied, const char *devname)
 		if( ((val[CMDS_SUPP_1] & VALID) == VALID_VAL) &&
 		     (val[CMDS_SUPP_1] & SUPPORT_48_BIT) )
 		{
-			bbbig = (__u64)val[LBA_64_MSB] 	<< 48 |
-			        (__u64)val[LBA_48_MSB] 	<< 32 |
-			        (__u64)val[LBA_MID] 	<< 16 |
+			bbbig = (__u64)val[LBA_64_MSB]	<< 48 |
+			        (__u64)val[LBA_48_MSB]	<< 32 |
+			        (__u64)val[LBA_MID]	<< 16 |
 					val[LBA_LSB] ;
 			printf("\tLBA48  user addressable sectors:%11llu\n",bbbig);
 		}
@@ -1081,7 +1081,7 @@ static void identify (uint16_t *id_supplied, const char *devname)
 
 	/* Programmed IO stuff */
 	printf("\tPIO: ");
-        /* If a drive supports mode n (e.g. 3), it also supports all modes less
+	/* If a drive supports mode n (e.g. 3), it also supports all modes less
 	 * than n (e.g. 3, 2, 1 and 0).  Print all the modes. */
 	if((val[WHATS_VALID] & OK_W64_70) && (val[ADV_PIO_MODES] & PIO_SUP))
 	{
@@ -1349,8 +1349,8 @@ static void dump_identity (const struct hd_driveid *id)
 	capacity = (id->cur_capacity1 << 16) | id->cur_capacity0;
 #endif
 	printf(" CurCHS=%u/%u/%u, CurSects=%lu, LBA=%s",id->cur_cyls, id->cur_heads,
-								 					id->cur_sectors, capacity ,
-								 			((id->capability&2)==0)?"no":"yes");
+													id->cur_sectors, capacity ,
+											((id->capability&2)==0)?"no":"yes");
 
 	if_printf((id->capability&2),", LBAsects=%u", id->lba_capacity);
 
@@ -1363,7 +1363,7 @@ static void dump_identity (const struct hd_driveid *id)
 			if_strcat((id->dma_1word & 0x200),	dmodes, "*");
 			if_strcat((id->dma_1word & 2),		dmodes, "sdma1 ");
 			if_strcat((id->dma_1word & 0x400),	dmodes, "*");
-			if_strcat((id->dma_1word & 4), 		dmodes, "sdma2 ");
+			if_strcat((id->dma_1word & 4),		dmodes, "sdma2 ");
 			if_strcat((id->dma_1word & 0xf800),	dmodes, "*");
 			if_strcat((id->dma_1word & 0xf8),	dmodes, "sdma? ");
 			if_strcat((id->dma_mword & 0x100),	dmodes, "*");
@@ -2346,7 +2346,7 @@ static void process_dev (char *devname)
 		no_scsi();
 		if (ioctl(fd, HDIO_DRIVE_CMD, &args)
 			 && (args[0] = WIN_CHECKPOWERMODE2) /* try again with 0x98 */
-		 	&& ioctl(fd, HDIO_DRIVE_CMD, &args))
+			&& ioctl(fd, HDIO_DRIVE_CMD, &args))
 		{
 			if (errno != EIO || args[0] != 0 || args[1] != 0)
 				state = "unknown";
@@ -2456,7 +2456,7 @@ identify_abort:
 
 
 	if (do_ctimings)
-		do_time(0,fd); 		/*time cache  */
+		do_time(0,fd);		/*time cache  */
 	if (do_timings)
 		do_time(1,fd);		/*time device */
 	if (do_flush)
diff --git a/miscutils/mountpoint.c b/miscutils/mountpoint.c
index 771df5588..38c654c6d 100644
--- a/miscutils/mountpoint.c
+++ b/miscutils/mountpoint.c
@@ -47,7 +47,7 @@ int mountpoint_main(int argc, char **argv)
 				dev_t st_dev = st.st_dev;
 				ino_t st_ino = st.st_ino;
 				char *p = bb_xasprintf("%s/..", arg);
-				
+
 				if (stat(p, &st) == 0) {
 					short ret = (st_dev != st.st_dev) ||
 						(st_dev == st.st_dev && st_ino == st.st_ino);
diff --git a/miscutils/setsid.c b/miscutils/setsid.c
index 7df35be3b..8061896f5 100644
--- a/miscutils/setsid.c
+++ b/miscutils/setsid.c
@@ -20,7 +20,7 @@
 
 int
 setsid_main(int argc, char *argv[]) {
-	
+
 	if (argc < 2) {
 		bb_show_usage();
 	}
diff --git a/miscutils/strings.c b/miscutils/strings.c
index 111aa94ba..df7ff093b 100644
--- a/miscutils/strings.c
+++ b/miscutils/strings.c
@@ -47,23 +47,23 @@ int strings_main(int argc, char **argv)
 	char *string;
 	const char *fmt = "%s: ";
 	char *n_arg = "4";
-	
+
 	opt = bb_getopt_ulflags (argc, argv, "afon:", &n_arg);
 	/* -a is our default behaviour */
-	
+
 	argc -= optind;
 	argv += optind;
 
 	n = bb_xgetlarg(n_arg, 10, 1, INT_MAX);
 	string = xcalloc(n + 1, 1);
 	n--;
-	
+
 	if ( argc == 0) {
 		fmt = "{%s}: ";
 		*argv = (char *)bb_msg_standard_input;
 		goto PIPE;
 	}
-	
+
 	do {
 		if ((file = bb_wfopen(*argv, "r"))) {
 PIPE:
diff --git a/miscutils/watchdog.c b/miscutils/watchdog.c
index 4b00e50c6..944288d29 100644
--- a/miscutils/watchdog.c
+++ b/miscutils/watchdog.c
@@ -29,7 +29,7 @@ static void watchdog_shutdown(int unused)
 
 int watchdog_main(int argc, char **argv)
 {
-	
+
 	char *t_arg;
 	unsigned long flags;
 	flags = bb_getopt_ulflags(argc, argv, "t:", &t_arg);
diff --git a/modutils/Config.in b/modutils/Config.in
index 8f23be836..b04988c7a 100644
--- a/modutils/Config.in
+++ b/modutils/Config.in
@@ -75,9 +75,9 @@ config CONFIG_LSMOD
 config CONFIG_FEATURE_LSMOD_PRETTY_2_6_OUTPUT
 	bool "lsmod pretty output for 2.6.x Linux kernels "
 	default n
-	depends on CONFIG_LSMOD 
+	depends on CONFIG_LSMOD
 	help
-	  This option makes output format of lsmod adjusted to 
+	  This option makes output format of lsmod adjusted to
 	  the format of module-init-tools for Linux kernel 2.6.
 
 config CONFIG_MODPROBE
diff --git a/modutils/insmod.c b/modutils/insmod.c
index 79bdebd2c..390a50316 100644
--- a/modutils/insmod.c
+++ b/modutils/insmod.c
@@ -295,7 +295,7 @@ extern int insmod_ng_main( int argc, char **argv);
 #define CONFIG_PLT_ENTRY_SIZE 8
 #define CONFIG_USE_SINGLE
 #ifndef EM_CYGNUS_V850	/* grumble */
-#define EM_CYGNUS_V850 	0x9080
+#define EM_CYGNUS_V850	0x9080
 #endif
 #define SYMBOL_PREFIX	"_"
 #endif
@@ -695,7 +695,7 @@ static int obj_gpl_license(struct obj_file *f, const char **license);
 #ifdef SYMBOL_PREFIX
 #define SPFX	SYMBOL_PREFIX
 #else
-#define SPFX 	""
+#define SPFX	""
 #endif
 
 
diff --git a/modutils/lsmod.c b/modutils/lsmod.c
index 3d9f700fb..018bc5323 100644
--- a/modutils/lsmod.c
+++ b/modutils/lsmod.c
@@ -173,7 +173,7 @@ extern int lsmod_main(int argc, char **argv)
 
 	  while (fgets(line, sizeof(line), file)) {
 	    char *tok;
-	    
+
 	    tok = strtok(line, " \t");
 	    printf("%-19s", tok);
 	    tok = strtok(NULL, " \t\n");
diff --git a/modutils/rmmod.c b/modutils/rmmod.c
index 7bc929de2..44c606e47 100644
--- a/modutils/rmmod.c
+++ b/modutils/rmmod.c
@@ -60,7 +60,7 @@ extern int rmmod_main(int argc, char **argv)
 	int n, ret = EXIT_SUCCESS;
 	unsigned int flags = O_NONBLOCK|O_EXCL;
 #ifdef CONFIG_FEATURE_QUERY_MODULE_INTERFACE
-	/* bb_common_bufsiz1 hold the module names which we ignore 
+	/* bb_common_bufsiz1 hold the module names which we ignore
 	   but must get */
 	size_t bufsize = sizeof(bb_common_bufsiz1);
 #endif
@@ -76,7 +76,7 @@ extern int rmmod_main(int argc, char **argv)
 		/* until the number of modules does not change */
 		size_t nmod = 0; /* number of modules */
 		size_t pnmod = -1; /* previous number of modules */
-		                
+
 		while (nmod != pnmod) {
 			if (syscall(__NR_delete_module, NULL, flags) != 0) {
 				if (errno==EFAULT)
@@ -101,7 +101,7 @@ extern int rmmod_main(int argc, char **argv)
 #ifdef CONFIG_FEATURE_2_6_MODULES
 		const char *afterslash;
 		char *module_name;
-		
+
 		afterslash = strrchr(argv[n], '/');
 		if (!afterslash)
 			afterslash = argv[n];
diff --git a/networking/ether-wake.c b/networking/ether-wake.c
index 9ea5c0366..7d5f79b6a 100644
--- a/networking/ether-wake.c
+++ b/networking/ether-wake.c
@@ -14,53 +14,53 @@
 /* full usage according Donald Becker
  * usage: ether-wake [-i <ifname>] [-p aa:bb:cc:dd[:ee:ff]] 00:11:22:33:44:55\n"
  *
- * 	This program generates and transmits a Wake-On-LAN (WOL)\n"
- * 	\"Magic Packet\", used for restarting machines that have been\n"
- * 	soft-powered-down (ACPI D3-warm state).\n"
- * 	It currently generates the standard AMD Magic Packet format, with\n"
- * 	an optional password appended.\n"
+ *	This program generates and transmits a Wake-On-LAN (WOL)\n"
+ *	\"Magic Packet\", used for restarting machines that have been\n"
+ *	soft-powered-down (ACPI D3-warm state).\n"
+ *	It currently generates the standard AMD Magic Packet format, with\n"
+ *	an optional password appended.\n"
  *
- * 	The single required parameter is the Ethernet MAC (station) address\n"
- * 	of the machine to wake or a host ID with known NSS 'ethers' entry.\n"
- * 	The MAC address may be found with the 'arp' program while the target\n"
- * 	machine is awake.\n"
+ *	The single required parameter is the Ethernet MAC (station) address\n"
+ *	of the machine to wake or a host ID with known NSS 'ethers' entry.\n"
+ *	The MAC address may be found with the 'arp' program while the target\n"
+ *	machine is awake.\n"
  *
- * 	Options:\n"
- * 		-b	Send wake-up packet to the broadcast address.\n"
- * 		-D	Increase the debug level.\n"
- * 		-i ifname	Use interface IFNAME instead of the default 'eth0'.\n"
- * 		-p <pw>		Append the four or six byte password PW to the packet.\n"
- * 					A password is only required for a few adapter types.\n"
- * 					The password may be specified in ethernet hex format\n"
- * 					or dotted decimal (Internet address)\n"
- * 		-p 00:22:44:66:88:aa\n"
- * 		-p 192.168.1.1\n";
- * 
+ *	Options:\n"
+ *		-b	Send wake-up packet to the broadcast address.\n"
+ *		-D	Increase the debug level.\n"
+ *		-i ifname	Use interface IFNAME instead of the default 'eth0'.\n"
+ *		-p <pw>		Append the four or six byte password PW to the packet.\n"
+ *					A password is only required for a few adapter types.\n"
+ *					The password may be specified in ethernet hex format\n"
+ *					or dotted decimal (Internet address)\n"
+ *		-p 00:22:44:66:88:aa\n"
+ *		-p 192.168.1.1\n";
+ *
+ *
+ *	This program generates and transmits a Wake-On-LAN (WOL) "Magic Packet",
+ *	used for restarting machines that have been soft-powered-down
+ *	(ACPI D3-warm state).  It currently generates the standard AMD Magic Packet
+ *	format, with an optional password appended.
+ *
+ *	This software may be used and distributed according to the terms
+ *	of the GNU Public License, incorporated herein by reference.
+ *	Contact the author for use under other terms.
+ *
+ *	This source file was originally part of the network tricks package, and
+ *	is now distributed to support the Scyld Beowulf system.
+ *	Copyright 1999-2003 Donald Becker and Scyld Computing Corporation.
+ *
+ *	The author may be reached as becker@scyld, or C/O
+ *	 Scyld Computing Corporation
+ *	 914 Bay Ridge Road, Suite 220
+ *	 Annapolis MD 21403
  *
- * 	This program generates and transmits a Wake-On-LAN (WOL) "Magic Packet",
- * 	used for restarting machines that have been soft-powered-down
- * 	(ACPI D3-warm state).  It currently generates the standard AMD Magic Packet
- * 	format, with an optional password appended.
- * 
- * 	This software may be used and distributed according to the terms
- * 	of the GNU Public License, incorporated herein by reference.
- * 	Contact the author for use under other terms.
- * 
- * 	This source file was originally part of the network tricks package, and
- * 	is now distributed to support the Scyld Beowulf system.
- * 	Copyright 1999-2003 Donald Becker and Scyld Computing Corporation.
- * 
- * 	The author may be reached as becker@scyld, or C/O
- * 	 Scyld Computing Corporation
- * 	 914 Bay Ridge Road, Suite 220
- * 	 Annapolis MD 21403
- * 
  *   Notes:
  *   On some systems dropping root capability allows the process to be
  *   dumped, traced or debugged.
  *   If someone traces this program, they get control of a raw socket.
  *   Linux handles this safely, but beware when porting this program.
- * 
+ *
  *   An alternative to needing 'root' is using a UDP broadcast socket, however
  *   doing so only works with adapters configured for unicast+broadcast Rx
  *   filter.  That configuration consumes more power.
diff --git a/networking/fakeidentd.c b/networking/fakeidentd.c
index 40d5cf1b7..c7fb42fc4 100644
--- a/networking/fakeidentd.c
+++ b/networking/fakeidentd.c
@@ -55,7 +55,7 @@ static const int ident_substr_len = sizeof(ident_substr) - 1;
 #define PIDFILE "/var/run/identd.pid"
 
 /*
- * We have to track the 'first connection socket' so that we 
+ * We have to track the 'first connection socket' so that we
  * don't go around closing file descriptors for non-clients.
  *
  * descriptor setup normally
diff --git a/networking/hostname.c b/networking/hostname.c
index a00263d8f..8b9314c98 100644
--- a/networking/hostname.c
+++ b/networking/hostname.c
@@ -77,8 +77,8 @@ int hostname_main(int argc, char **argv)
 	if (argc < 1)
 		bb_show_usage();
 
-        while ((opt = getopt(argc, argv, "dfisF:")) > 0) {
-                switch (opt) {
+	while ((opt = getopt(argc, argv, "dfisF:")) > 0) {
+		switch (opt) {
 		case 'd':
 		case 'f':
 		case 'i':
diff --git a/networking/ifupdown.c b/networking/ifupdown.c
index 9dce445bd..34a43e6fa 100644
--- a/networking/ifupdown.c
+++ b/networking/ifupdown.c
@@ -471,8 +471,8 @@ static int static_up(struct interface_defn_t *ifd, execfn *exec)
 	return ((result == 3) ? 3 : 0);
 #else
 	result = execute("ifconfig %iface% %address% netmask %netmask% "
-				"[[broadcast %broadcast%]] 	[[pointopoint %pointopoint%]] "
-				"[[media %media%]] [[mtu %mtu%]] 	[[hw %hwaddress%]] up",
+				"[[broadcast %broadcast%]] [[pointopoint %pointopoint%]] "
+				"[[media %media%]] [[mtu %mtu%]] [[hw %hwaddress%]] up",
 				ifd, exec);
 	result += execute("[[ route add default gw %gateway% %iface% ]]", ifd, exec);
 	return ((result == 2) ? 2 : 0);
diff --git a/networking/inetd.c b/networking/inetd.c
index 7a6ffae0c..9f6acdb98 100644
--- a/networking/inetd.c
+++ b/networking/inetd.c
@@ -1364,7 +1364,7 @@ inetd_main (int argc, char *argv[])
   sigaction (SIGINT, &sa, NULL);
   sa.sa_handler = SIG_IGN;
   sigaction (SIGPIPE, &sa, &sapipe);
-  memset(&wait_mask, 0, sizeof(wait_mask)); 
+  memset(&wait_mask, 0, sizeof(wait_mask));
   {
 	/* space for daemons to overwrite environment for ps */
 #define DUMMYSIZE       100
diff --git a/networking/interface.c b/networking/interface.c
index 554dc16d0..ad6c40fc1 100644
--- a/networking/interface.c
+++ b/networking/interface.c
@@ -1039,9 +1039,9 @@ static char *get_name(char *name, char *p)
  * args. */
 
 /* static const char * const ss_fmt[] = { */
-/* 	"%Ln%Lu%lu%lu%lu%lu%ln%ln%Ln%Lu%lu%lu%lu%lu%lu", */
-/* 	"%Lu%Lu%lu%lu%lu%lu%ln%ln%Lu%Lu%lu%lu%lu%lu%lu", */
-/* 	"%Lu%Lu%lu%lu%lu%lu%lu%lu%Lu%Lu%lu%lu%lu%lu%lu%lu" */
+/*	"%Ln%Lu%lu%lu%lu%lu%ln%ln%Ln%Lu%lu%lu%lu%lu%lu", */
+/*	"%Lu%Lu%lu%lu%lu%lu%ln%ln%Lu%Lu%lu%lu%lu%lu%lu", */
+/*	"%Lu%Lu%lu%lu%lu%lu%lu%lu%Lu%Lu%lu%lu%lu%lu%lu%lu" */
 /* }; */
 
 	/* Lie about the size of the int pointed to for %n. */
diff --git a/networking/libiproute/ipaddress.c b/networking/libiproute/ipaddress.c
index c6115b356..c5e6e4ea5 100644
--- a/networking/libiproute/ipaddress.c
+++ b/networking/libiproute/ipaddress.c
@@ -54,8 +54,8 @@ static void print_link_flags(FILE *fp, unsigned flags, unsigned mdown)
 	fprintf(fp, "<");
 	flags &= ~IFF_RUNNING;
 #define _PF(f) if (flags&IFF_##f) { \
-                  flags &= ~IFF_##f ; \
-                  fprintf(fp, #f "%s", flags ? "," : ""); }
+		  flags &= ~IFF_##f ; \
+		  fprintf(fp, #f "%s", flags ? "," : ""); }
 	_PF(LOOPBACK);
 	_PF(BROADCAST);
 	_PF(POINTOPOINT);
@@ -74,7 +74,7 @@ static void print_link_flags(FILE *fp, unsigned flags, unsigned mdown)
 #endif
 	_PF(UP);
 #undef _PF
-        if (flags)
+	if (flags)
 		fprintf(fp, "%x", flags);
 	if (mdown)
 		fprintf(fp, ",M-DOWN");
@@ -636,9 +636,9 @@ static int ipaddr_modify(int cmd, int argc, char **argv)
 		"anycast", "scope", "dev", "label", "local", 0 };
 	struct rtnl_handle rth;
 	struct {
-		struct nlmsghdr 	n;
-		struct ifaddrmsg 	ifa;
-		char   			buf[256];
+		struct nlmsghdr		n;
+		struct ifaddrmsg	ifa;
+		char			buf[256];
 	} req;
 	char  *d = NULL;
 	char  *l = NULL;
diff --git a/networking/libiproute/iplink.c b/networking/libiproute/iplink.c
index b4493d67d..91c85820c 100644
--- a/networking/libiproute/iplink.c
+++ b/networking/libiproute/iplink.c
@@ -289,7 +289,7 @@ static int do_set(int argc, char **argv)
 			NEXT_ARG();
 			newaddr = *argv;
 		} else {
-                        if (strcmp(*argv, "dev") == 0) {
+			if (strcmp(*argv, "dev") == 0) {
 				NEXT_ARG();
 			}
 			if (dev)
diff --git a/networking/libiproute/iproute.c b/networking/libiproute/iproute.c
index b622afd47..1c4f75520 100644
--- a/networking/libiproute/iproute.c
+++ b/networking/libiproute/iproute.c
@@ -286,9 +286,9 @@ static int iproute_modify(int cmd, unsigned flags, int argc, char **argv)
 {
 	struct rtnl_handle rth;
 	struct {
-		struct nlmsghdr 	n;
-		struct rtmsg 		r;
-		char   			buf[1024];
+		struct nlmsghdr		n;
+		struct rtmsg		r;
+		char			buf[1024];
 	} req;
 	char  mxbuf[256];
 	struct rtattr * mxrta = (void*)mxbuf;
@@ -648,15 +648,15 @@ static int iproute_get(int argc, char **argv)
 {
 	struct rtnl_handle rth;
 	struct {
-		struct nlmsghdr 	n;
-		struct rtmsg 		r;
-		char   			buf[1024];
+		struct nlmsghdr		n;
+		struct rtmsg		r;
+		char			buf[1024];
 	} req;
 	char  *idev = NULL;
 	char  *odev = NULL;
 	int connected = 0;
 	int from_ok = 0;
-	static const char * const options[] = 
+	static const char * const options[] =
 		{ "from", "iif", "oif", "dev", "notify", "connected", "to", 0 };
 
 	memset(&req, 0, sizeof(req));
@@ -816,8 +816,8 @@ static int iproute_get(int argc, char **argv)
 
 int do_iproute(int argc, char **argv)
 {
-	static const char * const ip_route_commands[] = 
-		{ "add", "append", "change", "chg", "delete", "del", "get", 
+	static const char * const ip_route_commands[] =
+		{ "add", "append", "change", "chg", "delete", "del", "get",
 		"list", "show", "prepend", "replace", "test", "flush", 0 };
 	int command_num = 7;
 	unsigned int flags = 0;
diff --git a/networking/libiproute/linux/pkt_sched.h b/networking/libiproute/linux/pkt_sched.h
index 70cbabc26..ec5b3fddd 100644
--- a/networking/libiproute/linux/pkt_sched.h
+++ b/networking/libiproute/linux/pkt_sched.h
@@ -256,8 +256,8 @@ struct tc_gred_sopt
 
 struct tc_htb_opt
 {
-	struct tc_ratespec 	rate;
-	struct tc_ratespec 	ceil;
+	struct tc_ratespec	rate;
+	struct tc_ratespec	ceil;
 	__u32	buffer;
 	__u32	cbuffer;
 	__u32	quantum;	/* out only */
@@ -268,9 +268,9 @@ struct tc_htb_opt
 };
 struct tc_htb_glob
 {
-    	__u32 rate2quantum;	/* bps->quantum divisor */
-    	__u32 defcls;		/* default class number */
-    	__u32 use_dcache;	/* use dequeue cache ? */
+	__u32 rate2quantum;	/* bps->quantum divisor */
+	__u32 defcls;		/* default class number */
+	__u32 use_dcache;	/* use dequeue cache ? */
 	__u32 debug;		/* debug flags */
 
 
@@ -311,8 +311,8 @@ struct tc_cbq_lssopt
 	unsigned char	flags;
 #define TCF_CBQ_LSS_BOUNDED	1
 #define TCF_CBQ_LSS_ISOLATED	2
-	unsigned char  	ewma_log;
-	unsigned char  	level;
+	unsigned char	ewma_log;
+	unsigned char	level;
 #define TCF_CBQ_LSS_FLAGS	1
 #define TCF_CBQ_LSS_EWMA	2
 #define TCF_CBQ_LSS_MAXIDLE	4
diff --git a/networking/libiproute/ll_proto.c b/networking/libiproute/ll_proto.c
index 104fbca25..873253050 100644
--- a/networking/libiproute/ll_proto.c
+++ b/networking/libiproute/ll_proto.c
@@ -92,23 +92,23 @@ __PF(ECONET,econet)
 
 const char * ll_proto_n2a(unsigned short id, char *buf, int len)
 {
-        int i;
+	int i;
 
 	id = ntohs(id);
 
-        for (i=0; i<sizeof(llproto_names)/sizeof(llproto_names[0]); i++) {
-                 if (llproto_names[i].id == id)
+	for (i=0; i<sizeof(llproto_names)/sizeof(llproto_names[0]); i++) {
+		 if (llproto_names[i].id == id)
 			return llproto_names[i].name;
 	}
-        snprintf(buf, len, "[%d]", id);
-        return buf;
+	snprintf(buf, len, "[%d]", id);
+	return buf;
 }
 
 int ll_proto_a2n(unsigned short *id, char *buf)
 {
-        int i;
-        for (i=0; i<sizeof(llproto_names)/sizeof(llproto_names[0]); i++) {
-                 if (strcasecmp(llproto_names[i].name, buf) == 0) {
+	int i;
+	for (i=0; i<sizeof(llproto_names)/sizeof(llproto_names[0]); i++) {
+		 if (strcasecmp(llproto_names[i].name, buf) == 0) {
 			 *id = htons(llproto_names[i].id);
 			 return 0;
 		 }
diff --git a/networking/libiproute/ll_types.c b/networking/libiproute/ll_types.c
index 6b42426d5..fc5a01530 100644
--- a/networking/libiproute/ll_types.c
+++ b/networking/libiproute/ll_types.c
@@ -105,11 +105,11 @@ __PF(VOID,void)
 };
 #undef __PF
 
-        int i;
-        for (i=0; i<sizeof(arphrd_names)/sizeof(arphrd_names[0]); i++) {
-                 if (arphrd_names[i].type == type)
+	int i;
+	for (i=0; i<sizeof(arphrd_names)/sizeof(arphrd_names[0]); i++) {
+		 if (arphrd_names[i].type == type)
 			return arphrd_names[i].name;
 	}
-        snprintf(buf, len, "[%d]", type);
-        return buf;
+	snprintf(buf, len, "[%d]", type);
+	return buf;
 }
diff --git a/networking/libiproute/utils.h b/networking/libiproute/utils.h
index 3d223edf6..0a3a06c15 100644
--- a/networking/libiproute/utils.h
+++ b/networking/libiproute/utils.h
@@ -46,8 +46,8 @@ typedef struct
 
 struct dn_naddr
 {
-        unsigned short          a_len;
-        unsigned char a_addr[DN_MAXADDL];
+	unsigned short          a_len;
+	unsigned char a_addr[DN_MAXADDL];
 };
 
 #define IPX_NODE_LEN 6
diff --git a/networking/nc.c b/networking/nc.c
index fda1fb8f6..85148c4a7 100644
--- a/networking/nc.c
+++ b/networking/nc.c
@@ -48,9 +48,9 @@ static void timeout(int signum)
 int nc_main(int argc, char **argv)
 {
 	int do_listen = 0, lport = 0, delay = 0, wsecs = 0, tmpfd, opt, sfd, x;
-	
+
 #define buf bb_common_bufsiz1
-	
+
 #ifdef CONFIG_NC_GAPING_SECURITY_HOLE
 	char *pr00gie = NULL;
 #endif
diff --git a/networking/netstat.c b/networking/netstat.c
index bc1ed057b..ea372322f 100644
--- a/networking/netstat.c
+++ b/networking/netstat.c
@@ -247,7 +247,7 @@ static void udp_do_one(int lnr, const char *line)
 
 	if (strlen(local_addr) > 8) {
 #ifdef CONFIG_FEATURE_IPV6
-        /* Demangle what the kernel gives us */
+	/* Demangle what the kernel gives us */
 		sscanf(local_addr, "%08X%08X%08X%08X",
 			   &in6.s6_addr32[0], &in6.s6_addr32[1],
 			   &in6.s6_addr32[2], &in6.s6_addr32[3]);
diff --git a/networking/ping.c b/networking/ping.c
index ed52abf04..14373c8d6 100644
--- a/networking/ping.c
+++ b/networking/ping.c
@@ -236,20 +236,20 @@ static void sendping(int junk)
 static char *icmp_type_name (int id)
 {
 	switch (id) {
-	case ICMP_ECHOREPLY: 		return "Echo Reply";
-	case ICMP_DEST_UNREACH: 	return "Destination Unreachable";
-	case ICMP_SOURCE_QUENCH: 	return "Source Quench";
-	case ICMP_REDIRECT: 		return "Redirect (change route)";
-	case ICMP_ECHO: 			return "Echo Request";
-	case ICMP_TIME_EXCEEDED: 	return "Time Exceeded";
-	case ICMP_PARAMETERPROB: 	return "Parameter Problem";
-	case ICMP_TIMESTAMP: 		return "Timestamp Request";
-	case ICMP_TIMESTAMPREPLY: 	return "Timestamp Reply";
-	case ICMP_INFO_REQUEST: 	return "Information Request";
-	case ICMP_INFO_REPLY: 		return "Information Reply";
-	case ICMP_ADDRESS: 			return "Address Mask Request";
-	case ICMP_ADDRESSREPLY: 	return "Address Mask Reply";
-	default: 					return "unknown ICMP type";
+	case ICMP_ECHOREPLY:		return "Echo Reply";
+	case ICMP_DEST_UNREACH:		return "Destination Unreachable";
+	case ICMP_SOURCE_QUENCH:	return "Source Quench";
+	case ICMP_REDIRECT:			return "Redirect (change route)";
+	case ICMP_ECHO:				return "Echo Request";
+	case ICMP_TIME_EXCEEDED:	return "Time Exceeded";
+	case ICMP_PARAMETERPROB:	return "Parameter Problem";
+	case ICMP_TIMESTAMP:		return "Timestamp Request";
+	case ICMP_TIMESTAMPREPLY:	return "Timestamp Reply";
+	case ICMP_INFO_REQUEST:		return "Information Request";
+	case ICMP_INFO_REPLY:		return "Information Reply";
+	case ICMP_ADDRESS:			return "Address Mask Request";
+	case ICMP_ADDRESSREPLY:		return "Address Mask Reply";
+	default:					return "unknown ICMP type";
 	}
 }
 
diff --git a/networking/ping6.c b/networking/ping6.c
index 72867f346..1d7271d7b 100644
--- a/networking/ping6.c
+++ b/networking/ping6.c
@@ -246,7 +246,7 @@ static char *icmp6_type_name (int id)
 	case ICMP6_MEMBERSHIP_QUERY:		return "Membership Query";
 	case ICMP6_MEMBERSHIP_REPORT:		return "Membership Report";
 	case ICMP6_MEMBERSHIP_REDUCTION:	return "Membership Reduction";
-	default: 							return "unknown ICMP type";
+	default:							return "unknown ICMP type";
 	}
 }
 
diff --git a/networking/route.c b/networking/route.c
index bb5f9405b..49d219ae0 100644
--- a/networking/route.c
+++ b/networking/route.c
@@ -86,7 +86,7 @@
 /* We remap '-' to '#' to avoid problems with getopt. */
 static const char tbl_hash_net_host[] =
 	"\007\001#net\0"
-/* 	"\010\002#host\0" */
+/*	"\010\002#host\0" */
 	"\007\002#host"				/* Since last, we can save a byte. */
 ;
 
@@ -128,7 +128,7 @@ static const char tbl_ipvx[] =
 #endif
 	"\006\041mod\0"
 	"\006\042dyn\0"
-/* 	"\014\043reinstate\0" */
+/*	"\014\043reinstate\0" */
 	"\013\043reinstate"			/* Since last, we can save a byte. */
 ;
 
@@ -186,7 +186,7 @@ static void INET_setroute(int action, char **args)
 		const char *target = *args++;
 
 		/* Prefer hostname lookup is -host flag (xflag==1) was given. */
- 		isnet = INET_resolve(target, (struct sockaddr_in *) &rt.rt_dst,
+		isnet = INET_resolve(target, (struct sockaddr_in *) &rt.rt_dst,
 							 (xflag & HOST_FLAG));
 		if (isnet < 0) {
 			bb_error_msg_and_die("resolving %s", target);
@@ -459,7 +459,7 @@ static const unsigned int flagvals[] = { /* Must agree with flagchars[]. */
 #define IPV4_MASK (RTF_GATEWAY|RTF_HOST|RTF_REINSTATE|RTF_DYNAMIC|RTF_MODIFIED)
 #define IPV6_MASK (RTF_GATEWAY|RTF_HOST|RTF_DEFAULT|RTF_ADDRCONF|RTF_CACHE)
 
-static const char flagchars[] = 		/* Must agree with flagvals[]. */
+static const char flagchars[] =		/* Must agree with flagvals[]. */
 	"GHRDM"
 #ifdef CONFIG_FEATURE_IPV6
 	"DAC"
@@ -645,10 +645,10 @@ static void INET6_displayroutes(int noresolve)
 #define ROUTE_OPT_INET6		0x08 /* Not an actual option. See below. */
 
 /* 1st byte is offset to next entry offset.  2nd byte is return value. */
-static const char tbl_verb[] = 	/* 2nd byte matches RTACTION_* code */
+static const char tbl_verb[] =	/* 2nd byte matches RTACTION_* code */
 	"\006\001add\0"
 	"\006\002del\0"
-/* 	"\011\002delete\0" */
+/*	"\011\002delete\0" */
 	"\010\002delete"			/* Since last, we can save a byte. */
 ;
 
diff --git a/networking/telnet.c b/networking/telnet.c
index 314363188..d9e66e5d3 100644
--- a/networking/telnet.c
+++ b/networking/telnet.c
@@ -647,7 +647,7 @@ extern int telnet_main(int argc, char** argv)
 #ifdef CONFIG_FEATURE_TELNET_AUTOLOGIN
 	if (1 & bb_getopt_ulflags(argc, argv, "al:", &autologin))
 		autologin = getenv("USER");
-	
+
 	if (optind < argc) {
 		bb_lookup_host(&s_in, argv[optind++]);
 		s_in.sin_port = bb_lookup_port((optind < argc) ? argv[optind++] :
diff --git a/networking/telnetd.c b/networking/telnetd.c
index d5de8903c..73303a20a 100644
--- a/networking/telnetd.c
+++ b/networking/telnetd.c
@@ -94,7 +94,7 @@ struct tsession {
    +-------+     wridx1++     +------+     rdidx1++     +----------+
    |       | <--------------  | buf1 | <--------------  |          |
    |       |     size1--      +------+     size1++      |          |
-   |  pty  |                                            |  socket  |
+   |  pty  |					    |  socket  |
    |       |     rdidx2++     +------+     wridx2++     |          |
    |       |  --------------> | buf2 |  --------------> |          |
    +-------+     size2++      +------+     size2--      +----------+
@@ -166,7 +166,7 @@ remove_iacs(struct tsession *ts, int *pnum_totty) {
 			else if (ptr[1] == SB && ptr[2] == TELOPT_NAWS) {
 				struct winsize ws;
 				if ((ptr+8) >= end)
-					break; 	/* incomplete, can't process */
+					break;	/* incomplete, can't process */
 				ws.ws_col = (ptr[3] << 8) | ptr[4];
 				ws.ws_row = (ptr[5] << 8) | ptr[6];
 				(void) ioctl(ts->ptyfd, TIOCSWINSZ, (char *)&ws);
@@ -383,7 +383,7 @@ int
 telnetd_main(int argc, char **argv)
 {
 #ifndef CONFIG_FEATURE_TELNETD_INETD
-        sockaddr_type sa;
+	sockaddr_type sa;
 	int master_fd;
 #endif /* CONFIG_FEATURE_TELNETD_INETD */
 	fd_set rdfdset, wrfdset;
@@ -446,7 +446,7 @@ telnetd_main(int argc, char **argv)
 
 	/* Grab a TCP socket.  */
 
-        master_fd = socket(SOCKET_TYPE, SOCK_STREAM, 0);
+	master_fd = socket(SOCKET_TYPE, SOCK_STREAM, 0);
 	if (master_fd < 0) {
 		bb_perror_msg_and_die("socket");
 	}
diff --git a/networking/tftp.c b/networking/tftp.c
index cad0dcc45..402d5d03c 100644
--- a/networking/tftp.c
+++ b/networking/tftp.c
@@ -1,34 +1,34 @@
 /* ------------------------------------------------------------------------- */
-/* tftp.c                                                                    */
-/*                                                                           */
-/* A simple tftp client for busybox.                                         */
-/* Tries to follow RFC1350.                                                  */
-/* Only "octet" mode supported.                                              */
+/* tftp.c					                            */
+/*					                                   */
+/* A simple tftp client for busybox.					 */
+/* Tries to follow RFC1350.					          */
+/* Only "octet" mode supported.					      */
 /* Optional blocksize negotiation (RFC2347 + RFC2348)                        */
-/*                                                                           */
+/*					                                   */
 /* Copyright (C) 2001 Magnus Damm <damm@opensource.se>                       */
-/*                                                                           */
-/* Parts of the code based on:                                               */
-/*                                                                           */
+/*					                                   */
+/* Parts of the code based on:					       */
+/*					                                   */
 /* atftp:  Copyright (C) 2000 Jean-Pierre Lefebvre <helix@step.polymtl.ca>   */
 /*                        and Remi Lefebvre <remi@debian.org>                */
-/*                                                                           */
+/*					                                   */
 /* utftp:  Copyright (C) 1999 Uwe Ohse <uwe@ohse.de>                         */
-/*                                                                           */
+/*					                                   */
 /* This program is free software; you can redistribute it and/or modify      */
 /* it under the terms of the GNU General Public License as published by      */
 /* the Free Software Foundation; either version 2 of the License, or         */
 /* (at your option) any later version.                                       */
-/*                                                                           */
+/*					                                   */
 /* This program is distributed in the hope that it will be useful,           */
 /* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
 /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU          */
 /* General Public License for more details.                                  */
-/*                                                                           */
+/*					                                   */
 /* You should have received a copy of the GNU General Public License         */
 /* along with this program; if not, write to the Free Software               */
 /* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA   */
-/*                                                                           */
+/*					                                   */
 /* ------------------------------------------------------------------------- */
 
 #include <stdio.h>
@@ -87,13 +87,13 @@ static const char * const tftp_bb_error_msg[] = {
 
 static int tftp_blocksize_check(int blocksize, int bufsize)
 {
-        /* Check if the blocksize is valid:
+	/* Check if the blocksize is valid:
 	 * RFC2348 says between 8 and 65464,
 	 * but our implementation makes it impossible
 	 * to use blocksizes smaller than 22 octets.
 	 */
 
-        if ((bufsize && (blocksize > bufsize)) ||
+	if ((bufsize && (blocksize > bufsize)) ||
 	    (blocksize < 8) || (blocksize > 65464)) {
 	        bb_error_msg("bad blocksize");
 	        return 0;
@@ -104,7 +104,7 @@ static int tftp_blocksize_check(int blocksize, int bufsize)
 
 static char *tftp_option_get(char *buf, int len, char *option)
 {
-        int opt_val = 0;
+	int opt_val = 0;
 	int opt_found = 0;
 	int k;
 
@@ -216,7 +216,7 @@ static inline int tftp(const int cmd, const struct hostent *host,
 
 		if ((cmd_get && (opcode == TFTP_RRQ)) ||
 			(cmd_put && (opcode == TFTP_WRQ))) {
-                        int too_long = 0;
+			int too_long = 0;
 
 			/* see if the filename fits into buf */
 			/* and fill in packet                */
@@ -418,7 +418,7 @@ static inline int tftp(const int cmd, const struct hostent *host,
 
 				 if (res) {
 				         int blksize = atoi(res);
-			
+
 					 if (tftp_blocksize_check(blksize,
 							   tftp_bufsize - 4)) {
 
@@ -452,7 +452,7 @@ static inline int tftp(const int cmd, const struct hostent *host,
 		if (cmd_get && (opcode == TFTP_DATA)) {
 
 			if (tmp == block_nr) {
-			
+
 				len = bb_full_write(localfd, &buf[4], len - 4);
 
 				if (len < 0) {
@@ -496,7 +496,7 @@ static inline int tftp(const int cmd, const struct hostent *host,
 #ifdef CONFIG_FEATURE_CLEAN_UP
 	close(socketfd);
 
-        free(buf);
+	free(buf);
 #endif
 
 	return finished ? EXIT_SUCCESS : EXIT_FAILURE;
@@ -549,8 +549,8 @@ int tftp_main(int argc, char **argv)
 	/* XXX: may be should #error ? */
 #endif
 
-	
-	cmd = bb_getopt_ulflags(argc, argv, GET PUT "l:r:" BS, 
+
+	cmd = bb_getopt_ulflags(argc, argv, GET PUT "l:r:" BS,
 				&localfile, &remotefile BS_ARG);
 #ifdef CONFIG_FEATURE_TFTP_BLOCKSIZE
 	if(sblocksize) {
diff --git a/networking/udhcp/arpping.c b/networking/udhcp/arpping.c
index 7cc2be42e..4831d4371 100644
--- a/networking/udhcp/arpping.c
+++ b/networking/udhcp/arpping.c
@@ -23,7 +23,7 @@
  *		ip - our ip
  *		mac - our arp address
  *		interface - interface to use
- * retn: 	1 addr free
+ * retn:	1 addr free
  *		0 addr used
  *		-1 error
  */
@@ -33,7 +33,7 @@ int arpping(uint32_t yiaddr, uint32_t ip, uint8_t *mac, char *interface)
 {
 
 	int	timeout = 2;
-	int 	optval = 1;
+	int	optval = 1;
 	int	s;			/* socket */
 	int	rv = 1;			/* return value */
 	struct sockaddr addr;		/* for interface name */
@@ -101,6 +101,6 @@ int arpping(uint32_t yiaddr, uint32_t ip, uint8_t *mac, char *interface)
 		prevTime = uptime();
 	}
 	close(s);
-	DEBUG(LOG_INFO, "%salid arp replies for this address", rv ? "No v" : "V");	
+	DEBUG(LOG_INFO, "%salid arp replies for this address", rv ? "No v" : "V");
 	return rv;
 }
diff --git a/networking/udhcp/clientpacket.c b/networking/udhcp/clientpacket.c
index 528befde6..e377bd236 100644
--- a/networking/udhcp/clientpacket.c
+++ b/networking/udhcp/clientpacket.c
@@ -205,8 +205,8 @@ int get_raw_packet(struct dhcpMessage *payload, int fd)
 	    packet.ip.ihl != sizeof(packet.ip) >> 2 || packet.udp.dest != htons(CLIENT_PORT) ||
 	    bytes > (int) sizeof(struct udp_dhcp_packet) ||
 	    ntohs(packet.udp.len) != (uint16_t) (bytes - sizeof(packet.ip))) {
-	    	DEBUG(LOG_INFO, "unrelated/bogus packet");
-	    	return -2;
+		DEBUG(LOG_INFO, "unrelated/bogus packet");
+		return -2;
 	}
 
 	/* check IP checksum */
diff --git a/networking/udhcp/common.h b/networking/udhcp/common.h
index efa8fd419..071a5c428 100644
--- a/networking/udhcp/common.h
+++ b/networking/udhcp/common.h
@@ -43,7 +43,7 @@ long uptime(void);
 void background(const char *pidfile);
 void start_log_and_pid(const char *client_server, const char *pidfile);
 void udhcp_logging(int level, const char *fmt, ...);
-                                                            
+
 #define LOG(level, str, args...) udhcp_logging(level, str, ## args)
 
 #ifdef UDHCP_DEBUG
diff --git a/networking/udhcp/dhcpc.c b/networking/udhcp/dhcpc.c
index c4277e3f1..a4afb0c46 100644
--- a/networking/udhcp/dhcpc.c
+++ b/networking/udhcp/dhcpc.c
@@ -196,7 +196,7 @@ int main(int argc, char *argv[])
 		{"hostname",	required_argument,	0, 'h'},
 		{"fqdn",	required_argument,	0, 'F'},
 		{"interface",	required_argument,	0, 'i'},
-		{"now", 	no_argument,		0, 'n'},
+		{"now",		no_argument,		0, 'n'},
 		{"pidfile",	required_argument,	0, 'p'},
 		{"quit",	no_argument,		0, 'q'},
 		{"request",	required_argument,	0, 'r'},
@@ -314,7 +314,7 @@ int main(int argc, char *argv[])
 		client_config.vendorclass[OPT_CODE] = DHCP_VENDOR;
 		client_config.vendorclass[OPT_LEN] = sizeof("udhcp "VERSION) - 1;
 		client_config.vendorclass[OPT_DATA] = 1;
-		memcpy(&client_config.vendorclass[OPT_DATA], 
+		memcpy(&client_config.vendorclass[OPT_DATA],
 			"udhcp "VERSION, sizeof("udhcp "VERSION) - 1);
 	}
 
@@ -370,7 +370,7 @@ int main(int argc, char *argv[])
 					} else if (client_config.abort_if_no_lease) {
 						LOG(LOG_INFO, "No lease, failing.");
 						return 1;
-				  	}
+					}
 					/* wait to try again */
 					packet_num = 0;
 					timeout = now + 60;
diff --git a/networking/udhcp/dhcpd.c b/networking/udhcp/dhcpd.c
index 2812e6e8c..0dfc0b559 100644
--- a/networking/udhcp/dhcpd.c
+++ b/networking/udhcp/dhcpd.c
@@ -193,7 +193,7 @@ int main(int argc, char *argv[])
 				LOG(LOG_ERR, "send OFFER failed");
 			}
 			break;
- 		case DHCPREQUEST:
+		case DHCPREQUEST:
 			DEBUG(LOG_INFO, "received REQUEST");
 
 			requested = get_option(&packet, DHCP_REQUESTED_IP);
diff --git a/networking/udhcp/dhcpd.h b/networking/udhcp/dhcpd.h
index 65c8348bf..a060002cd 100644
--- a/networking/udhcp/dhcpd.h
+++ b/networking/udhcp/dhcpd.h
@@ -108,23 +108,23 @@ struct static_lease {
 
 struct server_config_t {
 	uint32_t server;		/* Our IP, in network order */
-	uint32_t start;		/* Start address of leases, network order */
+	uint32_t start;			/* Start address of leases, network order */
 	uint32_t end;			/* End of leases, network order */
 	struct option_set *options;	/* List of DHCP options loaded from the config file */
 	char *interface;		/* The name of the interface to use */
 	int ifindex;			/* Index number of the interface to use */
-	uint8_t arp[6];		/* Our arp address */
+	uint8_t arp[6];			/* Our arp address */
 	unsigned long lease;		/* lease time in seconds (host order) */
-	unsigned long max_leases; 	/* maximum number of leases (including reserved address) */
-	char remaining; 		/* should the lease file be interpreted as lease time remaining, or
-			 		 * as the time the lease expires */
-	unsigned long auto_time; 	/* how long should udhcpd wait before writing a config file.
+	unsigned long max_leases;	/* maximum number of leases (including reserved address) */
+	char remaining;			/* should the lease file be interpreted as lease time remaining, or
+					 * as the time the lease expires */
+	unsigned long auto_time;	/* how long should udhcpd wait before writing a config file.
 					 * if this is zero, it will only write one on SIGUSR1 */
-	unsigned long decline_time; 	/* how long an address is reserved if a client returns a
-				    	 * decline message */
-	unsigned long conflict_time; 	/* how long an arp conflict offender is leased for */
-	unsigned long offer_time; 	/* how long an offered address is reserved */
-	unsigned long min_lease; 	/* minimum lease a client can request*/
+	unsigned long decline_time;	/* how long an address is reserved if a client returns a
+					 * decline message */
+	unsigned long conflict_time;	/* how long an arp conflict offender is leased for */
+	unsigned long offer_time;	/* how long an offered address is reserved */
+	unsigned long min_lease;	/* minimum lease a client can request*/
 	char *lease_file;
 	char *pidfile;
 	char *notify_file;		/* What to run whenever leases are written */
diff --git a/networking/udhcp/files.c b/networking/udhcp/files.c
index 40e68a0a8..01534f2bb 100644
--- a/networking/udhcp/files.c
+++ b/networking/udhcp/files.c
@@ -271,7 +271,7 @@ static const struct config_keyword keywords[] = {
 	{"boot_file",	read_str, &(server_config.boot_file),	""},
 	{"static_lease",read_staticlease, &(server_config.static_leases),	""},
 	/*ADDME: static lease */
-	{"",		NULL, 	  NULL,				""}
+	{"",		NULL,	  NULL,				""}
 };
 
 
diff --git a/networking/udhcp/leases.c b/networking/udhcp/leases.c
index 4da21a23b..bb08c3adb 100644
--- a/networking/udhcp/leases.c
+++ b/networking/udhcp/leases.c
@@ -148,7 +148,7 @@ uint32_t find_address(int check_expired)
 		     (check_expired  && lease_expired(lease))) &&
 
 		     /* and it isn't on the network */
-	    	     !check_ip(ret)) {
+		     !check_ip(ret)) {
 			return ret;
 			break;
 		}
diff --git a/networking/udhcp/libbb_udhcp.h b/networking/udhcp/libbb_udhcp.h
index 0dae40172..30e167f64 100644
--- a/networking/udhcp/libbb_udhcp.h
+++ b/networking/udhcp/libbb_udhcp.h
@@ -29,19 +29,19 @@
 
 /* make safe the exported namespace */
 /* from common.h */
-#define background 		udhcp_background
-#define start_log_and_pid 	udhcp_start_log_and_pid
+#define background		udhcp_background
+#define start_log_and_pid	udhcp_start_log_and_pid
 /* from script.h */
-#define run_script 		udhcp_run_script
+#define run_script		udhcp_run_script
 /* from packet.h */
-#define init_header 		udhcp_init_header
-#define get_packet 		udhcp_get_packet
-#define checksum 		udhcp_checksum
-#define raw_packet 		udhcp_raw_packet
-#define kernel_packet 		udhcp_kernel_packet
+#define init_header		udhcp_init_header
+#define get_packet		udhcp_get_packet
+#define checksum		udhcp_checksum
+#define raw_packet		udhcp_raw_packet
+#define kernel_packet		udhcp_kernel_packet
 /* from pidfile.h */
-#define pidfile_acquire 	udhcp_pidfile_acquire
-#define pidfile_write_release 	udhcp_pidfile_write_release
+#define pidfile_acquire		udhcp_pidfile_acquire
+#define pidfile_write_release	udhcp_pidfile_write_release
 /* from options.h */
 #define get_option		udhcp_get_option
 #define end_option		udhcp_end_option
diff --git a/networking/udhcp/options.c b/networking/udhcp/options.c
index 144345134..eebcaaa58 100644
--- a/networking/udhcp/options.c
+++ b/networking/udhcp/options.c
@@ -154,11 +154,11 @@ int add_simple_option(uint8_t *optionptr, uint8_t code, uint32_t data)
 	for (dh=dhcp_options; dh->code; dh++) {
 		if (dh->code == code) {
 			uint8_t option[6], len;
-			
+
 			option[OPT_CODE] = code;
 			len = option_lengths[dh->flags & TYPE_MASK];
 			option[OPT_LEN] = len;
-			if (__BYTE_ORDER == __BIG_ENDIAN) 
+			if (__BYTE_ORDER == __BIG_ENDIAN)
 				data <<= 8 * (4 - len);
 			/* This memcpy is for broken processors which can't
 			 * handle a simple unaligned 32-bit assignment */
diff --git a/networking/udhcp/packet.c b/networking/udhcp/packet.c
index 1c6bb0ca4..64a910031 100644
--- a/networking/udhcp/packet.c
+++ b/networking/udhcp/packet.c
@@ -71,13 +71,13 @@ int get_packet(struct dhcpMessage *packet, int fd)
 		for (i = 0; broken_vendors[i][0]; i++) {
 			if (vendor[OPT_LEN - 2] == (uint8_t) strlen(broken_vendors[i]) &&
 			    !strncmp(vendor, broken_vendors[i], vendor[OPT_LEN - 2])) {
-			    	DEBUG(LOG_INFO, "broken client (%s), forcing broadcast",
-			    		broken_vendors[i]);
-			    	packet->flags |= htons(BROADCAST_FLAG);
+				DEBUG(LOG_INFO, "broken client (%s), forcing broadcast",
+					broken_vendors[i]);
+				packet->flags |= htons(BROADCAST_FLAG);
 			}
 		}
 	}
-			
+
 
 	return bytes;
 }
diff --git a/networking/udhcp/script.c b/networking/udhcp/script.c
index c04c69f7e..b6b0e0d59 100644
--- a/networking/udhcp/script.c
+++ b/networking/udhcp/script.c
@@ -97,7 +97,7 @@ static void fill_options(char *dest, uint8_t *option, struct dhcp_option *type_p
 			optlen = 4;
 		case OPTION_IP:	/* Works regardless of host byte order. */
 			dest += sprintip(dest, "", option);
- 			break;
+			break;
 		case OPTION_BOOLEAN:
 			dest += sprintf(dest, *option ? "yes" : "no");
 			break;
diff --git a/networking/udhcp/serverpacket.c b/networking/udhcp/serverpacket.c
index c6a820909..1b89862b2 100644
--- a/networking/udhcp/serverpacket.c
+++ b/networking/udhcp/serverpacket.c
@@ -138,11 +138,11 @@ int sendOffer(struct dhcpMessage *oldpacket)
 		   /* and the ip is in the lease range */
 		   ntohl(req_align) >= ntohl(server_config.start) &&
 		   ntohl(req_align) <= ntohl(server_config.end) &&
-		
+
 			!static_lease_ip &&  /* Check that its not a static lease */
 			/* and is not already taken/offered */
 		   ((!(lease = find_lease_by_yiaddr(req_align)) ||
-		
+
 		   /* or its taken, but expired */ /* ADDME: or maybe in here */
 		   lease_expired(lease)))) {
 				packet.yiaddr = req_align; /* FIXME: oh my, is there a host using this IP? */
diff --git a/networking/vconfig.c b/networking/vconfig.c
index bbd29873c..36458f784 100644
--- a/networking/vconfig.c
+++ b/networking/vconfig.c
@@ -54,20 +54,20 @@ struct vlan_ioctl_args {
 	int cmd; /* Should be one of the vlan_ioctl_cmds enum above. */
 	char device1[24];
 
-        union {
+	union {
 		char device2[24];
 		int VID;
 		unsigned int skb_priority;
 		unsigned int name_type;
 		unsigned int bind_type;
 		unsigned int flag; /* Matches vlan_dev_info flags */
-        } u;
+	} u;
 
 	short vlan_qos;
 };
 
 #define VLAN_GROUP_ARRAY_LEN 4096
-#define SIOCSIFVLAN	0x8983		/* Set 802.1Q VLAN options 	*/
+#define SIOCSIFVLAN	0x8983		/* Set 802.1Q VLAN options */
 
 /* On entry, table points to the length of the current string plus
  * nul terminator plus data length for the subsequent entry.  The
diff --git a/networking/wget.c b/networking/wget.c
index 29f5d45c3..9c7ed9f1d 100644
--- a/networking/wget.c
+++ b/networking/wget.c
@@ -118,22 +118,22 @@ static char *safe_fgets(char *s, int size, FILE *stream)
  */
 static char *base64enc(unsigned char *p, char *buf, int len) {
 
-        char al[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
-                    "0123456789+/";
+	char al[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
+		    "0123456789+/";
 		char *s = buf;
 
-        while(*p) {
+	while(*p) {
 				if (s >= buf+len-4)
 					bb_error_msg_and_die("buffer overflow");
-                *(s++) = al[(*p >> 2) & 0x3F];
-                *(s++) = al[((*p << 4) & 0x30) | ((*(p+1) >> 4) & 0x0F)];
-                *s = *(s+1) = '=';
-                *(s+2) = 0;
-                if (! *(++p)) break;
-                *(s++) = al[((*p << 2) & 0x3C) | ((*(p+1) >> 6) & 0x03)];
-                if (! *(++p)) break;
-                *(s++) = al[*(p++) & 0x3F];
-        }
+		*(s++) = al[(*p >> 2) & 0x3F];
+		*(s++) = al[((*p << 4) & 0x30) | ((*(p+1) >> 4) & 0x0F)];
+		*s = *(s+1) = '=';
+		*(s+2) = 0;
+		if (! *(++p)) break;
+		*(s++) = al[((*p << 2) & 0x3C) | ((*(p+1) >> 6) & 0x03)];
+		if (! *(++p)) break;
+		*(s++) = al[*(p++) & 0x3F];
+	}
 
 		return buf;
 }
@@ -190,8 +190,8 @@ int wget_main(int argc, char **argv)
 	 */
 	bb_opt_complementally = "-1:\203::";
 	bb_applet_long_options = wget_long_options;
-	opt = bb_getopt_ulflags(argc, argv, "cq\213O:\203:P:Y:", 
-					&fname_out, &headers_llist, 
+	opt = bb_getopt_ulflags(argc, argv, "cq\213O:\203:P:Y:",
+					&fname_out, &headers_llist,
 					&dir_prefix, &proxy_flag);
 	if (opt & WGET_OPT_CONTINUE) {
 		++do_continue;
@@ -217,7 +217,7 @@ int wget_main(int argc, char **argv)
 			headers_llist = headers_llist->link;
 		}
 	}
-	
+
 	parse_url(argv[optind], &target);
 	server.host = target.host;
 	server.port = target.port;
@@ -347,8 +347,8 @@ int wget_main(int argc, char **argv)
 			fprintf(sfp,"Connection: close\r\n\r\n");
 
 			/*
-		 	* Retrieve HTTP response line and check for "200" status code.
-		 	*/
+			* Retrieve HTTP response line and check for "200" status code.
+			*/
 read_response:
 			if (fgets(buf, sizeof(buf), sfp) == NULL)
 				close_delete_and_die("no response from server");
diff --git a/networking/zcip.c b/networking/zcip.c
index 294ffd066..b64e37c58 100644
--- a/networking/zcip.c
+++ b/networking/zcip.c
@@ -174,7 +174,7 @@ run(char *script, char *arg, char *intf, struct in_addr *ip)
 			execl(script, script, arg, NULL);
 			perror("execl");
 			_exit(EXIT_FAILURE);
-		} 
+		}
 
 		if (waitpid(pid, &status, 0) <= 0) {
 			why = "waitpid";
@@ -365,7 +365,7 @@ fail:
 		fds[0].events = POLLIN;
 		fds[0].revents = 0;
 
-		// poll, being ready to adjust current timeout 
+		// poll, being ready to adjust current timeout
 		if (timeout > 0) {
 			gettimeofday(&tv1, NULL);
 			tv1.tv_usec += (timeout % 1000) * 1000;
@@ -477,7 +477,7 @@ fail:
 					&& p.arp.ar_op != htons(ARPOP_REPLY))
 				continue;
 
-			// some cases are always conflicts 
+			// some cases are always conflicts
 			if ((p.source_ip.s_addr == ip.s_addr)
 					&& (memcmp(&addr, &p.source_addr,
 							ETH_ALEN) != 0)) {
@@ -533,7 +533,7 @@ collision:
 bad:
 	if (foreground)
 		perror(why);
-	else 
+	else
 		syslog(LOG_ERR, "%s %s, %s error: %s",
 			prog, intf, why, strerror(errno));
 	return EXIT_FAILURE;
diff --git a/procps/Config.in b/procps/Config.in
index 8a22a5dcf..52bfd3f43 100644
--- a/procps/Config.in
+++ b/procps/Config.in
@@ -17,7 +17,7 @@ config CONFIG_FUSER
 	bool "fuser"
 	default n
 	help
-	  fuser lists all PIDs (Process IDs) that currently have a given 
+	  fuser lists all PIDs (Process IDs) that currently have a given
 	  file open.  fuser can also list all PIDs that have a given network
 	  (TCP or UDP) port open.
 
diff --git a/procps/fuser.c b/procps/fuser.c
index 0258945ea..7ee56fbd9 100644
--- a/procps/fuser.c
+++ b/procps/fuser.c
@@ -1,6 +1,6 @@
 /*
- * tiny fuser implementation 
- * 
+ * tiny fuser implementation
+ *
  * Copyright 2004 Tony J. White
  *
  * May be distributed under the conditions of the
@@ -25,9 +25,9 @@
 
 #define FUSER_OPT_MOUNT  1
 #define FUSER_OPT_KILL   2
-#define FUSER_OPT_SILENT 4 
-#define FUSER_OPT_IP6    8 
-#define FUSER_OPT_IP4    16 
+#define FUSER_OPT_SILENT 4
+#define FUSER_OPT_IP6    8
+#define FUSER_OPT_IP4    16
 
 typedef struct inode_list {
 	ino_t inode;
@@ -40,7 +40,7 @@ typedef struct pid_list {
 	struct pid_list *next;
 } pid_list;
 
-static int fuser_option(char *option) 
+static int fuser_option(char *option)
 {
 	int opt = 0;
 
@@ -55,7 +55,7 @@ static int fuser_option(char *option)
 		else if(*option == '4') opt |= FUSER_OPT_IP4;
 		else {
 			bb_error_msg_and_die(
-				"Unsupported option '%c'", *option); 
+				"Unsupported option '%c'", *option);
 		}
 		++option;
 	}
@@ -69,13 +69,13 @@ static int fuser_file_to_dev_inode(const char *filename,
 	if((stat(filename, &f_stat)) < 0) return 0;
 	*inode = f_stat.st_ino;
 	*dev = f_stat.st_dev;
-        return 1;
+	return 1;
 }
 
 static int fuser_find_socket_dev(dev_t *dev) {
 	int fd = socket(PF_INET, SOCK_DGRAM,0);
 	struct stat buf;
-	
+
 	if (fd >= 0 && (fstat(fd, &buf)) == 0) {
 		*dev =  buf.st_dev;
 		close(fd);
@@ -84,8 +84,8 @@ static int fuser_find_socket_dev(dev_t *dev) {
 	return 0;
 }
 
-static int fuser_parse_net_arg(const char *filename, 
-	const char **proto, int *port) 
+static int fuser_parse_net_arg(const char *filename,
+	const char **proto, int *port)
 {
 	char path[sizeof(FUSER_PROC_DIR)+12], tproto[5];
 
@@ -93,51 +93,51 @@ static int fuser_parse_net_arg(const char *filename,
 	sprintf(path, "%s/net/%s", FUSER_PROC_DIR, tproto);
 	if((access(path, R_OK)) != 0) return 0;
 	*proto = bb_xstrdup(tproto);
-	return 1;	
+	return 1;
 }
 
 static int fuser_add_pid(pid_list *plist, pid_t pid)
 {
-        pid_list *curr = NULL, *last = NULL;
-        
-        if(plist->pid == 0) plist->pid = pid;
-        curr = plist;
-        while(curr != NULL) {
-                if(curr->pid == pid) return 1;
-                last = curr;
-                curr = curr->next;
-        }
-        curr = xmalloc(sizeof(pid_list));
-        last->next = curr;
-        curr->pid = pid;
+	pid_list *curr = NULL, *last = NULL;
+
+	if(plist->pid == 0) plist->pid = pid;
+	curr = plist;
+	while(curr != NULL) {
+		if(curr->pid == pid) return 1;
+		last = curr;
+		curr = curr->next;
+	}
+	curr = xmalloc(sizeof(pid_list));
+	last->next = curr;
+	curr->pid = pid;
 	curr->next = NULL;
-        return 1;
+	return 1;
 }
 
 static int fuser_add_inode(inode_list *ilist, dev_t dev, ino_t inode)
 {
-        inode_list *curr = NULL, *last = NULL;
-                                                                                
-        if(!ilist->inode && !ilist->dev) {
+	inode_list *curr = NULL, *last = NULL;
+
+	if(!ilist->inode && !ilist->dev) {
 		ilist->dev = dev;
 		ilist->inode = inode;
 	}
-        curr = ilist;
-        while(curr != NULL) {
-                if(curr->inode == inode && curr->dev == dev) return 1;
-                last = curr;
-                curr = curr->next;
-        }
-        curr = xmalloc(sizeof(inode_list));
-        last->next = curr;
-        curr->dev = dev;
-        curr->inode = inode;
+	curr = ilist;
+	while(curr != NULL) {
+		if(curr->inode == inode && curr->dev == dev) return 1;
+		last = curr;
+		curr = curr->next;
+	}
+	curr = xmalloc(sizeof(inode_list));
+	last->next = curr;
+	curr->dev = dev;
+	curr->inode = inode;
 	curr->next = NULL;
-        return 1;
+	return 1;
 }
 
-static int fuser_scan_proc_net(int opts, const char *proto, 
-	int port, inode_list *ilist) 
+static int fuser_scan_proc_net(int opts, const char *proto,
+	int port, inode_list *ilist)
 {
 	char path[sizeof(FUSER_PROC_DIR)+12], line[FUSER_MAX_LINE+1];
 	char addr[128];
@@ -156,10 +156,10 @@ static int fuser_scan_proc_net(int opts, const char *proto,
 			"%*d: %64[0-9A-Fa-f]:%x %*x:%*x %*x %*x:%*x "
 			"%*x:%*x %*x %*d %*d %llu",
 			addr, &tmp_port, &uint64_inode) == 3) {
-			if((strlen(addr) == 8) && 
+			if((strlen(addr) == 8) &&
 				(opts & FUSER_OPT_IP6)) continue;
 			else if((strlen(addr) > 8) &&
-				(opts & FUSER_OPT_IP4)) continue; 
+				(opts & FUSER_OPT_IP4)) continue;
 			if(tmp_port == port) {
 				tmp_inode = uint64_inode;
 				fuser_add_inode(ilist, tmp_dev, tmp_inode);
@@ -171,24 +171,24 @@ static int fuser_scan_proc_net(int opts, const char *proto,
 	return 1;
 }
 
-static int fuser_search_dev_inode(int opts, inode_list *ilist, 
-	dev_t dev, ino_t inode) 
+static int fuser_search_dev_inode(int opts, inode_list *ilist,
+	dev_t dev, ino_t inode)
 {
-        inode_list *curr;
-        curr = ilist;
+	inode_list *curr;
+	curr = ilist;
 
-        while(curr) {
+	while(curr) {
 		if((opts & FUSER_OPT_MOUNT) &&  curr->dev == dev)
 			return 1;
 		if(curr->inode == inode && curr->dev == dev)
 			return 1;
-                curr = curr->next;
-        }
-        return 0;
+		curr = curr->next;
+	}
+	return 0;
 }
 
 static int fuser_scan_pid_maps(int opts, const char *fname, pid_t pid,
-	inode_list *ilist, pid_list *plist) 
+	inode_list *ilist, pid_list *plist)
 {
 	FILE *file;
 	char line[FUSER_MAX_LINE + 1];
@@ -199,28 +199,28 @@ static int fuser_scan_pid_maps(int opts, const char *fname, pid_t pid,
 
 	if (!(file = fopen(fname, "r"))) return 0;
 	while (fgets(line, FUSER_MAX_LINE, file)) {
-		if(sscanf(line, "%*s %*s %*s %x:%x %llu", 
+		if(sscanf(line, "%*s %*s %*s %x:%x %llu",
 			&major, &minor, &uint64_inode) != 3) continue;
 		inode = uint64_inode;
 		if(major == 0 && minor == 0 && inode == 0) continue;
-		dev = makedev(major, minor);		
+		dev = makedev(major, minor);
 		if(fuser_search_dev_inode(opts, ilist, dev, inode)) {
 			fuser_add_pid(plist, pid);
 		}
-		
+
 	}
 	fclose(file);
 	return 1;
 }
 
-static int fuser_scan_link(int opts, const char *lname, pid_t pid, 
-	inode_list *ilist, pid_list *plist) 
+static int fuser_scan_link(int opts, const char *lname, pid_t pid,
+	inode_list *ilist, pid_list *plist)
 {
 	ino_t inode;
-	dev_t dev;	
+	dev_t dev;
 
 	if(!fuser_file_to_dev_inode(lname, &dev, &inode)) return 0;
-	if(fuser_search_dev_inode(opts, ilist, dev, inode)) 
+	if(fuser_search_dev_inode(opts, ilist, dev, inode))
 		fuser_add_pid(plist, pid);
 	return 1;
 }
@@ -245,9 +245,9 @@ static int fuser_scan_dir_links(int opts, const char *dname, pid_t pid,
 	else return 0;
 	return 1;
 
-} 
+}
 
-static int fuser_scan_proc_pids(int opts, inode_list *ilist, pid_list *plist) 
+static int fuser_scan_proc_pids(int opts, inode_list *ilist, pid_list *plist)
 {
 	DIR *d;
 	struct dirent *de;
@@ -261,7 +261,7 @@ static int fuser_scan_proc_pids(int opts, inode_list *ilist, pid_list *plist)
 		dname = concat_subpath_file(FUSER_PROC_DIR, de->d_name);
 		if(chdir(dname) < 0) {
 			free(dname);
-			continue; 
+			continue;
 		}
 		free(dname);
 		fuser_scan_link(opts, "cwd", pid, ilist, plist);
@@ -272,8 +272,8 @@ static int fuser_scan_proc_pids(int opts, inode_list *ilist, pid_list *plist)
 		fuser_scan_dir_links(opts, "mmap", pid, ilist, plist);
 		fuser_scan_pid_maps(opts, "maps", pid, ilist, plist);
 		chdir("..");
-	} 
-	closedir(d);	
+	}
+	closedir(d);
 	return 1;
 }
 
@@ -290,22 +290,22 @@ static int fuser_print_pid_list(pid_list *plist) {
 }
 
 static int fuser_kill_pid_list(pid_list *plist, int sig) {
-        pid_list *curr = plist;
+	pid_list *curr = plist;
 	pid_t mypid = getpid();
 	int success = 1;
 
 	if(plist == NULL) return 0;
-        while(curr != NULL) {
+	while(curr != NULL) {
 		if(curr->pid > 0 && curr->pid != mypid) {
-			if (kill(curr->pid, sig) != 0) { 
-                                bb_perror_msg(
+			if (kill(curr->pid, sig) != 0) {
+				bb_perror_msg(
 					"Could not kill pid '%d'", curr->pid);
-				success = 0;		
+				success = 0;
 			}
 		}
-                curr = curr->next;
-        }
-        return success;
+		curr = curr->next;
+	}
+	return success;
 }
 
 extern int fuser_main(int argc, char **argv) {
@@ -324,7 +324,7 @@ extern int fuser_main(int argc, char **argv) {
 	fni = xmalloc(sizeof(int));
 	for(i=1;i<argc;i++) {
 		optn = fuser_option(argv[i]);
-		if(optn) opt |= optn; 
+		if(optn) opt |= optn;
 		else if(argv[i][0] == '-') {
 			if(!(u_signal_names(argv[i]+1, &killsig, 0)))
 				killsig = SIGTERM;
@@ -368,4 +368,4 @@ extern int fuser_main(int argc, char **argv) {
 	free(inodes);
 	/* return 0 on (success == 1) 1 otherwise */
 	return (success != 1);
-} 
+}
diff --git a/procps/kill.c b/procps/kill.c
index 6d7f083b8..2d4e6deb4 100644
--- a/procps/kill.c
+++ b/procps/kill.c
@@ -87,7 +87,7 @@ extern int kill_main(int argc, char **argv)
 		return EXIT_SUCCESS;
 	}
 
-#ifdef CONFIG_KILLALL	
+#ifdef CONFIG_KILLALL
 	/* The -q quiet option */
 	if(argv[1][1]=='q' && argv[1][2]=='\0'){
 		quiet++;
diff --git a/procps/top.c b/procps/top.c
index 5faeafb59..a2a44da7d 100644
--- a/procps/top.c
+++ b/procps/top.c
@@ -133,20 +133,20 @@ static unsigned long Hertz;
 #define FILE_TO_BUF(filename, fd) do{                           \
     if (fd == -1 && (fd = open(filename, O_RDONLY)) == -1) {    \
 	bb_perror_msg_and_die("/proc not be mounted?");            \
-    }                                                           \
+    }					                   \
     lseek(fd, 0L, SEEK_SET);                                    \
     if ((local_n = read(fd, buf, sizeof buf - 1)) < 0) {        \
 	bb_perror_msg_and_die("%s", filename);                     \
-    }                                                           \
-    buf[local_n] = '\0';                                        \
+    }					                   \
+    buf[local_n] = '\0';					\
 }while(0)
 
 #define FILE_TO_BUF2(filename, fd) do{                          \
     lseek(fd, 0L, SEEK_SET);                                    \
     if ((local_n = read(fd, buf, sizeof buf - 1)) < 0) {        \
 	bb_perror_msg_and_die("%s", filename);                     \
-    }                                                           \
-    buf[local_n] = '\0';                                        \
+    }					                   \
+    buf[local_n] = '\0';					\
 }while(0)
 
 static void init_Hertz_value(void) {
diff --git a/scripts/config/conf.c b/scripts/config/conf.c
index d6c921d98..edcf36d69 100644
--- a/scripts/config/conf.c
+++ b/scripts/config/conf.c
@@ -528,7 +528,7 @@ int main(int ac, char **av)
 			exit(0);
 		}
 	}
-  	name = av[i];
+	name = av[i];
 	if (!name) {
 		printf("%s: configuration file missing\n", av[0]);
 	}
diff --git a/scripts/config/confdata.c b/scripts/config/confdata.c
index 6fb92c9f3..c4087fd73 100644
--- a/scripts/config/confdata.c
+++ b/scripts/config/confdata.c
@@ -264,7 +264,7 @@ struct menu *next_menu(struct menu *menu)
 			break;
 		}
 	} while ((menu = menu->parent));
-	
+
 	return menu;
 }
 
diff --git a/scripts/config/expr.c b/scripts/config/expr.c
index 30e4f9d69..6f39e7a25 100644
--- a/scripts/config/expr.c
+++ b/scripts/config/expr.c
@@ -824,7 +824,7 @@ bool expr_depends_symbol(struct expr *dep, struct symbol *sym)
 	default:
 		;
 	}
- 	return false;
+	return false;
 }
 
 struct expr *expr_extract_eq_and(struct expr **ep1, struct expr **ep2)
diff --git a/scripts/config/lex.zconf.c_shipped b/scripts/config/lex.zconf.c_shipped
index b877bb6b3..8e5e85e4c 100644
--- a/scripts/config/lex.zconf.c_shipped
+++ b/scripts/config/lex.zconf.c_shipped
@@ -2771,7 +2771,7 @@ YY_FATAL_ERROR( "flex scanner jammed" );
  */
 static int yy_get_next_buffer (void)
 {
-    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
 	register char *source = (yytext_ptr);
 	register int number_to_move, i;
 	int ret_val;
@@ -3091,7 +3091,7 @@ static int yy_get_next_buffer (void)
 
 static void zconf_load_buffer_state  (void)
 {
-    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
 	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
 	(yy_hold_char) = *(yy_c_buf_p);
@@ -3180,7 +3180,7 @@ static void zconf_load_buffer_state  (void)
  */
     void zconf_flush_buffer (YY_BUFFER_STATE  b )
 {
-    	if ( ! b )
+	if ( ! b )
 		return;
 
 	b->yy_n_chars = 0;
@@ -3209,7 +3209,7 @@ static void zconf_load_buffer_state  (void)
  */
 void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
 {
-    	if (new_buffer == NULL)
+	if (new_buffer == NULL)
 		return;
 
 	zconfensure_buffer_stack();
@@ -3239,7 +3239,7 @@ void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
  */
 void zconfpop_buffer_state (void)
 {
-    	if (!YY_CURRENT_BUFFER)
+	if (!YY_CURRENT_BUFFER)
 		return;
 
 	zconf_delete_buffer(YY_CURRENT_BUFFER );
@@ -3387,7 +3387,7 @@ YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * bytes, int  len )
 
 static void yy_fatal_error (yyconst char* msg )
 {
-    	(void) fprintf( stderr, "%s\n", msg );
+	(void) fprintf( stderr, "%s\n", msg );
 	exit( YY_EXIT_FAILURE );
 }
 
@@ -3514,7 +3514,7 @@ int zconflex_destroy  (void)
 static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
 {
 	register int i;
-    	for ( i = 0; i < n; ++i )
+	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
 }
 #endif
@@ -3523,7 +3523,7 @@ static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
 static int yy_flex_strlen (yyconst char * s )
 {
 	register int n;
-    	for ( n = 0; s[n]; ++n )
+	for ( n = 0; s[n]; ++n )
 		;
 
 	return n;
diff --git a/scripts/config/lxdialog/checklist.c b/scripts/config/lxdialog/checklist.c
index 71de4a191..7565b5db1 100644
--- a/scripts/config/lxdialog/checklist.c
+++ b/scripts/config/lxdialog/checklist.c
@@ -52,8 +52,8 @@ print_item (WINDOW * win, const char *item, int status,
     wattrset (win, selected ? item_selected_attr : item_attr);
     waddstr (win, (char *)item+1);
     if (selected) {
-    	wmove (win, choice, check_x+1);
-    	wrefresh (win);
+	wmove (win, choice, check_x+1);
+	wrefresh (win);
     }
 }
 
@@ -120,7 +120,7 @@ int
 dialog_checklist (const char *title, const char *prompt, int height, int width,
 	int list_height, int item_no, struct dialog_list_item ** items,
 	int flag)
-	
+
 {
     int i, x, y, box_x, box_y;
     int key = 0, button = 0, choice = 0, scroll = 0, max_choice, *status;
@@ -140,7 +140,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
     for (i = 0; i < item_no; i++) {
 	status[i] = (items[i]->selected == 1); /* ON */
 	if ((!choice && status[i]) || items[i]->selected == 2) /* SELECTED */
-            choice = i + 1;
+	    choice = i + 1;
     }
     if (choice)
 	    choice--;
@@ -197,7 +197,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 
     /* Find length of longest item in order to center checklist */
     check_x = 0;
-    for (i = 0; i < item_no; i++) 
+    for (i = 0; i < item_no; i++)
 	check_x = MAX (check_x, + strlen (items[i]->name) + 4);
 
     check_x = (list_width - check_x) / 2;
@@ -226,12 +226,12 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
     while (key != ESC) {
 	key = wgetch (dialog);
 
-    	for (i = 0; i < max_choice; i++)
-            if (toupper(key) == toupper(items[scroll + i]->name[0]))
-                break;
+	for (i = 0; i < max_choice; i++)
+	    if (toupper(key) == toupper(items[scroll + i]->name[0]))
+		break;
 
 
-	if ( i < max_choice || key == KEY_UP || key == KEY_DOWN || 
+	if ( i < max_choice || key == KEY_UP || key == KEY_DOWN ||
 	    key == '+' || key == '-' ) {
 	    if (key == KEY_UP || key == '-') {
 		if (!choice) {
@@ -251,7 +251,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 				status[scroll], 0, TRUE);
 		    wnoutrefresh (list);
 
-    		    print_arrows(dialog, choice, item_no, scroll,
+		    print_arrows(dialog, choice, item_no, scroll,
 				box_y, box_x + check_x + 5, list_height);
 
 		    wrefresh (dialog);
@@ -279,7 +279,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 				max_choice - 1, TRUE);
 		    wnoutrefresh (list);
 
-    		    print_arrows(dialog, choice, item_no, scroll,
+		    print_arrows(dialog, choice, item_no, scroll,
 				box_y, box_x + check_x + 5, list_height);
 
 		    wrefresh (dialog);
@@ -342,11 +342,11 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 		}
 		wnoutrefresh (list);
 		wrefresh (dialog);
-            
+
 		for (i = 0; i < item_no; i++) {
 			items[i]->selected = status[i];
 		}
-            } else {
+	    } else {
 		    for (i = 0; i < item_no; i++)
 			    items[i]->selected = 0;
 		    items[scroll + choice]->selected = 1;
@@ -364,7 +364,7 @@ dialog_checklist (const char *title, const char *prompt, int height, int width,
 	/* Now, update everything... */
 	doupdate ();
     }
-    
+
 
     delwin (dialog);
     free (status);
diff --git a/scripts/config/lxdialog/dialog.h b/scripts/config/lxdialog/dialog.h
index 7bab3ad0e..cb482a5ab 100644
--- a/scripts/config/lxdialog/dialog.h
+++ b/scripts/config/lxdialog/dialog.h
@@ -89,7 +89,7 @@
 #define ACS_DARROW 'v'
 #endif
 
-/* 
+/*
  * Attribute names
  */
 #define screen_attr                   attributes[0]
@@ -165,7 +165,7 @@ int dialog_msgbox (const char *title, const char *prompt, int height,
 		int width, int pause);
 int dialog_textbox (const char *title, const char *file, int height, int width);
 int dialog_menu (const char *title, const char *prompt, int height, int width,
-		int menu_height, const char *choice, int item_no, 
+		int menu_height, const char *choice, int item_no,
 		struct dialog_list_item ** items);
 int dialog_checklist (const char *title, const char *prompt, int height,
 		int width, int list_height, int item_no,
diff --git a/scripts/config/lxdialog/menubox.c b/scripts/config/lxdialog/menubox.c
index 873dc587b..d0990c34e 100644
--- a/scripts/config/lxdialog/menubox.c
+++ b/scripts/config/lxdialog/menubox.c
@@ -26,7 +26,7 @@
  *
  *    *)  A bugfix for the Page-Down problem
  *
- *    *)  Formerly when I used Page Down and Page Up, the cursor would be set 
+ *    *)  Formerly when I used Page Down and Page Up, the cursor would be set
  *        to the first position in the menu box.  Now lxdialog is a bit
  *        smarter and works more like other menu systems (just have a look at
  *        it).
@@ -78,8 +78,8 @@ print_item (WINDOW * win, const char *item, int choice, int selected, int hotkey
     wmove (win, choice, 0);
 #if OLD_NCURSES
     {
-        int i;
-        for (i = 0; i < menu_width; i++)
+	int i;
+	for (i = 0; i < menu_width; i++)
 	    waddch (win, ' ');
     }
 #else
@@ -88,8 +88,8 @@ print_item (WINDOW * win, const char *item, int choice, int selected, int hotkey
     wattrset (win, selected ? item_selected_attr : item_attr);
     mvwaddstr (win, choice, item_x, menu_item);
     if (hotkey) {
-    	wattrset (win, selected ? tag_key_selected_attr : tag_key_attr);
-    	mvwaddch(win, choice, item_x+j, menu_item[j]);
+	wattrset (win, selected ? tag_key_selected_attr : tag_key_attr);
+	mvwaddch(win, choice, item_x+j, menu_item[j]);
     }
     if (selected) {
 	wmove (win, choice, item_x+1);
@@ -225,7 +225,7 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 
     /*
      * Find length of longest item in order to center menu.
-     * Set 'choice' to default item. 
+     * Set 'choice' to default item.
      */
     item_x = 0;
     for (i = 0; i < item_no; i++) {
@@ -261,7 +261,7 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
     /* Print the menu */
     for (i=0; i < max_choice; i++) {
 	print_item (menu, items[first_item + i]->name, i, i == choice,
-                    (items[first_item + i]->tag[0] != ':'));
+		    (items[first_item + i]->tag[0] != ':'));
     }
 
     wnoutrefresh (menu);
@@ -281,107 +281,107 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 	if (strchr("ynmh", key))
 		i = max_choice;
 	else {
-        for (i = choice+1; i < max_choice; i++) {
+	for (i = choice+1; i < max_choice; i++) {
 		j = first_alpha(items[scroll + i]->name, "YyNnMmHh");
 		if (key == tolower(items[scroll + i]->name[j]))
-                	break;
+			break;
 	}
 	if (i == max_choice)
-       		for (i = 0; i < max_choice; i++) {
+		for (i = 0; i < max_choice; i++) {
 			j = first_alpha(items[scroll + i]->name, "YyNnMmHh");
 			if (key == tolower(items[scroll + i]->name[j]))
-                		break;
+				break;
 		}
 	}
 
-	if (i < max_choice || 
-            key == KEY_UP || key == KEY_DOWN ||
-            key == '-' || key == '+' ||
-            key == KEY_PPAGE || key == KEY_NPAGE) {
+	if (i < max_choice ||
+	    key == KEY_UP || key == KEY_DOWN ||
+	    key == '-' || key == '+' ||
+	    key == KEY_PPAGE || key == KEY_NPAGE) {
 
-            print_item (menu, items[scroll + choice]->name, choice, FALSE,
-                       (items[scroll + choice]->tag[0] != ':'));
+	    print_item (menu, items[scroll + choice]->name, choice, FALSE,
+		       (items[scroll + choice]->tag[0] != ':'));
 
 	    if (key == KEY_UP || key == '-') {
-                if (choice < 2 && scroll) {
+		if (choice < 2 && scroll) {
 	            /* Scroll menu down */
-                    scrollok (menu, TRUE);
-                    wscrl (menu, -1);
-                    scrollok (menu, FALSE);
+		    scrollok (menu, TRUE);
+		    wscrl (menu, -1);
+		    scrollok (menu, FALSE);
 
-                    scroll--;
+		    scroll--;
 
-                    print_item (menu, items[scroll]->name, 0, FALSE,
-                               (items[scroll]->tag[0] != ':'));
+		    print_item (menu, items[scroll]->name, 0, FALSE,
+			       (items[scroll]->tag[0] != ':'));
 		} else
 		    choice = MAX(choice - 1, 0);
 
 	    } else if (key == KEY_DOWN || key == '+')  {
 
 		print_item (menu, items[scroll + choice]->name, choice, FALSE,
-                                (items[scroll + choice]->tag[0] != ':'));
+				(items[scroll + choice]->tag[0] != ':'));
 
-                if ((choice > max_choice-3) &&
-                    (scroll + max_choice < item_no)
-                   ) {
+		if ((choice > max_choice-3) &&
+		    (scroll + max_choice < item_no)
+		   ) {
 		    /* Scroll menu up */
 		    scrollok (menu, TRUE);
-                    scroll (menu);
-                    scrollok (menu, FALSE);
+		    scroll (menu);
+		    scrollok (menu, FALSE);
 
-                    scroll++;
+		    scroll++;
 
-                    print_item (menu, items[scroll + max_choice - 1]->name,
-                               max_choice-1, FALSE,
-                               (items[scroll + max_choice - 1]->tag[0] != ':'));
-                } else
-                    choice = MIN(choice+1, max_choice-1);
+		    print_item (menu, items[scroll + max_choice - 1]->name,
+			       max_choice-1, FALSE,
+			       (items[scroll + max_choice - 1]->tag[0] != ':'));
+		} else
+		    choice = MIN(choice+1, max_choice-1);
 
 	    } else if (key == KEY_PPAGE) {
 	        scrollok (menu, TRUE);
-                for (i=0; (i < max_choice); i++) {
-                    if (scroll > 0) {
-                	wscrl (menu, -1);
-                	scroll--;
-                	print_item (menu, items[scroll]->name, 0, FALSE,
-                	(items[scroll]->tag[0] != ':'));
-                    } else {
-                        if (choice > 0)
-                            choice--;
-                    }
-                }
-                scrollok (menu, FALSE);
-
-            } else if (key == KEY_NPAGE) {
-                for (i=0; (i < max_choice); i++) {
-                    if (scroll+max_choice < item_no) {
+		for (i=0; (i < max_choice); i++) {
+		    if (scroll > 0) {
+			wscrl (menu, -1);
+			scroll--;
+			print_item (menu, items[scroll]->name, 0, FALSE,
+			(items[scroll]->tag[0] != ':'));
+		    } else {
+			if (choice > 0)
+			    choice--;
+		    }
+		}
+		scrollok (menu, FALSE);
+
+	    } else if (key == KEY_NPAGE) {
+		for (i=0; (i < max_choice); i++) {
+		    if (scroll+max_choice < item_no) {
 			scrollok (menu, TRUE);
 			scroll(menu);
 			scrollok (menu, FALSE);
-                	scroll++;
-                	print_item (menu, items[scroll + max_choice - 1]->name,
+			scroll++;
+			print_item (menu, items[scroll + max_choice - 1]->name,
 			            max_choice-1, FALSE,
 			            (items[scroll + max_choice - 1]->tag[0] != ':'));
 		    } else {
 			if (choice+1 < max_choice)
 			    choice++;
 		    }
-                }
+		}
 
-            } else
-                choice = i;
+	    } else
+		choice = i;
 
-            print_item (menu, items[scroll + choice]->name, choice, TRUE,
-                       (items[scroll + choice]->tag[0] != ':'));
+	    print_item (menu, items[scroll + choice]->name, choice, TRUE,
+		       (items[scroll + choice]->tag[0] != ':'));
 
-            print_arrows(dialog, item_no, scroll,
-                         box_y, box_x+item_x+1, menu_height);
+	    print_arrows(dialog, item_no, scroll,
+			 box_y, box_x+item_x+1, menu_height);
 
-            wnoutrefresh (dialog);
-            wrefresh (menu);
+	    wnoutrefresh (dialog);
+	    wrefresh (menu);
 
 	    continue;		/* wait for another key press */
-        }
+	}
 
 	switch (key) {
 	case KEY_LEFT:
@@ -405,15 +405,15 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 		fclose(f);
 	    }
 	    delwin (dialog);
-            items[scroll + choice]->selected = 1;
-            switch (key) {
-            case 's': return 3;
-            case 'y': return 3;
-            case 'n': return 4;
-            case 'm': return 5;
-            case ' ': return 6;
-            case '/': return 7;
-            }
+	    items[scroll + choice]->selected = 1;
+	    switch (key) {
+	    case 's': return 3;
+	    case 'y': return 3;
+	    case 'n': return 4;
+	    case 'm': return 5;
+	    case ' ': return 6;
+	    case '/': return 7;
+	    }
 	    return 0;
 	case 'h':
 	case '?':
diff --git a/scripts/config/lxdialog/msgbox.c b/scripts/config/lxdialog/msgbox.c
index 93692e1fb..de0f32bf0 100644
--- a/scripts/config/lxdialog/msgbox.c
+++ b/scripts/config/lxdialog/msgbox.c
@@ -73,7 +73,7 @@ dialog_msgbox (const char *title, const char *prompt, int height, int width,
 
 	wrefresh (dialog);
 	while (key != ESC && key != '\n' && key != ' ' &&
-               key != 'O' && key != 'o' && key != 'X' && key != 'x')
+	       key != 'O' && key != 'o' && key != 'X' && key != 'x')
 	    key = wgetch (dialog);
     } else {
 	key = '\n';
diff --git a/scripts/config/lxdialog/textbox.c b/scripts/config/lxdialog/textbox.c
index a5a460b5c..b75e12a3e 100644
--- a/scripts/config/lxdialog/textbox.c
+++ b/scripts/config/lxdialog/textbox.c
@@ -472,8 +472,8 @@ print_line (WINDOW * win, int row, int width)
     /* Clear 'residue' of previous line */
 #if OLD_NCURSES
     {
-        int i;
-        for (i = 0; i < width - x; i++)
+	int i;
+	for (i = 0; i < width - x; i++)
 	    waddch (win, ' ');
     }
 #else
diff --git a/scripts/config/lxdialog/util.c b/scripts/config/lxdialog/util.c
index 6f83951b9..47afa5e6a 100644
--- a/scripts/config/lxdialog/util.c
+++ b/scripts/config/lxdialog/util.c
@@ -29,7 +29,7 @@ const char *backtitle = NULL;
 
 const char *dialog_result;
 
-/* 
+/*
  * Attribute values, default is for mono display
  */
 chtype attributes[] =
@@ -127,13 +127,13 @@ void dialog_clear (void)
     attr_clear (stdscr, LINES, COLS, screen_attr);
     /* Display background title if it exists ... - SLH */
     if (backtitle != NULL) {
-        int i;
+	int i;
 
-        wattrset (stdscr, screen_attr);
-        mvwaddstr (stdscr, 0, 1, (char *)backtitle);
-        wmove (stdscr, 1, 1);
-        for (i = 1; i < COLS - 1; i++)
-            waddch (stdscr, ACS_HLINE);
+	wattrset (stdscr, screen_attr);
+	mvwaddstr (stdscr, 0, 1, (char *)backtitle);
+	wmove (stdscr, 1, 1);
+	for (i = 1; i < COLS - 1; i++)
+	    waddch (stdscr, ACS_HLINE);
     }
     wnoutrefresh (stdscr);
 }
@@ -204,7 +204,7 @@ print_autowrap (WINDOW * win, const char *prompt, int width, int y, int x)
     strcpy (tempstr, prompt);
 
     prompt_len = strlen(tempstr);
-	
+
     /*
      * Remove newlines
      */
@@ -350,7 +350,7 @@ first_alpha(const char *string, const char *exempt)
 		if (strchr("<[(", c)) ++in_paren;
 		if (strchr(">])", c) && in_paren > 0) --in_paren;
 
-		if ((! in_paren) && isalpha(c) && 
+		if ((! in_paren) && isalpha(c) &&
 		     strchr(exempt, c) == 0)
 			return i;
 	}
diff --git a/scripts/config/zconf.tab.c_shipped b/scripts/config/zconf.tab.c_shipped
index be6bd4c0d..0bf511e30 100644
--- a/scripts/config/zconf.tab.c_shipped
+++ b/scripts/config/zconf.tab.c_shipped
@@ -333,7 +333,7 @@ union yyalloc
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   296
 
-#define YYTRANSLATE(YYX) 						\
+#define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
@@ -709,7 +709,7 @@ do								\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
+    {								\
       yyerror ("syntax error: cannot back up");\
       YYERROR;							\
     }								\
@@ -762,7 +762,7 @@ do {								\
   if (yydebug)							\
     {								\
       YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
+      yysymprint (stderr,					\
                   Token, Value);	\
       YYFPRINTF (stderr, "\n");					\
     }								\
diff --git a/shell/ash.c b/shell/ash.c
index ef1fe0af7..69062e02d 100644
--- a/shell/ash.c
+++ b/shell/ash.c
@@ -841,7 +841,7 @@ static int SIT(int c, int syntax)
 	return S_I_T[indx][syntax];
 }
 
-#else                                                   /* USE_SIT_FUNCTION */
+#else					           /* USE_SIT_FUNCTION */
 
 #define SIT(c, syntax) S_I_T[(int)syntax_index_table[((int)c)+SYNBASE]][syntax]
 
@@ -1142,7 +1142,7 @@ static const char syntax_index_table[258] = {
 	/* 257   127      */ CWORD_CWORD_CWORD_CWORD,
 };
 
-#endif                                                  /* USE_SIT_FUNCTION */
+#endif					          /* USE_SIT_FUNCTION */
 
 /*      alias.c      */
 
diff --git a/shell/cmdedit.c b/shell/cmdedit.c
index edfa01613..db246315c 100644
--- a/shell/cmdedit.c
+++ b/shell/cmdedit.c
@@ -67,7 +67,7 @@
 #define CONFIG_FEATURE_NONPRINTABLE_INVERSE_PUT
 #define CONFIG_FEATURE_CLEAN_UP
 
-#endif                                                  /* TEST */
+#endif					          /* TEST */
 
 #ifdef CONFIG_FEATURE_COMMAND_TAB_COMPLETION
 #include <dirent.h>
@@ -82,7 +82,7 @@
 
 #ifdef CONFIG_FEATURE_GETUSERNAME_AND_HOMEDIR
 #include "pwd_.h"
-#endif                                                  /* advanced FEATURES */
+#endif					          /* advanced FEATURES */
 
 
 /* Maximum length of the linked list for the command line history */
@@ -177,7 +177,7 @@ static void win_changed(int nsig)
 		previous_SIGWINCH_handler = signal(SIGWINCH, win_changed);
 	else if (nsig == SIGWINCH)      /* signaled called handler */
 		signal(SIGWINCH, win_changed);  /* set for next call       */
-	else                                            /* nsig == 0 */
+	else					    /* nsig == 0 */
 		/* set previous handler    */
 		signal(SIGWINCH, previous_SIGWINCH_handler);    /* reset    */
 }
@@ -907,7 +907,7 @@ static int find_match(char *matchBuf, int *len_with_quotes)
 		}
 
 	/* collapse (command...(command...)...) or {command...{command...}...} */
-	c = 0;                                          /* "recursive" level */
+	c = 0;					  /* "recursive" level */
 	c2 = 0;
 	for (i = 0; int_buf[i]; i++)
 		if (int_buf[i] == '(' || int_buf[i] == '{') {
@@ -1358,7 +1358,7 @@ vi_back_motion(char *command)
 }
 #endif
 
-/* 
+/*
  * the normal emacs mode and vi's insert mode are the same.
  * commands entered when in vi command mode ("escape mode") get
  * an extra bit added to distinguish them.  this lets them share
@@ -1431,7 +1431,7 @@ int cmdedit_read_input(char *prompt, char command[BUFSIZ])
 		newdelflag = 1;
 		ic = c;
 		if (vi_cmdmode)
-		    	ic |= VI_cmdbit;
+			ic |= VI_cmdbit;
 		switch (ic)
 #else
 		switch (c)
@@ -1613,7 +1613,7 @@ prepare_to_die:
 			vi_cmdmode = 0;
 			/* fall through */
 		case VICMD('d'):
-			{ 
+			{
 			int nc, sc;
 			sc = cursor;
 			prevc = ic;
@@ -1632,7 +1632,7 @@ prepare_to_die:
 			case 'E':
 			    switch (c) {
 			    case 'w':   /* "dw", "cw" */
-			    	    vi_word_motion(command, vi_cmdmode);
+				    vi_word_motion(command, vi_cmdmode);
 				    break;
 			    case 'W':   /* 'dW', 'cW' */
 				    vi_Word_motion(command, vi_cmdmode);
diff --git a/shell/hush.c b/shell/hush.c
index 70533a2b0..ff29974b6 100644
--- a/shell/hush.c
+++ b/shell/hush.c
@@ -1581,7 +1581,7 @@ static int run_list_real(struct pipe *pi)
 		if (rmode == RES_IN) continue;
 		if (rmode == RES_DO) {
 			if (!flag_rep) continue;
-		}	
+		}
 		if ((rmode == RES_DONE)) {
 			if (flag_rep) {
 				flag_restore = 1;
@@ -1782,17 +1782,17 @@ static int xglob(o_string *dest, int flags, glob_t *pglob)
 {
 	int gr;
 
- 	/* short-circuit for null word */
+	/* short-circuit for null word */
 	/* we can code this better when the debug_printf's are gone */
- 	if (dest->length == 0) {
- 		if (dest->nonnull) {
- 			/* bash man page calls this an "explicit" null */
- 			gr = globhack(dest->data, flags, pglob);
- 			debug_printf("globhack returned %d\n",gr);
- 		} else {
+	if (dest->length == 0) {
+		if (dest->nonnull) {
+			/* bash man page calls this an "explicit" null */
+			gr = globhack(dest->data, flags, pglob);
+			debug_printf("globhack returned %d\n",gr);
+		} else {
 			return 0;
 		}
- 	} else if (glob_needed(dest->data)) {
+	} else if (glob_needed(dest->data)) {
 		gr = glob(dest->data, flags, NULL, pglob);
 		debug_printf("glob returned %d\n",gr);
 		if (gr == GLOB_NOMATCH) {
@@ -2111,7 +2111,7 @@ static int done_word(o_string *dest, struct p_context *ctx)
 			if (reserved_word(dest,ctx)) return ctx->w==RES_SNTX;
 		}
 		glob_target = &child->glob_result;
- 		if (child->argv) flags |= GLOB_APPEND;
+		if (child->argv) flags |= GLOB_APPEND;
 	}
 	gr = xglob(dest, flags, glob_target);
 	if (gr != 0) return 1;
diff --git a/shell/lash.c b/shell/lash.c
index a23f5f4d4..56a3a23dd 100644
--- a/shell/lash.c
+++ b/shell/lash.c
@@ -1267,7 +1267,7 @@ static int pseudo_exec(struct child_prog *child)
 		char** argv_l=child->argv;
 		int argc_l;
 #ifdef _NEWLIB_VERSION
-		/* newlib uses __getopt_initialized for getopt() in 
+		/* newlib uses __getopt_initialized for getopt() in
 		 * addition to optind, see newlib/libc/sys/linux/getopt.c
 		 */
 		extern int __getopt_initialized = 0;
diff --git a/shell/msh.c b/shell/msh.c
index 9e9a10b9f..08ca792fa 100644
--- a/shell/msh.c
+++ b/shell/msh.c
@@ -335,9 +335,9 @@ static void sig(int i);			/* default signal handler */
 #define GROWBY	  (256)
 /* #define	SHRINKBY   (64) */
 #undef	SHRINKBY
-#define FREE 	  (32767)
-#define BUSY 	  (0)
-#define	ALIGN 	  (sizeof(int)-1)
+#define FREE	  (32767)
+#define BUSY	  (0)
+#define	ALIGN	  (sizeof(int)-1)
 
 
 struct region {
diff --git a/sysklogd/logread.c b/sysklogd/logread.c
index 883e2cf44..8ea8047f7 100644
--- a/sysklogd/logread.c
+++ b/sysklogd/logread.c
@@ -102,7 +102,7 @@ extern int logread_main(int argc, char **argv)
 		error_exit("Can't get access to circular buffer from syslogd");
 
 	if ( (log_semid = semget(KEY_ID, 0, 0)) == -1)
-	    	error_exit("Can't get access to semaphone(s) for circular buffer from syslogd");
+		error_exit("Can't get access to semaphone(s) for circular buffer from syslogd");
 
 	// Suppose atomic memory move
 	i = follow ? buf->tail : buf->head;
diff --git a/sysklogd/syslogd.c b/sysklogd/syslogd.c
index e6b7ee7ed..c827fd85a 100644
--- a/sysklogd/syslogd.c
+++ b/sysklogd/syslogd.c
@@ -386,7 +386,7 @@ static void logMessage(int pri, char *msg)
 	time_t now;
 	char *timestamp;
 	static char res[20];
-#ifdef CONFIG_FEATURE_REMOTE_LOG	
+#ifdef CONFIG_FEATURE_REMOTE_LOG
 	static char line[MAXLINE + 1];
 #endif
 	CODE *c_pri, *c_fac;
diff --git a/util-linux/Config.in b/util-linux/Config.in
index bf3e13b2a..27410bf10 100644
--- a/util-linux/Config.in
+++ b/util-linux/Config.in
@@ -214,7 +214,7 @@ config CONFIG_FEATURE_HWCLOCK_ADJTIME_FHS
 	depends on CONFIG_HWCLOCK
 	help
 	  Starting with FHS 2.3, the adjtime state file is supposed to exist
-	  at /var/lib/hwclock/adjtime instead of /etc/adjtime.  If you wish 
+	  at /var/lib/hwclock/adjtime instead of /etc/adjtime.  If you wish
 	  to use the FHS behavior, answer Y here, otherwise answer N for the
 	  classic /etc/adjtime path.
 
@@ -406,7 +406,7 @@ config CONFIG_FEATURE_MOUNT_LOOP
 	  command will detect you are trying to mount a file instead of a block
 	  device, and transparently associate the file with a loopback device.
 	  The umount command will also free that loopback device.
-	  
+
 	  You can still use the 'losetup' utility (to manually associate files
           with loop devices) if you need to do something advanced, such as
 	  specify an offset or cryptographic options to the loopback device.
diff --git a/util-linux/fbset.c b/util-linux/fbset.c
index 83bf309a3..b1118311f 100644
--- a/util-linux/fbset.c
+++ b/util-linux/fbset.c
@@ -52,7 +52,7 @@ enum {
 	CMD_VSYNC = 7,
 	CMD_LACED = 8,
 	CMD_DOUBLE = 9,
-/* 	CMD_XCOMPAT =     10, */
+/*	CMD_XCOMPAT =     10, */
 	CMD_ALL = 11,
 	CMD_INFO = 12,
 	CMD_CHANGE = 13,
@@ -207,70 +207,70 @@ static int readmode(struct fb_var_screeninfo *base, const char *fn,
 				while (!feof(f)) {
 					fgets(buf, sizeof(buf), f);
 
-                    if ((p = strstr(buf, "geometry "))) {
-                        p += 9;
-
-                        sscanf(p, "%d %d %d %d %d",
-                                &(base->xres), &(base->yres),
-                                &(base->xres_virtual), &(base->yres_virtual),
-                                &(base->bits_per_pixel));
-                    } else if ((p = strstr(buf, "timings "))) {
-                        p += 8;
-    
-                        sscanf(p, "%d %d %d %d %d %d %d",
-                                &(base->pixclock),
-                                &(base->left_margin), &(base->right_margin),
-                                &(base->upper_margin), &(base->lower_margin),
-                                &(base->hsync_len), &(base->vsync_len));
-                    } else if ((p = strstr(buf, "laced "))) {
-                        p += 6;
-
-                        if (strstr(buf, "false")) {
-                            base->vmode &= ~FB_VMODE_INTERLACED;
-                        } else {
-                            base->vmode |= FB_VMODE_INTERLACED;
-                        }
-                    } else if ((p = strstr(buf, "double "))) {
-                        p += 7;
-
-                        if (strstr(buf, "false")) {
-                            base->vmode &= ~FB_VMODE_DOUBLE;
-                        } else {
-                            base->vmode |= FB_VMODE_DOUBLE;
-                        }
-                    } else if ((p = strstr(buf, "vsync "))) {
-                        p += 6;
-
-                        if (strstr(buf, "low")) {
-                            base->sync &= ~FB_SYNC_VERT_HIGH_ACT;
-                        } else {
-                            base->sync |= FB_SYNC_VERT_HIGH_ACT;
-                        }
-                    } else if ((p = strstr(buf, "hsync "))) {
-                        p += 6;
-
-                        if (strstr(buf, "low")) {
-                            base->sync &= ~FB_SYNC_HOR_HIGH_ACT;
-                        } else {
-                            base->sync |= FB_SYNC_HOR_HIGH_ACT;
-                        }
-                    } else if ((p = strstr(buf, "csync "))) {
-                        p += 6;
-
-                        if (strstr(buf, "low")) {
-                            base->sync &= ~FB_SYNC_COMP_HIGH_ACT;
-                        } else {
-                            base->sync |= FB_SYNC_COMP_HIGH_ACT;
-                        }
-                    } else if ((p = strstr(buf, "extsync "))) {
-                        p += 8;
-
-                        if (strstr(buf, "false")) {
-                            base->sync &= ~FB_SYNC_EXT;
-                        } else {
-                            base->sync |= FB_SYNC_EXT;
-                        }
-                    }
+		    if ((p = strstr(buf, "geometry "))) {
+			p += 9;
+
+			sscanf(p, "%d %d %d %d %d",
+				&(base->xres), &(base->yres),
+				&(base->xres_virtual), &(base->yres_virtual),
+				&(base->bits_per_pixel));
+		    } else if ((p = strstr(buf, "timings "))) {
+			p += 8;
+
+			sscanf(p, "%d %d %d %d %d %d %d",
+				&(base->pixclock),
+				&(base->left_margin), &(base->right_margin),
+				&(base->upper_margin), &(base->lower_margin),
+				&(base->hsync_len), &(base->vsync_len));
+		    } else if ((p = strstr(buf, "laced "))) {
+			p += 6;
+
+			if (strstr(buf, "false")) {
+			    base->vmode &= ~FB_VMODE_INTERLACED;
+			} else {
+			    base->vmode |= FB_VMODE_INTERLACED;
+			}
+		    } else if ((p = strstr(buf, "double "))) {
+			p += 7;
+
+			if (strstr(buf, "false")) {
+			    base->vmode &= ~FB_VMODE_DOUBLE;
+			} else {
+			    base->vmode |= FB_VMODE_DOUBLE;
+			}
+		    } else if ((p = strstr(buf, "vsync "))) {
+			p += 6;
+
+			if (strstr(buf, "low")) {
+			    base->sync &= ~FB_SYNC_VERT_HIGH_ACT;
+			} else {
+			    base->sync |= FB_SYNC_VERT_HIGH_ACT;
+			}
+		    } else if ((p = strstr(buf, "hsync "))) {
+			p += 6;
+
+			if (strstr(buf, "low")) {
+			    base->sync &= ~FB_SYNC_HOR_HIGH_ACT;
+			} else {
+			    base->sync |= FB_SYNC_HOR_HIGH_ACT;
+			}
+		    } else if ((p = strstr(buf, "csync "))) {
+			p += 6;
+
+			if (strstr(buf, "low")) {
+			    base->sync &= ~FB_SYNC_COMP_HIGH_ACT;
+			} else {
+			    base->sync |= FB_SYNC_COMP_HIGH_ACT;
+			}
+		    } else if ((p = strstr(buf, "extsync "))) {
+			p += 8;
+
+			if (strstr(buf, "false")) {
+			    base->sync &= ~FB_SYNC_EXT;
+			} else {
+			    base->sync |= FB_SYNC_EXT;
+			}
+		    }
 
 					if (strstr(buf, "endmode"))
 						return 1;
@@ -374,9 +374,9 @@ extern int fbset_main(int argc, char **argv)
 					varset.hsync_len = strtoul(argv[6], 0, 0);
 					varset.vsync_len = strtoul(argv[7], 0, 0);
 					break;
-                case CMD_CHANGE:
-                    g_options |= OPT_CHANGE;
-                    break;
+		case CMD_CHANGE:
+		    g_options |= OPT_CHANGE;
+		    break;
 #ifdef CONFIG_FEATURE_FBSET_FANCY
 				case CMD_XRES:
 					varset.xres = strtoul(argv[1], 0, 0);
diff --git a/util-linux/fdformat.c b/util-linux/fdformat.c
index 768105159..e7dd943bb 100644
--- a/util-linux/fdformat.c
+++ b/util-linux/fdformat.c
@@ -134,7 +134,7 @@ int fdformat_main(int argc,char **argv)
 			if((read_bytes = safe_read(fd,data,n))!= n ) {
 				if(read_bytes < 0) {
 					bb_perror_msg("Read: ");
-	    		}
+				}
 				bb_error_msg_and_die("Problem reading cylinder %d, expected %d, read %d", cyl, n, read_bytes);
 			}
 			/* Check backwards so we don't need a counter */
@@ -147,14 +147,14 @@ int fdformat_main(int argc,char **argv)
 		/* There is no point in freeing blocks at the end of a program, because
 		all of the program's space is given back to the system when the process
 		terminates.*/
-		
+
 		if (ENABLE_FEATURE_CLEAN_UP) free(data);
-		
+
 		print_and_flush("done\n", NULL);
 	}
 
 	if (ENABLE_FEATURE_CLEAN_UP) close(fd);
-	
+
 	/* Don't bother closing.  Exit does
 	 * that, so we can save a few bytes */
 	return EXIT_SUCCESS;
diff --git a/util-linux/getopt.c b/util-linux/getopt.c
index fc3b9f97e..16dcbbca0 100644
--- a/util-linux/getopt.c
+++ b/util-linux/getopt.c
@@ -71,7 +71,7 @@ static int alternative; /* 0 is getopt_long, 1 is getopt_long_only */
 /* Function prototypes */
 static const char *normalize(const char *arg);
 static int generate_output(char * argv[],int argc,const char *optstr,
-                    const struct option *longopts);
+		    const struct option *longopts);
 static void add_long_options(char *options);
 static void add_longopt(const char *name,int has_arg);
 static void set_shell(const char *new_shell);
@@ -88,57 +88,57 @@ static void set_shell(const char *new_shell);
  */
 const char *normalize(const char *arg)
 {
-        static char *BUFFER=NULL;
-        const char *argptr=arg;
-        char *bufptr;
-
-        free(BUFFER);
-
-        if (!quote) { /* Just copy arg */
-               BUFFER=bb_xstrdup(arg);
-                return BUFFER;
-        }
-
-        /* Each character in arg may take up to four characters in the result:
-           For a quote we need a closing quote, a backslash, a quote and an
-           opening quote! We need also the global opening and closing quote,
-           and one extra character for '\0'. */
-        BUFFER=xmalloc(strlen(arg)*4+3);
-
-        bufptr=BUFFER;
-        *bufptr++='\'';
-
-        while (*argptr) {
-                if (*argptr == '\'') {
-                        /* Quote: replace it with: '\'' */
-                        *bufptr++='\'';
-                        *bufptr++='\\';
-                        *bufptr++='\'';
-                        *bufptr++='\'';
-                } else if (shell==TCSH && *argptr=='!') {
-                        /* Exclamation mark: replace it with: \! */
-                        *bufptr++='\'';
-                        *bufptr++='\\';
-                        *bufptr++='!';
-                        *bufptr++='\'';
-                } else if (shell==TCSH && *argptr=='\n') {
-                        /* Newline: replace it with: \n */
-                        *bufptr++='\\';
-                        *bufptr++='n';
-                } else if (shell==TCSH && isspace(*argptr)) {
-                        /* Non-newline whitespace: replace it with \<ws> */
-                        *bufptr++='\'';
-                        *bufptr++='\\';
-                        *bufptr++=*argptr;
-                        *bufptr++='\'';
-                } else
-                        /* Just copy */
-                        *bufptr++=*argptr;
-                argptr++;
-        }
-        *bufptr++='\'';
-        *bufptr++='\0';
-        return BUFFER;
+	static char *BUFFER=NULL;
+	const char *argptr=arg;
+	char *bufptr;
+
+	free(BUFFER);
+
+	if (!quote) { /* Just copy arg */
+	       BUFFER=bb_xstrdup(arg);
+		return BUFFER;
+	}
+
+	/* Each character in arg may take up to four characters in the result:
+	   For a quote we need a closing quote, a backslash, a quote and an
+	   opening quote! We need also the global opening and closing quote,
+	   and one extra character for '\0'. */
+	BUFFER=xmalloc(strlen(arg)*4+3);
+
+	bufptr=BUFFER;
+	*bufptr++='\'';
+
+	while (*argptr) {
+		if (*argptr == '\'') {
+			/* Quote: replace it with: '\'' */
+			*bufptr++='\'';
+			*bufptr++='\\';
+			*bufptr++='\'';
+			*bufptr++='\'';
+		} else if (shell==TCSH && *argptr=='!') {
+			/* Exclamation mark: replace it with: \! */
+			*bufptr++='\'';
+			*bufptr++='\\';
+			*bufptr++='!';
+			*bufptr++='\'';
+		} else if (shell==TCSH && *argptr=='\n') {
+			/* Newline: replace it with: \n */
+			*bufptr++='\\';
+			*bufptr++='n';
+		} else if (shell==TCSH && isspace(*argptr)) {
+			/* Non-newline whitespace: replace it with \<ws> */
+			*bufptr++='\'';
+			*bufptr++='\\';
+			*bufptr++=*argptr;
+			*bufptr++='\'';
+		} else
+			/* Just copy */
+			*bufptr++=*argptr;
+		argptr++;
+	}
+	*bufptr++='\'';
+	*bufptr++='\0';
+	return BUFFER;
 }
 
 /*
@@ -149,47 +149,47 @@ const char *normalize(const char *arg)
  * Other settings are found in global variables.
  */
 int generate_output(char * argv[],int argc,const char *optstr,
-                    const struct option *longopts)
+		    const struct option *longopts)
 {
-        int exit_code = 0; /* We assume everything will be OK */
-        int opt;
-        int longindex;
-        const char *charptr;
-
-        if (quiet_errors) /* No error reporting from getopt(3) */
-                opterr=0;
-        optind=0; /* Reset getopt(3) */
-
-        while ((opt = (alternative?
-                       getopt_long_only(argc,argv,optstr,longopts,&longindex):
-                       getopt_long(argc,argv,optstr,longopts,&longindex)))
-               != EOF)
-                if (opt == '?' || opt == ':' )
-                        exit_code = 1;
-                else if (!quiet_output) {
-                        if (opt == LONG_OPT) {
-                                printf(" --%s",longopts[longindex].name);
-                                if (longopts[longindex].has_arg)
-                                        printf(" %s",
-                                               normalize(optarg?optarg:""));
-                        } else if (opt == NON_OPT)
-                                printf(" %s",normalize(optarg));
-                        else {
-                                printf(" -%c",opt);
-                                charptr = strchr(optstr,opt);
-                                if (charptr != NULL && *++charptr == ':')
-                                        printf(" %s",
-                                               normalize(optarg?optarg:""));
-                        }
-                }
-
-        if (! quiet_output) {
-                printf(" --");
-                while (optind < argc)
-                        printf(" %s",normalize(argv[optind++]));
-                printf("\n");
-        }
-        return exit_code;
+	int exit_code = 0; /* We assume everything will be OK */
+	int opt;
+	int longindex;
+	const char *charptr;
+
+	if (quiet_errors) /* No error reporting from getopt(3) */
+		opterr=0;
+	optind=0; /* Reset getopt(3) */
+
+	while ((opt = (alternative?
+		       getopt_long_only(argc,argv,optstr,longopts,&longindex):
+		       getopt_long(argc,argv,optstr,longopts,&longindex)))
+	       != EOF)
+		if (opt == '?' || opt == ':' )
+			exit_code = 1;
+		else if (!quiet_output) {
+			if (opt == LONG_OPT) {
+				printf(" --%s",longopts[longindex].name);
+				if (longopts[longindex].has_arg)
+					printf(" %s",
+					       normalize(optarg?optarg:""));
+			} else if (opt == NON_OPT)
+				printf(" %s",normalize(optarg));
+			else {
+				printf(" -%c",opt);
+				charptr = strchr(optstr,opt);
+				if (charptr != NULL && *++charptr == ':')
+					printf(" %s",
+					       normalize(optarg?optarg:""));
+			}
+		}
+
+	if (! quiet_output) {
+		printf(" --");
+		while (optind < argc)
+			printf(" %s",normalize(argv[optind++]));
+		printf("\n");
+	}
+	return exit_code;
 }
 
 static struct option *long_options;
@@ -201,32 +201,32 @@ static const int LONG_OPTIONS_INCR = 10;
 /* Register a long option. The contents of name is copied. */
 void add_longopt(const char *name,int has_arg)
 {
-        if (!name) { /* init */
-                free(long_options);
-                long_options=NULL;
-                long_options_length=0;
-                long_options_nr=0;
-        }
-
-        if (long_options_nr == long_options_length) {
-                long_options_length += LONG_OPTIONS_INCR;
-                long_options=xrealloc(long_options,
-                                         sizeof(struct option) *
-                                         long_options_length);
-        }
-
-        long_options[long_options_nr].name=NULL;
-        long_options[long_options_nr].has_arg=0;
-        long_options[long_options_nr].flag=NULL;
-        long_options[long_options_nr].val=0;
-
-        if (long_options_nr) { /* Not for init! */
-                long_options[long_options_nr-1].has_arg=has_arg;
-                long_options[long_options_nr-1].flag=NULL;
-                long_options[long_options_nr-1].val=LONG_OPT;
-               long_options[long_options_nr-1].name=bb_xstrdup(name);
-        }
-        long_options_nr++;
+	if (!name) { /* init */
+		free(long_options);
+		long_options=NULL;
+		long_options_length=0;
+		long_options_nr=0;
+	}
+
+	if (long_options_nr == long_options_length) {
+		long_options_length += LONG_OPTIONS_INCR;
+		long_options=xrealloc(long_options,
+					 sizeof(struct option) *
+					 long_options_length);
+	}
+
+	long_options[long_options_nr].name=NULL;
+	long_options[long_options_nr].has_arg=0;
+	long_options[long_options_nr].flag=NULL;
+	long_options[long_options_nr].val=0;
+
+	if (long_options_nr) { /* Not for init! */
+		long_options[long_options_nr-1].has_arg=has_arg;
+		long_options[long_options_nr-1].flag=NULL;
+		long_options[long_options_nr-1].val=LONG_OPT;
+	       long_options[long_options_nr-1].name=bb_xstrdup(name);
+	}
+	long_options_nr++;
 }
 
 
@@ -237,43 +237,43 @@ void add_longopt(const char *name,int has_arg)
  */
 void add_long_options(char *options)
 {
-        int arg_opt, tlen;
-        char *tokptr=strtok(options,", \t\n");
-        while (tokptr) {
-                arg_opt=no_argument;
+	int arg_opt, tlen;
+	char *tokptr=strtok(options,", \t\n");
+	while (tokptr) {
+		arg_opt=no_argument;
 		tlen=strlen(tokptr);
-                if (tlen > 0) {
-                        if (tokptr[tlen-1] == ':') {
-                                if (tlen > 1 && tokptr[tlen-2] == ':') {
-                                        tokptr[tlen-2]='\0';
+		if (tlen > 0) {
+			if (tokptr[tlen-1] == ':') {
+				if (tlen > 1 && tokptr[tlen-2] == ':') {
+					tokptr[tlen-2]='\0';
 					tlen -= 2;
-                                        arg_opt=optional_argument;
-                                } else {
-                                        tokptr[tlen-1]='\0';
+					arg_opt=optional_argument;
+				} else {
+					tokptr[tlen-1]='\0';
 					tlen -= 1;
-                                        arg_opt=required_argument;
-                                }
-                                if (tlen == 0)
-                                        bb_error_msg("empty long option after -l or --long argument");
-                        }
-                        add_longopt(tokptr,arg_opt);
-                }
-                tokptr=strtok(NULL,", \t\n");
-        }
+					arg_opt=required_argument;
+				}
+				if (tlen == 0)
+					bb_error_msg("empty long option after -l or --long argument");
+			}
+			add_longopt(tokptr,arg_opt);
+		}
+		tokptr=strtok(NULL,", \t\n");
+	}
 }
 
 void set_shell(const char *new_shell)
 {
-        if (!strcmp(new_shell,"bash"))
-                shell=BASH;
-        else if (!strcmp(new_shell,"tcsh"))
-                shell=TCSH;
-        else if (!strcmp(new_shell,"sh"))
-                shell=BASH;
-        else if (!strcmp(new_shell,"csh"))
-                shell=TCSH;
-        else
-                bb_error_msg("unknown shell after -s or --shell argument");
+	if (!strcmp(new_shell,"bash"))
+		shell=BASH;
+	else if (!strcmp(new_shell,"tcsh"))
+		shell=TCSH;
+	else if (!strcmp(new_shell,"sh"))
+		shell=BASH;
+	else if (!strcmp(new_shell,"csh"))
+		shell=TCSH;
+	else
+		bb_error_msg("unknown shell after -s or --shell argument");
 }
 
 
@@ -287,16 +287,16 @@ void set_shell(const char *new_shell)
 
 static const struct option longopts[]=
 {
-        {"options",required_argument,NULL,'o'},
-        {"longoptions",required_argument,NULL,'l'},
-        {"quiet",no_argument,NULL,'q'},
-        {"quiet-output",no_argument,NULL,'Q'},
-        {"shell",required_argument,NULL,'s'},
-        {"test",no_argument,NULL,'T'},
-        {"unquoted",no_argument,NULL,'u'},
-        {"alternative",no_argument,NULL,'a'},
-        {"name",required_argument,NULL,'n'},
-        {NULL,0,NULL,0}
+	{"options",required_argument,NULL,'o'},
+	{"longoptions",required_argument,NULL,'l'},
+	{"quiet",no_argument,NULL,'q'},
+	{"quiet-output",no_argument,NULL,'Q'},
+	{"shell",required_argument,NULL,'s'},
+	{"test",no_argument,NULL,'T'},
+	{"unquoted",no_argument,NULL,'u'},
+	{"alternative",no_argument,NULL,'a'},
+	{"name",required_argument,NULL,'n'},
+	{NULL,0,NULL,0}
 };
 
 /* Stop scanning as soon as a non-option argument is found! */
@@ -305,77 +305,77 @@ static const char shortopts[]="+ao:l:n:qQs:Tu";
 
 int getopt_main(int argc, char *argv[])
 {
-        const char *optstr = NULL;
-        char *name = NULL;
-        int opt;
-        int compatible=0;
-
-        init_longopt();
-
-        if (getenv("GETOPT_COMPATIBLE"))
-                compatible=1;
-
-        if (argc == 1) {
-                if (compatible) {
-                        /* For some reason, the original getopt gave no error
-                           when there were no arguments. */
-                        printf(" --\n");
-                       return 0;
-                } else
-                        bb_error_msg_and_die("missing optstring argument");
-        }
-
-        if (argv[1][0] != '-' || compatible) {
+	const char *optstr = NULL;
+	char *name = NULL;
+	int opt;
+	int compatible=0;
+
+	init_longopt();
+
+	if (getenv("GETOPT_COMPATIBLE"))
+		compatible=1;
+
+	if (argc == 1) {
+		if (compatible) {
+			/* For some reason, the original getopt gave no error
+			   when there were no arguments. */
+			printf(" --\n");
+		       return 0;
+		} else
+			bb_error_msg_and_die("missing optstring argument");
+	}
+
+	if (argv[1][0] != '-' || compatible) {
 		char *s;
-		
-                quote=0;
-                s=xmalloc(strlen(argv[1])+1);
-                strcpy(s,argv[1]+strspn(argv[1],"-+"));
-                argv[1]=argv[0];
-               return (generate_output(argv+1,argc-1,s,long_options));
-        }
-
-        while ((opt=getopt_long(argc,argv,shortopts,longopts,NULL)) != EOF)
-                switch (opt) {
-                case 'a':
-                        alternative=1;
-                        break;
-                case 'o':
-                       optstr = optarg;
-                        break;
-                case 'l':
-                        add_long_options(optarg);
-                        break;
-                case 'n':
-                       name = optarg;
-                        break;
-                case 'q':
-                        quiet_errors=1;
-                        break;
-                case 'Q':
-                        quiet_output=1;
-                        break;
-                case 's':
-                        set_shell(optarg);
-                        break;
-                case 'T':
-                       return 4;
-                case 'u':
-                        quote=0;
-                        break;
-                default:
-                        bb_show_usage();
-                }
-
-        if (!optstr) {
-                if (optind >= argc)
-                        bb_error_msg_and_die("missing optstring argument");
-                else optstr=argv[optind++];
-        }
-        if (name)
-                argv[optind-1]=name;
-        else
-                argv[optind-1]=argv[0];
+
+		quote=0;
+		s=xmalloc(strlen(argv[1])+1);
+		strcpy(s,argv[1]+strspn(argv[1],"-+"));
+		argv[1]=argv[0];
+	       return (generate_output(argv+1,argc-1,s,long_options));
+	}
+
+	while ((opt=getopt_long(argc,argv,shortopts,longopts,NULL)) != EOF)
+		switch (opt) {
+		case 'a':
+			alternative=1;
+			break;
+		case 'o':
+		       optstr = optarg;
+			break;
+		case 'l':
+			add_long_options(optarg);
+			break;
+		case 'n':
+		       name = optarg;
+			break;
+		case 'q':
+			quiet_errors=1;
+			break;
+		case 'Q':
+			quiet_output=1;
+			break;
+		case 's':
+			set_shell(optarg);
+			break;
+		case 'T':
+		       return 4;
+		case 'u':
+			quote=0;
+			break;
+		default:
+			bb_show_usage();
+		}
+
+	if (!optstr) {
+		if (optind >= argc)
+			bb_error_msg_and_die("missing optstring argument");
+		else optstr=argv[optind++];
+	}
+	if (name)
+		argv[optind-1]=name;
+	else
+		argv[optind-1]=argv[0];
        return (generate_output(argv+optind-1,argc-optind+1,optstr,long_options));
 }
 
diff --git a/util-linux/hwclock.c b/util-linux/hwclock.c
index 5b990df0c..00abe10a6 100644
--- a/util-linux/hwclock.c
+++ b/util-linux/hwclock.c
@@ -67,7 +67,7 @@ static time_t read_rtc(int utc)
 		if (( rtc = open ( "/dev/misc/rtc", O_RDONLY )) < 0 )
 			bb_perror_msg_and_die ( "Could not access RTC" );
 	}
- 	memset ( &tm, 0, sizeof( struct tm ));
+	memset ( &tm, 0, sizeof( struct tm ));
 	if ( ioctl ( rtc, RTC_RD_TIME, &tm ) < 0 )
 		bb_perror_msg_and_die ( "Could not read time from RTC" );
 	tm. tm_isdst = -1; // not known
@@ -187,10 +187,10 @@ static int check_utc(void)
 }
 
 #define HWCLOCK_OPT_LOCALTIME	0x01
-#define HWCLOCK_OPT_UTC      	0x02
-#define HWCLOCK_OPT_SHOW     	0x04
-#define HWCLOCK_OPT_HCTOSYS  	0x08
-#define HWCLOCK_OPT_SYSTOHC  	0x10
+#define HWCLOCK_OPT_UTC			0x02
+#define HWCLOCK_OPT_SHOW		0x04
+#define HWCLOCK_OPT_HCTOSYS		0x08
+#define HWCLOCK_OPT_SYSTOHC		0x10
 
 extern int hwclock_main ( int argc, char **argv )
 {
diff --git a/util-linux/ipcrm.c b/util-linux/ipcrm.c
index 9e18752a3..f4abf6839 100644
--- a/util-linux/ipcrm.c
+++ b/util-linux/ipcrm.c
@@ -94,7 +94,7 @@ remove_ids(type_id type, int argc, char **argv) {
 			case MSG:
 				ret = msgctl (id, IPC_RMID, NULL);
 				break;
-				
+
 			case SHM:
 				ret = shmctl (id, IPC_RMID, NULL);
 				break;
@@ -109,7 +109,7 @@ remove_ids(type_id type, int argc, char **argv) {
 		argc--;
 		argv++;
 	}
-	
+
 	return(nb_errors);
 }
 
@@ -119,7 +119,7 @@ static int deprecated_main(int argc, char **argv)
 		bb_show_usage();
 		bb_fflush_stdout_and_exit(1);
 	}
-	
+
 	if (!strcmp(argv[1], "shm")) {
 		if (remove_ids(SHM, argc-2, &argv[2]))
 			bb_fflush_stdout_and_exit(1);
@@ -127,7 +127,7 @@ static int deprecated_main(int argc, char **argv)
 	else if (!strcmp(argv[1], "msg")) {
 		if (remove_ids(MSG, argc-2, &argv[2]))
 			bb_fflush_stdout_and_exit(1);
-	} 
+	}
 	else if (!strcmp(argv[1], "sem")) {
 		if (remove_ids(SEM, argc-2, &argv[2]))
 			bb_fflush_stdout_and_exit(1);
@@ -228,7 +228,7 @@ int ipcrm_main(int argc, char **argv)
 		}
 
 		result = ((c == 'q') ? msgctl(id, IPC_RMID, NULL) :
-			  (c == 'm') ? shmctl(id, IPC_RMID, NULL) : 
+			  (c == 'm') ? shmctl(id, IPC_RMID, NULL) :
 			  semctl(id, 0, IPC_RMID, arg));
 
 		if (result < 0) {
diff --git a/util-linux/ipcs.c b/util-linux/ipcs.c
index ea5e412ea..f1463a8e3 100644
--- a/util-linux/ipcs.c
+++ b/util-linux/ipcs.c
@@ -29,12 +29,12 @@
  * 19:30:41 1996 by janl@math.uio.no to add code missing in case PID:
  * clauses.
  *
- * Patches from Mike Jagdis (jaggy@purplet.demon.co.uk) applied 
- * Wed Feb 8 12:12:21 1995 by faith@cs.unc.edu to print numeric uids 
+ * Patches from Mike Jagdis (jaggy@purplet.demon.co.uk) applied
+ * Wed Feb 8 12:12:21 1995 by faith@cs.unc.edu to print numeric uids
  * if no passwd file entry.
  *
  * Modified Sat Oct  9 10:55:28 1993 for 0.99.13
- * Original author unknown, may be "krishna balasub@cis.ohio-state.edu" 
+ * Original author unknown, may be "krishna balasub@cis.ohio-state.edu"
  *
  */
 
@@ -136,7 +136,7 @@ static void print_msg (int id);
 static void print_sem (int id);
 
 int ipcs_main (int argc, char **argv) {
-	int opt, msg = 0, sem = 0, shm = 0, id=0, print=0; 
+	int opt, msg = 0, sem = 0, shm = 0, id=0, print=0;
 	char format = 0;
 	char options[] = "atclupsmqi:ih?";
 
@@ -173,7 +173,7 @@ int ipcs_main (int argc, char **argv) {
 		case 'u':
 			format = STATUS;
 			break;
-		case 'h': 
+		case 'h':
 		case '?':
 			bb_show_usage();
 			bb_fflush_stdout_and_exit (0);
@@ -181,11 +181,11 @@ int ipcs_main (int argc, char **argv) {
 	}
 
 	if  (print) {
-		if (shm) { 
+		if (shm) {
 			print_shm (id);
 			bb_fflush_stdout_and_exit (0);
 		}
-		if (sem) { 
+		if (sem) {
 			print_sem (id);
 			bb_fflush_stdout_and_exit (0);
 		}
@@ -201,15 +201,15 @@ int ipcs_main (int argc, char **argv) {
 		msg = sem = shm = 1;
 	bb_printf ("\n");
 
-	if (shm) {	
+	if (shm) {
 		do_shm (format);
 		bb_printf ("\n");
 	}
-	if (sem) {	
+	if (sem) {
 		do_sem (format);
 		bb_printf ("\n");
 	}
-	if (msg) {	
+	if (msg) {
 		do_msg (format);
 		bb_printf ("\n");
 	}
@@ -258,7 +258,7 @@ void do_shm (char format)
 		bb_printf ("kernel not configured for shared memory\n");
 		return;
 	}
-	
+
 	switch (format) {
 	case LIMITS:
 		bb_printf ("------ Shared Memory Limits --------\n");
@@ -282,7 +282,7 @@ void do_shm (char format)
 		bb_printf ("pages allocated %ld\n", shm_info.shm_tot);
 		bb_printf ("pages resident  %ld\n", shm_info.shm_rss);
 		bb_printf ("pages swapped   %ld\n", shm_info.shm_swp);
-		bb_printf ("Swap performance: %ld attempts\t %ld successes\n", 
+		bb_printf ("Swap performance: %ld attempts\t %ld successes\n",
 			shm_info.swap_attempts, shm_info.swap_successes);
 		return;
 
@@ -313,7 +313,7 @@ void do_shm (char format)
 
 	for (id = 0; id <= maxid; id++) {
 		shmid = shmctl (id, SHM_STAT, &shmseg);
-		if (shmid < 0) 
+		if (shmid < 0)
 			continue;
 		if (format == CREATOR)  {
 			print_perms (shmid, ipcp);
@@ -321,7 +321,7 @@ void do_shm (char format)
 		}
 		pw = getpwuid(ipcp->uid);
 		switch (format) {
-		case TIME: 
+		case TIME:
 			if (pw)
 				bb_printf ("%-10d %-10.10s", shmid, pw->pw_name);
 			else
@@ -342,14 +342,14 @@ void do_shm (char format)
 			bb_printf (" %-10d %-10d\n",
 				shmseg.shm_cpid, shmseg.shm_lpid);
 			break;
-			
+
 		default:
 				bb_printf("0x%08x ",ipcp->KEY );
 			if (pw)
 				bb_printf ("%-10d %-10.10s", shmid, pw->pw_name);
 			else
 				bb_printf ("%-10d %-10d", shmid, ipcp->uid);
-			bb_printf ("%-10o %-10lu %-10ld %-6s %-6s\n", 
+			bb_printf ("%-10o %-10lu %-10ld %-6s %-6s\n",
 				ipcp->mode & 0777,
 				/*
 				 * earlier: int, Austin has size_t
@@ -384,7 +384,7 @@ void do_sem (char format)
 		bb_printf ("kernel not configured for semaphores\n");
 		return;
 	}
-	
+
 	switch (format) {
 	case LIMITS:
 		bb_printf ("------ Semaphore Limits --------\n");
@@ -421,7 +421,7 @@ void do_sem (char format)
 
 	default:
 		bb_printf ("------ Semaphore Arrays --------\n");
-		bb_printf ("%-10s %-10s %-10s %-10s %-10s\n", 
+		bb_printf ("%-10s %-10s %-10s %-10s %-10s\n",
 			"key","semid","owner","perms","nsems");
 		break;
 	}
@@ -437,7 +437,7 @@ void do_sem (char format)
 		}
 		pw = getpwuid(ipcp->uid);
 		switch (format) {
-		case TIME: 
+		case TIME:
 			if (pw)
 				bb_printf ("%-8d %-10.10s", semid, pw->pw_name);
 			else
@@ -449,7 +449,7 @@ void do_sem (char format)
 			break;
 		case PID:
 			break;
-			
+
 		default:
 				bb_printf("0x%08x ", ipcp->KEY);
 			if (pw)
@@ -484,7 +484,7 @@ void do_msg (char format)
 		bb_printf ("kernel not configured for message queues\n");
 		return;
 	}
-	
+
 	switch (format) {
 	case LIMITS:
 		if ((msgctl (0, IPC_INFO, (struct msqid_ds *) (void *) &msginfo)) < 0 )
@@ -662,7 +662,7 @@ void print_sem (int semid)
 	bb_printf ("nsems = %ld\n", (long) semds.sem_nsems);
 	bb_printf ("otime = %-26.24s\n",
 		semds.sem_otime ? ctime (&semds.sem_otime) : "Not set");
-	bb_printf ("ctime = %-26.24s\n", ctime (&semds.sem_ctime));	
+	bb_printf ("ctime = %-26.24s\n", ctime (&semds.sem_ctime));
 
 	bb_printf ("%-10s %-10s %-10s %-10s %-10s\n",
 		"semnum","value","ncount","zcount","pid");
diff --git a/util-linux/losetup.c b/util-linux/losetup.c
index f03889663..c2d3339e0 100644
--- a/util-linux/losetup.c
+++ b/util-linux/losetup.c
@@ -31,16 +31,16 @@ die_failed:
     case -1:
       /* losetup takes two argument:, loop_device and file */
       if(optind+2==argc) {
-        if(set_loop(&argv[optind], argv[optind + 1], offset)>=0)
-          return EXIT_SUCCESS;
-        else goto die_failed;
+	if(set_loop(&argv[optind], argv[optind + 1], offset)>=0)
+	  return EXIT_SUCCESS;
+	else goto die_failed;
       }
       if(optind+1==argc) {
-        char *s=query_loop(argv[optind]);
-        if (!s) goto die_failed;
-        printf("%s: %s\n",argv[optind],s);
-        if(ENABLE_FEATURE_CLEAN_UP) free(s);
-        return EXIT_SUCCESS;
+	char *s=query_loop(argv[optind]);
+	if (!s) goto die_failed;
+	printf("%s: %s\n",argv[optind],s);
+	if(ENABLE_FEATURE_CLEAN_UP) free(s);
+	return EXIT_SUCCESS;
       }
       break;
   }
diff --git a/util-linux/mdev.c b/util-linux/mdev.c
index a18e44835..b8c0090fa 100644
--- a/util-linux/mdev.c
+++ b/util-linux/mdev.c
@@ -1,7 +1,7 @@
 /* vi:set ts=4:
- * 
+ *
  * mdev - Mini udev for busybox
- * 
+ *
  * Copyright 2005 Rob Landley <rob@landley.net>
  * Copyright 2005 Frank Sorenson <frank@tuxrocks.com>
  *
@@ -38,21 +38,21 @@ static void make_device(char *path)
 	RESERVE_CONFIG_BUFFER(temp,PATH_MAX);
 
 	/* Try to read major/minor string */
-	
+
 	snprintf(temp, PATH_MAX, "%s/dev", path);
 	fd = open(temp, O_RDONLY);
 	len = read(fd, temp, PATH_MAX-1);
 	if (len<1) goto end;
 	close(fd);
-	
+
 	/* Determine device name, type, major and minor */
-	
+
 	device_name = strrchr(path, '/') + 1;
 	type = strncmp(path+5, "block/" ,6) ? S_IFCHR : S_IFBLK;
 	if(sscanf(temp, "%d:%d", &major, &minor) != 2) goto end;
 
 	/* If we have a config file, look up permissions for this device */
-	
+
 	if (ENABLE_FEATURE_MDEV_CONF) {
 		char *conf,*pos,*end;
 
@@ -67,7 +67,7 @@ static void make_device(char *path)
 				for (pos=conf;pos-conf<len;) {
 					int field;
 					char *end2;
-					
+
 					line++;
 					/* find end of this line */
 					for(end=pos;end-conf<len && *end!='\n';end++);
@@ -88,11 +88,11 @@ static void make_device(char *path)
 								regmatch_t off;
 								int result;
 
-								/* Is this it? */	
+								/* Is this it? */
 								xregcomp(&match,regex,REG_EXTENDED);
 								result=regexec(&match,device_name,1,&off,0);
 								regfree(&match);
-								
+
 								/* If not this device, skip rest of line */
 								if(result || off.rm_so
 									|| off.rm_eo!=strlen(device_name))
@@ -159,7 +159,7 @@ found_device:
 		bb_perror_msg_and_die("mknod %s failed", temp);
 
 	if (ENABLE_FEATURE_MDEV_CONF) chown(temp,uid,gid);
-	
+
 end:
 	RELEASE_CONFIG_BUFFER(temp);
 }
@@ -177,7 +177,7 @@ static void find_dev(char *path)
 
 	for (;;) {
 		struct dirent *entry = readdir(dir);
-		
+
 		if (!entry) break;
 
 		/* Skip "." and ".." (also skips hidden files, which is ok) */
@@ -189,12 +189,12 @@ static void find_dev(char *path)
 			find_dev(path);
 			path[len] = 0;
 		}
-		
+
 		/* If there's a dev entry, mknod it */
-		
+
 		if (!strcmp(entry->d_name, "dev")) make_device(path);
 	}
-	
+
 	closedir(dir);
 }
 
@@ -205,7 +205,7 @@ int mdev_main(int argc, char *argv[])
 	RESERVE_CONFIG_BUFFER(temp,PATH_MAX);
 
 	/* Scan */
-	
+
 	if (argc == 2 && !strcmp(argv[1],"-s")) {
 		strcpy(temp,"/sys/block");
 		find_dev(temp);
@@ -218,7 +218,7 @@ int mdev_main(int argc, char *argv[])
 		action = getenv("ACTION");
 		env_path = getenv("DEVPATH");
 	    if (!action || !env_path) bb_show_usage();
-		
+
 		if (!strcmp(action, "add")) {
 			sprintf(temp, "/sys%s", env_path);
 			make_device(temp);
diff --git a/util-linux/mount.c b/util-linux/mount.c
index 4777e470b..68542f9bc 100644
--- a/util-linux/mount.c
+++ b/util-linux/mount.c
@@ -32,7 +32,7 @@
 
 /* Consume standard mount options (from -o options or --options).
  * Set appropriate flags and collect unrecognized ones as a comma separated
- * string to pass to kernel */ 
+ * string to pass to kernel */
 
 struct {
 	const char *name;
@@ -104,7 +104,7 @@ extern int mount_main(int argc, char **argv)
 		 *loopFile = 0, *buf = 0,
 		 *files[] = {"/etc/filesystems", "/proc/filesystems", 0};
 	int i, opt, all = FALSE, fakeIt = FALSE, allowWrite = FALSE,
-	   	rc = 1, useMtab = ENABLE_FEATURE_MTAB_SUPPORT;
+		rc = 1, useMtab = ENABLE_FEATURE_MTAB_SUPPORT;
 	int flags=0xc0ed0000;	// Needed for linux 2.2, ignored by 2.4 and 2.6.
 	FILE *file = 0,*f = 0;
 	char path[PATH_MAX*2];
@@ -185,7 +185,7 @@ extern int mount_main(int argc, char **argv)
 	statbuf.st_mode=0;
 	if(optind < argc)
 		blockDevice = !stat(argv[optind], &statbuf) ?
-		  	 	bb_simplify_path(argv[optind]) :
+				bb_simplify_path(argv[optind]) :
 				(ENABLE_FEATURE_CLEAN_UP ? strdup(argv[optind]) : argv[optind]);
 	if(optind+1 < argc) directory = bb_simplify_path(argv[optind+1]);
 
@@ -206,7 +206,7 @@ extern int mount_main(int argc, char **argv)
 				bb_perror_msg("Can't find %s in /etc/fstab\n", blockDevice);
 			break;
 		}
-		
+
 		// If we're mounting all and all doesn't mount this one, skip it.
 
 		if(all) {
@@ -271,7 +271,7 @@ singlemount:
 				goto mount_it_now;
 			}
 		} else {
-			
+
 			// Do we need to allocate a loopback device?
 
 			if(ENABLE_FEATURE_MOUNT_LOOP && !fakeIt && S_ISREG(statbuf.st_mode))
@@ -297,7 +297,7 @@ singlemount:
 			if(fsType || (flags & (MS_REMOUNT | MS_BIND | MS_MOVE)))
 				goto mount_it_now;
 		}
-		
+
 		// Loop through filesystem types until mount succeeds or we run out
 
 		for(i = 0; files[i] && rc; i++) {
@@ -305,11 +305,11 @@ singlemount:
 			if(!f) continue;
 			// Get next block device backed filesystem
 			for(buf = 0; (buf = fsType = bb_get_chomped_line_from_file(f));
-				   	free(buf))
+					free(buf))
 			{
 				// Skip funky entries in /proc
 				if(!strncmp(buf,"nodev",5) && isspace(buf[5])) continue;
-				
+
 				while(isspace(*fsType)) fsType++;
 				if(*buf=='#' || *buf=='*') continue;
 				if(!*fsType) continue;
diff --git a/util-linux/nfsmount.c b/util-linux/nfsmount.c
index 75f341a92..e9d6dc635 100644
--- a/util-linux/nfsmount.c
+++ b/util-linux/nfsmount.c
@@ -151,11 +151,11 @@ static const int MS_NODIRATIME = 2048;    /* Do not update directory access time
 #define NFS_MOUNT_VERSION 4
 
 struct nfs2_fh {
-        char                    data[32];
+	char                    data[32];
 };
 struct nfs3_fh {
-        unsigned short          size;
-        unsigned char           data[64];
+	unsigned short          size;
+	unsigned char           data[64];
 };
 
 struct nfs_mount_data {
@@ -687,7 +687,7 @@ int nfsmount(const char *spec, const char *node, int *flags,
 				       mountprog,
 				       mountvers,
 				       proto,
- 				       mountport);
+				       mountport);
 
 			/* contact the mount daemon via TCP */
 			mount_server_addr.sin_port = htons(pm_mnt->pm_port);
@@ -810,7 +810,7 @@ int nfsmount(const char *spec, const char *node, int *flags,
 
 	if (tcp) {
 		if (nfs_mount_version < 3) {
-	     		printf(_("NFS over TCP is not supported.\n"));
+			printf(_("NFS over TCP is not supported.\n"));
 			goto fail;
 		}
 		fsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
diff --git a/util-linux/pivot_root.c b/util-linux/pivot_root.c
index 85e180c46..c86e73cc1 100644
--- a/util-linux/pivot_root.c
+++ b/util-linux/pivot_root.c
@@ -16,7 +16,7 @@ extern int pivot_root(const char * new_root,const char * put_old);
 int pivot_root_main(int argc, char **argv)
 {
     if (argc != 3)
-        bb_show_usage();
+	bb_show_usage();
 
 	if (pivot_root(argv[1],argv[2]) < 0)
 		bb_perror_msg_and_die("pivot_root");
diff --git a/util-linux/rdate.c b/util-linux/rdate.c
index cabcc7dbe..2b011ebb0 100644
--- a/util-linux/rdate.c
+++ b/util-linux/rdate.c
@@ -55,7 +55,7 @@ static time_t askremotedate(const char *host)
 	 *  the RFC 868 time 2,208,988,800 corresponds to 00:00  1 Jan 1970 GMT
 	 * Subtract the RFC 868 time  to get Linux epoch
 	 */
-	
+
 	return(ntohl(nett) - RFC_868_BIAS);
 }
 
@@ -63,10 +63,10 @@ int rdate_main(int argc, char **argv)
 {
 	time_t remote_time;
 	unsigned long flags;
-	
+
 	bb_opt_complementally = "-1";
 	flags = bb_getopt_ulflags(argc, argv, "sp");
-	
+
 	remote_time = askremotedate(argv[optind]);
 
 	if (flags & 1) {
@@ -78,9 +78,9 @@ int rdate_main(int argc, char **argv)
 		else
 			if (stime(&remote_time) < 0)
 				bb_perror_msg_and_die("Could not set time of day");
-		
+
 	/* No need to check for the -p flag as it's the only option left */
-		
+
 	} else printf("%s", ctime(&remote_time));
 
 	return EXIT_SUCCESS;
diff --git a/util-linux/readprofile.c b/util-linux/readprofile.c
index 80716d9f0..1612d7147 100644
--- a/util-linux/readprofile.c
+++ b/util-linux/readprofile.c
@@ -149,9 +149,9 @@ int readprofile_main(int argc, char **argv)
 	/*
 	 * Use an fd for the profiling buffer, to skip stdio overhead
 	 */
-	 
+
 	proFd = bb_xopen(proFile,O_RDONLY);
-	
+
 	if (((int)(len=lseek(proFd,0,SEEK_END)) < 0)
 	    || (lseek(proFd,0,SEEK_SET) < 0))
 		bb_perror_msg_and_die(proFile);
diff --git a/util-linux/switch_root.c b/util-linux/switch_root.c
index 0c86eec08..bcc4443ab 100644
--- a/util-linux/switch_root.c
+++ b/util-linux/switch_root.c
@@ -47,20 +47,20 @@ static void delete_contents(char *directory)
 				// Skip . and ..
 				if(*newdir=='.' && (!newdir[1] || (newdir[1]=='.' && !newdir[2])))
 					continue;
-				
+
 				// Recurse to delete contents
 				newdir = alloca(strlen(directory) + strlen(d->d_name) + 2);
 				sprintf(newdir, "%s/%s", directory, d->d_name);
 				delete_contents(newdir);
 			}
 			closedir(dir);
-			
+
 			// Directory should now be empty.  Zap it.
 			rmdir(directory);
 		}
-		
+
 	// It wasn't a directory.  Zap it.
-		
+
 	} else unlink(directory);
 }
 
@@ -74,18 +74,18 @@ int switch_root_main(int argc, char *argv[])
 
 	bb_opt_complementally="-2";
 	bb_getopt_ulflags(argc,argv,"c:",&console);
-	
+
 	// Change to new root directory and verify it's a different fs.
 
 	newroot=argv[optind++];
-	
+
 	if (chdir(newroot) || stat(".", &st1) || stat("/", &st2) ||
 		st1.st_dev == st2.st_dev)
 	{
 		bb_error_msg_and_die("bad newroot %s",newroot);
 	}
 	rootdev=st2.st_dev;
-	
+
 	// Additional sanity checks: we're about to rm -rf /,  so be REALLY SURE
 	// we mean it.  (I could make this a CONFIG option, but I would get email
 	// from all the people who WILL eat their filesystemss.)
@@ -100,13 +100,13 @@ int switch_root_main(int argc, char *argv[])
 	// Zap everything out of rootdev
 
 	delete_contents("/");
-	
+
 	// Overmount / with newdir and chroot into it.  The chdir is needed to
 	// recalculate "." and ".." links.
 
 	if (mount(".", "/", NULL, MS_MOVE, NULL) || chroot(".") || chdir("/"))
 		bb_error_msg_and_die("moving root");
-	
+
 	// If a new console specified, redirect stdin/stdout/stderr to that.
 
 	if (console) {