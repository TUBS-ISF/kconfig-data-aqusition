"2006-09-17 16:28:10 +0000"
diff --git a/AUTHORS b/AUTHORS
index 6e49761f0..8f6498b98 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -113,7 +113,7 @@ Manuel Novoa III <mjn3@codepoet.org>
 
 Vladimir Oleynik <dzo@simtreas.ru>
     cmdedit; bb_mkdep, xargs(current), httpd(current);
-    ports: ash, crond, fdisk (initial, unmaintained now), inetd, stty, traceroute, 
+    ports: ash, crond, fdisk (initial, unmaintained now), inetd, stty, traceroute,
     top;
     locale, various fixes
     and irreconcilable critic of everything not perfect.
diff --git a/TODO b/TODO
index 719bdb325..f0e78e1e7 100644
--- a/TODO
+++ b/TODO
@@ -33,7 +33,7 @@ Rob Landley <rob@landley.net>:
   depmod
     busybox lacks a way to update module deps when running from firmware without the
     use of the depmod.pl (perl is to bloated for most embedded setups) and or orig
-    modutils. The orig depmod is rather pointless to have to add to a firmware image 
+    modutils. The orig depmod is rather pointless to have to add to a firmware image
     in when we already have a insmod/rmmod and friends.
   Unify base64 handling.
     There's base64 encoding and decoding going on in:
diff --git a/applets/Makefile.in b/applets/Makefile.in
index a4890c2fb..05580b9b4 100644
--- a/applets/Makefile.in
+++ b/applets/Makefile.in
@@ -21,6 +21,6 @@ libraries-y+=$(APPLETS_DIR)$(APPLETS_AR)
 $(APPLETS_DIR)$(APPLETS_AR): $(APPLET_OBJ)
 	$(do_ar)
 
-$(APPLET_OBJ): $(top_builddir)/.config 
+$(APPLET_OBJ): $(top_builddir)/.config
 $(APPLET_OBJ): $(APPLETS_DIR)%.o: $(srcdir)/%.c
 	$(compile.c)
diff --git a/applets/individual.c b/applets/individual.c
index c6d263b47..bc5f528d7 100644
--- a/applets/individual.c
+++ b/applets/individual.c
@@ -1,7 +1,7 @@
 /* Minimal wrapper to build an individual busybox applet.
  *
  * Copyright 2005 Rob Landley <rob@landley.net
- * 
+ *
  * Licensed under GPLv2 or later, see file License in this tarball for details
  */
 
diff --git a/archival/dpkg.c b/archival/dpkg.c
index 163d91f19..2180d1868 100644
--- a/archival/dpkg.c
+++ b/archival/dpkg.c
@@ -1316,8 +1316,8 @@ static void list_packages(void)
 	/* go through status hash, dereference package hash and finally strings */
 	for (i=0; i<STATUS_HASH_PRIME+1; i++) {
 
-	        if (status_hashtable[i]) {
-		        const char *stat_str;  /* status string */
+		if (status_hashtable[i]) {
+			const char *stat_str;  /* status string */
 			const char *name_str;  /* package name */
 			const char *vers_str;  /* version */
 			char  s1, s2;          /* status abbreviations */
@@ -1333,7 +1333,7 @@ static void list_packages(void)
 
 			/* get abbreviation for status field 2 */
 			for (j=0, spccnt=0; stat_str[j] && spccnt<2; j++) {
-			        if (stat_str[j] == ' ') spccnt++;
+				if (stat_str[j] == ' ') spccnt++;
 			}
 			s2 = stat_str[j];
 
diff --git a/archival/libunarchive/decompress_unzip.c b/archival/libunarchive/decompress_unzip.c
index c0203cc4a..74de9af44 100644
--- a/archival/libunarchive/decompress_unzip.c
+++ b/archival/libunarchive/decompress_unzip.c
@@ -29,7 +29,7 @@
  * Ken Turkowski, Dave Mack and Peter Jannesen.
  *
  * See the file algorithm.doc for the compression algorithms and file formats.
- * 
+ *
  * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
  */
 
@@ -853,7 +853,7 @@ int inflate_unzip(int in, int out)
 	/* Create the crc table */
 	gunzip_crc_table = crc32_filltable(0);
 	gunzip_crc = ~0;
-	
+
 	/* Allocate space for buffer */
 	bytebuffer = xmalloc(bytebuffer_max);
 
diff --git a/console-tools/setlogcons.c b/console-tools/setlogcons.c
index 9d1ef5492..90f24ce9c 100644
--- a/console-tools/setlogcons.c
+++ b/console-tools/setlogcons.c
@@ -1,6 +1,6 @@
 /* vi: set sw=4 ts=4: */
 /*
- * setlogcons: Send kernel messages to the current console or to console N 
+ * setlogcons: Send kernel messages to the current console or to console N
  *
  * Copyright (C) 2006 by Jan Kiszka <jan.kiszka@web.de>
  *
diff --git a/coreutils/Config.in b/coreutils/Config.in
index 07005b81a..20b5955d4 100644
--- a/coreutils/Config.in
+++ b/coreutils/Config.in
@@ -120,11 +120,11 @@ config CONFIG_FEATURE_DD_SIGNAL_HANDLING
 	default y
 	depends on CONFIG_DD
 	help
-	  sending a SIGUSR1 signal to a running `dd' process makes it 
-	  print to standard error the number of records read and written 
+	  sending a SIGUSR1 signal to a running `dd' process makes it
+	  print to standard error the number of records read and written
 	  so far, then to resume copying.
 
-	  $ dd if=/dev/zero of=/dev/null& pid=$! $ kill -USR1 $pid; sleep 1; kill $pid 
+	  $ dd if=/dev/zero of=/dev/null& pid=$! $ kill -USR1 $pid; sleep 1; kill $pid
 	  10899206+0 records in 10899206+0 records out
 
 config CONFIG_FEATURE_DD_IBS_OBS
@@ -744,9 +744,9 @@ config CONFIG_FEATURE_AUTOWIDTH
 	depends on CONFIG_LS || CONFIG_MORE || CONFIG_TELNET
 	help
 	  This option allows utilities such as 'ls', 'more' and 'telnet'
-	  to determine the width of the screen, which can allow them to 
+	  to determine the width of the screen, which can allow them to
 	  display additional text or avoid wrapping text onto the next line.
-	  If you leave this disabled, your utilities will be especially 
+	  If you leave this disabled, your utilities will be especially
 	  primitive and will be unable to determine the current screen width.
 
 comment "Common options for df, du, ls"
diff --git a/coreutils/cal.c b/coreutils/cal.c
index 9628459fe..8996aa8c7 100644
--- a/coreutils/cal.c
+++ b/coreutils/cal.c
@@ -33,7 +33,7 @@ static const char days_in_month[] = {
 };
 
 static const char sep1752[] = {
-	         1,	2,	14,	15,	16,
+		 1,	2,	14,	15,	16,
 	17,	18,	19,	20,	21,	22,	23,
 	24,	25,	26,	27,	28,	29,	30
 };
@@ -207,7 +207,7 @@ static void day_array(int month, int year, int *days)
 
 	if ((month == 9) && (year == 1752)) {
 		size_t oday = 0;
-		
+
 		j_offset = julian * 244;
 		do {
 			days[oday+2] = sep1752[oday] + j_offset;
diff --git a/coreutils/cksum.c b/coreutils/cksum.c
index 9a45fd656..9bec3bff4 100644
--- a/coreutils/cksum.c
+++ b/coreutils/cksum.c
@@ -10,7 +10,7 @@
 
 int cksum_main(int argc, char **argv)
 {
-	
+
 	uint32_t *crc32_table = crc32_filltable(1);
 
 	FILE *fp;
diff --git a/coreutils/cp.c b/coreutils/cp.c
index f5baa0d62..85086aab5 100644
--- a/coreutils/cp.c
+++ b/coreutils/cp.c
@@ -77,7 +77,7 @@ int cp_main(int argc, char **argv)
 	/* If there are only two arguments and...  */
 	if (optind + 2 == argc) {
 		s_flags = cp_mv_stat2(*argv, &source_stat,
-		                      (flags & FILEUTILS_DEREFERENCE) ? stat : lstat);
+				      (flags & FILEUTILS_DEREFERENCE) ? stat : lstat);
 		if ((s_flags < 0) || ((d_flags = cp_mv_stat(last, &dest_stat)) < 0)) {
 			exit(EXIT_FAILURE);
 		}
diff --git a/coreutils/dd.c b/coreutils/dd.c
index a9536a584..8d859ef5c 100644
--- a/coreutils/dd.c
+++ b/coreutils/dd.c
@@ -200,7 +200,7 @@ int dd_main(int argc, char **argv)
 				out_part++;
 		}
 	}
-	
+
 	if (ENABLE_FEATURE_DD_IBS_OBS && oc) {
 		xwrite(ofd, obuf, oc);
 		out_part++;
diff --git a/coreutils/diff.c b/coreutils/diff.c
index 22c157412..3c409b2cf 100644
--- a/coreutils/diff.c
+++ b/coreutils/diff.c
@@ -820,8 +820,8 @@ static void output(char *file1, FILE * f1, char *file2, FILE * f2)
 }
 
 /*
- *      The following code uses an algorithm due to Harold Stone, 
- *      which finds a pair of longest identical subsequences in 
+ *      The following code uses an algorithm due to Harold Stone,
+ *      which finds a pair of longest identical subsequences in
  *      the two files.
  *
  *      The major goal is to generate the match vector J.
diff --git a/coreutils/head.c b/coreutils/head.c
index e961ca6b6..8dc6ee0b4 100644
--- a/coreutils/head.c
+++ b/coreutils/head.c
@@ -28,7 +28,7 @@ static const struct suffix_mult head_suffixes[] = {
 	{ NULL, 0 }
 };
 #endif
-                                        
+
 static const char header_fmt_str[] = "\n==> %s <==\n";
 
 int head_main(int argc, char **argv)
@@ -83,8 +83,8 @@ int head_main(int argc, char **argv)
 #if !ENABLE_FEATURE_FANCY_HEAD
 				count = bb_xgetularg10(p);
 #else
-				count = bb_xgetularg_bnd_sfx(p, 10, 
-								0, ULONG_MAX, 
+				count = bb_xgetularg_bnd_sfx(p, 10,
+								0, ULONG_MAX,
 								head_suffixes);
 #endif
 				break;
diff --git a/coreutils/ls.c b/coreutils/ls.c
index 828127a4a..0099f18fe 100644
--- a/coreutils/ls.c
+++ b/coreutils/ls.c
@@ -196,7 +196,7 @@ static struct dnode *my_stat(char *fullname, char *name)
 #endif
 	{
 #ifdef CONFIG_SELINUX
-	        if  (is_selinux_enabled())  {
+		if  (is_selinux_enabled()) {
 		  lgetfilecon(fullname,&sid);
 		}
 #endif
diff --git a/coreutils/nohup.c b/coreutils/nohup.c
index 5dd90adcc..9e9150d33 100644
--- a/coreutils/nohup.c
+++ b/coreutils/nohup.c
@@ -1,11 +1,11 @@
 /* vi: set sw=4 ts=4: */
 /* nohup - invoke a utility immune to hangups.
- * 
+ *
  * Busybox version based on nohup specification at
  * http://www.opengroup.org/onlinepubs/007904975/utilities/nohup.html
- * 
+ *
  * Copyright 2006 Rob Landley <rob@landley.net>
- * 
+ *
  * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
  */
 
diff --git a/coreutils/seq.c b/coreutils/seq.c
index 0df094001..79fafbc8b 100644
--- a/coreutils/seq.c
+++ b/coreutils/seq.c
@@ -14,7 +14,7 @@
 int seq_main(int argc, char **argv)
 {
 	double last, first, increment, i;
-	
+
 	first = increment = 1;
 	switch (argc) {
 		case 4:
diff --git a/coreutils/sort.c b/coreutils/sort.c
index ea7752d2a..d86f8dcde 100644
--- a/coreutils/sort.c
+++ b/coreutils/sort.c
@@ -5,7 +5,7 @@
  * Copyright (C) 2004 by Rob Landley <rob@landley.net>
  *
  * MAINTAINER: Rob Landley <rob@landley.net>
- * 
+ *
  * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
  *
  * See SuS3 sort standard at:
diff --git a/coreutils/who.c b/coreutils/who.c
index 95ad21953..7566bfddc 100644
--- a/coreutils/who.c
+++ b/coreutils/who.c
@@ -24,7 +24,7 @@
 static const char * idle_string (time_t t)
 {
 	static char str[6];
-	
+
 	time_t s = time(NULL) - t;
 
 	if (s < 60)
@@ -43,11 +43,11 @@ int who_main(int argc, char **argv)
 	struct utmp *ut;
 	struct stat st;
 	char *name;
-	
+
 	if (argc > 1) {
 		bb_show_usage();
 	}
-	
+
 	setutent();
 	printf("USER       TTY      IDLE      TIME           HOST\n");
 	while ((ut = getutent()) != NULL) {
diff --git a/debianutils/start_stop_daemon.c b/debianutils/start_stop_daemon.c
index e0c8f2d9b..dcff1dd86 100644
--- a/debianutils/start_stop_daemon.c
+++ b/debianutils/start_stop_daemon.c
@@ -45,7 +45,7 @@ static int pid_is_exec(pid_t pid, const char *name)
 	sprintf(buf, "/proc/%d/exe", pid);
 	execbuf = xstrdup(name);
 	readlink(buf, execbuf, strlen(name)+1);
-	
+
 	equal = ! strcmp(execbuf, name);
 	if (ENABLE_FEATURE_CLEAN_UP)
 		free(execbuf);
diff --git a/docs/busybox.net/news.html b/docs/busybox.net/news.html
index 43af60bce..5def5a35c 100644
--- a/docs/busybox.net/news.html
+++ b/docs/busybox.net/news.html
@@ -62,7 +62,7 @@
     will be released before then if more bug fixes crop up.  (The new plan is
     to have a 1.x.0 new development release every 3 months, with 1.x.y stable
     bugfix only releases based on that as appropriate.)</p>
-    
+
   <li><b>27 March 2006 -- Software Freedom Law Center representing BusyBox and uClibc</b>
     <p>One issue Erik Andersen wanted to resolve when handing off BusyBox
     maintainership to Rob Landley was license enforcement.  BusyBox and
diff --git a/docs/busybox.net/oldnews.html b/docs/busybox.net/oldnews.html
index 3ab629e79..1017b6975 100644
--- a/docs/busybox.net/oldnews.html
+++ b/docs/busybox.net/oldnews.html
@@ -4,7 +4,7 @@
 <ul>
   <li><b>31 October 2005 -- 1.1.0-pre1</b>
     <p>The development branch of busybox is stable enough for wider testing, so
-    you can now 
+    you can now
     <a href="http://www.busybox.net/downloads/busybox-1.1.0-pre1.tar.bz2">download</a>,
     the first prerelease of 1.1.0.  This prerelease includes a lot of
     <a href="http://www.busybox.net/downloads/BusyBox.html">new
@@ -27,7 +27,7 @@
     developers of BusyBox are busy people, and have only so much they can keep
     in their brains at a time. In my case, I'm lucky if I can remember my own
     name, much less a bug report posted last week... To prevent your bug report
-    from getting lost, if you find a bug in BusyBox, please use the 
+    from getting lost, if you find a bug in BusyBox, please use the
     <a href="http://bugs.busybox.net/">shiny new Bug and Patch Tracking System</a>
     to post all the gory details.
 
@@ -856,7 +856,7 @@ image</a>. Here's how you use it:
 
 <pre>
     mount ./busybox.floppy.img /mnt -o loop -t msdos
-    cp /mnt/initrd.gz /tmp      
+    cp /mnt/initrd.gz /tmp
     umount /mnt
     gunzip /tmp/initrd.gz
     mount /tmp/initrd /mnt -o loop -t minix
diff --git a/docs/busybox.net/products.html b/docs/busybox.net/products.html
index 75ff6b929..daf8add20 100644
--- a/docs/busybox.net/products.html
+++ b/docs/busybox.net/products.html
@@ -159,7 +159,7 @@ Hat Linux</a>
     with source <a href="http://now-portal.c-lab.de/projects/gigaset/">here, I think...</a>
     with some details <a href="http://heinz.hippenstiel.org/familie/hp/hobby/gigaset_se515dsl.html">here.</a>
 </li><li><a href="http://frwt.stim.ru/">Free Remote Windows Terminal</a>
-    
+
 </li><li><a href="http://www.zyxel.com/">ZyXEL Routers</a>
 
 </li>
diff --git a/docs/busybox.net/shame.html b/docs/busybox.net/shame.html
index 3f3edafb1..d9da44b69 100644
--- a/docs/busybox.net/shame.html
+++ b/docs/busybox.net/shame.html
@@ -71,7 +71,7 @@ the busybox license by releasing the source code with your product.
   </li><li><a href="http://www.recospa.it/mdpro1/index.php">United *DVX4066 mpeg4 capable DVD players</a>
   </li><li><a href="http://www.a-link.com/RR64AP.html">Avaks alink Roadrunner 64</a>
   <br> Partial source available, based on source distributed under NDA from <a href="http://www.lsilogic.com/products/dsl_platform_solutions/hb_linuxr2_2.html"> LSILogic</a>. Why the NDA LSILogic, what are you hiding ?
-  <br>To verify the Avaks infrigment see my slashdot <a href="http://slashdot.org/~bug1/journal/">journal</a>. 
+  <br>To verify the Avaks infrigment see my slashdot <a href="http://slashdot.org/~bug1/journal/">journal</a>.
   <br>The ZipIt wireless IM device appears to be using Busybox-1.00-pre1 in the ramdisk, however no source has been made available.
   </li><li>Undoubtedly there are others...  Please report them so we can shame them (or if necessary sue them) into compliance.
 
diff --git a/docs/busybox.net/tinyutils.html b/docs/busybox.net/tinyutils.html
index 47e032197..9122d6e35 100644
--- a/docs/busybox.net/tinyutils.html
+++ b/docs/busybox.net/tinyutils.html
@@ -3,8 +3,8 @@
 
 <h3>External Tiny Utilities</h3>
 
-This is a list of tiny utilities whose functionality is not provided by 
-busybox.  If you have additional suggestions, please send an e-mail to our 
+This is a list of tiny utilities whose functionality is not provided by
+busybox.  If you have additional suggestions, please send an e-mail to our
 dev mailing list.
 
 <br><br>
diff --git a/e2fsprogs/blkid/blkid.h b/e2fsprogs/blkid/blkid.h
index 54721b221..4fa9f6fdf 100644
--- a/e2fsprogs/blkid/blkid.h
+++ b/e2fsprogs/blkid/blkid.h
@@ -56,7 +56,7 @@ extern int blkid_get_cache(blkid_cache *cache, const char *filename);
 extern const char *blkid_dev_devname(blkid_dev dev);
 
 extern blkid_dev_iterate blkid_dev_iterate_begin(blkid_cache cache);
-extern int blkid_dev_set_search(blkid_dev_iterate iter, 
+extern int blkid_dev_set_search(blkid_dev_iterate iter,
 				char *search_type, char *search_value);
 extern int blkid_dev_next(blkid_dev_iterate iterate, blkid_dev *dev);
 extern void blkid_dev_iterate_end(blkid_dev_iterate iterate);
@@ -90,7 +90,7 @@ extern blkid_tag_iterate blkid_tag_iterate_begin(blkid_dev dev);
 extern int blkid_tag_next(blkid_tag_iterate iterate,
 			      const char **type, const char **value);
 extern void blkid_tag_iterate_end(blkid_tag_iterate iterate);
-extern int blkid_dev_has_tag(blkid_dev dev, const char *type, 
+extern int blkid_dev_has_tag(blkid_dev dev, const char *type,
 			      const char *value);
 extern blkid_dev blkid_find_dev_with_tag(blkid_cache cache,
 					 const char *type,
diff --git a/e2fsprogs/blkid/dev.c b/e2fsprogs/blkid/dev.c
index 6d99504af..c2b756c81 100644
--- a/e2fsprogs/blkid/dev.c
+++ b/e2fsprogs/blkid/dev.c
@@ -76,8 +76,8 @@ void blkid_debug_dump_dev(blkid_dev dev)
 
 	list_for_each(p, &dev->bid_tags) {
 		blkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);
-		if (tag)   
-			printf("    tag: %s=\"%s\"\n", tag->bit_name, 
+		if (tag)
+			printf("    tag: %s=\"%s\"\n", tag->bit_name,
 			       tag->bit_val);
 		else
 			printf("    tag: NULL\n");
@@ -177,7 +177,7 @@ int main(int argc, char **argv)
 		case 'm':
 			blkid_debug_mask = strtoul (optarg, &tmp, 0);
 			if (*tmp) {
-				fprintf(stderr, "Invalid debug mask: %d\n", 
+				fprintf(stderr, "Invalid debug mask: %d\n",
 					optarg);
 				exit(1);
 			}
diff --git a/e2fsprogs/blkid/probe.c b/e2fsprogs/blkid/probe.c
index 211569779..a2165efee 100644
--- a/e2fsprogs/blkid/probe.c
+++ b/e2fsprogs/blkid/probe.c
@@ -99,7 +99,7 @@ static void get_ext2_info(blkid_dev dev, unsigned char *buf)
 static int probe_ext3(int fd __BLKID_ATTR((unused)),
 		      blkid_cache cache __BLKID_ATTR((unused)),
 		      blkid_dev dev,
-		      const struct blkid_magic *id __BLKID_ATTR((unused)), 
+		      const struct blkid_magic *id __BLKID_ATTR((unused)),
 		      unsigned char *buf)
 {
 	struct ext2_super_block *es;
@@ -126,7 +126,7 @@ static int probe_ext3(int fd __BLKID_ATTR((unused)),
 static int probe_ext2(int fd __BLKID_ATTR((unused)),
 		      blkid_cache cache __BLKID_ATTR((unused)),
 		      blkid_dev dev,
-		      const struct blkid_magic *id __BLKID_ATTR((unused)), 
+		      const struct blkid_magic *id __BLKID_ATTR((unused)),
 		      unsigned char *buf)
 {
 	struct ext2_super_block *es;
@@ -305,10 +305,10 @@ static int probe_romfs(int fd __BLKID_ATTR((unused)),
 	return 0;
 }
 
-static int probe_cramfs(int fd __BLKID_ATTR((unused)), 
-		       blkid_cache cache __BLKID_ATTR((unused)), 
+static int probe_cramfs(int fd __BLKID_ATTR((unused)),
+		       blkid_cache cache __BLKID_ATTR((unused)),
 		       blkid_dev dev,
-		       const struct blkid_magic *id __BLKID_ATTR((unused)), 
+		       const struct blkid_magic *id __BLKID_ATTR((unused)),
 		       unsigned char *buf)
 {
 	struct cramfs_super_block *csb;
diff --git a/e2fsprogs/blkid/read.c b/e2fsprogs/blkid/read.c
index e954c6d94..624c907f3 100644
--- a/e2fsprogs/blkid/read.c
+++ b/e2fsprogs/blkid/read.c
@@ -432,7 +432,7 @@ static void debug_dump_dev(blkid_dev dev)
 	list_for_each(p, &dev->bid_tags) {
 		blkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);
 		if (tag)
-			printf("    tag: %s=\"%s\"\n", tag->bit_name, 
+			printf("    tag: %s=\"%s\"\n", tag->bit_name,
 			       tag->bit_val);
 		else
 			printf("    tag: NULL\n");
diff --git a/e2fsprogs/blkid/tag.c b/e2fsprogs/blkid/tag.c
index ff10b28e2..09712bab7 100644
--- a/e2fsprogs/blkid/tag.c
+++ b/e2fsprogs/blkid/tag.c
@@ -355,7 +355,7 @@ extern int optind;
 void usage(char *prog)
 {
 	fprintf(stderr, "Usage: %s [-f blkid_file] [-m debug_mask] device "
-		"[type value]\n", 
+		"[type value]\n",
 		prog);
 	fprintf(stderr, "\tList all tags for a device and exit\n", prog);
 	exit(1);
@@ -383,7 +383,7 @@ int main(int argc, char **argv)
 		case 'm':
 			blkid_debug_mask = strtoul (optarg, &tmp, 0);
 			if (*tmp) {
-				fprintf(stderr, "Invalid debug mask: %d\n", 
+				fprintf(stderr, "Invalid debug mask: %d\n",
 					optarg);
 				exit(1);
 			}
@@ -414,7 +414,7 @@ int main(int argc, char **argv)
 	if (search_type) {
 		found = blkid_dev_has_tag(dev, search_type, search_value);
 		printf("Device %s: (%s, %s) %s\n", blkid_dev_devname(dev),
-		       search_type, search_value ? search_value : "NULL", 
+		       search_type, search_value ? search_value : "NULL",
 		       found ? "FOUND" : "NOT FOUND");
 		return(!found);
 	}
diff --git a/e2fsprogs/e2fsck.c b/e2fsprogs/e2fsck.c
index 985f9fd5c..7ffc0d230 100644
--- a/e2fsprogs/e2fsck.c
+++ b/e2fsprogs/e2fsck.c
@@ -3661,7 +3661,7 @@ static void e2fsck_pass1(e2fsck_t ctx)
 		e2fsck_read_inode(ctx, EXT2_RESIZE_INO, inode,
 				  "recreate inode");
 		inode->i_mtime = time(0);
-		e2fsck_write_inode(ctx, EXT2_RESIZE_INO, inode, 
+		e2fsck_write_inode(ctx, EXT2_RESIZE_INO, inode,
 				  "recreate inode");
 		fs->block_map = save_bmap;
 		ctx->flags &= ~E2F_FLAG_RESIZE_INODE;
diff --git a/e2fsprogs/e2p/ls.c b/e2fsprogs/e2p/ls.c
index e2a1ccb3d..9d29db6af 100644
--- a/e2fsprogs/e2p/ls.c
+++ b/e2fsprogs/e2p/ls.c
@@ -26,14 +26,14 @@ static void print_user(unsigned short uid, FILE *f)
 {
 	struct passwd *pw = getpwuid(uid);
 	fprintf(f, "%u (user %s)\n", uid,
-	        (pw == NULL ? "unknown" : pw->pw_name));
+			(pw == NULL ? "unknown" : pw->pw_name));
 }
 
 static void print_group(unsigned short gid, FILE *f)
 {
 	struct group *gr = getgrgid(gid);
 	fprintf(f, "%u (group %s)\n", gid,
-	        (gr == NULL ? "unknown" : gr->gr_name));
+			(gr == NULL ? "unknown" : gr->gr_name));
 }
 
 #define MONTH_INT (86400 * 30)
diff --git a/e2fsprogs/mke2fs.c b/e2fsprogs/mke2fs.c
index 687f18567..72ce57458 100644
--- a/e2fsprogs/mke2fs.c
+++ b/e2fsprogs/mke2fs.c
@@ -737,7 +737,7 @@ static void parse_extended_opts(struct ext2_super_block *sb_param,
 			}
 			if (resize <= sb_param->s_blocks_count) {
 				bb_error_msg("The resize maximum must be greater "
-				             "than the filesystem size");
+						"than the filesystem size");
 				r_usage++;
 				continue;
 			}
diff --git a/e2fsprogs/util.c b/e2fsprogs/util.c
index 113ef9c8f..efb128f59 100644
--- a/e2fsprogs/util.c
+++ b/e2fsprogs/util.c
@@ -99,7 +99,7 @@ force_check:
 			bb_error_msg_and_die("it's not safe to run badblocks!");
 	}
 
-	if (mount_flags & EXT2_MF_BUSY) {  
+	if (mount_flags & EXT2_MF_BUSY) {
 		bb_error_msg("%s is apparently in use by the system", device);
 		goto force_check;
 	}
diff --git a/editors/sed.c b/editors/sed.c
index 9f3af33ed..f8e3720b5 100644
--- a/editors/sed.c
+++ b/editors/sed.c
@@ -103,7 +103,7 @@ struct sed_globals
 
 	regmatch_t regmatch[10];
 	regex_t *previous_regex_ptr;
-	
+
 	/* linked list of sed commands */
 	sed_cmd_t sed_cmd_head, *sed_cmd_tail;
 
@@ -780,7 +780,7 @@ restart:
 				|| (sed_cmd->beg_line > 0 && (sed_cmd->beg_line == linenum))
 
 			/* Or does this line match our begin address regex? */
-			        || (sed_cmd->beg_match &&
+				|| (sed_cmd->beg_match &&
 				    !regexec(sed_cmd->beg_match, pattern_space, 0, NULL, 0))
 
 			/* Or did we match last line of input? */
diff --git a/editors/vi.c b/editors/vi.c
index 3cbf6937d..8ff118ffb 100644
--- a/editors/vi.c
+++ b/editors/vi.c
@@ -3923,4 +3923,4 @@ static void crash_test()
 	}
 	return;
 }
-#endif					          /* CONFIG_FEATURE_VI_CRASHME */
+#endif						/* CONFIG_FEATURE_VI_CRASHME */
diff --git a/examples/depmod.pl b/examples/depmod.pl
index 93c0b3dab..b2bf54713 100755
--- a/examples/depmod.pl
+++ b/examples/depmod.pl
@@ -34,7 +34,7 @@ my $dep = {};
 my $mod = {};
 
 my $usage = <<TXT;
-$0 -b basedir { -k <vmlinux> | -F <System.map> } [options]... 
+$0 -b basedir { -k <vmlinux> | -F <System.map> } [options]...
   Where:
    -h --help         : Show this help screen
    -b --basedir      : Modules base directory (e.g /lib/modules/<2.x.y>)
@@ -211,7 +211,7 @@ __END__
 
 depmod.pl - a cross platform script to generate kernel module
 dependency lists (modules.conf) which can then be used by modprobe
-on the target platform. 
+on the target platform.
 
 It supports Linux 2.4 and 2.6 styles of modules.conf (auto-detected)
 
@@ -245,7 +245,7 @@ This displays the help message.
 =item B<-b --basedir>
 
 The base directory uner which the target's modules will be found.  This
-defaults to the /lib/modules directory. 
+defaults to the /lib/modules directory.
 
 If you don't specify the kernel version, this script will search for
 one under the specified based directory and use the first thing that
diff --git a/include/platform.h b/include/platform.h
index fdaf50920..91f43f30b 100644
--- a/include/platform.h
+++ b/include/platform.h
@@ -11,7 +11,7 @@
 #undef __GNUC_PREREQ
 #if defined __GNUC__ && defined __GNUC_MINOR__
 # define __GNUC_PREREQ(maj, min) \
-	        ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+		((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
 #else
 # define __GNUC_PREREQ(maj, min) 0
 #endif
@@ -264,7 +264,7 @@ typedef unsigned long long int  uintmax_t;
 #define MS_SHARED      (1<<20)
 #endif
 
- 
+
 #if !defined(BLKSSZGET)
 #define BLKSSZGET _IO(0x12, 104)
 #endif
diff --git a/include/usage.h b/include/usage.h
index a2b8c0ec7..9da1bbd94 100644
--- a/include/usage.h
+++ b/include/usage.h
@@ -499,9 +499,9 @@ USE_FEATURE_DATE_ISOFMT( \
 	"\t-s SIZE\t\tUse a buffer of size SIZE"
 
 #define dnsd_trivial_usage \
-        "[-c config] [-t seconds] [-p port] [-i iface-ip] [-d]"
+	"[-c config] [-t seconds] [-p port] [-i iface-ip] [-d]"
 #define dnsd_full_usage \
-        "Small and static DNS server daemon\n\n" \
+	"Small and static DNS server daemon\n\n" \
 	"Options:\n" \
 	"\t-c\t\tconfig filename\n" \
 	"\t-t\t\tTTL in seconds\n" \
@@ -2058,7 +2058,7 @@ USE_FEATURE_MDEV_CONFIG( \
 	"$ mount /tmp/diskimage /opt -t ext2 -o loop\n" \
 	"$ mount cd_image.iso mydir\n"
 #define mount_notes_usage \
-	"Returns 0 for success, number of failed mounts for -a, or errno for one mount." 
+	"Returns 0 for success, number of failed mounts for -a, or errno for one mount."
 
 #define mountpoint_trivial_usage \
 	"[-q] <[-d] DIR | -x DEVICE>"
diff --git a/include/xregex.h b/include/xregex.h
index 188e90ff6..4185818a8 100644
--- a/include/xregex.h
+++ b/include/xregex.h
@@ -5,7 +5,7 @@
  *
  * Based in part on code from sash, Copyright (c) 1999 by David I. Bell
  * Permission has been granted to redistribute this code under the GPL.
- * 
+ *
  * Licensed under GPLv2 or later, see file License in this tarball for details.
  */
 #ifndef __BB_REGEX__
diff --git a/libbb/crc32.c b/libbb/crc32.c
index 538a13622..1e4a57e8a 100644
--- a/libbb/crc32.c
+++ b/libbb/crc32.c
@@ -6,7 +6,7 @@
  * very well-known)
  *
  * The following function creates a CRC32 table depending on whether
- * a big-endian (0x04c11db7) or little-endian (0xedb88320) CRC32 is 
+ * a big-endian (0x04c11db7) or little-endian (0xedb88320) CRC32 is
  * required. Admittedly, there are other CRC32 polynomials floating
  * around, but Busybox doesn't use them.
  *
@@ -18,12 +18,12 @@
 
 uint32_t *crc32_filltable(int endian)
 {
-	
+
 	uint32_t *crc_table = xmalloc(256 * sizeof(uint32_t));
 	uint32_t polynomial = endian ? 0x04c11db7 : 0xedb88320;
 	uint32_t c;
 	int i, j;
-	
+
 	for (i = 0; i < 256; i++) {
 		c = endian ? (i << 24) : i;
 		for (j = 8; j; j--) {
diff --git a/libbb/login.c b/libbb/login.c
index a7f8de41f..646995b0b 100644
--- a/libbb/login.c
+++ b/libbb/login.c
@@ -72,7 +72,7 @@ void print_login_issue(const char *issue_file, const char *tty)
 					case 'D':
 					case 'o':
 						c = getdomainname(buf, sizeof(buf) - 1);
-						buf[c >= 0 ? c : 0] = '\0'; 
+						buf[c >= 0 ? c : 0] = '\0';
 						break;
 
 					case 'd':
diff --git a/libbb/loop.c b/libbb/loop.c
index da41d1e76..d22b39800 100644
--- a/libbb/loop.c
+++ b/libbb/loop.c
@@ -83,7 +83,7 @@ int set_loop(char **device, const char *file, int offset)
 	bb_loop_info loopinfo;
 	struct stat statbuf;
 	int i, dfd, ffd, mode, rc=-1;
-	
+
 	/* Open the file.  Barf if this doesn't work.  */
 	if((ffd = open(file, mode=O_RDWR))<0 && (ffd = open(file,mode=O_RDONLY))<0)
 		return -errno;
diff --git a/libbb/md5.c b/libbb/md5.c
index cfdffe835..132efdf93 100644
--- a/libbb/md5.c
+++ b/libbb/md5.c
@@ -440,7 +440,7 @@ void *md5_end(void *resbuf, md5_ctx_t *ctx)
 	/* Process last bytes.  */
 	if (buf != ctx->buffer) md5_hash_block(ctx->buffer, ctx);
 	md5_hash_block(buf, ctx);
-	
+
 	/* Put result from CTX in first 16 bytes following RESBUF.  The result is
 	 * always in little endian byte order, so that a byte-wise output yields
 	 * to the wanted ASCII representation of the message digest.
diff --git a/libbb/sha1.c b/libbb/sha1.c
index ea4da2474..a86218b25 100644
--- a/libbb/sha1.c
+++ b/libbb/sha1.c
@@ -6,7 +6,7 @@
  *  Copyright (C) 2002 Dr Brian Gladman <brg@gladman.me.uk>, Worcester, UK.
  *  Copyright (C) 2003 Glenn L. McGrath
  *  Copyright (C) 2003 Erik Andersen
- *  
+ *
  * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
  *
  *  ---------------------------------------------------------------------------
@@ -172,7 +172,7 @@ void *sha1_end(void *resbuf, sha1_ctx_t *ctx)
 
 	for (i = 0; i < SHA1_DIGEST_SIZE; ++i)
 		hval[i] = (unsigned char) (ctx->hash[i >> 2] >> 8 * (~i & 3));
-	
+
 	return resbuf;
 }
 
diff --git a/libbb/u_signal_names.c b/libbb/u_signal_names.c
index 62fab810d..b9afc6ff1 100644
--- a/libbb/u_signal_names.c
+++ b/libbb/u_signal_names.c
@@ -16,12 +16,12 @@ static struct signal_name {
 	// SUSv3 says kill must support these, and specifies the numerical values,
 	// http://www.opengroup.org/onlinepubs/009695399/utilities/kill.html
 	{"0", 0}, {"HUP", 1}, {"INT", 2}, {"QUIT", 3}, {"ABRT", 6}, {"KILL", 9},
-   	{"ALRM", 14}, {"TERM", 15},
+	{"ALRM", 14}, {"TERM", 15},
 	// And Posix adds the following:
 	{"ILL", SIGILL}, {"TRAP", SIGTRAP}, {"FPE", SIGFPE}, {"USR1", SIGUSR1},
-   	{"SEGV", SIGSEGV}, {"USR2", SIGUSR2}, {"PIPE", SIGPIPE}, {"CHLD", SIGCHLD},
-   	{"CONT", SIGCONT}, {"STOP", SIGSTOP}, {"TSTP", SIGTSTP}, {"TTIN", SIGTTIN},
-   	{"TTOU", SIGTTOU}
+	{"SEGV", SIGSEGV}, {"USR2", SIGUSR2}, {"PIPE", SIGPIPE}, {"CHLD", SIGCHLD},
+	{"CONT", SIGCONT}, {"STOP", SIGSTOP}, {"TSTP", SIGTSTP}, {"TTIN", SIGTTIN},
+	{"TTOU", SIGTTOU}
 };
 
 // Convert signal name to number.
diff --git a/libbb/xfuncs.c b/libbb/xfuncs.c
index 3baf7b251..d77bf3839 100644
--- a/libbb/xfuncs.c
+++ b/libbb/xfuncs.c
@@ -489,8 +489,8 @@ void xlisten(int s, int backlog)
 // xstat() - a stat() which dies on failure with meaningful error message
 void xstat(char *name, struct stat *stat_buf)
 {
-        if (stat(name, stat_buf))
-                bb_perror_msg_and_die("Can't stat '%s'", name);
+	if (stat(name, stat_buf))
+		bb_perror_msg_and_die("Can't stat '%s'", name);
 }
 #endif
 
diff --git a/loginutils/addgroup.c b/loginutils/addgroup.c
index f5a99b796..13f29bfa3 100644
--- a/loginutils/addgroup.c
+++ b/loginutils/addgroup.c
@@ -88,7 +88,7 @@ int addgroup_main(int argc, char **argv)
 {
 	char *group;
 	gid_t gid = 0;
-	
+
 	/* check for min, max and missing args and exit on error */
 	bb_opt_complementally = "-1:?2:?";
 
diff --git a/loginutils/adduser.c b/loginutils/adduser.c
index 0133d8288..936e48e0a 100644
--- a/loginutils/adduser.c
+++ b/loginutils/adduser.c
@@ -137,8 +137,8 @@ static int adduser(struct passwd *p, unsigned long flags)
 		if (mkdir(p->pw_dir, 0755)
 		|| chown(p->pw_dir, p->pw_uid, p->pw_gid)
 		|| chmod(p->pw_dir, 02755)) {
- 			bb_perror_msg("%s", p->pw_dir);
- 		}
+			bb_perror_msg("%s", p->pw_dir);
+		}
 	}
 
 	if (!(flags & DONT_SET_PASS)) {
@@ -175,7 +175,7 @@ int adduser_main(int argc, char **argv)
 	/* got root? */
 	if(geteuid()) {
 		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
- 	}
+	}
 
 	/* create string for $HOME if not specified already */
 	if (!pw.pw_dir) {
diff --git a/loginutils/getty.c b/loginutils/getty.c
index 71f6b2458..b456e076d 100644
--- a/loginutils/getty.c
+++ b/loginutils/getty.c
@@ -337,7 +337,7 @@ static void open_tty(char *tty, struct termio *tp, int local)
 		if(fd) {
 			xdup2(fd, 0, tty);
 			close(fd);
-		}		
+		}
 	} else {
 		/*
 		 * Standard input should already be connected to an open port. Make
@@ -812,11 +812,11 @@ int getty_main(int argc, char **argv)
 	setsid();
 #endif
 	/* We want special flavor of error_msg_and_die */
-	die_sleep = 10;		
+	die_sleep = 10;
 	msg_eol = "\r\n";
 	/* Was "/dev/console". Why should we spam *system console*
 	 * if there is a problem with getty on /dev/ttyS15?... */
-	nullfd = xopen(bb_dev_null, O_RDWR); 
+	nullfd = xopen(bb_dev_null, O_RDWR);
 	dup2(nullfd, 0);
 	dup2(nullfd, 1);
 	dup2(nullfd, 2);
diff --git a/loginutils/sulogin.c b/loginutils/sulogin.c
index a2238d49d..8cfb64e9a 100644
--- a/loginutils/sulogin.c
+++ b/loginutils/sulogin.c
@@ -73,7 +73,7 @@ int sulogin_main(int argc, char **argv)
 
 	if (!(pwd = getpwuid(0))) {
 		goto auth_error;
-	} 
+	}
 
 	if (ENABLE_FEATURE_SHADOWPASSWDS) {
 		if (!(spwd = getspnam(pwd->pw_name))) {
@@ -108,6 +108,6 @@ int sulogin_main(int argc, char **argv)
 	run_shell(pwd->pw_shell, 1, 0, 0);
 	/* never returns */
 
-auth_error:	
+auth_error:
 	bb_error_msg_and_die("no password entry for `root'");
 }
diff --git a/miscutils/Config.in b/miscutils/Config.in
index dc3da6f9a..50ed4df99 100644
--- a/miscutils/Config.in
+++ b/miscutils/Config.in
@@ -292,7 +292,7 @@ config CONFIG_READAHEAD
 	  significantly speed up system startup.
 
 	  As readahead(2) blocks until each file has been read, it is best to
-	  run this applet as a background job. 
+	  run this applet as a background job.
 
 config CONFIG_RUNLEVEL
         bool "runlevel"
diff --git a/miscutils/hdparm.c b/miscutils/hdparm.c
index 1febcef2c..97f1b5752 100644
--- a/miscutils/hdparm.c
+++ b/miscutils/hdparm.c
@@ -755,7 +755,7 @@ static void identify(uint16_t *id_supplied)
 			strng = "<=10ms with INTRQ";
 		else if ((val[GEN_CONFIG] & DRQ_RESPONSE_TIME) ==  DRQ_50US_VAL)
 			strng ="50us";
-		else 
+		else
 			strng = "Unknown";
 		printf("\tDRQ response: %s\n\tPacket size: ", strng); /* Data Request (DRQ) */
 
@@ -817,7 +817,7 @@ static void identify(uint16_t *id_supplied)
 
 		if (bbbig > 1000)
 			printf("(%"PRIu64" GB)\n", bbbig/1000);
-		else 
+		else
 			printf("\n");
 	}
 
@@ -833,8 +833,8 @@ static void identify(uint16_t *id_supplied)
 
 	if (like_std != 1)
 	{
-		printf("IORDY%s(can%s be disabled)\n", 
-				!(val[CAPAB_0] & IORDY_SUP) ? "(may be)" : "", 
+		printf("IORDY%s(can%s be disabled)\n",
+				!(val[CAPAB_0] & IORDY_SUP) ? "(may be)" : "",
 				(val[CAPAB_0] & IORDY_OFF) ? "" :"not");
 	}
 	else
@@ -843,7 +843,7 @@ static void identify(uint16_t *id_supplied)
 	if ((like_std == 1) && val[BUF_TYPE])
 	{
 		printf("\tBuffer type: %04x: %s%s\n", val[BUF_TYPE],
-				(val[BUF_TYPE] < 2) ? "single port, single-sector" : "dual port, multi-sector", 
+				(val[BUF_TYPE] < 2) ? "single port, single-sector" : "dual port, multi-sector",
 				(val[BUF_TYPE] > 2) ? " with read caching ability" : "");
 	}
 
@@ -1063,9 +1063,9 @@ static void identify(uint16_t *id_supplied)
 			strng = " determined by the jumper";
 		else if ((jj & DEV_DET) == CSEL_VAL)
 			strng = " determined by CSEL";
-		else 
+		else
 			strng = "";
-		printf("HW reset results:\n\tCBLID- %s Vih\n\tDevice num = %i%s\n", 
+		printf("HW reset results:\n\tCBLID- %s Vih\n\tDevice num = %i%s\n",
 				(val[HWRST_RSLT] & CBLID) ? "above" : "below", !(oo), strng);
 	}
 
@@ -1200,8 +1200,8 @@ static void dump_identity(const struct hd_driveid *id)
 		printf(" (maybe):");
 
 	printf(" CurCHS=%u/%u/%u, CurSects=%lu, LBA=%s",id->cur_cyls, id->cur_heads,
-													id->cur_sectors, 
- 													(BB_BIG_ENDIAN) ? 
+													id->cur_sectors,
+													(BB_BIG_ENDIAN) ?
 													(long unsigned int)(id->cur_capacity0 << 16) | id->cur_capacity1 :
 													(long unsigned int)(id->cur_capacity1 << 16) | id->cur_capacity0,
 													((id->capability&2) == 0) ? "no" : "yes");
@@ -1213,7 +1213,7 @@ static void dump_identity(const struct hd_driveid *id)
 
 	if (((id->capability&8) || (id->field_valid&2)) && id->field_valid&2)
 		printf(", tPIO={min:%u,w/IORDY:%u}", id->eide_pio, id->eide_pio_iordy);
-	
+
 	if ((id->capability&1) && (id->field_valid&2))
 		printf(", tDMA={min:%u,rec:%u}", id->eide_dma_min, id->eide_dma_time);
 
@@ -1254,7 +1254,7 @@ static void dump_identity(const struct hd_driveid *id)
 		}
 	}
 	if (((id->capability&8) || (id->field_valid&2))	&& id->field_valid&4)
-	{	
+	{
 		printf("\n UDMA modes: ");
 		if (id->dma_ultra & 0x100) printf("*");
 		if (id->dma_ultra & 0x001) printf("udma0 ");
@@ -1399,7 +1399,7 @@ static void do_time(int flag, int fd)
 		if (read_big_block (fd, buf)) return;
 		printf(" Timing cached reads:   ");
 		fflush(stdout);
-	
+
 		/* Now do the timing */
 		iterations = 0;
 		getitimer(ITIMER_REAL, &e1);
@@ -1422,9 +1422,9 @@ static void do_time(int flag, int fd)
 			elapsed2 = (e1.it_value.tv_sec - e2.it_value.tv_sec)
 			+ ((e1.it_value.tv_usec - e2.it_value.tv_usec) / 1000000.0);
 		} while (--iterations);
-	
+
 		elapsed -= elapsed2;
-		print_timing(BUFCACHE_FACTOR * total_MB, elapsed);	
+		print_timing(BUFCACHE_FACTOR * total_MB, elapsed);
 		flush_buffer_cache(fd);
 		sleep(1);
 	}
@@ -1447,7 +1447,7 @@ static void do_time(int flag, int fd)
 			elapsed = (e1.it_value.tv_sec - e2.it_value.tv_sec)
 			+ ((e1.it_value.tv_usec - e2.it_value.tv_usec) / 1000000.0);
 		} while (elapsed < 3.0 && iterations < max_iterations);
-	
+
 		total_MB = iterations * TIMING_BUF_MB;
 		print_timing(total_MB, elapsed);
 	}
@@ -2124,7 +2124,7 @@ int hdparm_main(int argc, char **argv)
 		do_flush |= do_timings |= (c == 't');
 		do_flush |= do_ctimings |= (c == 'T');
 #ifdef HDIO_DRIVE_CMD
-		if (c == 'S') parse_opts(&get_standby, &set_standby, &standby_requested, 0, INT_MAX);	
+		if (c == 'S') parse_opts(&get_standby, &set_standby, &standby_requested, 0, INT_MAX);
 		if (c == 'D') parse_opts(&get_defects, &set_defects, &defects, 0, INT_MAX);
 		if (c == 'P') parse_opts(&get_prefetch, &set_prefetch, &prefetch, 0, INT_MAX);
 		parse_xfermode((c == 'X'), &get_xfermode, &set_xfermode, &xfermode_requested);
@@ -2138,22 +2138,22 @@ int hdparm_main(int argc, char **argv)
 		reread_partn |= (c == 'z');
 		get_seagate = set_seagate |= (c == 'Z');
 #endif
-		USE_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF(if (c == 'U') parse_opts(NULL, &unregister_hwif, &hwif, 0, INT_MAX));	
+		USE_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF(if (c == 'U') parse_opts(NULL, &unregister_hwif, &hwif, 0, INT_MAX));
 #ifdef HDIO_GET_QDMA
 		if (c == 'Q') {
 #ifdef HDIO_SET_QDMA
 			parse_opts(&get_dma_q, &set_dma_q, &dma_q, 0, INT_MAX);
 #else
-			parse_opts(&get_dma_q, NULL, NULL, 0, 0);	
+			parse_opts(&get_dma_q, NULL, NULL, 0, 0);
 #endif
 		}
-#endif		
+#endif
 		USE_FEATURE_HDPARM_HDIO_DRIVE_RESET(perform_reset = (c == 'r'));
-		USE_FEATURE_HDPARM_HDIO_TRISTATE_HWIF(if (c == 'x') parse_opts(NULL, &perform_tristate, &tristate, 0, 1));	
-		USE_FEATURE_HDPARM_HDIO_TRISTATE_HWIF(if (c == 'b') parse_opts(&get_busstate, &set_busstate, &busstate, 0, 2));	
+		USE_FEATURE_HDPARM_HDIO_TRISTATE_HWIF(if (c == 'x') parse_opts(NULL, &perform_tristate, &tristate, 0, 1));
+		USE_FEATURE_HDPARM_HDIO_TRISTATE_HWIF(if (c == 'b') parse_opts(&get_busstate, &set_busstate, &busstate, 0, 2));
 #if ENABLE_FEATURE_HDPARM_HDIO_SCAN_HWIF
 		if (c == 'R') {
-			parse_opts(NULL, &scan_hwif, &hwif_data, 0, INT_MAX);	
+			parse_opts(NULL, &scan_hwif, &hwif_data, 0, INT_MAX);
 			hwif_ctrl =  bb_xgetlarg((argv[optind]) ? argv[optind] : "", 10, 0, INT_MAX);
 			hwif_irq  =  bb_xgetlarg((argv[optind+1]) ? argv[optind+1] : "", 10, 0, INT_MAX);
 			/* Move past the 2 additional arguments */
diff --git a/miscutils/less.c b/miscutils/less.c
index c13d7b8a2..bde2a4527 100644
--- a/miscutils/less.c
+++ b/miscutils/less.c
@@ -610,26 +610,26 @@ static char *process_regex_on_line(char *line, regex_t *pattern, int action)
 
 	match_found = 0;
 	match_status = regexec(pattern, line2, 1, &match_structs, 0);
-	
+
 	while (match_status == 0) {
 		if (match_found == 0)
 			match_found = 1;
-		
+
 		if (action) {
-			growline = xasprintf("%s%.*s%s%.*s%s", growline, match_structs.rm_so, line2, HIGHLIGHT, match_structs.rm_eo - match_structs.rm_so, line2 + match_structs.rm_so, NORMAL); 
+			growline = xasprintf("%s%.*s%s%.*s%s", growline, match_structs.rm_so, line2, HIGHLIGHT, match_structs.rm_eo - match_structs.rm_so, line2 + match_structs.rm_so, NORMAL);
 		}
 		else {
 			growline = xasprintf("%s%.*s%.*s", growline, match_structs.rm_so - 4, line2, match_structs.rm_eo - match_structs.rm_so, line2 + match_structs.rm_so);
 		}
-		
+
 		line2 += match_structs.rm_eo;
 		match_status = regexec(pattern, line2, 1, &match_structs, REG_NOTBOL);
 	}
-	
+
 	growline = xasprintf("%s%s", growline, line2);
-	
+
 	return (match_found ? growline : line);
-	
+
 	free(growline);
 	free(line2);
 }
@@ -656,7 +656,7 @@ static void regex_process(void)
 	putchar((match_backwards) ? '?' : '/');
 	uncomp_regex[0] = 0;
 	fgets(uncomp_regex, sizeof(uncomp_regex), inp);
-	
+
 	if (strlen(uncomp_regex) == 1) {
 		if (num_matches)
 			goto_match(match_backwards ? match_pos - 1 : match_pos + 1);
@@ -665,7 +665,7 @@ static void regex_process(void)
 		return;
 	}
 	uncomp_regex[strlen(uncomp_regex) - 1] = '\0';
-	
+
 	/* Compile the regex and check for errors */
 	xregcomp(&pattern, uncomp_regex, 0);
 
@@ -677,7 +677,7 @@ static void regex_process(void)
 		}
 	}
 	old_pattern = pattern;
-	
+
 	/* Reset variables */
 	match_lines = xrealloc(match_lines, sizeof(int));
 	match_lines[0] = -1;
@@ -694,7 +694,7 @@ static void regex_process(void)
 			j++;
 		}
 	}
-	
+
 	num_matches = j;
 	if ((match_lines[0] != -1) && (num_flines > height - 2)) {
 		if (match_backwards) {
diff --git a/miscutils/readahead.c b/miscutils/readahead.c
index 8221bb4be..49cd7fd09 100644
--- a/miscutils/readahead.c
+++ b/miscutils/readahead.c
@@ -22,7 +22,7 @@ int readahead_main(int argc, char **argv)
 	while (*++argv) {
 		if ((f = bb_wfopen(*argv, "r")) != NULL) {
 			int r, fd=fileno(f);
-			
+
 			r = readahead(fd, 0, fdlength(fd));
 			fclose(f);
 			if (r >= 0) continue;
diff --git a/miscutils/strings.c b/miscutils/strings.c
index 9a76c8534..e9f335ebd 100644
--- a/miscutils/strings.c
+++ b/miscutils/strings.c
@@ -3,7 +3,7 @@
  * strings implementation for busybox
  *
  * Copyright Tito Ragusa <farmatito@tiscali.it>
- * 
+ *
  * Licensed under the GPL v2 or later, see the file LICENSE in this tarball.
  */
 
diff --git a/modutils/insmod.c b/modutils/insmod.c
index 249563435..2b2e3637d 100644
--- a/modutils/insmod.c
+++ b/modutils/insmod.c
@@ -981,7 +981,7 @@ arch_apply_relocation(struct obj_file *f,
 			/* dot is the address of the current instruction.
 			 * v is the target symbol address.
 			 * So we need to extract the offset in the code,
-			 * adding v, then subtrating the current address 
+			 * adding v, then subtrating the current address
 			 * of this instruction.
 			 * Ex: "IMM 0xFFFE  bralid 0x0000" = "bralid 0xFFFE0000"
 			 */
@@ -990,7 +990,7 @@ arch_apply_relocation(struct obj_file *f,
 			unsigned int temp = (loc[0] & 0xFFFF) << 16 |
 						(loc[1] & 0xFFFF);
 
-			/* Adjust relative offset. -4 adjustment required 
+			/* Adjust relative offset. -4 adjustment required
 			 * because dot points to the IMM insn, but branch
 			 * is computed relative to the branch instruction itself.
 			 */
diff --git a/modutils/lsmod.c b/modutils/lsmod.c
index 2bc1ae6b1..69c8ab3c7 100644
--- a/modutils/lsmod.c
+++ b/modutils/lsmod.c
@@ -104,7 +104,7 @@ int lsmod_main(int argc, char **argv)
 			if (errno == ENOENT) {
 				/* The module was removed out from underneath us. */
 				continue;
-			} else if (errno != ENOSPC) 
+			} else if (errno != ENOSPC)
 				bb_perror_msg_and_die("module %s: QM_REFS", mn);
 			deps = xrealloc(deps, count);
 		}
diff --git a/modutils/rmmod.c b/modutils/rmmod.c
index 8f210310d..f87fb5e24 100644
--- a/modutils/rmmod.c
+++ b/modutils/rmmod.c
@@ -36,7 +36,7 @@ void filename2modname(char *modname, const char *afterslash);
 // There really should be a header file for this...
 
 int query_module(const char *name, int which, void *buf,
-		        size_t bufsize, size_t *ret);
+			size_t bufsize, size_t *ret);
 
 int rmmod_main(int argc, char **argv)
 {
diff --git a/networking/Config.in b/networking/Config.in
index 2dff021a8..b78ae37e7 100644
--- a/networking/Config.in
+++ b/networking/Config.in
@@ -22,7 +22,7 @@ config CONFIG_DNSD
 	bool "dnsd"
 	default n
 	help
-	  Small and static DNS server daemon. 
+	  Small and static DNS server daemon.
 
 config CONFIG_ETHER_WAKE
 	bool "ether-wake"
@@ -132,9 +132,9 @@ config CONFIG_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR
 	default n
 	depends on CONFIG_FEATURE_HTTPD_CGI
 	help
-	  This option enables support for running scripts through an 
-	  interpreter. Turn this on if you want PHP scripts to work 
-	  properly. You need to supply an addition line in your httpd 
+	  This option enables support for running scripts through an
+	  interpreter. Turn this on if you want PHP scripts to work
+	  properly. You need to supply an addition line in your httpd
 	  config file:
 	  *.php:/path/to/your/php
 
diff --git a/networking/ifupdown.c b/networking/ifupdown.c
index 6429c07e5..fa5bfe1e9 100644
--- a/networking/ifupdown.c
+++ b/networking/ifupdown.c
@@ -708,7 +708,7 @@ static struct interfaces_file_t *read_interfaces(const char *filename)
 					llist_t *iface_list;
 					for (iface_list = defn->ifaces; iface_list; iface_list = iface_list->link) {
 						struct interface_defn_t *tmp = (struct interface_defn_t *) iface_list->data;
-						if ((strcmp(tmp->iface, currif->iface) == 0) && 
+						if ((strcmp(tmp->iface, currif->iface) == 0) &&
 							(tmp->address_family == currif->address_family)) {
 							bb_error_msg("duplicate interface \"%s\"", tmp->iface);
 							return NULL;
diff --git a/networking/nc.c b/networking/nc.c
index 3f4149e14..f8b3fb2dd 100644
--- a/networking/nc.c
+++ b/networking/nc.c
@@ -1,9 +1,9 @@
 /* vi: set sw=4 ts=4: */
 /*  nc: mini-netcat - built from the ground up for LRP
- *  
+ *
  *  Copyright (C) 1998, 1999  Charles P. Wright
  *  Copyright (C) 1998  Dave Cinege
- *  
+ *
  *  Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
  */
 
@@ -25,7 +25,7 @@ int nc_main(int argc, char **argv)
 
 	memset(&address, 0, sizeof(address));
 
-	if (ENABLE_NC_SERVER || ENABLE_NC_EXTRA) { 
+	if (ENABLE_NC_SERVER || ENABLE_NC_EXTRA) {
 		while ((opt = getopt(argc, argv, "lp:" USE_NC_EXTRA("i:ew:f:"))) > 0) {
 			if (ENABLE_NC_SERVER && opt=='l') do_listen++;
 			else if (ENABLE_NC_SERVER && opt=='p')
@@ -40,7 +40,7 @@ int nc_main(int argc, char **argv)
 		}
 	}
 
-	
+
 	// For listen or file we need zero arguments, dialout is 2.
 	// For exec we need at least one more argument at the end, more ok
 
@@ -53,7 +53,7 @@ int nc_main(int argc, char **argv)
 		signal(SIGALRM, timeout);
 		alarm(wsecs);
 	}
-	
+
 	if (infile) cfd = xopen(infile, O_RDWR);
 	else {
 		opt = 1;
@@ -132,7 +132,7 @@ repeatyness:
 	}
 
 	// Select loop copying stdin to cfd, and cfd to stdout.
-	
+
 	FD_ZERO(&readfds);
 	FD_SET(cfd, &readfds);
 	FD_SET(STDIN_FILENO, &readfds);
diff --git a/networking/ping6.c b/networking/ping6.c
index 990328a51..6079c40d9 100644
--- a/networking/ping6.c
+++ b/networking/ping6.c
@@ -370,7 +370,7 @@ static void ping(const char *host)
 		pingaddr.sin6_scope_id = if_index;
 
 	printf("PING %s (%s): %d data bytes\n",
-	           hostent->h_name,
+		   hostent->h_name,
 		   inet_ntop(AF_INET6, &pingaddr.sin6_addr,
 			buf, sizeof(buf)),
 		   datalen);
diff --git a/networking/telnet.c b/networking/telnet.c
index 5324d7a20..344fc3270 100644
--- a/networking/telnet.c
+++ b/networking/telnet.c
@@ -185,9 +185,9 @@ static void handlenetoutput(int len)
 	 *	I don't agree.
 	 *	first - I cannot use programs like sz/rz
 	 *	second - the 0x0D is sent as one character and if the next
-	 *	         char is 0x0A then it's eaten by a server side.
+	 *		 char is 0x0A then it's eaten by a server side.
 	 *	third - whay doy you have to make 'many write()s'?
-	 *	        I don't understand.
+	 *		I don't understand.
 	 *	So I implemented it. It's realy useful for me. I hope that
 	 *	others people will find it interesting to.
 	 */
diff --git a/networking/udhcp/dhcpc.h b/networking/udhcp/dhcpc.h
index 42af0a367..3dff11ab0 100644
--- a/networking/udhcp/dhcpc.h
+++ b/networking/udhcp/dhcpc.h
@@ -29,7 +29,7 @@ struct client_config_t {
 	uint8_t *hostname;		/* Optional hostname to use */
 	uint8_t *fqdn;			/* Optional fully qualified domain name to use */
 	int ifindex;			/* Index number of the interface to use */
-	int retries;			/* Max number of request packets */        
+	int retries;			/* Max number of request packets */
 	int timeout;			/* Number of seconds to try to get a lease */
 	uint8_t arp[6];			/* Our arp address */
 };
diff --git a/networking/wget.c b/networking/wget.c
index 181ea9397..1a80972fc 100644
--- a/networking/wget.c
+++ b/networking/wget.c
@@ -483,7 +483,7 @@ read_response:
 	do {
 		while (filesize > 0 || !got_clen) {
 			unsigned rdsz = sizeof(buf);
-			if (filesize < sizeof(buf) && (chunked || got_clen)) 
+			if (filesize < sizeof(buf) && (chunked || got_clen))
 				rdsz = filesize;
 			n = safe_fread(buf, 1, rdsz, dfp);
 			if (n <= 0)
diff --git a/networking/zcip.c b/networking/zcip.c
index 5d2a5f786..c6b0d2d80 100644
--- a/networking/zcip.c
+++ b/networking/zcip.c
@@ -314,7 +314,7 @@ int zcip_main(int argc, char *argv[])
 			tv1.tv_sec++;
 		}
 		tv1.tv_sec += timeout / 1000;
-	
+
 		VDBG("...wait %ld %s nprobes=%d, nclaims=%d\n",
 				timeout, intf, nprobes, nclaims);
 		switch (poll(fds, 1, timeout)) {
@@ -479,7 +479,7 @@ int zcip_main(int argc, char *argv[])
 				target_ip_conflict = 1;
 			}
 
-			VDBG("state = %d, source ip conflict = %d, target ip conflict = %d\n", 
+			VDBG("state = %d, source ip conflict = %d, target ip conflict = %d\n",
 				state, source_ip_conflict, target_ip_conflict);
 			switch (state) {
 			case PROBE:
diff --git a/scripts/checkhelp.awk b/scripts/checkhelp.awk
index 85d0661a7..608a46e58 100755
--- a/scripts/checkhelp.awk
+++ b/scripts/checkhelp.awk
@@ -2,7 +2,7 @@
 # AWK script to check for missing help entries for config options
 #
 # Copyright (C) 2006 Bernhard Fischer
-# 
+#
 # This file is distributed under the terms and conditions of the
 # MIT/X public licenses. See http://opensource.org/licenses/mit-license.html
 # and notice http://www.gnu.org/licenses/license-list.html#X11License
diff --git a/scripts/config/lxdialog/BIG.FAT.WARNING b/scripts/config/lxdialog/BIG.FAT.WARNING
index a8999d82b..7cb5a7ec9 100644
--- a/scripts/config/lxdialog/BIG.FAT.WARNING
+++ b/scripts/config/lxdialog/BIG.FAT.WARNING
@@ -1,4 +1,4 @@
 This is NOT the official version of dialog.  This version has been
 significantly modified from the original.  It is for use by the Linux
-kernel configuration script.  Please do not bother Savio Lam with 
+kernel configuration script.  Please do not bother Savio Lam with
 questions about this program.
diff --git a/scripts/config/lxdialog/menubox.c b/scripts/config/lxdialog/menubox.c
index 23a38e0fb..bdaaa1040 100644
--- a/scripts/config/lxdialog/menubox.c
+++ b/scripts/config/lxdialog/menubox.c
@@ -305,7 +305,7 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 
 	    if (key == KEY_UP || key == '-') {
 		if (choice < 2 && scroll) {
-	            /* Scroll menu down */
+		    /* Scroll menu down */
 		    scrollok (menu, TRUE);
 		    wscrl (menu, -1);
 		    scrollok (menu, FALSE);
@@ -339,7 +339,7 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 		    choice = MIN(choice+1, max_choice-1);
 
 	    } else if (key == KEY_PPAGE) {
-	        scrollok (menu, TRUE);
+		scrollok (menu, TRUE);
 		for (i=0; (i < max_choice); i++) {
 		    if (scroll > 0) {
 			wscrl (menu, -1);
@@ -361,8 +361,8 @@ dialog_menu (const char *title, const char *prompt, int height, int width,
 			scrollok (menu, FALSE);
 			scroll++;
 			print_item (menu, items[scroll + max_choice - 1]->name,
-			            max_choice-1, FALSE,
-			            (items[scroll + max_choice - 1]->tag[0] != ':'));
+				    max_choice-1, FALSE,
+				    (items[scroll + max_choice - 1]->tag[0] != ':'));
 		    } else {
 			if (choice+1 < max_choice)
 			    choice++;
diff --git a/scripts/config/lxdialog/util.c b/scripts/config/lxdialog/util.c
index bb43c836e..26dd376b9 100644
--- a/scripts/config/lxdialog/util.c
+++ b/scripts/config/lxdialog/util.c
@@ -224,7 +224,7 @@ print_autowrap (WINDOW * win, const char *prompt, int width, int y, int x)
 	while (word && *word) {
 	    sp = strchr(word, ' ');
 	    if (sp)
-	        *sp++ = 0;
+		*sp++ = 0;
 
 	    /* Wrap to next line if either the word does not fit,
 	       or it is the first word of a new sentence, and it is
@@ -242,11 +242,11 @@ print_autowrap (WINDOW * win, const char *prompt, int width, int y, int x)
 	    getyx (win, cur_y, cur_x);
 	    cur_x++;
 	    if (sp && *sp == ' ') {
-	        cur_x++;	/* double space */
+		cur_x++;	/* double space */
 		while (*++sp == ' ');
 		newl = 1;
 	    } else
-	        newl = 0;
+		newl = 0;
 	    word = sp;
 	}
     }
diff --git a/scripts/config/mconf.c b/scripts/config/mconf.c
index b2fb112f5..b8f27e69c 100644
--- a/scripts/config/mconf.c
+++ b/scripts/config/mconf.c
@@ -408,7 +408,7 @@ static void get_symbol_str(struct gstr *r, struct symbol *sym)
 	struct property *prop;
 
 	str_printf(r, "Symbol: %s [=%s]\n", sym->name,
-	                               sym_get_string_value(sym));
+				       sym_get_string_value(sym));
 	for_all_prompts(sym, prop)
 		get_prompt_str(r, prop);
 	hit = false;
diff --git a/scripts/config/menu.c b/scripts/config/menu.c
index 57292cf1d..7e97e8330 100644
--- a/scripts/config/menu.c
+++ b/scripts/config/menu.c
@@ -185,7 +185,7 @@ void sym_check_prop(struct symbol *sym)
 		case P_RANGE:
 			if (sym->type != S_INT && sym->type != S_HEX)
 				prop_warn(prop, "range is only allowed "
-				                "for int or hex symbols");
+						"for int or hex symbols");
 			if (!sym_string_valid(sym, prop->expr->left.sym->name) ||
 			    !sym_string_valid(sym, prop->expr->right.sym->name))
 				prop_warn(prop, "range is invalid");
diff --git a/shell/bbsh.c b/shell/bbsh.c
index 2194bdad6..05ae1637e 100644
--- a/shell/bbsh.c
+++ b/shell/bbsh.c
@@ -1,5 +1,5 @@
 /* vi: set ts=4 :
- * 
+ *
  * bbsh - busybox shell
  *
  * Copyright 2006 Rob Landley <rob@landley.net>
@@ -51,7 +51,7 @@
 // What we know about a single process.
 struct command {
 	struct command *next;
-	int flags;		// exit, suspend, && || 
+	int flags;		// exit, suspend, && ||
 	int pid;		// pid (or exit code)
 	int argc;
 	char *argv[0];
@@ -125,9 +125,9 @@ static char *parse_pipeline(char *cmdline, struct pipeline *line)
 			return 0;
 		}
 
-		// Allocate next command structure if necessary		
+		// Allocate next command structure if necessary
 		if (!*cmd) *cmd = xzalloc(sizeof(struct command)+8*sizeof(char *));
-		
+
 		// Parse next argument and add the results to argv[]
 		end = parse_word(start, cmd);
 
@@ -138,7 +138,7 @@ static char *parse_pipeline(char *cmdline, struct pipeline *line)
 					start++;
 					break;
 				}
-				// handle | & < > >> << || && 
+				// handle | & < > >> << || &&
 			}
 			break;
 		}
@@ -160,7 +160,7 @@ static int run_pipeline(struct pipeline *line)
 	if (cmd->argc==2 && !strcmp(cmd->argv[0],"cd"))
 		chdir(cmd->argv[1]);
 	else if(!strcmp(cmd->argv[0],"exit"))
-		exit(cmd->argc>1 ? atoi(cmd->argv[1]) : 0); 
+		exit(cmd->argc>1 ? atoi(cmd->argv[1]) : 0);
 	else {
 		int status;
 		pid_t pid=fork();
@@ -217,6 +217,6 @@ int bbsh_main(int argc, char *argv[])
 		}
 		if (ENABLE_FEATURE_CLEAN_UP) free(command);
 	}
-		
+
 	return 1;
 }
diff --git a/testsuite/cp/cp-dir-create-dir b/testsuite/cp/cp-dir-create-dir
index 2c89af67e..a8d7b50a5 100644
--- a/testsuite/cp/cp-dir-create-dir
+++ b/testsuite/cp/cp-dir-create-dir
@@ -1,4 +1,4 @@
-mkdir bar 
+mkdir bar
 touch bar/baz
-busybox cp -R bar foo 
-test -f foo/baz 
+busybox cp -R bar foo
+test -f foo/baz
diff --git a/testsuite/cp/cp-dir-existing-dir b/testsuite/cp/cp-dir-existing-dir
index 5ba3f8e33..4c788ba73 100644
--- a/testsuite/cp/cp-dir-existing-dir
+++ b/testsuite/cp/cp-dir-existing-dir
@@ -1,5 +1,5 @@
-mkdir bar 
+mkdir bar
 touch bar/baz
 mkdir foo
-busybox cp -R bar foo 
-test -f foo/bar/baz 
+busybox cp -R bar foo
+test -f foo/bar/baz
diff --git a/testsuite/grep.tests b/testsuite/grep.tests
index 0654905d2..ef0de482b 100755
--- a/testsuite/grep.tests
+++ b/testsuite/grep.tests
@@ -4,7 +4,7 @@
 # Copyright 2005 by Rob Landley <rob@landley.net>
 # Licensed under GPL v2, see file LICENSE for details.
 
-# AUDIT: 
+# AUDIT:
 
 . testing.sh
 
diff --git a/testsuite/mount.testroot b/testsuite/mount.testroot
index 4ab6b94bc..e18d0461d 100755
--- a/testsuite/mount.testroot
+++ b/testsuite/mount.testroot
@@ -86,7 +86,7 @@ testing "mount remount nonexistent directory" \
 
 # Fun with mount -a
 
-testing "mount -a no fstab" "mount -a 2>/dev/null || echo yes" "yes\n" "" "" 
+testing "mount -a no fstab" "mount -a 2>/dev/null || echo yes" "yes\n" "" ""
 
 umount /proc
 
diff --git a/testsuite/pidof.tests b/testsuite/pidof.tests
index 831dd2483..bfde26e2c 100755
--- a/testsuite/pidof.tests
+++ b/testsuite/pidof.tests
@@ -4,7 +4,7 @@
 # Copyright 2005 by Bernhard Fischer
 # Licensed under GPL v2, see file LICENSE for details.
 
-# AUDIT: 
+# AUDIT:
 
 . testing.sh
 
@@ -24,6 +24,6 @@ testing "pidof -s" "pidof -s init" "1\n" "" ""
 optional FEATURE_PIDOF_OMIT
 testing "pidof -o %PPID" "pidof -o %PPID pidof.tests | grep -o -w $$" "" "" ""
 testing "pidof -o %PPID NOP" "pidof -o %PPID -s init" "1\n" "" ""
-testing "pidof -o init" "pidof -o 1 init | grep -o -w 1" "" "" "" 
+testing "pidof -o init" "pidof -o 1 init | grep -o -w 1" "" "" ""
 
 exit $FAILCOUNT
diff --git a/testsuite/readlink.tests b/testsuite/readlink.tests
index fc04702d3..0faa6ed0c 100755
--- a/testsuite/readlink.tests
+++ b/testsuite/readlink.tests
@@ -28,5 +28,5 @@ testing "readlink -f on a wierd dir" "readlink -f $TESTDIR/../$TESTFILE" "$PWD/$
 
 
 # clean up
-rm -r "$TESTLINK" "$TESTDIR" 
+rm -r "$TESTLINK" "$TESTDIR"
 
diff --git a/testsuite/sed.tests b/testsuite/sed.tests
index 9d2be5570..2a0d4eacf 100755
--- a/testsuite/sed.tests
+++ b/testsuite/sed.tests
@@ -116,7 +116,7 @@ testing "sed leave off trailing newline" "sed -e 's/woo/bang/' input -" \
 testing "sed autoinsert newline" "sed -e 's/woo/bang/' input -" "bang\nbang" \
 	"woo" "woo"
 testing "sed empty file plus cat" "sed -e 's/nohit//' input -" "one\ntwo" \
-	"" "one\ntwo" 
+	"" "one\ntwo"
 testing "sed cat plus empty file" "sed -e 's/nohit//' input -" "one\ntwo" \
 	"one\ntwo" ""
 testing "sed append autoinserts newline" "sed -e '/woot/a woo' -" \
@@ -138,7 +138,7 @@ testing "sed selective matches noinsert newline" \
 	"c no\nd no"
 testing "sed clusternewline" \
 	"sed -e '/one/a 111' -e '/two/i 222' -e p input -" \
-	"one\none\n111\n222\ntwo\ntwo" "one" "two" 
+	"one\none\n111\n222\ntwo\ntwo" "one" "two"
 
 # Test end-of-file matching behavior
 
diff --git a/testsuite/sort.tests b/testsuite/sort.tests
index cd2e291b2..5a4937b58 100755
--- a/testsuite/sort.tests
+++ b/testsuite/sort.tests
@@ -56,7 +56,7 @@ testing "sort key range with numeric option and global reverse" \
 7	3	42	soup
 " "$data" ""
 
-# 
+#
 
 testing "sort key range with multiple options" "sort -k2,3rn input" \
 "7	3	42	soup
@@ -67,7 +67,7 @@ egg	1	2	papyrus
 " "$data" ""
 
 testing "sort key doesn't strip leading blanks, disables fallback global sort" \
-"sort -n -k2 -t ' '" " a \n 1 \n 2 \n" "" " 2 \n 1 \n a \n" 
+"sort -n -k2 -t ' '" " a \n 1 \n 2 \n" "" " 2 \n 1 \n a \n"
 
 testing "sort key edge case with -t" "sort -n -k4 -t/" \
 "/usr/lib/finish-install.d/1
diff --git a/testsuite/testing.sh b/testsuite/testing.sh
index 8bd23d803..e253e1aa6 100755
--- a/testsuite/testing.sh
+++ b/testsuite/testing.sh
@@ -76,7 +76,7 @@ testing ()
   echo -ne "$5" | eval "$2" > actual
   RETVAL=$?
 
-  cmp expected actual > /dev/null 
+  cmp expected actual > /dev/null
   if [ $? -ne 0 ]
   then
     FAILCOUNT=$[$FAILCOUNT+1]
diff --git a/testsuite/tr/tr-works b/testsuite/tr/tr-works
index b7a6e8df7..9b2e90e42 100644
--- a/testsuite/tr/tr-works
+++ b/testsuite/tr/tr-works
@@ -7,7 +7,7 @@ run_tr ()
 tr_test ()
 {
 	run_tr "cbaab"		abc 		zyx
-	run_tr "TESTING A B C" 	'[A-Z]' 	'[a-z]' 
+	run_tr "TESTING A B C" 	'[A-Z]' 	'[a-z]'
 	run_tr "abc[]" 		"a[b" 		AXB
 	run_tr abc		'[:alpha:]' 	A-ZA-Z
 	run_tr abc56		'[:alnum:]' 	A-ZA-Zxxxxxxxxxx
diff --git a/testsuite/uniq.tests b/testsuite/uniq.tests
index a1b69c2e5..49d4bed9c 100755
--- a/testsuite/uniq.tests
+++ b/testsuite/uniq.tests
@@ -40,7 +40,7 @@ testing "uniq input - (specify stdout)" "uniq input -" \
 #-s skip chars
 #-c occurrences
 #-d dups only
-#-u 
+#-u
 
 # Test various command line options
 
diff --git a/util-linux/dmesg.c b/util-linux/dmesg.c
index 34519dfd1..c8b3aeeab 100644
--- a/util-linux/dmesg.c
+++ b/util-linux/dmesg.c
@@ -1,6 +1,6 @@
 /* vi: set sw=4 ts=4: */
 /*
- * 
+ *
  * dmesg - display/control kernel ring buffer.
  *
  * Copyright 2006 Rob Landley <rob@landley.net>
@@ -30,7 +30,7 @@ int dmesg_main(int argc, char *argv[])
 		if (0 > (len = klogctl(3 + (flags & 1), buf, len)))
 			bb_perror_msg_and_die("klogctl");
 
-		// Skip <#> at the start of lines, and make sure we end with a newline. 
+		// Skip <#> at the start of lines, and make sure we end with a newline.
 
 		if (ENABLE_FEATURE_DMESG_PRETTY) {
 			int last = '\n';
diff --git a/util-linux/fdisk.c b/util-linux/fdisk.c
index 8c7225816..55f716657 100644
--- a/util-linux/fdisk.c
+++ b/util-linux/fdisk.c
@@ -1914,9 +1914,9 @@ sgi_set_swappartition(int i)
 static int
 sgi_check_bootfile(const char* aFile)
 {
- 	if (strlen(aFile) < 3) /* "/a\n" is minimum */ {
- 		printf(_("\nInvalid Bootfile!\n"
- 			"\tThe bootfile must be an absolute non-zero pathname,\n"
+	if (strlen(aFile) < 3) /* "/a\n" is minimum */ {
+		printf(_("\nInvalid Bootfile!\n"
+			"\tThe bootfile must be an absolute non-zero pathname,\n"
 			"\te.g. \"/unix\" or \"/unix.save\".\n"));
 		return 0;
 	} else {
@@ -1931,7 +1931,7 @@ sgi_check_bootfile(const char* aFile)
 				return 0;
 			}
 		}
- 	}
+	}
 	if (strncmp(aFile, (char*)sgilabel->boot_file, 16)) {
 		printf(_("\n\tBe aware, that the bootfile is not checked for existence.\n\t"
 			 "SGI's default is \"/unix\" and for backup \"/unix.save\".\n"));
@@ -2505,7 +2505,7 @@ static const struct systypes sun_sys_types[] = {
 	{ "\x83" "Linux native" }, /* LINUX_NATIVE */
 	{ "\x8e" "Linux LVM"    }, /* 0x8e         */
 /* New (2.2.x) raid partition with autodetect using persistent superblock */
-	{ "\xfd" "Linux raid autodetect" }, /* 0xfd         */  
+	{ "\xfd" "Linux raid autodetect" }, /* 0xfd         */
 	{ NULL }
 };
 
@@ -3080,14 +3080,14 @@ sun_list_table(int xtra)
 			uint32_t start = SUN_SSWAP32(sunlabel->partitions[i].start_cylinder) * heads * sectors;
 			uint32_t len = SUN_SSWAP32(sunlabel->partitions[i].num_sectors);
 			printf("%s %c%c %9ld %9ld %9ld%c  %2x  %s\n",
-				partname(disk_device, i+1, w),			/* device */            
-				(sunlabel->infos[i].flags & 0x01) ? 'u' : ' ',  /* flags */             
-				(sunlabel->infos[i].flags & 0x10) ? 'r' : ' ',  			
-				(long) scround(start),                          /* start */             
-				(long) scround(start+len),                      /* end */               
-				(long) len / 2, len & 1 ? '+' : ' ',            /* odd flag on end */   
-				sunlabel->infos[i].id,                          /* type id */           
-				partition_type(sunlabel->infos[i].id));         /* type name */         
+				partname(disk_device, i+1, w),			/* device */
+				(sunlabel->infos[i].flags & 0x01) ? 'u' : ' ',  /* flags */
+				(sunlabel->infos[i].flags & 0x10) ? 'r' : ' ',
+				(long) scround(start),                          /* start */
+				(long) scround(start+len),                      /* end */
+				(long) len / 2, len & 1 ? '+' : ' ',            /* odd flag on end */
+				sunlabel->infos[i].id,                          /* type id */
+				partition_type(sunlabel->infos[i].id));         /* type name */
 		}
 	}
 }
@@ -4280,8 +4280,8 @@ get_partition(int warn, int max)
 	if (warn) {
 		if (
 			(
-				label_sun != current_label_type && 
-				label_sgi != current_label_type && 
+				label_sun != current_label_type &&
+				label_sgi != current_label_type &&
 				!pe->part_table->sys_ind
 			)
 #ifdef CONFIG_FEATURE_SUN_LABEL
diff --git a/util-linux/hexdump.c b/util-linux/hexdump.c
index 136243122..c2d79da5b 100644
--- a/util-linux/hexdump.c
+++ b/util-linux/hexdump.c
@@ -66,9 +66,9 @@ int hexdump_main(int argc, char **argv)
 				bb_dump_add(add_first);
 				bb_dump_add(add_strings[(int)(p - hexdump_opts)]);
 			} else if (ch == 'C') {
-			        bb_dump_add("\"%08.8_Ax\n\"");
+				bb_dump_add("\"%08.8_Ax\n\"");
 				bb_dump_add("\"%08.8_ax  \" 8/1 \"%02x \" \"  \" 8/1 \"%02x \" ");
-			        bb_dump_add("\"  |\" 16/1 \"%_p\" \"|\\n\"");
+				bb_dump_add("\"  |\" 16/1 \"%_p\" \"|\\n\"");
 			} else {
 				/* Sae a little bit of space below by omitting the 'else's. */
 				if (ch == 'e') {
diff --git a/util-linux/mdev.c b/util-linux/mdev.c
index b6ca00409..da4930f27 100644
--- a/util-linux/mdev.c
+++ b/util-linux/mdev.c
@@ -138,7 +138,7 @@ static void make_device(char *path, int delete)
 							// Command to run
 							char *s = "@$*", *s2;
 							if (!(s2 = strchr(s, *pos++))) {
-							  	// Force error
+								// Force error
 								field = 1;
 								break;
 							}
@@ -171,13 +171,13 @@ static void make_device(char *path, int delete)
 
 		if (major == bbg.root_major && minor == bbg.root_minor)
 			symlink(device_name, "root");
-	
+
 		if (ENABLE_FEATURE_MDEV_CONF) chown(device_name, uid, gid);
 	}
 	if (command) {
 		int rc;
 		char *s;
-		
+
 		s=xasprintf("MDEV=%s",device_name);
 		putenv(s);
 		rc = system(command);
diff --git a/util-linux/mkswap.c b/util-linux/mkswap.c
index b109f5ce1..8c307ec43 100644
--- a/util-linux/mkswap.c
+++ b/util-linux/mkswap.c
@@ -19,7 +19,7 @@ int mkswap_main(int argc, char *argv[])
 	if (argc!=2) bb_show_usage();
 
 	// Figure out how big the device is and announce our intentions.
-	
+
 	fd = xopen(argv[1],O_RDWR);
 	len = fdlength(fd);
 	pagesize = getpagesize();
diff --git a/util-linux/mount.c b/util-linux/mount.c
index ea96fb5b0..6176de3a1 100644
--- a/util-linux/mount.c
+++ b/util-linux/mount.c
@@ -673,7 +673,7 @@ get_mountport(struct sockaddr_in *server_addr,
 	p.pm_vers = version;
 	p.pm_prot = proto;
 	p.pm_port = port;
-	
+
 	while (pmap) {
 		if (pmap->pml_map.pm_prog != prog)
 			goto next;
@@ -1315,7 +1315,7 @@ static int singlemount(struct mntent *mp, int ignore_busy)
 		s = strrchr(mp->mnt_fsname, '\\');
 		if (s == mp->mnt_fsname+1) goto report_error;
 		*s = 0;
-	   	he = gethostbyname(mp->mnt_fsname+2);
+		he = gethostbyname(mp->mnt_fsname+2);
 		*s = '\\';
 		if (!he) goto report_error;
 
@@ -1517,7 +1517,7 @@ int mount_main(int argc, char **argv)
 		if (rc) bb_perror_msg_and_die("%s", argv[0]);
 		goto clean_up;
 	}
-	
+
 	// Open either fstab or mtab
 
 	if (parse_mount_options(cmdopts,0) & MS_REMOUNT)
diff --git a/util-linux/umount.c b/util-linux/umount.c
index 1a6b14ccc..f19586a0d 100644
--- a/util-linux/umount.c
+++ b/util-linux/umount.c
@@ -76,7 +76,7 @@ int umount_main(int argc, char **argv)
 		m = 0;
 		if (!argc) bb_show_usage();
 	}
-	
+
 	// Loop through everything we're supposed to umount, and do so.
 	for (;;) {
 		int curstat;