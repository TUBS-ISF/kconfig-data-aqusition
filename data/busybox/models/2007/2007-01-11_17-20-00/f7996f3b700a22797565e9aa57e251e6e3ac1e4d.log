"2007-01-11 17:20:00 +0000"
diff --git a/Makefile b/Makefile
index ca11f1532..e3bf032da 100644
--- a/Makefile
+++ b/Makefile
@@ -71,7 +71,7 @@ endif
 # In both cases the working directory must be the root of the kernel src.
 # 1) O=
 # Use "make O=dir/to/store/output/files/"
-# 
+#
 # 2) Set KBUILD_OUTPUT
 # Set the environment variable KBUILD_OUTPUT to point to the directory
 # where the output files shall be placed.
@@ -145,7 +145,7 @@ export srctree objtree VPATH TOPDIR
 # SUBARCH tells the usermode build what the underlying arch is.  That is set
 # first, and if a usermode build is happening, the "ARCH=um" on the command
 # line overrides the setting of ARCH below.  If a native build is happening,
-# then ARCH is assigned, getting whatever value it gets normally, and 
+# then ARCH is assigned, getting whatever value it gets normally, and
 # SUBARCH is subsequently ignored.
 
 SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
@@ -229,7 +229,7 @@ export KBUILD_CHECKSRC KBUILD_SRC KBUILD_EXTMOD
 #         cmd_cc_o_c       = $(CC) $(c_flags) -c -o $@ $<
 #
 # If $(quiet) is empty, the whole command will be printed.
-# If it is set to "quiet_", only the short version will be printed. 
+# If it is set to "quiet_", only the short version will be printed.
 # If it is set to "silent_", nothing wil be printed at all, since
 # the variable $(silent_cmd_cc_o_c) doesn't exist.
 #
@@ -313,7 +313,7 @@ export	VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION \
 	HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
 
 export CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS LDFLAGS
-export CFLAGS CFLAGS_KERNEL CFLAGS_MODULE 
+export CFLAGS CFLAGS_KERNEL CFLAGS_MODULE
 export AFLAGS AFLAGS_KERNEL AFLAGS_MODULE
 
 # When compiling out-of-tree modules, put MODVERDIR in the module
@@ -351,7 +351,7 @@ endif
 # catch them early, and hand them over to scripts/kconfig/Makefile
 # It is allowed to specify more targets when calling make, including
 # mixing *config targets and build targets.
-# For example 'make oldconfig all'. 
+# For example 'make oldconfig all'.
 # Detect when mixed targets is specified, and make a second invocation
 # of make so .config is not included in this case either (for *config).
 
@@ -567,7 +567,7 @@ quiet_cmd_busybox__ ?= LINK    $@
       -Wl,--start-group $(busybox-all) -Wl,--end-group
 
 # Generate System.map
-quiet_cmd_sysmap = SYSMAP 
+quiet_cmd_sysmap = SYSMAP
       cmd_sysmap = $(CONFIG_SHELL) $(srctree)/scripts/mksysmap
 
 # Link of busybox
@@ -623,7 +623,7 @@ endef
 # First command is ':' to allow us to use + in front of this rule
 cmd_ksym_ld = $(cmd_busybox__)
 define rule_ksym_ld
-	: 
+	:
 	+$(call cmd,busybox_version)
 	$(call cmd,busybox__)
 	$(Q)echo 'cmd_$@ := $(cmd_busybox__)' > $(@D)/.$(@F).cmd
@@ -674,7 +674,7 @@ busybox: busybox_unstripped
 	$(Q)$(STRIP) -s --remove-section=.note --remove-section=.comment \
 		busybox_unstripped -o $@
 
-# The actual objects are generated when descending, 
+# The actual objects are generated when descending,
 # make sure no implicit rule kicks in
 $(sort $(busybox-all)): $(busybox-dirs) ;
 
@@ -707,7 +707,7 @@ _localver = $(foreach f, $(__localver), $(if $(findstring ~, $(f)),,$(f)))
 localver = $(subst $(space),, \
 	   $(shell cat /dev/null $(_localver)) \
 	   $(patsubst "%",%,$(CONFIG_LOCALVERSION)))
-	       
+
 # If CONFIG_LOCALVERSION_AUTO is set scripts/setlocalversion is called
 # and if the SCM is know a tag from the SCM is appended.
 # The appended tag is determinded by the SCM used.
@@ -1235,7 +1235,7 @@ endif
 	$(build)=$(build-dir) $(@:.ko=.o)
 	$(Q)$(MAKE) -rR -f $(srctree)/scripts/Makefile.modpost
 
-# FIXME Should go into a make.lib or something 
+# FIXME Should go into a make.lib or something
 # ===========================================================================
 
 quiet_cmd_rmdirs = $(if $(wildcard $(rm-dirs)),CLEAN   $(wildcard $(rm-dirs)))
diff --git a/archival/gzip.c b/archival/gzip.c
index bfe762128..b6705425e 100644
--- a/archival/gzip.c
+++ b/archival/gzip.c
@@ -792,13 +792,13 @@ static void check_match(IPos start, IPos match, int length)
 typedef uch extra_bits_t;
 
 /* extra bits for each length code */
-static const extra_bits_t extra_lbits[LENGTH_CODES]= { 
+static const extra_bits_t extra_lbits[LENGTH_CODES]= {
 	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4,
 	4, 4, 5, 5, 5, 5, 0
 };
 
 /* extra bits for each distance code */
-static const extra_bits_t extra_dbits[D_CODES] = { 
+static const extra_bits_t extra_dbits[D_CODES] = {
 	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
 	10, 10, 11, 11, 12, 12, 13, 13
 };
diff --git a/archival/tar.c b/archival/tar.c
index ee9007c47..2ba51adf7 100644
--- a/archival/tar.c
+++ b/archival/tar.c
@@ -673,7 +673,7 @@ static void handle_SIGCHLD(int status)
 	if (WIFEXITED(status) && WEXITSTATUS(status)==0)
 		/* child exited with 0 */
 		return;
-	/* Cannot happen? 
+	/* Cannot happen?
 	if(!WIFSIGNALED(status) && !WIFEXITED(status)) return; */
 	child_error = 1;
 }
diff --git a/coreutils/chown.c b/coreutils/chown.c
index 2f48610a8..da6b6abdd 100644
--- a/coreutils/chown.c
+++ b/coreutils/chown.c
@@ -93,7 +93,7 @@ int chown_main(int argc, char **argv)
 				fileAction,     // file action
 				fileAction,     // dir action
 				NULL,           // user data
-				0)              // depth 
+				0)              // depth
 		) {
 			retval = EXIT_FAILURE;
 		}
diff --git a/coreutils/uudecode.c b/coreutils/uudecode.c
index 06512119e..dc7d2aef8 100644
--- a/coreutils/uudecode.c
+++ b/coreutils/uudecode.c
@@ -146,7 +146,7 @@ int uudecode_main(int argc, char **argv)
 		FILE *dst_stream;
 		int mode;
 		int ret;
-		
+
 		if (strncmp(line, "begin-base64 ", 13) == 0) {
 			line_ptr = line + 13;
 			decode_fn_ptr = read_base64;
diff --git a/docs/busybox.net/FAQ.html b/docs/busybox.net/FAQ.html
index c751f7521..c07be9027 100644
--- a/docs/busybox.net/FAQ.html
+++ b/docs/busybox.net/FAQ.html
@@ -82,7 +82,7 @@ have additions to this FAQ document, we would love to add them,
     to determine which applet to run, as shown above.
 </p>
 <p>
-    BusyBox also has a feature called the 
+    BusyBox also has a feature called the
     <a name="standalone_shell">"standalone shell"</a>, where the busybox
     shell runs any built-in applets before checking the command path.  This
     feature is also enabled by "make allyesconfig", and to try it out run
@@ -261,7 +261,7 @@ within each applet.  More build coverage testing.</p></li>
 
 <hr />
 <p>
-<h2><a name="external">where can i find other small utilities since busybox 
+<h2><a name="external">where can i find other small utilities since busybox
 	does not include the features i want?</a></h2>
 <p>
 	we maintain such a <a href="tinyutils.html">list</a> on this site!
@@ -941,7 +941,7 @@ text console scrolling...)</p>
 
 <p>So will data always be read from the far end of a pipe at the
 same chunk sizes it was written in?  Nope.  Don't rely on that.  For one
-counterexample, see <a href="http://www.faqs.org/rfcs/rfc896.html">rfc 896 
+counterexample, see <a href="http://www.faqs.org/rfcs/rfc896.html">rfc 896
 for Nagle's algorithm</a>, which waits a fraction of a second or so before
 sending out small amounts of data through a TCP/IP connection in case more
 data comes in that can be merged into the same packet.  (In case you were
@@ -1089,7 +1089,7 @@ aaronl   :Aaron Lehmann
 beppu    :John Beppu
 dwhedon  :David Whedon
 erik     :Erik Andersen
-gfeldman :Gennady Feldman 
+gfeldman :Gennady Feldman
 jimg     :Jim Gleason
 kraai    :Matt Kraai
 markw    :Mark Whitley
diff --git a/docs/busybox.net/news.html b/docs/busybox.net/news.html
index 5492d6767..cdffd48eb 100644
--- a/docs/busybox.net/news.html
+++ b/docs/busybox.net/news.html
@@ -28,7 +28,7 @@
     <li>grep: added -r, fixed -h
     <li>watch: make it exec child like standard one does (was totally
         incompatible)
-    <li>tar: fix limitations which were preventing bbox tar usage 
+    <li>tar: fix limitations which were preventing bbox tar usage
         on big directories: long names and linknames, pax headers
         (Linux kernel tarballs have that). Fixed a number of obscure bugs.
         Raised max file limit (now 64Gb). Security fixes (/../ attacks).
diff --git a/docs/sigint.htm b/docs/sigint.htm
index 6fe76bbef..e230f4df7 100644
--- a/docs/sigint.htm
+++ b/docs/sigint.htm
@@ -40,7 +40,7 @@ scripts using <code>Control-C</code>. Or have interactive applications
 that don't behave right when sending SIGINT. Examples are emacs'es
 that die on Control-g or shellscript statements that sometimes are
 executed and sometimes not, apparently not determined by the user's
-intention. 
+intention.
 
 
 </td></tr><tr><th valign=top align=left>Required knowledge: </th>
@@ -101,7 +101,7 @@ just exit.
 
 <p>Now imagine the user hits C-c while a shellscript is executing its
 first program. The following programs receive SIGINT: program1 and
-also the shell executing the script. program1 exits. 
+also the shell executing the script. program1 exits.
 
 <p>But what should the shell do? If we say that it is only the
 innermost's programs business to react on SIGINT, the shell will do
@@ -351,7 +351,7 @@ that do not properly communicate the required information up to the
 calling program.
 
 <p>Unless a program messes with signal handling, the system does this
-automatically. 
+automatically.
 
 <p>There are programs that want to exit on SIGINT, but they don't let
 the system do the automatic exit, because they want to do some
@@ -425,7 +425,7 @@ Notes:
 special numeric value. People often assume this since the manuals for
 shells often list some return value for exactly this. But this is just
 a convention for your shell script. It does not work from one UNIX API
-program to another. 
+program to another.
 
 <P>All that happens is that the shell sets the "$?" variable to a
 special numeric value for the convenience of your script, because your
@@ -571,7 +571,7 @@ comments the scripts echo.
 <tr valign=top align=left>
 <td>IUE</td>
 <td>The shell executing a script exits immediately if it receives
-SIGINT.</td> 
+SIGINT.</td>
 <td>4.4BSD ash (ash), NetBSD, FreeBSD prior to 3.0/22.8</td>
 <td>The editor session is lost and subsequent commands are not
 executed.</td>
@@ -605,7 +605,7 @@ will further commands from the script be executed. </td>
 signal (either it had the default handler for SIGINT or it killed
 itself).  </td>
 <td>bash (Linux /bin/sh), most commercial /bin/sh, FreeBSD /bin/sh
-from 3.0/2.2.8.</td> 
+from 3.0/2.2.8.</td>
 <td>The editor continues as normal and subsequent commands are
 executed. </td>
 <td>The editor continues as normal and subsequent commands are
@@ -615,7 +615,7 @@ child exits, but only if the child exited with signal status. If
 the child did a normal exit (even if it received SIGINT, but catches
 it), the script will continue. </td>
 <td>The child must be implemented right, or the user will not be able
-to break shell scripts reliably.</td> 
+to break shell scripts reliably.</td>
 </tr>
 
 </table>
diff --git a/docs/tar_pax.txt b/docs/tar_pax.txt
index 8a3f1e755..e56c27b16 100644
--- a/docs/tar_pax.txt
+++ b/docs/tar_pax.txt
@@ -4,197 +4,197 @@ for everything (filename, uid, filesize etc) which can overflow.
 
 pax Header Block
 
-The pax header block shall be identical to the ustar header block 
-described in ustar Interchange Format, except that two additional 
+The pax header block shall be identical to the ustar header block
+described in ustar Interchange Format, except that two additional
 typeflag values are defined:
 
 x
-    Represents extended header records for the following file in 
+    Represents extended header records for the following file in
 the archive (which shall have its own ustar header block).
 
 g
-    Represents global extended header records for the following 
-files in the archive. Each value shall affect all subsequent files 
-that do not override that value in their own extended header 
-record and until another global extended header record is reached 
-that provides another value for the same field. The typeflag g 
-global headers should not be used with interchange media that 
+    Represents global extended header records for the following
+files in the archive. Each value shall affect all subsequent files
+that do not override that value in their own extended header
+record and until another global extended header record is reached
+that provides another value for the same field. The typeflag g
+global headers should not be used with interchange media that
 could suffer partial data loss in transporting the archive.
 
-For both of these types, the size field shall be the size of the 
-extended header records in octets. The other fields in the header 
-block are not meaningful to this version of the pax utility. 
-However, if this archive is read by a pax utility conforming to 
-the ISO POSIX-2:1993 standard, the header block fields are used to 
-create a regular file that contains the extended header records as 
-data. Therefore, header block field values should be selected to 
+For both of these types, the size field shall be the size of the
+extended header records in octets. The other fields in the header
+block are not meaningful to this version of the pax utility.
+However, if this archive is read by a pax utility conforming to
+the ISO POSIX-2:1993 standard, the header block fields are used to
+create a regular file that contains the extended header records as
+data. Therefore, header block field values should be selected to
 provide reasonable file access to this regular file.
 
-A further difference from the ustar header block is that data 
-blocks for files of typeflag 1 (the digit one) (hard link) may be 
-included, which means that the size field may be greater than 
+A further difference from the ustar header block is that data
+blocks for files of typeflag 1 (the digit one) (hard link) may be
+included, which means that the size field may be greater than
 zero.
 
 pax Extended Header
 
-An extended header shall consist of one or more records, each 
+An extended header shall consist of one or more records, each
 constructed as follows:
 
 "%d %s=%s\n", <length>, <keyword>, <value>
 
-The <length> field shall be the decimal length of the extended 
-header record in octets, including length string itself and the 
+The <length> field shall be the decimal length of the extended
+header record in octets, including length string itself and the
 trailing <newline>.
 
 [skip]
 
 atime
-    The file access time for the following file(s), equivalent to 
-the value of the st_atime member of the stat structure for a file, 
-as described by the stat() function. The access time shall be 
-restored if the process has the appropriate privilege required to 
-do so. The format of the <value> shall be as described in pax 
+    The file access time for the following file(s), equivalent to
+the value of the st_atime member of the stat structure for a file,
+as described by the stat() function. The access time shall be
+restored if the process has the appropriate privilege required to
+do so. The format of the <value> shall be as described in pax
 Extended Header File Times.
 
 charset
-    The name of the character set used to encode the data in the 
+    The name of the character set used to encode the data in the
 following file(s).
 
-    The encoding is included in an extended header for information 
-only; when pax is used as described in IEEE Std 1003.1-2001, it 
-shall not translate the file data into any other encoding. The 
+    The encoding is included in an extended header for information
+only; when pax is used as described in IEEE Std 1003.1-2001, it
+shall not translate the file data into any other encoding. The
 BINARY entry indicates unencoded binary data.
 
-    When used in write or copy mode, it is implementation-defined 
+    When used in write or copy mode, it is implementation-defined
 whether pax includes a charset extended header record for a file.
 
 comment
-    A series of characters used as a comment. All characters in 
+    A series of characters used as a comment. All characters in
 the <value> field shall be ignored by pax.
 
 gid
-    The group ID of the group that owns the file, expressed as a 
-decimal number using digits from the ISO/IEC 646:1991 standard. 
-This record shall override the gid field in the following header 
-block(s). When used in write or copy mode, pax shall include a gid 
-extended header record for each file whose group ID is greater 
+    The group ID of the group that owns the file, expressed as a
+decimal number using digits from the ISO/IEC 646:1991 standard.
+This record shall override the gid field in the following header
+block(s). When used in write or copy mode, pax shall include a gid
+extended header record for each file whose group ID is greater
 than 2097151 (octal 7777777).
 
 gname
-    The group of the file(s), formatted as a group name in the 
-group database. This record shall override the gid and gname 
-fields in the following header block(s), and any gid extended 
-header record. When used in read, copy, or list mode, pax shall 
-translate the name from the UTF-8 encoding in the header record to 
-the character set appropriate for the group database on the 
-receiving system. If any of the UTF-8 characters cannot be 
-translated, and if the -o invalid= UTF-8 option is not specified, 
-the results are implementation-defined. When used in write or copy 
-mode, pax shall include a gname extended header record for each 
-file whose group name cannot be represented entirely with the 
+    The group of the file(s), formatted as a group name in the
+group database. This record shall override the gid and gname
+fields in the following header block(s), and any gid extended
+header record. When used in read, copy, or list mode, pax shall
+translate the name from the UTF-8 encoding in the header record to
+the character set appropriate for the group database on the
+receiving system. If any of the UTF-8 characters cannot be
+translated, and if the -o invalid= UTF-8 option is not specified,
+the results are implementation-defined. When used in write or copy
+mode, pax shall include a gname extended header record for each
+file whose group name cannot be represented entirely with the
 letters and digits of the portable character set.
 
 linkpath
-    The pathname of a link being created to another file, of any 
-type, previously archived. This record shall override the linkname 
-field in the following ustar header block(s). The following ustar 
-header block shall determine the type of link created. If typeflag 
-of the following header block is 1, it shall be a hard link. If 
-typeflag is 2, it shall be a symbolic link and the linkpath value 
-shall be the contents of the symbolic link. The pax utility shall 
-translate the name of the link (contents of the symbolic link) 
-from the UTF-8 encoding to the character set appropriate for the 
-local file system. When used in write or copy mode, pax shall 
-include a linkpath extended header record for each link whose 
-pathname cannot be represented entirely with the members of the 
+    The pathname of a link being created to another file, of any
+type, previously archived. This record shall override the linkname
+field in the following ustar header block(s). The following ustar
+header block shall determine the type of link created. If typeflag
+of the following header block is 1, it shall be a hard link. If
+typeflag is 2, it shall be a symbolic link and the linkpath value
+shall be the contents of the symbolic link. The pax utility shall
+translate the name of the link (contents of the symbolic link)
+from the UTF-8 encoding to the character set appropriate for the
+local file system. When used in write or copy mode, pax shall
+include a linkpath extended header record for each link whose
+pathname cannot be represented entirely with the members of the
 portable character set other than NUL.
 
 mtime
-    The file modification time of the following file(s), 
-equivalent to the value of the st_mtime member of the stat 
-structure for a file, as described in the stat() function. This 
-record shall override the mtime field in the following header 
-block(s). The modification time shall be restored if the process 
-has the appropriate privilege required to do so. The format of the 
+    The file modification time of the following file(s),
+equivalent to the value of the st_mtime member of the stat
+structure for a file, as described in the stat() function. This
+record shall override the mtime field in the following header
+block(s). The modification time shall be restored if the process
+has the appropriate privilege required to do so. The format of the
 <value> shall be as described in pax Extended Header File Times.
 
 path
-    The pathname of the following file(s). This record shall 
-override the name and prefix fields in the following header 
-block(s). The pax utility shall translate the pathname of the file 
-from the UTF-8 encoding to the character set appropriate for the 
+    The pathname of the following file(s). This record shall
+override the name and prefix fields in the following header
+block(s). The pax utility shall translate the pathname of the file
+from the UTF-8 encoding to the character set appropriate for the
 local file system.
 
-    When used in write or copy mode, pax shall include a path 
-extended header record for each file whose pathname cannot be 
-represented entirely with the members of the portable character 
+    When used in write or copy mode, pax shall include a path
+extended header record for each file whose pathname cannot be
+represented entirely with the members of the portable character
 set other than NUL.
 
 realtime.any
-    The keywords prefixed by "realtime." are reserved for future 
+    The keywords prefixed by "realtime." are reserved for future
 standardization.
 
 security.any
-    The keywords prefixed by "security." are reserved for future 
+    The keywords prefixed by "security." are reserved for future
 standardization.
 
 size
-    The size of the file in octets, expressed as a decimal number 
-using digits from the ISO/IEC 646:1991 standard. This record shall 
-override the size field in the following header block(s). When 
-used in write or copy mode, pax shall include a size extended 
-header record for each file with a size value greater than 
+    The size of the file in octets, expressed as a decimal number
+using digits from the ISO/IEC 646:1991 standard. This record shall
+override the size field in the following header block(s). When
+used in write or copy mode, pax shall include a size extended
+header record for each file with a size value greater than
 8589934591 (octal 77777777777).
 
 uid
-    The user ID of the file owner, expressed as a decimal number 
-using digits from the ISO/IEC 646:1991 standard. This record shall 
-override the uid field in the following header block(s). When used 
-in write or copy mode, pax shall include a uid extended header 
-record for each file whose owner ID is greater than 2097151 (octal 
+    The user ID of the file owner, expressed as a decimal number
+using digits from the ISO/IEC 646:1991 standard. This record shall
+override the uid field in the following header block(s). When used
+in write or copy mode, pax shall include a uid extended header
+record for each file whose owner ID is greater than 2097151 (octal
 7777777).
 
 uname
-    The owner of the following file(s), formatted as a user name 
-in the user database. This record shall override the uid and uname 
-fields in the following header block(s), and any uid extended 
-header record. When used in read, copy, or list mode, pax shall 
-translate the name from the UTF-8 encoding in the header record to 
-the character set appropriate for the user database on the 
-receiving system. If any of the UTF-8 characters cannot be 
-translated, and if the -o invalid= UTF-8 option is not specified, 
-the results are implementation-defined. When used in write or copy 
-mode, pax shall include a uname extended header record for each 
-file whose user name cannot be represented entirely with the 
+    The owner of the following file(s), formatted as a user name
+in the user database. This record shall override the uid and uname
+fields in the following header block(s), and any uid extended
+header record. When used in read, copy, or list mode, pax shall
+translate the name from the UTF-8 encoding in the header record to
+the character set appropriate for the user database on the
+receiving system. If any of the UTF-8 characters cannot be
+translated, and if the -o invalid= UTF-8 option is not specified,
+the results are implementation-defined. When used in write or copy
+mode, pax shall include a uname extended header record for each
+file whose user name cannot be represented entirely with the
 letters and digits of the portable character set.
 
-If the <value> field is zero length, it shall delete any header 
-block field, previously entered extended header value, or global 
+If the <value> field is zero length, it shall delete any header
+block field, previously entered extended header value, or global
 extended header value of the same name.
 
-If a keyword in an extended header record (or in a -o 
-option-argument) overrides or deletes a corresponding field in the 
-ustar header block, pax shall ignore the contents of that header 
+If a keyword in an extended header record (or in a -o
+option-argument) overrides or deletes a corresponding field in the
+ustar header block, pax shall ignore the contents of that header
 block field.
 
-Unlike the ustar header block fields, NULs shall not delimit 
-<value>s; all characters within the <value> field shall be 
-considered data for the field. None of the length limitations of 
-the ustar header block fields in ustar Header Block shall apply to 
+Unlike the ustar header block fields, NULs shall not delimit
+<value>s; all characters within the <value> field shall be
+considered data for the field. None of the length limitations of
+the ustar header block fields in ustar Header Block shall apply to
 the extended header records.
 
 pax Extended Header File Times
 
-Time records shall be formatted as a decimal representation of the 
-time in seconds since the Epoch. If a period ( '.' ) decimal point 
-character is present, the digits to the right of the point shall 
-represent the units of a subsecond timing granularity. In read or 
-copy mode, the pax utility shall truncate the time of a file to 
-the greatest value that is not greater than the input header 
-file time. In write or copy mode, the pax utility shall output a 
-time exactly if it can be represented exactly as a decimal number, 
-and otherwise shall generate only enough digits so that the same 
-time shall be recovered if the file is extracted on a system whose 
+Time records shall be formatted as a decimal representation of the
+time in seconds since the Epoch. If a period ( '.' ) decimal point
+character is present, the digits to the right of the point shall
+represent the units of a subsecond timing granularity. In read or
+copy mode, the pax utility shall truncate the time of a file to
+the greatest value that is not greater than the input header
+file time. In write or copy mode, the pax utility shall output a
+time exactly if it can be represented exactly as a decimal number,
+and otherwise shall generate only enough digits so that the same
+time shall be recovered if the file is extracted on a system whose
 underlying implementation supports the same time granularity.
 
 Example from Linux kernel archive tarball:
diff --git a/e2fsprogs/old_e2fsprogs/blkid/probe.h b/e2fsprogs/old_e2fsprogs/blkid/probe.h
index 78f796419..0fd16a771 100644
--- a/e2fsprogs/old_e2fsprogs/blkid/probe.h
+++ b/e2fsprogs/old_e2fsprogs/blkid/probe.h
@@ -238,7 +238,7 @@ struct ocfs_volume_header {
 
 struct ocfs_volume_label {
 	unsigned char	disk_lock[48];
-	char		label[64];	
+	char		label[64];
 	unsigned char	label_len[2];
 	unsigned char  vol_id[16];
 	unsigned char  vol_id_len[2];
diff --git a/editors/awk.c b/editors/awk.c
index f8b26662a..9ed2781be 100644
--- a/editors/awk.c
+++ b/editors/awk.c
@@ -1930,11 +1930,11 @@ static var *exec_builtin(node *op, var *res)
 		s[n] = '\0';
 		setvar_p(res, s);
 		break;
-		
+
 	case B_an:
 		setvar_i(res, (long)getvar_i(av[0]) & (long)getvar_i(av[1]));
 		break;
-		
+
 	case B_co:
 		setvar_i(res, ~(long)getvar_i(av[0]));
 		break;
diff --git a/include/libbb.h b/include/libbb.h
index c4d187e00..704f34e56 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -4,7 +4,7 @@
  *
  * Based in part on code from sash, Copyright (c) 1999 by David I. Bell
  * Permission has been granted to redistribute this code under the GPL.
- * 
+ *
  * Licensed under the GPL version 2, see the file LICENSE in this tarball.
  */
 #ifndef	__LIBBUSYBOX_H__
diff --git a/libbb/copy_file.c b/libbb/copy_file.c
index 0135831fe..632064eaa 100644
--- a/libbb/copy_file.c
+++ b/libbb/copy_file.c
@@ -144,7 +144,7 @@ int copy_file(const char *source, const char *dest, int flags)
 
 	} else if (S_ISREG(source_stat.st_mode)
 	// Huh? DEREF uses stat, which never returns links IIRC...
-	 || (FLAGS_DEREF && S_ISLNK(source_stat.st_mode)) 
+	 || (FLAGS_DEREF && S_ISLNK(source_stat.st_mode))
 	) {
 		int src_fd;
 		int dst_fd;
diff --git a/libbb/copyfd.c b/libbb/copyfd.c
index 17bf4fbc2..0d0ec2232 100644
--- a/libbb/copyfd.c
+++ b/libbb/copyfd.c
@@ -60,7 +60,7 @@ static off_t bb_full_fd_action(int src_fd, int dst_fd, off_t size)
 			size -= rd;
 			if (!size) {
 				/* 'size' bytes copied - all done */
-				status = 0; 
+				status = 0;
 				break;
 			}
 		}
diff --git a/libbb/get_line_from_file.c b/libbb/get_line_from_file.c
index a27693f66..5078f49ea 100644
--- a/libbb/get_line_from_file.c
+++ b/libbb/get_line_from_file.c
@@ -11,7 +11,7 @@
 
 #include "libbb.h"
 
-/* This function reads an entire line from a text file, up to a newline 
+/* This function reads an entire line from a text file, up to a newline
  * or NUL byte, inclusive.  It returns a malloc'ed char * which must be
  * stored and free'ed by the caller.  If end is null '\n' isn't considered
  * end of line.  If end isn't null, length of the chunk read is stored in it. */
diff --git a/libbb/getopt32.c b/libbb/getopt32.c
index 50343fdab..f93438df0 100644
--- a/libbb/getopt32.c
+++ b/libbb/getopt32.c
@@ -79,7 +79,7 @@ const struct option *applet_long_options
         (see getopt(3))
 
         static const struct option applet_long_options[] = {
-        	//name,has_arg,flag,val 
+        	//name,has_arg,flag,val
         	{ "verbose", 0, 0, 'v' },
         	{ 0, 0, 0, 0 }
         };
diff --git a/libbb/procps.c b/libbb/procps.c
index 017710ff4..a799bf927 100644
--- a/libbb/procps.c
+++ b/libbb/procps.c
@@ -141,7 +141,7 @@ procps_status_t* procps_scan(procps_status_t* sp, int flags)
 			sp->uid = sb.st_uid;
 			sp->gid = sb.st_gid;
 		}
-	
+
 		if (flags & PSSCAN_STAT) {
 			char *cp;
 			/* see proc(5) for some details on this */
diff --git a/libbb/recursive_action.c b/libbb/recursive_action.c
index 121a3dffd..25a87b88e 100644
--- a/libbb/recursive_action.c
+++ b/libbb/recursive_action.c
@@ -33,7 +33,7 @@ static int true_action(const char *fileName, struct stat *statbuf, void* userDat
  *
  * if !depthFirst, dirAction return value of 0 (FALSE) or 2 (SKIP)
  * prevents recursion into that directory, instead
- * recursive_action() returns 0 (if FALSE) or 1 (if SKIP). 
+ * recursive_action() returns 0 (if FALSE) or 1 (if SKIP).
  *
  * followLinks=0/1 differs mainly in handling of links to dirs.
  * 0: lstat(statbuf). Calls fileAction on link name even if points to dir.
diff --git a/loginutils/adduser.c b/loginutils/adduser.c
index 5766e5de3..ea0b89a9b 100644
--- a/loginutils/adduser.c
+++ b/loginutils/adduser.c
@@ -115,7 +115,7 @@ static int adduser(struct passwd *p, unsigned long flags)
 	fseek(file, 0, SEEK_END);
 	fprintf(file, "%s:!:%ld:%d:%d:%d:::\n",
 			p->pw_name,             /* username */
-			time(NULL) / 86400,     /* sp->sp_lstchg */ 
+			time(NULL) / 86400,     /* sp->sp_lstchg */
 			0,                      /* sp->sp_min */
 			99999,                  /* sp->sp_max */
 			7);                     /* sp->sp_warn */
diff --git a/loginutils/deluser.c b/loginutils/deluser.c
index 869b22013..d07fd22ac 100644
--- a/loginutils/deluser.c
+++ b/loginutils/deluser.c
@@ -19,7 +19,7 @@ static void del_line_matching(const char *login, const char *filename)
 	int len = strlen(login);
 	int found = 0;
 	llist_t *plist = NULL;
-	
+
 	passwd = fopen_or_warn(filename, "r");
 	if (!passwd) return;
 
diff --git a/networking/dnsd.c b/networking/dnsd.c
index 6f1ec0ea4..1fb9ccfe5 100644
--- a/networking/dnsd.c
+++ b/networking/dnsd.c
@@ -230,7 +230,7 @@ static int table_lookup(uint16_t type, uint8_t * as, uint8_t * qs)
 		char *p,*q;
 		q = (char *)&(qs[1]);
 		p = &(d->name[1]);
-		fprintf(stderr, "\n%s: %d/%d p:%s q:%s %d", 
+		fprintf(stderr, "\n%s: %d/%d p:%s q:%s %d",
 			__FUNCTION__, strlen(p), (int)(d->name[0]), p, q, strlen(q));
 #endif
 		if (type == REQ_A) { /* search by host name */
@@ -247,7 +247,7 @@ static int table_lookup(uint16_t type, uint8_t * as, uint8_t * qs)
 #endif
 					return 0;
 			}
-		} else 
+		} else
 		if (type == REQ_PTR) { /* search by IP-address */
 			if (!strncmp((char*)&d->rip[1], (char*)&qs[1], strlen(d->rip)-1)) {
 				strcpy((char *)as, d->name);
diff --git a/networking/fakeidentd.c b/networking/fakeidentd.c
index 8967a7a38..7eac48065 100644
--- a/networking/fakeidentd.c
+++ b/networking/fakeidentd.c
@@ -240,68 +240,68 @@ int fakeidentd_main(int argc, char **argv)
 
 	/* main loop where we process all events and never exit */
 	while (1) {
-	fd_set rfds = G.readfds;
-	struct timeval tv = { 15, 0 };
-	int i;
-	int tim = time(NULL);
-
-	select(G.conncnt + FCS, &rfds, NULL, NULL, G.conncnt? &tv: NULL);
-
-	for (i = G.conncnt - 1; i >= 0; i--) {
-		int s = i + FCS;
-
-		if (FD_ISSET(s, &rfds)) {
-			char *buf = conns[i].buf;
-			unsigned int len = conns[i].len;
-			unsigned int l;
-
-			if ((l = read(s, buf + len, sizeof(conns[0].buf) - len)) > 0) {
-				if (checkInput(buf, len, l)) {
-					reply(s, buf);
-					goto deleteconn;
-				} else if (len + l >= sizeof(conns[0].buf)) {
-					replyError(s, "X-INVALID-REQUEST");
-					goto deleteconn;
+		fd_set rfds = G.readfds;
+		struct timeval tv = { 15, 0 };
+		int i;
+		int tim = time(NULL);
+
+		select(G.conncnt + FCS, &rfds, NULL, NULL, G.conncnt? &tv: NULL);
+
+		for (i = G.conncnt - 1; i >= 0; i--) {
+			int s = i + FCS;
+
+			if (FD_ISSET(s, &rfds)) {
+				char *buf = conns[i].buf;
+				unsigned int len = conns[i].len;
+				unsigned int l;
+
+				if ((l = read(s, buf + len, sizeof(conns[0].buf) - len)) > 0) {
+					if (checkInput(buf, len, l)) {
+						reply(s, buf);
+						goto deleteconn;
+					} else if (len + l >= sizeof(conns[0].buf)) {
+						replyError(s, "X-INVALID-REQUEST");
+						goto deleteconn;
+					} else {
+						conns[i].len += l;
+					}
 				} else {
-					conns[i].len += l;
+					goto deleteconn;
 				}
-			} else {
-				goto deleteconn;
-			}
 
-			conns[i].lasttime = tim;
-			continue;
+				conns[i].lasttime = tim;
+				continue;
 
 deleteconn:
-			deleteConn(s);
-		} else {
-			/* implement as time_after() in linux kernel sources ... */
-			if (conns[i].lasttime + MAXIDLETIME <= tim) {
-				replyError(s, "X-TIMEOUT");
 				deleteConn(s);
+			} else {
+				/* implement as time_after() in linux kernel sources ... */
+				if (conns[i].lasttime + MAXIDLETIME <= tim) {
+					replyError(s, "X-TIMEOUT");
+					deleteConn(s);
+				}
 			}
 		}
-	}
 
-	if (FD_ISSET(0, &rfds)) {
-		int s = accept(0, NULL, 0);
+		if (FD_ISSET(0, &rfds)) {
+			int s = accept(0, NULL, 0);
 
-		if (s < 0) {
-			if (errno != EINTR) /* EINTR */
-				bb_perror_msg("accept");
-		} else {
-			if (G.conncnt == MAXCONNS)
-				i = closeOldest();
-			else
-				i = G.conncnt++;
+			if (s < 0) {
+				if (errno != EINTR) /* EINTR */
+					bb_perror_msg("accept");
+			} else {
+				if (G.conncnt == MAXCONNS)
+					i = closeOldest();
+				else
+					i = G.conncnt++;
 
-			movefd(s, i + FCS); /* move if not already there */
-			FD_SET(i + FCS, &G.readfds);
+				movefd(s, i + FCS); /* move if not already there */
+				FD_SET(i + FCS, &G.readfds);
 
-			conns[i].len = 0;
-			conns[i].lasttime = time(NULL);
+				conns[i].len = 0;
+				conns[i].lasttime = time(NULL);
+			}
 		}
-	}
 	} /* end of while (1) */
 
 	return 0;
diff --git a/networking/httpd.c b/networking/httpd.c
index da33146de..818590f78 100644
--- a/networking/httpd.c
+++ b/networking/httpd.c
@@ -715,7 +715,7 @@ static char *decodeString(char *orig, int option_d)
 		}
 		value1 = value1 * 16 + value2;
 		if (!option_d && (value1 == '/' || value1 == '\0')) {
-			/* caller takes it as indication of invalid 
+			/* caller takes it as indication of invalid
 			 * (dangerous wrt exploits) chars */
 			return orig + 1;
 		}
@@ -998,7 +998,7 @@ static int sendCgi(const char *url,
 	pid = fork();
 	if (pid < 0)
 		return 0;
-	
+
 	if (!pid) {
 		/* child process */
 		char *script;
diff --git a/networking/interface.c b/networking/interface.c
index 6d23e9bfc..d47059220 100644
--- a/networking/interface.c
+++ b/networking/interface.c
@@ -116,7 +116,7 @@ static int INET_getsock(char *bufp, struct sockaddr *sap)
 	sock_in = (struct sockaddr_in *) sap;
 	sock_in->sin_family = AF_INET;
 	sock_in->sin_port = 0;
-	
+
 	val = 0;
 	bp = (char *) &val;
 	for (i = 0; i < sizeof(sock_in->sin_addr.s_addr); i++) {
diff --git a/networking/libiproute/iproute.c b/networking/libiproute/iproute.c
index 2ff99570e..c4c3fc2ca 100644
--- a/networking/libiproute/iproute.c
+++ b/networking/libiproute/iproute.c
@@ -562,7 +562,7 @@ static int iproute_list_or_flush(int argc, char **argv, int flush)
 				if (matches(*argv, "cache") == 0) {
 					filter.tb = -1;
 #if 0 && ENABLE_FEATURE_IP_RULE
-				
+
 #else
 				} else if (matches(*argv, "main") != 0) {
 					invarg(*argv, "table");
diff --git a/networking/libiproute/ll_map.c b/networking/libiproute/ll_map.c
index a14fa4e42..f429763eb 100644
--- a/networking/libiproute/ll_map.c
+++ b/networking/libiproute/ll_map.c
@@ -169,7 +169,7 @@ int ll_name_to_index(char *name)
 			 * to the reader... Jean II */
 			return ifr.ifr_ifindex;
 	}
-	
+
 	return 0;
 }
 
diff --git a/networking/nslookup.c b/networking/nslookup.c
index cc5ff95d6..4beecc63b 100644
--- a/networking/nslookup.c
+++ b/networking/nslookup.c
@@ -23,7 +23,7 @@
  * $ nslookup yahoo.com
  * Server:         128.193.0.10
  * Address:        128.193.0.10#53
- * 
+ *
  * Non-authoritative answer:
  * Name:   yahoo.com
  * Address: 216.109.112.135
@@ -33,11 +33,11 @@
  * $ nslookup 204.152.191.37
  * Server:         128.193.4.20
  * Address:        128.193.4.20#53
- * 
+ *
  * Non-authoritative answer:
  * 37.191.152.204.in-addr.arpa     canonical name = 37.32-27.191.152.204.in-addr.arpa.
  * 37.32-27.191.152.204.in-addr.arpa       name = zeus-pub2.kernel.org.
- * 
+ *
  * Authoritative answers can be found from:
  * 32-27.191.152.204.in-addr.arpa  nameserver = ns1.kernel.org.
  * 32-27.191.152.204.in-addr.arpa  nameserver = ns2.kernel.org.
diff --git a/networking/ping6.c b/networking/ping6.c
index fd18cc877..5cb02f51a 100644
--- a/networking/ping6.c
+++ b/networking/ping6.c
@@ -420,7 +420,7 @@ int ping6_main(int argc, char **argv)
 	datalen = DEFDATALEN; /* initialized here rather than in global scope to work around gcc bug */
 
 	/* exactly one argument needed, -v and -q don't mix */
-	opt_complementary = "=1:q--v:v--q"; 
+	opt_complementary = "=1:q--v:v--q";
 	getopt32(argc, argv, OPT_STRING, &opt_c, &opt_s, &opt_I);
 	if (option_mask32 & 4) pingcount = xatoul(opt_c); // -c
 	if (option_mask32 & 8) datalen = xatou16(opt_s); // -s
diff --git a/networking/telnetd.c b/networking/telnetd.c
index a0ee2c345..dd5d55de0 100644
--- a/networking/telnetd.c
+++ b/networking/telnetd.c
@@ -286,7 +286,7 @@ make_new_session(
 		ts->shell_pid = pid;
 		return ts;
 	}
-	
+
 	/* child */
 
 	/* open the child's side of the tty. */
diff --git a/procps/Config.in b/procps/Config.in
index 20d5f9bf2..e58b89f85 100644
--- a/procps/Config.in
+++ b/procps/Config.in
@@ -42,7 +42,7 @@ config KILLALL5
 	bool "killall5"
 	default n
 	depends on KILL
-	
+
 config PIDOF
 	bool "pidof"
 	default n
diff --git a/procps/top.c b/procps/top.c
index d1fbfe6e1..712544318 100644
--- a/procps/top.c
+++ b/procps/top.c
@@ -271,7 +271,7 @@ static unsigned long display_generic(int scr_width)
 		used, mfree, shared, buffers, cached);
 
 	printf(OPT_BATCH_MODE ? "%s\n" : "\e[H\e[J%s\n", scrbuf);
-    
+
 	snprintf(scrbuf, scr_width, "Load average: %s", buf);
 	printf("%s\n", scrbuf);
 
diff --git a/runit/chpst.c b/runit/chpst.c
index 14b8b5a15..4662a4a83 100644
--- a/runit/chpst.c
+++ b/runit/chpst.c
@@ -290,7 +290,7 @@ int chpst_main(int argc, char **argv)
 	}
 	argv += optind;
 	if (!argv || !*argv) bb_show_usage();
-	
+
 	if (OPT_pgrp) setsid();
 	if (env_dir) edir(env_dir);
 	if (root) {
diff --git a/runit/runit_lib.c b/runit/runit_lib.c
index 8612a1b94..b885a3412 100644
--- a/runit/runit_lib.c
+++ b/runit/runit_lib.c
@@ -84,7 +84,7 @@ int buffer_feed(buffer *s)
 int buffer_bget(buffer *s,char *buf,unsigned len)
 {
 	int r;
- 
+
 	if (s->p > 0) return getthis(s,buf,len);
 	if (s->n <= len) return oneread(s->op,s->fd,buf,s->n);
 	r = buffer_feed(s); if (r <= 0) return r;
@@ -94,7 +94,7 @@ int buffer_bget(buffer *s,char *buf,unsigned len)
 int buffer_get(buffer *s,char *buf,unsigned len)
 {
 	int r;
- 
+
 	if (s->p > 0) return getthis(s,buf,len);
 	if (s->n <= len) return oneread(s->op,s->fd,buf,len);
 	r = buffer_feed(s); if (r <= 0) return r;
@@ -135,7 +135,7 @@ static int allwrite(int (*op)(int fd,char *buf,unsigned len),int fd,const char *
 int buffer_flush(buffer *s)
 {
 	int p;
- 
+
 	p = s->p;
 	if (!p) return 0;
 	s->p = 0;
@@ -145,7 +145,7 @@ int buffer_flush(buffer *s)
 int buffer_putalign(buffer *s,const char *buf,unsigned len)
 {
 	unsigned n;
- 
+
 	while (len > (n = s->n - s->p)) {
 		memcpy(s->x + s->p,buf,n);
 		s->p += n;
@@ -162,7 +162,7 @@ int buffer_putalign(buffer *s,const char *buf,unsigned len)
 int buffer_put(buffer *s,const char *buf,unsigned len)
 {
 	unsigned n;
- 
+
 	n = s->n;
 	if (len > n - s->p) {
 		if (buffer_flush(s) == -1) return -1;
@@ -487,7 +487,7 @@ void taia_sub(struct taia *t,const struct taia *u,const struct taia *v)
 {
 	unsigned long unano = u->nano;
 	unsigned long uatto = u->atto;
-	
+
 	t->sec.x = u->sec.x - v->sec.x;
 	t->nano = unano - v->nano;
 	t->atto = uatto - v->atto;
diff --git a/runit/runsv.c b/runit/runsv.c
index 9e117fe0a..aace041a8 100644
--- a/runit/runsv.c
+++ b/runit/runsv.c
@@ -300,7 +300,7 @@ static void startservice(struct svdir *s)
 					fatal_cannot("setup filedescriptor for ./log/run");
 				close(logpipe[1]);
 				if (chdir("./log") == -1)
-					fatal_cannot("change directory to ./log");        
+					fatal_cannot("change directory to ./log");
 			} else {
 				if (fd_copy(1, logpipe[1]) == -1)
 					fatal_cannot("setup filedescriptor for ./run");
@@ -405,7 +405,7 @@ int runsv_main(int argc, char **argv)
 	coe(selfpipe[1]);
 	ndelay_on(selfpipe[0]);
 	ndelay_on(selfpipe[1]);
-	
+
 	sig_block(sig_child);
 	sig_catch(sig_child, s_child);
 	sig_block(sig_term);
@@ -544,7 +544,7 @@ int runsv_main(int argc, char **argv)
 		for (;;) {
 			int child;
 			int wstat;
-			
+
 			child = wait_nohang(&wstat);
 			if (!child) break;
 			if ((child == -1) && (errno != EINTR)) break;
diff --git a/runit/runsvdir.c b/runit/runsvdir.c
index 9238eec82..3290da5e6 100644
--- a/runit/runsvdir.c
+++ b/runit/runsvdir.c
@@ -36,7 +36,7 @@ static void fatal2_cannot(char *m1, char *m2)
 static void warn3x(char *m1, char *m2, char *m3)
 {
 	bb_error_msg("%s: warning: %s%s%s", svdir, m1, m2, m3);
-} 
+}
 static void warn2_cannot(char *m1, char *m2)
 {
 	warn3x("cannot ", m1, m2);
@@ -44,7 +44,7 @@ static void warn2_cannot(char *m1, char *m2)
 static void warnx(char *m1)
 {
 	warn3x(m1, "", "");
-} 
+}
 
 static void s_term(int sig_no)
 {
@@ -208,7 +208,7 @@ int runsvdir_main(int argc, char **argv)
 		}
 	}
 	curdir = open_read(".");
-	if (curdir == -1) 
+	if (curdir == -1)
 		fatal2_cannot("open current directory", "");
 	coe(curdir);
 
@@ -241,7 +241,7 @@ int runsvdir_main(int argc, char **argv)
 			/* wait at least a second */
 			taia_uint(&deadline, 1);
 			taia_add(&stampcheck, &now, &deadline);
-			
+
 			if (stat(svdir, &s) != -1) {
 				if (check || s.st_mtime != mtime
 				 || s.st_ino != ino || s.st_dev != dev
diff --git a/runit/sv.c b/runit/sv.c
index 9471d09a8..054053619 100644
--- a/runit/sv.c
+++ b/runit/sv.c
@@ -88,7 +88,7 @@ static unsigned svstatus_print(char *m)
 	int pid;
 	int normallyup = 0;
 	struct stat s;
- 
+
 	if (stat("down", &s) == -1) {
 		if (errno != ENOENT) {
 			bb_perror_msg(WARN"cannot stat %s/down", *service);
diff --git a/runit/svlogd.c b/runit/svlogd.c
index c91f85fe1..b089c5498 100644
--- a/runit/svlogd.c
+++ b/runit/svlogd.c
@@ -141,7 +141,7 @@ static unsigned processorstart(struct logdir *ld)
 		sig_unblock(sig_term);
 		sig_unblock(sig_alarm);
 		sig_unblock(sig_hangup);
-		
+
 		if (verbose)
 			bb_error_msg(INFO"processing: %s/%s", ld->name, ld->fnsave);
 		fd = xopen(ld->fnsave, O_RDONLY|O_NDELAY);
@@ -549,12 +549,12 @@ static unsigned logdir_open(struct logdir *ld, const char *fn)
 	coe(ld->fdcur);
 	while (fchmod(ld->fdcur, 0644) == -1)
 		pause2cannot("set mode of current", ld->name);
-	
+
 	if (verbose) {
 		if (i == 0) bb_error_msg(INFO"append: %s/current", ld->name);
 		else bb_error_msg(INFO"new: %s/current", ld->name);
 	}
-	
+
 	while (fchdir(fdwdir) == -1)
 		pause1cannot("change to initial working directory");
 	return 1;
@@ -569,7 +569,7 @@ static void logdirs_reopen(void)
 	tmaxflag = 0;
 	taia_now(&now);
 	for (l = 0; l < dirn; ++l) {
-		logdir_close(&dir[l]);    
+		logdir_close(&dir[l]);
 		if (logdir_open(&dir[l], fndir[l])) ok = 1;
 	}
 	if (!ok) fatalx("no functional log directories");
diff --git a/scripts/Kbuild.include b/scripts/Kbuild.include
index b0d067be7..a7fb4d521 100644
--- a/scripts/Kbuild.include
+++ b/scripts/Kbuild.include
@@ -99,7 +99,7 @@ cmd = @$(echo-cmd) $(cmd_$(1))
 objectify = $(foreach o,$(1),$(if $(filter /%,$(o)),$(o),$(obj)/$(o)))
 
 ###
-# if_changed      - execute command if any prerequisite is newer than 
+# if_changed      - execute command if any prerequisite is newer than
 #                   target, or command line has changed
 # if_changed_dep  - as if_changed, but uses fixdep to reveal dependencies
 #                   including used config symbols
diff --git a/scripts/Makefile.build b/scripts/Makefile.build
index e48e60da3..ddefea5a6 100644
--- a/scripts/Makefile.build
+++ b/scripts/Makefile.build
@@ -216,7 +216,7 @@ $(real-objs-m)      : modkern_aflags := $(AFLAGS_MODULE)
 $(real-objs-m:.o=.s): modkern_aflags := $(AFLAGS_MODULE)
 
 quiet_cmd_as_s_S = CPP $(quiet_modtag) $@
-cmd_as_s_S       = $(CPP) $(a_flags)   -o $@ $< 
+cmd_as_s_S       = $(CPP) $(a_flags)   -o $@ $<
 
 %.s: %.S FORCE
 	$(call if_changed_dep,as_s_S)
@@ -284,7 +284,7 @@ link_multi_deps =                     \
 $(filter $(addprefix $(obj)/,         \
 $($(subst $(obj)/,,$(@:.o=-objs)))    \
 $($(subst $(obj)/,,$(@:.o=-y)))), $^)
- 
+
 quiet_cmd_link_multi-y = LD      $@
 cmd_link_multi-y = $(LD) $(ld_flags) -r -o $@ $(link_multi_deps)
 
diff --git a/scripts/Makefile.host b/scripts/Makefile.host
index 2d519704b..763e2f2d7 100644
--- a/scripts/Makefile.host
+++ b/scripts/Makefile.host
@@ -152,5 +152,5 @@ $(host-cshlib): %: $(host-cshobjs) FORCE
 	$(call if_changed,host-cshlib)
 
 targets += $(host-csingle)  $(host-cmulti) $(host-cobjs)\
-	   $(host-cxxmulti) $(host-cxxobjs) $(host-cshlib) $(host-cshobjs) 
+	   $(host-cxxmulti) $(host-cxxobjs) $(host-cshlib) $(host-cshobjs)
 
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index 2cb4935e8..e1e0ba481 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -18,7 +18,7 @@ lib-y := $(filter-out $(obj-y), $(sort $(lib-y) $(lib-m)))
 # ---------------------------------------------------------------------------
 # o if we encounter foo/ in $(obj-y), replace it by foo/built-in.o
 #   and add the directory to the list of dirs to descend into: $(subdir-y)
-# o if we encounter foo/ in $(obj-m), remove it from $(obj-m) 
+# o if we encounter foo/ in $(obj-m), remove it from $(obj-m)
 #   and add the directory to the list of dirs to descend into: $(subdir-m)
 
 __subdir-y	:= $(patsubst %/,%,$(filter %/, $(obj-y)))
@@ -32,7 +32,7 @@ obj-m		:= $(filter-out %/, $(obj-m))
 
 subdir-ym	:= $(sort $(subdir-y) $(subdir-m))
 
-# if $(foo-objs) exists, foo.o is a composite object 
+# if $(foo-objs) exists, foo.o is a composite object
 multi-used-y := $(sort $(foreach m,$(obj-y), $(if $(strip $($(m:.o=-objs)) $($(m:.o=-y))), $(m))))
 multi-used-m := $(sort $(foreach m,$(obj-m), $(if $(strip $($(m:.o=-objs)) $($(m:.o=-y))), $(m))))
 multi-used   := $(multi-used-y) $(multi-used-m)
@@ -76,7 +76,7 @@ obj-dirs	:= $(addprefix $(obj)/,$(obj-dirs))
 
 # These flags are needed for modversions and compiling, so we define them here
 # already
-# $(modname_flags) #defines KBUILD_MODNAME as the name of the module it will 
+# $(modname_flags) #defines KBUILD_MODNAME as the name of the module it will
 # end up in (or would, if it gets compiled in)
 # Note: It's possible that one object gets potentially linked into more
 #       than one module. In that case KBUILD_MODNAME will be set to foo_bar,
@@ -134,7 +134,7 @@ $(obj)/%:: $(src)/%_shipped
 
 # Commands useful for building a boot image
 # ===========================================================================
-# 
+#
 #	Use as following:
 #
 #	target: source(s) FORCE
@@ -148,7 +148,7 @@ $(obj)/%:: $(src)/%_shipped
 
 quiet_cmd_ld = LD      $@
 cmd_ld = $(LD) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LDFLAGS_$(@F)) \
-	       $(filter-out FORCE,$^) -o $@ 
+	       $(filter-out FORCE,$^) -o $@
 
 # Objcopy
 # ---------------------------------------------------------------------------
diff --git a/scripts/kconfig/lex.zconf.c_shipped b/scripts/kconfig/lex.zconf.c_shipped
index 24e3c8cbb..7a4ca2c16 100644
--- a/scripts/kconfig/lex.zconf.c_shipped
+++ b/scripts/kconfig/lex.zconf.c_shipped
@@ -42,7 +42,7 @@ typedef uint32_t flex_uint32_t;
 typedef signed char flex_int8_t;
 typedef short int flex_int16_t;
 typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
+typedef unsigned char flex_uint8_t;
 typedef unsigned short int flex_uint16_t;
 typedef unsigned int flex_uint32_t;
 #endif /* ! C99 */
@@ -148,7 +148,7 @@ extern FILE *zconfin, *zconfout;
 #define EOB_ACT_LAST_MATCH 2
 
     #define YY_LESS_LINENO(n)
-    
+
 /* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
@@ -215,7 +215,7 @@ struct yy_buffer_state
 
     int yy_bs_lineno; /**< The line count. */
     int yy_bs_column; /**< The column count. */
-    
+
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
@@ -833,7 +833,7 @@ extern int zconfwrap (void );
 #endif
 
     static void yyunput (int c,char *buf_ptr  );
-    
+
 #ifndef yytext_ptr
 static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
@@ -938,7 +938,7 @@ YY_DECL
 	register yy_state_type yy_current_state;
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
-    
+
 	int str = 0;
 	int ts, i;
 
@@ -1536,7 +1536,7 @@ static int yy_get_next_buffer (void)
 {
 	register yy_state_type yy_current_state;
 	register char *yy_cp;
-    
+
 	yy_current_state = (yy_start);
 
 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
@@ -1555,7 +1555,7 @@ static int yy_get_next_buffer (void)
     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
 {
 	register int yy_is_jam;
-    
+
 	yy_current_state = yy_nxt[yy_current_state][1];
 	yy_is_jam = (yy_current_state <= 0);
 
@@ -1565,7 +1565,7 @@ static int yy_get_next_buffer (void)
     static void yyunput (int c, register char * yy_bp )
 {
 	register char *yy_cp;
-    
+
     yy_cp = (yy_c_buf_p);
 
 	/* undo effects of setting up zconftext */
@@ -1608,7 +1608,7 @@ static int yy_get_next_buffer (void)
 
 {
 	int c;
-    
+
 	*(yy_c_buf_p) = (yy_hold_char);
 
 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
@@ -1675,12 +1675,12 @@ static int yy_get_next_buffer (void)
 
 /** Immediately switch to a different input stream.
  * @param input_file A readable stream.
- * 
+ *
  * @note This function does not reset the start condition to @c INITIAL .
  */
     void zconfrestart  (FILE * input_file )
 {
-    
+
 	if ( ! YY_CURRENT_BUFFER ){
         zconfensure_buffer_stack ();
 		YY_CURRENT_BUFFER_LVALUE =
@@ -1693,11 +1693,11 @@ static int yy_get_next_buffer (void)
 
 /** Switch to a different input buffer.
  * @param new_buffer The new input buffer.
- * 
+ *
  */
     void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
 {
-    
+
 	/* TODO. We should be able to replace this entire function body
 	 * with
 	 *		zconfpop_buffer_state();
@@ -1737,13 +1737,13 @@ static void zconf_load_buffer_state  (void)
 /** Allocate and initialize an input buffer state.
  * @param file A readable stream.
  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * 
+ *
  * @return the allocated buffer state.
  */
     YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
 {
 	YY_BUFFER_STATE b;
-    
+
 	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
@@ -1766,11 +1766,11 @@ static void zconf_load_buffer_state  (void)
 
 /** Destroy the buffer.
  * @param b a buffer created with zconf_create_buffer()
- * 
+ *
  */
     void zconf_delete_buffer (YY_BUFFER_STATE  b )
 {
-    
+
 	if ( ! b )
 		return;
 
@@ -1791,7 +1791,7 @@ static void zconf_load_buffer_state  (void)
 
 {
 	int oerrno = errno;
-    
+
 	zconf_flush_buffer(b );
 
 	b->yy_input_file = file;
@@ -1807,13 +1807,13 @@ static void zconf_load_buffer_state  (void)
     }
 
         b->yy_is_interactive = 0;
-    
+
 	errno = oerrno;
 }
 
 /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * 
+ *
  */
     void zconf_flush_buffer (YY_BUFFER_STATE  b )
 {
@@ -1842,7 +1842,7 @@ static void zconf_load_buffer_state  (void)
  *  the current state. This function will allocate the stack
  *  if necessary.
  *  @param new_buffer The new state.
- *  
+ *
  */
 void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
 {
@@ -1872,7 +1872,7 @@ void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
 
 /** Removes and deletes the top of the stack, if present.
  *  The next element becomes the new top.
- *  
+ *
  */
 void zconfpop_buffer_state (void)
 {
@@ -1896,7 +1896,7 @@ void zconfpop_buffer_state (void)
 static void zconfensure_buffer_stack (void)
 {
 	int num_to_alloc;
-    
+
 	if (!(yy_buffer_stack)) {
 
 		/* First allocation is just for 2 elements, since we don't know if this
@@ -1907,9 +1907,9 @@ static void zconfensure_buffer_stack (void)
 		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
 								(num_to_alloc * sizeof(struct yy_buffer_state*)
 								);
-		
+
 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
+
 		(yy_buffer_stack_max) = num_to_alloc;
 		(yy_buffer_stack_top) = 0;
 		return;
@@ -1935,13 +1935,13 @@ static void zconfensure_buffer_stack (void)
 /** Setup the input buffer state to scan directly from a user-specified character buffer.
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object. 
+ *
+ * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
 {
 	YY_BUFFER_STATE b;
-    
+
 	if ( size < 2 ||
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
@@ -1970,14 +1970,14 @@ YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
 /** Setup the input buffer state to scan a string. The next call to zconflex() will
  * scan from a @e copy of @a str.
  * @param yy_str a NUL-terminated string to scan
- * 
+ *
  * @return the newly allocated buffer state object.
  * @note If you want to scan bytes that may contain NUL values, then use
  *       zconf_scan_bytes() instead.
  */
 YY_BUFFER_STATE zconf_scan_string (yyconst char * yy_str )
 {
-    
+
 	return zconf_scan_bytes(yy_str,strlen(yy_str) );
 }
 
@@ -1985,7 +1985,7 @@ YY_BUFFER_STATE zconf_scan_string (yyconst char * yy_str )
  * scan from a @e copy of @a bytes.
  * @param bytes the byte buffer to scan
  * @param len the number of bytes in the buffer pointed to by @a bytes.
- * 
+ *
  * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * bytes, int  len )
@@ -1994,7 +1994,7 @@ YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * bytes, int  len )
 	char *buf;
 	yy_size_t n;
 	int i;
-    
+
 	/* Get memory for full buffer, including space for trailing EOB's. */
 	n = len + 2;
 	buf = (char *) zconfalloc(n  );
@@ -2048,16 +2048,16 @@ static void yy_fatal_error (yyconst char* msg )
 /* Accessor  methods (get/set functions) to struct members. */
 
 /** Get the current line number.
- * 
+ *
  */
 int zconfget_lineno  (void)
 {
-        
+
     return zconflineno;
 }
 
 /** Get the input stream.
- * 
+ *
  */
 FILE *zconfget_in  (void)
 {
@@ -2065,7 +2065,7 @@ FILE *zconfget_in  (void)
 }
 
 /** Get the output stream.
- * 
+ *
  */
 FILE *zconfget_out  (void)
 {
@@ -2073,7 +2073,7 @@ FILE *zconfget_out  (void)
 }
 
 /** Get the length of the current token.
- * 
+ *
  */
 int zconfget_leng  (void)
 {
@@ -2081,7 +2081,7 @@ int zconfget_leng  (void)
 }
 
 /** Get the current token.
- * 
+ *
  */
 
 char *zconfget_text  (void)
@@ -2091,18 +2091,18 @@ char *zconfget_text  (void)
 
 /** Set the current line number.
  * @param line_number
- * 
+ *
  */
 void zconfset_lineno (int  line_number )
 {
-    
+
     zconflineno = line_number;
 }
 
 /** Set the input stream. This does not discard the current
  * input buffer.
  * @param in_str A readable stream.
- * 
+ *
  * @see zconf_switch_to_buffer
  */
 void zconfset_in (FILE *  in_str )
@@ -2128,7 +2128,7 @@ void zconfset_debug (int  bdebug )
 /* zconflex_destroy is for both reentrant and non-reentrant scanners. */
 int zconflex_destroy  (void)
 {
-    
+
     /* Pop the buffer stack, destroying each element. */
 	while(YY_CURRENT_BUFFER){
 		zconf_delete_buffer(YY_CURRENT_BUFFER  );
diff --git a/scripts/kconfig/lxdialog/BIG.FAT.WARNING b/scripts/kconfig/lxdialog/BIG.FAT.WARNING
index c9bfbb902..b5d3b10b2 100644
--- a/scripts/kconfig/lxdialog/BIG.FAT.WARNING
+++ b/scripts/kconfig/lxdialog/BIG.FAT.WARNING
@@ -1,4 +1,4 @@
 This is NOT the official version of dialog.  This version has been
 significantly modified from the original.  It is for use by the Linux
-busybox configuration script.  Please do not bother Savio Lam with 
+busybox configuration script.  Please do not bother Savio Lam with
 questions about this program.
diff --git a/scripts/kconfig/lxdialog/menubox.c b/scripts/kconfig/lxdialog/menubox.c
index bf8052f4f..078e55a2e 100644
--- a/scripts/kconfig/lxdialog/menubox.c
+++ b/scripts/kconfig/lxdialog/menubox.c
@@ -26,7 +26,7 @@
  *
  *    *)  A bugfix for the Page-Down problem
  *
- *    *)  Formerly when I used Page Down and Page Up, the cursor would be set 
+ *    *)  Formerly when I used Page Down and Page Up, the cursor would be set
  *        to the first position in the menu box.  Now lxdialog is a bit
  *        smarter and works more like other menu systems (just have a look at
  *        it).
diff --git a/scripts/kconfig/zconf.tab.c_shipped b/scripts/kconfig/zconf.tab.c_shipped
index e14eafa6c..ca8003dce 100644
--- a/scripts/kconfig/zconf.tab.c_shipped
+++ b/scripts/kconfig/zconf.tab.c_shipped
@@ -1086,7 +1086,7 @@ yyparse ()
 #endif
 #endif
 {
-  
+
   register int yystate;
   register int yyn;
   int yyresult;
diff --git a/shell/ash.c b/shell/ash.c
index 10217fe2f..95928e992 100644
--- a/shell/ash.c
+++ b/shell/ash.c
@@ -2036,7 +2036,7 @@ static int is_safe_applet(char *name)
 {
 	/* It isn't a bug to have non-existent applet here... */
 	/* ...just a waste of space... */
-	static const char safe_applets[][8] = { 
+	static const char safe_applets[][8] = {
 		"["
 		USE_AWK    (, "awk"    )
 		USE_CAT    (, "cat"    )
@@ -3763,7 +3763,7 @@ tryexec(char *cmd, char **argv, char **envp)
 	struct BB_applet *a;
 	int argc = 0;
 	char **c;
-	
+
 	if (strchr(cmd, '/') == NULL
 	 && (a = find_applet_by_name(cmd)) != NULL
 	 && is_safe_applet(cmd)
diff --git a/shell/bbsh.c b/shell/bbsh.c
index 99e4f61fb..7978fdc16 100644
--- a/shell/bbsh.c
+++ b/shell/bbsh.c
@@ -1,5 +1,5 @@
 /* vi: set ts=4 :
- * 
+ *
  * bbsh - busybox shell
  *
  * Copyright 2006 Rob Landley <rob@landley.net>
@@ -51,7 +51,7 @@
 // What we know about a single process.
 struct command {
 	struct command *next;
-	int flags;		// exit, suspend, && || 
+	int flags;		// exit, suspend, && ||
 	int pid;		// pid (or exit code)
 	int argc;
 	char *argv[0];
@@ -125,9 +125,9 @@ static char *parse_pipeline(char *cmdline, struct pipeline *line)
 			return 0;
 		}
 
-		// Allocate next command structure if necessary		
+		// Allocate next command structure if necessary
 		if (!*cmd) *cmd = xzalloc(sizeof(struct command)+8*sizeof(char *));
-		
+
 		// Parse next argument and add the results to argv[]
 		end = parse_word(start, cmd);
 
@@ -138,7 +138,7 @@ static char *parse_pipeline(char *cmdline, struct pipeline *line)
 					start++;
 					break;
 				}
-				// handle | & < > >> << || && 
+				// handle | & < > >> << || &&
 			}
 			break;
 		}
@@ -160,7 +160,7 @@ static int run_pipeline(struct pipeline *line)
 	if (cmd->argc==2 && !strcmp(cmd->argv[0],"cd"))
 		chdir(cmd->argv[1]);
 	else if(!strcmp(cmd->argv[0],"exit"))
-		exit(cmd->argc>1 ? atoi(cmd->argv[1]) : 0); 
+		exit(cmd->argc>1 ? atoi(cmd->argv[1]) : 0);
 	else {
 		int status;
 		pid_t pid=fork();
@@ -217,6 +217,6 @@ int bbsh_main(int argc, char *argv[])
 		}
 		if (ENABLE_FEATURE_CLEAN_UP) free(command);
 	}
-		
+
 	return 1;
 }
diff --git a/util-linux/fdisk_sun.c b/util-linux/fdisk_sun.c
index a3ca66f68..10107783e 100644
--- a/util-linux/fdisk_sun.c
+++ b/util-linux/fdisk_sun.c
@@ -71,7 +71,7 @@ static const struct systypes sun_sys_types[] = {
 	{ "\x83" "Linux native" }, /* LINUX_NATIVE */
 	{ "\x8e" "Linux LVM"    }, /* 0x8e         */
 /* New (2.2.x) raid partition with autodetect using persistent superblock */
-	{ "\xfd" "Linux raid autodetect" }, /* 0xfd         */  
+	{ "\xfd" "Linux raid autodetect" }, /* 0xfd         */
 	{ NULL }
 };
 
@@ -167,7 +167,7 @@ sun_autoconfigure_scsi(void)
 
 	if (ioctl(fd, SCSI_IOCTL_GET_IDLUN, &id))
 		return NULL;
-	
+
 	sprintf(buffer,
 		"Host: scsi%d Channel: %02d Id: %02d Lun: %02d\n",
 		/* This is very wrong (works only if you have one HBA),
@@ -651,14 +651,14 @@ sun_list_table(int xtra)
 			uint32_t start = SUN_SSWAP32(sunlabel->partitions[i].start_cylinder) * heads * sectors;
 			uint32_t len = SUN_SSWAP32(sunlabel->partitions[i].num_sectors);
 			printf("%s %c%c %9ld %9ld %9ld%c  %2x  %s\n",
-				partname(disk_device, i+1, w),			/* device */            
-				(sunlabel->infos[i].flags & 0x01) ? 'u' : ' ',  /* flags */             
-				(sunlabel->infos[i].flags & 0x10) ? 'r' : ' ',  			
-				(long) scround(start),                          /* start */             
-				(long) scround(start+len),                      /* end */               
-				(long) len / 2, len & 1 ? '+' : ' ',            /* odd flag on end */   
-				sunlabel->infos[i].id,                          /* type id */           
-				partition_type(sunlabel->infos[i].id));         /* type name */         
+				partname(disk_device, i+1, w),			/* device */
+				(sunlabel->infos[i].flags & 0x01) ? 'u' : ' ',  /* flags */
+				(sunlabel->infos[i].flags & 0x10) ? 'r' : ' ',
+				(long) scround(start),                          /* start */
+				(long) scround(start+len),                      /* end */
+				(long) len / 2, len & 1 ? '+' : ' ',            /* odd flag on end */
+				sunlabel->infos[i].id,                          /* type id */
+				partition_type(sunlabel->infos[i].id));         /* type name */
 		}
 	}
 }