"2007-03-27 22:01:31 +0000"
diff --git a/Config.in b/Config.in
index d15b2673a..650ea0878 100644
--- a/Config.in
+++ b/Config.in
@@ -141,6 +141,13 @@ config FEATURE_CLEAN_UP
 	  Don't enable this unless you have a really good reason to clean
 	  things up manually.
 
+config FEATURE_PIDFILE
+	bool "Support writing pidfiles"
+	default n
+	help
+	  This option makes some applets (crond, syslogd and inetd) write
+	  a pidfile in /var/run. Some applications rely on them
+
 config FEATURE_SUID
 	bool "Support for SUID/SGID handling"
 	default n
diff --git a/include/libbb.h b/include/libbb.h
index 67fd2af21..d734abed6 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -408,10 +408,11 @@ extern FILE *fopen_or_warn(const char *filename, const char *mode);
 extern FILE *fopen_or_warn_stdin(const char *filename);
 
 
-extern void utoa_to_buf(unsigned n, char *buf, unsigned buflen);
 extern char *utoa(unsigned n);
-extern void itoa_to_buf(int n, char *buf, unsigned buflen);
 extern char *itoa(int n);
+/* Returns a pointer past the formatted number, does NOT null-terminate */
+extern char *utoa_to_buf(unsigned n, char *buf, unsigned buflen);
+extern char *itoa_to_buf(int n, char *buf, unsigned buflen);
 extern void smart_ulltoa5(unsigned long long ul, char buf[5]);
 /* Put a string of hex bytes (ala "1b"), return advanced pointer */
 extern char *bin2hex(char *buf, const char *cp, int count);
@@ -542,6 +543,14 @@ extern void llist_unlink(llist_t **head, llist_t *elm);
 extern void llist_free(llist_t *elm, void (*freeit)(void *data));
 extern llist_t* llist_rev(llist_t *list);
 
+#if ENABLE_FEATURE_PIDFILE
+int write_pidfile(const char *path);
+#define remove_pidfile(f) ((void)unlink(f))
+#else
+#define write_pidfile(f)  1
+#define remove_pidfile(f) ((void)0)
+#endif
+
 enum {
 	LOGMODE_NONE = 0,
 	LOGMODE_STDIO = 1<<0,
diff --git a/libbb/Kbuild b/libbb/Kbuild
index ffded6a68..a3b78ef28 100644
--- a/libbb/Kbuild
+++ b/libbb/Kbuild
@@ -61,6 +61,7 @@ lib-y += perror_msg.o
 lib-y += perror_msg_and_die.o
 lib-y += perror_nomsg.o
 lib-y += perror_nomsg_and_die.o
+lib-y += pidfile.o
 lib-y += process_escape_sequence.o
 lib-y += procps.o
 lib-y += read.o
diff --git a/libbb/xfuncs.c b/libbb/xfuncs.c
index 7f870ac8b..e1632a4b6 100644
--- a/libbb/xfuncs.c
+++ b/libbb/xfuncs.c
@@ -257,7 +257,7 @@ void smart_ulltoa5(unsigned long long ul, char buf[5])
 // truncated result is always null terminated (unless buflen is 0), and
 // contains the first few digits of the result ala strncpy.
 void BUG_sizeof_unsigned_not_4(void);
-void utoa_to_buf(unsigned n, char *buf, unsigned buflen)
+char *utoa_to_buf(unsigned n, char *buf, unsigned buflen)
 {
 	unsigned i, out, res;
 	if (sizeof(unsigned) != 4)
@@ -273,19 +273,19 @@ void utoa_to_buf(unsigned n, char *buf, unsigned buflen)
 				*buf++ = '0' + res;
 			}
 		}
-		*buf = '\0';
 	}
+	return buf;
 }
 
 // Convert signed integer to ascii, like utoa_to_buf()
-void itoa_to_buf(int n, char *buf, unsigned buflen)
+char *itoa_to_buf(int n, char *buf, unsigned buflen)
 {
 	if (buflen && n<0) {
 		n = -n;
 		*buf++ = '-';
 		buflen--;
 	}
-	utoa_to_buf((unsigned)n, buf, buflen);
+	return utoa_to_buf((unsigned)n, buf, buflen);
 }
 
 // The following two functions use a static buffer, so calling either one a
@@ -300,7 +300,7 @@ static char local_buf[12];
 // Convert unsigned integer to ascii using a static buffer (returned).
 char *utoa(unsigned n)
 {
-	utoa_to_buf(n, local_buf, sizeof(local_buf));
+	*(utoa_to_buf(n, local_buf, sizeof(local_buf))) = '\0';
 
 	return local_buf;
 }
@@ -308,7 +308,7 @@ char *utoa(unsigned n)
 // Convert signed integer to ascii using a static buffer (returned).
 char *itoa(int n)
 {
-	itoa_to_buf(n, local_buf, sizeof(local_buf));
+	*(itoa_to_buf(n, local_buf, sizeof(local_buf))) = '\0';
 
 	return local_buf;
 }
diff --git a/miscutils/crond.c b/miscutils/crond.c
index 9d511f960..24aa3dcc3 100644
--- a/miscutils/crond.c
+++ b/miscutils/crond.c
@@ -185,6 +185,7 @@ int crond_main(int ac, char **av)
 		int rescan = 60;
 		short sleep_time = 60;
 
+		write_pidfile("/var/run/crond.pid");
 		for (;;) {
 			sleep((sleep_time + 1) - (short) (time(NULL) % sleep_time));
 
diff --git a/networking/inetd.c b/networking/inetd.c
index 4faa4203a..fd72aa726 100644
--- a/networking/inetd.c
+++ b/networking/inetd.c
@@ -1212,7 +1212,7 @@ static void goaway(int sig ATTRIBUTE_UNUSED)
 		}
 		(void) close(sep->se_fd);
 	}
-	(void) unlink(_PATH_INETDPID);
+	remove_pidfile(_PATH_INETDPID);
 	exit(0);
 }
 
@@ -1301,13 +1301,7 @@ int inetd_main(int argc, char *argv[])
 		setgroups(1, &gid);
 	}
 
-	{
-		FILE *fp = fopen(_PATH_INETDPID, "w");
-		if (fp != NULL) {
-			fprintf(fp, "%u\n", getpid());
-			fclose(fp);
-		}
-	}
+	write_pidfile(_PATH_INETDPID);
 
 	if (getrlimit(RLIMIT_NOFILE, &rlim_ofile) < 0) {
 		bb_perror_msg("getrlimit");
diff --git a/networking/udhcp/common.c b/networking/udhcp/common.c
index 7b2e19c42..46cc0348f 100644
--- a/networking/udhcp/common.c
+++ b/networking/udhcp/common.c
@@ -22,47 +22,35 @@ long uptime(void)
 	return info.uptime;
 }
 
-
+#if ENABLE_FEATURE_PIDFILE
 static const char *saved_pidfile;
 
 static void pidfile_delete(void)
 {
 	if (saved_pidfile)
-		unlink(saved_pidfile);
+		remove_pidfile(saved_pidfile);
 }
+#endif
 
-static int pidfile_acquire(const char *pidfile)
+static void create_pidfile(const char *pidfile)
 {
-	int pid_fd;
-	if (!pidfile) return -1;
+	if (!pidfile)
+		return;
 
-	pid_fd = open(pidfile, O_CREAT|O_WRONLY|O_TRUNC, 0644);
-	if (pid_fd < 0) {
-		bb_perror_msg("cannot open pidfile %s", pidfile);
-	} else {
-		/* lockf(pid_fd, F_LOCK, 0); */
-		if (!saved_pidfile)
-			atexit(pidfile_delete);
-		saved_pidfile = pidfile;
+	if (!write_pidfile(pidfile)) {
+		bb_perror_msg("cannot create pidfile %s", pidfile);
+		return;
 	}
-
-	return pid_fd;
-}
-
-static void pidfile_write_release(int pid_fd)
-{
-	if (pid_fd < 0) return;
-
-	fdprintf(pid_fd, "%d\n", getpid());
-	/* lockf(pid_fd, F_UNLCK, 0); */
-	close(pid_fd);
+#if ENABLE_FEATURE_PIDFILE
+	/* lockf(pid_fd, F_LOCK, 0); */
+	if (!saved_pidfile)
+		atexit(pidfile_delete);
+	saved_pidfile = pidfile;
+#endif
 }
 
-
 void udhcp_make_pidfile(const char *pidfile)
 {
-	int pid_fd;
-
 	/* Make sure fd 0,1,2 are open */
 	bb_sanitize_stdio();
 
@@ -70,8 +58,7 @@ void udhcp_make_pidfile(const char *pidfile)
 	setlinebuf(stdout);
 
 	/* Create pidfile */
-	pid_fd = pidfile_acquire(pidfile);
-	pidfile_write_release(pid_fd);
+	create_pidfile(pidfile);
 
 	bb_info_msg("%s (v%s) started", applet_name, BB_VER);
 }
diff --git a/shell/msh.c b/shell/msh.c
index 66b10f346..50ec90b0b 100644
--- a/shell/msh.c
+++ b/shell/msh.c
@@ -49,7 +49,7 @@ static char *find_applet_by_name(const char *applet)
 {
 	return NULL;
 }
-static void utoa_to_buf(unsigned n, char *buf, unsigned buflen)
+static char *utoa_to_buf(unsigned n, char *buf, unsigned buflen)
 {
 	unsigned i, out, res;
 	assert(sizeof(unsigned) == 4);
@@ -64,22 +64,22 @@ static void utoa_to_buf(unsigned n, char *buf, unsigned buflen)
 	    			*buf++ = '0' + res;
 			}
 		}
-		*buf = '\0';
 	}
+	return buf;
 }
-static void itoa_to_buf(int n, char *buf, unsigned buflen)
+static char *itoa_to_buf(int n, char *buf, unsigned buflen)
 {
 	if (buflen && n < 0) {
 		n = -n;
 		*buf++ = '-';
 		buflen--;
 	}
-	utoa_to_buf((unsigned)n, buf, buflen);
+	return utoa_to_buf((unsigned)n, buf, buflen);
 }
 static char local_buf[12];
 static char *itoa(int n)
 {
-	itoa_to_buf(n, local_buf, sizeof(local_buf));
+	*(itoa_to_buf(n, local_buf, sizeof(local_buf))) = '\0';
 	return local_buf;
 }
 #else
diff --git a/sysklogd/syslogd.c b/sysklogd/syslogd.c
index 51627bd82..76a446b6a 100644
--- a/sysklogd/syslogd.c
+++ b/sysklogd/syslogd.c
@@ -519,6 +519,7 @@ static void do_syslogd(void)
 	signal(SIGALRM, do_mark);
 	alarm(G.markInterval);
 #endif
+	remove_pidfile("/var/run/syslogd.pid");
 
 	memset(&sunx, 0, sizeof(sunx));
 	sunx.sun_family = AF_UNIX;
@@ -645,6 +646,7 @@ int syslogd_main(int argc, char **argv)
 		bb_daemonize_or_rexec(DAEMON_CHDIR_ROOT, argv);
 	}
 	umask(0);
+	write_pidfile("/var/run/syslogd.pid");
 	do_syslogd();
 	/* return EXIT_SUCCESS; */
 }