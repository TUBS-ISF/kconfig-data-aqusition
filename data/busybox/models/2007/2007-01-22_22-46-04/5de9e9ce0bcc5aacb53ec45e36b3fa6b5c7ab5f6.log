"2007-01-22 22:46:04 +0000"
diff --git a/include/libbb.h b/include/libbb.h
index 1a5ce24ad..8cd4bc377 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -336,12 +336,10 @@ char* xmalloc_sockaddr2hostonly_noport(const struct sockaddr *sa, socklen_t sale
 char* xmalloc_sockaddr2dotted(const struct sockaddr *sa, socklen_t salen);
 char* xmalloc_sockaddr2dotted_noport(const struct sockaddr *sa, socklen_t salen);
 // "old" (ipv4 only) API
-//void bb_lookup_host(struct sockaddr_in *s_in, const char *host);
-//int xconnect_tcp_v4(struct sockaddr_in *s_addr);
 // users: traceroute.c hostname.c ifconfig.c ping.c
 struct hostent *xgethostbyname(const char *name);
-//// ping6 is the only user - convert to new API
-//struct hostent *xgethostbyname2(const char *name, int af);
+//TODO: eliminate gethostbyname2 in arping (the only remaining place),
+//use host_and_af2sockaddr instead.
 
 
 extern char *xstrdup(const char *s);
diff --git a/networking/Config.in b/networking/Config.in
index 3b00f03ef..6bb2d3b83 100644
--- a/networking/Config.in
+++ b/networking/Config.in
@@ -12,6 +12,14 @@ config FEATURE_IPV6
 	  Enable IPv6 support in busybox.
 	  This adds IPv6 support in the networking applets.
 
+config VERBOSE_RESOLUTION_ERRORS
+	bool "Verbose resolution errors"
+	default n
+	help
+	  Enable if you are not satisfied with simplistic
+	  "can't resolve 'hostname.com'" and want to know more.
+	  This may increase size of your executable a bit.
+
 config ARP
 	bool "arp"
 	default n
diff --git a/networking/Kbuild b/networking/Kbuild
index bb024c9b7..65ecfbf5f 100644
--- a/networking/Kbuild
+++ b/networking/Kbuild
@@ -9,7 +9,6 @@ lib-$(CONFIG_ARP)          += arp.o interface.o
 lib-$(CONFIG_ARPING)       += arping.o
 lib-$(CONFIG_DNSD)         += dnsd.o
 lib-$(CONFIG_ETHER_WAKE)   += ether-wake.o
-#lib-$(CONFIG_FAKEIDENTD)   += fakeidentd.o
 lib-$(CONFIG_FAKEIDENTD)   += isrv_identd.o isrv.o
 lib-$(CONFIG_FTPGET)       += ftpgetput.o
 lib-$(CONFIG_FTPPUT)       += ftpgetput.o
diff --git a/networking/fakeidentd.c b/networking/fakeidentd.c
index 6f766a827..7af2f75fb 100644
--- a/networking/fakeidentd.c
+++ b/networking/fakeidentd.c
@@ -1,377 +1 @@
-/* NB: this file is to be removed soon. See isrv_identd.c */
-
-/* vi: set sw=4 ts=4: */
-/*
- * A fake identd server
- *
- * Adapted to busybox by Thomas Lundquist <thomasez@zelow.no>
- * Original Author: Tomi Ollila <too@iki.fi>
- *                  http://www.guru-group.fi/~too/sw/
- *
- * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
- */
-
-/* Ident crash course
- *
- * Incoming requests are of form "6191, 23\r\n" - peer asks us
- * "which user connected from your port 6191 to my port 23?"
- * We should answer:
- * "6193, 23 : USERID : UNIX : username\r\n"
- * and close the connection.
- * We can also reply:
- * "6195, 23 : USERID : OTHER[,US-ASCII] : username\r\n"
- * "6195, 23 : ERROR : INVALID-PORT/NO-USER/HIDDEN-USER/UNKNOWN-ERROR\r\n"
- * but we probably will never want that.
- */
-
-#include "busybox.h"
-
-#define SANE_INETD_ONLY_VERSION
-
-#ifdef SANE_INETD_ONLY_VERSION
-
-int fakeidentd_main(int argc, char **argv)
-{
-	char buf[64];
-	const char *bogouser = "nobody";
-	char *cur = buf;
-	int rem = sizeof(buf)-1;
-
-	if (argv[1])
-		bogouser = argv[1];
-
-	alarm(30);
-	while (1) {
-		char *p;
-		int sz = safe_read(0, cur, rem);
-		if (sz < 0) return 1;
-		cur[sz] = '\0';
-		p = strpbrk(cur, "\r\n");
-		if (p) {
-			*p = '\0';
-			break;
-		}
-		cur += sz;
-		rem -= sz;
-		if (!rem || !sz)
-			break;
-	}
-	printf("%s : USERID : UNIX : %s\r\n", buf, bogouser);
-	return 0;
-}
-
-#else
-
-/* Welcome to the bloaty horrors */
-
-#include <sys/syslog.h>
-#include <sys/uio.h>
-
-#define MAXCONNS    20
-#define MAXIDLETIME 45
-
-static const char ident_substr[] = " : USERID : UNIX : ";
-enum { ident_substr_len = sizeof(ident_substr) - 1 };
-#define PIDFILE "/var/run/identd.pid"
-
-/*
- * We have to track the 'first connection socket' so that we
- * don't go around closing file descriptors for non-clients.
- *
- * descriptor setup normally
- *  0 = server socket
- *  1 = syslog fd (hopefully -- otherwise this won't work)
- *  2 = connection socket after detached from tty. standard error before that
- *  3 - 2 + MAXCONNS = rest connection sockets
- *
- * To try to make sure that syslog fd is what is "requested", the that fd
- * is closed before openlog() call.  It can only severely fail if fd 0
- * is initially closed.
- */
-#define FCS 2
-
-/*
- * FD of the connection is always the index of the connection structure
- * in `conns' array + FCS
- */
-static struct {
-	time_t lasttime;
-	int len;
-	char buf[20];
-} conns[MAXCONNS];
-
-/* When using global variables, bind those at least to a structure. */
-static struct {
-	const char *identuser;
-	fd_set readfds;
-	int conncnt;
-} G;
-
-static char *bind_ip_address;
-
-static int chmatch(char c, char *chars)
-{
-	for (; *chars; chars++)
-		if (c == *chars)
-			return 1;
-	return 0;
-}
-
-static int skipchars(char **p, char *chars)
-{
-	while (chmatch(**p, chars))
-		(*p)++;
-	if (**p == '\r' || **p == '\n')
-		return 0;
-	return 1;
-}
-
-static int parseAddrs(char *ptr, char **myaddr, char **heraddr)
-{
-	/* parse <port-on-server> , <port-on-client> */
-
-	if (!skipchars(&ptr, " \t"))
-		return -1;
-
-	*myaddr = ptr;
-
-	if (!skipchars(&ptr, "1234567890"))
-		return -1;
-
-	if (!chmatch(*ptr, " \t,"))
-		return -1;
-
-	*ptr++ = '\0';
-
-	if (!skipchars(&ptr, " \t,") )
-		return -1;
-
-	*heraddr = ptr;
-
-	skipchars(&ptr, "1234567890");
-
-	if (!chmatch(*ptr, " \n\r"))
-		return -1;
-
-	*ptr = '\0';
-
-	return 0;
-}
-
-static void replyError(int s, char *buf)
-{
-	struct iovec iv[3];
-	iv[0].iov_base = "0, 0 : ERROR : ";   iv[0].iov_len = 15;
-	iv[1].iov_base = buf;                 iv[1].iov_len = strlen(buf);
-	iv[2].iov_base = "\r\n";              iv[2].iov_len = 2;
-	writev(s, iv, 3);
-}
-
-static void reply(int s, char *buf)
-{
-	char *myaddr, *heraddr;
-
-	myaddr = heraddr = NULL;
-
-	if (parseAddrs(buf, &myaddr, &heraddr))
-		replyError(s, "X-INVALID-REQUEST");
-	else {
-		struct iovec iv[6];
-		iv[0].iov_base = myaddr;               iv[0].iov_len = strlen(myaddr);
-		iv[1].iov_base = ", ";                 iv[1].iov_len = 2;
-		iv[2].iov_base = heraddr;              iv[2].iov_len = strlen(heraddr);
-		iv[3].iov_base = (void *)ident_substr; iv[3].iov_len = ident_substr_len;
-		iv[4].iov_base = (void *)G.identuser;  iv[4].iov_len = strlen(G.identuser);
-		iv[5].iov_base = "\r\n";               iv[5].iov_len = 2;
-		writev(s, iv, 6);
-	}
-}
-
-static void movefd(int from, int to)
-{
-	if (from != to) {
-		dup2(from, to);
-		close(from);
-	}
-}
-
-static void deleteConn(int s)
-{
-	int i = s - FCS;
-
-	close(s);
-
-	G.conncnt--;
-
-	/*
-	 * Most of the time there is 0 connections. Most often that there
-	 * is connections, there is just one connection. When this one connection
-	 * closes, i == G.conncnt = 0 -> no copying.
-	 * When there is more than one connection, the oldest connections closes
-	 * earlier on average. When this happens, the code below starts copying
-	 * the connection structure w/ highest index to the place which which is
-	 * just deleted. This means that the connection structures are no longer
-	 * in chronological order. I'd quess this means that when there is more
-	 * than 1 connection, on average every other connection structure needs
-	 * to be copied over the time all these connections are deleted.
-	 */
-	if (i != G.conncnt) {
-		memcpy(&conns[i], &conns[G.conncnt], sizeof(conns[0]));
-		movefd(G.conncnt + FCS, s);
-	}
-
-	FD_CLR(G.conncnt + FCS, &G.readfds);
-}
-
-static int closeOldest(void)
-{
-	time_t min = conns[0].lasttime;
-	int idx = 0;
-	int i;
-
-	for (i = 1; i < MAXCONNS; i++)
-		if (conns[i].lasttime < min)
-			idx = i;
-
-	replyError(idx + FCS, "X-SERVER-TOO-BUSY");
-	close(idx + FCS);
-
-	return idx;
-}
-
-static int checkInput(char *buf, int len, int l)
-{
-	int i;
-	for (i = len; i < len + l; ++i)
-		if (buf[i] == '\n')
-			return 1;
-	return 0;
-}
-
-/* May succeed. If not, won't care. */
-static const char *to_unlink;
-static void writepid(void)
-{
-	int fd = open(PIDFILE, O_WRONLY|O_CREAT|O_TRUNC, 0664);
-	if (fd < 0)
-		return;
-	to_unlink = PIDFILE;
-	fdprintf(fd, "%d\n", getpid());
-	close(fd);
-}
-
-static void handlexitsigs(int signum)
-{
-	if (to_unlink)
-		if (unlink(to_unlink) < 0)
-			close(open(to_unlink, O_WRONLY|O_CREAT|O_TRUNC, 0644));
-	exit(0);
-}
-
-int fakeidentd_main(int argc, char **argv)
-{
-	int fd;
-	pid_t pid;
-
-	/* FD_ZERO(&G.readfds); - in bss, already zeroed */
-	FD_SET(0, &G.readfds);
-
-	/* handle -b <ip> parameter */
-	getopt32(argc, argv, "b:", &bind_ip_address);
-	/* handle optional REPLY STRING */
-	if (optind < argc)
-		G.identuser = argv[optind];
-	else
-		G.identuser = "nobody";
-
-	writepid();
-	signal(SIGTERM, handlexitsigs);
-	signal(SIGINT,  handlexitsigs);
-	signal(SIGQUIT, handlexitsigs);
-	signal(SIGHUP, SIG_IGN);
-	signal(SIGPIPE, SIG_IGN); /* ignore closed connections when writing */
-
-	fd = create_and_bind_stream_or_die(bind_ip_address, bb_lookup_port("identd", "tcp", 113));
-	xlisten(fd, 5);
-
-	pid = fork();
-	if (pid < 0)
-		bb_perror_msg_and_die("fork");
-	if (pid != 0) /* parent */
-		exit(0);
-	/* child */
-	setsid();
-	movefd(fd, 0);
-	while (fd)
-		close(fd--);
-	openlog(applet_name, 0, LOG_DAEMON);
-	logmode = LOGMODE_SYSLOG;
-
-	/* main loop where we process all events and never exit */
-	while (1) {
-		fd_set rfds = G.readfds;
-		struct timeval tv = { 15, 0 };
-		int i;
-		int tim = time(NULL);
-
-		select(G.conncnt + FCS, &rfds, NULL, NULL, G.conncnt? &tv: NULL);
-
-		for (i = G.conncnt - 1; i >= 0; i--) {
-			int s = i + FCS;
-
-			if (FD_ISSET(s, &rfds)) {
-				char *buf = conns[i].buf;
-				unsigned len = conns[i].len;
-				unsigned l;
-
-				l = read(s, buf + len, sizeof(conns[0].buf) - len);
-				if (l > 0) {
-					if (checkInput(buf, len, l)) {
-						reply(s, buf);
-						goto deleteconn;
-					} else if (len + l >= sizeof(conns[0].buf)) {
-						replyError(s, "X-INVALID-REQUEST");
-						goto deleteconn;
-					} else {
-						conns[i].len += l;
-					}
-				} else {
-					goto deleteconn;
-				}
-				conns[i].lasttime = tim;
-				continue;
-deleteconn:
-				deleteConn(s);
-			} else {
-				/* implement as time_after() in linux kernel sources ... */
-				if (conns[i].lasttime + MAXIDLETIME <= tim) {
-					replyError(s, "X-TIMEOUT");
-					deleteConn(s);
-				}
-			}
-		}
-
-		if (FD_ISSET(0, &rfds)) {
-			int s = accept(0, NULL, 0);
-
-			if (s < 0) {
-				if (errno != EINTR)
-					bb_perror_msg("accept");
-			} else {
-				if (G.conncnt == MAXCONNS)
-					i = closeOldest();
-				else
-					i = G.conncnt++;
-
-				movefd(s, i + FCS); /* move if not already there */
-				FD_SET(i + FCS, &G.readfds);
-				conns[i].len = 0;
-				conns[i].lasttime = time(NULL);
-			}
-		}
-	} /* end of while (1) */
-
-	return 0;
-}
-
-#endif /* !SANE_INETD_ONLY_VERSION */
+/* TO DELETE */
diff --git a/networking/nslookup.c b/networking/nslookup.c
index af0816215..914f3f5ee 100644
--- a/networking/nslookup.c
+++ b/networking/nslookup.c
@@ -47,57 +47,8 @@
  * ns3.kernel.org  internet address = 204.152.191.36
  */
 
-/*static int sockaddr_to_dotted(struct sockaddr *saddr, char *buf, int buflen)
-{
-	if (buflen <= 0) return -1;
-	buf[0] = '\0';
-	if (saddr->sa_family == AF_INET) {
-		inet_ntop(AF_INET, &((struct sockaddr_in*)saddr)->sin_addr, buf, buflen);
-		return 0;
-	}
-	if (saddr->sa_family == AF_INET6) {
-		inet_ntop(AF_INET6, &((struct sockaddr_in6*)saddr)->sin6_addr, buf, buflen);
-		return 0;
-	}
-	return -1;
-}
-*/
-
 static int print_host(const char *hostname, const char *header)
 {
-#if 0
-	char str[128];	/* IPv6 address will fit, hostnames hopefully too */
-	struct addrinfo *result = NULL;
-	int rc;
-	struct addrinfo hint;
-
-	memset(&hint, 0 , sizeof(hint));
-	/* hint.ai_family = AF_UNSPEC; - zero anyway */
-	/* Needed. Or else we will get each address thrice (or more)
-	 * for each possible socket type (tcp,udp,raw...): */
-	hint.ai_socktype = SOCK_STREAM;
-	// hint.ai_flags = AI_CANONNAME;
-	rc = getaddrinfo(hostname, NULL /*service*/, &hint, &result);
-
-	if (!rc) {
-		struct addrinfo *cur = result;
-		// printf("%s\n", cur->ai_canonname); ?
-		while (cur) {
-			sockaddr_to_dotted(cur->ai_addr, str, sizeof(str));
-			printf("%s  %s\nAddress: %s", header, hostname, str);
-			str[0] = ' ';
-			if (getnameinfo(cur->ai_addr, cur->ai_addrlen, str+1, sizeof(str)-1, NULL, 0, NI_NAMEREQD))
-				str[0] = '\0';
-			puts(str);
-			cur = cur->ai_next;
-		}
-	} else {
-		bb_error_msg("getaddrinfo('%s') failed: %s", hostname, gai_strerror(rc));
-	}
-	freeaddrinfo(result);
-	return (rc != 0);
-
-#else
 	/* We can't use host2sockaddr() - we want to get ALL addresses,
 	 * not just one */
 
@@ -136,7 +87,7 @@ static int print_host(const char *hostname, const char *header)
 		}
 	} else {
 #if ENABLE_VERBOSE_RESOLUTION_ERRORS
-		bb_error_msg("getaddrinfo('%s') failed: %s", hostname, gai_strerror(rc));
+		bb_error_msg("can't resolve '%s': %s", hostname, gai_strerror(rc));
 #else
 		bb_error_msg("can't resolve '%s'", hostname);
 #endif
@@ -144,10 +95,8 @@ static int print_host(const char *hostname, const char *header)
 	if (ENABLE_FEATURE_CLEAN_UP)
 		freeaddrinfo(result);
 	return (rc != 0);
-#endif
 }
 
-
 /* lookup the default nameserver and display it */
 static void server_print(void)
 {
@@ -167,7 +116,6 @@ static void server_print(void)
 	puts("");
 }
 
-
 /* alter the global _res nameserver structure to use
    an explicit dns server instead of what is in /etc/resolv.h */
 static void set_default_dns(char *server)
@@ -180,7 +128,6 @@ static void set_default_dns(char *server)
 	}
 }
 
-
 int nslookup_main(int argc, char **argv)
 {
 	/* We allow 1 or 2 arguments.
diff --git a/networking/ping6.c b/networking/ping6.c
index ccb19b2b5..b95e098ad 100644
--- a/networking/ping6.c
+++ b/networking/ping6.c
@@ -48,8 +48,6 @@ static void ping(const char *host);
 
 /* simple version */
 
-//static struct hostent *h;
-
 static void noresp(int ign)
 {
 	printf("No response from %s\n", h->h_name);
@@ -58,7 +56,7 @@ static void noresp(int ign)
 
 static void ping(const char *host)
 {
-	len_and_sockaddr *lsa;//
+	len_and_sockaddr *lsa;
 	struct sockaddr_in6 pingaddr;
 	struct icmp6_hdr *pkt;
 	int pingsock, c;
@@ -67,10 +65,6 @@ static void ping(const char *host)
 
 	pingsock = create_icmp6_socket();
 
-	//memset(&pingaddr, 0, sizeof(pingaddr));
-	//pingaddr.sin6_family = AF_INET6;
-	//h = xgethostbyname2(host, AF_INET6);
-	//memcpy(&pingaddr.sin6_addr, h->h_addr, sizeof(pingaddr.sin6_addr));
 	lsa = host_and_af2sockaddr(host, 0, AF_INET6);
 	pingaddr = lsa->sin6;
 
@@ -144,8 +138,7 @@ static int myid;
 static unsigned long tmin = ULONG_MAX, tmax, tsum;
 static char rcvd_tbl[MAX_DUP_CHK / 8];
 
-//static struct hostent *hostent;
-char *hostname;
+static char *hostname;
 
 static void sendping(int);
 static void pingstats(int);
@@ -318,7 +311,7 @@ static void unpack(char *packet, int sz, struct sockaddr_in6 *from, int hoplimit
 extern int BUG_bad_offsetof_icmp6_cksum(void);
 static void ping(const char *host)
 {
-	len_and_sockaddr *lsa;//
+	len_and_sockaddr *lsa;
 	char packet[datalen + MAXIPLEN + MAXICMPLEN];
 	char buf[INET6_ADDRSTRLEN];
 	int sockopt;
@@ -329,12 +322,6 @@ static void ping(const char *host)
 
 	pingsock = create_icmp6_socket();
 
-	//memset(&pingaddr, 0, sizeof(pingaddr));
-	//pingaddr.sin6_family = AF_INET6;
-	//hostent = xgethostbyname2(host, AF_INET6);
-	//if (hostent->h_addrtype != AF_INET6)
-	//	bb_error_msg_and_die("unknown address type; only AF_INET6 is currently supported");
-	//memcpy(&pingaddr.sin6_addr, hostent->h_addr, sizeof(pingaddr.sin6_addr));
 	lsa = host_and_af2sockaddr(host, 0, AF_INET6);
 	hostname = xmalloc_sockaddr2host_noport(&lsa->sa, lsa->len);
 	pingaddr = lsa->sin6;
diff --git a/scripts/defconfig b/scripts/defconfig
index 8f15481de..6a1c57bc8 100644
--- a/scripts/defconfig
+++ b/scripts/defconfig
@@ -501,6 +501,7 @@ CONFIG_WATCHDOG=y
 # Networking Utilities
 #
 CONFIG_FEATURE_IPV6=y
+# CONFIG_VERBOSE_RESOLUTION_ERRORS is not set
 CONFIG_ARP=y
 CONFIG_ARPING=y
 CONFIG_DNSD=y