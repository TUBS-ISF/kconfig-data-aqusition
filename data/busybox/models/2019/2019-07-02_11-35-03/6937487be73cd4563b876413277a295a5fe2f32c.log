"2019-07-02 11:35:03 +0200"
diff --git a/Config.in b/Config.in
index 1a726f043..14f54aacc 100644
--- a/Config.in
+++ b/Config.in
@@ -661,6 +661,19 @@ config WERROR
 
 	Most people should answer N.
 
+config WARN_SIMPLE_MSG
+	bool "Warn about single parameter bb_xx_msg calls"
+	default n
+	help
+	This will cause warnings to be shown for any instances of
+	bb_error_msg(), bb_error_msg_and_die(), bb_perror_msg(),
+	bb_perror_msg_and_die(), bb_herror_msg() or bb_herror_msg_and_die()
+	being called with a single parameter. In these cases the equivalent
+	bb_simple_xx_msg function should be used instead.
+	Note that use of STRERROR_FMT may give false positives.
+
+	If you aren't developing busybox, say N here.
+
 choice
 	prompt "Additional debugging library"
 	default NO_DEBUG_LIB
diff --git a/archival/bbunzip.c b/archival/bbunzip.c
index 93f30d324..d31aaf7f3 100644
--- a/archival/bbunzip.c
+++ b/archival/bbunzip.c
@@ -114,7 +114,7 @@ int FAST_FUNC bbunpack(char **argv,
 
 		/* Check that the input is sane */
 		if (!(option_mask32 & BBUNPK_OPT_FORCE) && isatty(STDIN_FILENO)) {
-			bb_error_msg_and_die("compressed data not read from terminal, "
+			bb_simple_error_msg_and_die("compressed data not read from terminal, "
 					"use -f to force it");
 		}
 
diff --git a/archival/bzip2.c b/archival/bzip2.c
index 38cc0219a..d0390a92a 100644
--- a/archival/bzip2.c
+++ b/archival/bzip2.c
@@ -145,7 +145,7 @@ IF_DESKTOP(long long) int bz_write(bz_stream *strm, void* rbuf, ssize_t rlen, vo
 			if (n2 != n) {
 				if (n2 >= 0)
 					errno = 0; /* prevent bogus error message */
-				bb_perror_msg(n2 >= 0 ? "short write" : bb_msg_write_error);
+				bb_simple_perror_msg(n2 >= 0 ? "short write" : bb_msg_write_error);
 				return -1;
 			}
 		}
@@ -187,7 +187,7 @@ IF_DESKTOP(long long) int FAST_FUNC compressStream(transformer_state_t *xstate U
 	while (1) {
 		count = full_read(STDIN_FILENO, rbuf, IOBUF_SIZE);
 		if (count < 0) {
-			bb_perror_msg(bb_msg_read_error);
+			bb_simple_perror_msg(bb_msg_read_error);
 			total = -1;
 			break;
 		}
diff --git a/archival/dpkg.c b/archival/dpkg.c
index ddb5daf09..da77fba05 100644
--- a/archival/dpkg.c
+++ b/archival/dpkg.c
@@ -487,7 +487,7 @@ static void add_split_dependencies(common_node_t *parent_node, const char *whole
 					} else if (strncmp(version, ">=", offset_ch) == 0) {
 						edge->operator = VER_MORE_EQUAL;
 					} else {
-						bb_error_msg_and_die("illegal operator");
+						bb_simple_error_msg_and_die("illegal operator");
 					}
 				}
 				/* skip to start of version numbers */
@@ -730,7 +730,7 @@ static void set_status(const unsigned status_node_num, const char *new_value, co
 			status = new_value_num;
 			break;
 		default:
-			bb_error_msg_and_die("DEBUG ONLY: this shouldnt happen");
+			bb_simple_error_msg_and_die("DEBUG ONLY: this shouldnt happen");
 	}
 
 	new_status = xasprintf("%s %s %s", name_hashtable[want], name_hashtable[flag], name_hashtable[status]);
@@ -944,10 +944,10 @@ static void write_status_file(deb_file_t **deb_file)
 	/* Create a separate backfile to dpkg */
 	if (rename("/var/lib/dpkg/status", "/var/lib/dpkg/status.udeb.bak") == -1) {
 		if (errno != ENOENT)
-			bb_error_msg_and_die("can't create backup status file");
+			bb_simple_error_msg_and_die("can't create backup status file");
 		/* Its ok if renaming the status file fails because status
 		 * file doesn't exist, maybe we are starting from scratch */
-		bb_error_msg("no status file found, creating new one");
+		bb_simple_error_msg("no status file found, creating new one");
 	}
 
 	xrename("/var/lib/dpkg/status.udeb", "/var/lib/dpkg/status");
@@ -1816,7 +1816,7 @@ int dpkg_main(int argc UNUSED_PARAM, char **argv)
 			init_archive_deb_control(archive_handle);
 			deb_file[deb_count]->control_file = deb_extract_control_file_to_buffer(archive_handle, control_list);
 			if (deb_file[deb_count]->control_file == NULL) {
-				bb_error_msg_and_die("can't extract control file");
+				bb_simple_error_msg_and_die("can't extract control file");
 			}
 			deb_file[deb_count]->filename = xstrdup(argv[0]);
 			package_num = fill_package_struct(deb_file[deb_count]->control_file);
@@ -1879,13 +1879,13 @@ int dpkg_main(int argc UNUSED_PARAM, char **argv)
 		argv++;
 	}
 	if (!deb_count)
-		bb_error_msg_and_die("no package files specified");
+		bb_simple_error_msg_and_die("no package files specified");
 	deb_file[deb_count] = NULL;
 
 	/* Check that the deb file arguments are installable */
 	if (!(opt & OPT_force_ignore_depends)) {
 		if (!check_deps(deb_file, 0 /*, deb_count*/)) {
-			bb_error_msg_and_die("dependency check failed");
+			bb_simple_error_msg_and_die("dependency check failed");
 		}
 	}
 
diff --git a/archival/gzip.c b/archival/gzip.c
index 12c1df242..17341de45 100644
--- a/archival/gzip.c
+++ b/archival/gzip.c
@@ -99,7 +99,7 @@ aa:      85.1% -- replaced with aa.gz
 /* Diagnostic functions */
 #ifdef DEBUG
 static int verbose;
-#  define Assert(cond,msg) { if (!(cond)) bb_error_msg(msg); }
+#  define Assert(cond,msg) { if (!(cond)) bb_simple_error_msg(msg); }
 #  define Trace(x) fprintf x
 #  define Tracev(x) {if (verbose) fprintf x; }
 #  define Tracevv(x) {if (verbose > 1) fprintf x; }
@@ -787,7 +787,7 @@ static void check_match(IPos start, IPos match, int length)
 	/* check that the match is indeed a match */
 	if (memcmp(G1.window + match, G1.window + start, length) != 0) {
 		bb_error_msg(" start %d, match %d, length %d", start, match, length);
-		bb_error_msg("invalid match");
+		bb_simple_error_msg("invalid match");
 	}
 	if (verbose > 1) {
 		bb_error_msg("\\[%d,%d]", start - match, length);
diff --git a/archival/libarchive/data_extract_all.c b/archival/libarchive/data_extract_all.c
index 4c95db4a6..3142405a3 100644
--- a/archival/libarchive/data_extract_all.c
+++ b/archival/libarchive/data_extract_all.c
@@ -103,7 +103,7 @@ void FAST_FUNC data_extract_all(archive_handle_t *archive_handle)
 		struct stat existing_sb;
 		if (lstat(dst_name, &existing_sb) == -1) {
 			if (errno != ENOENT) {
-				bb_perror_msg_and_die("can't stat old file");
+				bb_simple_perror_msg_and_die("can't stat old file");
 			}
 		}
 		else if (existing_sb.st_mtime >= file_header->mtime) {
@@ -207,7 +207,7 @@ void FAST_FUNC data_extract_all(archive_handle_t *archive_handle)
 		}
 		break;
 	default:
-		bb_error_msg_and_die("unrecognized file type");
+		bb_simple_error_msg_and_die("unrecognized file type");
 	}
 
 	if (!S_ISLNK(file_header->mode)) {
diff --git a/archival/libarchive/decompress_bunzip2.c b/archival/libarchive/decompress_bunzip2.c
index 1f535b32a..42e2b4f88 100644
--- a/archival/libarchive/decompress_bunzip2.c
+++ b/archival/libarchive/decompress_bunzip2.c
@@ -817,7 +817,7 @@ unpack_bz2_stream(transformer_state_t *xstate)
 			break;
 		}
 		if (bd->headerCRC != bd->totalCRC) {
-			bb_error_msg("CRC error");
+			bb_simple_error_msg("CRC error");
 			break;
 		}
 
diff --git a/archival/libarchive/decompress_gunzip.c b/archival/libarchive/decompress_gunzip.c
index 7f9046b82..1ddce610c 100644
--- a/archival/libarchive/decompress_gunzip.c
+++ b/archival/libarchive/decompress_gunzip.c
@@ -1012,7 +1012,7 @@ inflate_unzip_internal(STATE_PARAM transformer_state_t *xstate)
 	error_msg = "corrupted data";
 	if (setjmp(error_jmp)) {
 		/* Error from deep inside zip machinery */
-		bb_error_msg(error_msg);
+		bb_simple_error_msg(error_msg);
 		n = -1;
 		goto ret;
 	}
@@ -1085,7 +1085,7 @@ static int top_up(STATE_PARAM unsigned n)
 		bytebuffer_offset = 0;
 		bytebuffer_size = full_read(gunzip_src_fd, &bytebuffer[count], bytebuffer_max - count);
 		if ((int)bytebuffer_size < 0) {
-			bb_error_msg(bb_msg_read_error);
+			bb_simple_error_msg(bb_msg_read_error);
 			return 0;
 		}
 		bytebuffer_size += count;
@@ -1211,7 +1211,7 @@ unpack_gz_stream(transformer_state_t *xstate)
 
 		if (full_read(xstate->src_fd, &magic2, 2) != 2) {
  bad_magic:
-			bb_error_msg("invalid magic");
+			bb_simple_error_msg("invalid magic");
 			return -1;
 		}
 		if (magic2 == COMPRESS_MAGIC) {
@@ -1233,7 +1233,7 @@ unpack_gz_stream(transformer_state_t *xstate)
 
  again:
 	if (!check_header_gzip(PASS_STATE xstate)) {
-		bb_error_msg("corrupted data");
+		bb_simple_error_msg("corrupted data");
 		total = -1;
 		goto ret;
 	}
@@ -1246,7 +1246,7 @@ unpack_gz_stream(transformer_state_t *xstate)
 	total += n;
 
 	if (!top_up(PASS_STATE 8)) {
-		bb_error_msg("corrupted data");
+		bb_simple_error_msg("corrupted data");
 		total = -1;
 		goto ret;
 	}
@@ -1254,7 +1254,7 @@ unpack_gz_stream(transformer_state_t *xstate)
 	/* Validate decompression - crc */
 	v32 = buffer_read_le_u32(PASS_STATE_ONLY);
 	if ((~gunzip_crc) != v32) {
-		bb_error_msg("crc error");
+		bb_simple_error_msg("crc error");
 		total = -1;
 		goto ret;
 	}
@@ -1262,7 +1262,7 @@ unpack_gz_stream(transformer_state_t *xstate)
 	/* Validate decompression - size */
 	v32 = buffer_read_le_u32(PASS_STATE_ONLY);
 	if ((uint32_t)gunzip_bytes_out != v32) {
-		bb_error_msg("incorrect length");
+		bb_simple_error_msg("incorrect length");
 		total = -1;
 	}
 
diff --git a/archival/libarchive/decompress_uncompress.c b/archival/libarchive/decompress_uncompress.c
index 1517559c6..2725a7f09 100644
--- a/archival/libarchive/decompress_uncompress.c
+++ b/archival/libarchive/decompress_uncompress.c
@@ -113,7 +113,7 @@ unpack_Z_stream(transformer_state_t *xstate)
 	/* xread isn't good here, we have to return - caller may want
 	 * to do some cleanup (e.g. delete incomplete unpacked file etc) */
 	if (full_read(xstate->src_fd, inbuf, 1) != 1) {
-		bb_error_msg("short read");
+		bb_simple_error_msg("short read");
 		goto err;
 	}
 
@@ -166,7 +166,7 @@ unpack_Z_stream(transformer_state_t *xstate)
 		if (insize < (int) (IBUFSIZ + 64) - IBUFSIZ) {
 			rsize = safe_read(xstate->src_fd, inbuf + insize, IBUFSIZ);
 			if (rsize < 0)
-				bb_error_msg_and_die(bb_msg_read_error);
+				bb_simple_error_msg_and_die(bb_msg_read_error);
 			insize += rsize;
 		}
 
@@ -200,7 +200,7 @@ unpack_Z_stream(transformer_state_t *xstate)
 
 			if (oldcode == -1) {
 				if (code >= 256)
-					bb_error_msg_and_die("corrupted data"); /* %ld", code); */
+					bb_simple_error_msg_and_die("corrupted data"); /* %ld", code); */
 				oldcode = code;
 				finchar = (int) oldcode;
 				outbuf[outpos++] = (unsigned char) finchar;
@@ -236,7 +236,7 @@ unpack_Z_stream(transformer_state_t *xstate)
 						insize, posbits, p[-1], p[0], p[1], p[2], p[3],
 						(posbits & 07));
 */
-					bb_error_msg("corrupted data");
+					bb_simple_error_msg("corrupted data");
 					goto err;
 				}
 
@@ -247,7 +247,7 @@ unpack_Z_stream(transformer_state_t *xstate)
 			/* Generate output characters in reverse order */
 			while (code >= 256) {
 				if (stackp <= &htabof(0))
-					bb_error_msg_and_die("corrupted data");
+					bb_simple_error_msg_and_die("corrupted data");
 				*--stackp = tab_suffixof(code);
 				code = tab_prefixof(code);
 			}
diff --git a/archival/libarchive/decompress_unlzma.c b/archival/libarchive/decompress_unlzma.c
index 668b01618..0744f231a 100644
--- a/archival/libarchive/decompress_unlzma.c
+++ b/archival/libarchive/decompress_unlzma.c
@@ -59,7 +59,7 @@ static void rc_read(rc_t *rc)
 //TODO: return -1 instead
 //This will make unlzma delete broken unpacked file on unpack errors
 	if (buffer_size <= 0)
-		bb_error_msg_and_die("unexpected EOF");
+		bb_simple_error_msg_and_die("unexpected EOF");
 	rc->buffer_end = RC_BUFFER + buffer_size;
 	rc->ptr = RC_BUFFER;
 }
@@ -234,7 +234,7 @@ unpack_lzma_stream(transformer_state_t *xstate)
 	if (full_read(xstate->src_fd, &header, sizeof(header)) != sizeof(header)
 	 || header.pos >= (9 * 5 * 5)
 	) {
-		bb_error_msg("bad lzma header");
+		bb_simple_error_msg("bad lzma header");
 		return -1;
 	}
 
@@ -513,7 +513,7 @@ unpack_lzma_stream(transformer_state_t *xstate)
 			 * potentially more detailed information).
 			 * Do not fail silently.
 			 */
-			bb_error_msg("corrupted data");
+			bb_simple_error_msg("corrupted data");
 			total_written = -1; /* failure */
 		}
 		rc_free(rc);
diff --git a/archival/libarchive/decompress_unxz.c b/archival/libarchive/decompress_unxz.c
index 8ae7a275b..f03341384 100644
--- a/archival/libarchive/decompress_unxz.c
+++ b/archival/libarchive/decompress_unxz.c
@@ -74,7 +74,7 @@ unpack_xz_stream(transformer_state_t *xstate)
 		if (iobuf.in_pos == iobuf.in_size) {
 			int rd = safe_read(xstate->src_fd, membuf, BUFSIZ);
 			if (rd < 0) {
-				bb_error_msg(bb_msg_read_error);
+				bb_simple_error_msg(bb_msg_read_error);
 				total = -1;
 				break;
 			}
@@ -123,7 +123,7 @@ unpack_xz_stream(transformer_state_t *xstate)
 			continue;
 		}
 		if (xz_result != XZ_OK && xz_result != XZ_UNSUPPORTED_CHECK) {
-			bb_error_msg("corrupted data");
+			bb_simple_error_msg("corrupted data");
 			total = -1;
 			break;
 		}
diff --git a/archival/libarchive/get_header_ar.c b/archival/libarchive/get_header_ar.c
index 7ce9c615c..b6ecd596c 100644
--- a/archival/libarchive/get_header_ar.c
+++ b/archival/libarchive/get_header_ar.c
@@ -22,7 +22,7 @@ static unsigned read_num(char *str, int base, int len)
 	 * on misformatted numbers bb_strtou returns all-ones */
 	err = bb_strtou(str, NULL, base);
 	if (err == -1)
-		bb_error_msg_and_die("invalid ar header");
+		bb_simple_error_msg_and_die("invalid ar header");
 	return err;
 }
 
@@ -53,7 +53,7 @@ char FAST_FUNC get_header_ar(archive_handle_t *archive_handle)
 	archive_handle->offset += 60;
 
 	if (ar.formatted.magic[0] != '`' || ar.formatted.magic[1] != '\n')
-		bb_error_msg_and_die("invalid ar header");
+		bb_simple_error_msg_and_die("invalid ar header");
 
 	/*
 	 * Note that the fields MUST be read in reverse order as
@@ -86,7 +86,7 @@ char FAST_FUNC get_header_ar(archive_handle_t *archive_handle)
 			return get_header_ar(archive_handle);
 		}
 #else
-		bb_error_msg_and_die("long filenames not supported");
+		bb_simple_error_msg_and_die("long filenames not supported");
 #endif
 	}
 	/* Only size is always present, the rest may be missing in
@@ -107,7 +107,7 @@ char FAST_FUNC get_header_ar(archive_handle_t *archive_handle)
 		long_offset = read_num(&ar.formatted.name[1], 10,
 				       sizeof(ar.formatted.name) - 1);
 		if (long_offset >= archive_handle->ar__long_name_size) {
-			bb_error_msg_and_die("can't resolve long filename");
+			bb_simple_error_msg_and_die("can't resolve long filename");
 		}
 		typed->name = xstrdup(archive_handle->ar__long_names + long_offset);
 	} else
diff --git a/archival/libarchive/get_header_cpio.c b/archival/libarchive/get_header_cpio.c
index 75fc6a406..4ad174732 100644
--- a/archival/libarchive/get_header_cpio.c
+++ b/archival/libarchive/get_header_cpio.c
@@ -33,14 +33,14 @@ char FAST_FUNC get_header_cpio(archive_handle_t *archive_handle)
 		goto create_hardlinks;
 	}
 	if (size != 110) {
-		bb_error_msg_and_die("short read");
+		bb_simple_error_msg_and_die("short read");
 	}
 	archive_handle->offset += 110;
 
 	if (!is_prefixed_with(&cpio_header[0], "07070")
 	 || (cpio_header[5] != '1' && cpio_header[5] != '2')
 	) {
-		bb_error_msg_and_die("unsupported cpio format, use newc or crc");
+		bb_simple_error_msg_and_die("unsupported cpio format, use newc or crc");
 	}
 
 	if (sscanf(cpio_header + 6,
@@ -50,7 +50,7 @@ char FAST_FUNC get_header_cpio(archive_handle_t *archive_handle)
 			&inode, &mode, &uid, &gid,
 			&nlink, &mtime, &size,
 			&major, &minor, &namesize) != 10)
-		bb_error_msg_and_die("damaged cpio file");
+		bb_simple_error_msg_and_die("damaged cpio file");
 	file_header->mode = mode;
 	/* "cpio -R USER:GRP" support: */
 	if (archive_handle->cpio__owner.uid != (uid_t)-1L)
diff --git a/archival/libarchive/get_header_tar.c b/archival/libarchive/get_header_tar.c
index 52fa4554a..b3131ff2d 100644
--- a/archival/libarchive/get_header_tar.c
+++ b/archival/libarchive/get_header_tar.c
@@ -32,7 +32,7 @@ static unsigned long long getOctal(char *str, int len)
 	if (*end != '\0' && *end != ' ') {
 		int8_t first = str[0];
 		if (!(first & 0x80))
-			bb_error_msg_and_die("corrupted octal value in tar header");
+			bb_simple_error_msg_and_die("corrupted octal value in tar header");
 		/*
 		 * GNU tar uses "base-256 encoding" for very large numbers.
 		 * Encoding is binary, with highest bit always set as a marker
@@ -100,7 +100,7 @@ static void process_pax_hdr(archive_handle_t *archive_handle, unsigned sz, int g
 		 || errno != EINVAL
 		 || *end != ' '
 		) {
-			bb_error_msg("malformed extended header, skipped");
+			bb_simple_error_msg("malformed extended header, skipped");
 			// More verbose version:
 			//bb_error_msg("malformed extended header at %"OFF_FMT"d, skipped",
 			//		archive_handle->offset - (sz + len));
@@ -194,13 +194,13 @@ char FAST_FUNC get_header_tar(archive_handle_t *archive_handle)
 		 * the very first read fails. Grrr.
 		 */
 		if (archive_handle->offset == 0)
-			bb_error_msg("short read");
+			bb_simple_error_msg("short read");
 		/* this merely signals end of archive, not exit(1): */
 		return EXIT_FAILURE;
 	}
 	if (i != 512) {
 		IF_FEATURE_TAR_AUTODETECT(goto autodetect;)
-		bb_error_msg_and_die("short read");
+		bb_simple_error_msg_and_die("short read");
 	}
 
 #else
@@ -243,11 +243,11 @@ char FAST_FUNC get_header_tar(archive_handle_t *archive_handle)
 			goto err;
 		if (setup_unzip_on_fd(archive_handle->src_fd, /*fail_if_not_compressed:*/ 0) != 0)
  err:
-			bb_error_msg_and_die("invalid tar magic");
+			bb_simple_error_msg_and_die("invalid tar magic");
 		archive_handle->offset = 0;
 		goto again_after_align;
 #endif
-		bb_error_msg_and_die("invalid tar magic");
+		bb_simple_error_msg_and_die("invalid tar magic");
 	}
 
 	/* Do checksum on headers.
@@ -282,7 +282,7 @@ char FAST_FUNC get_header_tar(archive_handle_t *archive_handle)
 	if (sum_u != sum
 	    IF_FEATURE_TAR_OLDSUN_COMPATIBILITY(&& sum_s != sum)
 	) {
-		bb_error_msg_and_die("invalid tar header checksum");
+		bb_simple_error_msg_and_die("invalid tar header checksum");
 	}
 
 	/* GET_OCTAL trashes subsequent field, therefore we call it
diff --git a/archival/libarchive/open_transformer.c b/archival/libarchive/open_transformer.c
index a90f42a45..44715ef25 100644
--- a/archival/libarchive/open_transformer.c
+++ b/archival/libarchive/open_transformer.c
@@ -15,7 +15,7 @@ int FAST_FUNC check_signature16(transformer_state_t *xstate, unsigned magic16)
 	if (!xstate->signature_skipped) {
 		uint16_t magic2;
 		if (full_read(xstate->src_fd, &magic2, 2) != 2 || magic2 != magic16) {
-			bb_error_msg("invalid magic");
+			bb_simple_error_msg("invalid magic");
 			return -1;
 		}
 		xstate->signature_skipped = 2;
@@ -46,7 +46,7 @@ ssize_t FAST_FUNC transformer_write(transformer_state_t *xstate, const void *buf
 	} else {
 		nwrote = full_write(xstate->dst_fd, buf, bufsize);
 		if (nwrote != (ssize_t)bufsize) {
-			bb_perror_msg("write");
+			bb_simple_perror_msg("write");
 			nwrote = -1;
 			goto ret;
 		}
@@ -205,7 +205,7 @@ static transformer_state_t *setup_transformer_on_fd(int fd, int fail_if_not_comp
 
 	/* No known magic seen */
 	if (fail_if_not_compressed)
-		bb_error_msg_and_die("no gzip"
+		bb_simple_error_msg_and_die("no gzip"
 			IF_FEATURE_SEAMLESS_BZ2("/bzip2")
 			IF_FEATURE_SEAMLESS_XZ("/xz")
 			" magic");
diff --git a/archival/libarchive/seek_by_jump.c b/archival/libarchive/seek_by_jump.c
index 232d97e53..dddaa3732 100644
--- a/archival/libarchive/seek_by_jump.c
+++ b/archival/libarchive/seek_by_jump.c
@@ -13,6 +13,6 @@ void FAST_FUNC seek_by_jump(int fd, off_t amount)
 		if (errno == ESPIPE)
 			seek_by_read(fd, amount);
 		else
-			bb_perror_msg_and_die("seek failure");
+			bb_simple_perror_msg_and_die("seek failure");
 	}
 }
diff --git a/archival/libarchive/unpack_ar_archive.c b/archival/libarchive/unpack_ar_archive.c
index 4f9f89874..584c18ce8 100644
--- a/archival/libarchive/unpack_ar_archive.c
+++ b/archival/libarchive/unpack_ar_archive.c
@@ -12,7 +12,7 @@ void FAST_FUNC unpack_ar_archive(archive_handle_t *ar_archive)
 
 	xread(ar_archive->src_fd, magic, AR_MAGIC_LEN);
 	if (!is_prefixed_with(magic, AR_MAGIC)) {
-		bb_error_msg_and_die("invalid ar magic");
+		bb_simple_error_msg_and_die("invalid ar magic");
 	}
 	ar_archive->offset += AR_MAGIC_LEN;
 
diff --git a/archival/lzop.c b/archival/lzop.c
index 585632c4e..bdd21598c 100644
--- a/archival/lzop.c
+++ b/archival/lzop.c
@@ -752,7 +752,7 @@ static FAST_FUNC void lzo_check(
 	 */
 	uint32_t c = fn(init, buf, len);
 	if (c != ref)
-		bb_error_msg_and_die("checksum error");
+		bb_simple_error_msg_and_die("checksum error");
 }
 
 /**********************************************************************/
@@ -785,15 +785,15 @@ static NOINLINE int lzo_decompress(uint32_t h_flags32)
 		/* error if split file */
 		if (dst_len == 0xffffffffL)
 			/* should not happen - not yet implemented */
-			bb_error_msg_and_die("this file is a split lzop file");
+			bb_simple_error_msg_and_die("this file is a split lzop file");
 
 		if (dst_len > MAX_BLOCK_SIZE)
-			bb_error_msg_and_die("corrupted data");
+			bb_simple_error_msg_and_die("corrupted data");
 
 		/* read compressed block size */
 		src_len = read32();
 		if (src_len <= 0 || src_len > dst_len)
-			bb_error_msg_and_die("corrupted data");
+			bb_simple_error_msg_and_die("corrupted data");
 
 		if (dst_len > block_size) {
 			if (b2) {
@@ -846,7 +846,7 @@ static NOINLINE int lzo_decompress(uint32_t h_flags32)
 				r = lzo1x_decompress_safe(b1, src_len, b2, &d /*, NULL*/);
 
 			if (r != 0 /*LZO_E_OK*/ || dst_len != d) {
-				bb_error_msg_and_die("corrupted data");
+				bb_simple_error_msg_and_die("corrupted data");
 			}
 			dst = b2;
 		} else {
@@ -913,7 +913,7 @@ static void check_magic(void)
 	unsigned char magic[sizeof(lzop_magic)];
 	xread(0, magic, sizeof(magic));
 	if (memcmp(magic, lzop_magic, sizeof(lzop_magic)) != 0)
-		bb_error_msg_and_die("bad magic number");
+		bb_simple_error_msg_and_die("bad magic number");
 }
 
 /**********************************************************************/
@@ -1049,7 +1049,7 @@ static void lzo_set_method(header_t *h)
 		else if (option_mask32 & OPT_8)
 			level = 8;
 #else
-		bb_error_msg_and_die("high compression not compiled in");
+		bb_simple_error_msg_and_die("high compression not compiled in");
 #endif
 	}
 
diff --git a/archival/rpm.c b/archival/rpm.c
index 95b2531e8..68afba914 100644
--- a/archival/rpm.c
+++ b/archival/rpm.c
@@ -543,7 +543,7 @@ int rpm2cpio_main(int argc UNUSED_PARAM, char **argv)
 	}
 
 	if (bb_copyfd_eof(rpm_fd, STDOUT_FILENO) < 0)
-		bb_error_msg_and_die("error unpacking");
+		bb_simple_error_msg_and_die("error unpacking");
 
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		close(rpm_fd);
diff --git a/archival/tar.c b/archival/tar.c
index 3ef89fb0a..ca802f73c 100644
--- a/archival/tar.c
+++ b/archival/tar.c
@@ -369,7 +369,7 @@ static int writeTarHeader(struct TarBallInfo *tbInfo,
 		/* If it is larger than 100 bytes, bail out */
 		if (header.linkname[sizeof(header.linkname)-1]) {
 			free(lpath);
-			bb_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
+			bb_simple_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
 			return FALSE;
 		}
 # endif
@@ -542,7 +542,7 @@ static int FAST_FUNC writeFileToTarball(const char *fileName, struct stat *statb
 
 # if !ENABLE_FEATURE_TAR_GNU_EXTENSIONS
 	if (strlen(header_name) >= NAME_SIZE) {
-		bb_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
+		bb_simple_error_msg("names longer than "NAME_SIZE_STR" chars not supported");
 		return TRUE;
 	}
 # endif
@@ -715,13 +715,13 @@ static NOINLINE int writeTarFile(
 		freeHardLinkInfo(&tbInfo->hlInfoHead);
 
 	if (errorFlag)
-		bb_error_msg("error exit delayed from previous errors");
+		bb_simple_error_msg("error exit delayed from previous errors");
 
 # if SEAMLESS_COMPRESSION
 	if (gzip) {
 		int status;
 		if (safe_waitpid(-1, &status, 0) == -1)
-			bb_perror_msg("waitpid");
+			bb_simple_perror_msg("waitpid");
 		else if (!WIFEXITED(status) || WEXITSTATUS(status))
 			/* gzip was killed or has exited with nonzero! */
 			errorFlag = TRUE;
@@ -1150,7 +1150,7 @@ int tar_main(int argc UNUSED_PARAM, char **argv)
 		if (opt & OPT_CREATE) {
 			/* Make sure there is at least one file to tar up */
 			if (tar_handle->accept == NULL)
-				bb_error_msg_and_die("empty archive");
+				bb_simple_error_msg_and_die("empty archive");
 
 			tar_fd = STDOUT_FILENO;
 			/* Mimicking GNU tar 1.15.1: */
diff --git a/archival/unzip.c b/archival/unzip.c
index 466794031..8c4cb9881 100644
--- a/archival/unzip.c
+++ b/archival/unzip.c
@@ -322,7 +322,7 @@ static uint32_t read_next_cdf(uint32_t cdf_offset, cdf_header_t *cdf)
 static void die_if_bad_fnamesize(unsigned sz)
 {
 	if (sz > 0xfff) /* more than 4k?! no funny business please */
-		bb_error_msg_and_die("bad archive");
+		bb_simple_error_msg_and_die("bad archive");
 }
 
 static void unzip_skip(off_t skip)
@@ -359,7 +359,7 @@ static void unzip_extract_symlink(llist_t **symlink_placeholders,
 		xread(zip_fd, target, zip->fmt.ucmpsize);
 	} else {
 #if 1
-		bb_error_msg_and_die("compressed symlink is not supported");
+		bb_simple_error_msg_and_die("compressed symlink is not supported");
 #else
 		transformer_state_t xstate;
 		init_transformer_state(&xstate);
@@ -399,10 +399,10 @@ static void unzip_extract(zip_header_t *zip, int dst_fd)
 	if (zip->fmt.method == 8) {
 		/* Method 8 - inflate */
 		if (inflate_unzip(&xstate) < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 		/* Validate decompression - crc */
 		if (zip->fmt.crc32 != (xstate.crc32 ^ 0xffffffffL)) {
-			bb_error_msg_and_die("crc error");
+			bb_simple_error_msg_and_die("crc error");
 		}
 	}
 #if ENABLE_FEATURE_UNZIP_BZIP2
@@ -412,7 +412,7 @@ static void unzip_extract(zip_header_t *zip, int dst_fd)
 		 */
 		xstate.bytes_out = unpack_bz2_stream(&xstate);
 		if (xstate.bytes_out < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 	}
 #endif
 #if ENABLE_FEATURE_UNZIP_LZMA
@@ -420,7 +420,7 @@ static void unzip_extract(zip_header_t *zip, int dst_fd)
 		/* Not tested yet */
 		xstate.bytes_out = unpack_lzma_stream(&xstate);
 		if (xstate.bytes_out < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 	}
 #endif
 #if ENABLE_FEATURE_UNZIP_XZ
@@ -428,7 +428,7 @@ static void unzip_extract(zip_header_t *zip, int dst_fd)
 		/* Not tested yet */
 		xstate.bytes_out = unpack_xz_stream(&xstate);
 		if (xstate.bytes_out < 0)
-			bb_error_msg_and_die("inflate error");
+			bb_simple_error_msg_and_die("inflate error");
 	}
 #endif
 	else {
@@ -439,7 +439,7 @@ static void unzip_extract(zip_header_t *zip, int dst_fd)
 	if (zip->fmt.ucmpsize != xstate.bytes_out) {
 		/* Don't die. Who knows, maybe len calculation
 		 * was botched somewhere. After all, crc matched! */
-		bb_error_msg("bad length");
+		bb_simple_error_msg("bad length");
 	}
 }
 
@@ -447,7 +447,7 @@ static void my_fgets80(char *buf80)
 {
 	fflush_all();
 	if (!fgets(buf80, 80, stdin)) {
-		bb_perror_msg_and_die("can't read standard input");
+		bb_simple_perror_msg_and_die("can't read standard input");
 	}
 }
 
diff --git a/console-tools/loadfont.c b/console-tools/loadfont.c
index b5d4e8f43..caad7d9ac 100644
--- a/console-tools/loadfont.c
+++ b/console-tools/loadfont.c
@@ -225,7 +225,7 @@ static void do_loadtable(int fd, unsigned char *inbuf, int tailsz, int fontsize,
 				if (unicode == PSF2_SEPARATOR) {
 					break;
 				} else if (unicode == PSF2_STARTSEQ) {
-					bb_error_msg_and_die("unicode sequences not implemented");
+					bb_simple_error_msg_and_die("unicode sequences not implemented");
 				} else if (unicode >= 0xC0) {
 					if (unicode >= 0xFC)
 						unicode &= 0x01, maxct = 5;
@@ -239,12 +239,12 @@ static void do_loadtable(int fd, unsigned char *inbuf, int tailsz, int fontsize,
 						unicode &= 0x1F, maxct = 1;
 					do {
 						if (tailsz <= 0 || *inbuf < 0x80 || *inbuf > 0xBF)
-							bb_error_msg_and_die("illegal UTF-8 character");
+							bb_simple_error_msg_and_die("illegal UTF-8 character");
 						--tailsz;
 						unicode = (unicode << 6) + (*inbuf++ & 0x3F);
 					} while (--maxct > 0);
 				} else if (unicode >= 0x80) {
-					bb_error_msg_and_die("illegal UTF-8 character");
+					bb_simple_error_msg_and_die("illegal UTF-8 character");
 				}
 #else
 				return;
@@ -281,7 +281,7 @@ static void do_load(int fd, unsigned char *buffer, size_t len)
 
 	if (len >= sizeof(struct psf1_header) && PSF1_MAGIC_OK(psf1h(buffer))) {
 		if (psf1h(buffer)->mode > PSF1_MAXMODE)
-			bb_error_msg_and_die("unsupported psf file mode");
+			bb_simple_error_msg_and_die("unsupported psf file mode");
 		if (psf1h(buffer)->mode & PSF1_MODE512)
 			fontsize = 512;
 		if (psf1h(buffer)->mode & PSF1_MODEHASTAB)
@@ -292,7 +292,7 @@ static void do_load(int fd, unsigned char *buffer, size_t len)
 #if ENABLE_FEATURE_LOADFONT_PSF2
 	if (len >= sizeof(struct psf2_header) && PSF2_MAGIC_OK(psf2h(buffer))) {
 		if (psf2h(buffer)->version > PSF2_MAXVERSION)
-			bb_error_msg_and_die("unsupported psf file version");
+			bb_simple_error_msg_and_die("unsupported psf file version");
 		fontsize = psf2h(buffer)->length;
 		if (psf2h(buffer)->flags & PSF2_HAS_UNICODE_TABLE)
 			has_table = 2;
@@ -311,19 +311,19 @@ static void do_load(int fd, unsigned char *buffer, size_t len)
 	} else
 #endif
 	{
-		bb_error_msg_and_die("input file: bad length or unsupported font type");
+		bb_simple_error_msg_and_die("input file: bad length or unsupported font type");
 	}
 
 #if !defined(PIO_FONTX) || defined(__sparc__)
 	if (fontsize != 256)
-		bb_error_msg_and_die("only fontsize 256 supported");
+		bb_simple_error_msg_and_die("only fontsize 256 supported");
 #endif
 
 	table = font + fontsize * charsize;
 	buffer += len;
 
 	if (table > buffer || (!has_table && table != buffer))
-		bb_error_msg_and_die("input file: bad length");
+		bb_simple_error_msg_and_die("input file: bad length");
 
 	do_loadfont(fd, font, height, width, charsize, fontsize);
 
@@ -361,7 +361,7 @@ int loadfont_main(int argc UNUSED_PARAM, char **argv)
 	buffer = xmalloc_read(STDIN_FILENO, &len);
 	// xmalloc_open_zipped_read_close(filename, &len);
 	if (!buffer)
-		bb_perror_msg_and_die("error reading input font");
+		bb_simple_perror_msg_and_die("error reading input font");
 	do_load(get_console_fd_or_die(), buffer, len);
 
 	return EXIT_SUCCESS;
@@ -502,7 +502,7 @@ int setfont_main(int argc UNUSED_PARAM, char **argv)
 				if (a < 0 || a >= E_TABSZ
 				 || b < 0 || b > 65535
 				) {
-					bb_error_msg_and_die("map format");
+					bb_simple_error_msg_and_die("map format");
 				}
 				// patch map
 				unicodes[a] = b;
diff --git a/console-tools/loadkmap.c b/console-tools/loadkmap.c
index d4981ad21..91ef50884 100644
--- a/console-tools/loadkmap.c
+++ b/console-tools/loadkmap.c
@@ -69,7 +69,7 @@ int loadkmap_main(int argc UNUSED_PARAM, char **argv)
 
 	xread(STDIN_FILENO, flags, 7);
 	if (!is_prefixed_with(flags, BINARY_KEYMAP_MAGIC))
-		bb_error_msg_and_die("not a valid binary keymap");
+		bb_simple_error_msg_and_die("not a valid binary keymap");
 
 	xread(STDIN_FILENO, flags, MAX_NR_KEYMAPS);
 
diff --git a/console-tools/openvt.c b/console-tools/openvt.c
index b01229a56..9e6cffecc 100644
--- a/console-tools/openvt.c
+++ b/console-tools/openvt.c
@@ -87,7 +87,7 @@ static int get_vt_fd(void)
 	fd = open(DEV_CONSOLE, O_RDONLY | O_NONBLOCK);
 	if (fd >= 0 && !not_vt_fd(fd))
 		return fd;
-	bb_error_msg_and_die("can't find open VT");
+	bb_simple_error_msg_and_die("can't find open VT");
 }
 
 static int find_free_vtno(void)
@@ -98,7 +98,7 @@ static int find_free_vtno(void)
 	errno = 0;
 	/*xfunc_error_retval = 3; - do we need compat? */
 	if (ioctl(fd, VT_OPENQRY, &vtno) != 0 || vtno <= 0)
-		bb_perror_msg_and_die("can't find open VT");
+		bb_simple_perror_msg_and_die("can't find open VT");
 // Not really needed, grep for DAEMON_CLOSE_EXTRA_FDS
 //	if (fd > 2)
 //		close(fd);
diff --git a/console-tools/showkey.c b/console-tools/showkey.c
index c322ce99d..8f0e9d938 100644
--- a/console-tools/showkey.c
+++ b/console-tools/showkey.c
@@ -56,7 +56,7 @@ static void xset1(struct termios *t)
 {
 	int ret = tcsetattr(STDIN_FILENO, TCSAFLUSH, t);
 	if (ret) {
-		bb_perror_msg("can't tcsetattr for stdin");
+		bb_simple_perror_msg("can't tcsetattr for stdin");
 	}
 }
 
diff --git a/coreutils/cp.c b/coreutils/cp.c
index 59e3d2f80..cfeb19fc4 100644
--- a/coreutils/cp.c
+++ b/coreutils/cp.c
@@ -217,7 +217,7 @@ int cp_main(int argc, char **argv)
 		//	flags, FILEUTILS_RMDEST, OPT_parents);
 		if (flags & OPT_parents) {
 			if (!(d_flags & 2)) {
-				bb_error_msg_and_die("with --parents, the destination must be a directory");
+				bb_simple_error_msg_and_die("with --parents, the destination must be a directory");
 			}
 		}
 		if (flags & FILEUTILS_RMDEST) {
@@ -236,7 +236,7 @@ int cp_main(int argc, char **argv)
 			goto DO_COPY; /* NB: argc==2 -> *++argv==last */
 		}
 	} else if (flags & FILEUTILS_NO_TARGET_DIR) {
-		bb_error_msg_and_die("too many arguments");
+		bb_simple_error_msg_and_die("too many arguments");
 	}
 
 	while (1) {
diff --git a/coreutils/cut.c b/coreutils/cut.c
index e952dc17b..1acbb513e 100644
--- a/coreutils/cut.c
+++ b/coreutils/cut.c
@@ -209,11 +209,11 @@ int cut_main(int argc UNUSED_PARAM, char **argv)
 //	argc -= optind;
 	argv += optind;
 	if (!(opt & (CUT_OPT_BYTE_FLGS | CUT_OPT_CHAR_FLGS | CUT_OPT_FIELDS_FLGS)))
-		bb_error_msg_and_die("expected a list of bytes, characters, or fields");
+		bb_simple_error_msg_and_die("expected a list of bytes, characters, or fields");
 
 	if (opt & CUT_OPT_DELIM_FLGS) {
 		if (ltok[0] && ltok[1]) { /* more than 1 char? */
-			bb_error_msg_and_die("the delimiter must be a single character");
+			bb_simple_error_msg_and_die("the delimiter must be a single character");
 		}
 		delim = ltok[0];
 	}
@@ -288,7 +288,7 @@ int cut_main(int argc UNUSED_PARAM, char **argv)
 
 		/* make sure we got some cut positions out of all that */
 		if (nlists == 0)
-			bb_error_msg_and_die("missing list of positions");
+			bb_simple_error_msg_and_die("missing list of positions");
 
 		/* now that the lists are parsed, we need to sort them to make life
 		 * easier on us when it comes time to print the chars / fields / lines
diff --git a/coreutils/date.c b/coreutils/date.c
index 3414d38ae..feb400430 100644
--- a/coreutils/date.c
+++ b/coreutils/date.c
@@ -304,7 +304,7 @@ int date_main(int argc UNUSED_PARAM, char **argv)
 
 		/* if setting time, set it */
 		if ((opt & OPT_SET) && stime(&ts.tv_sec) < 0) {
-			bb_perror_msg("can't set date");
+			bb_simple_perror_msg("can't set date");
 		}
 	}
 
diff --git a/coreutils/df.c b/coreutils/df.c
index f6d66e4b6..debb86867 100644
--- a/coreutils/df.c
+++ b/coreutils/df.c
@@ -178,7 +178,7 @@ int df_main(int argc UNUSED_PARAM, char **argv)
 	if (!argv[0]) {
 		mount_table = setmntent(bb_path_mtab_file, "r");
 		if (!mount_table)
-			bb_perror_msg_and_die(bb_path_mtab_file);
+			bb_simple_perror_msg_and_die(bb_path_mtab_file);
 	}
 
 	while (1) {
diff --git a/coreutils/echo.c b/coreutils/echo.c
index 5dc5be072..b3828894c 100644
--- a/coreutils/echo.c
+++ b/coreutils/echo.c
@@ -188,7 +188,7 @@ int echo_main(int argc UNUSED_PARAM, char **argv)
 	/*r =*/ full_write(STDOUT_FILENO, buffer, out - buffer);
 	free(buffer);
 	if (/*WRONG:r < 0*/ errno) {
-		bb_perror_msg(bb_msg_write_error);
+		bb_simple_perror_msg(bb_msg_write_error);
 		return 1;
 	}
 	return 0;
diff --git a/coreutils/env.c b/coreutils/env.c
index 878068f09..c37c0c2df 100644
--- a/coreutils/env.c
+++ b/coreutils/env.c
@@ -79,7 +79,7 @@ int env_main(int argc UNUSED_PARAM, char **argv)
 
 	while (*argv && (strchr(*argv, '=') != NULL)) {
 		if (putenv(*argv) < 0) {
-			bb_perror_msg_and_die("putenv");
+			bb_simple_perror_msg_and_die("putenv");
 		}
 		++argv;
 	}
diff --git a/coreutils/expand.c b/coreutils/expand.c
index 20e4c4b23..4fa974df8 100644
--- a/coreutils/expand.c
+++ b/coreutils/expand.c
@@ -247,7 +247,7 @@ int expand_main(int argc UNUSED_PARAM, char **argv)
 	/* Now close stdin also */
 	/* (if we didn't read from it, it's a no-op) */
 	if (fclose(stdin))
-		bb_perror_msg_and_die(bb_msg_standard_input);
+		bb_simple_perror_msg_and_die(bb_msg_standard_input);
 
 	fflush_stdout_and_exit(exit_status);
 }
diff --git a/coreutils/expr.c b/coreutils/expr.c
index 1bdfba004..b247f08db 100644
--- a/coreutils/expr.c
+++ b/coreutils/expr.c
@@ -249,7 +249,7 @@ static arith_t arithmetic_common(VALUE *l, VALUE *r, int op)
 	arith_t li, ri;
 
 	if (!toarith(l) || !toarith(r))
-		bb_error_msg_and_die("non-numeric argument");
+		bb_simple_error_msg_and_die("non-numeric argument");
 	li = l->u.i;
 	ri = r->u.i;
 	if (op == '+')
@@ -259,7 +259,7 @@ static arith_t arithmetic_common(VALUE *l, VALUE *r, int op)
 	if (op == '*')
 		return li * ri;
 	if (ri == 0)
-		bb_error_msg_and_die("division by zero");
+		bb_simple_error_msg_and_die("division by zero");
 	if (op == '/')
 		return li / ri;
 	return li % ri;
@@ -319,19 +319,19 @@ static VALUE *eval7(void)
 	VALUE *v;
 
 	if (!*G.args)
-		bb_error_msg_and_die("syntax error");
+		bb_simple_error_msg_and_die("syntax error");
 
 	if (nextarg("(")) {
 		G.args++;
 		v = eval();
 		if (!nextarg(")"))
-			bb_error_msg_and_die("syntax error");
+			bb_simple_error_msg_and_die("syntax error");
 		G.args++;
 		return v;
 	}
 
 	if (nextarg(")"))
-		bb_error_msg_and_die("syntax error");
+		bb_simple_error_msg_and_die("syntax error");
 
 	return str_value(*G.args++);
 }
@@ -353,7 +353,7 @@ static VALUE *eval6(void)
 	G.args++; /* We have a valid token, so get the next argument.  */
 	if (key == 1) { /* quote */
 		if (!*G.args)
-			bb_error_msg_and_die("syntax error");
+			bb_simple_error_msg_and_die("syntax error");
 		return str_value(*G.args++);
 	}
 	if (key == 2) { /* length */
@@ -546,11 +546,11 @@ int expr_main(int argc UNUSED_PARAM, char **argv)
 	xfunc_error_retval = 2; /* coreutils compat */
 	G.args = argv + 1;
 	if (*G.args == NULL) {
-		bb_error_msg_and_die("too few arguments");
+		bb_simple_error_msg_and_die("too few arguments");
 	}
 	v = eval();
 	if (*G.args)
-		bb_error_msg_and_die("syntax error");
+		bb_simple_error_msg_and_die("syntax error");
 	if (v->type == INTEGER)
 		printf("%" PF_REZ "d\n", PF_REZ_TYPE v->u.i);
 	else
diff --git a/coreutils/id.c b/coreutils/id.c
index 00c0cd8ab..f20cd7d09 100644
--- a/coreutils/id.c
+++ b/coreutils/id.c
@@ -231,7 +231,7 @@ int id_main(int argc UNUSED_PARAM, char **argv)
 			}
 		} else if (n < 0) { /* error in get_groups() */
 			if (ENABLE_DESKTOP)
-				bb_error_msg_and_die("can't get groups");
+				bb_simple_error_msg_and_die("can't get groups");
 			return EXIT_FAILURE;
 		}
 		if (ENABLE_FEATURE_CLEAN_UP)
diff --git a/coreutils/install.c b/coreutils/install.c
index 8270490bd..c0f1c538a 100644
--- a/coreutils/install.c
+++ b/coreutils/install.c
@@ -238,7 +238,7 @@ int install_main(int argc, char **argv)
 				args[2] = dest;
 				args[3] = NULL;
 				if (spawn_and_wait(args)) {
-					bb_perror_msg("strip");
+					bb_simple_perror_msg("strip");
 					ret = EXIT_FAILURE;
 				}
 			}
diff --git a/coreutils/ln.c b/coreutils/ln.c
index afeb0d72d..ea2d10eab 100644
--- a/coreutils/ln.c
+++ b/coreutils/ln.c
@@ -69,7 +69,7 @@ int ln_main(int argc, char **argv)
 	argc -= optind;
 
 	if ((opts & LN_LINKFILE) && argc > 2) {
-		bb_error_msg_and_die("-T accepts 2 args max");
+		bb_simple_error_msg_and_die("-T accepts 2 args max");
 	}
 
 	if (!argv[1]) {
diff --git a/coreutils/logname.c b/coreutils/logname.c
index 31ce61f0c..06bbe1b0e 100644
--- a/coreutils/logname.c
+++ b/coreutils/logname.c
@@ -56,5 +56,5 @@ int logname_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 		return fflush_all();
 	}
 
-	bb_perror_msg_and_die("getlogin");
+	bb_simple_perror_msg_and_die("getlogin");
 }
diff --git a/coreutils/md5_sha1_sum.c b/coreutils/md5_sha1_sum.c
index 538df251b..ba26c985a 100644
--- a/coreutils/md5_sha1_sum.c
+++ b/coreutils/md5_sha1_sum.c
@@ -300,7 +300,7 @@ int md5_sha1_sum_main(int argc UNUSED_PARAM, char **argv)
 				}
 				if (filename_ptr == NULL) {
 					if (flags & FLAG_WARN) {
-						bb_error_msg("invalid format");
+						bb_simple_error_msg("invalid format");
 					}
 					count_failed++;
 					return_value = EXIT_FAILURE;
diff --git a/coreutils/od_bloaty.c b/coreutils/od_bloaty.c
index 4cae0c529..e9c071f3a 100644
--- a/coreutils/od_bloaty.c
+++ b/coreutils/od_bloaty.c
@@ -536,7 +536,7 @@ check_and_close(void)
 	}
 
 	if (ferror(stdout)) {
-		bb_error_msg_and_die(bb_msg_write_error);
+		bb_simple_error_msg_and_die(bb_msg_write_error);
 	}
 }
 
@@ -841,7 +841,7 @@ skip(off_t n_skip)
 	}
 
 	if (n_skip)
-		bb_error_msg_and_die("can't skip past end of combined input");
+		bb_simple_error_msg_and_die("can't skip past end of combined input");
 }
 
 
@@ -1308,10 +1308,10 @@ int od_main(int argc UNUSED_PARAM, char **argv)
 					pseudo_start = o2;
 					argv[1] = NULL;
 				} else {
-					bb_error_msg_and_die("the last two arguments must be offsets");
+					bb_simple_error_msg_and_die("the last two arguments must be offsets");
 				}
 			} else { /* >3 args */
-				bb_error_msg_and_die("too many arguments");
+				bb_simple_error_msg_and_die("too many arguments");
 			}
 
 			if (pseudo_start >= 0) {
@@ -1332,7 +1332,7 @@ int od_main(int argc UNUSED_PARAM, char **argv)
 	if (option_mask32 & OPT_N) {
 		end_offset = n_bytes_to_skip + max_bytes_to_format;
 		if (end_offset < n_bytes_to_skip)
-			bb_error_msg_and_die("SKIP + SIZE is too large");
+			bb_simple_error_msg_and_die("SKIP + SIZE is too large");
 	}
 
 	if (G.n_specs == 0) {
@@ -1389,7 +1389,7 @@ int od_main(int argc UNUSED_PARAM, char **argv)
 		dump(n_bytes_to_skip, end_offset);
 
 	if (fclose(stdin))
-		bb_perror_msg_and_die(bb_msg_standard_input);
+		bb_simple_perror_msg_and_die(bb_msg_standard_input);
 
 	return G.exit_code;
 }
diff --git a/coreutils/paste.c b/coreutils/paste.c
index 3d81a5f1a..11743297a 100644
--- a/coreutils/paste.c
+++ b/coreutils/paste.c
@@ -116,7 +116,7 @@ int paste_main(int argc UNUSED_PARAM, char **argv)
 
 	if (opt & PASTE_OPT_DELIMITERS) {
 		if (!delims[0])
-			bb_error_msg_and_die("-d '' is not supported");
+			bb_simple_error_msg_and_die("-d '' is not supported");
 		/* unknown mappings are not changed: "\z" -> '\\' 'z' */
 		/* trailing backslash, if any, is preserved */
 		del_cnt = strcpy_and_process_escape_sequences(delims, delims) - delims;
diff --git a/coreutils/printf.c b/coreutils/printf.c
index 5cf518699..a20fc3301 100644
--- a/coreutils/printf.c
+++ b/coreutils/printf.c
@@ -430,7 +430,7 @@ int printf_main(int argc UNUSED_PARAM, char **argv)
 		if (ENABLE_ASH_PRINTF
 		 && applet_name[0] != 'p'
 		) {
-			bb_error_msg("usage: printf FORMAT [ARGUMENT...]");
+			bb_simple_error_msg("usage: printf FORMAT [ARGUMENT...]");
 			return 2; /* bash compat */
 		}
 		bb_show_usage();
diff --git a/coreutils/rm.c b/coreutils/rm.c
index fd94bb5c4..d000129d9 100644
--- a/coreutils/rm.c
+++ b/coreutils/rm.c
@@ -62,7 +62,7 @@ int rm_main(int argc UNUSED_PARAM, char **argv)
 			const char *base = bb_get_last_path_component_strip(*argv);
 
 			if (DOT_OR_DOTDOT(base)) {
-				bb_error_msg("can't remove '.' or '..'");
+				bb_simple_error_msg("can't remove '.' or '..'");
 			} else if (remove_file(*argv, flags) >= 0) {
 				continue;
 			}
diff --git a/coreutils/sort.c b/coreutils/sort.c
index f04c6067b..07c327645 100644
--- a/coreutils/sort.c
+++ b/coreutils/sort.c
@@ -277,7 +277,7 @@ static int compare_keys(const void *xarg, const void *yarg)
 		/* Perform actual comparison */
 		switch (flags & (FLAG_n | FLAG_g | FLAG_M | FLAG_V)) {
 		default:
-			bb_error_msg_and_die("unknown sort type");
+			bb_simple_error_msg_and_die("unknown sort type");
 			break;
 #if defined(HAVE_STRVERSCMP) && HAVE_STRVERSCMP == 1
 		case FLAG_V:
@@ -398,10 +398,10 @@ static unsigned str2u(char **str)
 {
 	unsigned long lu;
 	if (!isdigit((*str)[0]))
-		bb_error_msg_and_die("bad field specification");
+		bb_simple_error_msg_and_die("bad field specification");
 	lu = strtoul(*str, str, 10);
 	if ((sizeof(long) > sizeof(int) && lu > INT_MAX) || !lu)
-		bb_error_msg_and_die("bad field specification");
+		bb_simple_error_msg_and_die("bad field specification");
 	return lu;
 }
 #endif
@@ -461,7 +461,7 @@ int sort_main(int argc UNUSED_PARAM, char **argv)
 #if ENABLE_FEATURE_SORT_BIG
 	if (opts & FLAG_t) {
 		if (!str_t[0] || str_t[1])
-			bb_error_msg_and_die("bad -t parameter");
+			bb_simple_error_msg_and_die("bad -t parameter");
 		key_separator = str_t[0];
 	}
 	/* note: below this point we use option_mask32, not opts,
@@ -504,10 +504,10 @@ int sort_main(int argc UNUSED_PARAM, char **argv)
 					because comma isn't in OPT_STR */
 				idx = strchr(OPT_STR, *str_k);
 				if (!idx)
-					bb_error_msg_and_die("unknown key option");
+					bb_simple_error_msg_and_die("unknown key option");
 				flag = 1 << (idx - OPT_STR);
 				if (flag & ~FLAG_allowed_for_k)
-					bb_error_msg_and_die("unknown sort type");
+					bb_simple_error_msg_and_die("unknown sort type");
 				/* b after ',' means strip _trailing_ space */
 				if (i && flag == FLAG_b)
 					flag = FLAG_bb;
diff --git a/coreutils/split.c b/coreutils/split.c
index c1e4ceab2..ecbc9d2d8 100644
--- a/coreutils/split.c
+++ b/coreutils/split.c
@@ -127,7 +127,7 @@ int split_main(int argc UNUSED_PARAM, char **argv)
 	}
 
 	if (NAME_MAX < strlen(sfx) + suffix_len)
-		bb_error_msg_and_die("suffix too long");
+		bb_simple_error_msg_and_die("suffix too long");
 
 	{
 		char *char_p = xzalloc(suffix_len + 1);
@@ -147,7 +147,7 @@ int split_main(int argc UNUSED_PARAM, char **argv)
 		do {
 			if (!remaining) {
 				if (!pfx)
-					bb_error_msg_and_die("suffixes exhausted");
+					bb_simple_error_msg_and_die("suffixes exhausted");
 				xmove_fd(xopen(pfx, O_WRONLY | O_CREAT | O_TRUNC), 1);
 				pfx = next_file(pfx, suffix_len);
 				remaining = cnt;
diff --git a/coreutils/stty.c b/coreutils/stty.c
index d1309f9aa..40e812799 100644
--- a/coreutils/stty.c
+++ b/coreutils/stty.c
@@ -1320,7 +1320,7 @@ int stty_main(int argc UNUSED_PARAM, char **argv)
 					break;
 				case 'F':
 					if (file_name)
-						bb_error_msg_and_die("only one device may be specified");
+						bb_simple_error_msg_and_die("only one device may be specified");
 					file_name = &arg[i+1]; /* "-Fdevice" ? */
 					if (!file_name[0]) { /* nope, "-F device" */
 						int p = k+1; /* argv[p] is argnext */
@@ -1405,13 +1405,13 @@ int stty_main(int argc UNUSED_PARAM, char **argv)
 	if ((stty_state & (STTY_verbose_output | STTY_recoverable_output)) ==
 		(STTY_verbose_output | STTY_recoverable_output)
 	) {
-		bb_error_msg_and_die("-a and -g are mutually exclusive");
+		bb_simple_error_msg_and_die("-a and -g are mutually exclusive");
 	}
 	/* Specifying -a or -g with non-options is an error */
 	if ((stty_state & (STTY_verbose_output | STTY_recoverable_output))
 	 && !(stty_state & STTY_noargs)
 	) {
-		bb_error_msg_and_die("modes may not be set when -a or -g is used");
+		bb_simple_error_msg_and_die("modes may not be set when -a or -g is used");
 	}
 
 	/* Now it is safe to start doing things */
diff --git a/coreutils/tail.c b/coreutils/tail.c
index 14ed85d16..1f458f9ed 100644
--- a/coreutils/tail.c
+++ b/coreutils/tail.c
@@ -89,7 +89,7 @@ static ssize_t tail_read(int fd, char *buf, size_t count)
 
 	r = full_read(fd, buf, count);
 	if (r < 0) {
-		bb_perror_msg(bb_msg_read_error);
+		bb_simple_perror_msg(bb_msg_read_error);
 		G.exitcode = EXIT_FAILURE;
 	}
 
@@ -186,7 +186,7 @@ int tail_main(int argc, char **argv)
 	} while (++i < argc);
 
 	if (!nfiles)
-		bb_error_msg_and_die("no files");
+		bb_simple_error_msg_and_die("no files");
 
 	/* prepare the buffer */
 	tailbufsize = BUFSIZ;
diff --git a/coreutils/test.c b/coreutils/test.c
index 8d7dac025..868ffbecb 100644
--- a/coreutils/test.c
+++ b/coreutils/test.c
@@ -832,12 +832,12 @@ int test_main(int argc, char **argv)
 		--argc;
 		if (!arg0[1]) { /* "[" ? */
 			if (NOT_LONE_CHAR(argv[argc], ']')) {
-				bb_error_msg("missing ]");
+				bb_simple_error_msg("missing ]");
 				return 2;
 			}
 		} else { /* assuming "[[" */
 			if (strcmp(argv[argc], "]]") != 0) {
-				bb_error_msg("missing ]]");
+				bb_simple_error_msg("missing ]]");
 				return 2;
 			}
 		}
diff --git a/coreutils/tr.c b/coreutils/tr.c
index ae35a9ee3..1e402dfdb 100644
--- a/coreutils/tr.c
+++ b/coreutils/tr.c
@@ -308,7 +308,7 @@ int tr_main(int argc UNUSED_PARAM, char **argv)
 		str1_length = complement(str1, str1_length);
 	if (*argv) {
 		if (argv[0][0] == '\0')
-			bb_error_msg_and_die("STRING2 cannot be empty");
+			bb_simple_error_msg_and_die("STRING2 cannot be empty");
 		str2_length = expand(*argv, &str2);
 		map(vector, str1, str1_length,
 				str2, str2_length);
@@ -333,7 +333,7 @@ int tr_main(int argc UNUSED_PARAM, char **argv)
 			read_chars = safe_read(STDIN_FILENO, str1, TR_BUFSIZ);
 			if (read_chars <= 0) {
 				if (read_chars < 0)
-					bb_perror_msg_and_die(bb_msg_read_error);
+					bb_simple_perror_msg_and_die(bb_msg_read_error);
 				break;
 			}
 			in_index = 0;
diff --git a/coreutils/uudecode.c b/coreutils/uudecode.c
index 5f69e62b3..dc8ef5cca 100644
--- a/coreutils/uudecode.c
+++ b/coreutils/uudecode.c
@@ -82,7 +82,7 @@ static void FAST_FUNC read_stduu(FILE *src_stream, FILE *dst_stream, int flags U
 			continue;
 		}
 		if (encoded_len > 60) {
-			bb_error_msg_and_die("line too long");
+			bb_simple_error_msg_and_die("line too long");
 		}
 
 		dst = line;
@@ -108,7 +108,7 @@ static void FAST_FUNC read_stduu(FILE *src_stream, FILE *dst_stream, int flags U
 		fwrite(line, 1, dst - line, dst_stream);
 		free(line);
 	}
-	bb_error_msg_and_die("short file");
+	bb_simple_error_msg_and_die("short file");
 }
 #endif
 
@@ -166,7 +166,7 @@ int uudecode_main(int argc UNUSED_PARAM, char **argv)
 		/* fclose_if_not_stdin(src_stream); - redundant */
 		return EXIT_SUCCESS;
 	}
-	bb_error_msg_and_die("no 'begin' line");
+	bb_simple_error_msg_and_die("no 'begin' line");
 }
 #endif
 
@@ -216,7 +216,7 @@ int base64_main(int argc UNUSED_PARAM, char **argv)
 			if (!size)
 				break;
 			if ((ssize_t)size < 0)
-				bb_perror_msg_and_die(bb_msg_read_error);
+				bb_simple_perror_msg_and_die(bb_msg_read_error);
 			/* Encode the buffer we just read in */
 			bb_uuencode(dst_buf, src_buf, size, bb_uuenc_tbl_base64);
 			xwrite(STDOUT_FILENO, dst_buf, 4 * ((size + 2) / 3));
diff --git a/coreutils/uuencode.c b/coreutils/uuencode.c
index 2807ef82a..db49ec80a 100644
--- a/coreutils/uuencode.c
+++ b/coreutils/uuencode.c
@@ -66,7 +66,7 @@ int uuencode_main(int argc UNUSED_PARAM, char **argv)
 		if (!size)
 			break;
 		if ((ssize_t)size < 0)
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		/* Encode the buffer we just read in */
 		bb_uuencode(dst_buf, src_buf, size, tbl);
 		bb_putchar('\n');
diff --git a/debianutils/start_stop_daemon.c b/debianutils/start_stop_daemon.c
index 6fbf8b6de..68df44ae9 100644
--- a/debianutils/start_stop_daemon.c
+++ b/debianutils/start_stop_daemon.c
@@ -317,7 +317,7 @@ static void do_procinit(void)
 	}
 	closedir(procdir);
 	if (!pid)
-		bb_error_msg_and_die("nothing in /proc - not mounted?");
+		bb_simple_error_msg_and_die("nothing in /proc - not mounted?");
 }
 
 static int do_stop(void)
@@ -337,7 +337,7 @@ static int do_stop(void)
 	} else if (userspec) {
 		what = xasprintf("process(es) owned by '%s'", userspec);
 	} else {
-		bb_error_msg_and_die("internal error, please report");
+		bb_simple_error_msg_and_die("internal error, please report");
 	}
 
 	if (!G.found_procs) {
diff --git a/e2fsprogs/chattr.c b/e2fsprogs/chattr.c
index c93e209b5..c37469021 100644
--- a/e2fsprogs/chattr.c
+++ b/e2fsprogs/chattr.c
@@ -196,11 +196,11 @@ int chattr_main(int argc UNUSED_PARAM, char **argv)
 
 	/* run sanity checks on all the arguments given us */
 	if ((g.flags & OPT_SET) && (g.flags & (OPT_ADD|OPT_REM)))
-		bb_error_msg_and_die("= is incompatible with - and +");
+		bb_simple_error_msg_and_die("= is incompatible with - and +");
 	if (g.rf & g.af)
-		bb_error_msg_and_die("can't set and unset a flag");
+		bb_simple_error_msg_and_die("can't set and unset a flag");
 	if (!g.flags)
-		bb_error_msg_and_die("must use '-v', =, - or +");
+		bb_simple_error_msg_and_die("must use '-v', =, - or +");
 
 	/* now run chattr on all the files passed to us */
 	do change_attributes(*argv, &g); while (*++argv);
diff --git a/e2fsprogs/fsck.c b/e2fsprogs/fsck.c
index 8a14b3bdc..fc53a9043 100644
--- a/e2fsprogs/fsck.c
+++ b/e2fsprogs/fsck.c
@@ -431,10 +431,10 @@ static int wait_one(int flags)
 			if (errno == EINTR)
 				continue;
 			if (errno == ECHILD) { /* paranoia */
-				bb_error_msg("wait: no more children");
+				bb_simple_error_msg("wait: no more children");
 				return -1;
 			}
-			bb_perror_msg("wait");
+			bb_simple_perror_msg("wait");
 			continue;
 		}
 		prev = NULL;
@@ -919,7 +919,7 @@ static void compile_fs_type(char *fs_type)
 			if (G.fs_type_negated == -1)
 				G.fs_type_negated = negate;
 			if (G.fs_type_negated != negate)
-				bb_error_msg_and_die(
+				bb_simple_error_msg_and_die(
 "either all or none of the filesystem types passed to -t must be prefixed "
 "with 'no' or '!'");
 		}
diff --git a/editors/awk.c b/editors/awk.c
index d25508e5d..f19990901 100644
--- a/editors/awk.c
+++ b/editors/awk.c
@@ -2633,7 +2633,7 @@ static var *evaluate(node *op, var *res)
 					if (opn == '|') {
 						rsm->F = popen(R.s, "w");
 						if (rsm->F == NULL)
-							bb_perror_msg_and_die("popen");
+							bb_simple_perror_msg_and_die("popen");
 						rsm->is_pipe = 1;
 					} else {
 						rsm->F = xfopen(R.s, opn=='w' ? "w" : "a");
@@ -3246,7 +3246,7 @@ int awk_main(int argc UNUSED_PARAM, char **argv)
 	argv += optind;
 	//argc -= optind;
 	if (opt & OPT_W)
-		bb_error_msg("warning: option -W is ignored");
+		bb_simple_error_msg("warning: option -W is ignored");
 	if (opt & OPT_F) {
 		unescape_string_in_place(opt_F);
 		setvar_s(intvar[FS], opt_F);
diff --git a/editors/diff.c b/editors/diff.c
index 1462a9b18..dc40ab4f1 100644
--- a/editors/diff.c
+++ b/editors/diff.c
@@ -1006,7 +1006,7 @@ int diff_main(int argc UNUSED_PARAM, char **argv)
 	xfunc_error_retval = 1;
 
 	if (gotstdin && (S_ISDIR(stb[0].st_mode) || S_ISDIR(stb[1].st_mode)))
-		bb_error_msg_and_die("can't compare stdin to a directory");
+		bb_simple_error_msg_and_die("can't compare stdin to a directory");
 
 	/* Compare metadata to check if the files are the same physical file.
 	 *
@@ -1037,7 +1037,7 @@ int diff_main(int argc UNUSED_PARAM, char **argv)
 #if ENABLE_FEATURE_DIFF_DIR
 		diffdir(file, s_start);
 #else
-		bb_error_msg_and_die("no support for directory comparison");
+		bb_simple_error_msg_and_die("no support for directory comparison");
 #endif
 	} else {
 		bool dirfile = S_ISDIR(stb[0].st_mode) || S_ISDIR(stb[1].st_mode);
diff --git a/editors/ed.c b/editors/ed.c
index 1a36add39..d3ae8da92 100644
--- a/editors/ed.c
+++ b/editors/ed.c
@@ -165,7 +165,7 @@ static NOINLINE int searchLines(const char *str, int num1, int num2)
 
 	if (*str == '\0') {
 		if (searchString[0] == '\0') {
-			bb_error_msg("no previous search string");
+			bb_simple_error_msg("no previous search string");
 			return 0;
 		}
 		str = searchString;
@@ -228,7 +228,7 @@ static const char* getNum(const char *cp, smallint *retHaveNum, int *retNum)
 			case '\'':
 				cp++;
 				if ((unsigned)(*cp - 'a') >= 26) {
-					bb_error_msg("bad mark name");
+					bb_simple_error_msg("bad mark name");
 					return NULL;
 				}
 				haveNum = TRUE;
@@ -314,7 +314,7 @@ static int insertLine(int num, const char *data, int len)
 	LINE *newLp, *lp;
 
 	if ((num < 1) || (num > lastNum + 1)) {
-		bb_error_msg("inserting at bad line number");
+		bb_simple_error_msg("inserting at bad line number");
 		return FALSE;
 	}
 
@@ -384,7 +384,7 @@ static int readLines(const char *file, int num)
 	char *cp;
 
 	if ((num < 1) || (num > lastNum + 1)) {
-		bb_error_msg("bad line for read");
+		bb_simple_error_msg("bad line for read");
 		return FALSE;
 	}
 
@@ -629,7 +629,7 @@ static void subCommand(const char *cmd, int num1, int num2)
 	cp = buf;
 
 	if (isblank(*cp) || (*cp == '\0')) {
-		bb_error_msg("bad delimiter for substitute");
+		bb_simple_error_msg("bad delimiter for substitute");
 		return;
 	}
 
@@ -638,7 +638,7 @@ static void subCommand(const char *cmd, int num1, int num2)
 
 	cp = strchr(cp, delim);
 	if (cp == NULL) {
-		bb_error_msg("missing 2nd delimiter for substitute");
+		bb_simple_error_msg("missing 2nd delimiter for substitute");
 		return;
 	}
 
@@ -660,13 +660,13 @@ static void subCommand(const char *cmd, int num1, int num2)
 			printFlag = TRUE;
 			break;
 		default:
-			bb_error_msg("unknown option for substitute");
+			bb_simple_error_msg("unknown option for substitute");
 			return;
 	}
 
 	if (*oldStr == '\0') {
 		if (searchString[0] == '\0') {
-			bb_error_msg("no previous search string");
+			bb_simple_error_msg("no previous search string");
 			return;
 		}
 		oldStr = searchString;
@@ -846,7 +846,7 @@ static void doCommands(void)
 
 		case 'f':
 			if (*cp != '\0' && *cp != ' ') {
-				bb_error_msg("bad file command");
+				bb_simple_error_msg("bad file command");
 				break;
 			}
 			cp = skip_whitespace(cp);
@@ -870,7 +870,7 @@ static void doCommands(void)
 		case 'k':
 			cp = skip_whitespace(cp);
 			if ((unsigned)(*cp - 'a') >= 26 || cp[1]) {
-				bb_error_msg("bad mark name");
+				bb_simple_error_msg("bad mark name");
 				break;
 			}
 			marks[(unsigned)(*cp - 'a')] = num2;
@@ -887,7 +887,7 @@ static void doCommands(void)
 		case 'q':
 			cp = skip_whitespace(cp);
 			if (have1 || *cp) {
-				bb_error_msg("bad quit command");
+				bb_simple_error_msg("bad quit command");
 				break;
 			}
 			if (!dirty)
@@ -903,12 +903,12 @@ static void doCommands(void)
 
 		case 'r':
 			if (*cp != '\0' && *cp != ' ') {
-				bb_error_msg("bad read command");
+				bb_simple_error_msg("bad read command");
 				break;
 			}
 			cp = skip_whitespace(cp);
 			if (*cp == '\0') {
-				bb_error_msg("no file name");
+				bb_simple_error_msg("no file name");
 				break;
 			}
 			if (!have1)
@@ -925,14 +925,14 @@ static void doCommands(void)
 
 		case 'w':
 			if (*cp != '\0' && *cp != ' ') {
-				bb_error_msg("bad write command");
+				bb_simple_error_msg("bad write command");
 				break;
 			}
 			cp = skip_whitespace(cp);
 			if (*cp == '\0') {
 				cp = fileName;
 				if (!cp) {
-					bb_error_msg("no file name specified");
+					bb_simple_error_msg("no file name specified");
 					break;
 				}
 			}
@@ -960,7 +960,7 @@ static void doCommands(void)
 
 		case '.':
 			if (have1) {
-				bb_error_msg("no arguments allowed");
+				bb_simple_error_msg("no arguments allowed");
 				break;
 			}
 			printLines(curNum, curNum, FALSE);
@@ -984,7 +984,7 @@ static void doCommands(void)
 			break;
 
 		default:
-			bb_error_msg("unimplemented command");
+			bb_simple_error_msg("unimplemented command");
 			break;
 		}
 	}
diff --git a/editors/patch_bbox.c b/editors/patch_bbox.c
index 8e09ef488..d1f1ee2d6 100644
--- a/editors/patch_bbox.c
+++ b/editors/patch_bbox.c
@@ -30,7 +30,7 @@ static unsigned copy_lines(FILE *src_stream, FILE *dst_stream, unsigned lines_co
 			break;
 		}
 		if (fputs(line, dst_stream) == EOF) {
-			bb_perror_msg_and_die("error writing to new file");
+			bb_simple_perror_msg_and_die("error writing to new file");
 		}
 		free(line);
 		lines_count--;
@@ -148,7 +148,7 @@ int patch_main(int argc UNUSED_PARAM, char **argv)
 
 		new_filename = extract_filename(patch_line, patch_level, "+++ ");
 		if (!new_filename) {
-			bb_error_msg_and_die("invalid patch");
+			bb_simple_error_msg_and_die("invalid patch");
 		}
 
 		/* Get access rights from the file to be patched */
@@ -209,7 +209,7 @@ int patch_main(int argc UNUSED_PARAM, char **argv)
 				/* src_beg_line will be 0 if it's a new file */
 				count = src_beg_line - src_cur_line;
 				if (copy_lines(src_stream, dst_stream, count)) {
-					bb_error_msg_and_die("bad src file");
+					bb_simple_error_msg_and_die("bad src file");
 				}
 				src_cur_line += count;
 				dst_cur_line += count;
diff --git a/editors/patch_toybox.c b/editors/patch_toybox.c
index 3ffbf9084..aebab8132 100644
--- a/editors/patch_toybox.c
+++ b/editors/patch_toybox.c
@@ -200,7 +200,7 @@ int copy_tempfile(int fdin, char *name, char **tempname)
 
 	*tempname = xasprintf("%sXXXXXX", name);
 	fd = mkstemp(*tempname);
-	if(-1 == fd) bb_perror_msg_and_die("no temp file");
+	if(-1 == fd) bb_simple_perror_msg_and_die("no temp file");
 
 	// Set permissions of output file
 	fstat(fdin, &statbuf);
diff --git a/editors/sed.c b/editors/sed.c
index 57d3dda16..d3444003e 100644
--- a/editors/sed.c
+++ b/editors/sed.c
@@ -315,7 +315,7 @@ static int parse_regex_delim(const char *cmdstr, char **match, char **replace)
 	/* verify that the 's' or 'y' is followed by something.  That something
 	 * (typically a 'slash') is now our regexp delimiter... */
 	if (*cmdstr == '\0')
-		bb_error_msg_and_die("bad format in substitution expression");
+		bb_simple_error_msg_and_die("bad format in substitution expression");
 	delimiter = *cmdstr_ptr++;
 
 	/* save the match string */
@@ -360,7 +360,7 @@ static int get_address(const char *my_str, int *linenum, regex_t ** regex)
 		} else {
 			*regex = G.previous_regex_ptr;
 			if (!G.previous_regex_ptr)
-				bb_error_msg_and_die("no previous regexp");
+				bb_simple_error_msg_and_die("no previous regexp");
 		}
 		/* Move position to next character after last delimiter */
 		pos += (next+1);
@@ -378,7 +378,7 @@ static int parse_file_cmd(/*sed_cmd_t *sed_cmd,*/ const char *filecmdstr, char *
 	start = skip_whitespace(filecmdstr);
 	eol = strchrnul(start, '\n');
 	if (eol == start)
-		bb_error_msg_and_die("empty filename");
+		bb_simple_error_msg_and_die("empty filename");
 
 	if (*eol) {
 		/* If lines glued together, put backslash back. */
@@ -468,7 +468,7 @@ static int parse_subst_cmd(sed_cmd_t *sed_cmd, const char *substr)
 			goto out;
 		default:
 			dbg("s bad flags:'%s'", substr + idx);
-			bb_error_msg_and_die("bad option in substitution expression");
+			bb_simple_error_msg_and_die("bad option in substitution expression");
 		}
 	}
  out:
@@ -688,7 +688,7 @@ static void add_cmd(const char *cmdstr)
 				idx--; /* if 0, trigger error check below */
 			}
 			if (idx < 0)
-				bb_error_msg_and_die("no address after comma");
+				bb_simple_error_msg_and_die("no address after comma");
 			sed_cmd->end_line_orig = sed_cmd->end_line;
 		}
 
@@ -706,7 +706,7 @@ static void add_cmd(const char *cmdstr)
 
 		/* last part (mandatory) will be a command */
 		if (!*cmdstr)
-			bb_error_msg_and_die("missing command");
+			bb_simple_error_msg_and_die("missing command");
 		sed_cmd->cmd = *cmdstr++;
 		cmdstr = parse_cmd_args(sed_cmd, cmdstr);
 
@@ -791,7 +791,7 @@ static int do_subst_command(sed_cmd_t *sed_cmd, char **line_p)
 	if (!current_regex) {
 		current_regex = G.previous_regex_ptr;
 		if (!current_regex)
-			bb_error_msg_and_die("no previous regexp");
+			bb_simple_error_msg_and_die("no previous regexp");
 	}
 	G.previous_regex_ptr = current_regex;
 
@@ -962,7 +962,7 @@ static void puts_maybe_newline(char *s, FILE *file, char *last_puts_char, char l
 
 	if (ferror(file)) {
 		xfunc_error_retval = 4;  /* It's what gnu sed exits with... */
-		bb_error_msg_and_die(bb_msg_write_error);
+		bb_simple_error_msg_and_die(bb_msg_write_error);
 	}
 	*last_puts_char = lpc;
 }
@@ -1192,7 +1192,7 @@ static void process_files(void)
 					}
 					sed_cmd = sed_cmd->next;
 					if (!sed_cmd)
-						bb_error_msg_and_die("unterminated {");
+						bb_simple_error_msg_and_die("unterminated {");
 				}
 			}
 			continue;
diff --git a/editors/vi.c b/editors/vi.c
index 0ea547a75..f8fab7028 100644
--- a/editors/vi.c
+++ b/editors/vi.c
@@ -1042,7 +1042,7 @@ static int readit(void) // read (maybe cursor) key from stdin
 			goto again;
 		go_bottom_and_clear_to_eol();
 		cookmode(); // terminal to "cooked"
-		bb_error_msg_and_die("can't read user input");
+		bb_simple_error_msg_and_die("can't read user input");
 	}
 	return c;
 }
diff --git a/findutils/find.c b/findutils/find.c
index 06ad1b39c..d6679bd08 100644
--- a/findutils/find.c
+++ b/findutils/find.c
@@ -1245,7 +1245,7 @@ static action*** parse_params(char **argv)
 			 * coreutils expects {} to appear only once in "-exec +"
 			 */
 			if (all_subst != 1 && ap->filelist)
-				bb_error_msg_and_die("only one '{}' allowed for -exec +");
+				bb_simple_error_msg_and_die("only one '{}' allowed for -exec +");
 # endif
 		}
 #endif
@@ -1259,7 +1259,7 @@ static action*** parse_params(char **argv)
 			endarg = argv;
 			while (1) {
 				if (!*++endarg)
-					bb_error_msg_and_die("unpaired '('");
+					bb_simple_error_msg_and_die("unpaired '('");
 				if (LONE_CHAR(*endarg, '('))
 					nested++;
 				else if (LONE_CHAR(*endarg, ')') && !--nested) {
diff --git a/findutils/xargs.c b/findutils/xargs.c
index 03eafd616..726315803 100644
--- a/findutils/xargs.c
+++ b/findutils/xargs.c
@@ -665,7 +665,7 @@ int xargs_main(int argc UNUSED_PARAM, char **argv)
 	}
 	/* Sanity check */
 	if (n_max_chars <= 0) {
-		bb_error_msg_and_die("can't fit single argument within argument list size limit");
+		bb_simple_error_msg_and_die("can't fit single argument within argument list size limit");
 	}
 
 	buf = xzalloc(n_max_chars + 1);
@@ -716,7 +716,7 @@ int xargs_main(int argc UNUSED_PARAM, char **argv)
 
 		if (!G.args[initial_idx]) { /* not even one ARG was added? */
 			if (*rem != '\0')
-				bb_error_msg_and_die("argument line too long");
+				bb_simple_error_msg_and_die("argument line too long");
 			if (opt & OPT_NO_EMPTY)
 				break;
 		}
diff --git a/include/libbb.h b/include/libbb.h
index 021100db1..111d1b790 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -1137,7 +1137,7 @@ void exec_prog_or_SHELL(char **argv) NORETURN FAST_FUNC;
 ({ \
 	pid_t bb__xvfork_pid = vfork(); \
 	if (bb__xvfork_pid < 0) \
-		bb_perror_msg_and_die("vfork"); \
+		bb_simple_perror_msg_and_die("vfork"); \
 	bb__xvfork_pid; \
 })
 #if BB_MMU
@@ -1324,13 +1324,17 @@ extern void (*die_func)(void);
 void xfunc_die(void) NORETURN FAST_FUNC;
 void bb_show_usage(void) NORETURN FAST_FUNC;
 void bb_error_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_error_msg(const char *s) FAST_FUNC;
 void bb_error_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_error_msg_and_die(const char *s) NORETURN FAST_FUNC;
 void bb_perror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
 void bb_simple_perror_msg(const char *s) FAST_FUNC;
 void bb_perror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
 void bb_simple_perror_msg_and_die(const char *s) NORETURN FAST_FUNC;
 void bb_herror_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_herror_msg(const char *s) FAST_FUNC;
 void bb_herror_msg_and_die(const char *s, ...) __attribute__ ((noreturn, format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_herror_msg_and_die(const char *s) NORETURN FAST_FUNC;
 void bb_perror_nomsg_and_die(void) NORETURN FAST_FUNC;
 void bb_perror_nomsg(void) FAST_FUNC;
 void bb_verror_msg(const char *s, va_list p, const char *strerr) FAST_FUNC;
@@ -1339,12 +1343,51 @@ void bb_logenv_override(void) FAST_FUNC;
 
 #if ENABLE_FEATURE_SYSLOG_INFO
 void bb_info_msg(const char *s, ...) __attribute__ ((format (printf, 1, 2))) FAST_FUNC;
+void bb_simple_info_msg(const char *s) FAST_FUNC;
 void bb_vinfo_msg(const char *s, va_list p) FAST_FUNC;
 #else
 #define bb_info_msg bb_error_msg
+#define bb_simple_info_msg bb_simple_error_msg
 #define bb_vinfo_msg(s,p) bb_verror_msg(s,p,NULL)
 #endif
 
+#if ENABLE_WARN_SIMPLE_MSG
+/* If enabled, cause calls to bb_error_msg() et al that only take a single
+ * parameter to generate a warning.
+ */
+static inline void __attribute__ ((deprecated("use bb_simple_error_msg instead")))
+	bb_not_simple_error_msg(const char *s) { bb_simple_error_msg(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_error_msg_and_die instead"))) NORETURN
+	bb_not_simple_error_msg_and_die(const char *s) { bb_simple_error_msg_and_die(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_perror_msg instead")))
+	bb_not_simple_perror_msg(const char *s) { bb_simple_perror_msg(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_perror_msg_and_die instead"))) NORETURN
+	bb_not_simple_perror_msg_and_die(const char *s) { bb_simple_perror_msg_and_die(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_herror_msg instead")))
+	bb_not_simple_herror_msg(const char *s) { bb_simple_herror_msg(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_herror_msg_and_die instead"))) NORETURN
+	bb_not_simple_herror_msg_and_die(const char *s) { bb_simple_herror_msg_and_die(s); }
+static inline void __attribute__ ((deprecated("use bb_simple_info_msg instead")))
+	bb_not_simple_info_msg(const char *s) { bb_simple_info_msg(s); }
+/* Override bb_error_msg() and related functions with macros that will
+ * substitute them for the equivalent bb_not_simple_error_msg() function when
+ * they are used with only a single parameter. Macro approach inspired by
+ * https://gustedt.wordpress.com/2010/06/08/detect-empty-macro-arguments and
+ * https://gustedt.wordpress.com/2010/06/03/default-arguments-for-c99
+ */
+#define _ARG18(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, ...) _17
+#define BB_MSG_KIND(...)           _ARG18(__VA_ARGS__, , , , , , , , , , , , , , , , , _not_simple)
+#define _BB_MSG(name, kind, ...)   bb##kind##name(__VA_ARGS__)
+#define BB_MSG(name, kind, ...)    _BB_MSG(name, kind, __VA_ARGS__)
+#define bb_error_msg(...)          BB_MSG(_error_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_error_msg_and_die(...)  BB_MSG(_error_msg_and_die, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_perror_msg(...)         BB_MSG(_perror_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_perror_msg_and_die(...) BB_MSG(_perror_msg_and_die, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_herror_msg(...)         BB_MSG(_herror_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_herror_msg_and_die(...) BB_MSG(_herror_msg_and_die, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#define bb_info_msg(...)           BB_MSG(_info_msg, BB_MSG_KIND(__VA_ARGS__), __VA_ARGS__)
+#endif
+
 /* We need to export XXX_main from libbusybox
  * only if we build "individual" binaries
  */
diff --git a/init/bootchartd.c b/init/bootchartd.c
index 4377d90e3..750f67356 100644
--- a/init/bootchartd.c
+++ b/init/bootchartd.c
@@ -208,7 +208,7 @@ static char *make_tempdir(void)
 			bb_perror_msg_and_die("can't %smount tmpfs", "un");
 		}
 #else
-		bb_perror_msg_and_die("can't create temporary directory");
+		bb_simple_perror_msg_and_die("can't create temporary directory");
 #endif
 	} else {
 		xchdir(tempdir);
diff --git a/init/init.c b/init/init.c
index 87086b48b..0f3c5fa4d 100644
--- a/init/init.c
+++ b/init/init.c
@@ -1086,7 +1086,7 @@ int init_main(int argc UNUSED_PARAM, char **argv)
 		if (getpid() != 1
 		 && (!ENABLE_LINUXRC || applet_name[0] != 'l') /* not linuxrc? */
 		) {
-			bb_error_msg_and_die("must be run as PID 1");
+			bb_simple_error_msg_and_die("must be run as PID 1");
 		}
 #ifdef RB_DISABLE_CAD
 		/* Turn off rebooting via CTL-ALT-DEL - we get a
diff --git a/libbb/appletlib.c b/libbb/appletlib.c
index fa19e8488..9fa17cfa1 100644
--- a/libbb/appletlib.c
+++ b/libbb/appletlib.c
@@ -631,7 +631,7 @@ static void check_suid(int applet_no)
 			/* same group / in group */
 			m >>= 3;
 		if (!(m & S_IXOTH)) /* is x bit not set? */
-			bb_error_msg_and_die("you have no permission to run this applet");
+			bb_simple_error_msg_and_die("you have no permission to run this applet");
 
 		/* We set effective AND saved ids. If saved-id is not set
 		 * like we do below, seteuid(0) can still later succeed! */
@@ -643,7 +643,7 @@ static void check_suid(int applet_no)
 			rgid = sct->m_ugid.gid;
 		/* else: we will set egid = rgid, thus dropping sgid effect */
 		if (setresgid(-1, rgid, rgid))
-			bb_perror_msg_and_die("setresgid");
+			bb_simple_perror_msg_and_die("setresgid");
 
 		/* Are we directed to change uid
 		 * (APPLET = s** USER.GROUP or APPLET = S** USER.GROUP)?
@@ -653,7 +653,7 @@ static void check_suid(int applet_no)
 			uid = sct->m_ugid.uid;
 		/* else: we will set euid = ruid, thus dropping suid effect */
 		if (setresuid(-1, uid, uid))
-			bb_perror_msg_and_die("setresuid");
+			bb_simple_perror_msg_and_die("setresuid");
 
 		goto ret;
 	}
@@ -663,7 +663,7 @@ static void check_suid(int applet_no)
 
 		if (!onetime) {
 			onetime = 1;
-			bb_error_msg("using fallback suid method");
+			bb_simple_error_msg("using fallback suid method");
 		}
 	}
 #   endif
@@ -673,7 +673,7 @@ static void check_suid(int applet_no)
 		/* Real uid is not 0. If euid isn't 0 too, suid bit
 		 * is most probably not set on our executable */
 		if (geteuid())
-			bb_error_msg_and_die("must be suid to work properly");
+			bb_simple_error_msg_and_die("must be suid to work properly");
 	} else if (APPLET_SUID(applet_no) == BB_SUID_DROP) {
 		/*
 		 * Drop all privileges.
diff --git a/libbb/bb_getgroups.c b/libbb/bb_getgroups.c
index 59ae53738..5d83c729a 100644
--- a/libbb/bb_getgroups.c
+++ b/libbb/bb_getgroups.c
@@ -38,7 +38,7 @@ gid_t* FAST_FUNC bb_getgroups(int *ngroups, gid_t *group_array)
 			continue;
 		}
 		/* Some other error (should never happen on Linux) */
-		bb_perror_msg_and_die("getgroups");
+		bb_simple_perror_msg_and_die("getgroups");
 	}
 
 	if (ngroups)
diff --git a/libbb/bbunit.c b/libbb/bbunit.c
index 5f8d980a3..ccd909d78 100644
--- a/libbb/bbunit.c
+++ b/libbb/bbunit.c
@@ -60,6 +60,6 @@ int unit_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 		return EXIT_FAILURE;
 	}
 
-	bb_error_msg("All tests passed");
+	bb_simple_error_msg("All tests passed");
 	return EXIT_SUCCESS;
 }
diff --git a/libbb/capability.c b/libbb/capability.c
index d0ae78b91..23afd8eb9 100644
--- a/libbb/capability.c
+++ b/libbb/capability.c
@@ -119,7 +119,7 @@ void FAST_FUNC getcaps(void *arg)
 			caps->u32s = _LINUX_CAPABILITY_U32S_3;
 			break;
 		default:
-			bb_error_msg_and_die("unsupported capability version");
+			bb_simple_error_msg_and_die("unsupported capability version");
 	}
 
 	if (capget(&caps->header, caps->data) != 0)
diff --git a/libbb/change_identity.c b/libbb/change_identity.c
index 20d7c5f2d..9ff741234 100644
--- a/libbb/change_identity.c
+++ b/libbb/change_identity.c
@@ -51,7 +51,7 @@ void FAST_FUNC change_identity(const struct passwd *pw)
 			return;
 		}
 
-		bb_perror_msg_and_die("can't set groups");
+		bb_simple_perror_msg_and_die("can't set groups");
 	}
 
 	xsetgid(pw->pw_gid);
diff --git a/libbb/copy_file.c b/libbb/copy_file.c
index 2d6557cd4..49d1ec9c6 100644
--- a/libbb/copy_file.c
+++ b/libbb/copy_file.c
@@ -327,7 +327,7 @@ int FAST_FUNC copy_file(const char *source, const char *dest, int flags)
 		) {
 			security_context_t con;
 			if (getfscreatecon(&con) == -1) {
-				bb_perror_msg("getfscreatecon");
+				bb_simple_perror_msg("getfscreatecon");
 				return -1;
 			}
 			if (con) {
diff --git a/libbb/copyfd.c b/libbb/copyfd.c
index dd0517cd6..ae5c26999 100644
--- a/libbb/copyfd.c
+++ b/libbb/copyfd.c
@@ -87,7 +87,7 @@ static off_t bb_full_fd_action(int src_fd, int dst_fd, off_t size)
 		rd = safe_read(src_fd, buffer,
 			size > buffer_size ? buffer_size : size);
 		if (rd < 0) {
-			bb_perror_msg(bb_msg_read_error);
+			bb_simple_perror_msg(bb_msg_read_error);
 			break;
 		}
  read_ok:
@@ -100,7 +100,7 @@ static off_t bb_full_fd_action(int src_fd, int dst_fd, off_t size)
 			ssize_t wr = full_write(dst_fd, buffer, rd);
 			if (wr < rd) {
 				if (!continue_on_write_error) {
-					bb_perror_msg(bb_msg_write_error);
+					bb_simple_perror_msg(bb_msg_write_error);
 					break;
 				}
 				dst_fd = -1;
@@ -151,7 +151,7 @@ void FAST_FUNC bb_copyfd_exact_size(int fd1, int fd2, off_t size)
 	if (sz == (size >= 0 ? size : -size))
 		return;
 	if (sz != -1)
-		bb_error_msg_and_die("short read");
+		bb_simple_error_msg_and_die("short read");
 	/* if sz == -1, bb_copyfd_XX already complained */
 	xfunc_die();
 }
diff --git a/libbb/die_if_bad_username.c b/libbb/die_if_bad_username.c
index 46f103340..e5e1160c4 100644
--- a/libbb/die_if_bad_username.c
+++ b/libbb/die_if_bad_username.c
@@ -57,5 +57,5 @@ void FAST_FUNC die_if_bad_username(const char *name)
 	 * including the terminating null byte.
 	 */
 	if (name - start >= LOGIN_NAME_MAX)
-		bb_error_msg_and_die("name is too long");
+		bb_simple_error_msg_and_die("name is too long");
 }
diff --git a/libbb/dump.c b/libbb/dump.c
index b4b49d709..8029cca0e 100644
--- a/libbb/dump.c
+++ b/libbb/dump.c
@@ -199,7 +199,7 @@ static NOINLINE void rewrite(priv_dumper_t *dumper, FS *fs)
 				pr->bcnt = fu->bcnt;
 				if (fu->bcnt == 0) {
 					if (!prec)
-						bb_error_msg_and_die("%%s needs precision or byte count");
+						bb_simple_error_msg_and_die("%%s needs precision or byte count");
 					pr->bcnt = atoi(prec);
 				}
 			} else
@@ -266,7 +266,7 @@ static NOINLINE void rewrite(priv_dumper_t *dumper, FS *fs)
 
 			/* only one conversion character if byte count */
 			if (!(pr->flags & F_ADDRESS) && fu->bcnt && nconv++) {
-				bb_error_msg_and_die("byte count with multiple conversion characters");
+				bb_simple_error_msg_and_die("byte count with multiple conversion characters");
 			}
 		}
 		/*
diff --git a/libbb/fflush_stdout_and_exit.c b/libbb/fflush_stdout_and_exit.c
index 4c689c0fb..5df74170e 100644
--- a/libbb/fflush_stdout_and_exit.c
+++ b/libbb/fflush_stdout_and_exit.c
@@ -15,7 +15,7 @@ void FAST_FUNC fflush_stdout_and_exit(int retval)
 {
 	xfunc_error_retval = retval;
 	if (fflush(stdout))
-		bb_perror_msg_and_die(bb_msg_standard_output);
+		bb_simple_perror_msg_and_die(bb_msg_standard_output);
 	/* In case we are in NOFORK applet. Do not exit() directly,
 	 * but use xfunc_die() */
 	xfunc_die();
diff --git a/libbb/get_console.c b/libbb/get_console.c
index 0b53524aa..7f2c75332 100644
--- a/libbb/get_console.c
+++ b/libbb/get_console.c
@@ -62,7 +62,7 @@ int FAST_FUNC get_console_fd_or_die(void)
 		}
 	}
 
-	bb_error_msg_and_die("can't open console");
+	bb_simple_error_msg_and_die("can't open console");
 }
 
 /* From <linux/vt.h> */
diff --git a/libbb/get_volsize.c b/libbb/get_volsize.c
index 241ceda9b..087efb3c7 100644
--- a/libbb/get_volsize.c
+++ b/libbb/get_volsize.c
@@ -18,7 +18,7 @@ uoff_t FAST_FUNC get_volume_size_in_bytes(int fd,
 	if (override) {
 		result = XATOOFF(override);
 		if (result >= (uoff_t)(MAXINT(off_t)) / override_units)
-			bb_error_msg_and_die("image size is too big");
+			bb_simple_error_msg_and_die("image size is too big");
 		result *= override_units;
 		/* seek past end fails on block devices but works on files */
 		if (lseek(fd, result - 1, SEEK_SET) != (off_t)-1) {
@@ -42,7 +42,7 @@ uoff_t FAST_FUNC get_volume_size_in_bytes(int fd,
 	 *
 	 * Picked 16k arbitrarily: */
 	if (result < 16*1024)
-		bb_error_msg_and_die("image is too small");
+		bb_simple_error_msg_and_die("image is too small");
 
 	return result;
 }
diff --git a/libbb/getpty.c b/libbb/getpty.c
index 5d24ca930..9ec6265ad 100644
--- a/libbb/getpty.c
+++ b/libbb/getpty.c
@@ -23,14 +23,14 @@ int FAST_FUNC xgetpty(char *line)
 			const char *name;
 			name = ptsname(p); /* find out the name of slave pty */
 			if (!name) {
-				bb_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
+				bb_simple_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
 			}
 			safe_strncpy(line, name, GETPTY_BUFSIZE);
 		}
 # else
 		/* find out the name of slave pty */
 		if (ptsname_r(p, line, GETPTY_BUFSIZE-1) != 0) {
-			bb_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
+			bb_simple_perror_msg_and_die("ptsname error (is /dev/pts mounted?)");
 		}
 		line[GETPTY_BUFSIZE-1] = '\0';
 # endif
@@ -61,5 +61,5 @@ int FAST_FUNC xgetpty(char *line)
 		}
 	}
 #endif /* FEATURE_DEVPTS */
-	bb_error_msg_and_die("can't find free pty");
+	bb_simple_error_msg_and_die("can't find free pty");
 }
diff --git a/libbb/herror_msg.c b/libbb/herror_msg.c
index d041076e0..a7dd98679 100644
--- a/libbb/herror_msg.c
+++ b/libbb/herror_msg.c
@@ -26,3 +26,13 @@ void FAST_FUNC bb_herror_msg_and_die(const char *s, ...)
 	va_end(p);
 	xfunc_die();
 }
+
+void FAST_FUNC bb_simple_herror_msg(const char *s)
+{
+	bb_herror_msg("%s", s);
+}
+
+void FAST_FUNC bb_simple_herror_msg_and_die(const char *s)
+{
+	bb_herror_msg_and_die("%s", s);
+}
diff --git a/libbb/mtab.c b/libbb/mtab.c
index 131705ddb..aa1a2a103 100644
--- a/libbb/mtab.c
+++ b/libbb/mtab.c
@@ -21,7 +21,7 @@ void FAST_FUNC erase_mtab(const char *name)
 	/* Bummer. Fall back on trying the /proc filesystem */
 	if (!mountTable) mountTable = setmntent("/proc/mounts", "r");
 	if (!mountTable) {
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 		return;
 	}
 
@@ -49,6 +49,6 @@ void FAST_FUNC erase_mtab(const char *name)
 		}
 		endmntent(mountTable);
 	} else if (errno != EROFS)
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 }
 #endif
diff --git a/libbb/perror_nomsg.c b/libbb/perror_nomsg.c
index a2a11cc8e..d7d53de44 100644
--- a/libbb/perror_nomsg.c
+++ b/libbb/perror_nomsg.c
@@ -12,11 +12,11 @@
  * instead of including libbb.h */
 //#include "libbb.h"
 #include "platform.h"
-extern void bb_perror_msg(const char *s, ...) FAST_FUNC;
+extern void bb_simple_perror_msg(const char *s) FAST_FUNC;
 
 /* suppress gcc "no previous prototype" warning */
 void FAST_FUNC bb_perror_nomsg(void);
 void FAST_FUNC bb_perror_nomsg(void)
 {
-	bb_perror_msg(0);
+	bb_simple_perror_msg(0);
 }
diff --git a/libbb/perror_nomsg_and_die.c b/libbb/perror_nomsg_and_die.c
index 543ff5178..bea5f25a5 100644
--- a/libbb/perror_nomsg_and_die.c
+++ b/libbb/perror_nomsg_and_die.c
@@ -12,11 +12,11 @@
  * instead of including libbb.h */
 //#include "libbb.h"
 #include "platform.h"
-extern void bb_perror_msg_and_die(const char *s, ...) FAST_FUNC;
+extern void bb_simple_perror_msg_and_die(const char *s) FAST_FUNC;
 
 /* suppress gcc "no previous prototype" warning */
 void FAST_FUNC bb_perror_nomsg_and_die(void);
 void FAST_FUNC bb_perror_nomsg_and_die(void)
 {
-	bb_perror_msg_and_die(0);
+	bb_simple_perror_msg_and_die(0);
 }
diff --git a/libbb/read_printf.c b/libbb/read_printf.c
index cb582c080..0cd04ab7b 100644
--- a/libbb/read_printf.c
+++ b/libbb/read_printf.c
@@ -217,7 +217,7 @@ void FAST_FUNC xread(int fd, void *buf, size_t count)
 	if (count) {
 		ssize_t size = full_read(fd, buf, count);
 		if ((size_t)size != count)
-			bb_error_msg_and_die("short read");
+			bb_simple_error_msg_and_die("short read");
 	}
 }
 
diff --git a/libbb/safe_poll.c b/libbb/safe_poll.c
index cf93a9774..a07e785f3 100644
--- a/libbb/safe_poll.c
+++ b/libbb/safe_poll.c
@@ -27,7 +27,7 @@ int FAST_FUNC safe_poll(struct pollfd *ufds, nfds_t nfds, int timeout)
 		/* I doubt many callers would handle this correctly! */
 		if (errno == ENOMEM)
 			continue;
-		bb_perror_msg("poll");
+		bb_simple_perror_msg("poll");
 		return n;
 	}
 }
diff --git a/libbb/selinux_common.c b/libbb/selinux_common.c
index c2585557f..f917a1c6a 100644
--- a/libbb/selinux_common.c
+++ b/libbb/selinux_common.c
@@ -48,7 +48,7 @@ void FAST_FUNC selinux_preserve_fcontext(int fdesc)
 	if (fgetfilecon(fdesc, &context) < 0) {
 		if (errno == ENODATA || errno == ENOTSUP)
 			return;
-		bb_perror_msg_and_die("fgetfilecon failed");
+		bb_simple_perror_msg_and_die("fgetfilecon failed");
 	}
 	setfscreatecon_or_die(context);
 	freecon(context);
diff --git a/libbb/time.c b/libbb/time.c
index f9b8da0b3..cab0ad602 100644
--- a/libbb/time.c
+++ b/libbb/time.c
@@ -258,7 +258,7 @@ char* FAST_FUNC strftime_YYYYMMDDHHMMSS(char *buf, unsigned len, time_t *tp)
 static void get_mono(struct timespec *ts)
 {
 	if (syscall(__NR_clock_gettime, CLOCK_MONOTONIC, ts))
-		bb_error_msg_and_die("clock_gettime(MONOTONIC) failed");
+		bb_simple_error_msg_and_die("clock_gettime(MONOTONIC) failed");
 }
 unsigned long long FAST_FUNC monotonic_ns(void)
 {
diff --git a/libbb/update_passwd.c b/libbb/update_passwd.c
index dc967683a..c605c4c64 100644
--- a/libbb/update_passwd.c
+++ b/libbb/update_passwd.c
@@ -25,7 +25,7 @@ static void check_selinux_update_passwd(const char *username)
 		return;  /* No need to check */
 
 	if (getprevcon_raw(&context) < 0)
-		bb_perror_msg_and_die("getprevcon failed");
+		bb_simple_perror_msg_and_die("getprevcon failed");
 	seuser = strtok(context, ":");
 	if (!seuser)
 		bb_error_msg_and_die("invalid context '%s'", context);
@@ -42,7 +42,7 @@ static void check_selinux_update_passwd(const char *username)
 
 		if (selinux_check_passwd_access(av) != 0)
  die:
-			bb_error_msg_and_die("SELinux: access denied");
+			bb_simple_error_msg_and_die("SELinux: access denied");
 	}
 	if (ENABLE_FEATURE_CLEAN_UP)
 		freecon(context);
diff --git a/libbb/uuencode.c b/libbb/uuencode.c
index f32a3da7d..d36b34f63 100644
--- a/libbb/uuencode.c
+++ b/libbb/uuencode.c
@@ -213,7 +213,7 @@ void FAST_FUNC read_base64(FILE *src_stream, FILE *dst_stream, int flags)
 			if (*in_tail == '\0')
 				return;
 			/* No */
-			bb_error_msg_and_die("truncated base64 input");
+			bb_simple_error_msg_and_die("truncated base64 input");
 		}
 
 		/* It was partial decode */
diff --git a/libbb/verror_msg.c b/libbb/verror_msg.c
index 6d3459905..71512aee2 100644
--- a/libbb/verror_msg.c
+++ b/libbb/verror_msg.c
@@ -197,4 +197,19 @@ void FAST_FUNC bb_info_msg(const char *s, ...)
 	bb_vinfo_msg(s, p);
 	va_end(p);
 }
+
+void FAST_FUNC bb_simple_info_msg(const char *s)
+{
+	bb_info_msg("%s", s);
+}
 #endif
+
+void FAST_FUNC bb_simple_error_msg(const char *s)
+{
+	bb_error_msg("%s", s);
+}
+
+void FAST_FUNC bb_simple_error_msg_and_die(const char *s)
+{
+	bb_error_msg_and_die("%s", s);
+}
diff --git a/libbb/warn_ignoring_args.c b/libbb/warn_ignoring_args.c
index 3f3025c03..b24546e41 100644
--- a/libbb/warn_ignoring_args.c
+++ b/libbb/warn_ignoring_args.c
@@ -12,7 +12,7 @@
 void FAST_FUNC bb_warn_ignoring_args(char *arg)
 {
 	if (arg) {
-		bb_error_msg("ignoring all arguments");
+		bb_simple_error_msg("ignoring all arguments");
 	}
 }
 #endif
diff --git a/libbb/xconnect.c b/libbb/xconnect.c
index eb2871cb1..e9a2470e4 100644
--- a/libbb/xconnect.c
+++ b/libbb/xconnect.c
@@ -66,7 +66,7 @@ int FAST_FUNC setsockopt_bindtodevice(int fd, const char *iface)
 int FAST_FUNC setsockopt_bindtodevice(int fd UNUSED_PARAM,
 		const char *iface UNUSED_PARAM)
 {
-	bb_error_msg("SO_BINDTODEVICE is not supported on this system");
+	bb_simple_error_msg("SO_BINDTODEVICE is not supported on this system");
 	return -1;
 }
 #endif
@@ -109,7 +109,7 @@ void FAST_FUNC xconnect(int s, const struct sockaddr *s_addr, socklen_t addrlen)
 			bb_perror_msg_and_die("%s (%s)",
 				"can't connect to remote host",
 				inet_ntoa(((struct sockaddr_in *)s_addr)->sin_addr));
-		bb_perror_msg_and_die("can't connect to remote host");
+		bb_simple_perror_msg_and_die("can't connect to remote host");
 	}
 }
 
diff --git a/libbb/xfuncs.c b/libbb/xfuncs.c
index b4d512bd6..ee2dbdef1 100644
--- a/libbb/xfuncs.c
+++ b/libbb/xfuncs.c
@@ -426,6 +426,6 @@ int FAST_FUNC wait_for_exitstatus(pid_t pid)
 
 	n = safe_waitpid(pid, &exit_status, 0);
 	if (n < 0)
-		bb_perror_msg_and_die("waitpid");
+		bb_simple_perror_msg_and_die("waitpid");
 	return exit_status;
 }
diff --git a/libbb/xfuncs_printf.c b/libbb/xfuncs_printf.c
index 6cc60f6c0..93f325c62 100644
--- a/libbb/xfuncs_printf.c
+++ b/libbb/xfuncs_printf.c
@@ -27,7 +27,7 @@
 
 void FAST_FUNC bb_die_memory_exhausted(void)
 {
-	bb_error_msg_and_die(bb_msg_memory_exhausted);
+	bb_simple_error_msg_and_die(bb_msg_memory_exhausted);
 }
 
 #ifndef DMALLOC
@@ -40,7 +40,7 @@ void* FAST_FUNC malloc_or_warn(size_t size)
 {
 	void *ptr = malloc(size);
 	if (ptr == NULL && size != 0)
-		bb_error_msg(bb_msg_memory_exhausted);
+		bb_simple_error_msg(bb_msg_memory_exhausted);
 	return ptr;
 }
 
@@ -97,7 +97,7 @@ char* FAST_FUNC xstrndup(const char *s, int n)
 	char *t;
 
 	if (ENABLE_DEBUG && s == NULL)
-		bb_error_msg_and_die("xstrndup bug");
+		bb_simple_error_msg_and_die("xstrndup bug");
 
 	/* We can just xmalloc(n+1) and strncpy into it, */
 	/* but think about xstrndup("abc", 10000) wastage! */
@@ -215,13 +215,13 @@ int FAST_FUNC rename_or_warn(const char *oldpath, const char *newpath)
 void FAST_FUNC xpipe(int filedes[2])
 {
 	if (pipe(filedes))
-		bb_perror_msg_and_die("can't create pipe");
+		bb_simple_perror_msg_and_die("can't create pipe");
 }
 
 void FAST_FUNC xdup2(int from, int to)
 {
 	if (dup2(from, to) != to)
-		bb_perror_msg_and_die("can't duplicate file descriptor");
+		bb_simple_perror_msg_and_die("can't duplicate file descriptor");
 		//		" %d to %d", from, to);
 }
 
@@ -245,7 +245,7 @@ void FAST_FUNC xwrite(int fd, const void *buf, size_t count)
 			 * or some writes succeeded, then we hit an error.
 			 * In either case, errno is set.
 			 */
-			bb_perror_msg_and_die(
+			bb_simple_perror_msg_and_die(
 				size >= 0 ? "short write" : "write error"
 			);
 		}
@@ -259,7 +259,7 @@ void FAST_FUNC xwrite_str(int fd, const char *str)
 void FAST_FUNC xclose(int fd)
 {
 	if (close(fd))
-		bb_perror_msg_and_die("close failed");
+		bb_simple_perror_msg_and_die("close failed");
 }
 
 // Die with an error message if we can't lseek to the right spot.
@@ -267,9 +267,7 @@ off_t FAST_FUNC xlseek(int fd, off_t offset, int whence)
 {
 	off_t off = lseek(fd, offset, whence);
 	if (off == (off_t)-1) {
-		if (whence == SEEK_SET)
-			bb_perror_msg_and_die("lseek(%"OFF_FMT"u)", offset);
-		bb_perror_msg_and_die("lseek");
+		bb_perror_msg_and_die("lseek(%"OFF_FMT"u, %d)", offset, whence);
 	}
 	return off;
 }
@@ -384,23 +382,23 @@ void FAST_FUNC bb_unsetenv_and_free(char *var)
 // setgid() will fail and we'll _still_be_root_, which is bad.)
 void FAST_FUNC xsetgid(gid_t gid)
 {
-	if (setgid(gid)) bb_perror_msg_and_die("setgid");
+	if (setgid(gid)) bb_simple_perror_msg_and_die("setgid");
 }
 
 // Die with an error message if we can't set uid.  (See xsetgid() for why.)
 void FAST_FUNC xsetuid(uid_t uid)
 {
-	if (setuid(uid)) bb_perror_msg_and_die("setuid");
+	if (setuid(uid)) bb_simple_perror_msg_and_die("setuid");
 }
 
 void FAST_FUNC xsetegid(gid_t egid)
 {
-	if (setegid(egid)) bb_perror_msg_and_die("setegid");
+	if (setegid(egid)) bb_simple_perror_msg_and_die("setegid");
 }
 
 void FAST_FUNC xseteuid(uid_t euid)
 {
-	if (seteuid(euid)) bb_perror_msg_and_die("seteuid");
+	if (seteuid(euid)) bb_simple_perror_msg_and_die("seteuid");
 }
 
 // Die if we can't chdir to a new path.
@@ -413,7 +411,7 @@ void FAST_FUNC xchdir(const char *path)
 void FAST_FUNC xfchdir(int fd)
 {
 	if (fchdir(fd))
-		bb_perror_msg_and_die("fchdir");
+		bb_simple_perror_msg_and_die("fchdir");
 }
 
 void FAST_FUNC xchroot(const char *path)
@@ -463,7 +461,7 @@ int FAST_FUNC xsocket(int domain, int type, int protocol)
 IF_FEATURE_IPV6(if (domain == AF_INET6) s = "INET6";)
 		bb_perror_msg_and_die("socket(AF_%s,%d,%d)", s, type, protocol);
 #else
-		bb_perror_msg_and_die("socket");
+		bb_simple_perror_msg_and_die("socket");
 #endif
 	}
 
@@ -473,13 +471,13 @@ IF_FEATURE_IPV6(if (domain == AF_INET6) s = "INET6";)
 // Die with an error message if we can't bind a socket to an address.
 void FAST_FUNC xbind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen)
 {
-	if (bind(sockfd, my_addr, addrlen)) bb_perror_msg_and_die("bind");
+	if (bind(sockfd, my_addr, addrlen)) bb_simple_perror_msg_and_die("bind");
 }
 
 // Die with an error message if we can't listen for connections on a socket.
 void FAST_FUNC xlisten(int s, int backlog)
 {
-	if (listen(s, backlog)) bb_perror_msg_and_die("listen");
+	if (listen(s, backlog)) bb_simple_perror_msg_and_die("listen");
 }
 
 /* Die with an error message if sendto failed.
@@ -491,7 +489,7 @@ ssize_t FAST_FUNC xsendto(int s, const void *buf, size_t len, const struct socka
 	if (ret < 0) {
 		if (ENABLE_FEATURE_CLEAN_UP)
 			close(s);
-		bb_perror_msg_and_die("sendto");
+		bb_simple_perror_msg_and_die("sendto");
 	}
 	return ret;
 }
@@ -519,12 +517,12 @@ void FAST_FUNC selinux_or_die(void)
 #if ENABLE_SELINUX
 	int rc = is_selinux_enabled();
 	if (rc == 0) {
-		bb_error_msg_and_die("SELinux is disabled");
+		bb_simple_error_msg_and_die("SELinux is disabled");
 	} else if (rc < 0) {
-		bb_error_msg_and_die("is_selinux_enabled() failed");
+		bb_simple_error_msg_and_die("is_selinux_enabled() failed");
 	}
 #else
-	bb_error_msg_and_die("SELinux support is disabled");
+	bb_simple_error_msg_and_die("SELinux support is disabled");
 #endif
 }
 
@@ -675,7 +673,7 @@ pid_t FAST_FUNC xfork(void)
 	pid_t pid;
 	pid = fork();
 	if (pid < 0) /* wtf? */
-		bb_perror_msg_and_die("vfork"+1);
+		bb_simple_perror_msg_and_die("vfork"+1);
 	return pid;
 }
 #endif
diff --git a/libbb/xgetcwd.c b/libbb/xgetcwd.c
index 7f9088bda..f4e768982 100644
--- a/libbb/xgetcwd.c
+++ b/libbb/xgetcwd.c
@@ -33,7 +33,7 @@ xrealloc_getcwd_or_warn(char *cwd)
 			if (errno == ERANGE)
 				continue;
 			free(cwd);
-			bb_perror_msg("getcwd");
+			bb_simple_perror_msg("getcwd");
 			return NULL;
 		}
 		cwd = xrealloc(cwd, strlen(cwd) + 1);
diff --git a/libbb/xgethostbyname.c b/libbb/xgethostbyname.c
index 89d0329cc..9446daba7 100644
--- a/libbb/xgethostbyname.c
+++ b/libbb/xgethostbyname.c
@@ -12,6 +12,6 @@ struct hostent* FAST_FUNC xgethostbyname(const char *name)
 {
 	struct hostent *retval = gethostbyname(name);
 	if (!retval)
-		bb_herror_msg_and_die("%s", name);
+		bb_simple_herror_msg_and_die(name);
 	return retval;
 }
diff --git a/loginutils/addgroup.c b/loginutils/addgroup.c
index baa961ff3..2a83c8a15 100644
--- a/loginutils/addgroup.c
+++ b/loginutils/addgroup.c
@@ -149,7 +149,7 @@ int addgroup_main(int argc UNUSED_PARAM, char **argv)
 
 	/* need to be root */
 	if (geteuid()) {
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 	}
 	/* Syntax:
 	 *  addgroup group
diff --git a/loginutils/adduser.c b/loginutils/adduser.c
index 850c810c4..d3c795afa 100644
--- a/loginutils/adduser.c
+++ b/loginutils/adduser.c
@@ -159,7 +159,7 @@ static void passwd_wrapper(const char *login_name) NORETURN;
 static void passwd_wrapper(const char *login_name)
 {
 	BB_EXECLP("passwd", "passwd", "--", login_name, NULL);
-	bb_error_msg_and_die("can't execute passwd, you must set password manually");
+	bb_simple_error_msg_and_die("can't execute passwd, you must set password manually");
 }
 
 //FIXME: upstream adduser has no short options! NOT COMPATIBLE!
@@ -193,7 +193,7 @@ int adduser_main(int argc UNUSED_PARAM, char **argv)
 
 	/* got root? */
 	if (geteuid()) {
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 	}
 
 	pw.pw_gecos = (char *)"Linux User,,,";
diff --git a/loginutils/chpasswd.c b/loginutils/chpasswd.c
index dd0532c66..4e70b2557 100644
--- a/loginutils/chpasswd.c
+++ b/loginutils/chpasswd.c
@@ -63,7 +63,7 @@ int chpasswd_main(int argc UNUSED_PARAM, char **argv)
 	int opt;
 
 	if (getuid() != 0)
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 
 	opt = getopt32long(argv, "^" "emc:R:" "\0" "m--ec:e--mc:c--em",
 			chpasswd_longopts,
@@ -81,7 +81,7 @@ int chpasswd_main(int argc UNUSED_PARAM, char **argv)
 
 		pass = strchr(name, ':');
 		if (!pass)
-			bb_error_msg_and_die("missing new password");
+			bb_simple_error_msg_and_die("missing new password");
 		*pass++ = '\0';
 
 		xuname2uid(name); /* dies if there is no such user */
diff --git a/loginutils/deluser.c b/loginutils/deluser.c
index d7e9327ba..56bc7eaa6 100644
--- a/loginutils/deluser.c
+++ b/loginutils/deluser.c
@@ -76,7 +76,7 @@ int deluser_main(int argc, char **argv)
 #endif
 
 	if (geteuid() != 0)
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 
 	name = argv[1];
 	member = NULL;
diff --git a/loginutils/getty.c b/loginutils/getty.c
index 23e92bc77..7393a3d1c 100644
--- a/loginutils/getty.c
+++ b/loginutils/getty.c
@@ -168,7 +168,7 @@ static void parse_speeds(char *arg)
 		/* note: arg "0" turns into speed B0 */
 		G.numspeed++;
 		if (G.numspeed > MAX_SPEED)
-			bb_error_msg_and_die("too many alternate speeds");
+			bb_simple_error_msg_and_die("too many alternate speeds");
 	}
 	debug("exiting parse_speeds\n");
 }
@@ -230,7 +230,7 @@ static void open_tty(void)
 		 * Make sure it is open for read/write.
 		 */
 		if ((fcntl(0, F_GETFL) & (O_RDWR|O_RDONLY|O_WRONLY)) != O_RDWR)
-			bb_error_msg_and_die("stdin is not open for read/write");
+			bb_simple_error_msg_and_die("stdin is not open for read/write");
 
 		/* Try to get real tty name instead of "-" */
 		n = xmalloc_ttyname(0);
@@ -243,7 +243,7 @@ static void open_tty(void)
 static void set_tty_attrs(void)
 {
 	if (tcsetattr_stdin_TCSANOW(&G.tty_attrs) < 0)
-		bb_perror_msg_and_die("tcsetattr");
+		bb_simple_perror_msg_and_die("tcsetattr");
 }
 
 /* We manipulate tty_attrs this way:
@@ -485,7 +485,7 @@ static char *get_logname(void)
 				finalize_tty_attrs();
 				if (errno == EINTR || errno == EIO)
 					exit(EXIT_SUCCESS);
-				bb_perror_msg_and_die(bb_msg_read_error);
+				bb_simple_perror_msg_and_die(bb_msg_read_error);
 			}
 
 			switch (c) {
@@ -582,7 +582,7 @@ int getty_main(int argc UNUSED_PARAM, char **argv)
 			//	" sid %d pgid %d",
 			//	pid, getppid(),
 			//	getsid(0), getpgid(0));
-			bb_perror_msg_and_die("setsid");
+			bb_simple_perror_msg_and_die("setsid");
 			/*
 			 * When we can end up here?
 			 * Example: setsid() fails when run alone in interactive shell:
@@ -651,13 +651,13 @@ int getty_main(int argc UNUSED_PARAM, char **argv)
 	tsid = tcgetsid(STDIN_FILENO);
 	if (tsid < 0 || pid != tsid) {
 		if (ioctl(STDIN_FILENO, TIOCSCTTY, /*force:*/ (long)1) < 0)
-			bb_perror_msg_and_die("TIOCSCTTY");
+			bb_simple_perror_msg_and_die("TIOCSCTTY");
 	}
 
 #ifdef __linux__
 	/* Make ourself a foreground process group within our session */
 	if (tcsetpgrp(STDIN_FILENO, pid) < 0)
-		bb_perror_msg_and_die("tcsetpgrp");
+		bb_simple_perror_msg_and_die("tcsetpgrp");
 #endif
 
 	/*
@@ -669,7 +669,7 @@ int getty_main(int argc UNUSED_PARAM, char **argv)
 	 * 5 seconds seems to be a good value.
 	 */
 	if (tcgetattr(STDIN_FILENO, &G.tty_attrs) < 0)
-		bb_perror_msg_and_die("tcgetattr");
+		bb_simple_perror_msg_and_die("tcgetattr");
 
 	/* Update the utmp file. This tty is ours now! */
 	update_utmp(pid, LOGIN_PROCESS, G.tty_name, "LOGIN", G.fakehost);
diff --git a/loginutils/login.c b/loginutils/login.c
index a08642a34..4e65b3a19 100644
--- a/loginutils/login.c
+++ b/loginutils/login.c
@@ -358,7 +358,7 @@ int login_main(int argc UNUSED_PARAM, char **argv)
 	opt = getopt32(argv, "f:h:p", &opt_user, &opt_host);
 	if (opt & LOGIN_OPT_f) {
 		if (!run_by_root)
-			bb_error_msg_and_die("-f is for root only");
+			bb_simple_error_msg_and_die("-f is for root only");
 		safe_strncpy(username, opt_user, sizeof(username));
 	}
 	argv += optind;
@@ -529,7 +529,7 @@ int login_main(int argc UNUSED_PARAM, char **argv)
 	child_pid = vfork();
 	if (child_pid != 0) {
 		if (child_pid < 0)
-			bb_perror_msg("vfork");
+			bb_simple_perror_msg("vfork");
 		else {
 			wait_for_exitstatus(child_pid);
 			update_utmp_DEAD_PROCESS(child_pid);
diff --git a/loginutils/su.c b/loginutils/su.c
index 41291ea8f..7c1fc69c5 100644
--- a/loginutils/su.c
+++ b/loginutils/su.c
@@ -147,7 +147,7 @@ int su_main(int argc UNUSED_PARAM, char **argv)
 			syslog(LOG_NOTICE, "%c %s %s:%s",
 				'-', tty, old_user, opt_username);
 		bb_do_delay(LOGIN_FAIL_DELAY);
-		bb_error_msg_and_die("incorrect password");
+		bb_simple_error_msg_and_die("incorrect password");
 	}
 
 	if (ENABLE_FEATURE_CLEAN_UP && ENABLE_FEATURE_SU_SYSLOG) {
@@ -165,7 +165,7 @@ int su_main(int argc UNUSED_PARAM, char **argv)
 		 * probably a uucp account or has restricted access.  Don't
 		 * compromise the account by allowing access with a standard
 		 * shell.  */
-		bb_error_msg("using restricted shell");
+		bb_simple_error_msg("using restricted shell");
 		opt_shell = NULL; /* ignore -s PROG */
 	}
 	/* else: user can run whatever he wants via "su -s PROG USER".
diff --git a/loginutils/sulogin.c b/loginutils/sulogin.c
index 9bb4d3613..099085340 100644
--- a/loginutils/sulogin.c
+++ b/loginutils/sulogin.c
@@ -56,7 +56,7 @@ int sulogin_main(int argc UNUSED_PARAM, char **argv)
 
 	pwd = getpwuid(0);
 	if (!pwd) {
-		bb_error_msg_and_die("no password entry for root");
+		bb_simple_error_msg_and_die("no password entry for root");
 	}
 
 	while (1) {
@@ -68,17 +68,17 @@ int sulogin_main(int argc UNUSED_PARAM, char **argv)
 		);
 		if (r < 0) {
 			/* ^D, ^C, timeout, or read error */
-			bb_info_msg("normal startup");
+			bb_simple_info_msg("normal startup");
 			return 0;
 		}
 		if (r > 0) {
 			break;
 		}
 		bb_do_delay(LOGIN_FAIL_DELAY);
-		bb_info_msg("Login incorrect");
+		bb_simple_info_msg("Login incorrect");
 	}
 
-	bb_info_msg("starting shell for system maintenance");
+	bb_simple_info_msg("starting shell for system maintenance");
 
 	IF_SELINUX(renew_current_security_context());
 
diff --git a/mailutils/mail.c b/mailutils/mail.c
index 6726654f7..3a1fd6949 100644
--- a/mailutils/mail.c
+++ b/mailutils/mail.c
@@ -15,7 +15,7 @@ static void signal_handler(int signo)
 {
 #define err signo
 	if (SIGALRM == signo) {
-		bb_error_msg_and_die("timed out");
+		bb_simple_error_msg_and_die("timed out");
 	}
 
 	// SIGCHLD. reap zombies
@@ -128,7 +128,7 @@ static void encode_n_base64(const char *fname, const char *text, size_t len)
 		if (fname) {
 			size = fread((char *)src_buf, 1, SRC_BUF_SIZE, fp);
 			if ((ssize_t)size < 0)
-				bb_perror_msg_and_die(bb_msg_read_error);
+				bb_simple_perror_msg_and_die(bb_msg_read_error);
 		} else {
 			size = len;
 			if (len > SRC_BUF_SIZE)
@@ -179,5 +179,5 @@ void FAST_FUNC get_cred_or_die(int fd)
 		G.pass = xmalloc_reads(fd, /* maxsize: */ NULL);
 	}
 	if (!G.user || !*G.user || !G.pass)
-		bb_error_msg_and_die("no username or password");
+		bb_simple_error_msg_and_die("no username or password");
 }
diff --git a/mailutils/popmaildir.c b/mailutils/popmaildir.c
index 589456715..6927e3a58 100644
--- a/mailutils/popmaildir.c
+++ b/mailutils/popmaildir.c
@@ -222,7 +222,7 @@ int popmaildir_main(int argc UNUSED_PARAM, char **argv)
 			fp = popen(delivery, "w");
 			unsetenv("FILENAME");
 			if (!fp) {
-				bb_perror_msg("delivery helper");
+				bb_simple_perror_msg("delivery helper");
 				break;
 			}
 		} else
diff --git a/mailutils/sendmail.c b/mailutils/sendmail.c
index 32c50ba84..1bdc1c300 100644
--- a/mailutils/sendmail.c
+++ b/mailutils/sendmail.c
@@ -338,7 +338,7 @@ int sendmail_main(int argc UNUSED_PARAM, char **argv)
 			smtp_check(NULL, 250);
 		else
 		if (code != 250)
-			bb_error_msg_and_die("SMTP init failed");
+			bb_simple_error_msg_and_die("SMTP init failed");
 	} else {
 		// vanilla connection
 		int fd;
diff --git a/miscutils/bc.c b/miscutils/bc.c
index aba51e5f8..7ac30dd53 100644
--- a/miscutils/bc.c
+++ b/miscutils/bc.c
@@ -893,7 +893,7 @@ static void fflush_and_check(void)
 {
 	fflush_all();
 	if (ferror(stdout) || ferror(stderr))
-		bb_perror_msg_and_die("output error");
+		bb_simple_perror_msg_and_die("output error");
 }
 
 #if ENABLE_FEATURE_CLEAN_UP
@@ -908,7 +908,7 @@ static void quit(void) NORETURN;
 static void quit(void)
 {
 	if (ferror(stdin))
-		bb_perror_msg_and_die("input error");
+		bb_simple_perror_msg_and_die("input error");
 	fflush_and_check();
 	dbg_exec("quit(): exiting with exitcode SUCCESS");
 	exit(0);
@@ -2576,7 +2576,7 @@ static void xc_read_line(BcVec *vec, FILE *fp)
 				goto get_char;
 			if (c == EOF) {
 				if (ferror(fp))
-					bb_perror_msg_and_die("input error");
+					bb_simple_perror_msg_and_die("input error");
 				// Note: EOF does not append '\n'
 				break;
 			}
@@ -6925,9 +6925,9 @@ static BC_STATUS zxc_vm_process(const char *text)
 		ip = (void*)G.prog.exestack.v;
 #if SANITY_CHECKS
 		if (G.prog.exestack.len != 1) // should have only main's IP
-			bb_error_msg_and_die("BUG:call stack");
+			bb_simple_error_msg_and_die("BUG:call stack");
 		if (ip->func != BC_PROG_MAIN)
-			bb_error_msg_and_die("BUG:not MAIN");
+			bb_simple_error_msg_and_die("BUG:not MAIN");
 #endif
 		f = xc_program_func_BC_PROG_MAIN();
 		// bc discards strings, constants and code after each
@@ -6943,7 +6943,7 @@ static BC_STATUS zxc_vm_process(const char *text)
 		if (IS_BC) {
 #if SANITY_CHECKS
 			if (G.prog.results.len != 0) // should be empty
-				bb_error_msg_and_die("BUG:data stack");
+				bb_simple_error_msg_and_die("BUG:data stack");
 #endif
 			IF_BC(bc_vec_pop_all(&f->strs);)
 			IF_BC(bc_vec_pop_all(&f->consts);)
diff --git a/miscutils/chat.c b/miscutils/chat.c
index 5183d1369..a04565063 100644
--- a/miscutils/chat.c
+++ b/miscutils/chat.c
@@ -307,7 +307,7 @@ int chat_main(int argc UNUSED_PARAM, char **argv)
 			} else if (DIR_SAY == key) {
 				// just print argument verbatim
 				// TODO: should we use full_write() to avoid unistd/stdio conflict?
-				bb_error_msg("%s", arg);
+				bb_simple_error_msg(arg);
 			}
 			// next, please!
 			argv++;
diff --git a/miscutils/crond.c b/miscutils/crond.c
index b533a3991..2e8ca8b68 100644
--- a/miscutils/crond.c
+++ b/miscutils/crond.c
@@ -731,7 +731,7 @@ fork_job(const char *user, int mailFd, CronLine *line, bool run_sendmail)
 	logmode = sv_logmode;
 
 	if (pid < 0) {
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
  err:
 		pid = 0;
 	} /* else: PARENT, FORK SUCCESS */
@@ -861,7 +861,7 @@ static pid_t start_one_job(const char *user, CronLine *line)
 		bb_error_msg_and_die("can't execute '%s' for user %s", shell, user);
 	}
 	if (pid < 0) {
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
  err:
 		pid = 0;
 	}
diff --git a/miscutils/crontab.c b/miscutils/crontab.c
index 96dc4741a..c71d914fc 100644
--- a/miscutils/crontab.c
+++ b/miscutils/crontab.c
@@ -107,7 +107,7 @@ int crontab_main(int argc UNUSED_PARAM, char **argv)
 	if (sanitize_env_if_suid()) { /* Clears dangerous stuff, sets PATH */
 		/* Run by non-root */
 		if (opt_ler & (OPT_u|OPT_c))
-			bb_error_msg_and_die(bb_msg_you_must_be_root);
+			bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 	}
 
 	if (opt_ler & OPT_u) {
diff --git a/miscutils/dc.c b/miscutils/dc.c
index 5aef64b60..ef93c20ba 100644
--- a/miscutils/dc.c
+++ b/miscutils/dc.c
@@ -39,14 +39,14 @@ static unsigned check_under(void)
 {
 	unsigned p = pointer;
 	if (p == 0)
-		bb_error_msg_and_die("stack underflow");
+		bb_simple_error_msg_and_die("stack underflow");
 	return p - 1;
 }
 
 static void push(double a)
 {
 	if (pointer >= STACK_SIZE)
-		bb_error_msg_and_die("stack overflow");
+		bb_simple_error_msg_and_die("stack overflow");
 	stack[pointer++] = a;
 }
 
diff --git a/miscutils/devfsd.c b/miscutils/devfsd.c
index e4d104d0c..f3d935b2e 100644
--- a/miscutils/devfsd.c
+++ b/miscutils/devfsd.c
@@ -344,14 +344,19 @@ static const char bb_msg_variable_not_found[] ALIGN1 = "variable: %s not found";
 /* Busybox stuff */
 #if ENABLE_DEVFSD_VERBOSE || ENABLE_DEBUG
 #define info_logger(p, fmt, args...)                 bb_info_msg(fmt, ## args)
+#define simple_info_logger(p, msg)                   bb_simple_info_msg(msg)
 #define msg_logger(p, fmt, args...)                  bb_error_msg(fmt, ## args)
+#define simple_msg_logger(p, msg)                    bb_simple_error_msg(msg)
 #define msg_logger_and_die(p, fmt, args...)          bb_error_msg_and_die(fmt, ## args)
+#define simple_msg_logger_and_die(p, msg)            bb_simple_error_msg_and_die(msg)
 #define error_logger(p, fmt, args...)                bb_perror_msg(fmt, ## args)
 #define error_logger_and_die(p, fmt, args...)        bb_perror_msg_and_die(fmt, ## args)
 #else
 #define info_logger(p, fmt, args...)
 #define msg_logger(p, fmt, args...)
+#define simple_msg_logger(p, msg)
 #define msg_logger_and_die(p, fmt, args...)           exit(EXIT_FAILURE)
+#define simple_msg_logger_and_die(p, msg)             exit(EXIT_FAILURE)
 #define error_logger(p, fmt, args...)
 #define error_logger_and_die(p, fmt, args...)         exit(EXIT_FAILURE)
 #endif
@@ -727,7 +732,7 @@ static int do_servicing(int fd, unsigned long event_mask)
 		caught_sighup = FALSE;
 		return c_sighup;
 	}
-	msg_logger_and_die(LOG_ERR, "read error on control file");
+	simple_msg_logger_and_die(LOG_ERR, "read error on control file");
 }   /*  End Function do_servicing  */
 
 static void service_name(const struct devfsd_notify_struct *info)
@@ -786,7 +791,7 @@ static void service_name(const struct devfsd_notify_struct *info)
 				action_compat(info, entry->action.what);
 				break;
 			default:
-				msg_logger_and_die(LOG_ERR, "Unknown action");
+				simple_msg_logger_and_die(LOG_ERR, "Unknown action");
 		}
 	}
 }   /*  End Function service_name  */
@@ -1691,7 +1696,7 @@ int st_expr_expand(char *output, unsigned int length, const char *input,
 	}
 	return FALSE;
 st_expr_expand_out:
-	info_logger(LOG_INFO, bb_msg_small_buffer);
+	simple_info_logger(LOG_INFO, bb_msg_small_buffer);
 	return FALSE;
 }   /*  End Function st_expr_expand  */
 
@@ -1775,7 +1780,7 @@ static const char *expand_variable(char *buffer, unsigned int length,
 		return input + len;
 	}
 	if (ch != ':' || ptr[1] != '-') {
-		info_logger(LOG_INFO, "illegal char in var name");
+		simple_info_logger(LOG_INFO, "illegal char in var name");
 		return NULL;
 	}
 	/*  It's that handy "${var:-word}" expression. Check if var is defined  */
@@ -1838,7 +1843,7 @@ static const char *expand_variable(char *buffer, unsigned int length,
 	*out_pos += len;
 	return input;
 expand_variable_out:
-	info_logger(LOG_INFO, bb_msg_small_buffer);
+	simple_info_logger(LOG_INFO, bb_msg_small_buffer);
 	return NULL;
 }   /*  End Function expand_variable  */
 
diff --git a/miscutils/devmem.c b/miscutils/devmem.c
index 51ac3f22f..e8dce5225 100644
--- a/miscutils/devmem.c
+++ b/miscutils/devmem.c
@@ -89,7 +89,7 @@ int devmem_main(int argc UNUSED_PARAM, char **argv)
 			fd,
 			target & ~(off_t)(page_size - 1));
 	if (map_base == MAP_FAILED)
-		bb_perror_msg_and_die("mmap");
+		bb_simple_perror_msg_and_die("mmap");
 
 //	printf("Memory mapped at address %p.\n", map_base);
 
@@ -110,7 +110,7 @@ int devmem_main(int argc UNUSED_PARAM, char **argv)
 			read_result = *(volatile uint64_t*)virt_addr;
 			break;
 		default:
-			bb_error_msg_and_die("bad width");
+			bb_simple_error_msg_and_die("bad width");
 		}
 //		printf("Value at address 0x%"OFF_FMT"X (%p): 0x%llX\n",
 //			target, virt_addr,
@@ -136,7 +136,7 @@ int devmem_main(int argc UNUSED_PARAM, char **argv)
 //			read_result = *(volatile uint64_t*)virt_addr;
 			break;
 		default:
-			bb_error_msg_and_die("bad width");
+			bb_simple_error_msg_and_die("bad width");
 		}
 //		printf("Written 0x%llX; readback 0x%llX\n",
 //				(unsigned long long)writeval,
@@ -145,7 +145,7 @@ int devmem_main(int argc UNUSED_PARAM, char **argv)
 
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		if (munmap(map_base, mapped_size) == -1)
-			bb_perror_msg_and_die("munmap");
+			bb_simple_perror_msg_and_die("munmap");
 		close(fd);
 	}
 
diff --git a/miscutils/fbsplash.c b/miscutils/fbsplash.c
index bba22d6d1..141957809 100644
--- a/miscutils/fbsplash.c
+++ b/miscutils/fbsplash.c
@@ -183,7 +183,7 @@ static void fb_open(const char *strfb_device)
 			(G.scr_var.yres_virtual ?: G.scr_var.yres) * G.scr_fix.line_length,
 			PROT_WRITE, MAP_SHARED, fbfd, 0);
 	if (G.addr == MAP_FAILED)
-		bb_perror_msg_and_die("mmap");
+		bb_simple_perror_msg_and_die("mmap");
 
 	// point to the start of the visible screen
 	G.addr += G.scr_var.yoffset * G.scr_fix.line_length + G.scr_var.xoffset * G.bytes_per_pixel;
diff --git a/miscutils/flash_eraseall.c b/miscutils/flash_eraseall.c
index a3dabdadb..c76d9a699 100644
--- a/miscutils/flash_eraseall.c
+++ b/miscutils/flash_eraseall.c
@@ -120,7 +120,7 @@ int flash_eraseall_main(int argc UNUSED_PARAM, char **argv)
 				if (clmlen > 8)
 					clmlen = 8;
 				if (clmlen == 0)
-					bb_error_msg_and_die("autoplacement selected and no empty space in oob");
+					bb_simple_error_msg_and_die("autoplacement selected and no empty space in oob");
 			} else {
 				/* Legacy mode */
 				switch (meminfo.oobsize) {
@@ -168,9 +168,9 @@ int flash_eraseall_main(int argc UNUSED_PARAM, char **argv)
 				if (errno == EOPNOTSUPP) {
 					flags |= OPTION_N;
 					if (flags & IS_NAND)
-						bb_error_msg_and_die("bad block check not available");
+						bb_simple_error_msg_and_die("bad block check not available");
 				} else {
-					bb_perror_msg_and_die("MEMGETBADBLOCK error");
+					bb_simple_perror_msg_and_die("MEMGETBADBLOCK error");
 				}
 			}
 		}
diff --git a/miscutils/hdparm.c b/miscutils/hdparm.c
index 342e240fa..b453efba9 100644
--- a/miscutils/hdparm.c
+++ b/miscutils/hdparm.c
@@ -810,7 +810,7 @@ static void identify(uint16_t *val)
 		like_std = 3;
 	} else
 		/* "Unknown device type:\n\tbits 15&14 of general configuration word 0 both set to 1.\n" */
-		bb_error_msg_and_die("unknown device type");
+		bb_simple_error_msg_and_die("unknown device type");
 
 	printf("%sremovable media\n", !(val[GEN_CONFIG] & MEDIA_REMOVABLE) ? "non-" : "");
 	/* Info from the specific configuration word says whether or not the
@@ -1440,7 +1440,7 @@ static void flush_buffer_cache(/*int fd*/ void)
 	sleep(1);
 	if (ioctl(fd, HDIO_DRIVE_CMD, NULL) && errno != EINVAL) {	/* await completion */
 		if (ENABLE_IOCTL_HEX2STR_ERROR) /* To be coherent with ioctl_or_warn */
-			bb_perror_msg("HDIO_DRIVE_CMD");
+			bb_simple_perror_msg("HDIO_DRIVE_CMD");
 		else
 			bb_perror_msg("ioctl %#x failed", HDIO_DRIVE_CMD);
 	}
@@ -1506,7 +1506,7 @@ static void do_time(int cache /*,int fd*/)
 	char *buf = xmalloc(TIMING_BUF_BYTES);
 
 	if (mlock(buf, TIMING_BUF_BYTES))
-		bb_perror_msg_and_die("mlock");
+		bb_simple_perror_msg_and_die("mlock");
 
 	/* Clear out the device request queues & give them time to complete.
 	 * NB: *small* delay. User is expected to have a clue and to not run
@@ -1857,7 +1857,7 @@ static void process_dev(char *devname)
 		char buf[512];
 		flush_buffer_cache();
 		if (-1 == read(fd, buf, sizeof(buf)))
-			bb_perror_msg("read of 512 bytes failed");
+			bb_simple_perror_msg("read of 512 bytes failed");
 	}
 #endif  /* HDIO_DRIVE_CMD */
 	if (getset_mult || get_identity) {
@@ -1865,7 +1865,7 @@ static void process_dev(char *devname)
 		if (ioctl(fd, HDIO_GET_MULTCOUNT, &multcount)) {
 			/* To be coherent with ioctl_or_warn. */
 			if (getset_mult && ENABLE_IOCTL_HEX2STR_ERROR)
-				bb_perror_msg("HDIO_GET_MULTCOUNT");
+				bb_simple_perror_msg("HDIO_GET_MULTCOUNT");
 			else
 				bb_perror_msg("ioctl %#x failed", HDIO_GET_MULTCOUNT);
 		} else if (getset_mult) {
@@ -1985,7 +1985,7 @@ static void process_dev(char *devname)
 		} else if (errno == -ENOMSG)
 			puts(" no identification info available");
 		else if (ENABLE_IOCTL_HEX2STR_ERROR)  /* To be coherent with ioctl_or_warn */
-			bb_perror_msg("HDIO_GET_IDENTITY");
+			bb_simple_perror_msg("HDIO_GET_IDENTITY");
 		else
 			bb_perror_msg("ioctl %#x failed", HDIO_GET_IDENTITY);
 	}
diff --git a/miscutils/hexedit.c b/miscutils/hexedit.c
index 5c2f4a555..898d77376 100644
--- a/miscutils/hexedit.c
+++ b/miscutils/hexedit.c
@@ -193,7 +193,7 @@ static int remap(unsigned cur_pos)
 	);
 	if (G.baseaddr == MAP_FAILED) {
 		restore_term();
-		bb_perror_msg_and_die("mmap");
+		bb_simple_perror_msg_and_die("mmap");
 	}
 
 	G.current_byte = G.baseaddr + cur_pos;
diff --git a/miscutils/i2c_tools.c b/miscutils/i2c_tools.c
index 7a2e8534a..82a559f74 100644
--- a/miscutils/i2c_tools.c
+++ b/miscutils/i2c_tools.c
@@ -344,7 +344,7 @@ static void get_funcs_matrix(int fd, unsigned long *funcs)
 static void check_funcs_test_end(int funcs, int pec, const char *err)
 {
 	if (pec && !(funcs & (I2C_FUNC_SMBUS_PEC | I2C_FUNC_I2C)))
-		bb_error_msg("warning: adapter does not support PEC");
+		bb_simple_error_msg("warning: adapter does not support PEC");
 
 	if (err)
 		bb_error_msg_and_die(
@@ -392,7 +392,7 @@ static void check_read_funcs(int fd, int mode, int data_addr, int pec)
 		break;
 #endif /* ENABLE_I2CDUMP */
 	default:
-		bb_error_msg_and_die("internal error");
+		bb_simple_error_msg_and_die("internal error");
 	}
 	check_funcs_test_end(funcs, pec, err);
 }
@@ -438,7 +438,7 @@ static void confirm_or_abort(void)
 {
 	fprintf(stderr, "Continue? [y/N] ");
 	if (!bb_ask_y_confirmation())
-		bb_error_msg_and_die("aborting");
+		bb_simple_error_msg_and_die("aborting");
 }
 
 /*
@@ -449,20 +449,20 @@ static void confirm_or_abort(void)
  */
 static void confirm_action(int bus_addr, int mode, int data_addr, int pec)
 {
-	bb_error_msg("WARNING! This program can confuse your I2C bus");
+	bb_simple_error_msg("WARNING! This program can confuse your I2C bus");
 
 	/* Don't let the user break his/her EEPROMs */
 	if (bus_addr >= 0x50 && bus_addr <= 0x57 && pec) {
-		bb_error_msg_and_die("this is I2C not smbus - using PEC on I2C "
+		bb_simple_error_msg_and_die("this is I2C not smbus - using PEC on I2C "
 			"devices may result in data loss, aborting");
 	}
 
 	if (mode == I2C_SMBUS_BYTE && data_addr >= 0 && pec)
-		bb_error_msg("WARNING! May interpret a write byte command "
+		bb_simple_error_msg("WARNING! May interpret a write byte command "
 			"with PEC as a write byte data command");
 
 	if (pec)
-		bb_error_msg("PEC checking enabled");
+		bb_simple_error_msg("PEC checking enabled");
 
 	confirm_or_abort();
 }
@@ -507,7 +507,7 @@ int i2cget_main(int argc UNUSED_PARAM, char **argv)
 			case 'w':	mode = I2C_SMBUS_WORD_DATA;	break;
 			case 'c':	mode = I2C_SMBUS_BYTE;		break;
 			default:
-				bb_error_msg("invalid mode");
+				bb_simple_error_msg("invalid mode");
 				bb_show_usage();
 			}
 			pec = argv[3][1] == 'p';
@@ -529,7 +529,7 @@ int i2cget_main(int argc UNUSED_PARAM, char **argv)
 		if (data_addr >= 0) {
 			status = i2c_smbus_write_byte(fd, data_addr);
 			if (status < 0)
-				bb_error_msg("warning - write failed");
+				bb_simple_error_msg("warning - write failed");
 		}
 		status = i2c_smbus_read_byte(fd);
 		break;
@@ -542,7 +542,7 @@ int i2cget_main(int argc UNUSED_PARAM, char **argv)
 	close(fd);
 
 	if (status < 0)
-		bb_perror_msg_and_die("read failed");
+		bb_simple_perror_msg_and_die("read failed");
 
 	printf("0x%0*x\n", mode == I2C_SMBUS_WORD_DATA ? 4 : 2, status);
 
@@ -611,7 +611,7 @@ int i2cset_main(int argc, char **argv)
 			case 'i': mode = I2C_SMBUS_I2C_BLOCK_DATA;
 				break;
 			default:
-				bb_error_msg("invalid mode");
+				bb_simple_error_msg("invalid mode");
 				bb_show_usage();
 			}
 
@@ -620,11 +620,11 @@ int i2cset_main(int argc, char **argv)
 			 || mode == I2C_SMBUS_I2C_BLOCK_DATA
 			) {
 				if (pec && mode == I2C_SMBUS_I2C_BLOCK_DATA)
-					bb_error_msg_and_die(
+					bb_simple_error_msg_and_die(
 						"PEC not supported for I2C "
 						"block writes");
 				if (opts & opt_m)
-					bb_error_msg_and_die(
+					bb_simple_error_msg_and_die(
 						"mask not supported for block "
 						"writes");
 			}
@@ -685,7 +685,7 @@ int i2cset_main(int argc, char **argv)
 		}
 
 		if (tmpval < 0)
-			bb_perror_msg_and_die("can't read old value");
+			bb_simple_perror_msg_and_die("can't read old value");
 
 		val = (val & mask) | (tmpval & ~mask);
 
@@ -724,7 +724,7 @@ int i2cset_main(int argc, char **argv)
 		break;
 	}
 	if (status < 0)
-		bb_perror_msg_and_die("write failed");
+		bb_simple_perror_msg_and_die("write failed");
 
 	if (pec)
 		i2c_set_pec(fd, 0); /* Clear PEC. */
@@ -978,12 +978,12 @@ int i2cdump_main(int argc UNUSED_PARAM, char **argv)
 		case 's': mode = I2C_SMBUS_BLOCK_DATA;		break;
 		case 'i': mode = I2C_SMBUS_I2C_BLOCK_DATA;	break;
 		default:
-			bb_error_msg_and_die("invalid mode");
+			bb_simple_error_msg_and_die("invalid mode");
 		}
 
 		if (argv[2][1] == 'p') {
 			if (argv[2][0] == 'W' || argv[2][0] == 'i') {
-				bb_error_msg_and_die(
+				bb_simple_error_msg_and_die(
 					"pec not supported for -W and -i");
 			} else {
 				pec = 1;
@@ -994,7 +994,7 @@ int i2cdump_main(int argc UNUSED_PARAM, char **argv)
 	if (opts & opt_r) {
 		first = strtol(opt_r_str, &dash, 0);
 		if (dash == opt_r_str || *dash != '-' || first > 0xff)
-			bb_error_msg_and_die("invalid range");
+			bb_simple_error_msg_and_die("invalid range");
 		last = xstrtou_range(++dash, 0, first, 0xff);
 
 		/* Range is not available for every mode. */
@@ -1007,7 +1007,7 @@ int i2cdump_main(int argc UNUSED_PARAM, char **argv)
 				break;
 			/* Fall through */
 		default:
-			bb_error_msg_and_die(
+			bb_simple_error_msg_and_die(
 				"range not compatible with selected mode");
 		}
 	}
@@ -1032,7 +1032,7 @@ int i2cdump_main(int argc UNUSED_PARAM, char **argv)
 		if (mode == I2C_SMBUS_BYTE) {
 			res = i2c_smbus_write_byte(fd, first);
 			if (res < 0)
-				bb_perror_msg_and_die("write start address");
+				bb_simple_perror_msg_and_die("write start address");
 		}
 
 		dump_data(fd, mode, first, last, block, blen);
@@ -1398,7 +1398,7 @@ static void check_i2c_func(int fd)
 	get_funcs_matrix(fd, &funcs);
 
 	if (!(funcs & I2C_FUNC_I2C))
-		bb_error_msg_and_die("adapter does not support I2C transfers");
+		bb_simple_error_msg_and_die("adapter does not support I2C transfers");
 }
 
 //usage:#define i2ctransfer_trivial_usage
@@ -1451,7 +1451,7 @@ int i2ctransfer_main(int argc UNUSED_PARAM, char **argv)
 		char *end;
 
 		if (nmsgs >= I2C_RDWR_IOCTL_MAX_MSGS)
-			bb_error_msg_and_die("too many messages, max: "I2C_RDWR_IOCTL_MAX_MSGS_STR);
+			bb_simple_error_msg_and_die("too many messages, max: "I2C_RDWR_IOCTL_MAX_MSGS_STR);
 
 		flags = 0;
 		arg_ptr = *argv;
diff --git a/miscutils/inotifyd.c b/miscutils/inotifyd.c
index ec0321941..8bff86ae5 100644
--- a/miscutils/inotifyd.c
+++ b/miscutils/inotifyd.c
@@ -117,7 +117,7 @@ int inotifyd_main(int argc, char **argv)
 	// open inotify
 	pfd.fd = inotify_init();
 	if (pfd.fd < 0)
-		bb_perror_msg_and_die("no kernel support");
+		bb_simple_perror_msg_and_die("no kernel support");
 
 	// setup watches
 	while (*++argv) {
diff --git a/miscutils/nandwrite.c b/miscutils/nandwrite.c
index 09bcaaf63..f111c6363 100644
--- a/miscutils/nandwrite.c
+++ b/miscutils/nandwrite.c
@@ -101,7 +101,7 @@ static unsigned next_good_eraseblock(int fd, struct mtd_info_user *meminfo,
 
 		if (block_offset >= meminfo->size) {
 			if (IS_NANDWRITE)
-				bb_error_msg_and_die("not enough space in MTD device");
+				bb_simple_error_msg_and_die("not enough space in MTD device");
 			return block_offset; /* let the caller exit */
 		}
 		offs = block_offset;
@@ -174,7 +174,7 @@ int nandwrite_main(int argc UNUSED_PARAM, char **argv)
 	meminfo_writesize = meminfo.writesize;
 
 	if (mtdoffset & (meminfo_writesize - 1))
-		bb_error_msg_and_die("start address is not page aligned");
+		bb_simple_error_msg_and_die("start address is not page aligned");
 
 	filebuf = xmalloc(meminfo_writesize);
 	oobbuf = xmalloc(meminfo.oobsize);
@@ -248,9 +248,9 @@ int nandwrite_main(int argc UNUSED_PARAM, char **argv)
 		}
 		if (cnt < meminfo_writesize) {
 			if (IS_NANDDUMP)
-				bb_error_msg_and_die("short read");
+				bb_simple_error_msg_and_die("short read");
 			if (!(opts & OPT_p))
-				bb_error_msg_and_die("input size is not rounded up to page size, "
+				bb_simple_error_msg_and_die("input size is not rounded up to page size, "
 						"use -p to zero pad");
 			/* zero pad to end of write block */
 			memset(filebuf + cnt, 0, meminfo_writesize - cnt);
@@ -273,7 +273,7 @@ int nandwrite_main(int argc UNUSED_PARAM, char **argv)
 		/* We filled entire MTD, but did we reach EOF on input? */
 		if (full_read(STDIN_FILENO, filebuf, meminfo_writesize) != 0) {
 			/* no */
-			bb_error_msg_and_die("not enough space in MTD device");
+			bb_simple_error_msg_and_die("not enough space in MTD device");
 		}
 	}
 
diff --git a/miscutils/rfkill.c b/miscutils/rfkill.c
index 766bad8c7..db7c83750 100644
--- a/miscutils/rfkill.c
+++ b/miscutils/rfkill.c
@@ -88,7 +88,7 @@ int rfkill_main(int argc UNUSED_PARAM, char **argv)
 
 	rf_fd = device_open("/dev/rfkill", mode);
 	if (rf_fd < 0)
-		bb_perror_msg_and_die("/dev/rfkill");
+		bb_simple_perror_msg_and_die("/dev/rfkill");
 
 	if (rf_opt & OPT_l) {
 		while (full_read(rf_fd, &event, sizeof(event)) == RFKILL_EVENT_SIZE_V1) {
diff --git a/miscutils/rx.c b/miscutils/rx.c
index 874a3f0a3..319ec1d49 100644
--- a/miscutils/rx.c
+++ b/miscutils/rx.c
@@ -120,7 +120,7 @@ static int receive(/*int read_fd, */int file_fd)
 		/* Write previously received block */
 		errno = 0;
 		if (full_write(file_fd, blockBuf, blockLength) != blockLength) {
-			bb_perror_msg(bb_msg_write_error);
+			bb_simple_perror_msg(bb_msg_write_error);
 			goto fatal;
 		}
 
@@ -150,7 +150,7 @@ static int receive(/*int read_fd, */int file_fd)
 			goto timeout;
 
 		if (blockNo != (255 - blockNoOnesCompl)) {
-			bb_error_msg("bad block ones compl");
+			bb_simple_error_msg("bad block ones compl");
 			goto error;
 		}
 
@@ -229,7 +229,7 @@ static int receive(/*int read_fd, */int file_fd)
 				do_crc = 0;
 				goto timeout;
 			}
-			bb_error_msg("too many errors; giving up");
+			bb_simple_error_msg("too many errors; giving up");
  fatal:
 			/* 5 CAN followed by 5 BS. Don't try too hard... */
 			safe_write(write_fd, "\030\030\030\030\030\010\010\010\010\010", 10);
diff --git a/miscutils/time.c b/miscutils/time.c
index 064888ab8..d15d363f3 100644
--- a/miscutils/time.c
+++ b/miscutils/time.c
@@ -88,7 +88,7 @@ static void resuse_end(pid_t pid, resource_t *resp)
 	 * returns the child process, set the time the command finished. */
 	while ((caught = wait3(&resp->waitstatus, 0, &resp->ru)) != pid) {
 		if (caught == -1 && errno != EINTR) {
-			bb_perror_msg("wait");
+			bb_simple_perror_msg("wait");
 			return;
 		}
 	}
diff --git a/miscutils/ubi_tools.c b/miscutils/ubi_tools.c
index dc7af25a4..8318df0f9 100644
--- a/miscutils/ubi_tools.c
+++ b/miscutils/ubi_tools.c
@@ -234,10 +234,10 @@ int ubi_tools_main(int argc UNUSED_PARAM, char **argv)
 			//	bb_error_msg_and_die("%s invalid maximum size calculated", "UBI");
 		} else
 		if (!(opts & OPTION_s))
-			bb_error_msg_and_die("size not specified");
+			bb_simple_error_msg_and_die("size not specified");
 
 		if (!(opts & OPTION_N))
-			bb_error_msg_and_die("name not specified");
+			bb_simple_error_msg_and_die("name not specified");
 
 		/* the structure is memset(0) above */
 		mkvol_req.vol_id = vol_id;
@@ -264,7 +264,7 @@ int ubi_tools_main(int argc UNUSED_PARAM, char **argv)
 //usage:     "\n	-N VOLNAME	Volume name"
 	if (do_rmvol) {
 		if (!(opts & (OPTION_n|OPTION_N)))
-			bb_error_msg_and_die("volume id not specified");
+			bb_simple_error_msg_and_die("volume id not specified");
 
 		if (opts & OPTION_N) {
 			unsigned num = ubi_devnum_from_devname(ubi_ctrl);
@@ -288,9 +288,9 @@ int ubi_tools_main(int argc UNUSED_PARAM, char **argv)
 //usage:     "\n	-s SIZE		Size in bytes"
 	if (do_rsvol) {
 		if (!(opts & OPTION_s))
-			bb_error_msg_and_die("size not specified");
+			bb_simple_error_msg_and_die("size not specified");
 		if (!(opts & OPTION_n))
-			bb_error_msg_and_die("volume id not specified");
+			bb_simple_error_msg_and_die("volume id not specified");
 
 		rsvol_req.bytes = size_bytes; /* signed int64_t */
 		rsvol_req.vol_id = vol_id;
diff --git a/miscutils/ubirename.c b/miscutils/ubirename.c
index 21bd10111..e7c56640c 100644
--- a/miscutils/ubirename.c
+++ b/miscutils/ubirename.c
@@ -72,7 +72,7 @@ int ubirename_main(int argc, char **argv)
 	rnvol = xzalloc(sizeof(*rnvol));
 	rnvol->count = --argc;
 	if (argc > ARRAY_SIZE(rnvol->ents))
-		bb_error_msg_and_die("too many renames requested");
+		bb_simple_error_msg_and_die("too many renames requested");
 
 	ubi_devname = argv[1];
 	ubi_devnum = ubi_devnum_from_devname(ubi_devname);
diff --git a/modutils/modutils-24.c b/modutils/modutils-24.c
index 1a30dd87c..ac8632481 100644
--- a/modutils/modutils-24.c
+++ b/modutils/modutils-24.c
@@ -2600,7 +2600,7 @@ static void new_get_kernel_symbols(void)
 			module_names = xrealloc(module_names, bufsize);
 			goto retry_modules_load;
 		}
-		bb_perror_msg_and_die("QM_MODULES");
+		bb_simple_perror_msg_and_die("QM_MODULES");
 	}
 
 	n_ext_modules = nmod = ret;
@@ -2661,7 +2661,7 @@ static void new_get_kernel_symbols(void)
 			syms = xrealloc(syms, bufsize);
 			goto retry_kern_sym_load;
 		}
-		bb_perror_msg_and_die("kernel: QM_SYMBOLS");
+		bb_simple_perror_msg_and_die("kernel: QM_SYMBOLS");
 	}
 	nksyms = nsyms = ret;
 	ksyms = syms;
@@ -3247,21 +3247,21 @@ static struct obj_file *obj_load(char *image, size_t image_size, int loadprogbit
 	f->load_order_search_start = &f->load_order;
 
 	if (image_size < sizeof(f->header))
-		bb_error_msg_and_die("error while loading ELF header");
+		bb_simple_error_msg_and_die("error while loading ELF header");
 	memcpy(&f->header, image, sizeof(f->header));
 
 	if (*(aliased_uint32_t*)(&f->header.e_ident) != ELFMAG_U32) {
-		bb_error_msg_and_die("not an ELF file");
+		bb_simple_error_msg_and_die("not an ELF file");
 	}
 	if (f->header.e_ident[EI_CLASS] != ELFCLASSM
 	 || f->header.e_ident[EI_DATA] != (BB_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB)
 	 || f->header.e_ident[EI_VERSION] != EV_CURRENT
 	 || !MATCH_MACHINE(f->header.e_machine)
 	) {
-		bb_error_msg_and_die("ELF file not for this architecture");
+		bb_simple_error_msg_and_die("ELF file not for this architecture");
 	}
 	if (f->header.e_type != ET_REL) {
-		bb_error_msg_and_die("ELF file not a relocatable object");
+		bb_simple_error_msg_and_die("ELF file not a relocatable object");
 	}
 
 	/* Read the section headers.  */
@@ -3280,7 +3280,7 @@ static struct obj_file *obj_load(char *image, size_t image_size, int loadprogbit
 
 	section_headers = alloca(sizeof(ElfW(Shdr)) * shnum);
 	if (image_size < f->header.e_shoff + sizeof(ElfW(Shdr)) * shnum)
-		bb_error_msg_and_die("error while loading section headers");
+		bb_simple_error_msg_and_die("error while loading section headers");
 	memcpy(section_headers, image + f->header.e_shoff, sizeof(ElfW(Shdr)) * shnum);
 
 	/* Read the section data.  */
@@ -3317,16 +3317,16 @@ static struct obj_file *obj_load(char *image, size_t image_size, int loadprogbit
 				if (sec->header.sh_size > 0) {
 					sec->contents = xmalloc(sec->header.sh_size);
 					if (image_size < (sec->header.sh_offset + sec->header.sh_size))
-						bb_error_msg_and_die("error while loading section data");
+						bb_simple_error_msg_and_die("error while loading section data");
 					memcpy(sec->contents, image + sec->header.sh_offset, sec->header.sh_size);
 				}
 				break;
 #if SHT_RELM == SHT_REL
 			case SHT_RELA:
-				bb_error_msg_and_die("RELA relocations not supported on this architecture");
+				bb_simple_error_msg_and_die("RELA relocations not supported on this architecture");
 #else
 			case SHT_REL:
-				bb_error_msg_and_die("REL relocations not supported on this architecture");
+				bb_simple_error_msg_and_die("REL relocations not supported on this architecture");
 #endif
 			default:
 				if (sec->header.sh_type >= SHT_LOPROC) {
@@ -3447,7 +3447,7 @@ static int obj_load_progbits(char *image, size_t image_size, struct obj_file *f,
 			continue;
 		sec->contents = imagebase + (sec->header.sh_addr - base);
 		if (image_size < (sec->header.sh_offset + sec->header.sh_size)) {
-			bb_error_msg("error reading ELF section data");
+			bb_simple_error_msg("error reading ELF section data");
 			return 0; /* need to delete half-loaded module! */
 		}
 		memcpy(sec->contents, image + sec->header.sh_offset, sec->header.sh_size);
@@ -3845,7 +3845,7 @@ int FAST_FUNC bb_init_module_24(const char *m_filename, const char *options)
 		if (m_has_modinfo) {
 			int m_version = new_get_module_version(f, m_strversion);
 			if (m_version == -1) {
-				bb_error_msg_and_die("can't find the kernel version "
+				bb_simple_error_msg_and_die("can't find the kernel version "
 					"the module was compiled for");
 			}
 		}
@@ -3864,7 +3864,7 @@ int FAST_FUNC bb_init_module_24(const char *m_filename, const char *options)
 #endif
 
 	if (query_module(NULL, 0, NULL, 0, NULL))
-		bb_error_msg_and_die("old (unsupported) kernel");
+		bb_simple_error_msg_and_die("old (unsupported) kernel");
 	new_get_kernel_symbols();
 	k_crcs = new_is_kernel_checksummed();
 
diff --git a/modutils/rmmod.c b/modutils/rmmod.c
index a3548879c..8d4639f50 100644
--- a/modutils/rmmod.c
+++ b/modutils/rmmod.c
@@ -52,7 +52,7 @@ int rmmod_main(int argc UNUSED_PARAM, char **argv)
 		/* Unload _all_ unused modules via NULL delete_module() call */
 		err = bb_delete_module(NULL, flags);
 		if (err && err != EFAULT)
-			bb_perror_msg_and_die("rmmod");
+			bb_simple_perror_msg_and_die("rmmod");
 		return EXIT_SUCCESS;
 	}
 
diff --git a/networking/arp.c b/networking/arp.c
index 71bfe3cbf..6519f8156 100644
--- a/networking/arp.c
+++ b/networking/arp.c
@@ -116,7 +116,7 @@ static int arp_del(char **args)
 	/* Resolve the host name. */
 	host = *args;
 	if (ap->input(host, &sa) < 0) {
-		bb_herror_msg_and_die("%s", host);
+		bb_simple_herror_msg_and_die(host);
 	}
 
 	/* If a host has more than one address, use the correct one! */
@@ -149,7 +149,7 @@ static int arp_del(char **args)
 #ifdef HAVE_ATF_DONTPUB
 			req.arp_flags |= ATF_DONTPUB;
 #else
-			bb_error_msg("feature ATF_DONTPUB is not supported");
+			bb_simple_error_msg("feature ATF_DONTPUB is not supported");
 #endif
 			args++;
 			break;
@@ -157,7 +157,7 @@ static int arp_del(char **args)
 #ifdef HAVE_ATF_MAGIC
 			req.arp_flags |= ATF_MAGIC;
 #else
-			bb_error_msg("feature ATF_MAGIC is not supported");
+			bb_simple_error_msg("feature ATF_MAGIC is not supported");
 #endif
 			args++;
 			break;
@@ -173,7 +173,7 @@ static int arp_del(char **args)
 			if (strcmp(*args, "255.255.255.255") != 0) {
 				host = *args;
 				if (ap->input(host, &sa) < 0) {
-					bb_herror_msg_and_die("%s", host);
+					bb_simple_herror_msg_and_die(host);
 				}
 				memcpy(&req.arp_netmask, &sa, sizeof(struct sockaddr));
 				req.arp_flags |= ATF_NETMASK;
@@ -195,7 +195,7 @@ static int arp_del(char **args)
 	/* Call the kernel. */
 	if (flags & 2) {
 		if (option_mask32 & ARP_OPT_v)
-			bb_error_msg("SIOCDARP(nopub)");
+			bb_simple_error_msg("SIOCDARP(nopub)");
 		err = ioctl(sockfd, SIOCDARP, &req);
 		if (err < 0) {
 			if (errno == ENXIO) {
@@ -204,20 +204,20 @@ static int arp_del(char **args)
 				printf("No ARP entry for %s\n", host);
 				return -1;
 			}
-			bb_perror_msg_and_die("SIOCDARP(priv)");
+			bb_simple_perror_msg_and_die("SIOCDARP(priv)");
 		}
 	}
 	if ((flags & 1) && err) {
  nopub:
 		req.arp_flags |= ATF_PUBL;
 		if (option_mask32 & ARP_OPT_v)
-			bb_error_msg("SIOCDARP(pub)");
+			bb_simple_error_msg("SIOCDARP(pub)");
 		if (ioctl(sockfd, SIOCDARP, &req) < 0) {
 			if (errno == ENXIO) {
 				printf("No ARP entry for %s\n", host);
 				return -1;
 			}
-			bb_perror_msg_and_die("SIOCDARP(pub)");
+			bb_simple_perror_msg_and_die("SIOCDARP(pub)");
 		}
 	}
 	return 0;
@@ -233,7 +233,7 @@ static void arp_getdevhw(char *ifname, struct sockaddr *sa)
 	ioctl_or_perror_and_die(sockfd, SIOCGIFHWADDR, &ifr,
 					"can't get HW-Address for '%s'", ifname);
 	if (hw_set && (ifr.ifr_hwaddr.sa_family != hw->type)) {
-		bb_error_msg_and_die("protocol type mismatch");
+		bb_simple_error_msg_and_die("protocol type mismatch");
 	}
 	memcpy(sa, &(ifr.ifr_hwaddr), sizeof(struct sockaddr));
 
@@ -261,20 +261,20 @@ static int arp_set(char **args)
 
 	host = *args++;
 	if (ap->input(host, &sa) < 0) {
-		bb_herror_msg_and_die("%s", host);
+		bb_simple_herror_msg_and_die(host);
 	}
 	/* If a host has more than one address, use the correct one! */
 	memcpy(&req.arp_pa, &sa, sizeof(struct sockaddr));
 
 	/* Fetch the hardware address. */
 	if (*args == NULL) {
-		bb_error_msg_and_die("need hardware address");
+		bb_simple_error_msg_and_die("need hardware address");
 	}
 	if (option_mask32 & ARP_OPT_D) {
 		arp_getdevhw(*args++, &req.arp_ha);
 	} else {
 		if (hw->input(*args++, &req.arp_ha) < 0) {
-			bb_error_msg_and_die("invalid hardware address");
+			bb_simple_error_msg_and_die("invalid hardware address");
 		}
 	}
 
@@ -302,7 +302,7 @@ static int arp_set(char **args)
 #ifdef HAVE_ATF_DONTPUB
 			flags |= ATF_DONTPUB;
 #else
-			bb_error_msg("feature ATF_DONTPUB is not supported");
+			bb_simple_error_msg("feature ATF_DONTPUB is not supported");
 #endif
 			args++;
 			break;
@@ -310,7 +310,7 @@ static int arp_set(char **args)
 #ifdef HAVE_ATF_MAGIC
 			flags |= ATF_MAGIC;
 #else
-			bb_error_msg("feature ATF_MAGIC is not supported");
+			bb_simple_error_msg("feature ATF_MAGIC is not supported");
 #endif
 			args++;
 			break;
@@ -326,7 +326,7 @@ static int arp_set(char **args)
 			if (strcmp(*args, "255.255.255.255") != 0) {
 				host = *args;
 				if (ap->input(host, &sa) < 0) {
-					bb_herror_msg_and_die("%s", host);
+					bb_simple_herror_msg_and_die(host);
 				}
 				memcpy(&req.arp_netmask, &sa, sizeof(struct sockaddr));
 				flags |= ATF_NETMASK;
@@ -346,7 +346,7 @@ static int arp_set(char **args)
 
 	/* Call the kernel. */
 	if (option_mask32 & ARP_OPT_v)
-		bb_error_msg("SIOCSARP()");
+		bb_simple_error_msg("SIOCSARP()");
 	xioctl(sockfd, SIOCSARP, &req);
 	return 0;
 }
@@ -422,7 +422,7 @@ static int arp_show(char *name)
 	if (name != NULL) {
 		/* Resolve the host name. */
 		if (ap->input(name, &sa) < 0) {
-			bb_herror_msg_and_die("%s", name);
+			bb_simple_herror_msg_and_die(name);
 		}
 		host = xstrdup(ap->sprint(&sa, 1));
 	}
@@ -530,7 +530,7 @@ int arp_main(int argc UNUSED_PARAM, char **argv)
 	/* Now see what we have to do here... */
 	if (opts & (ARP_OPT_d | ARP_OPT_s)) {
 		if (argv[0] == NULL)
-			bb_error_msg_and_die("need host name");
+			bb_simple_error_msg_and_die("need host name");
 		if (opts & ARP_OPT_s)
 			return arp_set(argv);
 		return arp_del(argv);
diff --git a/networking/arping.c b/networking/arping.c
index 901578b68..2a256aaa0 100644
--- a/networking/arping.c
+++ b/networking/arping.c
@@ -375,7 +375,7 @@ int arping_main(int argc UNUSED_PARAM, char **argv)
 			xconnect(probe_fd, (struct sockaddr *) &G.probe_saddr, sizeof(G.probe_saddr));
 			bb_getsockname(probe_fd, (struct sockaddr *) &G.probe_saddr, sizeof(G.probe_saddr));
 			if (G.probe_saddr.sin_family != AF_INET)
-				bb_error_msg_and_die("no IP address configured");
+				bb_simple_error_msg_and_die("no IP address configured");
 			src = G.probe_saddr.sin_addr;
 		}
 		close(probe_fd);
@@ -430,7 +430,7 @@ int arping_main(int argc UNUSED_PARAM, char **argv)
 		/* Don't allow SIGALRMs while we process the reply */
 		sigprocmask(SIG_BLOCK, &G.sset, NULL);
 		if (cc < 0) {
-			bb_perror_msg("recvfrom");
+			bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		recv_pack(G.packet, cc, &from);
diff --git a/networking/dnsd.c b/networking/dnsd.c
index f2c6bddc6..0ff0290fb 100644
--- a/networking/dnsd.c
+++ b/networking/dnsd.c
@@ -395,11 +395,11 @@ static int process_packet(struct dns_entry *conf_data,
 
 	head = (struct dns_head *)buf;
 	if (head->nquer == 0) {
-		bb_error_msg("packet has 0 queries, ignored");
+		bb_simple_error_msg("packet has 0 queries, ignored");
 		return 0; /* don't reply */
 	}
 	if (head->flags & htons(0x8000)) { /* QR bit */
-		bb_error_msg("response packet, ignored");
+		bb_simple_error_msg("response packet, ignored");
 		return 0; /* don't reply */
 	}
 	/* QR = 1 "response", RCODE = 4 "Not Implemented" */
@@ -474,7 +474,7 @@ static int process_packet(struct dns_entry *conf_data,
 	 * RCODE = 0 "success"
 	 */
 	if (OPT_verbose)
-		bb_info_msg("returning positive reply");
+		bb_simple_info_msg("returning positive reply");
 	outr_flags = htons(0x8000 | 0x0400 | 0);
 	/* we have one answer */
 	head->nansw = htons(1);
@@ -557,7 +557,7 @@ int dnsd_main(int argc UNUSED_PARAM, char **argv)
 			continue;
 		}
 		if (OPT_verbose)
-			bb_info_msg("got UDP packet");
+			bb_simple_info_msg("got UDP packet");
 		buf[r] = '\0'; /* paranoia */
 		r = process_packet(conf_data, conf_ttl, buf);
 		if (r <= 0)
diff --git a/networking/ether-wake.c b/networking/ether-wake.c
index acaac16f8..f45d43609 100644
--- a/networking/ether-wake.c
+++ b/networking/ether-wake.c
@@ -182,7 +182,7 @@ static int get_wol_pw(const char *ethoptarg, unsigned char *wol_passwd)
 		byte_cnt = sscanf(ethoptarg, "%u.%u.%u.%u",
 		                  &passwd[0], &passwd[1], &passwd[2], &passwd[3]);
 	if (byte_cnt < 4) {
-		bb_error_msg("can't read Wake-On-LAN pass");
+		bb_simple_error_msg("can't read Wake-On-LAN pass");
 		return 0;
 	}
 // TODO: check invalid numbers >255??
@@ -266,7 +266,7 @@ int ether_wake_main(int argc UNUSED_PARAM, char **argv)
 	/* This is necessary for broadcasts to work */
 	if (flags /* & 1 OPT_BROADCAST */) {
 		if (setsockopt_broadcast(s) != 0)
-			bb_perror_msg("SO_BROADCAST");
+			bb_simple_perror_msg("SO_BROADCAST");
 	}
 
 #if defined(PF_PACKET)
diff --git a/networking/ftpgetput.c b/networking/ftpgetput.c
index cb6910fb0..6f7f7e9ca 100644
--- a/networking/ftpgetput.c
+++ b/networking/ftpgetput.c
@@ -214,7 +214,7 @@ int ftp_receive(const char *local_path, char *server_path)
 		struct stat sbuf;
 		/* lstat would be wrong here! */
 		if (stat(local_path, &sbuf) < 0) {
-			bb_perror_msg_and_die("stat");
+			bb_simple_perror_msg_and_die("stat");
 		}
 		if (sbuf.st_size > 0) {
 			beg_range = sbuf.st_size;
diff --git a/networking/hostname.c b/networking/hostname.c
index 248d8b65a..f96daed95 100644
--- a/networking/hostname.c
+++ b/networking/hostname.c
@@ -61,7 +61,7 @@ static void do_sethostname(char *s, int isfile)
 	} else if (sethostname(s, strlen(s))) {
 //		if (errno == EPERM)
 //			bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
-		bb_perror_msg_and_die("sethostname");
+		bb_simple_perror_msg_and_die("sethostname");
 	}
 }
 
diff --git a/networking/httpd.c b/networking/httpd.c
index a0a4abc10..1757e09c9 100644
--- a/networking/httpd.c
+++ b/networking/httpd.c
@@ -1025,7 +1025,7 @@ static void log_and_exit(void)
 	*/
 
 	if (verbose > 2)
-		bb_error_msg("closed");
+		bb_simple_error_msg("closed");
 	_exit(xfunc_error_retval);
 }
 
@@ -1220,7 +1220,7 @@ static void send_headers(unsigned responseNum)
 	}
 	if (full_write(STDOUT_FILENO, iobuf, len) != len) {
 		if (verbose > 1)
-			bb_perror_msg("error");
+			bb_simple_perror_msg("error");
 		log_and_exit();
 	}
 }
@@ -1838,7 +1838,7 @@ static NOINLINE void send_file_and_exit(const char *url, int what)
 	if (count < 0) {
  IF_FEATURE_USE_SENDFILE(fin:)
 		if (verbose > 1)
-			bb_perror_msg("error");
+			bb_simple_perror_msg("error");
 	}
 	log_and_exit();
 }
@@ -2149,7 +2149,7 @@ static void handle_incoming_and_exit(const len_and_sockaddr *fromAddr)
 		if (rmt_ip_str)
 			applet_name = rmt_ip_str;
 		if (verbose > 2)
-			bb_error_msg("connected");
+			bb_simple_error_msg("connected");
 	}
 	if_ip_denied_send_HTTP_FORBIDDEN_and_exit(remote_ip);
 
@@ -2746,7 +2746,7 @@ int httpd_main(int argc UNUSED_PARAM, char **argv)
 		if (opt & OPT_SETUID) {
 			if (ugid.gid != (gid_t)-1) {
 				if (setgroups(1, &ugid.gid) == -1)
-					bb_perror_msg_and_die("setgroups");
+					bb_simple_perror_msg_and_die("setgroups");
 				xsetgid(ugid.gid);
 			}
 			xsetuid(ugid.uid);
diff --git a/networking/ifconfig.c b/networking/ifconfig.c
index 5c47abc16..b566d91a9 100644
--- a/networking/ifconfig.c
+++ b/networking/ifconfig.c
@@ -361,7 +361,7 @@ int ifconfig_main(int argc UNUSED_PARAM, char **argv)
 #if ENABLE_FEATURE_IFCONFIG_STATUS
 		return display_interfaces(argv[0] ? argv[0] : show_all_param);
 #else
-		bb_error_msg_and_die("no support for status display");
+		bb_simple_error_msg_and_die("no support for status display");
 #endif
 	}
 
diff --git a/networking/ifplugd.c b/networking/ifplugd.c
index b7b26c113..fa18edd57 100644
--- a/networking/ifplugd.c
+++ b/networking/ifplugd.c
@@ -365,7 +365,7 @@ static void up_iface(void)
 	if (!(ifrequest.ifr_flags & IFF_UP)) {
 		ifrequest.ifr_flags |= IFF_UP;
 		/* Let user know we mess up with interface */
-		bb_info_msg("upping interface");
+		bb_simple_info_msg("upping interface");
 		if (network_ioctl(SIOCSIFFLAGS, &ifrequest, "setting interface flags") < 0) {
 			if (errno != ENODEV && errno != EADDRNOTAVAIL)
 				xfunc_die();
@@ -461,7 +461,7 @@ static smallint detect_link(void)
 		else if (option_mask32 & FLAG_IGNORE_FAIL_POSITIVE)
 			status = IFSTATUS_UP;
 		else if (G.api_mode[0] == 'a')
-			bb_error_msg("can't detect link status");
+			bb_simple_error_msg("can't detect link status");
 	}
 
 	if (status != G.iface_last_status) {
@@ -493,14 +493,14 @@ static NOINLINE int check_existence_through_netlink(void)
 				goto ret;
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg("netlink: recv");
+			bb_simple_perror_msg("netlink: recv");
 			return -1;
 		}
 
 		mhdr = (struct nlmsghdr*)replybuf;
 		while (bytes > 0) {
 			if (!NLMSG_OK(mhdr, bytes)) {
-				bb_error_msg("netlink packet too small or truncated");
+				bb_simple_error_msg("netlink packet too small or truncated");
 				return -1;
 			}
 
@@ -509,7 +509,7 @@ static NOINLINE int check_existence_through_netlink(void)
 				int attr_len;
 
 				if (mhdr->nlmsg_len < NLMSG_LENGTH(sizeof(struct ifinfomsg))) {
-					bb_error_msg("netlink packet too small or truncated");
+					bb_simple_error_msg("netlink packet too small or truncated");
 					return -1;
 				}
 
@@ -591,7 +591,7 @@ int ifplugd_main(int argc UNUSED_PARAM, char **argv)
 	}
 
 	if (pid_from_pidfile > 0 && kill(pid_from_pidfile, 0) == 0)
-		bb_error_msg_and_die("daemon already running");
+		bb_simple_error_msg_and_die("daemon already running");
 #endif
 
 	api_mode_found = strchr(api_modes, G.api_mode[0]);
@@ -690,7 +690,7 @@ int ifplugd_main(int argc UNUSED_PARAM, char **argv)
 		) {
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg("poll");
+			bb_simple_perror_msg("poll");
 			goto exiting;
 		}
 
@@ -763,5 +763,5 @@ int ifplugd_main(int argc UNUSED_PARAM, char **argv)
 
  exiting:
 	remove_pidfile(pidfile_name);
-	bb_error_msg_and_die("exiting");
+	bb_simple_error_msg_and_die("exiting");
 }
diff --git a/networking/ifupdown.c b/networking/ifupdown.c
index 5327b0979..60ceb5a1f 100644
--- a/networking/ifupdown.c
+++ b/networking/ifupdown.c
@@ -665,7 +665,7 @@ static int FAST_FUNC dhcp_up(struct interface_defn_t *ifd, execfn *exec)
 		if (executable_exists(ext_dhcp_clients[i].name))
 			return execute(ext_dhcp_clients[i].startcmd, ifd, exec);
 	}
-	bb_error_msg("no dhcp clients found");
+	bb_simple_error_msg("no dhcp clients found");
 	return 0;
 }
 # elif ENABLE_UDHCPC
@@ -707,7 +707,7 @@ static int FAST_FUNC dhcp_down(struct interface_defn_t *ifd, execfn *exec)
 	}
 
 	if (!result)
-		bb_error_msg("warning: no dhcp clients found and stopped");
+		bb_simple_error_msg("warning: no dhcp clients found and stopped");
 
 	/* Sleep a bit, otherwise static_down tries to bring down interface too soon,
 	   and it may come back up because udhcpc is still shutting down */
diff --git a/networking/inetd.c b/networking/inetd.c
index da6551174..3cd2b11f0 100644
--- a/networking/inetd.c
+++ b/networking/inetd.c
@@ -504,7 +504,7 @@ static void register_rpc(servtab_t *sep)
 
 	if (bb_getsockname(sep->se_fd, (struct sockaddr *) &ir_sin, sizeof(ir_sin)) < 0) {
 //TODO: verify that such failure is even possible in Linux kernel
-		bb_perror_msg("getsockname");
+		bb_simple_perror_msg("getsockname");
 		return;
 	}
 
@@ -544,7 +544,7 @@ static void bump_nofile(void)
 	}
 
 	if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
-		bb_perror_msg("setrlimit");
+		bb_simple_perror_msg("setrlimit");
 		return;
 	}
 
@@ -599,7 +599,7 @@ static void prepare_socket_fd(servtab_t *sep)
 
 	fd = socket(sep->se_family, sep->se_socktype, 0);
 	if (fd < 0) {
-		bb_perror_msg("socket");
+		bb_simple_perror_msg("socket");
 		return;
 	}
 	setsockopt_reuseaddr(fd);
@@ -815,7 +815,7 @@ static NOINLINE servtab_t *parse_one_line(void)
 			n = bb_strtou(p, &p, 10);
 			if (n > INT_MAX) {
  bad_ver_spec:
-				bb_error_msg("bad rpc version");
+				bb_simple_error_msg("bad rpc version");
 				goto parse_err;
 			}
 			sep->se_rpcver_lo = sep->se_rpcver_hi = n;
@@ -829,7 +829,7 @@ static NOINLINE servtab_t *parse_one_line(void)
 			if (*p != '\0')
 				goto bad_ver_spec;
 #else
-			bb_error_msg("no support for rpc services");
+			bb_simple_error_msg("no support for rpc services");
 			goto parse_err;
 #endif
 		}
@@ -1235,7 +1235,7 @@ int inetd_main(int argc UNUSED_PARAM, char **argv)
 	if (argv[0])
 		config_filename = argv[0];
 	if (config_filename == NULL)
-		bb_error_msg_and_die("non-root must specify config file");
+		bb_simple_error_msg_and_die("non-root must specify config file");
 	if (!(opt & 2))
 		bb_daemonize_or_rexec(0, argv - optind);
 	else
@@ -1304,7 +1304,7 @@ int inetd_main(int argc UNUSED_PARAM, char **argv)
 		ready_fd_cnt = select(maxsock + 1, &readable, NULL, NULL, NULL);
 		if (ready_fd_cnt < 0) {
 			if (errno != EINTR) {
-				bb_perror_msg("select");
+				bb_simple_perror_msg("select");
 				sleep(1);
 			}
 			continue;
@@ -1405,7 +1405,7 @@ int inetd_main(int argc UNUSED_PARAM, char **argv)
 					pid = vfork();
 
 				if (pid < 0) { /* fork error */
-					bb_perror_msg("vfork"+1);
+					bb_simple_perror_msg("vfork"+1);
 					sleep(1);
 					restore_sigmask(&omask);
 					maybe_close(new_udp_fd);
@@ -1488,7 +1488,7 @@ int inetd_main(int argc UNUSED_PARAM, char **argv)
 			}
 			if (real_uid != 0 && real_uid != pwd->pw_uid) {
 				/* a user running private inetd */
-				bb_error_msg("non-root must run services as himself");
+				bb_simple_error_msg("non-root must run services as himself");
 				goto do_exit1;
 			}
 			if (pwd->pw_uid != real_uid) {
@@ -1502,7 +1502,7 @@ int inetd_main(int argc UNUSED_PARAM, char **argv)
 			}
 			if (rlim_ofile.rlim_cur != rlim_ofile_cur)
 				if (setrlimit(RLIMIT_NOFILE, &rlim_ofile) < 0)
-					bb_perror_msg("setrlimit");
+					bb_simple_perror_msg("setrlimit");
 
 			/* closelog(); - WRONG. we are after vfork,
 			 * this may confuse syslog() internal state.
diff --git a/networking/ipcalc.c b/networking/ipcalc.c
index 67f768836..09b146872 100644
--- a/networking/ipcalc.c
+++ b/networking/ipcalc.c
@@ -183,7 +183,7 @@ int ipcalc_main(int argc UNUSED_PARAM, char **argv)
 
 	if (argv[1]) {
 		if (ENABLE_FEATURE_IPCALC_FANCY && have_netmask) {
-			bb_error_msg_and_die("use prefix or netmask, not both");
+			bb_simple_error_msg_and_die("use prefix or netmask, not both");
 		}
 		if (inet_aton(argv[1], &s_netmask) == 0) {
 			bb_error_msg_and_die("bad netmask: %s", argv[1]);
diff --git a/networking/isrv.c b/networking/isrv.c
index 97f5c6d4e..0e3f10f9a 100644
--- a/networking/isrv.c
+++ b/networking/isrv.c
@@ -185,7 +185,7 @@ static void handle_accept(isrv_state_t *state, int fd)
 		/* Most probably someone gave us wrong fd type
 		 * (for example, non-socket). Don't want
 		 * to loop forever. */
-		bb_perror_msg_and_die("accept");
+		bb_simple_perror_msg_and_die("accept");
 	}
 
 	DPRINTF("new_peer(%d)", newfd);
@@ -311,7 +311,7 @@ void isrv_run(
 
 		if (n < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("select");
+				bb_simple_perror_msg("select");
 			continue;
 		}
 
diff --git a/networking/libiproute/ipaddress.c b/networking/libiproute/ipaddress.c
index 7b7e0154b..86cf3beea 100644
--- a/networking/libiproute/ipaddress.c
+++ b/networking/libiproute/ipaddress.c
@@ -119,7 +119,7 @@ static NOINLINE int print_linkinfo(const struct nlmsghdr *n)
 	//memset(tb, 0, sizeof(tb)); - parse_rtattr does this
 	parse_rtattr(tb, IFLA_MAX, IFLA_RTA(ifi), len);
 	if (tb[IFLA_IFNAME] == NULL) {
-		bb_error_msg("nil ifname");
+		bb_simple_error_msg("nil ifname");
 		return -1;
 	}
 	if (G_filter.label
@@ -205,7 +205,7 @@ static NOINLINE int print_linkinfo(const struct nlmsghdr *n)
 static int flush_update(void)
 {
 	if (rtnl_send_check(G_filter.rth, G_filter.flushb, G_filter.flushp) < 0) {
-		bb_perror_msg("can't send flush request");
+		bb_simple_perror_msg("can't send flush request");
 		return -1;
 	}
 	G_filter.flushp = 0;
@@ -439,7 +439,7 @@ int FAST_FUNC ipaddr_list_or_flush(char **argv, int flush)
 			bb_error_msg_and_die(bb_msg_requires_arg, "flush");
 		}
 		if (G_filter.family == AF_PACKET) {
-			bb_error_msg_and_die("can't flush link addresses");
+			bb_simple_error_msg_and_die("can't flush link addresses");
 		}
 	}
 
@@ -700,7 +700,7 @@ static int ipaddr_modify(int cmd, int flags, char **argv)
 
 	if (!d) {
 		/* There was no "dev IFACE", but we need that */
-		bb_error_msg_and_die("need \"dev IFACE\"");
+		bb_simple_error_msg_and_die("need \"dev IFACE\"");
 	}
 	if (l && !is_prefixed_with(l, d)) {
 		bb_error_msg_and_die("\"dev\" (%s) must match \"label\" (%s)", d, l);
@@ -717,7 +717,7 @@ static int ipaddr_modify(int cmd, int flags, char **argv)
 		inet_prefix brd;
 		int i;
 		if (req.ifa.ifa_family != AF_INET) {
-			bb_error_msg_and_die("broadcast can be set only for IPv4 addresses");
+			bb_simple_error_msg_and_die("broadcast can be set only for IPv4 addresses");
 		}
 		brd = peer;
 		if (brd.bitlen <= 30) {
diff --git a/networking/libiproute/ipneigh.c b/networking/libiproute/ipneigh.c
index 984dd4bdd..b9b4f4b31 100644
--- a/networking/libiproute/ipneigh.c
+++ b/networking/libiproute/ipneigh.c
@@ -49,7 +49,7 @@ typedef struct filter_t filter_t;
 static int flush_update(void)
 {
 	if (rtnl_send_check(G_filter.rth, G_filter.flushb, G_filter.flushp) < 0) {
-		bb_perror_msg("can't send flush request");
+		bb_simple_perror_msg("can't send flush request");
 		return -1;
 	}
 	G_filter.flushp = 0;
@@ -305,7 +305,7 @@ static int FAST_FUNC ipneigh_list_or_flush(char **argv, int flush)
 			xrtnl_wilddump_request(&rth, G_filter.family, RTM_GETNEIGH);
 			G_filter.flushed = 0;
 			if (xrtnl_dump_filter(&rth, print_neigh, NULL) < 0) {
-				bb_perror_msg_and_die("flush terminated");
+				bb_simple_perror_msg_and_die("flush terminated");
 			}
 			if (G_filter.flushed == 0) {
 				if (round == 0)
@@ -325,11 +325,11 @@ static int FAST_FUNC ipneigh_list_or_flush(char **argv, int flush)
 	ndm.ndm_family = G_filter.family;
 
 	if (rtnl_dump_request(&rth, RTM_GETNEIGH, &ndm, sizeof(struct ndmsg)) < 0) {
-		bb_perror_msg_and_die("can't send dump request");
+		bb_simple_perror_msg_and_die("can't send dump request");
 	}
 
 	if (xrtnl_dump_filter(&rth, print_neigh, NULL) < 0) {
-		bb_error_msg_and_die("dump terminated");
+		bb_simple_error_msg_and_die("dump terminated");
 	}
 
 	return 0;
diff --git a/networking/libiproute/iproute.c b/networking/libiproute/iproute.c
index b11078ed5..5a972f8b2 100644
--- a/networking/libiproute/iproute.c
+++ b/networking/libiproute/iproute.c
@@ -57,7 +57,7 @@ typedef struct filter_t filter_t;
 static int flush_update(void)
 {
 	if (rtnl_send_check(G_filter.rth, G_filter.flushb, G_filter.flushp) < 0) {
-		bb_perror_msg("can't send flush request");
+		bb_simple_perror_msg("can't send flush request");
 		return -1;
 	}
 	G_filter.flushp = 0;
@@ -756,7 +756,7 @@ static void iproute_flush_cache(void)
 	}
 
 	if (write(flush_fd, "-1", 2) < 2) {
-		bb_perror_msg("can't flush routing cache");
+		bb_simple_perror_msg("can't flush routing cache");
 		return;
 	}
 	close(flush_fd);
@@ -948,7 +948,7 @@ static int iproute_list_or_flush(char **argv, int flush)
 	if (G_filter.tb != -1) {
 		xrtnl_wilddump_request(&rth, do_ipv6, RTM_GETROUTE);
 	} else if (rtnl_rtcache_request(&rth, do_ipv6) < 0) {
-		bb_perror_msg_and_die("can't send dump request");
+		bb_simple_perror_msg_and_die("can't send dump request");
 	}
 	xrtnl_dump_filter(&rth, print_route, NULL);
 
@@ -1041,7 +1041,7 @@ static int iproute_get(char **argv)
 	}
 
 	if (req.r.rtm_dst_len == 0) {
-		bb_error_msg_and_die("need at least destination address");
+		bb_simple_error_msg_and_die("need at least destination address");
 	}
 
 	xrtnl_open(&rth);
@@ -1077,7 +1077,7 @@ static int iproute_get(char **argv)
 		print_route(NULL, &req.n, NULL);
 
 		if (req.n.nlmsg_type != RTM_NEWROUTE) {
-			bb_error_msg_and_die("not a route?");
+			bb_simple_error_msg_and_die("not a route?");
 		}
 		len -= NLMSG_LENGTH(sizeof(*r));
 		if (len < 0) {
@@ -1091,7 +1091,7 @@ static int iproute_get(char **argv)
 			tb[RTA_PREFSRC]->rta_type = RTA_SRC;
 			r->rtm_src_len = 8*RTA_PAYLOAD(tb[RTA_PREFSRC]);
 		} else if (!tb[RTA_SRC]) {
-			bb_error_msg_and_die("can't connect the route");
+			bb_simple_error_msg_and_die("can't connect the route");
 		}
 		if (!odev && tb[RTA_OIF]) {
 			tb[RTA_OIF]->rta_type = 0;
diff --git a/networking/libiproute/iptunnel.c b/networking/libiproute/iptunnel.c
index 4002feb78..c9fa632f3 100644
--- a/networking/libiproute/iptunnel.c
+++ b/networking/libiproute/iptunnel.c
@@ -338,7 +338,7 @@ static void parse_args(char **argv, int cmd, struct ip_tunnel_parm *p)
 
 	if (p->iph.protocol == IPPROTO_IPIP || p->iph.protocol == IPPROTO_IPV6) {
 		if ((p->i_flags & GRE_KEY) || (p->o_flags & GRE_KEY)) {
-			bb_error_msg_and_die("keys are not allowed with ipip and sit");
+			bb_simple_error_msg_and_die("keys are not allowed with ipip and sit");
 		}
 	}
 
@@ -355,7 +355,7 @@ static void parse_args(char **argv, int cmd, struct ip_tunnel_parm *p)
 		p->o_flags |= GRE_KEY;
 	}
 	if (IN_MULTICAST(ntohl(p->iph.daddr)) && !p->iph.saddr) {
-		bb_error_msg_and_die("broadcast tunnel requires a source address");
+		bb_simple_error_msg_and_die("broadcast tunnel requires a source address");
 	}
 }
 
@@ -367,7 +367,7 @@ static int do_add(int cmd, char **argv)
 	parse_args(argv, cmd, &p);
 
 	if (p.iph.ttl && p.iph.frag_off == 0) {
-		bb_error_msg_and_die("ttl != 0 and noptmudisc are incompatible");
+		bb_simple_error_msg_and_die("ttl != 0 and noptmudisc are incompatible");
 	}
 
 	switch (p.iph.protocol) {
@@ -378,7 +378,7 @@ static int do_add(int cmd, char **argv)
 	case IPPROTO_IPV6:
 		return do_add_ioctl(cmd, "sit0", &p);
 	default:
-		bb_error_msg_and_die("can't determine tunnel mode (ipip, gre or sit)");
+		bb_simple_error_msg_and_die("can't determine tunnel mode (ipip, gre or sit)");
 	}
 }
 
@@ -485,7 +485,7 @@ static void do_tunnels_list(struct ip_tunnel_parm *p)
 		if (ptr == NULL ||
 		    (*ptr++ = 0, sscanf(buf, "%s", name) != 1)
 		) {
-			bb_error_msg("wrong format of /proc/net/dev");
+			bb_simple_error_msg("wrong format of /proc/net/dev");
 			return;
 		}
 		if (sscanf(ptr, "%lu%lu%lu%lu%lu%lu%lu%*d%lu%lu%lu%lu%lu%lu%lu",
diff --git a/networking/libiproute/libnetlink.c b/networking/libiproute/libnetlink.c
index b0d4166ac..7e3473a1c 100644
--- a/networking/libiproute/libnetlink.c
+++ b/networking/libiproute/libnetlink.c
@@ -79,7 +79,7 @@ int FAST_FUNC rtnl_send_check(struct rtnl_handle *rth, const void *buf, int len)
 		if (h->nlmsg_type == NLMSG_ERROR) {
 			struct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);
 			if (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr)))
-				bb_error_msg("ERROR truncated");
+				bb_simple_error_msg("ERROR truncated");
 			else
 				errno = -err->error;
 			return -1;
@@ -149,11 +149,11 @@ static int rtnl_dump_filter(struct rtnl_handle *rth,
 		if (status < 0) {
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg("OVERRUN");
+			bb_simple_perror_msg("OVERRUN");
 			continue;
 		}
 		if (status == 0) {
-			bb_error_msg("EOF on netlink");
+			bb_simple_error_msg("EOF on netlink");
 			goto ret;
 		}
 		if (msg.msg_namelen != sizeof(nladdr)) {
@@ -184,10 +184,10 @@ static int rtnl_dump_filter(struct rtnl_handle *rth,
 			if (h->nlmsg_type == NLMSG_ERROR) {
 				struct nlmsgerr *l_err = (struct nlmsgerr*)NLMSG_DATA(h);
 				if (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {
-					bb_error_msg("ERROR truncated");
+					bb_simple_error_msg("ERROR truncated");
 				} else {
 					errno = -l_err->error;
-					bb_perror_msg("RTNETLINK answers");
+					bb_simple_perror_msg("RTNETLINK answers");
 				}
 				goto ret;
 			}
@@ -201,7 +201,7 @@ static int rtnl_dump_filter(struct rtnl_handle *rth,
 			h = NLMSG_NEXT(h, status);
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
-			bb_error_msg("message truncated");
+			bb_simple_error_msg("message truncated");
 			continue;
 		}
 		if (status) {
@@ -221,7 +221,7 @@ int FAST_FUNC xrtnl_dump_filter(struct rtnl_handle *rth,
 {
 	int ret = rtnl_dump_filter(rth, filter, arg1/*, NULL, NULL*/);
 	if (ret < 0)
-		bb_error_msg_and_die("dump terminated");
+		bb_simple_error_msg_and_die("dump terminated");
 	return ret;
 }
 
@@ -266,7 +266,7 @@ int FAST_FUNC rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n,
 	status = sendmsg(rtnl->fd, &msg, 0);
 
 	if (status < 0) {
-		bb_perror_msg("can't talk to rtnetlink");
+		bb_simple_perror_msg("can't talk to rtnetlink");
 		goto ret;
 	}
 
@@ -280,11 +280,11 @@ int FAST_FUNC rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n,
 			if (errno == EINTR) {
 				continue;
 			}
-			bb_perror_msg("OVERRUN");
+			bb_simple_perror_msg("OVERRUN");
 			continue;
 		}
 		if (status == 0) {
-			bb_error_msg("EOF on netlink");
+			bb_simple_error_msg("EOF on netlink");
 			goto ret;
 		}
 		if (msg.msg_namelen != sizeof(nladdr)) {
@@ -297,7 +297,7 @@ int FAST_FUNC rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n,
 
 			if (l < 0 || len > status) {
 				if (msg.msg_flags & MSG_TRUNC) {
-					bb_error_msg("truncated message");
+					bb_simple_error_msg("truncated message");
 					goto ret;
 				}
 				bb_error_msg_and_die("malformed message: len=%d!", len);
@@ -320,7 +320,7 @@ int FAST_FUNC rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n,
 			if (h->nlmsg_type == NLMSG_ERROR) {
 				struct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);
 				if (l < (int)sizeof(struct nlmsgerr)) {
-					bb_error_msg("ERROR truncated");
+					bb_simple_error_msg("ERROR truncated");
 				} else {
 					errno = - err->error;
 					if (errno == 0) {
@@ -329,7 +329,7 @@ int FAST_FUNC rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n,
 						}
 						goto ret_0;
 					}
-					bb_perror_msg("RTNETLINK answers");
+					bb_simple_perror_msg("RTNETLINK answers");
 				}
 				goto ret;
 			}
@@ -338,13 +338,13 @@ int FAST_FUNC rtnl_talk(struct rtnl_handle *rtnl, struct nlmsghdr *n,
 				goto ret_0;
 			}
 
-			bb_error_msg("unexpected reply!");
+			bb_simple_error_msg("unexpected reply!");
 
 			status -= NLMSG_ALIGN(len);
 			h = (struct nlmsghdr*)((char*)h + NLMSG_ALIGN(len));
 		}
 		if (msg.msg_flags & MSG_TRUNC) {
-			bb_error_msg("message truncated");
+			bb_simple_error_msg("message truncated");
 			continue;
 		}
 		if (status) {
diff --git a/networking/libiproute/utils.c b/networking/libiproute/utils.c
index bf053a54b..4ce230356 100644
--- a/networking/libiproute/utils.c
+++ b/networking/libiproute/utils.c
@@ -230,7 +230,7 @@ uint32_t FAST_FUNC get_addr32(char *name)
 char** FAST_FUNC next_arg(char **argv)
 {
 	if (!*++argv)
-		bb_error_msg_and_die("command line is not complete, try \"help\"");
+		bb_simple_error_msg_and_die("command line is not complete, try \"help\"");
 	return argv;
 }
 
diff --git a/networking/nbd-client.c b/networking/nbd-client.c
index 0dc8d0c43..3db3b46f9 100644
--- a/networking/nbd-client.c
+++ b/networking/nbd-client.c
@@ -179,7 +179,7 @@ int nbdclient_main(int argc, char **argv)
 		if (memcmp(&nbd_header.magic1, "NBDMAGIC",
 				sizeof(nbd_header.magic1)) != 0
 		) {
-			bb_error_msg_and_die("login failed");
+			bb_simple_error_msg_and_die("login failed");
 		}
 		if (memcmp(&nbd_header.magic2,
 				"\x00\x00\x42\x02\x81\x86\x12\x53",
@@ -189,7 +189,7 @@ int nbdclient_main(int argc, char **argv)
 		} else if (memcmp(&nbd_header.magic2, "IHAVEOPT", 8) == 0) {
 			proto_new = 1;
 		} else {
-			bb_error_msg_and_die("login failed");
+			bb_simple_error_msg_and_die("login failed");
 		}
 
 		if (!proto_new) {
@@ -240,17 +240,17 @@ int nbdclient_main(int argc, char **argv)
 		}
 
 		if (ioctl(nbd, BLKROSET, &ro) < 0) {
-			bb_perror_msg_and_die("BLKROSET");
+			bb_simple_perror_msg_and_die("BLKROSET");
 		}
 
 		if (timeout) {
 			if (ioctl(nbd, NBD_SET_TIMEOUT, (unsigned long) timeout)) {
-				bb_perror_msg_and_die("NBD_SET_TIMEOUT");
+				bb_simple_perror_msg_and_die("NBD_SET_TIMEOUT");
 			}
 		}
 
 		if (ioctl(nbd, NBD_SET_SOCK, sock)) {
-			bb_perror_msg_and_die("NBD_SET_SOCK");
+			bb_simple_perror_msg_and_die("NBD_SET_SOCK");
 		}
 
 		//if (swap) mlockall(MCL_CURRENT|MCL_FUTURE);
diff --git a/networking/nc.c b/networking/nc.c
index b208f46c6..705b7356a 100644
--- a/networking/nc.c
+++ b/networking/nc.c
@@ -112,7 +112,7 @@
 
 static void timeout(int signum UNUSED_PARAM)
 {
-	bb_error_msg_and_die("timed out");
+	bb_simple_error_msg_and_die("timed out");
 }
 
 int nc_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -211,7 +211,7 @@ int nc_main(int argc, char **argv)
  accept_again:
 			cfd = accept(sfd, NULL, 0);
 			if (cfd < 0)
-				bb_perror_msg_and_die("accept");
+				bb_simple_perror_msg_and_die("accept");
 			if (!execparam)
 				close(sfd);
 		} else {
@@ -260,7 +260,7 @@ int nc_main(int argc, char **argv)
 		int nread;
 
 		if (safe_poll(pfds, 2, -1) < 0)
-			bb_perror_msg_and_die("poll");
+			bb_simple_perror_msg_and_die("poll");
 
 		fdidx = 0;
 		while (1) {
diff --git a/networking/nc_bloaty.c b/networking/nc_bloaty.c
index 42c84de45..034e03d21 100644
--- a/networking/nc_bloaty.c
+++ b/networking/nc_bloaty.c
@@ -198,8 +198,8 @@ enum {
 #define Debug(...) do { } while (0)
 #endif
 
-#define holler_error(...)  do { if (o_verbose) bb_error_msg(__VA_ARGS__); } while (0)
-#define holler_perror(...) do { if (o_verbose) bb_perror_msg(__VA_ARGS__); } while (0)
+#define holler_error(msg)  do { if (o_verbose) bb_simple_error_msg(msg); } while (0)
+#define holler_perror(msg) do { if (o_verbose) bb_simple_perror_msg(msg); } while (0)
 
 /* catch: no-brainer interrupt handler */
 static void catch(int sig)
@@ -361,10 +361,10 @@ static void dolisten(int is_persistent, char **proggie)
 			rr = recv_from_to(netfd, NULL, 0, MSG_PEEK, /*was bigbuf_net, BIGSIZ*/
 				&remend.u.sa, &ouraddr->u.sa, ouraddr->len);
 			if (rr < 0)
-				bb_perror_msg_and_die("recvfrom");
+				bb_simple_perror_msg_and_die("recvfrom");
 			unarm();
 		} else
-			bb_error_msg_and_die("timeout");
+			bb_simple_error_msg_and_die("timeout");
 /* Now we learned *to which IP* peer has connected, and we want to anchor
 our socket on it, so that our outbound packets will have correct local IP.
 Unfortunately, bind() on already bound socket will fail now (EINVAL):
@@ -382,7 +382,7 @@ create new one, and bind() it. TODO */
 			remend.len = LSA_SIZEOF_SA;
 			rr = accept(netfd, &remend.u.sa, &remend.len);
 			if (rr < 0)
-				bb_perror_msg_and_die("accept");
+				bb_simple_perror_msg_and_die("accept");
 			if (themaddr) {
 				int sv_port, port, r;
 
@@ -409,7 +409,7 @@ create new one, and bind() it. TODO */
 			}
 			unarm();
 		} else
-			bb_error_msg_and_die("timeout");
+			bb_simple_error_msg_and_die("timeout");
 
 		if (is_persistent && proggie) {
 			/* -l -k -e PROG */
@@ -494,7 +494,7 @@ static int udptest(void)
 
 	rr = write(netfd, bigbuf_in, 1);
 	if (rr != 1)
-		bb_perror_msg("udptest first write");
+		bb_simple_perror_msg("udptest first write");
 
 	if (o_wait)
 		sleep(o_wait); // can be interrupted! while (t) nanosleep(&t)?
@@ -644,7 +644,7 @@ static int readwrite(void)
 			if (rr <= 0) {
 				if (rr < 0 && o_verbose > 1) {
 					/* nc 1.10 doesn't do this */
-					bb_perror_msg("net read");
+					bb_simple_perror_msg("net read");
 				}
 				pfds[1].fd = -1;                   /* don't poll for netfd anymore */
 				fds_open--;
@@ -869,7 +869,7 @@ int nc_main(int argc UNUSED_PARAM, char **argv)
 		/* apparently UDP can listen ON "port 0",
 		 but that's not useful */
 		if (!o_lport)
-			bb_error_msg_and_die("UDP listen needs nonzero -p port");
+			bb_simple_error_msg_and_die("UDP listen needs nonzero -p port");
 	}
 #endif
 
diff --git a/networking/netstat.c b/networking/netstat.c
index f6bcd44ba..29b891cdc 100644
--- a/networking/netstat.c
+++ b/networking/netstat.c
@@ -343,9 +343,9 @@ static void prg_cache_load(void)
 		return;
 
 	if (prg_cache_loaded == 1)
-		bb_error_msg("can't scan /proc - are you root?");
+		bb_simple_error_msg("can't scan /proc - are you root?");
 	else
-		bb_error_msg("showing only processes with your user ID");
+		bb_simple_error_msg("showing only processes with your user ID");
 }
 
 #else
diff --git a/networking/nslookup.c b/networking/nslookup.c
index 24e09d4f0..8adde14b8 100644
--- a/networking/nslookup.c
+++ b/networking/nslookup.c
@@ -549,7 +549,7 @@ static int send_queries(struct ns *ns)
 
 		recvlen = read(pfd.fd, reply, sizeof(reply));
 		if (recvlen < 0) {
-			bb_perror_msg("read");
+			bb_simple_perror_msg("read");
  next:
 			tcur = monotonic_ms();
 			continue;
diff --git a/networking/ntpd.c b/networking/ntpd.c
index d55b070c5..2700cf515 100644
--- a/networking/ntpd.c
+++ b/networking/ntpd.c
@@ -905,7 +905,7 @@ do_sendto(int fd,
 		ret = send_to_from(fd, msg, len, MSG_DONTWAIT, to, from, addrlen);
 	}
 	if (ret != len) {
-		bb_perror_msg("send failed");
+		bb_simple_perror_msg("send failed");
 		return -1;
 	}
 	return 0;
@@ -1121,7 +1121,7 @@ step_time(double offset)
 	dtime = tvc.tv_sec + (1.0e-6 * tvc.tv_usec) + offset;
 	d_to_tv(dtime, &tvn);
 	if (settimeofday(&tvn, NULL) == -1)
-		bb_perror_msg_and_die("settimeofday");
+		bb_simple_perror_msg_and_die("settimeofday");
 
 	VERB2 {
 		tval = tvc.tv_sec;
@@ -1494,7 +1494,7 @@ select_and_cluster(void)
 		/* Starting from 1 is ok here */
 		for (i = 1; i < num_survivors; i++) {
 			if (G.last_update_peer == survivor[i].p) {
-				VERB5 bb_error_msg("keeping old synced peer");
+				VERB5 bb_simple_error_msg("keeping old synced peer");
 				p = G.last_update_peer;
 				goto keep_old;
 			}
@@ -1702,7 +1702,7 @@ update_local_clock(peer_t *p)
 #else
 			set_new_values(STATE_SYNC, offset, recv_time);
 #endif
-			VERB4 bb_error_msg("transitioning to FREQ, datapoint ignored");
+			VERB4 bb_simple_error_msg("transitioning to FREQ, datapoint ignored");
 			return 0; /* "leave poll interval as is" */
 
 #if 0 /* this is dead code for now */
@@ -1796,7 +1796,7 @@ update_local_clock(peer_t *p)
 	VERB4 {
 		memset(&tmx, 0, sizeof(tmx));
 		if (adjtimex(&tmx) < 0)
-			bb_perror_msg_and_die("adjtimex");
+			bb_simple_perror_msg_and_die("adjtimex");
 		bb_error_msg("p adjtimex freq:%ld offset:%+ld status:0x%x tc:%ld",
 				tmx.freq, tmx.offset, tmx.status, tmx.constant);
 	}
@@ -1906,7 +1906,7 @@ update_local_clock(peer_t *p)
 	//tmx.maxerror = (uint32_t)((sys_rootdelay / 2 + sys_rootdisp) * 1e6);
 	rc = adjtimex(&tmx);
 	if (rc < 0)
-		bb_perror_msg_and_die("adjtimex");
+		bb_simple_perror_msg_and_die("adjtimex");
 	/* NB: here kernel returns constant == G.poll_exp, not == G.poll_exp - 4.
 	 * Not sure why. Perhaps it is normal.
 	 */
@@ -2248,7 +2248,7 @@ recv_and_process_client_pkt(void /*int fd*/)
 		if (size < 0) {
 			if (errno == EAGAIN)
 				goto bail;
-			bb_perror_msg_and_die("recv");
+			bb_simple_perror_msg_and_die("recv");
 		}
 		addr = xmalloc_sockaddr2dotted_noport(from);
 		bb_error_msg("malformed packet received from %s: size %u", addr, (int)size);
@@ -2415,7 +2415,7 @@ static NOINLINE void ntp_init(char **argv)
 	srand(getpid());
 
 	if (getuid())
-		bb_error_msg_and_die(bb_msg_you_must_be_root);
+		bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 
 	/* Set some globals */
 	G.discipline_jitter = G_precision_sec;
@@ -2491,7 +2491,7 @@ static NOINLINE void ntp_init(char **argv)
 				/* supports 'sha' and 'sha1' formats */
 				hash_type = HASH_SHA1;
 			else
-				bb_error_msg_and_die("only MD5 and SHA1 keys supported");
+				bb_simple_error_msg_and_die("only MD5 and SHA1 keys supported");
 /* man ntp.keys:
  *  MD5    The key is 1 to 16 printable characters terminated by an EOL,
  *         whitespace, or a # (which is the "start of comment" character).
@@ -2674,7 +2674,7 @@ int ntpd_main(int argc UNUSED_PARAM, char **argv)
 				if (p->p_fd == -1) {
 					/* Time to send new req */
 					if (--cnt == 0) {
-						VERB4 bb_error_msg("disabling burst mode");
+						VERB4 bb_simple_error_msg("disabling burst mode");
 						G.polladj_count = 0;
 						G.poll_exp = MINPOLL;
 					}
diff --git a/networking/ping.c b/networking/ping.c
index b534c74c7..a47342fee 100644
--- a/networking/ping.c
+++ b/networking/ping.c
@@ -184,8 +184,8 @@ create_icmp_socket(void)
 		sock = socket(AF_INET, SOCK_RAW, 1); /* 1 == ICMP */
 	if (sock < 0) {
 		if (errno == EPERM)
-			bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
-		bb_perror_msg_and_die(bb_msg_can_not_create_raw_socket);
+			bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_perror_msg_and_die(bb_msg_can_not_create_raw_socket);
 	}
 
 	xmove_fd(sock, pingsock);
@@ -235,7 +235,7 @@ static void ping4(len_and_sockaddr *lsa)
 #endif
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		if (c >= 76) {			/* ip + icmp */
@@ -280,7 +280,7 @@ static void ping6(len_and_sockaddr *lsa)
 #endif
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		if (c >= ICMP_MINLEN) {	/* icmp6_hdr */
@@ -482,7 +482,7 @@ static void sendping_tail(void (*sp)(int), int size_pkt)
 	 * it doesn't matter */
 	sz = xsendto(pingsock, G.snd_packet, size_pkt, &pingaddr.sa, sizeof(pingaddr));
 	if (sz != size_pkt)
-		bb_error_msg_and_die(bb_msg_write_error);
+		bb_simple_error_msg_and_die(bb_msg_write_error);
 
 	if (pingcount == 0 || G.ntransmitted < pingcount) {
 		/* Didn't send all pings yet - schedule next in -i SEC interval */
@@ -723,7 +723,7 @@ static void ping4(len_and_sockaddr *lsa)
 	if (source_lsa) {
 		if (setsockopt(pingsock, IPPROTO_IP, IP_MULTICAST_IF,
 				&source_lsa->u.sa, source_lsa->len))
-			bb_error_msg_and_die("can't set multicast source interface");
+			bb_simple_error_msg_and_die("can't set multicast source interface");
 		xbind(pingsock, &source_lsa->u.sa, source_lsa->len);
 	}
 
@@ -757,7 +757,7 @@ static void ping4(len_and_sockaddr *lsa)
 				(struct sockaddr *) &from, &fromlen);
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		c = unpack4(G.rcv_packet, c, &from);
@@ -838,7 +838,7 @@ static void ping6(len_and_sockaddr *lsa)
 		c = recvmsg(pingsock, &msg, 0);
 		if (c < 0) {
 			if (errno != EINTR)
-				bb_perror_msg("recvfrom");
+				bb_simple_perror_msg("recvfrom");
 			continue;
 		}
 		for (mp = CMSG_FIRSTHDR(&msg); mp; mp = CMSG_NXTHDR(&msg, mp)) {
diff --git a/networking/route.c b/networking/route.c
index ac1d94c28..a5d8d7cb9 100644
--- a/networking/route.c
+++ b/networking/route.c
@@ -336,7 +336,7 @@ static NOINLINE void INET_setroute(int action, char **args)
 		}
 		mask = ((struct sockaddr_in *) &rt->rt_dst)->sin_addr.s_addr;
 		if (mask & ~(uint32_t)mask_in_addr(*rt)) {
-			bb_error_msg_and_die("netmask and route address conflict");
+			bb_simple_error_msg_and_die("netmask and route address conflict");
 		}
 	}
 
@@ -532,7 +532,7 @@ void FAST_FUNC bb_displayroutes(int noresolve, int netstatfmt)
 			if ((r < 0) && feof(fp)) { /* EOF with no (nonspace) chars read. */
 				break;
 			}
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		}
 
 		if (!(flgs & RTF_UP)) { /* Skip interfaces that are down. */
@@ -598,7 +598,7 @@ static void INET6_displayroutes(void)
 				break;
 			}
  ERROR:
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		}
 
 		/* Do the addr6x shift-and-insert changes to ':'-delimit addresses.
diff --git a/networking/slattach.c b/networking/slattach.c
index c6feca248..659822a91 100644
--- a/networking/slattach.c
+++ b/networking/slattach.c
@@ -56,7 +56,7 @@ static int tcsetattr_serial_or_warn(struct termios *state)
 
 	ret = tcsetattr(serial_fd, TCSANOW, state);
 	if (ret != 0) {
-		bb_perror_msg("tcsetattr");
+		bb_simple_perror_msg("tcsetattr");
 		return 1; /* used as exitcode */
 	}
 	return ret; /* 0 */
@@ -159,7 +159,7 @@ int slattach_main(int argc UNUSED_PARAM, char **argv)
 
 	/* Save current tty state */
 	if (tcgetattr(serial_fd, &G.saved_state) != 0)
-		bb_perror_msg_and_die("tcgetattr");
+		bb_simple_perror_msg_and_die("tcgetattr");
 	/* Save line discipline */
 	xioctl(serial_fd, TIOCGETD, &G.saved_disc);
 
diff --git a/networking/tcpudp.c b/networking/tcpudp.c
index a0af64981..8c4afabf6 100644
--- a/networking/tcpudp.c
+++ b/networking/tcpudp.c
@@ -325,7 +325,7 @@ int tcpudpsvd_main(int argc UNUSED_PARAM, char **argv)
 	client = 0;
 	if ((getuid() == 0) && !(opts & OPT_u)) {
 		xfunc_error_retval = 100;
-		bb_error_msg_and_die(bb_msg_you_must_be_root);
+		bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 	}
 	if (opts & OPT_u)
 		if (!uidgid_get(&sslugid, ssluser, 1)) {
@@ -419,7 +419,7 @@ int tcpudpsvd_main(int argc UNUSED_PARAM, char **argv)
 	sig_block(SIGCHLD);
 	if (conn < 0) {
 		if (errno != EINTR)
-			bb_perror_msg(tcp ? "accept" : "recv");
+			bb_simple_perror_msg(tcp ? "accept" : "recv");
 		goto again2;
 	}
 	xmove_fd(tcp ? conn : sock, 0);
@@ -484,7 +484,7 @@ int tcpudpsvd_main(int argc UNUSED_PARAM, char **argv)
 
 	pid = vfork();
 	if (pid == -1) {
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
 		goto again;
 	}
 
diff --git a/networking/telnetd.c b/networking/telnetd.c
index 6abecbde2..29f805de7 100644
--- a/networking/telnetd.c
+++ b/networking/telnetd.c
@@ -495,7 +495,7 @@ make_new_session(
 		free(ts);
 		close(fd);
 		/* sock will be closed by caller */
-		bb_perror_msg("vfork");
+		bb_simple_perror_msg("vfork");
 		return NULL;
 	}
 	if (pid > 0) {
diff --git a/networking/tftp.c b/networking/tftp.c
index d551c861f..04bfe844f 100644
--- a/networking/tftp.c
+++ b/networking/tftp.c
@@ -453,7 +453,7 @@ static int tftp_protocol(
 		/* fill in packet if the filename fits into xbuf */
 		len = strlen(remote_file) + 1;
 		if (2 + len + sizeof("octet") >= io_bufsize) {
-			bb_error_msg("remote filename is too long");
+			bb_simple_error_msg("remote filename is too long");
 			goto ret;
 		}
 		strcpy(cp, remote_file);
@@ -468,7 +468,7 @@ static int tftp_protocol(
 
 		/* Need to add option to pkt */
 		if ((&xbuf[io_bufsize - 1] - cp) < sizeof("blksize NNNNN tsize ") + sizeof(off_t)*3) {
-			bb_error_msg("remote filename is too long");
+			bb_simple_error_msg("remote filename is too long");
 			goto ret;
 		}
 		expect_OACK = 1;
@@ -569,7 +569,7 @@ static int tftp_protocol(
 			retries--;
 			if (retries == 0) {
 				tftp_progress_done();
-				bb_error_msg("timeout");
+				bb_simple_error_msg("timeout");
 				goto ret; /* no err packet sent */
 			}
 
@@ -674,7 +674,7 @@ static int tftp_protocol(
 			 * must be ignored by the client and server
 			 * as if it were never requested." */
 			if (blksize != TFTP_BLKSIZE_DEFAULT)
-				bb_error_msg("falling back to blocksize "TFTP_BLKSIZE_DEFAULT_STR);
+				bb_simple_error_msg("falling back to blocksize "TFTP_BLKSIZE_DEFAULT_STR);
 			blksize = TFTP_BLKSIZE_DEFAULT;
 			io_bufsize = TFTP_BLKSIZE_DEFAULT + 4;
 		}
@@ -739,7 +739,7 @@ static int tftp_protocol(
 	strcpy(G_error_pkt_str, bb_msg_read_error);
  send_err_pkt:
 	if (G_error_pkt_str[0])
-		bb_error_msg("%s", G_error_pkt_str);
+		bb_simple_error_msg(G_error_pkt_str);
 	G.error_pkt[1] = TFTP_ERROR;
 	xsendto(socket_fd, G.error_pkt, 4 + 1 + strlen(G_error_pkt_str),
 			&peer_lsa->u.sa, peer_lsa->len);
diff --git a/networking/tls.c b/networking/tls.c
index db7be07f3..854937302 100644
--- a/networking/tls.c
+++ b/networking/tls.c
@@ -446,7 +446,7 @@ static void hmac_begin(hmac_precomputed_t *pre, uint8_t *key, unsigned key_size,
 	// than INSIZE bytes will first hash the key using H and then use the
 	// resultant OUTSIZE byte string as the actual key to HMAC."
 	if (key_size > SHA_INSIZE) {
-		bb_error_msg_and_die("HMAC key>64"); //does not happen (yet?)
+		bb_simple_error_msg_and_die("HMAC key>64"); //does not happen (yet?)
 //		md5sha_ctx_t ctx;
 //		begin(&ctx);
 //		md5sha_hash(&ctx, key, key_size);
@@ -1132,7 +1132,7 @@ static int tls_xread_record(tls_state_t *tls, const char *expected)
 		}
 	}
 	if (sz < 0)
-		bb_error_msg_and_die("encrypted data too short");
+		bb_simple_error_msg_and_die("encrypted data too short");
 
 	//dump_hex("<< %s\n", tls->inbuf, RECHDR_LEN + sz);
 
@@ -1411,7 +1411,7 @@ static void find_key_in_der_cert(tls_state_t *tls, uint8_t *der, int len)
 			dbg("ECDSA key\n");
 			//UNUSED: tls->flags |= GOT_CERT_ECDSA_KEY_ALG;
 		} else
-			bb_error_msg_and_die("not RSA or ECDSA cert");
+			bb_simple_error_msg_and_die("not RSA or ECDSA cert");
 	}
 
 	if (tls->flags & GOT_CERT_RSA_KEY_ALG) {
@@ -1882,7 +1882,7 @@ static void process_server_key(tls_state_t *tls, int len)
 	/* So far we only support curve_x25519 */
 	move_from_unaligned32(t32, keybuf);
 	if (t32 != htonl(0x03001d20))
-		bb_error_msg_and_die("elliptic curve is not x25519");
+		bb_simple_error_msg_and_die("elliptic curve is not x25519");
 
 	memcpy(tls->hsd->ecc_pub_key32, keybuf + 4, 32);
 	tls->flags |= GOT_EC_KEY;
@@ -1929,7 +1929,7 @@ static void send_client_key_exchange(tls_state_t *tls)
 	if (!(tls->flags & NEED_EC_KEY)) {
 		/* RSA */
 		if (!(tls->flags & GOT_CERT_RSA_KEY_ALG))
-			bb_error_msg("server cert is not RSA");
+			bb_simple_error_msg("server cert is not RSA");
 
 		tls_get_random(rsa_premaster, sizeof(rsa_premaster));
 		if (TLS_DEBUG_FIXED_SECRETS)
@@ -1959,7 +1959,7 @@ static void send_client_key_exchange(tls_state_t *tls)
 		uint8_t privkey[CURVE25519_KEYSIZE]; //[32]
 
 		if (!(tls->flags & GOT_EC_KEY))
-			bb_error_msg("server did not provide EC key");
+			bb_simple_error_msg("server did not provide EC key");
 
 		/* Generate random private key, see RFC 7748 */
 		tls_get_random(privkey, sizeof(privkey));
@@ -2322,7 +2322,7 @@ void FAST_FUNC tls_run_copy_loop(tls_state_t *tls, unsigned flags)
 		int nread;
 
 		if (safe_poll(pfds, 2, -1) < 0)
-			bb_perror_msg_and_die("poll");
+			bb_simple_perror_msg_and_die("poll");
 
 		if (pfds[0].revents) {
 			void *buf;
diff --git a/networking/tls.h b/networking/tls.h
index 494ed78c4..d4ac1bef8 100644
--- a/networking/tls.h
+++ b/networking/tls.h
@@ -90,7 +90,7 @@ void xorbuf_aligned_AES_BLOCK_SIZE(void* buf, const void* mask) FAST_FUNC;
 #define matrixCryptoGetPrngData(buf, len, userPtr) (tls_get_random(buf, len), PS_SUCCESS)
 
 #define psFree(p, pool)    free(p)
-#define psTraceCrypto(...) bb_error_msg_and_die(__VA_ARGS__)
+#define psTraceCrypto(msg) bb_simple_error_msg_and_die(msg)
 
 /* Secure zerofill */
 #define memset_s(A,B,C,D) memset((A),(C),(D))
diff --git a/networking/traceroute.c b/networking/traceroute.c
index bdf451186..0435d6ba6 100644
--- a/networking/traceroute.c
+++ b/networking/traceroute.c
@@ -875,7 +875,7 @@ common_traceroute_main(int op, char **argv)
 		 * probe (e.g., on a multi-homed host).
 		 */
 		if (getuid() != 0)
-			bb_error_msg_and_die(bb_msg_you_must_be_root);
+			bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 	}
 	if (op & OPT_WAITTIME)
 		waittime = xatou_range(waittime_str, 1, 24 * 60 * 60);
@@ -1003,7 +1003,7 @@ common_traceroute_main(int op, char **argv)
 		if (af == AF_INET)
 			if (setsockopt(sndsock, IPPROTO_IP, IP_MULTICAST_IF,
 					&source_lsa->u.sa, source_lsa->len))
-				bb_error_msg_and_die("can't set multicast source interface");
+				bb_simple_error_msg_and_die("can't set multicast source interface");
 //TODO: we can query source port we bound to,
 // and check it in replies... if we care enough
 		xbind(sndsock, &source_lsa->u.sa, source_lsa->len);
@@ -1025,7 +1025,7 @@ common_traceroute_main(int op, char **argv)
 		/* read IP and port */
 		source_lsa = get_sock_lsa(probe_fd);
 		if (source_lsa == NULL)
-			bb_error_msg_and_die("can't get probe addr");
+			bb_simple_error_msg_and_die("can't get probe addr");
 
 		close(probe_fd);
 
diff --git a/networking/udhcp/arpping.c b/networking/udhcp/arpping.c
index 215d023ce..a395e838d 100644
--- a/networking/udhcp/arpping.c
+++ b/networking/udhcp/arpping.c
@@ -53,12 +53,12 @@ int FAST_FUNC arpping(uint32_t test_nip,
 
 	s = socket(PF_PACKET, SOCK_PACKET, htons(ETH_P_ARP));
 	if (s == -1) {
-		bb_perror_msg(bb_msg_can_not_create_raw_socket);
+		bb_simple_perror_msg(bb_msg_can_not_create_raw_socket);
 		return -1;
 	}
 
 	if (setsockopt_broadcast(s) == -1) {
-		bb_perror_msg("can't enable bcast on raw socket");
+		bb_simple_perror_msg("can't enable bcast on raw socket");
 		goto ret;
 	}
 
diff --git a/networking/udhcp/common.c b/networking/udhcp/common.c
index 62ad248ce..4a452cdb9 100644
--- a/networking/udhcp/common.c
+++ b/networking/udhcp/common.c
@@ -240,7 +240,7 @@ uint8_t* FAST_FUNC udhcp_get_option(struct dhcp_packet *packet, int code)
 	while (1) {
 		if (rem <= 0) {
  complain:
-			bb_error_msg("bad packet, malformed option field");
+			bb_simple_error_msg("bad packet, malformed option field");
 			return NULL;
 		}
 
diff --git a/networking/udhcp/common.h b/networking/udhcp/common.h
index bba3d6037..60255eefa 100644
--- a/networking/udhcp/common.h
+++ b/networking/udhcp/common.h
@@ -267,26 +267,45 @@ struct option_set *udhcp_find_option(struct option_set *opt_list, uint8_t code)
 # define IF_UDHCP_VERBOSE(...) __VA_ARGS__
 extern unsigned dhcp_verbose;
 # define log1(...) do { if (dhcp_verbose >= 1) bb_info_msg(__VA_ARGS__); } while (0)
+# define log1s(msg) do { if (dhcp_verbose >= 1) bb_simple_info_msg(msg); } while (0)
 # if CONFIG_UDHCP_DEBUG >= 2
 void udhcp_dump_packet(struct dhcp_packet *packet) FAST_FUNC;
 #  define log2(...) do { if (dhcp_verbose >= 2) bb_info_msg(__VA_ARGS__); } while (0)
+#  define log2s(msg) do { if (dhcp_verbose >= 2) bb_simple_info_msg(msg); } while (0)
 # else
 #  define udhcp_dump_packet(...) ((void)0)
 #  define log2(...) ((void)0)
+#  define log2s(msg) ((void)0)
 # endif
 # if CONFIG_UDHCP_DEBUG >= 3
 #  define log3(...) do { if (dhcp_verbose >= 3) bb_info_msg(__VA_ARGS__); } while (0)
+#  define log3s(msg) do { if (dhcp_verbose >= 3) bb_simple_info_msg(msg); } while (0)
 # else
 #  define log3(...) ((void)0)
+#  define log3s(msg) ((void)0)
 # endif
 #else
 # define IF_UDHCP_VERBOSE(...)
 # define udhcp_dump_packet(...) ((void)0)
 # define log1(...) ((void)0)
+# define log1s(msg) ((void)0)
 # define log2(...) ((void)0)
+# define log2s(msg) ((void)0)
 # define log3(...) ((void)0)
+# define log3s(msg) ((void)0)
 #endif
 
+#if defined(__mips__)
+/*
+ * The 'simple' message functions have a negative impact on the size of the
+ * DHCP code when compiled for MIPS, so don't use them in this case.
+ */
+#define bb_simple_info_msg bb_info_msg
+#define bb_simple_error_msg bb_error_msg
+#define bb_simple_perror_msg_and_die bb_perror_msg_and_die
+#undef log1s
+#define log1s log1
+#endif
 
 /*** Other shared functions ***/
 
diff --git a/networking/udhcp/d6_dhcpc.c b/networking/udhcp/d6_dhcpc.c
index 4eb7ae1c1..9d8e17c51 100644
--- a/networking/udhcp/d6_dhcpc.c
+++ b/networking/udhcp/d6_dhcpc.c
@@ -235,7 +235,7 @@ static char *string_option_to_env(const uint8_t *option,
  found:
 	val_len = (option[2] << 8) | option[3];
 	if (val_len + &option[D6_OPT_DATA] > option_end) {
-		bb_error_msg("option data exceeds option length");
+		bb_simple_error_msg("option data exceeds option length");
 		return NULL;
 	}
 	return xasprintf("%s=%.*s", name, val_len, (char*)option + 4);
@@ -848,19 +848,19 @@ static NOINLINE int d6_recv_raw_packet(struct in6_addr *peer_ipv6, struct d6_pac
 
 	bytes = safe_read(fd, &packet, sizeof(packet));
 	if (bytes < 0) {
-		log1("packet read error, ignoring");
+		log1s("packet read error, ignoring");
 		/* NB: possible down interface, etc. Caller should pause. */
 		return bytes; /* returns -1 */
 	}
 
 	if (bytes < (int) (sizeof(packet.ip6) + sizeof(packet.udp))) {
-		log1("packet is too short, ignoring");
+		log1s("packet is too short, ignoring");
 		return -2;
 	}
 
 	if (bytes < sizeof(packet.ip6) + ntohs(packet.ip6.ip6_plen)) {
 		/* packet is bigger than sizeof(packet), we did partial read */
-		log1("oversized packet, ignoring");
+		log1s("oversized packet, ignoring");
 		return -2;
 	}
 
@@ -874,7 +874,7 @@ static NOINLINE int d6_recv_raw_packet(struct in6_addr *peer_ipv6, struct d6_pac
 	/* || bytes > (int) sizeof(packet) - can't happen */
 	 || packet.udp.len != packet.ip6.ip6_plen
 	) {
-		log1("unrelated/bogus packet, ignoring");
+		log1s("unrelated/bogus packet, ignoring");
 		return -2;
 	}
 
@@ -1003,7 +1003,7 @@ static int d6_raw_socket(int ifindex)
 	}
 #endif
 
-	log1("created raw socket");
+	log1s("created raw socket");
 
 	return fd;
 }
@@ -1031,7 +1031,7 @@ static void change_listen_mode(int new_mode)
 /* Called only on SIGUSR1 */
 static void perform_renew(void)
 {
-	bb_info_msg("performing DHCP renew");
+	bb_simple_info_msg("performing DHCP renew");
 	switch (client_data.state) {
 	case BOUND:
 		change_listen_mode(LISTEN_KERNEL);
@@ -1059,10 +1059,10 @@ static void perform_d6_release(struct in6_addr *server_ipv6, struct in6_addr *ou
 	 || client_data.state == REBINDING
 	 || client_data.state == RENEW_REQUESTED
 	) {
-		bb_info_msg("unicasting a release");
+		bb_simple_info_msg("unicasting a release");
 		send_d6_release(server_ipv6, our_cur_ipv6); /* unicast */
 	}
-	bb_info_msg("entering released state");
+	bb_simple_info_msg("entering released state");
 /*
  * We can be here on: SIGUSR2,
  * or on exit (SIGTERM) and -R "release on quit" is specified.
@@ -1275,7 +1275,7 @@ int udhcpc6_main(int argc UNUSED_PARAM, char **argv)
 	/* Create pidfile */
 	write_pidfile(client_data.pidfile);
 	/* Goes to stdout (unless NOMMU) and possibly syslog */
-	bb_info_msg("started, v"BB_VER);
+	bb_simple_info_msg("started, v"BB_VER);
 
 	client_data.state = INIT_SELECTING;
 	d6_run_script_no_option("deconfig");
@@ -1321,7 +1321,7 @@ int udhcpc6_main(int argc UNUSED_PARAM, char **argv)
 					continue;
 				}
 				/* Else: an error occured, panic! */
-				bb_perror_msg_and_die("poll");
+				bb_simple_perror_msg_and_die("poll");
 			}
 		}
 
@@ -1362,7 +1362,7 @@ int udhcpc6_main(int argc UNUSED_PARAM, char **argv)
 				d6_run_script_no_option("leasefail");
 #if BB_MMU /* -b is not supported on NOMMU */
 				if (opt & OPT_b) { /* background if no lease */
-					bb_info_msg("no lease, forking to background");
+					bb_simple_info_msg("no lease, forking to background");
 					client_background();
 					/* do not background again! */
 					opt = ((opt & ~(OPT_b|OPT_n)) | OPT_f);
@@ -1375,7 +1375,7 @@ int udhcpc6_main(int argc UNUSED_PARAM, char **argv)
 				} else
 #endif
 				if (opt & OPT_n) { /* abort if no lease */
-					bb_info_msg("no lease, failing");
+					bb_simple_info_msg("no lease, failing");
 					retval = 1;
 					goto ret;
 				}
@@ -1403,7 +1403,7 @@ int udhcpc6_main(int argc UNUSED_PARAM, char **argv)
 				client_data.state = RENEWING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
 				change_listen_mode(LISTEN_KERNEL);
-				log1("entering renew state");
+				log1s("entering renew state");
 				/* fall right through */
 			case RENEW_REQUESTED: /* manual (SIGUSR1) renew */
 			case_RENEW_REQUESTED:
@@ -1423,7 +1423,7 @@ int udhcpc6_main(int argc UNUSED_PARAM, char **argv)
 					continue;
 				}
 				/* Timed out, enter rebinding state */
-				log1("entering rebinding state");
+				log1s("entering rebinding state");
 				client_data.state = REBINDING;
 				/* fall right through */
 			case REBINDING:
@@ -1438,7 +1438,7 @@ int udhcpc6_main(int argc UNUSED_PARAM, char **argv)
 					continue;
 				}
 				/* Timed out, enter init state */
-				bb_info_msg("lease lost, entering init state");
+				bb_simple_info_msg("lease lost, entering init state");
 				d6_run_script_no_option("deconfig");
 				client_data.state = INIT_SELECTING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
@@ -1560,7 +1560,7 @@ int udhcpc6_main(int argc UNUSED_PARAM, char **argv)
 				}
 				option = d6_copy_option(packet.d6_options, packet_end, D6_OPT_SERVERID);
 				if (!option) {
-					bb_info_msg("no server ID, ignoring packet");
+					bb_simple_info_msg("no server ID, ignoring packet");
 					continue;
 					/* still selecting - this server looks bad */
 				}
diff --git a/networking/udhcp/d6_packet.c b/networking/udhcp/d6_packet.c
index 01d1c930b..446497e15 100644
--- a/networking/udhcp/d6_packet.c
+++ b/networking/udhcp/d6_packet.c
@@ -35,12 +35,12 @@ int FAST_FUNC d6_recv_kernel_packet(struct in6_addr *peer_ipv6
 	memset(packet, 0, sizeof(*packet));
 	bytes = safe_read(fd, packet, sizeof(*packet));
 	if (bytes < 0) {
-		log1("packet read error, ignoring");
+		log1s("packet read error, ignoring");
 		return bytes; /* returns -1 */
 	}
 
 	if (bytes < offsetof(struct d6_packet, d6_options)) {
-		bb_info_msg("packet with bad magic, ignoring");
+		bb_simple_info_msg("packet with bad magic, ignoring");
 		return -2;
 	}
 	log1("received %s", "a packet");
diff --git a/networking/udhcp/d6_socket.c b/networking/udhcp/d6_socket.c
index 25e622d6f..8ddee5a8e 100644
--- a/networking/udhcp/d6_socket.c
+++ b/networking/udhcp/d6_socket.c
@@ -115,7 +115,7 @@ int FAST_FUNC d6_listen_socket(int port, const char *inf)
 
 	setsockopt_reuseaddr(fd);
 	if (setsockopt_broadcast(fd) == -1)
-		bb_perror_msg_and_die("SO_BROADCAST");
+		bb_simple_perror_msg_and_die("SO_BROADCAST");
 
 	/* NB: bug 1032 says this doesn't work on ethernet aliases (ethN:M) */
 	if (setsockopt_bindtodevice(fd, inf))
diff --git a/networking/udhcp/dhcpc.c b/networking/udhcp/dhcpc.c
index d1a0eaf02..656295ff7 100644
--- a/networking/udhcp/dhcpc.c
+++ b/networking/udhcp/dhcpc.c
@@ -906,7 +906,7 @@ static NOINLINE int udhcp_recv_raw_packet(struct dhcp_packet *dhcp_pkt, int fd)
 		if (bytes < 0) {
 			if (errno == EINTR)
 				continue;
-			log1("packet read error, ignoring");
+			log1s("packet read error, ignoring");
 			/* NB: possible down interface, etc. Caller should pause. */
 			return bytes; /* returns -1 */
 		}
@@ -914,13 +914,13 @@ static NOINLINE int udhcp_recv_raw_packet(struct dhcp_packet *dhcp_pkt, int fd)
 	}
 
 	if (bytes < (int) (sizeof(packet.ip) + sizeof(packet.udp))) {
-		log1("packet is too short, ignoring");
+		log1s("packet is too short, ignoring");
 		return -2;
 	}
 
 	if (bytes < ntohs(packet.ip.tot_len)) {
 		/* packet is bigger than sizeof(packet), we did partial read */
-		log1("oversized packet, ignoring");
+		log1s("oversized packet, ignoring");
 		return -2;
 	}
 
@@ -935,7 +935,7 @@ static NOINLINE int udhcp_recv_raw_packet(struct dhcp_packet *dhcp_pkt, int fd)
 	/* || bytes > (int) sizeof(packet) - can't happen */
 	 || ntohs(packet.udp.len) != (uint16_t)(bytes - sizeof(packet.ip))
 	) {
-		log1("unrelated/bogus packet, ignoring");
+		log1s("unrelated/bogus packet, ignoring");
 		return -2;
 	}
 
@@ -943,7 +943,7 @@ static NOINLINE int udhcp_recv_raw_packet(struct dhcp_packet *dhcp_pkt, int fd)
 	check = packet.ip.check;
 	packet.ip.check = 0;
 	if (check != inet_cksum((uint16_t *)&packet.ip, sizeof(packet.ip))) {
-		log1("bad IP header checksum, ignoring");
+		log1s("bad IP header checksum, ignoring");
 		return -2;
 	}
 
@@ -968,13 +968,13 @@ static NOINLINE int udhcp_recv_raw_packet(struct dhcp_packet *dhcp_pkt, int fd)
 	check = packet.udp.check;
 	packet.udp.check = 0;
 	if (check && check != inet_cksum((uint16_t *)&packet, bytes)) {
-		log1("packet with bad UDP checksum received, ignoring");
+		log1s("packet with bad UDP checksum received, ignoring");
 		return -2;
 	}
  skip_udp_sum_check:
 
 	if (packet.data.cookie != htonl(DHCP_MAGIC)) {
-		bb_info_msg("packet with bad magic, ignoring");
+		bb_simple_info_msg("packet with bad magic, ignoring");
 		return -2;
 	}
 
@@ -1089,10 +1089,10 @@ static int udhcp_raw_socket(int ifindex)
 
 	if (setsockopt_1(fd, SOL_PACKET, PACKET_AUXDATA) != 0) {
 		if (errno != ENOPROTOOPT)
-			log1("can't set PACKET_AUXDATA on raw socket");
+			log1s("can't set PACKET_AUXDATA on raw socket");
 	}
 
-	log1("created raw socket");
+	log1s("created raw socket");
 
 	return fd;
 }
@@ -1120,7 +1120,7 @@ static void change_listen_mode(int new_mode)
 /* Called only on SIGUSR1 */
 static void perform_renew(void)
 {
-	bb_info_msg("performing DHCP renew");
+	bb_simple_info_msg("performing DHCP renew");
 	switch (client_data.state) {
 	case BOUND:
 		change_listen_mode(LISTEN_KERNEL);
@@ -1158,7 +1158,7 @@ static void perform_release(uint32_t server_addr, uint32_t requested_ip)
 				inet_ntoa(temp_addr), buffer);
 		send_release(server_addr, requested_ip); /* unicast */
 	}
-	bb_info_msg("entering released state");
+	bb_simple_info_msg("entering released state");
 /*
  * We can be here on: SIGUSR2,
  * or on exit (SIGTERM) and -R "release on quit" is specified.
@@ -1303,7 +1303,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 	);
 	if (opt & (OPT_h|OPT_H)) {
 		//msg added 2011-11
-		bb_error_msg("option -h NAME is deprecated, use -x hostname:NAME");
+		bb_simple_error_msg("option -h NAME is deprecated, use -x hostname:NAME");
 		client_data.hostname = alloc_dhcp_option(DHCP_HOST_NAME, str_h, 0);
 	}
 	if (opt & OPT_F) {
@@ -1397,7 +1397,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 	/* Create pidfile */
 	write_pidfile(client_data.pidfile);
 	/* Goes to stdout (unless NOMMU) and possibly syslog */
-	bb_info_msg("started, v"BB_VER);
+	bb_simple_info_msg("started, v"BB_VER);
 	/* We want random_xid to be random... */
 	srand(monotonic_us());
 
@@ -1444,7 +1444,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 					continue;
 				}
 				/* Else: an error occurred, panic! */
-				bb_perror_msg_and_die("poll");
+				bb_simple_perror_msg_and_die("poll");
 			}
 		}
 
@@ -1485,7 +1485,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 				udhcp_run_script(NULL, "leasefail");
 #if BB_MMU /* -b is not supported on NOMMU */
 				if (opt & OPT_b) { /* background if no lease */
-					bb_info_msg("no lease, forking to background");
+					bb_simple_info_msg("no lease, forking to background");
 					client_background();
 					/* do not background again! */
 					opt = ((opt & ~(OPT_b|OPT_n)) | OPT_f);
@@ -1498,7 +1498,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 				} else
 #endif
 				if (opt & OPT_n) { /* abort if no lease */
-					bb_info_msg("no lease, failing");
+					bb_simple_info_msg("no lease, failing");
 					retval = 1;
 					goto ret;
 				}
@@ -1526,7 +1526,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 				client_data.state = RENEWING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
 				change_listen_mode(LISTEN_KERNEL);
-				log1("entering renew state");
+				log1s("entering renew state");
 				/* fall right through */
 			case RENEW_REQUESTED: /* manual (SIGUSR1) renew */
 			case_RENEW_REQUESTED:
@@ -1559,7 +1559,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 					 */
 				}
 				/* Timed out or error, enter rebinding state */
-				log1("entering rebinding state");
+				log1s("entering rebinding state");
 				client_data.state = REBINDING;
 				/* fall right through */
 			case REBINDING:
@@ -1574,7 +1574,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 					continue;
 				}
 				/* Timed out, enter init state */
-				bb_info_msg("lease lost, entering init state");
+				bb_simple_info_msg("lease lost, entering init state");
 				udhcp_run_script(NULL, "deconfig");
 				client_data.state = INIT_SELECTING;
 				client_data.first_secs = 0; /* make secs field count from 0 */
@@ -1660,13 +1660,13 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 		 || memcmp(packet.chaddr, client_data.client_mac, 6) != 0
 		) {
 //FIXME: need to also check that last 10 bytes are zero
-			log1("chaddr does not match, ignoring packet"); // log2?
+			log1("chaddr does not match%s", ", ignoring packet"); // log2?
 			continue;
 		}
 
 		message = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);
 		if (message == NULL) {
-			bb_info_msg("no message type option, ignoring packet");
+			bb_info_msg("no message type option%s", ", ignoring packet");
 			continue;
 		}
 
@@ -1703,7 +1703,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 				server_addr = 0;
 				temp = udhcp_get_option32(&packet, DHCP_SERVER_ID);
 				if (!temp) {
-					bb_info_msg("no server ID, using 0.0.0.0");
+					bb_simple_info_msg("no server ID, using 0.0.0.0");
 				} else {
 					/* it IS unaligned sometimes, don't "optimize" */
 					move_from_unaligned32(server_addr, temp);
@@ -1730,7 +1730,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 
 				temp = udhcp_get_option32(&packet, DHCP_LEASE_TIME);
 				if (!temp) {
-					bb_info_msg("no lease time with ACK, using 1 hour lease");
+					bb_simple_info_msg("no lease time with ACK, using 1 hour lease");
 					lease_seconds = 60 * 60;
 				} else {
 					/* it IS unaligned sometimes, don't "optimize" */
@@ -1763,7 +1763,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 							client_data.interface,
 							arpping_ms)
 					) {
-						bb_info_msg("offered address is in use "
+						bb_simple_info_msg("offered address is in use "
 							"(got ARP reply), declining");
 						send_decline(/*xid,*/ server_addr, packet.yiaddr);
 
@@ -1827,7 +1827,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)
 					if (!temp) {
  non_matching_svid:
 						log1("received DHCP NAK with wrong"
-							" server ID, ignoring packet");
+							" server ID%s", ", ignoring packet");
 						continue;
 					}
 					move_from_unaligned32(svid, temp);
diff --git a/networking/udhcp/dhcpd.c b/networking/udhcp/dhcpd.c
index 022b8721b..3e08ec011 100644
--- a/networking/udhcp/dhcpd.c
+++ b/networking/udhcp/dhcpd.c
@@ -582,11 +582,11 @@ static void send_packet_to_client(struct dhcp_packet *dhcp_pkt, int force_broadc
 	 || (dhcp_pkt->flags & htons(BROADCAST_FLAG))
 	 || dhcp_pkt->ciaddr == 0
 	) {
-		log1("broadcasting packet to client");
+		log1s("broadcasting packet to client");
 		ciaddr = INADDR_BROADCAST;
 		chaddr = MAC_BCAST_ADDR;
 	} else {
-		log1("unicasting packet to client ciaddr");
+		log1s("unicasting packet to client ciaddr");
 		ciaddr = dhcp_pkt->ciaddr;
 		chaddr = dhcp_pkt->chaddr;
 	}
@@ -600,7 +600,7 @@ static void send_packet_to_client(struct dhcp_packet *dhcp_pkt, int force_broadc
 /* Send a packet to gateway_nip using the kernel ip stack */
 static void send_packet_to_relay(struct dhcp_packet *dhcp_pkt)
 {
-	log1("forwarding packet to relay");
+	log1s("forwarding packet to relay");
 
 	udhcp_send_kernel_packet(dhcp_pkt,
 			server_data.server_nip, SERVER_PORT,
@@ -754,7 +754,7 @@ static NOINLINE void send_offer(struct dhcp_packet *oldpacket,
 		}
 
 		if (!packet.yiaddr) {
-			bb_error_msg("no free IP addresses. OFFER abandoned");
+			bb_simple_error_msg("no free IP addresses. OFFER abandoned");
 			return;
 		}
 		/* Reserve the IP for a short time hoping to get DHCPREQUEST soon */
@@ -765,7 +765,7 @@ static NOINLINE void send_offer(struct dhcp_packet *oldpacket,
 				p_host_name ? (unsigned char)p_host_name[OPT_LEN - OPT_DATA] : 0
 		);
 		if (!lease) {
-			bb_error_msg("no free IP addresses. OFFER abandoned");
+			bb_simple_error_msg("no free IP addresses. OFFER abandoned");
 			return;
 		}
 	}
@@ -914,7 +914,7 @@ int udhcpd_main(int argc UNUSED_PARAM, char **argv)
 	write_pidfile(server_data.pidfile);
 	/* if (!..) bb_perror_msg("can't create pidfile %s", pidfile); */
 
-	bb_info_msg("started, v"BB_VER);
+	bb_simple_info_msg("started, v"BB_VER);
 
 	option = udhcp_find_option(server_data.options, DHCP_LEASE_TIME);
 	server_data.max_lease_sec = DEFAULT_LEASE_TIME;
@@ -985,7 +985,7 @@ int udhcpd_main(int argc UNUSED_PARAM, char **argv)
 			if (errno == EINTR)
 				goto new_tv;
 			/* < 0 and not EINTR: should not happen */
-			bb_perror_msg_and_die("poll");
+			bb_simple_perror_msg_and_die("poll");
 		}
 
 		if (pfds[0].revents) switch (udhcp_sp_read()) {
@@ -1019,16 +1019,16 @@ int udhcpd_main(int argc UNUSED_PARAM, char **argv)
 			continue;
 		}
 		if (packet.hlen != 6) {
-			bb_info_msg("MAC length != 6, ignoring packet");
+			bb_info_msg("MAC length != 6%s", ", ignoring packet");
 			continue;
 		}
 		if (packet.op != BOOTREQUEST) {
-			bb_info_msg("not a REQUEST, ignoring packet");
+			bb_info_msg("not a REQUEST%s", ", ignoring packet");
 			continue;
 		}
 		state = udhcp_get_option(&packet, DHCP_MESSAGE_TYPE);
 		if (state == NULL || state[0] < DHCP_MINTYPE || state[0] > DHCP_MAXTYPE) {
-			bb_info_msg("no or bad message type option, ignoring packet");
+			bb_info_msg("no or bad message type option%s", ", ignoring packet");
 			continue;
 		}
 
@@ -1039,7 +1039,7 @@ int udhcpd_main(int argc UNUSED_PARAM, char **argv)
 			move_from_unaligned32(server_id_network_order, server_id_opt);
 			if (server_id_network_order != server_data.server_nip) {
 				/* client talks to somebody else */
-				log1("server ID doesn't match, ignoring");
+				log1("server ID doesn't match%s", ", ignoring");
 				continue;
 			}
 		}
@@ -1162,7 +1162,7 @@ o DHCPREQUEST generated during REBINDING state:
 			if (!requested_ip_opt) {
 				requested_nip = packet.ciaddr;
 				if (requested_nip == 0) {
-					log1("no requested IP and no ciaddr, ignoring");
+					log1("no requested IP and no ciaddr%s", ", ignoring");
 					break;
 				}
 			}
diff --git a/networking/udhcp/dhcprelay.c b/networking/udhcp/dhcprelay.c
index 86dcb1af0..ef9447b4b 100644
--- a/networking/udhcp/dhcprelay.c
+++ b/networking/udhcp/dhcprelay.c
@@ -186,7 +186,7 @@ static int sendto_ip4(int sock, const void *msg, int msg_len, struct sockaddr_in
 	err = sendto(sock, msg, msg_len, 0, (struct sockaddr*) to, sizeof(*to));
 	err -= msg_len;
 	if (err)
-		bb_perror_msg("sendto");
+		bb_simple_perror_msg("sendto");
 	return err;
 }
 
@@ -273,7 +273,7 @@ int dhcprelay_main(int argc UNUSED_PARAM, char **argv)
 		bb_show_usage();
 	if (argv[3]) {
 		if (!inet_aton(argv[3], &server_addr.sin_addr))
-			bb_perror_msg_and_die("bad server IP");
+			bb_simple_perror_msg_and_die("bad server IP");
 	}
 
 	iface_list = make_iface_list(argv + 1, &num_sockets);
diff --git a/networking/udhcp/packet.c b/networking/udhcp/packet.c
index 64af802a3..6d4375237 100644
--- a/networking/udhcp/packet.c
+++ b/networking/udhcp/packet.c
@@ -85,14 +85,14 @@ int FAST_FUNC udhcp_recv_kernel_packet(struct dhcp_packet *packet, int fd)
 	memset(packet, 0, sizeof(*packet));
 	bytes = safe_read(fd, packet, sizeof(*packet));
 	if (bytes < 0) {
-		log1("packet read error, ignoring");
+		log1s("packet read error, ignoring");
 		return bytes; /* returns -1 */
 	}
 
 	if (bytes < offsetof(struct dhcp_packet, options)
 	 || packet->cookie != htonl(DHCP_MAGIC)
 	) {
-		bb_info_msg("packet with bad magic, ignoring");
+		bb_simple_info_msg("packet with bad magic, ignoring");
 		return -2;
 	}
 	log1("received %s", "a packet");
diff --git a/networking/udhcp/signalpipe.c b/networking/udhcp/signalpipe.c
index 81d1fc01a..7df671245 100644
--- a/networking/udhcp/signalpipe.c
+++ b/networking/udhcp/signalpipe.c
@@ -28,7 +28,7 @@ static void signal_handler(int sig)
 	int sv = errno;
 	unsigned char ch = sig; /* use char, avoid dealing with partial writes */
 	if (write(WRITE_FD, &ch, 1) != 1)
-		bb_perror_msg("can't send signal");
+		bb_simple_perror_msg("can't send signal");
 	errno = sv;
 }
 
diff --git a/networking/udhcp/socket.c b/networking/udhcp/socket.c
index 34049c3ee..65a1a8ead 100644
--- a/networking/udhcp/socket.c
+++ b/networking/udhcp/socket.c
@@ -87,7 +87,7 @@ int FAST_FUNC udhcp_listen_socket(/*uint32_t ip,*/ int port, const char *inf)
 
 	setsockopt_reuseaddr(fd);
 	if (setsockopt_broadcast(fd) == -1)
-		bb_perror_msg_and_die("SO_BROADCAST");
+		bb_simple_perror_msg_and_die("SO_BROADCAST");
 
 	/* SO_BINDTODEVICE doesn't work on ethernet aliases (ethN:M) */
 	colon = strrchr(inf, ':');
diff --git a/networking/wget.c b/networking/wget.c
index b6f9d605a..9e5a40b6f 100644
--- a/networking/wget.c
+++ b/networking/wget.c
@@ -368,7 +368,7 @@ static void alarm_handler(int sig UNUSED_PARAM)
 {
 	/* This is theoretically unsafe (uses stdio and malloc in signal handler) */
 	if (G.die_if_timed_out)
-		bb_error_msg_and_die("download timed out");
+		bb_simple_error_msg_and_die("download timed out");
 }
 static void set_alarm(void)
 {
@@ -452,7 +452,7 @@ static char fgets_trim_sanitize(FILE *fp, const char *fmt)
 
 	set_alarm();
 	if (fgets(G.wget_buf, sizeof(G.wget_buf), fp) == NULL)
-		bb_perror_msg_and_die("error getting response");
+		bb_simple_perror_msg_and_die("error getting response");
 	clear_alarm();
 
 	buf_ptr = strchrnul(G.wget_buf, '\n');
@@ -633,7 +633,7 @@ static char *get_sanitized_hdr(FILE *fp)
 
 static void reset_beg_range_to_zero(void)
 {
-	bb_error_msg("restart failed");
+	bb_simple_error_msg("restart failed");
 	G.beg_range = 0;
 	xlseek(G.output_fd, 0, SEEK_SET);
 	/* Done at the end instead: */
@@ -651,7 +651,7 @@ static int spawn_https_helper_openssl(const char *host, unsigned port)
 
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) != 0)
 		/* Kernel can have AF_UNIX support disabled */
-		bb_perror_msg_and_die("socketpair");
+		bb_simple_perror_msg_and_die("socketpair");
 
 	if (!strchr(host, ':'))
 		host = allocated = xasprintf("%s:%u", host, port);
@@ -724,7 +724,7 @@ static void spawn_ssl_client(const char *host, int network_fd, int flags)
 
 	if (!(option_mask32 & WGET_OPT_NO_CHECK_CERT)) {
 		option_mask32 |= WGET_OPT_NO_CHECK_CERT;
-		bb_error_msg("note: TLS certificate validation not implemented");
+		bb_simple_error_msg("note: TLS certificate validation not implemented");
 	}
 
 	servername = xstrdup(host);
@@ -733,7 +733,7 @@ static void spawn_ssl_client(const char *host, int network_fd, int flags)
 
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) != 0)
 		/* Kernel can have AF_UNIX support disabled */
-		bb_perror_msg_and_die("socketpair");
+		bb_simple_perror_msg_and_die("socketpair");
 
 	fflush_all();
 	pid = BB_MMU ? xfork() : xvfork();
@@ -785,7 +785,7 @@ static FILE* prepare_ftp_session(FILE **dfpp, struct host_info *target, len_and_
 #endif
 
 	if (ftpcmd(NULL, NULL, sfp) != 220)
-		bb_error_msg_and_die("%s", G.wget_buf);
+		bb_simple_error_msg_and_die(G.wget_buf);
 		/* note: ftpcmd() sanitizes G.wget_buf, ok to print */
 
 	/* Split username:password pair */
@@ -948,7 +948,7 @@ static void NOINLINE retrieve_file_data(FILE *dfp)
 			if (errno != EAGAIN) {
 				if (ferror(dfp)) {
 					progress_meter(PROGRESS_END);
-					bb_perror_msg_and_die(bb_msg_read_error);
+					bb_simple_perror_msg_and_die(bb_msg_read_error);
 				}
 				break; /* EOF, not error */
 			}
@@ -961,7 +961,7 @@ static void NOINLINE retrieve_file_data(FILE *dfp)
 # if ENABLE_FEATURE_WGET_TIMEOUT
 				if (second_cnt != 0 && --second_cnt == 0) {
 					progress_meter(PROGRESS_END);
-					bb_error_msg_and_die("download timed out");
+					bb_simple_error_msg_and_die("download timed out");
 				}
 # endif
 				/* We used to loop back to poll here,
@@ -1014,7 +1014,7 @@ static void NOINLINE retrieve_file_data(FILE *dfp)
 	G.got_clen = 1; /* makes it show 100% even for download of (formerly) unknown size */
 	progress_meter(PROGRESS_END);
 	if (G.content_len != 0) {
-		bb_perror_msg_and_die("connection closed prematurely");
+		bb_simple_perror_msg_and_die("connection closed prematurely");
 		/* GNU wget says "DATE TIME (NN MB/s) - Connection closed at byte NNN. Retrying." */
 	}
 
@@ -1348,7 +1348,7 @@ However, in real world it was observed that some web servers
 			}
 			if (key == KEY_location && status >= 300) {
 				if (--redir_limit == 0)
-					bb_error_msg_and_die("too many redirections");
+					bb_simple_error_msg_and_die("too many redirections");
 				fclose(sfp);
 				if (str[0] == '/') {
 					free(redirected_path);
diff --git a/networking/zcip.c b/networking/zcip.c
index f95b6f7fb..134dfb2df 100644
--- a/networking/zcip.c
+++ b/networking/zcip.c
@@ -276,7 +276,7 @@ int zcip_main(int argc UNUSED_PARAM, char **argv)
 		if (inet_aton(l_opt, &net) == 0
 		 || (net.s_addr & htonl(IN_CLASSB_NET)) != net.s_addr
 		) {
-			bb_error_msg_and_die("invalid network address");
+			bb_simple_error_msg_and_die("invalid network address");
 		}
 		G.localnet_ip = ntohl(net.s_addr);
 	}
@@ -285,7 +285,7 @@ int zcip_main(int argc UNUSED_PARAM, char **argv)
 		if (inet_aton(r_opt, &ip) == 0
 		 || (ntohl(ip.s_addr) & IN_CLASSB_NET) != G.localnet_ip
 		) {
-			bb_error_msg_and_die("invalid link address");
+			bb_simple_error_msg_and_die("invalid link address");
 		}
 		chosen_nip = ip.s_addr;
 	}
@@ -473,7 +473,7 @@ int zcip_main(int argc UNUSED_PARAM, char **argv)
 
 		// Read ARP packet
 		if (safe_read(sock_fd, &p, sizeof(p)) < 0) {
-			bb_perror_msg_and_die(bb_msg_read_error);
+			bb_simple_perror_msg_and_die(bb_msg_read_error);
 		}
 
 		if (p.eth.ether_type != htons(ETHERTYPE_ARP))
diff --git a/printutils/lpr.c b/printutils/lpr.c
index 7acb6c357..77d1a79a4 100644
--- a/printutils/lpr.c
+++ b/printutils/lpr.c
@@ -167,7 +167,7 @@ int lpqr_main(int argc UNUSED_PARAM, char *argv[])
 	// LPR ------------------------
 	//
 	if (opts & LPR_V)
-		bb_error_msg("connected to server");
+		bb_simple_error_msg("connected to server");
 
 	job = getpid() % 1000;
 	hostname = safe_gethostname();
@@ -206,7 +206,7 @@ int lpqr_main(int argc UNUSED_PARAM, char *argv[])
 		 * Standard lpr works around it by refusing to send such jobs:
 		 */
 		if (st.st_size == 0) {
-			bb_error_msg("nothing to print");
+			bb_simple_error_msg("nothing to print");
 			continue;
 		}
 
@@ -246,7 +246,7 @@ int lpqr_main(int argc UNUSED_PARAM, char *argv[])
 
 		// send control file
 		if (opts & LPR_V)
-			bb_error_msg("sending control file");
+			bb_simple_error_msg("sending control file");
 		/* "Acknowledgement processing must occur as usual
 		 * after the command is sent." */
 		cflen = (unsigned)strlen(controlfile);
@@ -262,12 +262,12 @@ int lpqr_main(int argc UNUSED_PARAM, char *argv[])
 
 		// send data file, with name "dfaXXX"
 		if (opts & LPR_V)
-			bb_error_msg("sending data file");
+			bb_simple_error_msg("sending data file");
 		fdprintf(fd, "\x3" "%"OFF_FMT"u d%s\n", st.st_size, remote_filename);
 		get_response_or_say_and_die(fd, "sending data file");
 		if (bb_copyfd_size(dfd, fd, st.st_size) != st.st_size) {
 			// We're screwed. We sent less bytes than we advertised.
-			bb_error_msg_and_die("local file changed size?!");
+			bb_simple_error_msg_and_die("local file changed size?!");
 		}
 		write(fd, "", 1); // send ACK
 		get_response_or_say_and_die(fd, "sending data file");
@@ -283,7 +283,7 @@ int lpqr_main(int argc UNUSED_PARAM, char *argv[])
 
 		// say job accepted
 		if (opts & LPR_V)
-			bb_error_msg("job accepted");
+			bb_simple_error_msg("job accepted");
 
 		// next, please!
 		job = (job + 1) % 1000;
diff --git a/procps/kill.c b/procps/kill.c
index a30a79dd8..4a2eab613 100644
--- a/procps/kill.c
+++ b/procps/kill.c
@@ -268,7 +268,7 @@ int kill_main(int argc UNUSED_PARAM, char **argv)
 #if ENABLE_KILL || ENABLE_KILLALL
 	/* Pid or name is required for kill/killall */
 	if (!arg) {
-		bb_error_msg("you need to specify whom to kill");
+		bb_simple_error_msg("you need to specify whom to kill");
 		return EXIT_FAILURE;
 	}
 
diff --git a/procps/mpstat.c b/procps/mpstat.c
index 4ea1b5d97..52a436a55 100644
--- a/procps/mpstat.c
+++ b/procps/mpstat.c
@@ -931,7 +931,7 @@ int mpstat_main(int argc UNUSED_PARAM, char **argv)
 				/* Get CPU number */
 				unsigned n = xatoi_positive(t);
 				if (n >= G.cpu_nr)
-					bb_error_msg_and_die("not that many processors");
+					bb_simple_error_msg_and_die("not that many processors");
 				n++;
 				G.cpu_bitmap[n >> 3] |= 1 << (n & 7);
 			}
diff --git a/procps/powertop.c b/procps/powertop.c
index e70f5433b..d508b5f78 100644
--- a/procps/powertop.c
+++ b/procps/powertop.c
@@ -657,7 +657,7 @@ static void show_timerstats(void)
 		}
 	} else {
 		bb_putchar('\n');
-		bb_error_msg("no stats available; run as root or"
+		bb_simple_error_msg("no stats available; run as root or"
 				" enable the timer_stats module");
 	}
 }
@@ -707,7 +707,7 @@ int powertop_main(int argc UNUSED_PARAM, char UNUSED_PARAM **argv)
 
 	/* Print warning when we don't have superuser privileges */
 	if (geteuid() != 0)
-		bb_error_msg("run as root to collect enough information");
+		bb_simple_error_msg("run as root to collect enough information");
 
 	/* Get number of CPUs */
 	G.total_cpus = get_cpu_count();
diff --git a/procps/pstree.c b/procps/pstree.c
index 1d124d2d2..67b711168 100644
--- a/procps/pstree.c
+++ b/procps/pstree.c
@@ -404,7 +404,7 @@ int pstree_main(int argc UNUSED_PARAM, char **argv)
 	else {
 		dump_by_user(find_proc(1), uid);
 		if (!G.dumped) {
-			bb_error_msg_and_die("no processes found");
+			bb_simple_error_msg_and_die("no processes found");
 		}
 	}
 
diff --git a/procps/top.c b/procps/top.c
index 89f9d23f4..8fe53324f 100644
--- a/procps/top.c
+++ b/procps/top.c
@@ -1229,7 +1229,7 @@ int top_main(int argc UNUSED_PARAM, char **argv)
 #endif
 		} /* end of "while we read /proc" */
 		if (ntop == 0) {
-			bb_error_msg("no process info in /proc");
+			bb_simple_error_msg("no process info in /proc");
 			break;
 		}
 
diff --git a/runit/chpst.c b/runit/chpst.c
index 5e77245f6..af777568f 100644
--- a/runit/chpst.c
+++ b/runit/chpst.c
@@ -270,7 +270,7 @@ static void limit(int what, long l)
 	else
 		r.rlim_cur = l;
 	if (setrlimit(what, &r) == -1)
-		bb_perror_msg_and_die("setrlimit");
+		bb_simple_perror_msg_and_die("setrlimit");
 }
 
 int chpst_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -467,12 +467,12 @@ int chpst_main(int argc UNUSED_PARAM, char **argv)
 	if (opt & OPT_n) {
 		errno = 0;
 		if (nice(xatoi(nicestr)) == -1)
-			bb_perror_msg_and_die("nice");
+			bb_simple_perror_msg_and_die("nice");
 	}
 
 	if (opt & OPT_u) {
 		if (setgroups(1, &ugid.gid) == -1)
-			bb_perror_msg_and_die("setgroups");
+			bb_simple_perror_msg_and_die("setgroups");
 		xsetgid(ugid.gid);
 		xsetuid(ugid.uid);
 	}
diff --git a/runit/svlogd.c b/runit/svlogd.c
index c9e5346d1..a250058a1 100644
--- a/runit/svlogd.c
+++ b/runit/svlogd.c
@@ -274,7 +274,7 @@ static void warnx(const char *m0, const char *m1)
 }
 static void pause_nomem(void)
 {
-	bb_error_msg(PAUSE"out of memory");
+	bb_simple_error_msg(PAUSE"out of memory");
 	sleep(3);
 }
 static void pause1cannot(const char *m0)
diff --git a/selinux/chcon.c b/selinux/chcon.c
index 5bf91710c..afe7f713d 100644
--- a/selinux/chcon.c
+++ b/selinux/chcon.c
@@ -107,7 +107,7 @@ static int FAST_FUNC change_filedir_context(
 
 	context_string = context_str(context);
 	if (!context_string) {
-		bb_error_msg("can't obtain security context in text expression");
+		bb_simple_error_msg("can't obtain security context in text expression");
 		goto skip;
 	}
 
@@ -194,7 +194,7 @@ int chcon_main(int argc UNUSED_PARAM, char **argv)
 		/* specified_context is never NULL -
 		 * "-1" in opt_complementary prevents this. */
 		if (!argv[0])
-			bb_error_msg_and_die("too few arguments");
+			bb_simple_error_msg_and_die("too few arguments");
 	}
 
 	for (i = 0; (fname = argv[i]) != NULL; i++) {
diff --git a/selinux/getenforce.c b/selinux/getenforce.c
index 0286dd0be..f082ba614 100644
--- a/selinux/getenforce.c
+++ b/selinux/getenforce.c
@@ -29,12 +29,12 @@ int getenforce_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 
 	rc = is_selinux_enabled();
 	if (rc < 0)
-		bb_error_msg_and_die("is_selinux_enabled() failed");
+		bb_simple_error_msg_and_die("is_selinux_enabled() failed");
 
 	if (rc == 1) {
 		rc = security_getenforce();
 		if (rc < 0)
-			bb_error_msg_and_die("getenforce() failed");
+			bb_simple_error_msg_and_die("getenforce() failed");
 
 		if (rc)
 			puts("Enforcing");
diff --git a/selinux/getsebool.c b/selinux/getsebool.c
index 6d7805c8d..36ddd45b9 100644
--- a/selinux/getsebool.c
+++ b/selinux/getsebool.c
@@ -40,7 +40,7 @@ int getsebool_main(int argc, char **argv)
 
 		rc = security_get_boolean_names(&names, &len);
 		if (rc)
-			bb_perror_msg_and_die("can't get boolean names");
+			bb_simple_perror_msg_and_die("can't get boolean names");
 
 		if (!len) {
 			puts("No booleans");
diff --git a/selinux/load_policy.c b/selinux/load_policy.c
index b7930839c..eac6ba6c1 100644
--- a/selinux/load_policy.c
+++ b/selinux/load_policy.c
@@ -31,7 +31,7 @@ int load_policy_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 
 	rc = selinux_mkload_policy(1);
 	if (rc < 0) {
-		bb_perror_msg_and_die("can't load policy");
+		bb_simple_perror_msg_and_die("can't load policy");
 	}
 
 	return 0;
diff --git a/selinux/runcon.c b/selinux/runcon.c
index a5a394427..bc4fa23e0 100644
--- a/selinux/runcon.c
+++ b/selinux/runcon.c
@@ -65,7 +65,7 @@ static context_t runcon_compute_new_context(char *user, char *role, char *type,
 	security_context_t cur_context;
 
 	if (getcon(&cur_context))
-		bb_error_msg_and_die("can't get current context");
+		bb_simple_error_msg_and_die("can't get current context");
 
 	if (compute_trans) {
 		security_context_t file_context, new_context;
@@ -75,7 +75,7 @@ static context_t runcon_compute_new_context(char *user, char *role, char *type,
 					command);
 		if (security_compute_create(cur_context, file_context,
 					SECCLASS_PROCESS, &new_context))
-			bb_error_msg_and_die("unable to compute a new context");
+			bb_simple_error_msg_and_die("unable to compute a new context");
 		cur_context = new_context;
 	}
 
@@ -137,7 +137,7 @@ int runcon_main(int argc UNUSED_PARAM, char **argv)
 	if (!(opts & OPTS_CONTEXT_COMPONENT)) {
 		context = *argv++;
 		if (!argv[0])
-			bb_error_msg_and_die("no command given");
+			bb_simple_error_msg_and_die("no command given");
 	}
 
 	if (context) {
diff --git a/selinux/sestatus.c b/selinux/sestatus.c
index 6954aca70..098a4d189 100644
--- a/selinux/sestatus.c
+++ b/selinux/sestatus.c
@@ -216,5 +216,5 @@ int sestatus_main(int argc UNUSED_PARAM, char **argv)
 	return 0;
 
   error:
-	bb_perror_msg_and_die("libselinux returns unknown state");
+	bb_simple_perror_msg_and_die("libselinux returns unknown state");
 }
diff --git a/selinux/setenforce.c b/selinux/setenforce.c
index c28de6ec5..996034f8e 100644
--- a/selinux/setenforce.c
+++ b/selinux/setenforce.c
@@ -49,7 +49,7 @@ int setenforce_main(int argc UNUSED_PARAM, char **argv)
 			continue;
 		rc = security_setenforce(i & 1);
 		if (rc < 0)
-			bb_perror_msg_and_die("setenforce() failed");
+			bb_simple_perror_msg_and_die("setenforce() failed");
 		return 0;
 	}
 
diff --git a/selinux/setfiles.c b/selinux/setfiles.c
index 740eaf8fb..55bfb4d02 100644
--- a/selinux/setfiles.c
+++ b/selinux/setfiles.c
@@ -182,7 +182,7 @@ static void inc_err(void)
 {
 	nerr++;
 	if (nerr > 9 && !FLAG_d_debug) {
-		bb_error_msg_and_die("exiting after 10 errors");
+		bb_simple_error_msg_and_die("exiting after 10 errors");
 	}
 }
 
diff --git a/selinux/setsebool.c b/selinux/setsebool.c
index 579118172..2af23acd7 100644
--- a/selinux/setsebool.c
+++ b/selinux/setsebool.c
@@ -46,7 +46,7 @@ int setsebool_main(int argc, char **argv)
 	}
 
 	if (security_set_boolean(argv[1], value) < 0)
-		bb_error_msg_and_die("can't set boolean");
+		bb_simple_error_msg_and_die("can't set boolean");
 
 	return 0;
 }
diff --git a/shell/hush.c b/shell/hush.c
index f82747f74..19b97e2a5 100644
--- a/shell/hush.c
+++ b/shell/hush.c
@@ -1398,7 +1398,7 @@ static void syntax_error(unsigned lineno UNUSED_PARAM, const char *msg)
 	if (msg)
 		bb_error_msg("syntax error: %s", msg);
 	else
-		bb_error_msg("syntax error");
+		bb_simple_error_msg("syntax error");
 	die_if_script();
 }
 
@@ -1637,7 +1637,7 @@ static int refill_HFILE_and_getc(HFILE *fp)
 	fp->cur = fp->buf;
 	n = safe_read(fp->fd, fp->buf, sizeof(fp->buf));
 	if (n < 0) {
-		bb_perror_msg("read error");
+		bb_simple_perror_msg("read error");
 		n = 0;
 	}
 	fp->end = fp->buf + n;
@@ -2282,7 +2282,7 @@ static int set_local_var(char *str, unsigned flags)
 
 	eq_sign = strchr(str, '=');
 	if (HUSH_DEBUG && !eq_sign)
-		bb_error_msg_and_die("BUG in setvar");
+		bb_simple_error_msg_and_die("BUG in setvar");
 
 	name_len = eq_sign - str + 1; /* including '=' */
 	cur_pp = &G.top_var;
@@ -2505,7 +2505,7 @@ static void set_vars_and_save_old(char **strings)
 
 		eq = strchr(*s, '=');
 		if (HUSH_DEBUG && !eq)
-			bb_error_msg_and_die("BUG in varexp4");
+			bb_simple_error_msg_and_die("BUG in varexp4");
 		var_pp = get_ptr_to_local_var(*s, eq - *s);
 		if (var_pp) {
 			var_p = *var_pp;
@@ -4246,7 +4246,7 @@ static int parse_redir_right_fd(o_string *as_string, struct in_str *input)
 
 //TODO: this is the place to catch ">&file" bashism (redirect both fd 1 and 2)
 
-	bb_error_msg("ambiguous redirect");
+	bb_simple_error_msg("ambiguous redirect");
 	return REDIRFD_SYNTAX_ERR;
 }
 
@@ -6956,7 +6956,7 @@ static char *expand_string_to_string(const char *str, int EXP_flags, int do_unba
 	} else {
 		if (HUSH_DEBUG)
 			if (list[1])
-				bb_error_msg_and_die("BUG in varexp2");
+				bb_simple_error_msg_and_die("BUG in varexp2");
 		/* actually, just move string 2*sizeof(char*) bytes back */
 		overlapping_strcpy((char*)list, list[0]);
 		if (do_unbackslash)
@@ -7217,7 +7217,7 @@ static void re_execute_shell(char ***to_free, const char *s,
 	if (argv[0][0] == '/')
 		execve(argv[0], argv, pp);
 	xfunc_error_retval = 127;
-	bb_error_msg_and_die("can't re-execute the shell");
+	bb_simple_error_msg_and_die("can't re-execute the shell");
 }
 #endif  /* !BB_MMU */
 
@@ -7919,7 +7919,7 @@ static void leave_var_nest_level(void)
 	G.var_nest_level--;
 	debug_printf_env("var_nest_level-- %u\n", G.var_nest_level);
 	if (HUSH_DEBUG && (int)G.var_nest_level < 0)
-		bb_error_msg_and_die("BUG: nesting underflow");
+		bb_simple_error_msg_and_die("BUG: nesting underflow");
 
 	remove_nested_vars();
 }
@@ -8776,7 +8776,7 @@ static int checkjobs(struct pipe *fg_pipe, pid_t waitfor_pid)
 		childpid = waitpid(-1, &status, attributes);
 		if (childpid <= 0) {
 			if (childpid && errno != ECHILD)
-				bb_perror_msg("waitpid");
+				bb_simple_perror_msg("waitpid");
 #if ENABLE_HUSH_FAST
 			else { /* Until next SIGCHLD, waitpid's are useless */
 				G.we_have_children = (childpid == 0);
@@ -9308,7 +9308,7 @@ static NOINLINE int run_pipe(struct pipe *pi)
 		argv_expanded = NULL;
 		if (command->pid < 0) { /* [v]fork failed */
 			/* Clearly indicate, was it fork or vfork */
-			bb_perror_msg(BB_MMU ? "vfork"+1 : "vfork");
+			bb_simple_perror_msg(BB_MMU ? "vfork"+1 : "vfork");
 		} else {
 			pi->alive_cmds++;
 #if ENABLE_HUSH_JOB
@@ -10617,7 +10617,7 @@ static int FAST_FUNC builtin_read(char **argv)
 	}
 
 	if ((uintptr_t)r > 1) {
-		bb_error_msg("%s", r);
+		bb_simple_error_msg(r);
 		r = (char*)(uintptr_t)1;
 	}
 
@@ -10862,7 +10862,7 @@ static int FAST_FUNC builtin_unset(char **argv)
 	if (opts == (unsigned)-1)
 		return EXIT_FAILURE;
 	if (opts == 3) {
-		bb_error_msg("unset: -v and -f are exclusive");
+		bb_simple_error_msg("unset: -v and -f are exclusive");
 		return EXIT_FAILURE;
 	}
 	argv += optind;
@@ -11025,7 +11025,7 @@ Test that VAR is a valid variable name?
 
 	optstring = *++argv;
 	if (!optstring || !(var = *++argv)) {
-		bb_error_msg("usage: getopts OPTSTRING VAR [ARGS]");
+		bb_simple_error_msg("usage: getopts OPTSTRING VAR [ARGS]");
 		return EXIT_FAILURE;
 	}
 
@@ -11254,7 +11254,7 @@ static int FAST_FUNC builtin_trap(char **argv)
 	}
 
 	if (!argv[1]) { /* no second arg */
-		bb_error_msg("trap: invalid arguments");
+		bb_simple_error_msg("trap: invalid arguments");
 		return EXIT_FAILURE;
 	}
 
@@ -11295,7 +11295,7 @@ static struct pipe *parse_jobspec(const char *str)
 		/* It is "%%", "%+" or "%" - current job */
 		jobnum = G.last_jobid;
 		if (jobnum == 0) {
-			bb_error_msg("no current job");
+			bb_simple_error_msg("no current job");
 			return NULL;
 		}
 	}
@@ -11372,7 +11372,7 @@ static int FAST_FUNC builtin_fg_bg(char **argv)
 			delete_finished_job(pi);
 			return EXIT_SUCCESS;
 		}
-		bb_perror_msg("kill (SIGCONT)");
+		bb_simple_perror_msg("kill (SIGCONT)");
 	}
 
 	if (argv[0][0] == 'f') {
diff --git a/shell/shell_common.c b/shell/shell_common.c
index e0582adfb..a93533903 100644
--- a/shell/shell_common.c
+++ b/shell/shell_common.c
@@ -619,7 +619,7 @@ shell_builtin_ulimit(char **argv)
 				limit.rlim_cur = val;
 //bb_error_msg("setrlimit(%d, %lld, %lld)", limits_tbl[i].cmd, (long long)limit.rlim_cur, (long long)limit.rlim_max);
 			if (setrlimit(limits_tbl[i].cmd, &limit) < 0) {
-				bb_perror_msg("error setting limit");
+				bb_simple_perror_msg("error setting limit");
 				return EXIT_FAILURE;
 			}
 		}
diff --git a/sysklogd/klogd.c b/sysklogd/klogd.c
index 17b6ca235..bdd0b6325 100644
--- a/sysklogd/klogd.c
+++ b/sysklogd/klogd.c
@@ -244,7 +244,7 @@ int klogd_main(int argc UNUSED_PARAM, char **argv)
 		if (n < 0) {
 			if (errno == EINTR)
 				continue;
-			bb_perror_msg(READ_ERROR);
+			bb_simple_perror_msg(READ_ERROR);
 			break;
 		}
 		start[n] = '\0';
diff --git a/sysklogd/logread.c b/sysklogd/logread.c
index ea41fc0c8..1e1f1347f 100644
--- a/sysklogd/logread.c
+++ b/sysklogd/logread.c
@@ -88,7 +88,7 @@ static void error_exit(const char *str)
 }
 #else
 /* On Linux, shmdt is not mandatory on exit */
-# define error_exit(str) bb_perror_msg_and_die(str)
+# define error_exit(str) bb_simple_perror_msg_and_die(str)
 #endif
 
 /*
diff --git a/sysklogd/syslogd.c b/sysklogd/syslogd.c
index d0dd1bd20..0e226124a 100644
--- a/sysklogd/syslogd.c
+++ b/sysklogd/syslogd.c
@@ -572,12 +572,12 @@ static void ipcsyslog_init(void)
 
 	G.shmid = shmget(KEY_ID, G.shm_size, IPC_CREAT | 0644);
 	if (G.shmid == -1) {
-		bb_perror_msg_and_die("shmget");
+		bb_simple_perror_msg_and_die("shmget");
 	}
 
 	G.shbuf = shmat(G.shmid, NULL, 0);
 	if (G.shbuf == (void*) -1L) { /* shmat has bizarre error return */
-		bb_perror_msg_and_die("shmat");
+		bb_simple_perror_msg_and_die("shmat");
 	}
 
 	memset(G.shbuf, 0, G.shm_size);
@@ -592,7 +592,7 @@ static void ipcsyslog_init(void)
 			if (G.s_semid != -1)
 				return;
 		}
-		bb_perror_msg_and_die("semget");
+		bb_simple_perror_msg_and_die("semget");
 	}
 }
 
@@ -603,7 +603,7 @@ static void log_to_shmem(const char *msg)
 	int len;
 
 	if (semop(G.s_semid, G.SMwdn, 3) == -1) {
-		bb_perror_msg_and_die("SMwdn");
+		bb_simple_perror_msg_and_die("SMwdn");
 	}
 
 	/* Circular Buffer Algorithm:
@@ -631,7 +631,7 @@ static void log_to_shmem(const char *msg)
 		goto again;
 	}
 	if (semop(G.s_semid, G.SMwup, 1) == -1) {
-		bb_perror_msg_and_die("SMwup");
+		bb_simple_perror_msg_and_die("SMwup");
 	}
 	if (DEBUG)
 		printf("tail:%d\n", G.shbuf->tail);
diff --git a/util-linux/acpid.c b/util-linux/acpid.c
index 7274b6866..95f8150e2 100644
--- a/util-linux/acpid.c
+++ b/util-linux/acpid.c
@@ -148,7 +148,7 @@ static void process_event(const char *event)
 	const char *args[] = { "run-parts", handler, NULL };
 
 	// log the event
-	bb_error_msg("%s", event);
+	bb_simple_error_msg(event);
 
 	// spawn handler
 	// N.B. run-parts would require scripts to have #!/bin/sh
diff --git a/util-linux/dmesg.c b/util-linux/dmesg.c
index b797c7b2a..a1f269142 100644
--- a/util-linux/dmesg.c
+++ b/util-linux/dmesg.c
@@ -74,7 +74,7 @@ int dmesg_main(int argc UNUSED_PARAM, char **argv)
 	opts = getopt32(argv, "cs:+n:+r", &len, &level);
 	if (opts & OPT_n) {
 		if (klogctl(8, NULL, (long) level))
-			bb_perror_msg_and_die("klogctl");
+			bb_simple_perror_msg_and_die("klogctl");
 		return EXIT_SUCCESS;
 	}
 
@@ -88,7 +88,7 @@ int dmesg_main(int argc UNUSED_PARAM, char **argv)
 	buf = xmalloc(len);
 	len = klogctl(3 + (opts & OPT_c), buf, len); /* read ring buffer */
 	if (len < 0)
-		bb_perror_msg_and_die("klogctl");
+		bb_simple_perror_msg_and_die("klogctl");
 	if (len == 0)
 		return EXIT_SUCCESS;
 
diff --git a/util-linux/eject.c b/util-linux/eject.c
index 749e2c986..3ccb4ae89 100644
--- a/util-linux/eject.c
+++ b/util-linux/eject.c
@@ -70,7 +70,7 @@ static void eject_scsi(const char *dev)
 	sg_io_hdr_t io_hdr;
 
 	if ((ioctl(dev_fd, SG_GET_VERSION_NUM, &i) < 0) || (i < 30000))
-		bb_error_msg_and_die("not a sg device or old sg driver");
+		bb_simple_error_msg_and_die("not a sg device or old sg driver");
 
 	memset(&io_hdr, 0, sizeof(sg_io_hdr_t));
 	io_hdr.interface_id = 'S';
diff --git a/util-linux/fdformat.c b/util-linux/fdformat.c
index ff3bc4870..e1c8561d6 100644
--- a/util-linux/fdformat.c
+++ b/util-linux/fdformat.c
@@ -117,7 +117,7 @@ int fdformat_main(int argc UNUSED_PARAM, char **argv)
 			read_bytes = safe_read(fd, data, n);
 			if (read_bytes != n) {
 				if (read_bytes < 0) {
-					bb_perror_msg(bb_msg_read_error);
+					bb_simple_perror_msg(bb_msg_read_error);
 				}
 				bb_error_msg_and_die("problem reading cylinder %d, "
 					"expected %d, read %d", cyl, n, read_bytes);
diff --git a/util-linux/fdisk.c b/util-linux/fdisk.c
index 58e93bb92..f28d4fdd2 100644
--- a/util-linux/fdisk.c
+++ b/util-linux/fdisk.c
@@ -511,7 +511,7 @@ static sector_t bb_BLKGETSIZE_sectors(int fd)
 			 * we support can't record more than 32 bit
 			 * sector counts or offsets
 			 */
-			bb_error_msg("device has more than 2^32 sectors, can't use all of them");
+			bb_simple_error_msg("device has more than 2^32 sectors, can't use all of them");
 			v64 = (uint32_t)-1L;
 		}
 		return v64;
diff --git a/util-linux/flock.c b/util-linux/flock.c
index 130627e93..12c16013c 100644
--- a/util-linux/flock.c
+++ b/util-linux/flock.c
@@ -73,7 +73,7 @@ int flock_main(int argc UNUSED_PARAM, char **argv)
 	) {
 		argv++;
 		if (argv[1])
-			bb_error_msg_and_die("-c takes only one argument");
+			bb_simple_error_msg_and_die("-c takes only one argument");
 		opt |= OPT_c;
 	}
 
diff --git a/util-linux/fsck_minix.c b/util-linux/fsck_minix.c
index f523da945..40b86d01b 100644
--- a/util-linux/fsck_minix.c
+++ b/util-linux/fsck_minix.c
@@ -321,7 +321,7 @@ static void die(const char *str)
 {
 	if (termios_set)
 		tcsetattr_stdin_TCSANOW(&sv_termios);
-	bb_error_msg_and_die("%s", str);
+	bb_simple_error_msg_and_die(str);
 }
 
 static void push_filename(const char *name)
diff --git a/util-linux/getopt.c b/util-linux/getopt.c
index 1666d3d30..db7db6ff8 100644
--- a/util-linux/getopt.c
+++ b/util-linux/getopt.c
@@ -308,7 +308,7 @@ static struct option *add_long_options(struct option *long_options, char *option
 				}
 				tokptr[tlen] = '\0';
 				if (tlen == 0)
-					bb_error_msg_and_die("empty long option specified");
+					bb_simple_error_msg_and_die("empty long option specified");
 			}
 			long_options = xrealloc_vector(long_options, 4, long_nr);
 			long_options[long_nr].has_arg = arg_opt;
@@ -380,7 +380,7 @@ int getopt_main(int argc, char **argv)
 			puts(" --");
 			return 0;
 		}
-		bb_error_msg_and_die("missing optstring argument");
+		bb_simple_error_msg_and_die("missing optstring argument");
 	}
 
 	if (argv[1][0] != '-' || compatible) {
@@ -416,7 +416,7 @@ int getopt_main(int argc, char **argv)
 	if (!optstr) {
 		optstr = argv[++n];
 		if (!optstr)
-			bb_error_msg_and_die("missing optstring argument");
+			bb_simple_error_msg_and_die("missing optstring argument");
 	}
 
 	argv[n] = name ? name : argv[0];
diff --git a/util-linux/hwclock.c b/util-linux/hwclock.c
index 29f51021e..dc97d8fb4 100644
--- a/util-linux/hwclock.c
+++ b/util-linux/hwclock.c
@@ -132,7 +132,7 @@ static void to_sys_clock(const char **pp_rtcname, int utc)
 	tv.tv_sec = read_rtc(pp_rtcname, NULL, utc);
 	tv.tv_usec = 0;
 	if (settimeofday(&tv, &tz))
-		bb_perror_msg_and_die("settimeofday");
+		bb_simple_perror_msg_and_die("settimeofday");
 }
 
 static void from_sys_clock(const char **pp_rtcname, int utc)
@@ -284,7 +284,7 @@ static void set_system_clock_timezone(int utc)
 	if (!utc)
 		tv.tv_sec += tz.tz_minuteswest * 60;
 	if (settimeofday(&tv, &tz))
-		bb_perror_msg_and_die("settimeofday");
+		bb_simple_perror_msg_and_die("settimeofday");
 }
 
 //usage:#define hwclock_trivial_usage
diff --git a/util-linux/ipcs.c b/util-linux/ipcs.c
index 4863a5c29..df86cfb9d 100644
--- a/util-linux/ipcs.c
+++ b/util-linux/ipcs.c
@@ -467,7 +467,7 @@ static void print_shm(int shmid)
 	struct ipc_perm *ipcp = &shmds.shm_perm;
 
 	if (shmctl(shmid, IPC_STAT, &shmds) == -1) {
-		bb_perror_msg("shmctl");
+		bb_simple_perror_msg("shmctl");
 		return;
 	}
 
@@ -493,7 +493,7 @@ static void print_msg(int msqid)
 	struct ipc_perm *ipcp = &buf.msg_perm;
 
 	if (msgctl(msqid, IPC_STAT, &buf) == -1) {
-		bb_perror_msg("msgctl");
+		bb_simple_perror_msg("msgctl");
 		return;
 	}
 
@@ -527,7 +527,7 @@ static void print_sem(int semid)
 
 	arg.buf = &semds;
 	if (semctl(semid, 0, IPC_STAT, arg)) {
-		bb_perror_msg("semctl");
+		bb_simple_perror_msg("semctl");
 		return;
 	}
 
@@ -555,7 +555,7 @@ static void print_sem(int semid)
 		zcnt = semctl(semid, i, GETZCNT, arg);
 		pid = semctl(semid, i, GETPID, arg);
 		if (val < 0 || ncnt < 0 || zcnt < 0 || pid < 0) {
-			bb_perror_msg_and_die("semctl");
+			bb_simple_perror_msg_and_die("semctl");
 		}
 		printf("%-10u %-10d %-10d %-10d %-10d\n", i, val, ncnt, zcnt, pid);
 	}
diff --git a/util-linux/last.c b/util-linux/last.c
index 689aa7a34..24ce7a8d8 100644
--- a/util-linux/last.c
+++ b/util-linux/last.c
@@ -100,7 +100,7 @@ int last_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 	pos = lseek(file, pos - sizeof(ut), SEEK_SET);
 	while ((n = full_read(file, &ut, sizeof(ut))) > 0) {
 		if (n != sizeof(ut)) {
-			bb_perror_msg_and_die("short read");
+			bb_simple_perror_msg_and_die("short read");
 		}
 		n = index_in_strings(_ut_lin, ut.ut_line);
 		if (n == _TILDE) { /* '~' */
diff --git a/util-linux/losetup.c b/util-linux/losetup.c
index 5dc757074..cc6c2b1d5 100644
--- a/util-linux/losetup.c
+++ b/util-linux/losetup.c
@@ -118,13 +118,13 @@ int losetup_main(int argc UNUSED_PARAM, char **argv)
 
 		n = get_free_loop();
 		if (n == -1)
-			bb_error_msg_and_die("no free loop devices");
+			bb_simple_error_msg_and_die("no free loop devices");
 		if (n < 0) /* n == -2: no /dev/loop-control, use legacy method */
 			n = 0;
 		/* or: n >= 0: the number of next free loopdev, just verify it */
 		do {
 			if (n > MAX_LOOP_NUM)
-				bb_error_msg_and_die("no free loop devices");
+				bb_simple_error_msg_and_die("no free loop devices");
 			sprintf(dev, LOOP_FORMAT, n++);
 			s = query_loop(dev);
 			free(s);
diff --git a/util-linux/mdev.c b/util-linux/mdev.c
index 9cb3586f1..207a112c1 100644
--- a/util-linux/mdev.c
+++ b/util-linux/mdev.c
@@ -250,18 +250,24 @@
 
 #if DEBUG_LVL >= 1
 # define dbg1(...) do { if (G.verbose) bb_error_msg(__VA_ARGS__); } while(0)
+# define dbg1s(msg) do { if (G.verbose) bb_simple_error_msg(msg); } while(0)
 #else
 # define dbg1(...) ((void)0)
+# define dbg1s(msg) ((void)0)
 #endif
 #if DEBUG_LVL >= 2
 # define dbg2(...) do { if (G.verbose >= 2) bb_error_msg(__VA_ARGS__); } while(0)
+# define dbg2s(msg) do { if (G.verbose >= 2) bb_simple_error_msg(msg); } while(0)
 #else
 # define dbg2(...) ((void)0)
+# define dbg2s(msg) ((void)0)
 #endif
 #if DEBUG_LVL >= 3
 # define dbg3(...) do { if (G.verbose >= 3) bb_error_msg(__VA_ARGS__); } while(0)
+# define dbg3s(msg) do { if (G.verbose >= 3) bb_simple_error_msg(msg); } while(0)
 #else
 # define dbg3(...) ((void)0)
+# define dbg3s(msg) ((void)0)
 #endif
 
 
@@ -1021,7 +1027,7 @@ wait_for_seqfile(unsigned expected_seq)
 			/* seed file: write out seq ASAP */
 			xwrite_str(seq_fd, utoa(expected_seq));
 			xlseek(seq_fd, 0, SEEK_SET);
-			dbg2("first seq written");
+			dbg2s("first seq written");
 			break;
 		}
 		seqbufnum = atoll(seqbuf);
@@ -1165,7 +1171,7 @@ static void daemon_loop(char *temp, int fd)
 
 		len = safe_read(fd, netbuf, sizeof(netbuf) - 1);
 		if (len < 0) {
-			bb_perror_msg_and_die("read");
+			bb_simple_perror_msg_and_die("read");
 		}
 		end = netbuf + len;
 		*end = '\0';
diff --git a/util-linux/mesg.c b/util-linux/mesg.c
index c7b696853..8c032555b 100644
--- a/util-linux/mesg.c
+++ b/util-linux/mesg.c
@@ -65,7 +65,7 @@ int mesg_main(int argc UNUSED_PARAM, char **argv)
 	 */
 
 	if (!isatty(STDIN_FILENO))
-		bb_error_msg_and_die("not a tty");
+		bb_simple_error_msg_and_die("not a tty");
 
 	xfstat(STDIN_FILENO, &sb, "stdin");
 	if (c == 0) {
diff --git a/util-linux/mkfs_ext2.c b/util-linux/mkfs_ext2.c
index 845ba0a24..d568f4be5 100644
--- a/util-linux/mkfs_ext2.c
+++ b/util-linux/mkfs_ext2.c
@@ -266,7 +266,7 @@ int mkfs_ext2_main(int argc UNUSED_PARAM, char **argv)
 	// N.B. what if we format a file? find_mount_point will return false negative since
 	// it is loop block device which is mounted!
 	if (find_mount_point(argv[0], 0))
-		bb_error_msg_and_die("can't format mounted filesystem");
+		bb_simple_error_msg_and_die("can't format mounted filesystem");
 
 	// get size in kbytes
 	kilobytes = get_volume_size_in_bytes(fd, argv[1], 1024, /*extend:*/ !(option_mask32 & OPT_n)) / 1024;
@@ -326,11 +326,11 @@ int mkfs_ext2_main(int argc UNUSED_PARAM, char **argv)
 	kilobytes >>= (blocksize_log2 - EXT2_MIN_BLOCK_LOG_SIZE);
 	nblocks = kilobytes;
 	if (nblocks != kilobytes)
-		bb_error_msg_and_die("block count doesn't fit in 32 bits");
+		bb_simple_error_msg_and_die("block count doesn't fit in 32 bits");
 #define kilobytes kilobytes_unused_after_this
 	// Experimentally, standard mke2fs won't work on images smaller than 60k
 	if (nblocks < 60)
-		bb_error_msg_and_die("need >= 60 blocks");
+		bb_simple_error_msg_and_die("need >= 60 blocks");
 
 	// How many reserved blocks?
 	if (reserved_percent > 50)
diff --git a/util-linux/mkfs_minix.c b/util-linux/mkfs_minix.c
index e191acbd0..8f791cf66 100644
--- a/util-linux/mkfs_minix.c
+++ b/util-linux/mkfs_minix.c
@@ -262,7 +262,7 @@ static int get_free_block(void)
 	int blk;
 
 	if (G.used_good_blocks + 1 >= MAX_GOOD_BLOCKS)
-		bb_error_msg_and_die("too many bad blocks");
+		bb_simple_error_msg_and_die("too many bad blocks");
 	if (G.used_good_blocks)
 		blk = G.good_blocks_table[G.used_good_blocks - 1] + 1;
 	else
@@ -270,7 +270,7 @@ static int get_free_block(void)
 	while (blk < SB_ZONES && zone_in_use(blk))
 		blk++;
 	if (blk >= SB_ZONES)
-		bb_error_msg_and_die("not enough good blocks");
+		bb_simple_error_msg_and_die("not enough good blocks");
 	G.good_blocks_table[G.used_good_blocks] = blk;
 	G.used_good_blocks++;
 	return blk;
@@ -342,7 +342,7 @@ static void make_bad_inode(void)
 				goto end_bad;
 		}
 	}
-	bb_error_msg_and_die("too many bad blocks");
+	bb_simple_error_msg_and_die("too many bad blocks");
  end_bad:
 	if (ind)
 		write_block(ind, (char *) ind_block);
@@ -398,7 +398,7 @@ static void make_bad_inode2(void)
 		}
 	}
 	/* Could make triple indirect block here */
-	bb_error_msg_and_die("too many bad blocks");
+	bb_simple_error_msg_and_die("too many bad blocks");
  end_bad:
 	if (ind)
 		write_block(ind, (char *) ind_block);
@@ -514,7 +514,7 @@ static void check_blocks(void)
 		if (got == try)
 			continue;
 		if (G.currently_testing < SB_FIRSTZONE)
-			bb_error_msg_and_die("bad blocks before data-area: cannot make fs");
+			bb_simple_error_msg_and_die("bad blocks before data-area: cannot make fs");
 		mark_zone(G.currently_testing);
 		G.badblocks++;
 		G.currently_testing++;
@@ -588,7 +588,7 @@ static void setup_tables(void)
 		SB_ZMAPS = sb_zmaps;
 		/* new SB_ZMAPS, need to recalc NORM_FIRSTZONE */
 	} while (--i);
-	bb_error_msg_and_die("incompatible size/inode count, try different -i N");
+	bb_simple_error_msg_and_die("incompatible size/inode count, try different -i N");
  got_it:
 
 	SB_FIRSTZONE = norm_firstzone;
@@ -623,10 +623,10 @@ int mkfs_minix_main(int argc UNUSED_PARAM, char **argv)
 	G.magic = MINIX1_SUPER_MAGIC2;
 
 	if (INODE_SIZE1 * MINIX1_INODES_PER_BLOCK != BLOCK_SIZE)
-		bb_error_msg_and_die("bad inode size");
+		bb_simple_error_msg_and_die("bad inode size");
 #if ENABLE_FEATURE_MINIX2
 	if (INODE_SIZE2 * MINIX2_INODES_PER_BLOCK != BLOCK_SIZE)
-		bb_error_msg_and_die("bad inode size");
+		bb_simple_error_msg_and_die("bad inode size");
 #endif
 
 	opt = getopt32(argv, "ci:l:n:+v", &str_i, &listfile, &G.namelen);
@@ -644,7 +644,7 @@ int mkfs_minix_main(int argc UNUSED_PARAM, char **argv)
 #if ENABLE_FEATURE_MINIX2
 		version2 = 1;
 #else
-		bb_error_msg_and_die("not compiled with minix v2 support");
+		bb_simple_error_msg_and_die("not compiled with minix v2 support");
 #endif
 	}
 
@@ -654,14 +654,14 @@ int mkfs_minix_main(int argc UNUSED_PARAM, char **argv)
 
 	/* Check if it is mounted */
 	if (find_mount_point(G.device_name, 0))
-		bb_error_msg_and_die("can't format mounted filesystem");
+		bb_simple_error_msg_and_die("can't format mounted filesystem");
 
 	xmove_fd(xopen(G.device_name, O_RDWR), dev_fd);
 
 	G.total_blocks = get_volume_size_in_bytes(dev_fd, argv[1], 1024, /*extend:*/ 1) / 1024;
 
 	if (G.total_blocks < 10)
-		bb_error_msg_and_die("must have at least 10 blocks");
+		bb_simple_error_msg_and_die("must have at least 10 blocks");
 
 	if (version2) {
 		G.magic = MINIX2_SUPER_MAGIC2;
diff --git a/util-linux/mkfs_reiser.c b/util-linux/mkfs_reiser.c
index b4c8dda6f..d2eaf5f94 100644
--- a/util-linux/mkfs_reiser.c
+++ b/util-linux/mkfs_reiser.c
@@ -178,7 +178,7 @@ int mkfs_reiser_main(int argc UNUSED_PARAM, char **argv)
 	// N.B. what if we format a file? find_mount_point will return false negative since
 	// it is loop block device which is mounted!
 	if (find_mount_point(argv[0], 0))
-		bb_error_msg_and_die("can't format mounted filesystem");
+		bb_simple_error_msg_and_die("can't format mounted filesystem");
 
 	// open the device, get size in blocks
 	blocks = get_volume_size_in_bytes(fd, argv[1], blocksize, /*extend:*/ 1) / blocksize;
diff --git a/util-linux/mkfs_vfat.c b/util-linux/mkfs_vfat.c
index b760fb2aa..16c1fac00 100644
--- a/util-linux/mkfs_vfat.c
+++ b/util-linux/mkfs_vfat.c
@@ -278,7 +278,7 @@ int mkfs_vfat_main(int argc UNUSED_PARAM, char **argv)
 	if (!S_ISBLK(st.st_mode)) {
 		if (!S_ISREG(st.st_mode)) {
 			if (!argv[1])
-				bb_error_msg_and_die("image size must be specified");
+				bb_simple_error_msg_and_die("image size must be specified");
 		}
 		// not a block device, skip bad sectors check
 		opts &= ~OPT_c;
@@ -399,7 +399,7 @@ int mkfs_vfat_main(int argc UNUSED_PARAM, char **argv)
 	// "mkdosfs -v -F 32 image5k 5" is the minimum:
 	// 2 sectors for FATs and 2 data sectors
 	if ((off_t)(volume_size_sect - reserved_sect) < 4)
-		bb_error_msg_and_die("the image is too small for FAT32");
+		bb_simple_error_msg_and_die("the image is too small for FAT32");
 	sect_per_fat = 1;
 	while (1) {
 		while (1) {
@@ -439,7 +439,7 @@ int mkfs_vfat_main(int argc UNUSED_PARAM, char **argv)
 		}
  next:
 		if (sect_per_clust == 128)
-			bb_error_msg_and_die("can't make FAT32 with >128 sectors/cluster");
+			bb_simple_error_msg_and_die("can't make FAT32 with >128 sectors/cluster");
 		sect_per_clust *= 2;
 		sect_per_fat = (sect_per_fat / 2) | 1;
 	}
diff --git a/util-linux/mkswap.c b/util-linux/mkswap.c
index 38413606d..9e51a1dcc 100644
--- a/util-linux/mkswap.c
+++ b/util-linux/mkswap.c
@@ -75,7 +75,7 @@ static void mkswap_selinux_setcontext(int fd, const char *path)
 	}
 	return;
  error:
-	bb_perror_msg_and_die("SELinux relabeling failed");
+	bb_simple_perror_msg_and_die("SELinux relabeling failed");
 }
 #else
 # define mkswap_selinux_setcontext(fd, path) ((void)0)
diff --git a/util-linux/mount.c b/util-linux/mount.c
index e6bad7c2c..84c85c057 100644
--- a/util-linux/mount.c
+++ b/util-linux/mount.c
@@ -483,7 +483,7 @@ static void FAST_FUNC update_mtab_entry_on_move(const struct mntent *mp)
 
 	mountTable = setmntent(bb_path_mtab_file, "r");
 	if (!mountTable) {
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 		return;
 	}
 
@@ -511,7 +511,7 @@ static void FAST_FUNC update_mtab_entry_on_move(const struct mntent *mp)
 		}
 		endmntent(mountTable);
 	} else if (errno != EROFS)
-		bb_perror_msg(bb_path_mtab_file);
+		bb_simple_perror_msg(bb_path_mtab_file);
 
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		for (i = 0; i < count; i++) {
@@ -739,7 +739,7 @@ static int mount_it_now(struct mntent *mp, unsigned long vfsflags, char *filtero
 	// Abort entirely if permission denied.
 
 	if (rc && errno == EPERM)
-		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
+		bb_simple_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 
 	// If the mount was successful, and we're maintaining an old-style
 	// mtab file by hand, add the new entry to it now.
@@ -751,7 +751,7 @@ static int mount_it_now(struct mntent *mp, unsigned long vfsflags, char *filtero
 		int i;
 
 		if (!mountTable) {
-			bb_perror_msg(bb_path_mtab_file);
+			bb_simple_perror_msg(bb_path_mtab_file);
 			goto ret;
 		}
 
@@ -1288,18 +1288,18 @@ static NOINLINE int nfsmount(struct mntent *mp, unsigned long vfsflags, char *fi
 	s = strchr(hostname, ',');
 	if (s) {
 		*s = '\0';
-		bb_error_msg("warning: multiple hostnames not supported");
+		bb_simple_error_msg("warning: multiple hostnames not supported");
 	}
 
 	server_addr.sin_family = AF_INET;
 	if (!inet_aton(hostname, &server_addr.sin_addr)) {
 		hp = gethostbyname(hostname);
 		if (hp == NULL) {
-			bb_herror_msg("%s", hostname);
+			bb_simple_herror_msg(hostname);
 			goto fail;
 		}
 		if (hp->h_length != (int)sizeof(struct in_addr)) {
-			bb_error_msg_and_die("only IPv4 is supported");
+			bb_simple_error_msg_and_die("only IPv4 is supported");
 		}
 		memcpy(&server_addr.sin_addr, hp->h_addr_list[0], sizeof(struct in_addr));
 	}
@@ -1389,7 +1389,7 @@ static NOINLINE int nfsmount(struct mntent *mp, unsigned long vfsflags, char *fi
 				else if (is_prefixed_with(opteq, "udp"))
 					tcp = 0;
 				else
-					bb_error_msg("warning: unrecognized proto= option");
+					bb_simple_error_msg("warning: unrecognized proto= option");
 				continue;
 			case 20: // "addr" - ignore
 				continue;
@@ -1522,7 +1522,7 @@ static NOINLINE int nfsmount(struct mntent *mp, unsigned long vfsflags, char *fi
 				if (nfs_mount_version >= 3)
 					nolock = !val;
 				else
-					bb_error_msg("warning: option nolock is not supported");
+					bb_simple_error_msg("warning: option nolock is not supported");
 				break;
 			case 11: //rdirplus
 				nordirplus = !val;
@@ -1590,11 +1590,11 @@ static NOINLINE int nfsmount(struct mntent *mp, unsigned long vfsflags, char *fi
 		} else {
 			hp = gethostbyname(mounthost);
 			if (hp == NULL) {
-				bb_herror_msg("%s", mounthost);
+				bb_simple_herror_msg(mounthost);
 				goto fail;
 			}
 			if (hp->h_length != (int)sizeof(struct in_addr)) {
-				bb_error_msg_and_die("only IPv4 is supported");
+				bb_simple_error_msg_and_die("only IPv4 is supported");
 			}
 			mount_server_addr.sin_family = AF_INET;
 			memcpy(&mount_server_addr.sin_addr, hp->h_addr_list[0], sizeof(struct in_addr));
@@ -1767,18 +1767,18 @@ static NOINLINE int nfsmount(struct mntent *mp, unsigned long vfsflags, char *fi
 	/* Create nfs socket for kernel */
 	if (tcp) {
 		if (nfs_mount_version < 3) {
-			bb_error_msg("NFS over TCP is not supported");
+			bb_simple_error_msg("NFS over TCP is not supported");
 			goto fail;
 		}
 		fsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
 	} else
 		fsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 	if (fsock < 0) {
-		bb_perror_msg("nfs socket");
+		bb_simple_perror_msg("nfs socket");
 		goto fail;
 	}
 	if (bindresvport(fsock, 0) < 0) {
-		bb_perror_msg("nfs bindresvport");
+		bb_simple_perror_msg("nfs bindresvport");
 		goto fail;
 	}
 	if (port == 0) {
@@ -2047,9 +2047,9 @@ static int singlemount(struct mntent *mp, int ignore_busy)
 			);
 			if (loopfd < 0) {
 				if (errno == EPERM || errno == EACCES)
-					bb_error_msg(bb_msg_perm_denied_are_you_root);
+					bb_simple_error_msg(bb_msg_perm_denied_are_you_root);
 				else
-					bb_perror_msg("can't setup loop device");
+					bb_simple_perror_msg("can't setup loop device");
 				return errno;
 			}
 
@@ -2255,7 +2255,7 @@ int mount_main(int argc UNUSED_PARAM, char **argv)
 		// argument when we get it.
 		if (argv[1]) {
 			if (nonroot)
-				bb_error_msg_and_die(bb_msg_you_must_be_root);
+				bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 			mtpair->mnt_fsname = argv[0];
 			mtpair->mnt_dir = argv[1];
 			mtpair->mnt_type = fstype;
@@ -2272,7 +2272,7 @@ int mount_main(int argc UNUSED_PARAM, char **argv)
 
 	cmdopt_flags = parse_mount_options(cmdopts, NULL);
 	if (nonroot && (cmdopt_flags & ~MS_SILENT)) // Non-root users cannot specify flags
-		bb_error_msg_and_die(bb_msg_you_must_be_root);
+		bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 
 	// If we have a shared subtree flag, don't worry about fstab or mtab.
 	if (ENABLE_FEATURE_MOUNT_FLAGS
@@ -2337,7 +2337,7 @@ int mount_main(int argc UNUSED_PARAM, char **argv)
 			// No, mount -a won't mount anything,
 			// even user mounts, for mere humans
 			if (nonroot)
-				bb_error_msg_and_die(bb_msg_you_must_be_root);
+				bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 
 			// Does type match? (NULL matches always)
 			if (!fstype_matches(mtcur->mnt_type, fstype))
@@ -2417,7 +2417,7 @@ int mount_main(int argc UNUSED_PARAM, char **argv)
 			// fstab must have "users" or "user"
 			l = parse_mount_options(mtcur->mnt_opts, NULL);
 			if (!(l & MOUNT_USERS))
-				bb_error_msg_and_die(bb_msg_you_must_be_root);
+				bb_simple_error_msg_and_die(bb_msg_you_must_be_root);
 		}
 
 		//util-linux-2.12 does not do this check.
diff --git a/util-linux/nsenter.c b/util-linux/nsenter.c
index 4eeaa9f3e..304f2d748 100644
--- a/util-linux/nsenter.c
+++ b/util-linux/nsenter.c
@@ -257,7 +257,7 @@ int nsenter_main(int argc UNUSED_PARAM, char **argv)
 
 	if (opts & OPT_setgid) {
 		if (setgroups(0, NULL) < 0 && setgroups_failed)
-			bb_perror_msg_and_die("setgroups");
+			bb_simple_perror_msg_and_die("setgroups");
 		xsetgid(gid);
 	}
 	if (opts & OPT_setuid)
diff --git a/util-linux/rdate.c b/util-linux/rdate.c
index 70f829e7f..41aade5ea 100644
--- a/util-linux/rdate.c
+++ b/util-linux/rdate.c
@@ -33,7 +33,7 @@ enum { RFC_868_BIAS = 2208988800UL };
 
 static void socket_timeout(int sig UNUSED_PARAM)
 {
-	bb_error_msg_and_die("timeout connecting to time server");
+	bb_simple_error_msg_and_die("timeout connecting to time server");
 }
 
 static time_t askremotedate(const char *host)
@@ -94,10 +94,10 @@ int rdate_main(int argc UNUSED_PARAM, char **argv)
 
 	if (!(flags & 2)) { /* no -p (-s may be present) */
 		if (time(NULL) == remote_time)
-			bb_error_msg("current time matches remote time");
+			bb_simple_error_msg("current time matches remote time");
 		else
 			if (stime(&remote_time) < 0)
-				bb_perror_msg_and_die("can't set time of day");
+				bb_simple_perror_msg_and_die("can't set time of day");
 	}
 
 	if (flags != 1) /* not lone -s */
diff --git a/util-linux/readprofile.c b/util-linux/readprofile.c
index cab2c4319..c4ea374be 100644
--- a/util-linux/readprofile.c
+++ b/util-linux/readprofile.c
@@ -142,7 +142,7 @@ int readprofile_main(int argc UNUSED_PARAM, char **argv)
 				small++;
 		}
 		if (big > small) {
-			bb_error_msg("assuming reversed byte order, "
+			bb_simple_error_msg("assuming reversed byte order, "
 				"use -n to force native byte order");
 			BUILD_BUG_ON(sizeof(*p) > 8);
 			for (p = buf; p < buf+len; p++) {
@@ -204,7 +204,7 @@ int readprofile_main(int argc UNUSED_PARAM, char **argv)
 		}
 
 		if (indx >= len)
-			bb_error_msg_and_die("profile address out of range. "
+			bb_simple_error_msg_and_die("profile address out of range. "
 					"Wrong map file?");
 
 		this = 0;
diff --git a/util-linux/rtcwake.c b/util-linux/rtcwake.c
index 29c440b82..cad0f9d64 100644
--- a/util-linux/rtcwake.c
+++ b/util-linux/rtcwake.c
@@ -230,7 +230,7 @@ int rtcwake_main(int argc UNUSED_PARAM, char **argv)
 		do {
 			ssize_t ret = safe_read(fd, &data, sizeof(data));
 			if (ret < 0) {
-				bb_perror_msg("rtc read");
+				bb_simple_perror_msg("rtc read");
 				break;
 			}
 		} while (!(data & RTC_AF));
diff --git a/util-linux/setpriv.c b/util-linux/setpriv.c
index b69b8cbb6..e5cf96957 100644
--- a/util-linux/setpriv.c
+++ b/util-linux/setpriv.c
@@ -164,7 +164,7 @@ static void set_inh_caps(char *capstring)
 	}
 
 	if (capset(&caps.header, caps.data) != 0)
-		bb_perror_msg_and_die("capset");
+		bb_simple_perror_msg_and_die("capset");
 }
 
 static void set_ambient_caps(char *string)
@@ -178,10 +178,10 @@ static void set_ambient_caps(char *string)
 		idx = parse_cap(cap);
 		if (cap[0] == '+') {
 			if (prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, idx, 0, 0) < 0)
-				bb_perror_msg("cap_ambient_raise");
+				bb_simple_perror_msg("cap_ambient_raise");
 		} else {
 			if (prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_LOWER, idx, 0, 0) < 0)
-				bb_perror_msg("cap_ambient_lower");
+				bb_simple_perror_msg("cap_ambient_lower");
 		}
 		cap = strtok(NULL, ",");
 	}
@@ -236,7 +236,7 @@ static int dump(void)
 		unsigned idx = CAP_TO_INDEX(i);
 		if (idx >= caps.u32s) {
 			printf("\nindex: %u u32s: %u capability: %u\n", idx, caps.u32s, i);
-			bb_error_msg_and_die("unsupported capability");
+			bb_simple_error_msg_and_die("unsupported capability");
 		}
 		if (caps.data[idx].inheritable & CAP_TO_MASK(i)) {
 			printf_cap(fmt, i);
diff --git a/util-linux/switch_root.c b/util-linux/switch_root.c
index ae9d412d1..a483893ed 100644
--- a/util-linux/switch_root.c
+++ b/util-linux/switch_root.c
@@ -117,7 +117,7 @@ static void drop_capset(int cap_idx)
 	getcaps(&caps);
 	caps.data[CAP_TO_INDEX(cap_idx)].inheritable &= ~CAP_TO_MASK(cap_idx);
 	if (capset(&caps.header, caps.data) != 0)
-		bb_perror_msg_and_die("capset");
+		bb_simple_perror_msg_and_die("capset");
 }
 
 static void drop_bounding_set(int cap_idx)
@@ -253,7 +253,7 @@ int switch_root_main(int argc UNUSED_PARAM, char **argv)
 	if ((unsigned)stfs.f_type != RAMFS_MAGIC
 	 && (unsigned)stfs.f_type != TMPFS_MAGIC
 	) {
-		bb_error_msg_and_die("root filesystem is not ramfs/tmpfs");
+		bb_simple_error_msg_and_die("root filesystem is not ramfs/tmpfs");
 	}
 
 	if (!dry_run) {
@@ -263,7 +263,7 @@ int switch_root_main(int argc UNUSED_PARAM, char **argv)
 		// Overmount / with newdir and chroot into it
 		if (mount(".", "/", NULL, MS_MOVE, NULL)) {
 			// For example, fails when newroot is not a mountpoint
-			bb_perror_msg_and_die("error moving root");
+			bb_simple_perror_msg_and_die("error moving root");
 		}
 	}
 	xchroot(".");
diff --git a/util-linux/uevent.c b/util-linux/uevent.c
index 2f8990ed9..7a1d7d4a7 100644
--- a/util-linux/uevent.c
+++ b/util-linux/uevent.c
@@ -75,12 +75,12 @@ int uevent_main(int argc UNUSED_PARAM, char **argv)
 					MAP_PRIVATE | MAP_ANON,
 					/* ignored: */ -1, 0);
 		if (netbuf == MAP_FAILED)
-			bb_perror_msg_and_die("mmap");
+			bb_simple_perror_msg_and_die("mmap");
 
 		// Here we block, possibly for a very long time
 		len = safe_read(fd, netbuf, BUFFER_SIZE - 1);
 		if (len < 0)
-			bb_perror_msg_and_die("read");
+			bb_simple_perror_msg_and_die("read");
 		end = netbuf + len;
 		*end = '\0';
 
diff --git a/util-linux/unshare.c b/util-linux/unshare.c
index 61fc71197..a943e7b03 100644
--- a/util-linux/unshare.c
+++ b/util-linux/unshare.c
@@ -239,7 +239,7 @@ int unshare_main(int argc UNUSED_PARAM, char **argv)
 	if (setgrp_str) {
 		if (strcmp(setgrp_str, "allow") == 0) {
 			if (opts & OPT_map_root) {
-				bb_error_msg_and_die(
+				bb_simple_error_msg_and_die(
 					"--setgroups=allow and --map-root-user "
 					"are mutually exclusive"
 				);