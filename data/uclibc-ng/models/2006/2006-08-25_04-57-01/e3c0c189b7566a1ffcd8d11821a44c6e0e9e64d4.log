"2006-08-25 04:57:01 +0000"
diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
index 4eb7d0f4a..79851b39b 100644
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -1496,7 +1496,7 @@ config SUPPORT_LD_DEBUG_EARLY
 
 config UCLIBC_MALLOC_DEBUGGING
 	bool "Build malloc with debugging support"
-	depends MALLOC
+	depends MALLOC || MALLOC_STANDARD
 	default n
 	help
 	  Answer Y here to compile extra debugging support code into malloc.
diff --git a/libc/stdlib/malloc-standard/Makefile.in b/libc/stdlib/malloc-standard/Makefile.in
index 4a0a86661..3bbe93e08 100644
--- a/libc/stdlib/malloc-standard/Makefile.in
+++ b/libc/stdlib/malloc-standard/Makefile.in
@@ -5,11 +5,6 @@
 # Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
 #
 
-# Turn on malloc debugging if requested
-ifeq ($(UCLIBC_MALLOC_DEBUGGING),y)
-CFLAGS += -D__MALLOC_DEBUGGING
-endif
-
 # calloc.c can be found at uClibc/libc/stdlib/calloc.c
 # valloc.c can be found at uClibc/libc/stdlib/valloc.c
 CSRC := malloc.c calloc.c realloc.c free.c memalign.c mallopt.c mallinfo.c
diff --git a/libc/stdlib/malloc-standard/malloc.c b/libc/stdlib/malloc-standard/malloc.c
index b4b1216ed..7a87ffd36 100644
--- a/libc/stdlib/malloc-standard/malloc.c
+++ b/libc/stdlib/malloc-standard/malloc.c
@@ -33,7 +33,7 @@ struct malloc_state __malloc_state;  /* never directly referenced */
 /* forward declaration */
 static int __malloc_largebin_index(unsigned int sz);
 
-#ifdef __MALLOC_DEBUGGING
+#ifdef __UCLIBC_MALLOC_DEBUGGING__
 
 /*
   Debugging support
@@ -43,21 +43,21 @@ static int __malloc_largebin_index(unsigned int sz);
   programs.  This can be very effective (albeit in an annoying way)
   in helping track down dangling pointers.
 
-  If you compile with -D__MALLOC_DEBUGGING, a number of assertion checks are
+  If you compile with __UCLIBC_MALLOC_DEBUGGING__, a number of assertion checks are
   enabled that will catch more memory errors. You probably won't be
   able to make much sense of the actual assertion errors, but they
   should help you locate incorrectly overwritten memory.  The
   checking is fairly extensive, and will slow down execution
-  noticeably. Calling malloc_stats or mallinfo with __MALLOC_DEBUGGING set will
+  noticeably. Calling malloc_stats or mallinfo with __UCLIBC_MALLOC_DEBUGGING__ set will
   attempt to check every non-mmapped allocated and free chunk in the
   course of computing the summmaries. (By nature, mmapped regions
   cannot be checked very much automatically.)
 
-  Setting __MALLOC_DEBUGGING may also be helpful if you are trying to modify
+  Setting __UCLIBC_MALLOC_DEBUGGING__ may also be helpful if you are trying to modify
   this code. The assertions in the check routines spell out in more
   detail the assumptions and invariants underlying the algorithms.
 
-  Setting __MALLOC_DEBUGGING does NOT provide an automated mechanism for checking
+  Setting __UCLIBC_MALLOC_DEBUGGING__ does NOT provide an automated mechanism for checking
   that all accesses to malloced memory stay within their
   bounds. However, there are several add-ons and adaptations of this
   or other mallocs available that do this.
diff --git a/libc/stdlib/malloc-standard/malloc.h b/libc/stdlib/malloc-standard/malloc.h
index 453d69736..556aef4d7 100644
--- a/libc/stdlib/malloc-standard/malloc.h
+++ b/libc/stdlib/malloc-standard/malloc.h
@@ -925,7 +925,7 @@ extern struct malloc_state __malloc_state;  /* never directly referenced */
    At most one "call" to get_malloc_state is made per invocation of
    the public versions of malloc and free, but other routines
    that in turn invoke malloc and/or free may call more then once.
-   Also, it is called in check* routines if __MALLOC_DEBUGGING is set.
+   Also, it is called in check* routines if __UCLIBC_MALLOC_DEBUGGING__ is set.
 */
 
 #define get_malloc_state() (&(__malloc_state))
@@ -935,7 +935,7 @@ void   __malloc_consolidate(mstate) attribute_hidden;
 
 
 /* Debugging support */
-#if ! __MALLOC_DEBUGGING
+#ifndef __UCLIBC_MALLOC_DEBUGGING__
 
 #define check_chunk(P)
 #define check_free_chunk(P)