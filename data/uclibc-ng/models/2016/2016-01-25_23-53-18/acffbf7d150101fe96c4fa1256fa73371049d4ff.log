"2016-01-25 23:53:18 +0100"
diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
index 25b512677..3afc2912d 100644
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -70,8 +70,8 @@ config TARGET_cris
 config TARGET_h8300
 	bool "h8300"
 
-#config TARGET_hppa
-#	bool "hppa"
+config TARGET_hppa
+	bool "hppa"
 
 config TARGET_i386
 	bool "i386"
diff --git a/libc/sysdeps/linux/hppa/bits/atomic.h b/libc/sysdeps/linux/hppa/bits/atomic.h
index 0bf5a6a5f..9890af2f0 100644
--- a/libc/sysdeps/linux/hppa/bits/atomic.h
+++ b/libc/sysdeps/linux/hppa/bits/atomic.h
@@ -20,7 +20,7 @@
 #include <errno.h>
 #include <bits/kernel-features.h>
 
-#define ABORT_INSTRUCTION __asm__(__UCLIBC_ABORT_INSTRUCTION__)
+#define ABORT_INSTRUCTION __asm__("iitlbp %r0,(%sr0, %r0)")
 
 /* We need EFAULT, ENOSYS */
 #if !defined EFAULT && !defined ENOSYS
@@ -58,7 +58,6 @@ typedef uintmax_t uatomic_max_t;
 #define LWS_CLOBBER "r1", "r26", "r25", "r24", "r23", "r22", "r21", "r20", "r28", "r31", "memory"
 #define ASM_EAGAIN "11" 
 
-#if __ASSUME_LWS_CAS
 /* The only basic operation needed is compare and exchange.  */
 # define atomic_compare_and_exchange_val_acq(mem, newval, oldval) 	\
   ({									\
@@ -94,10 +93,6 @@ typedef uintmax_t uatomic_max_t;
      /* Return 1 if it was already acquired */				\
      (ret != oldval);							\
    })
-#else
-# error __ASSUME_LWS_CAS is required to build uClibc.
-#endif	
-/* __ASSUME_LWS_CAS */
 
 #endif
 /* _BITS_ATOMIC_H */
diff --git a/libc/sysdeps/linux/hppa/bits/mman.h b/libc/sysdeps/linux/hppa/bits/mman.h
index ca2787f7d..cbde4b8d4 100644
--- a/libc/sysdeps/linux/hppa/bits/mman.h
+++ b/libc/sysdeps/linux/hppa/bits/mman.h
@@ -1,5 +1,5 @@
 /* Definitions for POSIX memory map interface.  Linux/HPPA version.
-   Copyright (C) 1997, 1998, 2000, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1997-2015 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -13,19 +13,19 @@
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
+   License along with the GNU C Library.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
 #ifndef _SYS_MMAN_H
 # error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
 #endif
 
-/* these are basically taken from the kernel definitions */
+/* These are taken from the kernel definitions.  */
 
-#define PROT_READ	0x1		/* page can be read */
-#define PROT_WRITE	0x2		/* page can be written */
-#define PROT_EXEC	0x4		/* page can be executed */
-#define PROT_NONE	0x0		/* page can not be accessed */
+#define PROT_READ	0x1		/* Page can be read */
+#define PROT_WRITE	0x2		/* Page can be written */
+#define PROT_EXEC	0x4		/* Page can be executed */
+#define PROT_NONE	0x0		/* Page can not be accessed */
 #define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
 					   growsdown vma (mprotect only).  */
 #define PROT_GROWSUP	0x02000000	/* Extend change to start of
@@ -33,61 +33,83 @@
 
 #define MAP_SHARED	0x01		/* Share changes */
 #define MAP_PRIVATE	0x02		/* Changes are private */
-#define MAP_TYPE	0x03		/* Mask for type of mapping */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x03		/* Mask for type of mapping */
+#endif
+
+/* Other flags.  */
 #define MAP_FIXED	0x04		/* Interpret addr exactly */
-#define MAP_ANONYMOUS	0x10		/* don't use a file */
+#ifdef __USE_MISC
+# define MAP_FILE	0x0
+# define MAP_ANONYMOUS	0x10		/* Don't use a file */
+# define MAP_ANON	MAP_ANONYMOUS
+# define MAP_VARIABLE	0
+/* When MAP_HUGETLB is set bits [26:31] encode the log2 of the huge page size.  */
+# define MAP_HUGE_SHIFT	26
+# define MAP_HUGE_MASK	0x3f
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable */
+# define MAP_LOCKED	0x2000		/* Pages are locked */
+# define MAP_NORESERVE	0x4000		/* Don't check for reservations */
+# define MAP_GROWSDOWN	0x8000		/* Stack-like segment */
+# define MAP_POPULATE	0x10000		/* Populate (prefault) pagetables */
+# define MAP_NONBLOCK	0x20000		/* Do not block on IO */
+#endif
 
-#define MAP_DENYWRITE	0x0800		/* ETXTBSY */
-#define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
-#define MAP_LOCKED	0x2000		/* pages are locked */
-#define MAP_NORESERVE	0x4000		/* don't check for reservations */
-#define MAP_GROWSDOWN	0x8000		/* stack-like segment */
-#define MAP_POPULATE	0x10000		/* populate (prefault) pagetables */
-#define MAP_NONBLOCK	0x20000		/* do not block on IO */
-#define MAP_UNINITIALIZED 0x4000000     /* For anonymous mmap, memory could
-					  be uninitialized. */
+/* Flags to "msync"  */
+#define MS_SYNC		1		/* Synchronous memory sync */
+#define MS_ASYNC	2		/* Sync memory asynchronously */
+#define MS_INVALIDATE	4		/* Invalidate the caches */
 
-#define MS_SYNC		1		/* synchronous memory sync */
-#define MS_ASYNC	2		/* sync memory asynchronously */
-#define MS_INVALIDATE	4		/* invalidate the caches */
+/* Flags to "mlockall"  */
+#define MCL_CURRENT	1		/* Lock all current mappings */
+#define MCL_FUTURE	2		/* Lock all future mappings */
 
-#define MCL_CURRENT	1		/* lock all current mappings */
-#define MCL_FUTURE	2		/* lock all future mappings */
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE 1
+# define MREMAP_FIXED	2
+#endif
 
-/* Advice to "madvise" */
-#ifdef __USE_BSD
-# define MADV_NORMAL	  0	/* no further special treatment */
-# define MADV_RANDOM	  1	/* expect random page references */
-# define MADV_SEQUENTIAL  2	/* expect sequential page references */
-# define MADV_WILLNEED	  3	/* will need these pages */
-# define MADV_DONTNEED	  4	/* dont need these pages */
-# define MADV_SPACEAVAIL  5	/* insure that resources are reserved */
+/* Advice to "madvise"  */
+#ifdef __USE_MISC
+# define MADV_NORMAL	  0	/* No further special treatment */
+# define MADV_RANDOM	  1	/* Expect random page references */
+# define MADV_SEQUENTIAL  2	/* Expect sequential page references */
+# define MADV_WILLNEED	  3	/* Will need these pages */
+# define MADV_DONTNEED	  4	/* Dont need these pages */
+# define MADV_SPACEAVAIL  5	/* Insure that resources are reserved */
 # define MADV_VPS_PURGE	  6	/* Purge pages from VM page cache */
 # define MADV_VPS_INHERIT 7	/* Inherit parents page size */
 # define MADV_REMOVE	  9	/* Remove these pages and resources.  */
 # define MADV_DONTFORK	 10	/* Do not inherit across fork.  */
 # define MADV_DOFORK	 11	/* Do inherit across fork.  */
+# define MADV_MERGEABLE   65	/* KSM may merge identical pages */
+# define MADV_UNMERGEABLE 66	/* KSM may not merge identical pages */
 #endif
 
 /* The range 12-64 is reserved for page size specification. */
-#define MADV_4K_PAGES   12              /* Use 4K pages  */
-#define MADV_16K_PAGES  14              /* Use 16K pages */
-#define MADV_64K_PAGES  16              /* Use 64K pages */
-#define MADV_256K_PAGES 18              /* Use 256K pages */
-#define MADV_1M_PAGES   20              /* Use 1 Megabyte pages */
-#define MADV_4M_PAGES   22              /* Use 4 Megabyte pages */
-#define MADV_16M_PAGES  24              /* Use 16 Megabyte pages */
-#define MADV_64M_PAGES  26              /* Use 64 Megabyte pages */
-
-/* compatibility flags */
-#define MAP_ANON	MAP_ANONYMOUS
-#define MAP_FILE	0
-#define MAP_VARIABLE	0
-
-/* Flags for `mremap'.  */
-#ifdef __USE_GNU
-# define MREMAP_MAYMOVE 1
-# define MREMAP_FIXED	2
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MADV_4K_PAGES		12	/* Use 4K pages.  */
+# define MADV_16K_PAGES		14	/* Use 16K pages.  */
+# define MADV_64K_PAGES		16	/* Use 64K pages.  */
+# define MADV_256K_PAGES	18	/* Use 256K pages.  */
+# define MADV_1M_PAGES		20	/* Use 1 Megabyte pages.  */
+# define MADV_4M_PAGES		22	/* Use 4 Megabyte pages.  */
+# define MADV_16M_PAGES		24	/* Use 16 Megabyte pages.  */
+# define MADV_64M_PAGES		26	/* Use 64 Megabyte pages.  */
 #endif
 
-
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff --git a/libc/sysdeps/linux/hppa/sys/procfs.h b/libc/sysdeps/linux/hppa/sys/procfs.h
index 24e4c3174..8d12dfb65 100644
--- a/libc/sysdeps/linux/hppa/sys/procfs.h
+++ b/libc/sysdeps/linux/hppa/sys/procfs.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1996-2015 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -12,7 +12,7 @@
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
+   License along with the GNU C Library.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
 #ifndef _SYS_PROCFS_H
@@ -28,15 +28,21 @@
    GDB unless you know what you are doing.  */
 
 #include <features.h>
-#include <signal.h>
 #include <sys/time.h>
 #include <sys/types.h>
-#include <sys/ucontext.h>
 #include <sys/user.h>
-#include <asm/elf.h>
 
 __BEGIN_DECLS
 
+typedef unsigned long elf_greg_t;
+#define ELF_NGREG 80    /* We only need 64 at present, but leave space
+			                              for expansion. */
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+#define ELF_NFPREG 32
+typedef double elf_fpreg_t;
+typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
+
 struct elf_siginfo
   {
     int si_signo;			/* Signal number.  */
diff --git a/libc/sysdeps/linux/hppa/sys/user.h b/libc/sysdeps/linux/hppa/sys/user.h
new file mode 100644
index 000000000..c871f1a03
--- /dev/null
+++ b/libc/sysdeps/linux/hppa/sys/user.h
@@ -0,0 +1 @@
+/* This file is not needed, but in practice gdb might try to include it.  */
diff --git a/libpthread/linuxthreads.old/sysdeps/hppa/pspinlock.c b/libpthread/linuxthreads.old/sysdeps/hppa/pspinlock.c
new file mode 100644
index 000000000..1a6aa64a9
--- /dev/null
+++ b/libpthread/linuxthreads.old/sysdeps/hppa/pspinlock.c
@@ -0,0 +1,80 @@
+/* POSIX spinlock implementation.  hppa version.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include "internals.h"
+
+int
+__pthread_spin_lock (pthread_spinlock_t *lock)
+{
+  unsigned int val;
+
+  do
+    __asm__ __volatile__ ("ldcw %1,%0"
+		  : "=r" (val), "=m" (*lock)
+		  : "m" (*lock));
+  while (!val);
+
+  return 0;
+}
+weak_alias (__pthread_spin_lock, pthread_spin_lock)
+
+
+int
+__pthread_spin_trylock (pthread_spinlock_t *lock)
+{
+  unsigned int val;
+
+  __asm__ __volatile__ ("ldcw %1,%0"
+		: "=r" (val), "=m" (*lock)
+		: "m" (*lock));
+
+  return val ? 0 : EBUSY;
+}
+weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
+
+
+int
+__pthread_spin_unlock (pthread_spinlock_t *lock)
+{
+  *lock = 1;
+  return 0;
+}
+weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
+
+
+int
+__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
+{
+  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
+     all processes which can access the memory location `lock' points
+     to can use the spinlock.  */
+  *lock = 1;
+  return 0;
+}
+weak_alias (__pthread_spin_init, pthread_spin_init)
+
+
+int
+__pthread_spin_destroy (pthread_spinlock_t *lock)
+{
+  /* Nothing to do.  */
+  return 0;
+}
+weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads.old/sysdeps/hppa/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/hppa/pt-machine.h
new file mode 100644
index 000000000..85c453c77
--- /dev/null
+++ b/libpthread/linuxthreads.old/sysdeps/hppa/pt-machine.h
@@ -0,0 +1,59 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   hppa version.
+   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#include <features.h>
+#include <bits/initspin.h>
+
+#ifndef PT_EI
+# define PT_EI __extern_always_inline
+#endif
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("%r30");
+
+
+/* The hppa only has one atomic read and modify memory operation,
+   load and clear, so hppa spinlocks must use zero to signify that
+   someone is holding the lock.  */
+
+#define xstr(s) str(s)
+#define str(s) #s
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+  int ret;
+
+  __asm__ __volatile__(
+       "ldcw 0(%2),%0"
+       : "=r"(ret), "=m"(*spinlock)
+       : "r"(spinlock));
+
+  return ret == 0;
+}
+#undef str
+#undef xstr
+
+#endif /* pt-machine.h */