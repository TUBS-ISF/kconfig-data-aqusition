"2016-06-01 19:59:03 +0200"
diff --git a/Makefile.in b/Makefile.in
index 36245e38d..59656853e 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -497,7 +497,6 @@ allyesconfig: $(conf)
 		-e "s/^DOASSERTS=.*/# DOASSERTS is not set/" \
 		-e "s/^SUPPORT_LD_DEBUG_EARLY=.*/# SUPPORT_LD_DEBUG_EARLY is not set/" \
 		-e "s/^SUPPORT_LD_DEBUG=.*/# SUPPORT_LD_DEBUG is not set/" \
-		-e "s/^UCLIBC_MJN3_ONLY=.*/# UCLIBC_MJN3_ONLY is not set/" \
 		$(KCONFIG_CONFIG)
 	$(Q)$< -o $(Kconfig)
 alldefconfig: $(conf)
diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
index 17ae847ce..f3494db99 100644
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -1848,20 +1848,6 @@ config UCLIBC_HAS_SYS_SIGLIST
 
 	  Most people will answer N.
 
-config UCLIBC_HAS_GETTEXT_AWARENESS
-	bool "Include gettext awareness"
-	depends on UCLIBC_HAS_LOCALE && UCLIBC_MJN3_ONLY
-	help
-	  NOTE!!!  Not yet integrated with strerror and strsignal.  NOTE!!!
-
-	  Answer Y if you want to include weak stub gettext support and
-	  make the *strerror*() and strsignal() functions gettext-aware.
-
-	  Currently, to get functional gettext functionality you will need
-	  to use gnu gettext.
-
-	  Most people will answer N.
-
 config UCLIBC_HAS_GNU_GETOPT
 	bool "Support gnu getopt"
 	default y
diff --git a/extra/Configs/defconfigs/or1k/defconfig b/extra/Configs/defconfigs/or1k/defconfig
index 63d657109..a4658dace 100644
--- a/extra/Configs/defconfigs/or1k/defconfig
+++ b/extra/Configs/defconfigs/or1k/defconfig
@@ -238,4 +238,3 @@ UCLIBC_EXTRA_CFLAGS=""
 WARNINGS="-Wall"
 # EXTRA_WARNINGS is not set
 # DOMULTI is not set
-# UCLIBC_MJN3_ONLY is not set
diff --git a/include/nl_types.h b/include/nl_types.h
index cb86cf0cd..3692d0c4e 100644
--- a/include/nl_types.h
+++ b/include/nl_types.h
@@ -31,10 +31,6 @@
 
 __BEGIN_DECLS
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning "mjn3 FIXME: None of these prototypes have implementations."
-#endif
-
 #ifndef __UCLIBC_STRICT_HEADERS__
 /* Message catalog descriptor type.  */
 typedef void *nl_catd;
diff --git a/include/time.h b/include/time.h
index a1dfdea18..785c8f665 100644
--- a/include/time.h
+++ b/include/time.h
@@ -288,16 +288,6 @@ extern char *ctime_r (const time_t *__restrict __timer,
 		      char *__restrict __buf) __THROW;
 # endif	/* POSIX or misc */
 
-
-/* Defined in localtime.c.  */
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning "mjn3 FIXME: __tzname, __daylight, and __timezone have a prototype but are not defined."
-extern char *__tzname[2];	/* Current timezone names.  */
-extern int __daylight;		/* If daylight-saving time is ever in use.  */
-extern long int __timezone;	/* Seconds west of UTC.  */
-#endif /* __UCLIBC_MJN3_ONLY__ */
-
-
 # ifdef	__USE_POSIX
 /* Same as above.  */
 extern char *tzname[2];
@@ -403,49 +393,6 @@ extern int timer_getoverrun (timer_t __timerid) __THROW;
 #  endif /* __UCLIBC_HAS_REALTIME__ */
 # endif /* __USE_POSIX199309 */
 
-
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning "mjn3 FIXME: a bunch of unimplemented function prototypes."
-# ifdef __USE_XOPEN_EXTENDED
-/* Set to one of the following values to indicate an error.
-     1  the DATEMSK environment variable is null or undefined,
-     2  the template file cannot be opened for reading,
-     3  failed to get file status information,
-     4  the template file is not a regular file,
-     5  an error is encountered while reading the template file,
-     6  memory allication failed (not enough memory available),
-     7  there is no line in the template that matches the input,
-     8  invalid input specification Example: February 31 or a time is
-        specified that can not be represented in a time_t (representing
-	the time in seconds since 00:00:00 UTC, January 1, 1970) */
-extern int getdate_err;
-
-/* Parse the given string as a date specification and return a value
-   representing the value.  The templates from the file identified by
-   the environment variable DATEMSK are used.  In case of an error
-   `getdate_err' is set.
-
-   This function is a possible cancellation points and therefore not
-   marked with __THROW.  */
-extern struct tm *getdate (const char *__string);
-# endif
-
-# ifdef __USE_GNU
-/* Since `getdate' is not reentrant because of the use of `getdate_err'
-   and the static buffer to return the result in, we provide a thread-safe
-   variant.  The functionality is the same.  The result is returned in
-   the buffer pointed to by RESBUFP and in case of an error the return
-   value is != 0 with the same values as given above for `getdate_err'.
-
-   This function is not part of POSIX and therefore no official
-   cancellation point.  But due to similarity with an POSIX interface
-   or due to the implementation it is a cancellation point and
-   therefore not marked with __THROW.  */
-extern int getdate_r (const char *__restrict __string,
-		      struct tm *__restrict __resbufp);
-# endif
-#endif /* __UCLIBC_MJN3_ONLY__ */
-
 __END_DECLS
 
 #endif /* <time.h> included.  */
diff --git a/include/wctype.h b/include/wctype.h
index aa133bd60..3842ccf4e 100644
--- a/include/wctype.h
+++ b/include/wctype.h
@@ -101,11 +101,6 @@ enum
   _ISwpunct = _ISwbit (__ISwpunct),	/* Punctuation.  */
   _ISwalnum = _ISwbit (__ISwalnum)	/* Alphanumeric.  */
 };
-# else
-#  if defined(__UCLIBC_MJN3_ONLY__) && defined(L_iswctype)
-#warning remove _ISwbit already defined check?
-#error _ISwbit already defined!
-#  endif
 # endif /* Not _ISwbit  */
 
 
diff --git a/libc/inet/resolv.c b/libc/inet/resolv.c
index f378c9b9d..e3ad5131f 100644
--- a/libc/inet/resolv.c
+++ b/libc/inet/resolv.c
@@ -2082,9 +2082,6 @@ int gethostbyname_r(const char *name,
 		return ERANGE;
 
 	/* we store only one "alias" - the name itself */
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO -- generate the full list
-#endif
 	alias[0] = alias0;
 	alias[1] = NULL;
 
@@ -2283,9 +2280,6 @@ int gethostbyname2_r(const char *name,
 		return ERANGE;
 
 	/* we store only one "alias" - the name itself */
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO -- generate the full list
-#endif
 	alias[0] = alias0;
 	alias[1] = NULL;
 
diff --git a/libc/misc/ctype/ctype.c b/libc/misc/ctype/ctype.c
index db8061d9f..bbe12e514 100644
--- a/libc/misc/ctype/ctype.c
+++ b/libc/misc/ctype/ctype.c
@@ -62,16 +62,7 @@
 #endif /* __UCLIBC_HAS_CTYPE_SIGNED__ */
 
 #endif /* __UCLIBC_HAS_CTYPE_TABLES__ */
-/**********************************************************************/
-#ifdef __UCLIBC_MJN3_ONLY__
-#ifdef L_isspace
-/* emit only once */
-#warning CONSIDER: Should we assert when debugging and __UCLIBC_HAS_CTYPE_CHECKED?
-#warning TODO: Fix asserts in to{upper|lower}{_l}.
-#warning TODO: Optimize the isx*() funcs.
-#endif
-#endif /* __UCLIBC_MJN3_ONLY__ */
-/**********************************************************************/
+
 #undef PASTE2
 #define PASTE2(X,Y)    X ## Y
 
diff --git a/libc/misc/error/err.c b/libc/misc/error/err.c
index 4f1e6a33f..1563450a0 100644
--- a/libc/misc/error/err.c
+++ b/libc/misc/error/err.c
@@ -12,14 +12,8 @@
 #include <errno.h>
 #include <err.h>
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: Deal with wide oriented stderr case.
-#endif
-
 #if defined __USE_BSD
 
-
-
 static void vwarn_work(const char *format, va_list args, int showerr)
 {
 	/*                         0123 45678 9 a b*/
diff --git a/libc/misc/locale/locale.c b/libc/misc/locale/locale.c
index 68e54413e..f868ac022 100644
--- a/libc/misc/locale/locale.c
+++ b/libc/misc/locale/locale.c
@@ -58,11 +58,6 @@
 #include <ctype.h>
 #include <stdio.h>
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#ifdef L_setlocale
-#warning TODO: Make the link_warning()s a config option?
-#endif
-#endif
 #undef link_warning
 #define link_warning(A,B)
 
@@ -78,13 +73,6 @@
 
 #else  /* __LOCALE_C_ONLY */
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#ifdef L_setlocale
-#warning TODO: Fix the __CTYPE_HAS_8_BIT_LOCALES define at the top of the file.
-#warning TODO: Fix __WCHAR_ENABLED.
-#endif
-#endif
-
 /* Need to include this before locale.h! */
 #include <bits/uClibc_locale.h>
 
@@ -107,9 +95,6 @@
 #define LOCALE_AT_MODIFIERS		(__locale_mmap->locale_at_modifiers)
 #define CATEGORY_NAMES			(__locale_mmap->lc_names)
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: redo the MAX_LOCALE_STR stuff...
-#endif
 #define MAX_LOCALE_STR			256 /* TODO: Only sufficient for current case. */
 #define MAX_LOCALE_CATEGORY_STR	32 /* TODO: Only sufficient for current case. */
 /* Note: Best if MAX_LOCALE_CATEGORY_STR is a power of 2. */
@@ -122,11 +107,6 @@ extern void _locale_init_l(__locale_t base) attribute_hidden;
 #undef LOCALE_STRING_SIZE
 #define LOCALE_SELECTOR_SIZE (2 * __LC_ALL + 2)
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#ifdef L_setlocale
-#warning TODO: Create a C locale selector string.
-#endif
-#endif
 #define C_LOCALE_SELECTOR "\x23\x80\x80\x80\x80\x80\x80\x80\x80\x80\x80\x80\x80"
 
 
@@ -163,15 +143,9 @@ link_warning(setlocale,"REMINDER: The 'setlocale' function is _not_ threadsafe e
 #error locales enabled, but not data other than for C locale!
 #endif
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Move posix and utf8 strings.
-#endif
 static const char posix[] = "POSIX";
 static const char utf8[] = "UTF-8";
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Fix dimensions of hr_locale.
-#endif
 /* Individual category strings start at hr_locale + category * MAX_LOCALE_CATEGORY.
  * This holds for LC_ALL as well.
  */
@@ -355,9 +329,6 @@ __locale_t __curlocale_var = &__global_locale_data;
 #endif
 
 /*----------------------------------------------------------------------*/
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Move utf8 and ascii strings.
-#endif
 static const char utf8[] = "UTF-8";
 static const char ascii[] = "ASCII";
 
@@ -413,9 +384,6 @@ static int init_cur_collate(int der_num, __collate_t *cur_collate)
 	size_t n;
 	uint16_t i, w;
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning kill of x86-specific asserts
-#endif
 #if 0
 	assert(sizeof(coldata_base_t) == 19*2);
 	assert(sizeof(coldata_der_t) == 4*2);
@@ -431,9 +399,6 @@ static int init_cur_collate(int der_num, __collate_t *cur_collate)
 
 	cdh = (coldata_header_t *) __locale_collate_tbl;
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Should we assert here?
-#endif
 #if 0
 	if (der_num >= cdh->num_der) {
 		return 0;
@@ -492,11 +457,6 @@ static int init_cur_collate(int der_num, __collate_t *cur_collate)
 
 	cur_collate->MAX_WEIGHTS = cdh->MAX_WEIGHTS;
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Fix the +1 by increasing max_col_index?
-#warning CONSIDER: Since this collate info is dependent only on LC_COLLATE ll_cc and not on codeset, we could just globally allocate this for each in a table
-#endif
-
 	cur_collate->index2weight = calloc(2*cur_collate->max_col_index+2,
 									   sizeof(uint16_t));
 	if (!cur_collate->index2weight) {
@@ -643,9 +603,6 @@ int attribute_hidden _locale_set_l(const unsigned char *p, __locale_t base)
 					c -= 3;
 					base->codeset = (char *) (r + r[c]);
 					base->encoding = __ctype_encoding_8_bit;
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: update 8 bit mb_cur_max when translit implemented!
-#endif
 					/* TODO - update when translit implemented! */
 					base->mb_cur_max = 1;
 					c8b = __locale_mmap->codeset_8_bit + c;
@@ -775,9 +732,6 @@ int attribute_hidden _locale_set_l(const unsigned char *p, __locale_t base)
 
 #endif /* __CTYPE_HAS_8_BIT_LOCALES */
 				}
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Put the outdigit string length in the locale_mmap object.
-#endif
 				d = base->outdigit_length;
 				x = &base->outdigit0_mb;
 				for (c = 0 ; c < 10 ; c++) {
@@ -798,9 +752,6 @@ int attribute_hidden _locale_set_l(const unsigned char *p, __locale_t base)
 						= __locale_mbrtowc_l(&base->thousands_sep_wc,
 											 base->thousands_sep, base);
 #if 1
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Remove hack involving grouping without a thousep char (bg_BG).
-#endif
 					assert(base->thousands_sep_len >= 0);
 					if (base->thousands_sep_len == 0) {
 						base->grouping = base->thousands_sep; /* empty string */
@@ -898,9 +849,6 @@ void attribute_hidden _locale_init_l(__locale_t base)
 	__ctype_toupper = __C_ctype_toupper;
 #endif /* __UCLIBC_HAS_XLOCALE__ */
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Initialize code2flag correctly based on locale_mmap.
-#endif
 	base->code2flag = __code2flag;
 
 	_locale_set_l((unsigned char*) C_LOCALE_SELECTOR, base);
@@ -1056,9 +1004,6 @@ libc_hidden_def(__XL_NPP(nl_langinfo))
 
 #warning mask defines for extra locale categories
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Move posix and utf8 strings.
-#endif
 static const char posix[] = "POSIX";
 static const char utf8[] = "UTF-8";
 
@@ -1073,9 +1018,6 @@ static int find_locale(int category_mask, const char *p,
 #if defined(__LOCALE_DATA_AT_MODIFIERS_LENGTH) && 1
 	/* Support standard locale handling for @-modifiers. */
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: Fix buf size in find_locale.
-#endif
 	char buf[18];	/* TODO: 7+{max codeset name length} */
 	const char *q;
 
@@ -1226,9 +1168,6 @@ __locale_t newlocale(int category_mask, const char *locale, __locale_t base)
 		return NULL; /* No locale or illegal/unsupported category. */
 	}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Rename cur_locale to locale_selector.
-#endif
 	strcpy((char *) new_selector,
 		   (base ? (char *) base->cur_locale : C_LOCALE_SELECTOR));
 
@@ -1272,15 +1211,9 @@ __locale_t newlocale(int category_mask, const char *locale, __locale_t base)
 		goto INVALID;
 	}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Do a compatible codeset check!
-#endif
 
 	/* If we get here, the new selector corresponds to a valid locale. */
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Probably want a _locale_new func to allow for caching of locales.
-#endif
 #if 0
 	if (base) {
 		_locale_set_l(new_selector, base);
@@ -1309,10 +1242,6 @@ libc_hidden_def(newlocale)
 #ifdef L_duplocale
 
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: When we allocate ctype tables, remember to dup them.
-#endif
-
 __locale_t duplocale(__locale_t dataset)
 {
 	__locale_t r;
@@ -1341,10 +1270,6 @@ __locale_t duplocale(__locale_t dataset)
 /**********************************************************************/
 #ifdef L_freelocale
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: When we allocate ctype tables, remember to free them.
-#endif
-
 void freelocale(__locale_t dataset)
 {
 	assert(dataset != __global_locale);
diff --git a/libc/misc/time/time.c b/libc/misc/time/time.c
index 03635d86d..cd189169a 100644
--- a/libc/misc/time/time.c
+++ b/libc/misc/time/time.c
@@ -1033,10 +1033,6 @@ static wchar_t* fmt_to_wc_1(const char *src)
 
 #define MAX_PUSH 4
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Check multibyte format string validity.
-#endif
-
 size_t __XL_NPP(strftime)(CHAR_T *__restrict s, size_t maxsize,
 					  const CHAR_T *__restrict format,
 					  const struct tm *__restrict timeptr   __LOCALE_PARAM )
@@ -1871,10 +1867,6 @@ static const char *getnumber(register const char *e, int *pn)
 }
 
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Should we preserve errno from open/read/close errors re TZ file?
-#endif
-
 #ifdef __UCLIBC_HAS_TZ_FILE__
 
 #ifndef __UCLIBC_HAS_TZ_FILE_READ_MANY__
diff --git a/libc/misc/wchar/wchar.c b/libc/misc/wchar/wchar.c
index 966f78d19..201f30772 100644
--- a/libc/misc/wchar/wchar.c
+++ b/libc/misc/wchar/wchar.c
@@ -112,12 +112,6 @@
 
 /**********************************************************************/
 #ifdef __UCLIBC_HAS_LOCALE__
-#ifdef __UCLIBC_MJN3_ONLY__
-#ifdef L_iswspace
-/* generates one warning */
-#warning TODO: Fix Cc2wc* and Cwc2c* defines!
-#endif
-#endif /* __UCLIBC_MJN3_ONLY__ */
 
 #define ENCODING		(__UCLIBC_CURLOCALE->encoding)
 
@@ -134,13 +128,6 @@
 
 #else  /* __UCLIBC_HAS_LOCALE__ */
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#ifdef L_btowc
-/* emit only once */
-#warning fix preprocessor logic testing locale settings
-#endif
-#endif
-
 #define ENCODING (__ctype_encoding_7_bit)
 #ifdef __CTYPE_HAS_8_BIT_LOCALES
 #error __CTYPE_HAS_8_BIT_LOCALES is defined!
@@ -313,10 +300,6 @@ size_t mbrtowc(wchar_t *__restrict pwc, const char *__restrict s,
 	}
 #endif
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: This adds a trailing nul!
-#endif /* __UCLIBC_MJN3_ONLY__ */
-
 	r = mbsnrtowcs(wcbuf, &p, SIZE_MAX, 1, ps);
 
 	if (((ssize_t) r) >= 0) {
@@ -339,9 +322,6 @@ libc_hidden_def(mbrtowc)
 size_t wcrtomb(register char *__restrict s, wchar_t wc,
 			   mbstate_t *__restrict ps)
 {
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Should wcsnrtombs nul-terminate unconditionally?  Check glibc.
-#endif /* __UCLIBC_MJN3_ONLY__ */
 	wchar_t wcbuf[1];
 	const wchar_t *pwc;
 	size_t r;
@@ -473,9 +453,6 @@ size_t attribute_hidden _wchar_utf8sntowcs(wchar_t *__restrict pwc, size_t wn,
 		--n;
 		if ((wc = ((unsigned char) *s++)) >= 0x80) { /* Not ASCII... */
 			mask = 0x40;
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Fix range for 16 bit wchar_t case.
-#endif
 			if (( ((unsigned char)(s[-1] - 0xc0)) < (0xfe - 0xc0) ) &&
 			(((unsigned char)s[-1] != 0xc0 ) && ((unsigned char)s[-1] != 0xc1 ))) {
 				goto START;
@@ -910,12 +887,6 @@ libc_hidden_def(wcsnrtombs)
 /**********************************************************************/
 #ifdef L_wcswidth
 
-
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: If we start doing translit, wcwidth and wcswidth will need updating.
-#warning TODO: Update wcwidth to match latest by Kuhn.
-#endif
-
 #if defined(__UCLIBC_HAS_LOCALE__) && \
 ( defined(__CTYPE_HAS_8_BIT_LOCALES) || defined(__CTYPE_HAS_UTF_8_LOCALES) )
 
@@ -1442,9 +1413,6 @@ size_t weak_function iconv(iconv_t cd, char **__restrict inbuf,
 					}
 					return (size_t)(-1);
 				}
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: optimize this.
-#endif
 				if (p != NULL) { /* incomplete char case */
 					goto INVALID;
 				}
@@ -1519,9 +1487,6 @@ size_t weak_function iconv(iconv_t cd, char **__restrict inbuf,
 			do {
 				r = _wchar_wcsntoutf8s(*outbuf, *outbytesleft, &pw, 1);
 				if (r != (size_t)(-1)) {
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: What happens for a nul?
-#endif
 					if (r == 0) {
 						if (wc != 0) {
 							goto TOO_BIG;
diff --git a/libc/misc/wctype/_wctype.c b/libc/misc/wctype/_wctype.c
index 68fae8b54..81076baf1 100644
--- a/libc/misc/wctype/_wctype.c
+++ b/libc/misc/wctype/_wctype.c
@@ -93,13 +93,6 @@ enum {
 
 /*--------------------------------------------------------------------*/
 
-#ifdef __UCLIBC_MJN3_ONLY__
-# ifdef L_iswspace
-/* generates one warning */
-#  warning TODO: Fix WC* defines!
-# endif
-#endif
-
 #define ENCODING		(__UCLIBC_CURLOCALE->encoding)
 
 #define WCctype			(__UCLIBC_CURLOCALE->tblwctype)
@@ -459,10 +452,6 @@ libc_hidden_def(wctype)
 /**********************************************************************/
 #ifdef L_wctype_l
 
-#ifdef __UCLIBC_MJN3_ONLY__
-# warning REMINDER: Currently wctype_l simply calls wctype.
-#endif
-
 wctype_t wctype_l (const char *property, __locale_t locale)
 {
 	return wctype(property);
@@ -485,12 +474,6 @@ wctype_t wctype_l (const char *property, __locale_t locale)
 	    ) \
 	)
 
-#ifdef __UCLIBC_MJN3_ONLY__
-# ifdef L_iswctype
-#  warning CONSIDER: Change to bit shift?  would need to sync with wctype.h
-# endif
-#endif
-
 #ifdef __UCLIBC_HAS_CTYPE_TABLES__
 # if !defined(__UCLIBC_HAS_XLOCALE__) || defined(L_iswctype_l)
 static const unsigned short int desc2flag[] = {
@@ -570,12 +553,6 @@ int iswctype(wint_t wc, wctype_t desc)
 
 #else  /* __LOCALE_C_ONLY */
 
-#ifdef __UCLIBC_MJN3_ONLY__
-# ifdef L_iswctype
-#  warning CONSIDER: Handle combining class?
-# endif
-#endif
-
 #ifdef L_iswctype
 # define ISWCTYPE(w,d) iswctype(w,d)
 #else
@@ -629,9 +606,6 @@ int ISWCTYPE(wint_t wc, wctype_t desc)
 #endif
 		}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-# warning TODO: xdigit really needs to be handled better.  Remember only for ascii!
-#endif
 		/* TODO - Add locale-specific classifications. */
 		return (desc == _CTYPE_iswxdigit) ? __C_iswxdigit(wc) : 0;
 	}
@@ -741,9 +715,6 @@ wint_t TOWCTRANS(wint_t wc, wctrans_t desc)
 			}
 			wc += WCuplow_diff[i];
 			if (desc == _CTYPE_totitle) {
-#ifdef __UCLIBC_MJN3_ONLY__
-# warning TODO: Verify totitle special cases!
-#endif
 				/* WARNING! These special cases work for glibc 2.2.4.  Changes
 				 * may be needed if the glibc locale tables are updated. */
 				if ((__uwchar_t)(wc - 0x1c4) <= (0x1cc - 0x1c4)
@@ -781,9 +752,6 @@ wint_t TOWCTRANS(wint_t wc, wctrans_t desc)
 	if ((unsigned)(desc - _CTYPE_toupper) <= (_CTYPE_totitle - _CTYPE_toupper)) {
 		wc = TOWUPPER(wc, __UCLIBC_CURLOCALE);
 		if (desc == _CTYPE_totitle) {
-#ifdef __UCLIBC_MJN3_ONLY__
-# warning TODO: Verify totitle special cases!
-#endif
 			/* WARNING! These special cases work for glibc 2.2.4.  Changes
 			 * may be needed if the glibc locale tables are updated. */
 			if ((__uwchar_t)(wc - 0x1c4) <= (0x1cc - 0x1c4)
@@ -843,10 +811,6 @@ libc_hidden_def(wctrans)
 /**********************************************************************/
 #ifdef L_wctrans_l
 
-# ifdef __UCLIBC_MJN3_ONLY__
-#  warning REMINDER: Currently wctrans_l simply calls wctrans.
-# endif
-
 wctrans_t wctrans_l(const char *property, __locale_t locale)
 {
 	return wctrans(property);
diff --git a/libc/stdio/_READ.c b/libc/stdio/_READ.c
index a548dbb3f..a3c141385 100644
--- a/libc/stdio/_READ.c
+++ b/libc/stdio/_READ.c
@@ -38,9 +38,6 @@ size_t attribute_hidden __stdio_READ(register FILE *stream,
 			bufsize = SSIZE_MAX;
 		}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning EINTR?
-#endif
 /* 	RETRY: */
 		if ((rv = __READ(stream, (char *) buf, bufsize)) <= 0) {
 			if (rv == 0) {
@@ -50,9 +47,6 @@ size_t attribute_hidden __stdio_READ(register FILE *stream,
 				__STDIO_STREAM_SET_ERROR(stream);
 				rv = 0;
 			}
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Make custom stream read return check optional.
-#endif
 #ifdef __UCLIBC_HAS_GLIBC_CUSTOM_STREAMS__
 		} else {
 			assert(rv <= bufsize);
diff --git a/libc/stdio/_WRITE.c b/libc/stdio/_WRITE.c
index 712236f8f..113f0eb86 100644
--- a/libc/stdio/_WRITE.c
+++ b/libc/stdio/_WRITE.c
@@ -46,9 +46,6 @@ size_t attribute_hidden __stdio_WRITE(register FILE *stream,
 		stodo = (todo <= SSIZE_MAX) ? todo : SSIZE_MAX;
 		rv = __WRITE(stream, (char *) buf, stodo);
 		if (rv >= 0) {
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Make custom stream write return check optional.
-#endif
 #ifdef __UCLIBC_HAS_GLIBC_CUSTOM_STREAMS__
 			assert(rv <= stodo);
 			if (rv > stodo) {	/* Wrote more than stodo! */
diff --git a/libc/stdio/_fopen.c b/libc/stdio/_fopen.c
index be05c48a5..ddad1586c 100644
--- a/libc/stdio/_fopen.c
+++ b/libc/stdio/_fopen.c
@@ -64,11 +64,6 @@ FILE attribute_hidden *_stdio_fopen(intptr_t fname_or_mode,
 		open_mode += (O_RDWR - (O_RDONLY | O_WRONLY));
 	}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Implement glibc ccs option to bind a codeset?
-#warning CONSIDER: Implement glibc mmap option for readonly files?
-#warning CONSIDER: Implement a text mode using custom read/write funcs?
-#endif
 #if defined(__UCLIBC_HAS_FOPEN_EXCLUSIVE_MODE__) || defined(__UCLIBC_HAS_FOPEN_LARGEFILE_MODE__) || \
     defined(__UCLIBC_HAS_FOPEN_CLOSEEXEC_MODE__)
 
@@ -110,10 +105,6 @@ FILE attribute_hidden *_stdio_fopen(intptr_t fname_or_mode,
 #endif
 	}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Verify fdopen append behavior of glibc.
-#endif
-
 	if (filedes >= 0) {			/* Handle fdopen trickery. */
 		stream->__filedes = filedes;
 		/* NOTE: it is insufficient to just check R/W/RW agreement.
diff --git a/libc/stdio/_fpmaxtostr.c b/libc/stdio/_fpmaxtostr.c
index 35805844a..b06b25aa0 100644
--- a/libc/stdio/_fpmaxtostr.c
+++ b/libc/stdio/_fpmaxtostr.c
@@ -210,9 +210,6 @@ ssize_t _fpmaxtostr(FILE * fp, __fpmax_t x, struct printf_info *info,
 	intptr_t pc_fwi[3*MAX_CALLS];
 	intptr_t *ppc;
 	intptr_t *ppc_last;
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: The size of exp_buf[] should really be determined by the float constants.
-#endif /* __UCLIBC_MJN3_ONLY__ */
 	char exp_buf[16];
 	char buf[BUF_SIZE];
 	char sign_str[6];			/* Last 2 are for 1st digit + nul. */
@@ -291,9 +288,6 @@ ssize_t _fpmaxtostr(FILE * fp, __fpmax_t x, struct printf_info *info,
 
 	{
 		int i, j;
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Clean up defines when hexadecimal float notation is unsupported.
-#endif /* __UCLIBC_MJN3_ONLY__ */
 
 #ifdef __UCLIBC_HAS_HEXADECIMAL_FLOATS__
 
@@ -375,9 +369,6 @@ ssize_t _fpmaxtostr(FILE * fp, __fpmax_t x, struct printf_info *info,
 		do {
 			uint_fast32_t digit_block = (uint_fast32_t) x;
 			assert(digit_block < upper_bnd);
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Can rounding be a problem?
-#endif /* __UCLIBC_MJN3_ONLY__ */
 			x = (x - digit_block) * upper_bnd;
 			s += dpb;
 			j = 0;
diff --git a/libc/stdio/_fwrite.c b/libc/stdio/_fwrite.c
index 47860afbf..2e712c9e5 100644
--- a/libc/stdio/_fwrite.c
+++ b/libc/stdio/_fwrite.c
@@ -25,9 +25,6 @@ size_t attribute_hidden __stdio_fwrite(const unsigned char * __restrict buffer,
 	assert(bytes);
 
 	if (!__STDIO_STREAM_IS_NBF(stream)) { /* FBF or LBF. */
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Try to consolidate some of the code?
-#endif
 		if (__STDIO_STREAM_IS_FAKE_VSNPRINTF(stream)) {
 			pending = __STDIO_STREAM_BUFFER_WAVAIL(stream);
 			if (pending > bytes) {
@@ -66,9 +63,6 @@ size_t attribute_hidden __stdio_fwrite(const unsigned char * __restrict buffer,
 			if (__STDIO_COMMIT_WRITE_BUFFER(stream)) { /* Commit failed! */
 				return 0;
 			}
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Do we want to try again if data now fits in buffer?
-#endif
 /* 			goto RETRY; */
 		}
 	}
diff --git a/libc/stdio/_rfill.c b/libc/stdio/_rfill.c
index e9d2fa698..d2b3de593 100644
--- a/libc/stdio/_rfill.c
+++ b/libc/stdio/_rfill.c
@@ -7,10 +7,6 @@
 
 #include "_stdio.h"
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Do we really need a seperate rfill function?
-#endif
-
 #ifdef __STDIO_BUFFERS
 
 /* Read some data into the buffer.
diff --git a/libc/stdio/_scanf.c b/libc/stdio/_scanf.c
index 80e49567f..3f3000d6f 100644
--- a/libc/stdio/_scanf.c
+++ b/libc/stdio/_scanf.c
@@ -192,10 +192,6 @@ int vscanf(const char * __restrict format, va_list arg)
 /**********************************************************************/
 #ifdef L_vsscanf
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning WISHLIST: Implement vsscanf for non-buf and no custom stream case.
-#endif /* __UCLIBC_MJN3_ONLY__ */
-
 #ifdef __STDIO_BUFFERS
 
 int vsscanf(const char *sp, const char *fmt, va_list ap)
@@ -424,13 +420,6 @@ enum {
 #define SPEC_BASE		{ 16, 16, 16, 8, 10, 10,  0 }
 #endif /* __UCLIBC_HAS_FLOATS__ */
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#ifdef L_vfscanf
-/* emit once */
-#warning CONSIDER: Add a '0' flag to eat 0 padding when grouping?
-#endif
-#endif /* __UCLIBC_MJN3_ONLY__ */
-
 #define SPEC_FLAGS		"*'I"
 
 enum {
@@ -630,9 +619,6 @@ extern int __psfs_do_numeric(psfs_t *psfs, struct scan_cookie *sc) attribute_hid
 /**********************************************************************/
 #ifdef L___scan_cookie
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Remove dependence on decpt_str and fake_decpt in stub locale mode.
-#endif
 #ifndef __UCLIBC_HAS_LOCALE__
 static const char decpt_str[] = ".";
 #endif
@@ -856,11 +842,6 @@ int attribute_hidden __psfs_parse_spec(register psfs_t *psfs)
 	}
 	psfs->dataargtype = ((int)(p[(sizeof(qual_chars)-2) / 2])) << 8;
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Should we validate that psfs->max_width > 0 in __psfs_parse_spec()?  It would avoid whitespace consumption...
-#warning CONSIDER: Should INT_MAX be a valid width (%c/%C)?  See __psfs_parse_spec().
-#endif /* __UCLIBC_MJN3_ONLY__ */
-
 	p = spec_chars;
 	do {
 		if (*psfs->fmt == *p) {
@@ -1109,9 +1090,6 @@ int VFSCANF (FILE *__restrict fp, const Wchar *__restrict format, va_list arg)
 	psfs_t psfs;
 	int i;
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Fix MAX_DIGITS.  We do not do binary, so...!
-#endif
 #define MAX_DIGITS 65			/* Allow one leading 0. */
 	unsigned char buf[MAX_DIGITS+2];
 #ifdef L_vfscanf
@@ -1122,9 +1100,6 @@ int VFSCANF (FILE *__restrict fp, const Wchar *__restrict format, va_list arg)
 	unsigned char zero_conversions = 1;
 	__STDIO_AUTO_THREADLOCK_VAR;
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Make checking of the format string in C locale an option.
-#endif
 	/* To support old programs, don't check mb validity if in C locale. */
 #if defined(__UCLIBC_HAS_LOCALE__) && !defined(L_vfwscanf)
 	/* ANSI/ISO C99 requires format string to be a valid multibyte string
@@ -1285,9 +1260,6 @@ int VFSCANF (FILE *__restrict fp, const Wchar *__restrict format, va_list arg)
 			}
 
 			if (psfs.conv_num == CONV_n) {
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Should %n count as a conversion as far as EOF return value?
-#endif
 /* 				zero_conversions = 0; */
 				if (psfs.store) {
 					_store_inttype(psfs.cur_ptr, psfs.dataargtype,
@@ -1740,19 +1712,12 @@ int attribute_hidden __psfs_do_numeric(psfs_t *psfs, struct scan_cookie *sc)
 #ifdef __UCLIBC_HAS_FLOATS__
 	int exp_adjust = 0;
 #endif
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Fix MAX_DIGITS.  We do not do binary, so...!
-#warning TODO: Fix buf!
-#endif
 #define MAX_DIGITS 65			/* Allow one leading 0. */
 	unsigned char buf[MAX_DIGITS+2+ 100];
 	unsigned char usflag, base;
 	unsigned char nonzero = 0;
 	unsigned char seendigit = 0;
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: What should be returned for an invalid conversion specifier?
-#endif
 #ifndef __UCLIBC_HAS_FLOATS__
 	if (psfs->conv_num > CONV_i) { /* floating point */
 		goto DONE;
@@ -1786,9 +1751,6 @@ int attribute_hidden __psfs_do_numeric(psfs_t *psfs, struct scan_cookie *sc)
 			}
 		} while (1);
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Should we require a 0x prefix and disallow +/- for pointer %p?
-#endif /*  __UCLIBC_MJN3_ONLY__ */
 	}
 
 	__scan_getc(sc);
@@ -1844,10 +1806,6 @@ int attribute_hidden __psfs_do_numeric(psfs_t *psfs, struct scan_cookie *sc)
 
 		int nblk1, nblk2, nbmax, lastblock, pass, i;
 
-
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Should we initalize the grouping blocks in __init_scan_cookie()?
-#endif /*  __UCLIBC_MJN3_ONLY__ */
 		nbmax = nblk2 = nblk1 = *p;
 		if (*++p) {
 			nblk2 = *p;
@@ -1876,9 +1834,6 @@ int attribute_hidden __psfs_do_numeric(psfs_t *psfs, struct scan_cookie *sc)
 		if (sc->cc == '0') {
 			seendigit = 1;
 			*b++ = '0';			/* Store the first 0. */
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Should leading 0s be skipped before digit grouping? (printf 0 pad)
-#endif /*  __UCLIBC_MJN3_ONLY__ */
 #if 0
 			do {				/* But ignore all subsequent 0s. */
 				__scan_getc(sc);
@@ -2155,9 +2110,6 @@ int attribute_hidden __psfs_do_numeric(psfs_t *psfs, struct scan_cookie *sc)
 			__scan_getc(sc);
 		}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Fix MAX_EXP_DIGITS!
-#endif
 #define MAX_EXP_DIGITS 20
 		assert(seendigit);
 		seendigit = 0;
diff --git a/libc/stdio/_vfprintf.c b/libc/stdio/_vfprintf.c
index a795f4979..fc5d3ff68 100644
--- a/libc/stdio/_vfprintf.c
+++ b/libc/stdio/_vfprintf.c
@@ -130,14 +130,6 @@
 
 /**********************************************************************/
 
-#ifdef __UCLIBC_MJN3_ONLY__
-# ifdef L_register_printf_function
-/* emit only once */
-#  warning WISHLIST: Make MAX_USER_SPEC configurable?
-#  warning WISHLIST: Make MAX_ARGS_PER_SPEC configurable?
-# endif
-#endif
-
 #ifdef __UCLIBC_HAS_GLIBC_CUSTOM_PRINTF__
 # define MAX_USER_SPEC       10
 # define MAX_ARGS_PER_SPEC    5
@@ -460,9 +452,6 @@ int attribute_hidden _ppfs_init(register ppfs_t *ppfs, const char *fmt0)
 	--ppfs->maxposarg;			/* set to -1 */
 #endif
 	ppfs->fmtpos = fmt0;
-#ifdef __UCLIBC_MJN3_ONLY__
-# warning TODO: Make checking of the format string in C locale an option.
-#endif
 #ifdef __UCLIBC_HAS_LOCALE__
 	/* To support old programs, don't check mb validity if in C locale. */
 	if (__UCLIBC_CURLOCALE->encoding != __ctype_encoding_7_bit) {
@@ -878,11 +867,6 @@ int attribute_hidden _ppfs_parsespec(ppfs_t *ppfs)
 		} else {
 			if (maxposarg > 0) {
 # ifdef __UCLIBC_HAS_PRINTF_M_SPEC__
-#  ifdef __UCLIBC_MJN3_ONLY__
-#   warning TODO: Support prec and width for %m when positional args used
-				/* Actually, positional arg processing will fail in general
-				 * for specifiers that don't require an arg. */
-#  endif
 				if (*fmt == 'm') {
 					goto PREC_WIDTH;
 				}
@@ -1414,9 +1398,6 @@ static int _do_one_spec(FILE * __restrict stream,
 	int numfill = 0;			/* TODO: fix */
 	int prefix_num = PREFIX_NONE;
 	char padchar = ' ';
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Determine appropriate buf size.
-#endif
 	/* TODO: buf needs to be big enough for any possible error return strings
 	 * and also for any locale-grouped long long integer strings generated.
 	 * This should be large enough for any of the current archs/locales, but
@@ -1468,11 +1449,6 @@ static int _do_one_spec(FILE * __restrict stream,
 		if (ppfs->conv_num <= CONV_i) {	/* pointer or (un)signed int */
 			alphacase = __UIM_LOWER;
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#ifdef L__vfprintf_internal
-#warning CONSIDER: Should we ignore these flags if stub locale?  What about custom specs?
-#endif
-#endif
 			base = spec_base[(int)(ppfs->conv_num - CONV_p)];
 			if (base == 10) {
 				if (PRINT_INFO_FLAG_VAL(&(ppfs->info),group)) {
@@ -1497,11 +1473,6 @@ static int _do_one_spec(FILE * __restrict stream,
 			if (ppfs->info.prec < 0) { /* Ignore '0' flag if prec specified. */
 				padchar = ppfs->info.pad;
 			}
-#ifdef __UCLIBC_MJN3_ONLY__
-#ifdef L__vfprintf_internal
-#warning CONSIDER: If using outdigits and/or grouping, how should we interpret precision?
-#endif
-#endif
 			s = _uintmaxtostr(buf + sizeof(buf) - 1,
 							  (uintmax_t)
 							  _load_inttype(ppfs->conv_num == CONV_p ? PA_FLAG_LONG : *argtype & __PA_INTMASK,
@@ -1654,9 +1625,6 @@ static int _do_one_spec(FILE * __restrict stream,
 		} else if (ppfs->conv_num <= CONV_s) {	/* char or string */
 
 			if (ppfs->conv_num == CONV_s) { /* string */
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Fix %s for _vfwprintf_internal... output upto illegal sequence?
-#endif
 				s = *((char **) (*argptr));
 				if (s) {
 #ifdef __UCLIBC_HAS_PRINTF_M_SPEC__
@@ -1722,11 +1690,6 @@ static int _do_one_spec(FILE * __restrict stream,
 			return -1;
 		}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#ifdef L__vfprintf_internal
-#warning CONSIDER: If using outdigits and/or grouping, how should we pad?
-#endif
-#endif
 		{
 			size_t t;
 
diff --git a/libc/stdio/_wfwrite.c b/libc/stdio/_wfwrite.c
index 517e3a7a3..65b38e7e7 100644
--- a/libc/stdio/_wfwrite.c
+++ b/libc/stdio/_wfwrite.c
@@ -12,11 +12,6 @@
 #error wide function when no wide support!
 #endif
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning TODO: Fix prototype.
-#endif
-
-
 size_t attribute_hidden _wstdio_fwrite(const wchar_t *__restrict ws, size_t n,
 					  register FILE *__restrict stream)
 {
diff --git a/libc/stdio/fclose.c b/libc/stdio/fclose.c
index 7e7bc3b5b..26b27c8cf 100644
--- a/libc/stdio/fclose.c
+++ b/libc/stdio/fclose.c
@@ -85,9 +85,6 @@ int fclose(register FILE *stream)
 	__STDIO_AUTO_THREADUNLOCK(stream);
 
 	__STDIO_STREAM_FREE_BUFFER(stream);
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: inefficient - locks and unlocks twice and walks whole list
-#endif
 #if defined(__UCLIBC_HAS_THREADS__) && defined(__STDIO_BUFFERS)
 	/* inefficient - locks/unlocks twice and walks whole list */
 	__STDIO_OPENLIST_INC_DEL_CNT;
diff --git a/libc/stdio/fcloseall.c b/libc/stdio/fcloseall.c
index 4d78b37d6..ab8248c7b 100644
--- a/libc/stdio/fcloseall.c
+++ b/libc/stdio/fcloseall.c
@@ -27,17 +27,11 @@ int fcloseall (void)
 
 	__STDIO_OPENLIST_INC_USE;
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: should probably have a get_head() operation
-#endif
 	__STDIO_THREADLOCK_OPENLIST_ADD;
 	f = _stdio_openlist;
 	__STDIO_THREADUNLOCK_OPENLIST_ADD;
 
 	while (f) {
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: should probably have a get_next() operation
-#endif
 		FILE *n = f->__nextopen;
 		__STDIO_AUTO_THREADLOCK_VAR;
 
diff --git a/libc/stdio/fflush.c b/libc/stdio/fflush.c
index cf0356a38..7c05ea5fe 100644
--- a/libc/stdio/fflush.c
+++ b/libc/stdio/fflush.c
@@ -10,10 +10,6 @@
 
 #ifdef __DO_UNLOCKED
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning WISHLIST: Add option to test for undefined behavior of fflush.
-#endif /* __UCLIBC_MJN3_ONLY__ */
-
 /* Even if the stream is set to user-locking, we still need to lock
  * when all (lbf) writing streams are flushed. */
 
@@ -34,16 +30,10 @@ void attribute_hidden _stdio_openlist_dec_use(void)
 		FILE *n;
 		FILE *stream;
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: As an optimization, we could unlock after we move past the head.
-#endif
 		/* Grab the openlist add lock since we might change the head of the list. */
 		__STDIO_THREADLOCK_OPENLIST_ADD;
 		for (stream = _stdio_openlist; stream; stream = n) {
 			n = stream->__nextopen;
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: fix for nonatomic
-#endif
 			if ((stream->__modeflags & (__FLAG_READONLY|__FLAG_WRITEONLY|__FLAG_FAILED_FREOPEN))
 				== (__FLAG_READONLY|__FLAG_WRITEONLY)
 				) {		 /* The file was closed and should be removed from the list. */
@@ -70,9 +60,6 @@ int fflush_unlocked(register FILE *stream)
 #ifdef __STDIO_BUFFERS
 
 	int retval = 0;
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning REMINDER: should probably define a modeflags type
-#endif
 	unsigned short bufmask = __FLAG_LBF;
 
 #ifndef NDEBUG
diff --git a/libc/stdio/fgets.c b/libc/stdio/fgets.c
index bc710c764..0a6d31e5c 100644
--- a/libc/stdio/fgets.c
+++ b/libc/stdio/fgets.c
@@ -19,9 +19,6 @@ char *fgets_unlocked(char *__restrict s, int n,
 
 	__STDIO_STREAM_VALIDATE(stream);
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: What should fgets do if n <= 0?
-#endif /* __UCLIBC_MJN3_ONLY__ */
 	/* Should we assert here?  Or set errno?  Or just fail... */
 	if (n <= 0) {
 /* 		__set_errno(EINVAL); */
@@ -48,9 +45,6 @@ char *fgets_unlocked(char *__restrict s, int n,
 		}
 	}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: If n==1 and not at EOF, should fgets return an empty string?
-#endif /* __UCLIBC_MJN3_ONLY__ */
 	if (p > s) {
 		*p = 0;
 		return s;
diff --git a/libc/stdio/fputc.c b/libc/stdio/fputc.c
index 7876d77af..d4e5d2528 100644
--- a/libc/stdio/fputc.c
+++ b/libc/stdio/fputc.c
@@ -41,9 +41,6 @@ int __fputc_unlocked(int c, register FILE *stream)
 				) {
 				goto BAD;
 			}
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Should we fail if the commit fails but we now have room?
-#endif
 
 			__STDIO_STREAM_BUFFER_ADD(stream, ((unsigned char) c));
 
diff --git a/libc/stdio/fread.c b/libc/stdio/fread.c
index 5df33b468..5f4ec6f38 100644
--- a/libc/stdio/fread.c
+++ b/libc/stdio/fread.c
@@ -62,9 +62,6 @@ size_t fread_unlocked(void * __restrict ptr, size_t size, size_t nmemb,
 			}
 #endif
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: should we refill and read from the buffer sometimes?
-#endif
 			while ((avail = __stdio_READ(stream, buffer, todo)) > 0) {
 				buffer += avail;
 				if (!(todo -= avail)) {
diff --git a/libc/stdio/ftrylockfile.c b/libc/stdio/ftrylockfile.c
index 0d2e156af..c2f49ca0f 100644
--- a/libc/stdio/ftrylockfile.c
+++ b/libc/stdio/ftrylockfile.c
@@ -7,10 +7,6 @@
 
 #include "_stdio.h"
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: What should this return when not threading?
-#endif
-
 int ftrylockfile(FILE *stream)
 {
 	__STDIO_STREAM_VALIDATE(stream);
diff --git a/libc/stdio/perror.c b/libc/stdio/perror.c
index 8b943e467..d36d75bcf 100644
--- a/libc/stdio/perror.c
+++ b/libc/stdio/perror.c
@@ -7,11 +7,6 @@
 
 #include "_stdio.h"
 
-
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Increase buffer size for error message (non-%m case)?
-#endif
-
 void perror(register const char *s)
 {
 	/* If the program is calling perror, it's a safe bet that printf and
diff --git a/libc/stdio/popen.c b/libc/stdio/popen.c
index 1efbd3b7a..a5aa99885 100644
--- a/libc/stdio/popen.c
+++ b/libc/stdio/popen.c
@@ -23,10 +23,6 @@
 #include <sys/wait.h>
 #include <bits/uClibc_mutex.h>
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning "hmm... susv3 says Pipe streams are byte-oriented."
-#endif /* __UCLIBC_MJN3_ONLY__ */
-
 #ifndef VFORK_LOCK
 __UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
 # define VFORK_LOCK		__UCLIBC_MUTEX_LOCK(mylock)
diff --git a/libc/stdio/ungetc.c b/libc/stdio/ungetc.c
index ea4edd22c..14c8d95c0 100644
--- a/libc/stdio/ungetc.c
+++ b/libc/stdio/ungetc.c
@@ -31,9 +31,6 @@ int ungetc(int c, register FILE *stream)
 	__STDIO_AUTO_THREADLOCK(stream);
 	__STDIO_STREAM_VALIDATE(stream);
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Make fast ungetc an option?
-#endif
 #ifdef __UCLIBC_HAS_STDIO_GETC_MACRO__
 	/* If buffered narrow reading with no ungot slots filled, and if not
 	 * ungetting a different char than the one last read from the buffer,
diff --git a/libc/stdio/vasprintf.c b/libc/stdio/vasprintf.c
index fa7926c60..026d8b2bd 100644
--- a/libc/stdio/vasprintf.c
+++ b/libc/stdio/vasprintf.c
@@ -12,12 +12,6 @@
 #include <stdarg.h>
 #include <bits/uClibc_va_copy.h>
 
-
-#ifdef __UCLIBC_MJN3_ONLY__
-/* Do the memstream stuff inline to avoid fclose and the openlist? */
-#warning CONSIDER: avoid open_memstream call?
-#endif
-
 #ifndef __STDIO_HAS_VSNPRINTF
 #warning Skipping vasprintf since no vsnprintf!
 #else
diff --git a/libc/stdio/vsnprintf.c b/libc/stdio/vsnprintf.c
index 3a4c60794..9e1bed132 100644
--- a/libc/stdio/vsnprintf.c
+++ b/libc/stdio/vsnprintf.c
@@ -8,11 +8,6 @@
 #include "_stdio.h"
 #include <stdarg.h>
 
-
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning WISHLIST: Implement vsnprintf for non-buffered and no custom stream case.
-#endif /* __UCLIBC_MJN3_ONLY__ */
-
 #ifdef __STDIO_BUFFERS
 /* NB: we can still have __USE_OLD_VFPRINTF__ defined in this case! */
 
diff --git a/libc/stdlib/drand48-iter.c b/libc/stdlib/drand48-iter.c
index b4b7b33b0..1ddf40204 100644
--- a/libc/stdlib/drand48-iter.c
+++ b/libc/stdlib/drand48-iter.c
@@ -26,9 +26,6 @@
 /* Global state for non-reentrant functions.  */
 struct drand48_data __libc_drand48_data;
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning turn int __drand48_iterate into void
-#endif /* __UCLIBC_MJN3_ONLY__ */
 int __drand48_iterate (unsigned short int xsubi[3], struct drand48_data *buffer)
 {
   uint64_t X;
diff --git a/libc/stdlib/stdlib.c b/libc/stdlib/stdlib.c
index 6c887eabc..075e6e5d6 100644
--- a/libc/stdlib/stdlib.c
+++ b/libc/stdlib/stdlib.c
@@ -70,12 +70,6 @@
 
 #else  /* __UCLIBC_HAS_LOCALE__ */
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#ifdef L_mblen
-/* emit only once */
-#warning devel checks
-#endif
-#endif
 #ifdef __CTYPE_HAS_8_BIT_LOCALES
 #error __CTYPE_HAS_8_BIT_LOCALES is defined!
 #endif
@@ -821,11 +815,6 @@ size_t _stdlib_mb_cur_max(void)
 #ifdef __CTYPE_HAS_UTF_8_LOCALES
 	return __UCLIBC_CURLOCALE->mb_cur_max;
 #else
-#ifdef __CTYPE_HAS_8_BIT_LOCALES
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning need to change this when/if transliteration is implemented
-#endif
-#endif
 	return 1;
 #endif
 }
diff --git a/libc/string/_collate.c b/libc/string/_collate.c
index 93501b85e..d487c8ba3 100644
--- a/libc/string/_collate.c
+++ b/libc/string/_collate.c
@@ -173,9 +173,6 @@ static void next_weight(col_state_t *cs, int pass   __LOCALE_PARAM )
 			goto POSITION_SKIP;
 		}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning should we walk pendings backwards?
-#endif
 		if (cs->cip) {			/* possible pending weight */
 			if ((r = *(cs->cip++)) == 0) {
 				cs->cip = NULL;
@@ -267,9 +264,6 @@ static void next_weight(col_state_t *cs, int pass   __LOCALE_PARAM )
 				} while (1);
 			} else if (r == 0) {		/* illegal, undefined, or part of a range */
 				if ((CUR_COLLATE->range_count)
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning .. need to introduce range as a collating item?
-#endif
 					&& (((__uwchar_t)(WC - CUR_COLLATE->range_low)) <= CUR_COLLATE->range_count)
 					) {					/* part of a range */
 					/* Note: cs->colitem = 0 already. */
@@ -288,9 +282,6 @@ static void next_weight(col_state_t *cs, int pass   __LOCALE_PARAM )
 					assert(ri != 0); /* implicit undefined isn't supported */
 
 					TRACE(("    found explicit UNDEFINED\n"));
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning right now single weight locales do not support ..
-#endif
 					if (CUR_COLLATE->num_weights == 1) {
 						TRACE(("    single weight UNDEFINED\n"));
 						cs->weightidx = RANGE_IDX;
@@ -333,9 +324,6 @@ static void next_weight(col_state_t *cs, int pass   __LOCALE_PARAM )
 		FOUND:
 			ri = CUR_COLLATE->index2ruleidx[cs->colitem - 1];
 			TRACE((" ri=%d ", ri));
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning make sure this is correct
-#endif
 			if (!ri) {
 				TRACE(("NOT IN THIS LOCALE\n"));
 				goto UNDEFINED;
@@ -344,9 +332,6 @@ static void next_weight(col_state_t *cs, int pass   __LOCALE_PARAM )
 
 		RANGE_SKIP_TO:
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning ignoreables probably should not interrupt backwards processing, but this is wrong
-#endif
 /* 			if (!(ru & WEIGHT_MASK)) { */
 /* 				TRACE(("IGNORE\n")); */
 /* 				cs->s += n; */
@@ -368,9 +353,6 @@ static void next_weight(col_state_t *cs, int pass   __LOCALE_PARAM )
 							cs->bp = malloc(cs->bb_size + 128);
 							if (!cs->bp) {
 								/* __set_errno(ENOMEM); */
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning what to do here?
-#endif
 								cs->weight = 0;
 								return;
 							}
@@ -380,9 +362,6 @@ static void next_weight(col_state_t *cs, int pass   __LOCALE_PARAM )
 							cs->bp = realloc(cs->back_buf, cs->bb_size + 128);
 							if (!cs->bp) {
 								/* __set_errno(ENOMEM); */
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning what to do here?
-#endif
 								cs->weight = 0;
 								return;
 							}
@@ -430,9 +409,6 @@ static void next_weight(col_state_t *cs, int pass   __LOCALE_PARAM )
 						assert(ru & WEIGHT_MASK);
 						cs->ru_pushed = ru;
 						cs->weight = cs->position;
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning devel code
-#endif
 						cs->position = 0;	/* reset to reduce size for strcoll? */
 						cs->s += n;
 						cs->weightidx = RANGE_IDX;
@@ -453,9 +429,6 @@ static void next_weight(col_state_t *cs, int pass   __LOCALE_PARAM )
 			cs->rule = ru & RULE_MASK;
 		}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning for pending we only want the weight... _not_ the rule
-#endif
 		if (!cs->weightidx) {	/* ignore */
 			continue;
 		}
@@ -547,10 +520,6 @@ size_t __XL_NPP(wcsxfrm)(wchar_t *__restrict ws1, const wchar_t *__restrict ws2,
 		return __wcslcpy(ws1, ws2, n);
 	}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning handle empty string as a special case
-#endif
-
 	count = pass = 0;
 	do {						/* loop through the weights levels */
 		init_col_state(&cs, ws2);
@@ -630,10 +599,6 @@ size_t __XL_NPP(strxfrm)(char *__restrict ws1, const char *__restrict ws2, size_
 		return strlcpy(ws1, ws2, n);
 	}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning handle empty string as a special case
-#endif
-
 	inc = count = pass = 0;
 	do {						/* loop through the weights levels */
 		init_col_state(&cs, ws2);