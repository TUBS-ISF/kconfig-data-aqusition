"2002-10-31 18:20:21 +0000"
diff --git a/.cvsignore b/.cvsignore
index 19c5ad2af..49273e8e3 100644
--- a/.cvsignore
+++ b/.cvsignore
@@ -9,3 +9,4 @@ lib
 Config
 _install
 build-stamp
+.config*
diff --git a/Makefile b/Makefile
index c5f69e132..a23e5727a 100644
--- a/Makefile
+++ b/Makefile
@@ -22,29 +22,27 @@
 # other sundry sources.  Files within this library are copyright by their
 # respective copyright holders.
 
-#--------------------------------------------------------
-#
-#There are a number of configurable options in "Config"
-#
-#--------------------------------------------------------
 
+#--------------------------------------------------------------
+# You shouldn't need to mess with anything beyond this point...
+#--------------------------------------------------------------
+noconfig_targets := menuconfig config oldconfig randconfig \
+	defconfig allyesconfig allnoconfig clean distclean \
+	release tags TAGS
 TOPDIR=./
 include Rules.mak
 
 DIRS = extra ldso libc libcrypt libresolv libutil libm libpthread
 
-all: headers uClibc_config subdirs shared utils finished
+ifdef include-config
 
-Config:
-	@echo
-	@echo "You didn't read the README, did you... =)"
-	@echo "Choose a configuration file in extras/Config/ and then run"
-	@echo "  ln -s ./extra/Configs/Config.<arch> ./Config"
-	@echo
-	@exit 1
+all: headers subdirs shared utils finished
+
+# In this section, we need .config
+-include .config.cmd
 
 shared:
-ifeq ($(strip $(HAVE_SHARED)),true)
+ifeq ($(strip $(HAVE_SHARED)),y)
 	@$(MAKE) -C libc shared
 	@$(MAKE) -C ldso shared
 	@$(MAKE) -C libcrypt shared
@@ -67,7 +65,7 @@ finished: shared
 # Target for uClinux distro
 #
 romfs:
-ifeq ($(strip $(HAVE_SHARED)),true)
+ifeq ($(strip $(HAVE_SHARED)),y)
 	install -d $(ROMFSDIR)/lib
 	install -m 644 lib/lib*-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so \
 		$(ROMFSDIR)/lib
@@ -79,13 +77,18 @@ ifeq ($(strip $(HAVE_SHARED)),true)
 	fi;
 endif
 
-headers: dummy
+include/bits/uClibc_config.h: .config
+	rm -rf include/bits
+	mkdir -p include/bits
+	@./extra/config/conf -o extra/Configs/Config.$(TARGET_ARCH)
+
+headers: include/bits/uClibc_config.h
 	rm -f include/asm;
-	@if [ $(TARGET_ARCH) = "powerpc" ];then \
+	@if [ "$(TARGET_ARCH)" = "powerpc" ];then \
 	    ln -fs $(KERNEL_SOURCE)/include/asm-ppc include/asm; \
-	elif [ $(TARGET_ARCH) = "mips" ];then \
+	elif [ "$(TARGET_ARCH)" = "mips" ];then \
 	    ln -fs $(KERNEL_SOURCE)/include/asm-mips include/asm; \
-	elif [ $(TARGET_ARCH) = "mipsel" ];then \
+	elif [ "$(TARGET_ARCH)" = "mipsel" ];then \
 	    ln -fs $(KERNEL_SOURCE)/include/asm-mips include/asm; \
 	    cd $(shell pwd)/libc/sysdeps/linux; \
 	    ln -fs mips mipsel; \
@@ -93,10 +96,10 @@ headers: dummy
 	    ln -fs mips mipsel; \
 	    cd $(shell pwd)/libpthread/linuxthreads/sysdeps; \
 	    ln -fs mips mipsel; \
-	elif [ $(TARGET_ARCH) = "cris" ];then \
+	elif [ "$(TARGET_ARCH)" = "cris" ];then \
 		ln -fs $(KERNEL_SOURCE)/include/asm-cris include/asm; \
 	else \
-	    if [ $(HAS_MMU) != "true" ]; then \
+	    if [ "$(UCLIBC_HAS_MMU)" != "y" ]; then \
 	    	if [ -d $(KERNEL_SOURCE)/include/asm-$(TARGET_ARCH)nommu ] ; then \
 		    ln -fs $(KERNEL_SOURCE)/include/asm-$(TARGET_ARCH)nommu include/asm;\
 		else \
@@ -110,16 +113,14 @@ headers: dummy
 	    set -e; \
 	    echo " "; \
 	    echo "The path '$(KERNEL_SOURCE)/include/asm' doesn't exist."; \
-	    echo "I bet you didn't set KERNEL_SOURCE, TARGET_ARCH or HAS_MMU in \`Config'"; \
-	    echo "correctly.  Please edit \`Config' and fix these settings."; \
+	    echo "I bet you didn't set KERNEL_SOURCE, TARGET_ARCH or UCLIBC_HAS_MMU"; \
+	    echo "correctly when you configured uClibc.  Please fix these settings."; \
 	    echo " "; \
 	    false; \
 	fi;
 	rm -f include/linux include/scsi
 	ln -fs $(KERNEL_SOURCE)/include/linux include/linux
 	ln -fs $(KERNEL_SOURCE)/include/scsi include/scsi
-	rm -rf include/bits
-	mkdir -p include/bits
 	@cd include/bits; \
 	set -e; \
 	for i in `ls ../../libc/sysdeps/linux/common/bits/*.h` ; do \
@@ -146,97 +147,6 @@ headers: dummy
 	TOPDIR=. CC=$(CC) /bin/sh extra/scripts/gen_bits_syscall_h.sh > include/bits/sysnum.h
 	$(MAKE) -C libc/sysdeps/linux/$(TARGET_ARCH) headers
 
-uClibc_config: Makefile Config
-	@echo "/* WARNING!!! AUTO-GENERATED FILE!!! DO NOT EDIT!!! */" > include/bits/uClibc_config.h
-	@echo "#if !defined __FEATURES_H && !defined __need_uClibc_config_h" >> include/bits/uClibc_config.h
-	@echo "#error Never include <bits/uClibc_config.h> directly; use <features.h> instead." >> include/bits/uClibc_config.h
-	@echo "#endif" >> include/bits/uClibc_config.h
-	@echo "#define __UCLIBC_MAJOR__ $(MAJOR_VERSION)" >> include/bits/uClibc_config.h 
-	@echo "#define __UCLIBC_MINOR__ $(MINOR_VERSION)" >> include/bits/uClibc_config.h 
-	@echo "#define __UCLIBC_SUBLEVEL__ $(SUBLEVEL)" >> include/bits/uClibc_config.h 
-	@echo "#define linux 1" >> include/bits/uClibc_config.h 
-	@echo "#define __linux__ 1" >> include/bits/uClibc_config.h 
-	@if [ "$(INCLUDE_IPV6)" = "true" ] ; then \
-	    echo "#define __UCLIBC_HAS_IPV6__ 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef __UCLIBC_HAS_IPV6__" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(HAS_MMU)" = "true" ] ; then \
-	    echo "#define __UCLIBC_HAS_MMU__ 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "For now we make the assumption that a linux system without an"; \
-	    echo "MMU must be uClinux, and must have a broken munmap (both"; \
-	    echo "assumptions are a bit dodgy, but can be changed in the future)."; \
-	    echo "#undef __UCLIBC_HAS_MMU__" >> include/bits/uClibc_config.h ; \
-	    echo "#define __UCLIBC_UCLINUX_BROKEN_MUNMAP__ 1" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(HAS_FLOATING_POINT)" = "true" ] ; then \
-	    echo "#define __UCLIBC_HAS_FLOATS__ 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef __UCLIBC_HAS_FLOATS__" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(HAS_LOCALE)" = "true" ] ; then \
-	    echo "#define __UCLIBC_HAS_LOCALE__ 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef __UCLIBC_HAS_LOCALE__" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(HAS_WCHAR)" = "true" ] ; then \
-	    echo "#define __UCLIBC_HAS_WCHAR__ 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef __UCLIBC_HAS_WCHAR__" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(HAVE_ELF)" = "false" ] ; then \
-	    echo "#undef HAVE_ELF" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#define HAVE_ELF 1" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(HAVE_SHARED)" = "false" ] ; then \
-	    echo "#undef HAVE_SHARED" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#define HAVE_SHARED 1" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(TARGET_ARCH)" = "sh" ] ; then \
-	    echo "#define NO_UNDERSCORES 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef NO_UNDERSCORES" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(INCLUDE_RPC)" = "true" ] ; then \
-	    echo "#define __UCLIBC_HAS_RPC__ 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef __UCLIBC_HAS_RPC__" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(DOLFS)" = "true" ] ; then \
-	    echo "#define __UCLIBC_HAVE_LFS__ 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef __UCLIBC_HAVE_LFS__" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(INCLUDE_THREADS)" = "true" ] ; then \
-	    echo "#define __UCLIBC_HAS_THREADS__ 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef __UCLIBC_HAS_THREADS__" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(INCLUDE_REGEX)" = "true" ] ; then \
-	    echo "#define __UCLIBC_HAS_REGEX__ 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef __UCLIBC_HAS_REGEX__" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(UNIX98PTY_ONLY)" = "true" ] ; then \
-	    echo "#define UNIX98PTY_ONLY 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef UNIX98PTY_ONLY" >> include/bits/uClibc_config.h ; \
-	fi
-	@if [ "$(ASSUME_DEVPTS)" = "true" ] ; then \
-	    echo "#define ASSUME_DEVPTS 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef ASSUME_DEVPTS" >> include/bits/uClibc_config.h ; \
-	fi
-	@echo "#define C_SYMBOL_PREFIX "\""$(C_SYMBOL_PREFIX)"\" >> include/bits/uClibc_config.h
-	@if [ "$(HAVE_DOT_HIDDEN)" = "true" ] ; then \
-	    echo "#define HAVE_DOT_HIDDEN 1" >> include/bits/uClibc_config.h ; \
-	else \
-	    echo "#undef HAVE_DOT_HIDDEN" >> include/bits/uClibc_config.h ; \
-	fi
-
 subdirs: $(patsubst %, _dir_%, $(DIRS))
 
 $(patsubst %, _dir_%, $(DIRS)) : dummy
@@ -260,7 +170,7 @@ install_dev:
 	done;
 	-find $(PREFIX)$(DEVEL_PREFIX) -name CVS | xargs rm -rf;
 	-chown -R `id | sed 's/^uid=\([0-9]*\).*gid=\([0-9]*\).*$$/\1.\2/'` $(PREFIX)$(DEVEL_PREFIX)
-ifeq ($(strip $(HAVE_SHARED)),true)
+ifeq ($(strip $(HAVE_SHARED)),y)
 	-find lib/ -type l -name '*.so' -exec cp -a {} $(PREFIX)$(DEVEL_PREFIX)/lib ';'
 	# If we build shared libraries then the static libs are PIC...
 	# Make _pic.a symlinks to make mklibs.py and similar tools happy.
@@ -274,7 +184,7 @@ endif
 # allowing cross development.  If you want to deploy to a target 
 # system, use the "install_target" target instead... 
 install_runtime:
-ifeq ($(strip $(HAVE_SHARED)),true)
+ifeq ($(strip $(HAVE_SHARED)),y)
 	install -d $(PREFIX)$(DEVEL_PREFIX)/lib
 	install -d $(PREFIX)$(DEVEL_PREFIX)/bin
 	install -m 644 lib/lib*-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so \
@@ -297,7 +207,7 @@ install_toolchain:
 	install -d $(PREFIX)$(SYSTEM_DEVEL_PREFIX)/bin
 	$(MAKE) -C extra/gcc-uClibc install
 
-ifeq ($(strip $(HAVE_SHARED)),true)
+ifeq ($(strip $(HAVE_SHARED)),y)
 utils: $(TOPDIR)ldso/util/ldd
 	$(MAKE) -C ldso utils
 else
@@ -305,7 +215,7 @@ utils: dummy
 endif
 
 install_utils: utils
-ifeq ($(strip $(HAVE_SHARED)),true)
+ifeq ($(strip $(HAVE_SHARED)),y)
 	install -d $(PREFIX)$(DEVEL_TOOL_PREFIX)/bin;
 	install -m 755 ldso/util/ldd \
 		$(PREFIX)$(SYSTEM_DEVEL_PREFIX)/bin/$(TARGET_ARCH)-uclibc-ldd
@@ -332,7 +242,7 @@ endif
 # $PREFIX is set to, allowing you to package up the result for
 # deployment onto your target system.
 install_target:
-ifeq ($(strip $(HAVE_SHARED)),true)
+ifeq ($(strip $(HAVE_SHARED)),y)
 	install -d $(PREFIX)$(TARGET_PREFIX)/lib
 	install -d $(PREFIX)$(TARGET_PREFIX)/usr/bin
 	install -m 644 lib/lib*-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so \
@@ -349,7 +259,7 @@ ifeq ($(strip $(HAVE_SHARED)),true)
 endif
 
 install_target_utils:
-ifeq ($(strip $(HAVE_SHARED)),true)
+ifeq ($(strip $(HAVE_SHARED)),y)
 	@$(MAKE) -C ldso/util ldd.target readelf.target #ldconfig.target
 	install -d $(PREFIX)$(TARGET_PREFIX)/usr/bin;
 	install -m 755 ldso/util/ldd.target $(PREFIX)$(TARGET_PREFIX)/usr/bin/ldd
@@ -367,8 +277,60 @@ finished2:
 	@echo Finished installing...
 	@echo
 
+else # ifdef include-config
+
+all: menuconfig
+
+ifeq ($(filter-out $(noconfig_targets),$(MAKECMDGOALS)),)
+# Targets which don't need .config
+
+# configuration
+# ---------------------------------------------------------------------------
+
+extra/config/conf extra/config/mconf:
+	make -C extra/config
+	-@if [ ! -f .config ] ; then \
+		cp extra/Configs/Config.$(TARGET_ARCH).default .config; \
+	fi
 
-distclean clean:
+menuconfig: extra/config/mconf
+	make -C extra/config/lxdialog
+	rm -rf include/bits
+	mkdir -p include/bits
+	@./extra/config/mconf extra/Configs/Config.$(TARGET_ARCH)
+
+config: extra/config/conf
+	rm -rf include/bits
+	mkdir -p include/bits
+	@./extra/config/conf extra/Configs/Config.$(TARGET_ARCH)
+
+oldconfig: extra/config/conf
+	rm -rf include/bits
+	mkdir -p include/bits
+	@./extra/config/conf -o extra/Configs/Config.$(TARGET_ARCH)
+
+randconfig: extra/config/conf
+	rm -rf include/bits
+	mkdir -p include/bits
+	@./extra/config/conf -r extra/Configs/Config.$(TARGET_ARCH)
+
+allyesconfig: extra/config/conf
+	rm -rf include/bits
+	mkdir -p include/bits
+	@./extra/config/conf -y extra/Configs/Config.$(TARGET_ARCH)
+
+allnoconfig: extra/config/conf
+	rm -rf include/bits
+	mkdir -p include/bits
+	@./extra/config/conf -n extra/Configs/Config.$(TARGET_ARCH)
+
+defconfig: extra/config/conf
+	rm -rf include/bits
+	mkdir -p include/bits
+	@./extra/config/conf -d extra/Configs/Config.$(TARGET_ARCH)
+
+
+clean:
 	- find . \( -name \*.o -o -name \*.a -o -name \*.so -o -name core -o -name .\#\* \) -exec rm -f {} \;
 	@rm -rf tmp lib include/bits libc/tmp _install
 	$(MAKE) -C test clean
@@ -390,14 +352,17 @@ distclean clean:
 	@if [ -d libc/sysdeps/linux/$(TARGET_ARCH) ]; then		\
 	    $(MAKE) -C libc/sysdeps/linux/$(TARGET_ARCH) clean;		\
 	fi;
-	@if [ $(TARGET_ARCH) = "mipsel" ]; then \
+	@if [ "$(TARGET_ARCH)" = "mipsel" ]; then \
 	    $(MAKE) -C libc/sysdeps/linux/mips clean; \
 	    rm -f ldso/ldso/mipsel; \
 	    rm -f libc/sysdeps/linux/mipsel; \
 	    rm -f libpthread/linuxthreads/sysdeps/mipsel; \
 	fi;
 
-dist release: distclean
+distclean: clean
+	rm -f .config .config.old .config.cmd
+
+release: distclean
 	cd ..;					\
 	rm -rf uClibc-$(VERSION);		\
 	cp -a uClibc uClibc-$(VERSION);		\
@@ -406,5 +371,9 @@ dist release: distclean
 						\
 	tar -cvzf uClibc-$(VERSION).tar.gz --exclude CVS uClibc-$(VERSION)/;
 
-.PHONY: dummy subdirs release distclean clean
+endif # ifeq ($(filter-out $(noconfig_targets),$(MAKECMDGOALS)),)
+endif # ifdef include-config
+
+.PHONY: dummy subdirs release distclean clean config oldconfig menuconfig
+
 
diff --git a/Rules.mak b/Rules.mak
index 4c27771b6..3a8dcec56 100644
--- a/Rules.mak
+++ b/Rules.mak
@@ -21,22 +21,41 @@
 # along with this program; if not, write to the Free Software Foundation, Inc.,
 # 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 
--include $(TOPDIR)Config
+# If you are running a cross compiler, you may want to set this
+# to something more interesting...  Target architecture is determined
+# by asking this compiler what arch it compiles stuff for.
+CROSS=
+CC = $(CROSS)gcc-3.2
+AR = $(CROSS)ar
+LD = $(CROSS)ld
+NM = $(CROSS)nm
+STRIPTOOL = $(CROSS)strip
+#STRIPTOOL = /bin/true
+
+# Select the compiler needed to build binaries for your development system
+NATIVE_CC = gcc
+
 
 # Be sure to update include/features.h when changing this...
 MAJOR_VERSION:=0
 MINOR_VERSION:=9
 SUBLEVEL:=15
 VERSION:=$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL)
+export MAJOR_VERSION MINOR_VERSION SUBLEVEL VERSION
 
-
-LIBNAME:=libc.a
 SHARED_FULLNAME:=libuClibc-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so
 SHARED_MAJORNAME:=libc.so.$(MAJOR_VERSION)
 UCLIBC_LDSO:=ld-uClibc.so.$(MAJOR_VERSION)
-LIBC:=$(TOPDIR)libc/libc.a
+LIBNAME:=libc.a
+LIBC:=$(TOPDIR)libc/$(LIBNAME)
 LIBGCC:=$(shell $(CC) $(LIBGCC_CFLAGS) -print-libgcc-file-name)
 
+# Pull in the user's uClibc configuration
+ifeq ($(filter $(noconfig_targets),$(MAKECMDGOALS)),)
+include-config := 1
+-include $(TOPDIR).config
+endif
+
 # A nifty macro to make testing gcc features easier
 check_gcc=$(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; \
 	then echo "$(1)"; else echo "$(2)"; fi)
@@ -45,7 +64,7 @@ check_gcc=$(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1;
 AWK:=$(shell if [ -x /usr/bin/nawk ]; then echo "/usr/bin/nawk"; \
 	else echo "/usr/bin/awk"; fi)
 
-NATIVE_ARCH:= ${shell uname -m | sed \
+NATIVE_ARCH:= $(shell uname -m | sed \
 		-e 's/i.86/i386/' \
 		-e 's/sparc.*/sparc/' \
 		-e 's/arm.*/arm/g' \
@@ -54,9 +73,9 @@ NATIVE_ARCH:= ${shell uname -m | sed \
 		-e 's/v850.*/v850/g' \
 		-e 's/sh[234].*/sh/' \
 		-e 's/mips.*/mips/' \
-		}
+		)
 ifeq ($(strip $(TARGET_ARCH)),)
-TARGET_ARCH:=${shell $(CC) -dumpmachine | sed -e s'/-.*//' \
+TARGET_ARCH:=$(shell $(CC) -dumpmachine | sed -e s'/-.*//' \
 		-e 's/i.86/i386/' \
 		-e 's/sparc.*/sparc/' \
 		-e 's/arm.*/arm/g' \
@@ -66,7 +85,7 @@ TARGET_ARCH:=${shell $(CC) -dumpmachine | sed -e s'/-.*//' \
 		-e 's/sh[234]/sh/' \
 		-e 's/mips.*/mips/' \
 		-e 's/cris.*/cris/' \
-		}
+		)
 endif
 
 # Ensure consistent filename sort order
@@ -80,7 +99,7 @@ ifndef OPTIMIZATION
 
 # use '-Os' optimization if available, else use -O2, allow Config to override
 OPTIMIZATION:=
-OPTIMIZATION+=${call check_gcc,-Os,-O2}
+OPTIMIZATION+=$(call check_gcc,-Os,-O2)
 ifeq ($(strip $(TARGET_ARCH)),arm)
 	OPTIMIZATION+=-fstrict-aliasing
 endif
@@ -100,7 +119,7 @@ CFLAGS:=$(WARNINGS) $(OPTIMIZATION) -fno-builtin -nostdinc $(CPUFLAGS) \
 	-I$(TOPDIR)include -iwithprefix include -I. -D_LIBC $(ARCH_CFLAGS)
 NATIVE_CFLAGS:=-O2 -Wall
 
-ifeq ($(strip $(DODEBUG)),true)
+ifeq ($(strip $(DODEBUG)),y)
     CFLAGS += -g
     LDFLAGS:= -shared --warn-common --warn-once -z combreloc
     STRIPTOOL:= true -Since_we_are_debugging
@@ -109,27 +128,21 @@ else
     LDFLAGS := -s -shared --warn-common --warn-once -z combreloc
 endif
 
-ifeq ($(strip $(HAVE_SHARED)),true)
-    DOPIC:=true
+ifeq ($(strip $(HAVE_SHARED)),y)
     LIBRARY_CACHE:=#-DUSE_CACHE
-    ifeq ($(strip $(BUILD_UCLIBC_LDSO)),true)
+    ifeq ($(strip $(BUILD_UCLIBC_LDSO)),y)
 	LDSO:=$(TOPDIR)lib/$(UCLIBC_LDSO)
 	DYNAMIC_LINKER:=$(SHARED_LIB_LOADER_PATH)/$(UCLIBC_LDSO)
-	BUILD_DYNAMIC_LINKER:=${shell cd $(TOPDIR) && pwd}/lib/$(UCLIBC_LDSO)
+	BUILD_DYNAMIC_LINKER:=$(shell cd $(TOPDIR) && pwd)/lib/$(UCLIBC_LDSO)
     else
 	LDSO:=$(SYSTEM_LDSO)
-	BUILD_UCLIBC_LDSO:=false
 	DYNAMIC_LINKER:=/lib/$(notdir $(SYSTEM_LDSO))
 	BUILD_DYNAMIC_LINKER:=/lib/$(notdir $(SYSTEM_LDSO))
    endif
 endif
-ifeq ($(strip $(DOPIC)),true)
+ifeq ($(strip $(DOPIC)),y)
     CFLAGS += -fPIC
 endif
-# Currently locale support requires wide char support.
-ifeq ($(strip $(HAS_LOCALE)),true)
-    HAS_WCHAR:=true
-endif
 
 # TARGET_PREFIX is the directory under which which the uClibc runtime
 # environment will be installed and used on the target system.   The 
diff --git a/extra/Configs/Config.i386 b/extra/Configs/Config.i386
index 13e4916bb..4b3ff7b5a 100644
--- a/extra/Configs/Config.i386
+++ b/extra/Configs/Config.i386
@@ -1,189 +1,187 @@
-# Library Configuration rules for uClibc
 #
-# This file contains rules which are shared between multiple Makefiles.  All
-# normal configuration options live in the file named "Config".  You probably
-# should not mess with this file unless you know what you are doing...  
-# 
-# Copyright (C) 2000 by Lineo, inc.
-# Copyright (C) 2000,2001 Erik Andersen <andersee@debian.org>
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/config-language.txt.
 #
-# This program is free software; you can redistribute it and/or modify it under
-# the terms of the GNU Library General Public License as published by the Free
-# Software Foundation; either version 2 of the License, or (at your option) any
-# later version.
-#
-# This program is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
-# details.
-#
-# You should have received a copy of the GNU Library General Public License
-# along with this program; if not, write to the Free Software Foundation, Inc.,
-# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-#
-# Derived in part from the Linux-8086 C library, the GNU C Library, and several
-# other sundry sources.  Files within this library are copyright by their
-# respective copyright holders.
-
-NATIVE_CC = gcc
-
-# If you are running a cross compiler, you may want to set this
-# to something more interesting...  Target architecture is determined
-# by asking this compiler what arch it compiles stuff for.
-CROSS = #$(TARGET_ARCH)-linux-
-CC = $(CROSS)gcc
-AR = $(CROSS)ar
-LD = $(CROSS)ld
-NM = $(CROSS)nm
-STRIPTOOL = $(CROSS)strip
-#STRIPTOOL = /bin/true
-
-# Set the following to `true' to make a debuggable build, and `false' for
-# production builds.
-DODEBUG = false
-
-# Compiler warnings you want to see 
-WARNINGS=-Wall
-
-# Note that the kernel source you use to compile with should be the same as the
-# Linux kernel you run your apps on.  uClibc doesn't even try to achieve binary
-# compatibility across kernel versions.  So don't expect, for example, uClibc
-# compiled with Linux kernel 2.0.x to implement lchown properly, since 2.0.x
-# can't do that. Similarly, if you compile uClibc vs Linux 2.4.x kernel headers,
-# but then run on Linux 2.0.x, lchown will be compiled into uClibc, but won't
-# work at all.  You have been warned.
-KERNEL_SOURCE=/usr/src/linux
-
-# Set this to `false' if your CPU doesn't have a memory management unit (MMU).
-# Set it to `true' otherwise.
-HAS_MMU = true
-
-# Set this to `false' if you don't have/need basic floating point support
-# support in libc (strtod, printf, scanf).  Set it to `true' otherwise.
-# If this is not true, then libm will not be built.
-HAS_FLOATING_POINT = true
-
-# Set to `true' if you want the math library to contain the full set
-# of C99 math library features.  Costs an extra 35k or so on x86. 
-DO_C99_MATH = false
-
-# Set this to 'false if you don't need shadow password support.
-HAS_SHADOW = false
-
-# Set this to `false' if you don't have/need locale support; `true' otherwise.
-# NOTE: Currently does not affect collation.
-# You must also generate the locale data and associated .h file.
-# See the README in directory extra/locale for details.
-HAS_LOCALE = false
-
-# Set this to `false' if you don't have/need wide char support.
-HAS_WCHAR = false
-
-# This specifies which malloc implementation is used.
-#
-# "malloc" use mmap for all allocations and so works very well on MMU-less
-# systems that do not support the brk() system call.   It is pretty smart 
-# about reusing already allocated memory, and minimizing memory wastage.
-#
-# "malloc-930716" is derived from libc-5.3.12 and uses the brk() system call
-# for all memory allocations.  This makes it very fast.  It is also pretty
-# smart about reusing already allocated memory, and minimizing memory wastage.
-# Because this uses brk() it will not work on uClinux MMU-less systems.
-#MALLOC = malloc 
-MALLOC = malloc-930716
-
-# If you want large file support (greater then 2 GiB) turn this on.
-# Do not enable this unless your kernel provides large file support.
-DOLFS = false
-
-# Posix regular expression code is really big -- 27k all by itself.
-# If you don't use regular expressions, turn this off and save space.
-# Of course, if you only staticly link, leave this on, since it will
-# only be included in your apps if you use regular expressions. 
-INCLUDE_REGEX=true
-
-# If you want to include RPC support, enable this.  RPC is almost never used 
-# for anything except NFS support, so unless you plan to use NFS, leave this
-# disabled.  This is off by default.
-INCLUDE_RPC = false
-
-# Normally we enable just enough RPC support for things like rshd and 
-# nfs mount to work.  If you find you need the rest of the RPC stuff, 
-# then enable this.
-INCLUDE_FULL_RPC = false
-
-# If you want to include support for the next version of the Internet
-# Protocol: IP version 6, enable this.  This is off by default.
-INCLUDE_IPV6 = false
-
-# If you want to include threads support, enable this.  The C library will
-# be compiled thread-safe, and the libpthread library will be built.
-INCLUDE_THREADS = true
-
-# If you want to support only Unix 98 PTYs enable this.  Some older
-# applications may need this disabled.  For most current programs, 
-# you can generally leave this true.
-UNIX98PTY_ONLY = true
-
-# Enable this if /dev/pts is on a devpts or devfs file system.  Both
-# these filesystems automatically manage permissions on the /dev/pts 
-# devices.  You may need to mount this fs on /dev/pts for this to work. 
-# This is true by default.
-ASSUME_DEVPTS = true
-
-
-# If you want to compile the library as PIC code, turn this on.
-# This is automagically enabled when HAVE_SHARED is true
-DOPIC = false
-
-# Enable support for shared libraries?  If this is false, you can
-# ignore all the rest of the options in this file...
-HAVE_SHARED = true
-
-# uClibc has a native shared library loader for some architectures.
-BUILD_UCLIBC_LDSO=true
-
-# If you are using shared libraries, but do not want/have a native
-# uClibc shared library loader, please specify the name of your
-# system's shared library loader here...
-#SYSTEM_LDSO=/lib/ld-linux.so.2
-
-# When using shared libraries, this path is the location where the
-# shared library will be invoked.  This value will be compiled into
-# every binary compiled with uClibc.  
-#
-# BIG FAT WARNING:  
-# If you do not have a shared library loader with the correct name
-# sitting in the directory this points to, your binaries will not run.
-SHARED_LIB_LOADER_PATH=$(DEVEL_PREFIX)/lib
-
-# DEVEL_PREFIX is the directory into which the uClibc development
-# environment will be installed.   The result will look something 
-# like the following:
-#   DEVEL_PREFIX/
-#	lib/            <contains all runtime and static libs>
-#	include/        <Where all the header files go>
-# This value is used by the 'make install' Makefile target.  Since this
-# directory is compiled into the uclibc cross compiler spoofer, you
-# have to recompile if you change this value...
-DEVEL_PREFIX = /usr/$(TARGET_ARCH)-linux-uclibc
-
-# SYSTEM_DEVEL_PREFIX is the directory prefix used when installing
-# bin/arch-uclibc-gcc, bin/arch-uclibc-ld, etc.   This is only used by
-# the 'make install' target, and is not compiled into anything.  This
-# defaults to $DEVEL_PREFIX/usr, but makers of .rpms and .debs will
-# want to set this to "/usr" instead.
-SYSTEM_DEVEL_PREFIX = $(DEVEL_PREFIX)
-
-# DEVEL_TOOL_PREFIX is the directory prefix used when installing
-# bin/gcc, bin/ld, etc.   This is only used by the 'make install'
-# target, and is not compiled into anything.  This defaults to
-# $DEVEL_PREFIX/usr, but makers of .rpms and .debs may want to
-# set this to something else.
-DEVEL_TOOL_PREFIX = $(DEVEL_PREFIX)/usr
-
-# If you want 'make install' to install everything under a temporary
-# directory, the define PREFIX during the install step,
-# i.e., 'make PREFIX=/var/tmp/uClibc install'.
-#PREFIX = $(TOPDIR)/_install
+
+mainmenu "uClibc C Library Configuration"
+
+menu "Target Architecture Features and Options"
+
+choice
+	prompt "Target Processor Type"
+	default CONFIG_386
+	help
+	  This is the processor type of your CPU. This information is used for
+	  optimizing purposes.  To build a library that will run on all x86 CPU
+	  types (albeit not optimally fast), you can specify "386" here.  If
+	  you pick anything other than "386", there is no guarantee that uClibc
+	  will even run on anything other than the selected processor type.
+
+	  Here are the settings recommended for greatest speed:
+	  - "386" for the AMD/Cyrix/Intel 386DX/DXL/SL/SLC/SX, Cyrix/TI
+	    486DLC/DLC2, UMC 486SX-S and NexGen Nx586.  Only "386" kernels
+	    will run on a 386 class machine.
+	  - "486" for the AMD/Cyrix/IBM/Intel 486DX/DX2/DX4 or
+	    SL/SLC/SLC2/SLC3/SX/SX2 and UMC U5D or U5S.
+	  - "586" for generic Pentium CPUs lacking the TSC
+	    (time stamp counter) register.
+	  - "Pentium-Classic" for the Intel Pentium.
+	  - "Pentium-MMX" for the Intel Pentium MMX.
+	  - "Pentium-Pro" for the Intel Pentium Pro/Celeron/Pentium II.
+	  - "Pentium-III" for the Intel Pentium III
+	    and Celerons based on the Coppermine core.
+	  - "Pentium-4" for the Intel Pentium 4.
+	  - "K6" for the AMD K6, K6-II and K6-III (aka K6-3D).
+	  - "Athlon" for the AMD K7 family (Athlon/Duron/Thunderbird).
+	  - "Crusoe" for the Transmeta Crusoe series.
+	  - "Winchip-C6" for original IDT Winchip.
+	  - "Winchip-2" for IDT Winchip 2.
+	  - "Winchip-2A" for IDT Winchips with 3dNow! capabilities.
+	  - "CyrixIII/VIA C3" for VIA Cyrix III or VIA C3.
+
+	  If you don't know what to do, choose "386".
+
+config CONFIG_386
+	bool "386"
+
+config CONFIG_486
+	bool "486"
+
+config CONFIG_586
+	bool "586/K5/5x86/6x86/6x86MX"
+
+config CONFIG_586TSC
+	bool "Pentium-Classic"
+
+config CONFIG_586MMX
+	bool "Pentium-MMX"
+
+config CONFIG_686
+	bool "Pentium-Pro/Celeron/Pentium-II"
+
+config CONFIG_PENTIUMIII
+	bool "Pentium-III/Celeron(Coppermine)"
+
+config CONFIG_PENTIUM4
+	bool "Pentium-4"
+
+config CONFIG_K6
+	bool "K6/K6-II/K6-III"
+
+config CONFIG_K7
+	bool "Athlon/Duron/K7"
+
+config CONFIG_ELAN
+	bool "Elan"
+
+config CONFIG_CRUSOE
+	bool "Crusoe"
+
+config CONFIG_WINCHIPC6
+	bool "Winchip-C6"
+
+config CONFIG_WINCHIP2
+	bool "Winchip-2"
+
+config CONFIG_WINCHIP3D
+	bool "Winchip-2A/Winchip-3"
+
+config CONFIG_CYRIXIII
+	bool "CyrixIII/VIA-C3"
+
+endchoice
+
+config UCLIBC_HAS_MMU
+	bool "Target CPU has a memory management unit (MMU)"
+	default y
+	help
+	  If your target CPU does not have a memory management unit (MMU), 
+	  then answer N here.  Normally, Linux runs on systems with an MMU.  
+	  If you are building a uClinux system, answer N.
+
+	  Most people will answer Y.
+
+config UCLIBC_HAS_FLOATS
+	bool "Enable floating point number support"
+	default y
+	help
+	  This option allows you to entirely omit all floating point number
+	  support from uClibc.  This will cause floating point functions like
+	  strtod() to be entirely omitted from uClibc.  Other functions, such
+	  as printf() and scanf() will still be included in the library, but
+	  will not contain support for floating point numbers.
+
+	  Answering N to this option can reduce the size of uClibc.  Most people
+	  will answer Y.
+
+config HAS_FPU
+	bool "Target CPU has a floating point unit (FPU)"
+	depends on UCLIBC_HAS_FLOATS
+	default y
+	help
+	  If your target CPU does not have a floating management unit (FPU),
+	  but you wish to support floating point functions, then uClibc will
+	  need to be compiled with soft floating point support (-msoft-float).
+	  If your target CPU does not have an FPU or an FPU emulator within the
+	  Linux kernel, then you should answer N.
+
+	  Most people will answer Y.
+
+config DO_C99_MATH
+	bool "Enable full C99 math library support"
+	depends on UCLIBC_HAS_FLOATS
+	default n
+	help
+	  If you want the uClibc math library to contain the full set C99
+	  math library features, then answer Y.  If you leave this set to
+	  N the math library will contain only the math functions that were
+	  listed as part of the traditionla POSIX/IEEE 1003.1b-1993 standard.
+	  Leaving this option set to N will save around 35k on an x86 system.
+
+	  If your applications require the newer C99 math library functions, 
+	  then answer Y.
+
+config WARNINGS
+	string "Compiler Warnings"
+	default "-Wall"
+	help
+	  Set this to the set of gcc warnings you wish to see while compiling.
+
+config KERNEL_SOURCE
+	string "Linux kernel header location"
+	default "/usr/src/linux"
+	help
+	  The kernel source you use to compile with should be the same as the
+	  Linux kernel you run your apps on.  uClibc doesn't even try to achieve binary
+	  compatibility across kernel versions.  So don't expect, for example, uClibc
+	  compiled with Linux kernel 2.0.x to implement lchown properly, since 2.0.x
+	  can't do that. Similarly, if you compile uClibc vs Linux 2.4.x kernel headers,
+	  but then run on Linux 2.0.x, lchown will be compiled into uClibc, but won't
+	  work at all.  You have been warned.
+
+config C_SYMBOL_PREFIX
+	string
+	default ""
+
+config UCLIBC_UCLINUX_BROKEN_MUNMAP
+	bool
+	depends on !HAS_MMU
+	default y
+
+config HAVE_ELF
+	bool
+	default y
+
+config NO_UNDERSCORES
+	bool
+	default n
+
+config HAVE_DOT_HIDDEN
+	bool
+	default n
+
+endmenu
+
+source "extra/Configs/Config.in"
+
 
diff --git a/extra/Configs/Config.i386.default b/extra/Configs/Config.i386.default
new file mode 100644
index 000000000..3fdaa05b7
--- /dev/null
+++ b/extra/Configs/Config.i386.default
@@ -0,0 +1,73 @@
+#
+# Automatically generated make config: don't edit
+#
+
+#
+# Target Architecture Features and Options
+#
+CONFIG_386=y
+# CONFIG_486 is not set
+# CONFIG_586 is not set
+# CONFIG_586TSC is not set
+# CONFIG_586MMX is not set
+# CONFIG_686 is not set
+# CONFIG_PENTIUMIII is not set
+# CONFIG_PENTIUM4 is not set
+# CONFIG_K6 is not set
+# CONFIG_K7 is not set
+# CONFIG_ELAN is not set
+# CONFIG_CRUSOE is not set
+# CONFIG_WINCHIPC6 is not set
+# CONFIG_WINCHIP2 is not set
+# CONFIG_WINCHIP3D is not set
+# CONFIG_CYRIXIII is not set
+UCLIBC_HAS_MMU=y
+UCLIBC_HAS_FLOATS=y
+HAS_FPU=y
+# DO_C99_MATH is not set
+WARNINGS="-Wall"
+KERNEL_SOURCE="/usr/src/linux"
+C_SYMBOL_PREFIX=""
+UCLIBC_UCLINUX_BROKEN_MUNMAP=y
+HAVE_ELF=y
+# NO_UNDERSCORES is not set
+# HAVE_DOT_HIDDEN is not set
+
+#
+# General Library Settings
+#
+HAVE_PIC=y
+HAVE_SHARED=y
+BUILD_UCLIBC_LDSO=y
+UCLIBC_HAS_THREADS=y
+UCLIBC_HAS_LFS=y
+# MALLOC is not set
+MALLOC_930716=y
+HAS_SHADOW=y
+UCLIBC_HAS_REGEX=y
+UNIX98PTY_ONLY=y
+ASSUME_DEVPTS=y
+
+#
+# Networking Support
+#
+# UCLIBC_HAS_IPV6 is not set
+# UCLIBC_HAS_RPC is not set
+
+#
+# String and Stdio Support
+#
+# UCLIBC_HAS_WCHAR is not set
+# USE_OLD_VFPRINTF is not set
+
+#
+# Library Installation Options
+#
+SHARED_LIB_LOADER_PATH="$(DEVEL_PREFIX)/lib"
+DEVEL_PREFIX="/usr/$(TARGET_ARCH)-linux-uclibc"
+SYSTEM_DEVEL_PREFIX="$(DEVEL_PREFIX)"
+
+#
+# uClibc hacking options
+#
+# DODEBUG is not set
diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
new file mode 100644
index 000000000..43bc9a68c
--- /dev/null
+++ b/extra/Configs/Config.in
@@ -0,0 +1,260 @@
+#
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/config-language.txt.
+#
+
+
+menu "General Library Settings"
+
+config HAVE_PIC
+	bool "Generate Position Independent Code (PIC)"
+	default y
+	help
+	  If you wish to build uClibc with support for shared libraries then
+	  answer Y here.  If you only want to build uClibc as a static library,
+	  then answer N.
+
+config HAVE_SHARED
+	bool "Enable support for shared libraries"
+	depends on HAVE_PIC
+	default y
+	help
+	  If you wish to build uClibc with support for shared libraries then
+	  answer Y here.  If you only want to build uClibc as a static library,
+	  then answer N.
+
+config BUILD_UCLIBC_LDSO
+	bool "Compile native shared library loader"
+	depends on HAVE_SHARED
+	default y
+	help
+	  uClibc has a native shared library loader for some architectures.
+	  If you answer Y here, the uClibc native shared library loader will
+	  be built for your target architecture.  If this option is available,
+	  to you, then you almost certainly want to answer Y.
+
+config UCLIBC_HAS_THREADS
+	bool "POSIX Threading Support"
+	default y
+	help
+	  If you want to compile uClibc with pthread support, then answer Y.  
+	  This will increase the size of uClibc by adding a bunch of locking
+	  to critical data structures, and adding extra code to ensure that
+	  functions are properly reentrant.
+
+	  If your applications require pthreads, answer Y.
+
+config UCLIBC_HAS_LFS
+	bool "Large File Support"
+	default y
+	help
+	  If you wish to build uClibc with support for accessing large files 
+	  (i.e. files greater then 2 GiB) then answer Y.  Do not enable this 
+	  if you are using an older Linux kernel (2.0.x) that lacks large file 
+	  support.  Enabling this option will increase the size of uClibc.
+
+choice
+	prompt "Malloc Implementation"
+	default "malloc-930716"
+	help
+	  "malloc" use mmap for all allocations and so works very well on MMU-less
+	  systems that do not support the brk() system call.   It is pretty smart
+	  about reusing already allocated memory, and minimizing memory wastage.
+
+	  "malloc-930716" is derived from libc-5.3.12 and uses the brk() system call
+	  for all memory allocations.  This makes it very fast.  It is also pretty
+	  smart about reusing already allocated memory, and minimizing memory wastage.
+	  Because this uses brk() it will not work on uClinux MMU-less systems.
+
+	  If unsure, answer "malloc".
+
+config MALLOC
+	bool "malloc"
+
+config MALLOC_930716
+	bool "malloc-930716"
+	depends on UCLIBC_HAS_MMU
+
+endchoice
+
+config HAS_SHADOW
+	bool "Shadow Password Support"
+	default y
+	help
+	  Answer N if you do not need shadow password support.  
+	  Most people will answer Y.
+
+config UCLIBC_HAS_REGEX
+	bool "Regular Expression Support"
+	default y
+	help
+	  Posix regular expression code is really big -- 27k all by itself.
+	  If you don't use regular expressions, turn this off and save space.
+	  Of course, if you only staticly link, leave this on, since it will
+	  only be included in your apps if you use regular expressions.
+
+config UNIX98PTY_ONLY
+	bool "Support only Unix 98 PTYs"
+	default y
+	help
+	  If you want to support only Unix 98 PTYs enable this.  Some older
+	  applications may need this disabled.  For most current programs, 
+	  you can generally answer Y.
+
+config ASSUME_DEVPTS
+	bool "Assume that /dev/pts is a devpts or devfs file system"
+	default y
+	help
+	  Enable this if /dev/pts is on a devpts or devfs filesystem.  Both
+	  these filesystems automatically manage permissions on the /dev/pts 
+	  devices.  You may need to mount your devpts or devfs filesystem on
+	  /dev/pts for this to work.
+
+	  Most people should answer Y.
+
+endmenu
+
+
+
+menu "Networking Support"
+
+config UCLIBC_HAS_IPV6
+	bool "IP version 6 Support"
+	default n
+	help
+	  If you want to include support for the next version of the Internet
+	  Protocol (IP version 6) then answer Y.
+	  
+	  Most people should answer N.
+
+config UCLIBC_HAS_RPC
+	bool "Remote Procedute Call (RPC) support"
+	default n
+	help
+	  If you want to include RPC support, enable this.  RPC is rarely used 
+	  for anything except for the NFS filesystem.  Unless you plan to use NFS, 
+	  you can probably leave this set to N and save some space.  If you need
+	  to use NFS then you should answer Y.
+
+config UCLIBC_HAS_FULL_RPC
+	bool "Full RPC support"
+	depends on UCLIBC_HAS_RPC
+	default n
+	help
+	  Normally we enable just enough RPC support for things like rshd and
+	  nfs mounts to work.  If you find you need the rest of the RPC stuff, 
+	  then enable this option.  Most people can safely answer N.
+
+endmenu
+
+
+menu "String and Stdio Support"
+
+config UCLIBC_HAS_WCHAR
+	bool "Wide Charactor Support"
+	default n
+	help
+	  Answer Y to enable wide char support.  This will make uClibc much
+	  bigger.
+
+	  Most people will answer N.
+
+config UCLIBC_HAS_LOCALE
+	bool "Locale Support"
+	depends on UCLIBC_HAS_WCHAR
+	default n
+	help
+	  Answer Y to enable locale support.  This will make uClibc much
+	  bigger.
+
+	  Most people will answer N.
+
+config USE_OLD_VFPRINTF
+	bool "Use the old vfprintf implementation"
+	default n
+	help
+	  Set to true to use the old vfprintf instead of the new.  This is roughly
+	  C89 compliant, but doesn't deal with qualifiers on %n and doesn't deal with
+	  %h correctly or %hh at all on the interger conversions.  But on i386 it is
+	  over 1.5k smaller than the new code.  Of course, the new code fixes the
+	  above mentioned deficiencies and adds custom specifier support similar to
+	  glibc, as well as handling positional args.  This will be rewritten at some 
+	  point to bring it to full C89 standards compliance.
+
+	  Most people will answer N.
+
+endmenu
+
+menu "Library Installation Options"
+
+config SHARED_LIB_LOADER_PATH
+	string "Shared library loader path"
+	depends on BUILD_UCLIBC_LDSO
+	default "$(DEVEL_PREFIX)/lib"
+	help
+	  When using shared libraries, this path is the location where the
+	  shared library will be invoked.  This value will be compiled into
+	  every binary compiled with uClibc.
+
+	  BIG FAT WARNING:
+	  If you do not have a shared library loader with the correct name
+	  sitting in the directory this points to, your binaries will not 
+	  run.
+
+config SYSTEM_LDSO
+	string "System shared library loader"
+	depends on !BUILD_UCLIBC_LDSO
+	default "/lib/ld-linux.so.2"
+	help
+	  If you are using shared libraries, but do not want/have a native
+	  uClibc shared library loader, please specify the name of your
+	  target system's shared library loader here...
+
+	  BIG FAT WARNING:
+	  If you do not have a shared library loader with the correct name
+	  sitting in the directory this points to, your binaries will not 
+	  run.
+
+config DEVEL_PREFIX
+	string "uClibc development environment directory"
+	default "/usr/$(TARGET_ARCH)-linux-uclibc"
+	help
+	  DEVEL_PREFIX is the directory into which the uClibc development
+	  environment will be installed.   The result will look something
+	  like the following:
+	      $(DEVEL_PREFIX)/
+	          lib/            <contains all runtime and static libs>
+		  include/        <Where all the header files go>
+	  This value is used by the 'make install' Makefile target.  Since this
+	  directory is compiled into the uclibc cross compiler spoofer, you
+	  have to recompile uClibc if you change this value...
+
+config SYSTEM_DEVEL_PREFIX
+	string "uClibc development environment system directory"
+	default "$(DEVEL_PREFIX)"
+	help
+	  SYSTEM_DEVEL_PREFIX is the directory prefix used when installing
+	  bin/arch-uclibc-gcc, bin/arch-uclibc-ld, etc.   This is only used by
+	  the 'make install' target, and is not compiled into anything.  This
+	  defaults to $(DEVEL_PREFIX)/usr, but makers of .rpms and .debs will
+	  want to set this to "/usr" instead.
+
+endmenu
+
+menu "uClibc hacking options"
+
+config DODEBUG
+	bool "Build uClibc with debugging symbols"
+	default n
+	help
+	  Say Y here if you wish to compile uClibc with debugging symbols.
+	  This will allow you to use a debugger to examine uClibc internals
+	  while applications are running.  This increases the size of the
+	  library considerably and should only be used when doing development.
+	  If you are doing development and want to debug uClibc, answer Y.
+
+	  Otherwise, answer N.
+endmenu
+
+
+
diff --git a/extra/config/Makefile b/extra/config/Makefile
new file mode 100644
index 000000000..5b283a297
--- /dev/null
+++ b/extra/config/Makefile
@@ -0,0 +1,83 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2002 Erik Andersen <andersen@codepoet.org>
+#
+# This program is free software; you can redistribute it and/or modify it under
+# the terms of the GNU Library General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option) any
+# later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+# details.
+#
+# You should have received a copy of the GNU Library General Public License
+# along with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+TOPDIR=../../
+include $(TOPDIR)Rules.mak
+
+
+all: conf mconf
+
+NATIVE_CFLAGS=-Wall -g -O0
+
+
+CONF_SRC  =conf.c zconf.tab.c
+MCONF_SRC =mconf.c zconf.tab.c
+CONF_OBJS =$(patsubst %.c,%.o, $(CONF_SRC))
+MCONF_OBJS=$(patsubst %.c,%.o, $(MCONF_SRC))
+
+conf: $(CONF_OBJS) 
+	$(NATIVE_CC) $(NATIVE_CFLAGS) $(NATIVE_LDFLAGS) $^ -o $@
+
+mconf: $(MCONF_OBJS)
+	$(NATIVE_CC) $(NATIVE_CFLAGS) $(NATIVE_LDFLAGS) $^ -o $@
+
+lkc_deps:=lkc.h lkc_proto.h lkc_defs.h expr.h zconf.tab.h
+
+conf.o: conf.c $(lkc_deps)
+
+mconf.o: mconf.c $(lkc_deps)
+
+zconf.tab.o: zconf.tab.c lex.zconf.c confdata.c expr.c symbol.c menu.c $(lkc_deps)
+
+lex.zconf.o: lex.zconf.c $(lkc_deps)
+
+%.o : %.c
+	$(NATIVE_CC) $(NATIVE_CFLAGS) -I. -c $< -o $@
+
+lkc_defs.h: lkc_proto.h
+	sed < $< > $@ 's/P(\([^,]*\),.*/#define \1 (\*\1_p)/'
+
+###
+# The following requires flex/bison
+# By default we use the _shipped versions, uncomment the 
+# following line if you are modifying the flex/bison src.
+# LKC_GENPARSER := 1
+
+#ifdef LKC_GENPARSER
+#
+#%.tab.c %.tab.h: %.y
+#	bison -t -d -v -b $* -p $(notdir $*) $<
+#
+#lex.%.c: %.l
+#	flex -P$(notdir $*) -o$@ $<
+#else
+
+lex.zconf.c: lex.zconf.c_shipped
+	cp lex.zconf.c_shipped lex.zconf.c
+
+zconf.tab.c: zconf.tab.c_shipped
+	cp zconf.tab.c_shipped zconf.tab.c
+
+zconf.tab.h: zconf.tab.h_shipped
+	cp zconf.tab.h_shipped zconf.tab.h
+#endif
+
+clean:
+	rm -f *.o *~ core $(TARGETS) $(MCONF_OBJS) $(CONF_OBJS) \
+		conf mconf zconf.tab.c zconf.tab.h lex.zconf.c lkc_defs.h
+
diff --git a/extra/config/conf b/extra/config/conf
new file mode 100755
index 000000000..ed1a65310
Binary files /dev/null and b/extra/config/conf differ
diff --git a/extra/config/conf.c b/extra/config/conf.c
new file mode 100644
index 000000000..bf82f6664
--- /dev/null
+++ b/extra/config/conf.c
@@ -0,0 +1,565 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <sys/stat.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+static void conf(struct menu *menu);
+static void check_conf(struct menu *menu);
+
+enum {
+	ask_all,
+	ask_new,
+	ask_silent,
+	set_default,
+	set_yes,
+	set_mod,
+	set_no,
+	set_random
+} input_mode = ask_all;
+
+static int indent = 1;
+static int valid_stdin = 1;
+static int conf_cnt;
+static char line[128];
+static struct menu *rootEntry;
+
+static char nohelp_text[] = "Sorry, no help available for this option yet.\n";
+
+#if 0
+static void printc(int ch)
+{
+	static int sep = 0;
+
+	if (!sep) {
+		putchar('[');
+		sep = 1;
+	} else if (ch)
+		putchar('/');
+	if (!ch) {
+		putchar(']');
+		putchar(' ');
+		sep = 0;
+	} else
+		putchar(ch);
+}
+#endif
+
+static void printo(const char *o)
+{
+	static int sep = 0;
+
+	if (!sep) {
+		putchar('(');
+		sep = 1;
+	} else if (o) {
+		putchar(',');
+		putchar(' ');
+	}
+	if (!o) {
+		putchar(')');
+		putchar(' ');
+		sep = 0;
+	} else
+		printf("%s", o);
+}
+
+static void strip(char *str)
+{
+	char *p = str;
+	int l;
+
+	while ((isspace(*p)))
+		p++;
+	l = strlen(p);
+	if (p != str)
+		memmove(str, p, l + 1);
+	if (!l)
+		return;
+	p = str + l - 1;
+	while ((isspace(*p)))
+		*p-- = 0;
+}
+
+static void conf_askvalue(struct symbol *sym, const char *def)
+{
+	enum symbol_type type = sym_get_type(sym);
+	tristate val;
+
+	if (!sym_has_value(sym))
+		printf("(NEW) ");
+
+	line[0] = '\n';
+	line[1] = 0;
+
+	switch (input_mode) {
+	case ask_new:
+	case ask_silent:
+		if (sym_has_value(sym)) {
+			printf("%s\n", def);
+			return;
+		}
+		if (!valid_stdin && input_mode == ask_silent) {
+			printf("aborted!\n\n");
+			printf("Console input/output is redirected. ");
+			printf("Run 'make oldconfig' to update configuration.\n\n");
+			exit(1);
+		}
+	case ask_all:
+		fgets(line, 128, stdin);
+		return;
+	case set_default:
+		printf("%s\n", def);
+		return;
+	default:
+		break;
+	}
+
+	switch (type) {
+	case S_INT:
+	case S_HEX:
+	case S_STRING:
+		printf("%s\n", def);
+		return;
+	default:
+		;
+	}
+	switch (input_mode) {
+	case set_yes:
+		if (sym_tristate_within_range(sym, yes)) {
+			line[0] = 'y';
+			line[1] = '\n';
+			line[2] = 0;
+			break;
+		}
+	case set_mod:
+		if (type == S_TRISTATE) {
+			if (sym_tristate_within_range(sym, mod)) {
+				line[0] = 'm';
+				line[1] = '\n';
+				line[2] = 0;
+				break;
+			}
+		} else {
+			if (sym_tristate_within_range(sym, yes)) {
+				line[0] = 'y';
+				line[1] = '\n';
+				line[2] = 0;
+				break;
+			}
+		}
+	case set_no:
+		if (sym_tristate_within_range(sym, no)) {
+			line[0] = 'n';
+			line[1] = '\n';
+			line[2] = 0;
+			break;
+		}
+	case set_random:
+		do {
+			val = (tristate)(random() % 3);
+		} while (!sym_tristate_within_range(sym, val));
+		switch (val) {
+		case no: line[0] = 'n'; break;
+		case mod: line[0] = 'm'; break;
+		case yes: line[0] = 'y'; break;
+		}
+		line[1] = '\n';
+		line[2] = 0;
+		break;
+	default:
+		break;
+	}
+	printf("%s", line);
+}
+
+int conf_string(struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	const char *def, *help;
+
+	while (1) {
+		printf("%*s%s ", indent - 1, "", menu->prompt->text);
+		printf("(%s) ", sym->name);
+		def = sym_get_string_value(sym);
+		if (sym_get_string_value(sym))
+			printf("[%s] ", def);
+		conf_askvalue(sym, def);
+		switch (line[0]) {
+		case '\n':
+			break;
+		case '?':
+			/* print help */
+			if (line[1] == 0) {
+				help = nohelp_text;
+				if (menu->sym->help)
+					help = menu->sym->help;
+				printf("\n%s\n", menu->sym->help);
+				def = NULL;
+				break;
+			}
+		default:
+			line[strlen(line)-1] = 0;
+			def = line;
+		}
+		if (def && sym_set_string_value(sym, def))
+			return 0;
+	}
+}
+
+static int conf_sym(struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	int type;
+	tristate oldval, newval;
+	const char *help;
+
+	while (1) {
+		printf("%*s%s ", indent - 1, "", menu->prompt->text);
+		if (sym->name)
+			printf("(%s) ", sym->name);
+		type = sym_get_type(sym);
+		putchar('[');
+		oldval = sym_get_tristate_value(sym);
+		switch (oldval) {
+		case no:
+			putchar('N');
+			break;
+		case mod:
+			putchar('M');
+			break;
+		case yes:
+			putchar('Y');
+			break;
+		}
+		if (oldval != no && sym_tristate_within_range(sym, no))
+			printf("/n");
+		if (oldval != mod && sym_tristate_within_range(sym, mod))
+			printf("/m");
+		if (oldval != yes && sym_tristate_within_range(sym, yes))
+			printf("/y");
+		if (sym->help)
+			printf("/?");
+		printf("] ");
+		conf_askvalue(sym, sym_get_string_value(sym));
+		strip(line);
+
+		switch (line[0]) {
+		case 'n':
+		case 'N':
+			newval = no;
+			if (!line[1] || !strcmp(&line[1], "o"))
+				break;
+			continue;
+		case 'm':
+		case 'M':
+			newval = mod;
+			if (!line[1])
+				break;
+			continue;
+		case 'y':
+		case 'Y':
+			newval = yes;
+			if (!line[1] || !strcmp(&line[1], "es"))
+				break;
+			continue;
+		case 0:
+			newval = oldval;
+			break;
+		case '?':
+			goto help;
+		default:
+			continue;
+		}
+		if (sym_set_tristate_value(sym, newval))
+			return 0;
+help:
+		help = nohelp_text;
+		if (sym->help)
+			help = sym->help;
+		printf("\n%s\n", help);
+	}
+}
+
+static int conf_choice(struct menu *menu)
+{
+	struct symbol *sym, *def_sym;
+	struct menu *cmenu, *def_menu;
+	const char *help;
+	int type, len;
+	bool is_new;
+
+	sym = menu->sym;
+	type = sym_get_type(sym);
+	is_new = !sym_has_value(sym);
+	if (sym_is_changable(sym)) {
+		conf_sym(menu);
+		sym_calc_value(sym);
+		switch (sym_get_tristate_value(sym)) {
+		case no:
+			return 1;
+		case mod:
+			return 0;
+		case yes:
+			break;
+		}
+	} else {
+		sym->def = sym->curr;
+		if (S_TRI(sym->curr) == mod) {
+			printf("%*s%s\n", indent - 1, "", menu_get_prompt(menu));
+			return 0;
+		}
+	}
+
+	while (1) {
+		printf("%*s%s ", indent - 1, "", menu_get_prompt(menu));
+		def_sym = sym_get_choice_value(sym);
+		def_menu = NULL;
+		for (cmenu = menu->list; cmenu; cmenu = cmenu->next) {
+			if (!menu_is_visible(cmenu))
+				continue;
+			printo(menu_get_prompt(cmenu));
+			if (cmenu->sym == def_sym)
+				def_menu = cmenu;
+		}
+		printo(NULL);
+		if (def_menu)
+			printf("[%s] ", menu_get_prompt(def_menu));
+		else {
+			printf("\n");
+			return 1;
+		}
+		switch (input_mode) {
+		case ask_new:
+		case ask_silent:
+		case ask_all:
+			conf_askvalue(sym, menu_get_prompt(def_menu));
+			strip(line);
+			break;
+		default:
+			line[0] = 0;
+			printf("\n");
+		}
+		if (line[0] == '?' && !line[1]) {
+			help = nohelp_text;
+			if (menu->sym->help)
+				help = menu->sym->help;
+			printf("\n%s\n", help);
+			continue;
+		}
+		if (line[0]) {
+			len = strlen(line) - 1;
+			line[len] = 0;
+
+			def_menu = NULL;
+			for (cmenu = menu->list; cmenu; cmenu = cmenu->next) {
+				if (!cmenu->sym || !menu_is_visible(cmenu))
+					continue;
+				if (!strncmp(line, menu_get_prompt(cmenu), len)) {
+					def_menu = cmenu;
+					break;
+				}
+			}
+		}
+		if (def_menu) {
+			sym_set_choice_value(sym, def_menu->sym);
+			if (def_menu->list) {
+				indent += 2;
+				conf(def_menu->list);
+				indent -= 2;
+			}
+			return 1;
+		}
+	}
+}
+
+static void conf(struct menu *menu)
+{
+	struct symbol *sym;
+	struct property *prop;
+	struct menu *child;
+
+	if (!menu_is_visible(menu))
+		return;
+
+	sym = menu->sym;
+	prop = menu->prompt;
+	if (prop) {
+		const char *prompt;
+
+		switch (prop->type) {
+		case P_MENU:
+			if (input_mode == ask_silent && rootEntry != menu) {
+				check_conf(menu);
+				return;
+			}
+		case P_COMMENT:
+			prompt = menu_get_prompt(menu);
+			if (prompt)
+				printf("%*c\n%*c %s\n%*c\n",
+					indent, '*',
+					indent, '*', prompt,
+					indent, '*');
+		default:
+			;
+		}
+	}
+
+	if (!sym)
+		goto conf_childs;
+
+	if (sym_is_choice(sym)) {
+		conf_choice(menu);
+		if (S_TRI(sym->curr) != mod)
+			return;
+		goto conf_childs;
+	}
+
+	switch (sym->type) {
+	case S_INT:
+	case S_HEX:
+	case S_STRING:
+		conf_string(menu);
+		break;
+	default:
+		conf_sym(menu);
+		break;
+	}
+
+conf_childs:
+	if (sym)
+		indent += 2;
+	for (child = menu->list; child; child = child->next)
+		conf(child);
+	if (sym)
+		indent -= 2;
+}
+
+static void check_conf(struct menu *menu)
+{
+	struct symbol *sym;
+	struct menu *child;
+
+	if (!menu_is_visible(menu))
+		return;
+
+	sym = menu->sym;
+	if (!sym)
+		goto conf_childs;
+
+	if (sym_is_choice(sym)) {
+		if (!sym_has_value(sym)) {
+			if (!conf_cnt++)
+				printf("*\n* Restart config...\n*\n");
+			rootEntry = menu_get_parent_menu(menu);
+			conf(rootEntry);
+		}
+		if (sym_get_tristate_value(sym) != mod)
+			return;
+		goto conf_childs;
+	}
+
+	if (!sym_has_value(sym)) {
+		if (!conf_cnt++)
+			printf("*\n* Restart config...\n*\n");
+		rootEntry = menu_get_parent_menu(menu);
+		conf(rootEntry);
+	}
+
+conf_childs:
+	for (child = menu->list; child; child = child->next)
+		check_conf(child);
+}
+
+int main(int ac, char **av)
+{
+	const char *name;
+	struct stat tmpstat;
+
+	if (ac > 1 && av[1][0] == '-') {
+		switch (av[1][1]) {
+		case 'o':
+			input_mode = ask_new;
+			break;
+		case 's':
+			input_mode = ask_silent;
+			valid_stdin = isatty(0) && isatty(1) && isatty(2);
+			break;
+		case 'd':
+			input_mode = set_default;
+			break;
+		case 'n':
+			input_mode = set_no;
+			break;
+		case 'm':
+			input_mode = set_mod;
+			break;
+		case 'y':
+			input_mode = set_yes;
+			break;
+		case 'r':
+			input_mode = set_random;
+			srandom(time(NULL));
+			break;
+		case 'h':
+		case '?':
+			printf("%s [-o|-s] config\n", av[0]);
+			exit(0);
+		}
+		name = av[2];
+	} else
+		name = av[1];
+	conf_parse(name);
+	//zconfdump(stdout);
+	switch (input_mode) {
+	case set_default:
+		name = conf_get_default_confname();
+		if (conf_read(name)) {
+			printf("***\n"
+				"*** Can't find default configuration \"%s\"!\n"
+				"***\n", name);
+			exit(1);
+		}
+		break;
+	case ask_silent:
+		if (stat(".config", &tmpstat)) {
+			printf("***\n"
+				"*** You have not yet configured uClibc!\n"
+				"***\n"
+				"*** Please run some configurator (e.g. \"make oldconfig\"\n"
+				"*** or \"make menuconfig\").\n"
+				"***\n");
+			exit(1);
+		}
+	case ask_all:
+	case ask_new:
+		conf_read(NULL);
+		break;
+	default:
+		break;
+	}
+
+	if (input_mode != ask_silent) {
+		rootEntry = &rootmenu;
+		conf(&rootmenu);
+		if (input_mode == ask_all) {
+			input_mode = ask_silent;
+			valid_stdin = 1;
+		}
+	}
+	do {
+		conf_cnt = 0;
+		check_conf(&rootmenu);
+	} while (conf_cnt);
+	conf_write(NULL);
+	return 0;
+}
diff --git a/extra/config/confdata.c b/extra/config/confdata.c
new file mode 100644
index 000000000..00e87486a
--- /dev/null
+++ b/extra/config/confdata.c
@@ -0,0 +1,370 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+const char conf_def_filename[] = ".config";
+char conf_filename[PATH_MAX+1];
+
+const char conf_defname[] = "extra/Configs/Config.$TARGET_ARCH.default";
+
+const char *conf_confnames[] = {
+	".config",
+	conf_defname,
+	NULL,
+};
+
+static char *conf_expand_value(const char *in)
+{
+	struct symbol *sym;
+	const char *src;
+	static char res_value[SYMBOL_MAXLENGTH];
+	char *dst, name[SYMBOL_MAXLENGTH];
+
+	res_value[0] = 0;
+	dst = name;
+	while ((src = strchr(in, '$'))) {
+		strncat(res_value, in, src - in);
+		src++;
+		dst = name;
+		while (isalnum(*src) || *src == '_')
+			*dst++ = *src++;
+		*dst = 0;
+		sym = sym_lookup(name, 0);
+		sym_calc_value(sym);
+		strcat(res_value, sym_get_string_value(sym));
+		in = src;
+	}
+	strcat(res_value, in);
+
+	return res_value;
+}
+
+char *conf_get_default_confname(void)
+{
+	return conf_expand_value(conf_defname);
+}
+
+int conf_read(const char *name)
+{
+	FILE *in = NULL;
+	char line[128];
+	char *p, *p2;
+	int lineno = 0;
+	struct symbol *sym;
+	struct property *prop;
+	struct expr *e;
+	int i;
+
+	if (name) {
+		in = fopen(name, "r");
+		if (in)
+			strcpy(conf_filename, name);
+	} else {
+		const char **names = conf_confnames;
+		while ((name = *names++)) {
+			name = conf_expand_value(name);
+			in = fopen(name, "r");
+			if (in) {
+				printf("#\n"
+				       "# using defaults found in %s\n"
+				       "#\n", name);
+				break;
+			}
+		}
+	}
+
+	if (!in)
+		return 1;
+
+	for_all_symbols(i, sym) {
+		sym->flags |= SYMBOL_NEW;
+		switch (sym->type) {
+		case S_INT:
+		case S_HEX:
+		case S_STRING:
+			if (S_VAL(sym->def)) {
+				free(S_VAL(sym->def));
+				S_VAL(sym->def) = NULL;
+			}
+		default:
+			;
+		}
+	}
+
+	while (fgets(line, 128, in)) {
+		lineno++;
+		switch (line[0]) {
+		case '\n':
+			break;
+		case ' ':
+			break;
+		case '#':
+			p = strchr(line, ' ');
+			if (!p)
+				continue;
+			*p++ = 0;
+			p = strchr(p, ' ');
+			if (!p)
+				continue;
+			*p++ = 0;
+			if (strncmp(p, "is not set", 10))
+				continue;
+			sym = sym_lookup(line+2, 0);
+			switch (sym->type) {
+			case S_BOOLEAN:
+			case S_TRISTATE:
+				sym->def = symbol_no.curr;
+				sym->flags &= ~SYMBOL_NEW;
+				break;
+			default:
+				;
+			}
+			break;
+		case 'A' ... 'Z':
+			p = strchr(line, '=');
+			if (!p)
+				continue;
+			*p++ = 0;
+			p2 = strchr(p, '\n');
+			if (p2)
+				*p2 = 0;
+			sym = sym_find(line);
+			if (!sym) {
+				fprintf(stderr, "%s:%d: trying to assign nonexistent symbol %s\n", name, lineno, line);
+				break;
+			}
+			switch (sym->type) {
+			case S_BOOLEAN:
+				sym->def = symbol_yes.curr;
+				sym->flags &= ~SYMBOL_NEW;
+				break;
+			case S_TRISTATE:
+				if (p[0] == 'm')
+					sym->def = symbol_mod.curr;
+				else
+					sym->def = symbol_yes.curr;
+				sym->flags &= ~SYMBOL_NEW;
+				break;
+			case S_STRING:
+				if (*p++ != '"')
+					break;
+				for (p2 = p; (p2 = strpbrk(p2, "\"\\")); p2++) {
+					if (*p2 == '"') {
+						*p2 = 0;
+						break;
+					}
+					memmove(p2, p2 + 1, strlen(p2));
+				}
+			case S_INT:
+			case S_HEX:
+				if (sym_string_valid(sym, p)) {
+					S_VAL(sym->def) = strdup(p);
+					sym->flags &= ~SYMBOL_NEW;
+				} else
+					fprintf(stderr, "%s:%d:symbol value '%s' invalid for %s\n", name, lineno, p, sym->name);
+				break;
+			default:
+				;
+			}
+			if (sym_is_choice_value(sym)) {
+				prop = sym_get_choice_prop(sym);
+				switch (S_TRI(sym->def)) {
+				case mod:
+					if (S_TRI(prop->def->def) == yes)
+						/* warn? */;
+					break;
+				case yes:
+					if (S_TRI(prop->def->def) != no)
+						/* warn? */;
+					S_VAL(prop->def->def) = sym;
+					break;
+				case no:
+					break;
+				}
+				S_TRI(prop->def->def) = S_TRI(sym->def);
+			}
+			break;
+		default:
+			continue;
+		}
+	}
+	fclose(in);
+
+	for_all_symbols(i, sym) {
+		if (!sym_is_choice(sym))
+			continue;
+		prop = sym_get_choice_prop(sym);
+		for (e = prop->dep; e; e = e->left.expr)
+			sym->flags |= e->right.sym->flags & SYMBOL_NEW;
+		sym->flags &= ~SYMBOL_NEW;
+	}
+
+	sym_change_count = 1;
+
+	return 0;
+}
+
+int conf_write(const char *name)
+{
+	FILE *out, *out_h;
+	struct symbol *sym;
+	struct menu *menu;
+	char oldname[128];
+	int type, l;
+	const char *str;
+
+	out = fopen(".tmpconfig", "w");
+	if (!out)
+		return 1;
+	out_h = fopen(".tmpconfig.h", "w");
+	if (!out_h)
+		return 1;
+	fprintf(out, "#\n"
+		     "# Automatically generated make config: don't edit\n"
+		     "#\n");
+	fprintf(out_h, "/*\n"
+		       " * Automatically generated C config: don't edit\n"
+		       " */\n"
+		       "#if !defined __FEATURES_H && !defined __need_uClibc_config_h\n"
+		       "#error Never include <bits/uClibc_config.h> directly; use <features.h> instead.\n"
+		       "#endif\n"
+		       "#define AUTOCONF_INCLUDED\n\n"
+		       "/*\n"
+		       " * Version Number\n"
+		       " */\n"
+		       "#define __UCLIBC_MAJOR__ %s\n"
+		       "#define __UCLIBC_MINOR__ %s\n"
+		       "#define __UCLIBC_SUBLEVEL__ %s\n",
+		       getenv("MAJOR_VERSION"),
+		       getenv("MINOR_VERSION"),
+		       getenv("SUBLEVEL")
+       );
+
+	if (!sym_change_count)
+		sym_clear_all_valid();
+
+	menu = rootmenu.list;
+	while (menu) {
+		sym = menu->sym;
+		if (!sym) {
+			if (!menu_is_visible(menu))
+				goto next;
+			str = menu_get_prompt(menu);
+			fprintf(out, "\n"
+				     "#\n"
+				     "# %s\n"
+				     "#\n", str);
+			fprintf(out_h, "\n"
+				       "/*\n"
+				       " * %s\n"
+				       " */\n", str);
+		} else if (!(sym->flags & SYMBOL_CHOICE)) {
+			sym_calc_value(sym);
+			if (!(sym->flags & SYMBOL_WRITE))
+				goto next;
+			sym->flags &= ~SYMBOL_WRITE;
+			type = sym->type;
+			if (type == S_TRISTATE) {
+				sym_calc_value(modules_sym);
+				if (S_TRI(modules_sym->curr) == no)
+					type = S_BOOLEAN;
+			}
+			switch (type) {
+			case S_BOOLEAN:
+			case S_TRISTATE:
+				switch (sym_get_tristate_value(sym)) {
+				case no:
+					fprintf(out, "# %s is not set\n", sym->name);
+					fprintf(out_h, "#undef __%s__\n", sym->name);
+					break;
+				case mod:
+					fprintf(out, "%s=m\n", sym->name);
+					fprintf(out_h, "#define __%s__MODULE 1\n", sym->name);
+					break;
+				case yes:
+					fprintf(out, "%s=y\n", sym->name);
+					fprintf(out_h, "#define __%s__ 1\n", sym->name);
+					break;
+				}
+				break;
+			case S_STRING:
+				// fix me
+				str = sym_get_string_value(sym);
+				fprintf(out, "%s=\"", sym->name);
+				fprintf(out_h, "#define __%s__ \"", sym->name);
+				do {
+					l = strcspn(str, "\"\\");
+					if (l) {
+						fwrite(str, l, 1, out);
+						fwrite(str, l, 1, out_h);
+					}
+					str += l;
+					while (*str == '\\' || *str == '"') {
+						fprintf(out, "\\%c", *str);
+						fprintf(out_h, "\\%c", *str);
+						str++;
+					}
+				} while (*str);
+				fputs("\"\n", out);
+				fputs("\"\n", out_h);
+				break;
+			case S_HEX:
+				str = sym_get_string_value(sym);
+				if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
+					fprintf(out, "%s=%s\n", sym->name, str);
+					fprintf(out_h, "#define __%s__ 0x%s\n", sym->name, str);
+					break;
+				}
+			case S_INT:
+				str = sym_get_string_value(sym);
+				fprintf(out, "%s=%s\n", sym->name, str);
+				fprintf(out_h, "#define __%s__ %s\n", sym->name, str);
+				break;
+			}
+		}
+
+	next:
+		if (menu->list) {
+			menu = menu->list;
+			continue;
+		}
+		if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+	fclose(out);
+	fclose(out_h);
+
+	if (!name) {
+		rename(".tmpconfig.h", "include/bits/uClibc_config.h");
+		name = conf_def_filename;
+		file_write_dep(NULL);
+	} else
+		unlink(".tmpconfig.h");
+
+	sprintf(oldname, "%s.old", name);
+	rename(name, oldname);
+	if (rename(".tmpconfig", name))
+		return 1;
+	strcpy(conf_filename, name);
+
+	sym_change_count = 0;
+
+	return 0;
+}
diff --git a/extra/config/expr.c b/extra/config/expr.c
new file mode 100644
index 000000000..d1af2a581
--- /dev/null
+++ b/extra/config/expr.c
@@ -0,0 +1,1054 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+struct expr *expr_alloc_symbol(struct symbol *sym)
+{
+	struct expr *e = malloc(sizeof(*e));
+	memset(e, 0, sizeof(*e));
+	e->type = E_SYMBOL;
+	e->left.sym = sym;
+	return e;
+}
+
+struct expr *expr_alloc_one(enum expr_type type, struct expr *ce)
+{
+	struct expr *e = malloc(sizeof(*e));
+	memset(e, 0, sizeof(*e));
+	e->type = type;
+	e->left.expr = ce;
+	return e;
+}
+
+struct expr *expr_alloc_two(enum expr_type type, struct expr *e1, struct expr *e2)
+{
+	struct expr *e = malloc(sizeof(*e));
+	memset(e, 0, sizeof(*e));
+	e->type = type;
+	e->left.expr = e1;
+	e->right.expr = e2;
+	return e;
+}
+
+struct expr *expr_alloc_comp(enum expr_type type, struct symbol *s1, struct symbol *s2)
+{
+	struct expr *e = malloc(sizeof(*e));
+	memset(e, 0, sizeof(*e));
+	e->type = type;
+	e->left.sym = s1;
+	e->right.sym = s2;
+	return e;
+}
+
+struct expr *expr_alloc_and(struct expr *e1, struct expr *e2)
+{
+	if (!e1)
+		return e2;
+	return e2 ? expr_alloc_two(E_AND, e1, e2) : e1;
+}
+
+struct expr *expr_copy(struct expr *org)
+{
+	struct expr *e;
+
+	if (!org)
+		return NULL;
+
+	e = malloc(sizeof(*org));
+	memcpy(e, org, sizeof(*org));
+	switch (org->type) {
+	case E_SYMBOL:
+		e->left = org->left;
+		break;
+	case E_NOT:
+		e->left.expr = expr_copy(org->left.expr);
+		break;
+	case E_EQUAL:
+	case E_UNEQUAL:
+		e->left.sym = org->left.sym;
+		e->right.sym = org->right.sym;
+		break;
+	case E_AND:
+	case E_OR:
+	case E_CHOICE:
+		e->left.expr = expr_copy(org->left.expr);
+		e->right.expr = expr_copy(org->right.expr);
+		break;
+	default:
+		printf("can't copy type %d\n", e->type);
+		free(e);
+		e = NULL;
+		break;
+	}
+
+	return e;
+}
+
+void expr_free(struct expr *e)
+{
+	if (!e)
+		return;
+
+	switch (e->type) {
+	case E_SYMBOL:
+		break;
+	case E_NOT:
+		expr_free(e->left.expr);
+		return;
+	case E_EQUAL:
+	case E_UNEQUAL:
+		break;
+	case E_OR:
+	case E_AND:
+		expr_free(e->left.expr);
+		expr_free(e->right.expr);
+		break;
+	default:
+		printf("how to free type %d?\n", e->type);
+		break;
+	}
+	free(e);
+}
+
+static int trans_count;
+
+#define e1 (*ep1)
+#define e2 (*ep2)
+
+static void __expr_eliminate_eq(enum expr_type type, struct expr **ep1, struct expr **ep2)
+{
+	if (e1->type == type) {
+		__expr_eliminate_eq(type, &e1->left.expr, &e2);
+		__expr_eliminate_eq(type, &e1->right.expr, &e2);
+		return;
+	}
+	if (e2->type == type) {
+		__expr_eliminate_eq(type, &e1, &e2->left.expr);
+		__expr_eliminate_eq(type, &e1, &e2->right.expr);
+		return;
+	}
+	if (e1->type == E_SYMBOL && e2->type == E_SYMBOL &&
+	    e1->left.sym == e2->left.sym && (e1->left.sym->flags & (SYMBOL_YES|SYMBOL_NO)))
+		return;
+	if (!expr_eq(e1, e2))
+		return;
+	trans_count++;
+	expr_free(e1); expr_free(e2);
+	switch (type) {
+	case E_OR:
+		e1 = expr_alloc_symbol(&symbol_no);
+		e2 = expr_alloc_symbol(&symbol_no);
+		break;
+	case E_AND:
+		e1 = expr_alloc_symbol(&symbol_yes);
+		e2 = expr_alloc_symbol(&symbol_yes);
+		break;
+	default:
+		;
+	}
+}
+
+void expr_eliminate_eq(struct expr **ep1, struct expr **ep2)
+{
+	if (!e1 || !e2 || e1->type != e2->type)
+		return;
+	__expr_eliminate_eq(e1->type, ep1, ep2);
+	e1 = expr_eliminate_yn(e1);
+	e2 = expr_eliminate_yn(e2);
+}
+
+#undef e1
+#undef e2
+
+int expr_eq(struct expr *e1, struct expr *e2)
+{
+	int res, old_count;
+
+	if (e1->type != e2->type)
+		return 0;
+	switch (e1->type) {
+	case E_EQUAL:
+	case E_UNEQUAL:
+		return e1->left.sym == e2->left.sym && e1->right.sym == e2->right.sym;
+	case E_SYMBOL:
+		return e1->left.sym == e2->left.sym;
+	case E_NOT:
+		return expr_eq(e1->left.expr, e2->left.expr);
+	case E_AND:
+	case E_OR:
+		e1 = expr_copy(e1);
+		e2 = expr_copy(e2);
+		old_count = trans_count;
+		expr_eliminate_eq(&e1, &e2);
+		res = (e1->type == E_SYMBOL && e2->type == E_SYMBOL &&
+		       e1->left.sym == e2->left.sym);
+		expr_free(e1);
+		expr_free(e2);
+		trans_count = old_count;
+		return res;
+	case E_CHOICE:
+	case E_NONE:
+		/* panic */;
+	}
+
+	print_expr(0, e1, 0);
+	printf(" = ");
+	print_expr(0, e2, 0);
+	printf(" ?\n");
+
+	return 0;
+}
+
+struct expr *expr_eliminate_yn(struct expr *e)
+{
+	struct expr *tmp;
+
+	if (e) switch (e->type) {
+	case E_AND:
+		e->left.expr = expr_eliminate_yn(e->left.expr);
+		e->right.expr = expr_eliminate_yn(e->right.expr);
+		if (e->left.expr->type == E_SYMBOL) {
+			if (e->left.expr->left.sym == &symbol_no) {
+				expr_free(e->left.expr);
+				expr_free(e->right.expr);
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_no;
+				e->right.expr = NULL;
+				return e;
+			} else if (e->left.expr->left.sym == &symbol_yes) {
+				free(e->left.expr);
+				tmp = e->right.expr;
+				*e = *(e->right.expr);
+				free(tmp);
+				return e;
+			}
+		}
+		if (e->right.expr->type == E_SYMBOL) {
+			if (e->right.expr->left.sym == &symbol_no) {
+				expr_free(e->left.expr);
+				expr_free(e->right.expr);
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_no;
+				e->right.expr = NULL;
+				return e;
+			} else if (e->right.expr->left.sym == &symbol_yes) {
+				free(e->right.expr);
+				tmp = e->left.expr;
+				*e = *(e->left.expr);
+				free(tmp);
+				return e;
+			}
+		}
+		break;
+	case E_OR:
+		e->left.expr = expr_eliminate_yn(e->left.expr);
+		e->right.expr = expr_eliminate_yn(e->right.expr);
+		if (e->left.expr->type == E_SYMBOL) {
+			if (e->left.expr->left.sym == &symbol_no) {
+				free(e->left.expr);
+				tmp = e->right.expr;
+				*e = *(e->right.expr);
+				free(tmp);
+				return e;
+			} else if (e->left.expr->left.sym == &symbol_yes) {
+				expr_free(e->left.expr);
+				expr_free(e->right.expr);
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_yes;
+				e->right.expr = NULL;
+				return e;
+			}
+		}
+		if (e->right.expr->type == E_SYMBOL) {
+			if (e->right.expr->left.sym == &symbol_no) {
+				free(e->right.expr);
+				tmp = e->left.expr;
+				*e = *(e->left.expr);
+				free(tmp);
+				return e;
+			} else if (e->right.expr->left.sym == &symbol_yes) {
+				expr_free(e->left.expr);
+				expr_free(e->right.expr);
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_yes;
+				e->right.expr = NULL;
+				return e;
+			}
+		}
+		break;
+	default:
+		;
+	}
+	return e;
+}
+
+/*
+ * bool FOO!=n => FOO
+ */
+struct expr *expr_trans_bool(struct expr *e)
+{
+	if (!e)
+		return NULL;
+	switch (e->type) {
+	case E_AND:
+	case E_OR:
+	case E_NOT:
+		e->left.expr = expr_trans_bool(e->left.expr);
+		e->right.expr = expr_trans_bool(e->right.expr);
+		break;
+	case E_UNEQUAL:
+		// FOO!=n -> FOO
+		if (e->left.sym->type == S_TRISTATE) {
+			if (e->right.sym == &symbol_no) {
+				e->type = E_SYMBOL;
+				e->right.sym = NULL;
+			}
+		}
+		break;
+	default:
+		;
+	}
+	return e;
+}
+
+/*
+ * e1 || e2 -> ?
+ */
+struct expr *expr_join_or(struct expr *e1, struct expr *e2)
+{
+	struct expr *tmp;
+	struct symbol *sym1, *sym2;
+
+	if (expr_eq(e1, e2))
+		return expr_copy(e1);
+	if (e1->type != E_EQUAL && e1->type != E_UNEQUAL && e1->type != E_SYMBOL && e1->type != E_NOT)
+		return NULL;
+	if (e2->type != E_EQUAL && e2->type != E_UNEQUAL && e2->type != E_SYMBOL && e2->type != E_NOT)
+		return NULL;
+	if (e1->type == E_NOT) {
+		tmp = e1->left.expr;
+		if (tmp->type != E_EQUAL && tmp->type != E_UNEQUAL && tmp->type != E_SYMBOL)
+			return NULL;
+		sym1 = tmp->left.sym;
+	} else
+		sym1 = e1->left.sym;
+	if (e2->type == E_NOT) {
+		if (e2->left.expr->type != E_SYMBOL)
+			return NULL;
+		sym2 = e2->left.expr->left.sym;
+	} else
+		sym2 = e2->left.sym;
+	if (sym1 != sym2)
+		return NULL;
+	if (sym1->type != S_BOOLEAN && sym1->type != S_TRISTATE)
+		return NULL;
+	if (sym1->type == S_TRISTATE) {
+		if (e1->type == E_EQUAL && e2->type == E_EQUAL &&
+		    ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_mod) ||
+		     (e1->right.sym == &symbol_mod && e2->right.sym == &symbol_yes))) {
+			// (a='y') || (a='m') -> (a!='n')
+			return expr_alloc_comp(E_UNEQUAL, sym1, &symbol_no);
+		}
+		if (e1->type == E_EQUAL && e2->type == E_EQUAL &&
+		    ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_no) ||
+		     (e1->right.sym == &symbol_no && e2->right.sym == &symbol_yes))) {
+			// (a='y') || (a='n') -> (a!='m')
+			return expr_alloc_comp(E_UNEQUAL, sym1, &symbol_mod);
+		}
+		if (e1->type == E_EQUAL && e2->type == E_EQUAL &&
+		    ((e1->right.sym == &symbol_mod && e2->right.sym == &symbol_no) ||
+		     (e1->right.sym == &symbol_no && e2->right.sym == &symbol_mod))) {
+			// (a='m') || (a='n') -> (a!='y')
+			return expr_alloc_comp(E_UNEQUAL, sym1, &symbol_yes);
+		}
+	}
+	if (sym1->type == S_BOOLEAN && sym1 == sym2) {
+		if ((e1->type == E_NOT && e1->left.expr->type == E_SYMBOL && e2->type == E_SYMBOL) ||
+		    (e2->type == E_NOT && e2->left.expr->type == E_SYMBOL && e1->type == E_SYMBOL))
+			return expr_alloc_symbol(&symbol_yes);
+	}
+
+	printf("optimize ");
+	print_expr(0, e1, 0);
+	printf(" || ");
+	print_expr(0, e2, 0);
+	printf(" ?\n");
+	return NULL;
+}
+
+struct expr *expr_join_and(struct expr *e1, struct expr *e2)
+{
+	struct expr *tmp;
+	struct symbol *sym1, *sym2;
+
+	if (expr_eq(e1, e2))
+		return expr_copy(e1);
+	if (e1->type != E_EQUAL && e1->type != E_UNEQUAL && e1->type != E_SYMBOL && e1->type != E_NOT)
+		return NULL;
+	if (e2->type != E_EQUAL && e2->type != E_UNEQUAL && e2->type != E_SYMBOL && e2->type != E_NOT)
+		return NULL;
+	if (e1->type == E_NOT) {
+		tmp = e1->left.expr;
+		if (tmp->type != E_EQUAL && tmp->type != E_UNEQUAL && tmp->type != E_SYMBOL)
+			return NULL;
+		sym1 = tmp->left.sym;
+	} else
+		sym1 = e1->left.sym;
+	if (e2->type == E_NOT) {
+		if (e2->left.expr->type != E_SYMBOL)
+			return NULL;
+		sym2 = e2->left.expr->left.sym;
+	} else
+		sym2 = e2->left.sym;
+	if (sym1 != sym2)
+		return NULL;
+	if (sym1->type != S_BOOLEAN && sym1->type != S_TRISTATE)
+		return NULL;
+
+	if ((e1->type == E_SYMBOL && e2->type == E_EQUAL && e2->right.sym == &symbol_yes) ||
+	    (e2->type == E_SYMBOL && e1->type == E_EQUAL && e1->right.sym == &symbol_yes))
+		// (a) && (a='y') -> (a='y')
+		return expr_alloc_comp(E_EQUAL, sym1, &symbol_yes);
+
+	if ((e1->type == E_SYMBOL && e2->type == E_UNEQUAL && e2->right.sym == &symbol_no) ||
+	    (e2->type == E_SYMBOL && e1->type == E_UNEQUAL && e1->right.sym == &symbol_no))
+		// (a) && (a!='n') -> (a)
+		return expr_alloc_symbol(sym1);
+
+	if (sym1->type == S_TRISTATE) {
+		if (e1->type == E_EQUAL && e2->type == E_UNEQUAL) {
+			// (a='b') && (a!='c') -> 'b'='c' ? 'n' : a='b'
+			sym2 = e1->right.sym;
+			if ((e2->right.sym->flags & SYMBOL_CONST) && (sym2->flags & SYMBOL_CONST))
+				return sym2 != e2->right.sym ? expr_alloc_comp(E_EQUAL, sym1, sym2)
+							     : expr_alloc_symbol(&symbol_no);
+		}
+		if (e1->type == E_UNEQUAL && e2->type == E_EQUAL) {
+			// (a='b') && (a!='c') -> 'b'='c' ? 'n' : a='b'
+			sym2 = e2->right.sym;
+			if ((e1->right.sym->flags & SYMBOL_CONST) && (sym2->flags & SYMBOL_CONST))
+				return sym2 != e1->right.sym ? expr_alloc_comp(E_EQUAL, sym1, sym2)
+							     : expr_alloc_symbol(&symbol_no);
+		}
+		if (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&
+			   ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_no) ||
+			    (e1->right.sym == &symbol_no && e2->right.sym == &symbol_yes)))
+			// (a!='y') && (a!='n') -> (a='m')
+			return expr_alloc_comp(E_EQUAL, sym1, &symbol_mod);
+
+		if (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&
+			   ((e1->right.sym == &symbol_yes && e2->right.sym == &symbol_mod) ||
+			    (e1->right.sym == &symbol_mod && e2->right.sym == &symbol_yes)))
+			// (a!='y') && (a!='m') -> (a='n')
+			return expr_alloc_comp(E_EQUAL, sym1, &symbol_no);
+
+		if (e1->type == E_UNEQUAL && e2->type == E_UNEQUAL &&
+			   ((e1->right.sym == &symbol_mod && e2->right.sym == &symbol_no) ||
+			    (e1->right.sym == &symbol_no && e2->right.sym == &symbol_mod)))
+			// (a!='m') && (a!='n') -> (a='m')
+			return expr_alloc_comp(E_EQUAL, sym1, &symbol_yes);
+
+		if ((e1->type == E_SYMBOL && e2->type == E_EQUAL && e2->right.sym == &symbol_mod) ||
+		    (e2->type == E_SYMBOL && e1->type == E_EQUAL && e1->right.sym == &symbol_mod) ||
+		    (e1->type == E_SYMBOL && e2->type == E_UNEQUAL && e2->right.sym == &symbol_yes) ||
+		    (e2->type == E_SYMBOL && e1->type == E_UNEQUAL && e1->right.sym == &symbol_yes))
+			return NULL;
+	}
+	printf("optimize ");
+	print_expr(0, e1, 0);
+	printf(" && ");
+	print_expr(0, e2, 0);
+	printf(" ?\n");
+	return NULL;
+}
+
+static void expr_eliminate_dups1(enum expr_type type, struct expr **ep1, struct expr **ep2)
+{
+#define e1 (*ep1)
+#define e2 (*ep2)
+	struct expr *tmp;
+
+	if (e1->type == type) {
+		expr_eliminate_dups1(type, &e1->left.expr, &e2);
+		expr_eliminate_dups1(type, &e1->right.expr, &e2);
+		return;
+	}
+	if (e2->type == type) {
+		expr_eliminate_dups1(type, &e1, &e2->left.expr);
+		expr_eliminate_dups1(type, &e1, &e2->right.expr);
+		return;
+	}
+	if (e1 == e2)
+		return;
+
+	switch (e1->type) {
+	case E_OR: case E_AND:
+		expr_eliminate_dups1(e1->type, &e1, &e1);
+	default:
+		;
+	}
+
+	switch (type) {
+	case E_OR:
+		tmp = expr_join_or(e1, e2);
+		if (tmp) {
+			expr_free(e1); expr_free(e2);
+			e1 = expr_alloc_symbol(&symbol_no);
+			e2 = tmp;
+			trans_count++;
+		}
+		break;
+	case E_AND:
+		tmp = expr_join_and(e1, e2);
+		if (tmp) {
+			expr_free(e1); expr_free(e2);
+			e1 = expr_alloc_symbol(&symbol_yes);
+			e2 = tmp;
+			trans_count++;
+		}
+		break;
+	default:
+		;
+	}
+#undef e1
+#undef e2
+}
+
+static void expr_eliminate_dups2(enum expr_type type, struct expr **ep1, struct expr **ep2)
+{
+#define e1 (*ep1)
+#define e2 (*ep2)
+	struct expr *tmp, *tmp1, *tmp2;
+
+	if (e1->type == type) {
+		expr_eliminate_dups2(type, &e1->left.expr, &e2);
+		expr_eliminate_dups2(type, &e1->right.expr, &e2);
+		return;
+	}
+	if (e2->type == type) {
+		expr_eliminate_dups2(type, &e1, &e2->left.expr);
+		expr_eliminate_dups2(type, &e1, &e2->right.expr);
+	}
+	if (e1 == e2)
+		return;
+
+	switch (e1->type) {
+	case E_OR:
+		expr_eliminate_dups2(e1->type, &e1, &e1);
+		// (FOO || BAR) && (!FOO && !BAR) -> n
+		tmp1 = expr_transform(expr_alloc_one(E_NOT, expr_copy(e1)));
+		tmp2 = expr_copy(e2);
+		tmp = expr_extract_eq_and(&tmp1, &tmp2);
+		if (expr_is_yes(tmp1)) {
+			expr_free(e1);
+			e1 = expr_alloc_symbol(&symbol_no);
+			trans_count++;
+		}
+		expr_free(tmp2);
+		expr_free(tmp1);
+		expr_free(tmp);
+		break;
+	case E_AND:
+		expr_eliminate_dups2(e1->type, &e1, &e1);
+		// (FOO && BAR) || (!FOO || !BAR) -> y
+		tmp1 = expr_transform(expr_alloc_one(E_NOT, expr_copy(e1)));
+		tmp2 = expr_copy(e2);
+		tmp = expr_extract_eq_or(&tmp1, &tmp2);
+		if (expr_is_no(tmp1)) {
+			expr_free(e1);
+			e1 = expr_alloc_symbol(&symbol_yes);
+			trans_count++;
+		}
+		expr_free(tmp2);
+		expr_free(tmp1);
+		expr_free(tmp);
+		break;
+	default:
+		;
+	}
+#undef e1
+#undef e2
+}
+
+struct expr *expr_eliminate_dups(struct expr *e)
+{
+	int oldcount;
+	if (!e)
+		return e;
+
+	oldcount = trans_count;
+	while (1) {
+		trans_count = 0;
+		switch (e->type) {
+		case E_OR: case E_AND:
+			expr_eliminate_dups1(e->type, &e, &e);
+			expr_eliminate_dups2(e->type, &e, &e);
+		default:
+			;
+		}
+		if (!trans_count)
+			break;
+		e = expr_eliminate_yn(e);
+	}
+	trans_count = oldcount;
+	return e;
+}
+
+struct expr *expr_transform(struct expr *e)
+{
+	struct expr *tmp;
+
+	if (!e)
+		return NULL;
+	switch (e->type) {
+	case E_EQUAL:
+	case E_UNEQUAL:
+	case E_SYMBOL:
+	case E_CHOICE:
+		break;
+	default:
+		e->left.expr = expr_transform(e->left.expr);
+		e->right.expr = expr_transform(e->right.expr);
+	}
+
+	switch (e->type) {
+	case E_EQUAL:
+		if (e->left.sym->type != S_BOOLEAN)
+			break;
+		if (e->right.sym == &symbol_no) {
+			e->type = E_NOT;
+			e->left.expr = expr_alloc_symbol(e->left.sym);
+			e->right.sym = NULL;
+			break;
+		}
+		if (e->right.sym == &symbol_mod) {
+			printf("boolean symbol %s tested for 'm'? test forced to 'n'\n", e->left.sym->name);
+			e->type = E_SYMBOL;
+			e->left.sym = &symbol_no;
+			e->right.sym = NULL;
+			break;
+		}
+		if (e->right.sym == &symbol_yes) {
+			e->type = E_SYMBOL;
+			e->right.sym = NULL;
+			break;
+		}
+		break;
+	case E_UNEQUAL:
+		if (e->left.sym->type != S_BOOLEAN)
+			break;
+		if (e->right.sym == &symbol_no) {
+			e->type = E_SYMBOL;
+			e->right.sym = NULL;
+			break;
+		}
+		if (e->right.sym == &symbol_mod) {
+			printf("boolean symbol %s tested for 'm'? test forced to 'y'\n", e->left.sym->name);
+			e->type = E_SYMBOL;
+			e->left.sym = &symbol_yes;
+			e->right.sym = NULL;
+			break;
+		}
+		if (e->right.sym == &symbol_yes) {
+			e->type = E_NOT;
+			e->left.expr = expr_alloc_symbol(e->left.sym);
+			e->right.sym = NULL;
+			break;
+		}
+		break;
+	case E_NOT:
+		switch (e->left.expr->type) {
+		case E_NOT:
+			// !!a -> a
+			tmp = e->left.expr->left.expr;
+			free(e->left.expr);
+			free(e);
+			e = tmp;
+			e = expr_transform(e);
+			break;
+		case E_EQUAL:
+		case E_UNEQUAL:
+			// !a='x' -> a!='x'
+			tmp = e->left.expr;
+			free(e);
+			e = tmp;
+			e->type = e->type == E_EQUAL ? E_UNEQUAL : E_EQUAL;
+			break;
+		case E_OR:
+			// !(a || b) -> !a && !b
+			tmp = e->left.expr;
+			e->type = E_AND;
+			e->right.expr = expr_alloc_one(E_NOT, tmp->right.expr);
+			tmp->type = E_NOT;
+			tmp->right.expr = NULL;
+			e = expr_transform(e);
+			break;
+		case E_AND:
+			// !(a && b) -> !a || !b
+			tmp = e->left.expr;
+			e->type = E_OR;
+			e->right.expr = expr_alloc_one(E_NOT, tmp->right.expr);
+			tmp->type = E_NOT;
+			tmp->right.expr = NULL;
+			e = expr_transform(e);
+			break;
+		case E_SYMBOL:
+			if (e->left.expr->left.sym == &symbol_yes) {
+				// !'y' -> 'n'
+				tmp = e->left.expr;
+				free(e);
+				e = tmp;
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_no;
+				break;
+			}
+			if (e->left.expr->left.sym == &symbol_mod) {
+				// !'m' -> 'm'
+				tmp = e->left.expr;
+				free(e);
+				e = tmp;
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_mod;
+				break;
+			}
+			if (e->left.expr->left.sym == &symbol_no) {
+				// !'n' -> 'y'
+				tmp = e->left.expr;
+				free(e);
+				e = tmp;
+				e->type = E_SYMBOL;
+				e->left.sym = &symbol_yes;
+				break;
+			}
+			break;
+		default:
+			;
+		}
+		break;
+	default:
+		;
+	}
+	return e;
+}
+
+int expr_contains_symbol(struct expr *dep, struct symbol *sym)
+{
+	if (!dep)
+		return 0;
+
+	switch (dep->type) {
+	case E_AND:
+	case E_OR:
+		return expr_contains_symbol(dep->left.expr, sym) ||
+		       expr_contains_symbol(dep->right.expr, sym);
+	case E_SYMBOL:
+		return dep->left.sym == sym;
+	case E_EQUAL:
+	case E_UNEQUAL:
+		return dep->left.sym == sym ||
+		       dep->right.sym == sym;
+	case E_NOT:
+		return expr_contains_symbol(dep->left.expr, sym);
+	default:
+		;
+	}
+	return 0;
+}
+
+bool expr_depends_symbol(struct expr *dep, struct symbol *sym)
+{
+	if (!dep)
+		return false;
+
+	switch (dep->type) {
+	case E_AND:
+		return expr_depends_symbol(dep->left.expr, sym) ||
+		       expr_depends_symbol(dep->right.expr, sym);
+	case E_SYMBOL:
+		return dep->left.sym == sym;
+	case E_EQUAL:
+		if (dep->left.sym == sym) {
+			if (dep->right.sym == &symbol_yes || dep->right.sym == &symbol_mod)
+				return true;
+		}
+		break;
+	case E_UNEQUAL:
+		if (dep->left.sym == sym) {
+			if (dep->right.sym == &symbol_no)
+				return true;
+		}
+		break;
+	default:
+		;
+	}
+ 	return false;
+}
+
+struct expr *expr_extract_eq_and(struct expr **ep1, struct expr **ep2)
+{
+	struct expr *tmp = NULL;
+	expr_extract_eq(E_AND, &tmp, ep1, ep2);
+	if (tmp) {
+		*ep1 = expr_eliminate_yn(*ep1);
+		*ep2 = expr_eliminate_yn(*ep2);
+	}
+	return tmp;
+}
+
+struct expr *expr_extract_eq_or(struct expr **ep1, struct expr **ep2)
+{
+	struct expr *tmp = NULL;
+	expr_extract_eq(E_OR, &tmp, ep1, ep2);
+	if (tmp) {
+		*ep1 = expr_eliminate_yn(*ep1);
+		*ep2 = expr_eliminate_yn(*ep2);
+	}
+	return tmp;
+}
+
+void expr_extract_eq(enum expr_type type, struct expr **ep, struct expr **ep1, struct expr **ep2)
+{
+#define e1 (*ep1)
+#define e2 (*ep2)
+	if (e1->type == type) {
+		expr_extract_eq(type, ep, &e1->left.expr, &e2);
+		expr_extract_eq(type, ep, &e1->right.expr, &e2);
+		return;
+	}
+	if (e2->type == type) {
+		expr_extract_eq(type, ep, ep1, &e2->left.expr);
+		expr_extract_eq(type, ep, ep1, &e2->right.expr);
+		return;
+	}
+	if (expr_eq(e1, e2)) {
+		*ep = *ep ? expr_alloc_two(type, *ep, e1) : e1;
+		expr_free(e2);
+		if (type == E_AND) {
+			e1 = expr_alloc_symbol(&symbol_yes);
+			e2 = expr_alloc_symbol(&symbol_yes);
+		} else if (type == E_OR) {
+			e1 = expr_alloc_symbol(&symbol_no);
+			e2 = expr_alloc_symbol(&symbol_no);
+		}
+	}
+#undef e1
+#undef e2
+}
+
+struct expr *expr_trans_compare(struct expr *e, enum expr_type type, struct symbol *sym)
+{
+	struct expr *e1, *e2;
+
+	if (!e) {
+		e = expr_alloc_symbol(sym);
+		if (type == E_UNEQUAL)
+			e = expr_alloc_one(E_NOT, e);
+		return e;
+	}
+	switch (e->type) {
+	case E_AND:
+		e1 = expr_trans_compare(e->left.expr, E_EQUAL, sym);
+		e2 = expr_trans_compare(e->right.expr, E_EQUAL, sym);
+		if (sym == &symbol_yes)
+			e = expr_alloc_two(E_AND, e1, e2);
+		if (sym == &symbol_no)
+			e = expr_alloc_two(E_OR, e1, e2);
+		if (type == E_UNEQUAL)
+			e = expr_alloc_one(E_NOT, e);
+		return e;
+	case E_OR:
+		e1 = expr_trans_compare(e->left.expr, E_EQUAL, sym);
+		e2 = expr_trans_compare(e->right.expr, E_EQUAL, sym);
+		if (sym == &symbol_yes)
+			e = expr_alloc_two(E_OR, e1, e2);
+		if (sym == &symbol_no)
+			e = expr_alloc_two(E_AND, e1, e2);
+		if (type == E_UNEQUAL)
+			e = expr_alloc_one(E_NOT, e);
+		return e;
+	case E_NOT:
+		return expr_trans_compare(e->left.expr, type == E_EQUAL ? E_UNEQUAL : E_EQUAL, sym);
+	case E_UNEQUAL:
+	case E_EQUAL:
+		if (type == E_EQUAL) {
+			if (sym == &symbol_yes)
+				return expr_copy(e);
+			if (sym == &symbol_mod)
+				return expr_alloc_symbol(&symbol_no);
+			if (sym == &symbol_no)
+				return expr_alloc_one(E_NOT, expr_copy(e));
+		} else {
+			if (sym == &symbol_yes)
+				return expr_alloc_one(E_NOT, expr_copy(e));
+			if (sym == &symbol_mod)
+				return expr_alloc_symbol(&symbol_yes);
+			if (sym == &symbol_no)
+				return expr_copy(e);
+		}
+		break;
+	case E_SYMBOL:
+		return expr_alloc_comp(type, e->left.sym, sym);
+	case E_CHOICE:
+	case E_NONE:
+		/* panic */;
+	}
+	return NULL;
+}
+
+tristate expr_calc_value(struct expr *e)
+{
+	tristate val1, val2;
+	const char *str1, *str2;
+
+	if (!e)
+		return yes;
+
+	switch (e->type) {
+	case E_SYMBOL:
+		sym_calc_value(e->left.sym);
+		return S_TRI(e->left.sym->curr);
+	case E_AND:
+		val1 = expr_calc_value(e->left.expr);
+		val2 = expr_calc_value(e->right.expr);
+		return E_AND(val1, val2);
+	case E_OR:
+		val1 = expr_calc_value(e->left.expr);
+		val2 = expr_calc_value(e->right.expr);
+		return E_OR(val1, val2);
+	case E_NOT:
+		val1 = expr_calc_value(e->left.expr);
+		return E_NOT(val1);
+	case E_EQUAL:
+		sym_calc_value(e->left.sym);
+		sym_calc_value(e->right.sym);
+		str1 = sym_get_string_value(e->left.sym);
+		str2 = sym_get_string_value(e->right.sym);
+		return !strcmp(str1, str2) ? yes : no;
+	case E_UNEQUAL:
+		sym_calc_value(e->left.sym);
+		sym_calc_value(e->right.sym);
+		str1 = sym_get_string_value(e->left.sym);
+		str2 = sym_get_string_value(e->right.sym);
+		return !strcmp(str1, str2) ? no : yes;
+	default:
+		printf("expr_calc_value: %d?\n", e->type);
+		return no;
+	}
+}
+
+int expr_compare_type(enum expr_type t1, enum expr_type t2)
+{
+#if 0
+	return 1;
+#else
+	if (t1 == t2)
+		return 0;
+	switch (t1) {
+	case E_EQUAL:
+	case E_UNEQUAL:
+		if (t2 == E_NOT)
+			return 1;
+	case E_NOT:
+		if (t2 == E_AND)
+			return 1;
+	case E_AND:
+		if (t2 == E_OR)
+			return 1;
+	case E_OR:
+		if (t2 == E_CHOICE)
+			return 1;
+	case E_CHOICE:
+		if (t2 == 0)
+			return 1;
+	default:
+		return -1;
+	}
+	printf("[%dgt%d?]", t1, t2);
+	return 0;
+#endif
+}
+
+void expr_print(struct expr *e, void (*fn)(void *, const char *), void *data, int prevtoken)
+{
+	if (!e) {
+		fn(data, "y");
+		return;
+	}
+
+	if (expr_compare_type(prevtoken, e->type) > 0)
+		fn(data, "(");
+	switch (e->type) {
+	case E_SYMBOL:
+		if (e->left.sym->name)
+			fn(data, e->left.sym->name);
+		else
+			fn(data, "<choice>");
+		break;
+	case E_NOT:
+		fn(data, "!");
+		expr_print(e->left.expr, fn, data, E_NOT);
+		break;
+	case E_EQUAL:
+		fn(data, e->left.sym->name);
+		fn(data, "=");
+		fn(data, e->right.sym->name);
+		break;
+	case E_UNEQUAL:
+		fn(data, e->left.sym->name);
+		fn(data, "!=");
+		fn(data, e->right.sym->name);
+		break;
+	case E_OR:
+		expr_print(e->left.expr, fn, data, E_OR);
+		fn(data, " || ");
+		expr_print(e->right.expr, fn, data, E_OR);
+		break;
+	case E_AND:
+		expr_print(e->left.expr, fn, data, E_AND);
+		fn(data, " && ");
+		expr_print(e->right.expr, fn, data, E_AND);
+		break;
+	case E_CHOICE:
+		if (e->left.expr) {
+			expr_print(e->left.expr, fn, data, E_CHOICE);
+			fn(data, " ^ ");
+		}
+		fn(data, e->right.sym->name);
+		break;
+	default:
+	  {
+		char buf[32];
+		sprintf(buf, "<unknown type %d>", e->type);
+		fn(data, buf);
+		break;
+	  }
+	}
+	if (expr_compare_type(prevtoken, e->type) > 0)
+		fn(data, ")");
+}
+
+static void expr_print_file_helper(void *data, const char *str)
+{
+	fwrite(str, strlen(str), 1, data);
+}
+
+void expr_fprint(struct expr *e, FILE *out)
+{
+	expr_print(e, expr_print_file_helper, out, E_NONE);
+}
+
+void print_expr(int mask, struct expr *e, int prevtoken)
+{
+	if (!(cdebug & mask))
+		return;
+	expr_fprint(e, stdout);
+}
+
diff --git a/extra/config/expr.h b/extra/config/expr.h
new file mode 100644
index 000000000..fd9c32a7e
--- /dev/null
+++ b/extra/config/expr.h
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#ifndef EXPR_H
+#define EXPR_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#ifndef __cplusplus
+#include <stdbool.h>
+#endif
+
+struct file {
+	struct file *next;
+	struct file *parent;
+#ifdef CML1
+	struct statement *stmt;
+	struct statement *last_stmt;
+#endif
+	char *name;
+	int lineno;
+	int flags;
+};
+
+#define FILE_BUSY		0x0001
+#define FILE_SCANNED		0x0002
+#define FILE_PRINTED		0x0004
+
+typedef enum tristate {
+	no, mod, yes
+} tristate;
+
+enum expr_type {
+	E_NONE, E_OR, E_AND, E_NOT, E_EQUAL, E_UNEQUAL, E_CHOICE, E_SYMBOL
+};
+
+union expr_data {
+	struct expr *expr;
+	struct symbol *sym;
+};
+
+struct expr {
+#ifdef CML1
+	int token;
+#else
+	enum expr_type type;
+#endif
+	union expr_data left, right;
+};
+
+#define E_TRI(ev)	((ev).tri)
+#define E_EXPR(ev)	((ev).expr)
+#define E_CALC(ev)	(E_TRI(ev) = expr_calc_value(E_EXPR(ev)))
+
+#define E_OR(dep1, dep2)	(((dep1)>(dep2))?(dep1):(dep2))
+#define E_AND(dep1, dep2)	(((dep1)<(dep2))?(dep1):(dep2))
+#define E_NOT(dep)		(2-(dep))
+
+struct expr_value {
+	struct expr *expr;
+	tristate tri;
+};
+
+#define S_VAL(sv)	((sv).value)
+#define S_TRI(sv)	((sv).tri)
+#define S_EQ(sv1, sv2)	(S_VAL(sv1) == S_VAL(sv2) || !strcmp(S_VAL(sv1), S_VAL(sv2)))
+
+struct symbol_value {
+	void *value;
+	tristate tri;
+};
+
+enum symbol_type {
+	S_UNKNOWN, S_BOOLEAN, S_TRISTATE, S_INT, S_HEX, S_STRING, S_OTHER
+};
+
+struct symbol {
+	struct symbol *next;
+	char *name;
+	char *help;
+#ifdef CML1
+	int type;
+#else
+	enum symbol_type type;
+#endif
+	struct symbol_value curr, def;
+	tristate visible;
+	int flags;
+	struct property *prop;
+	struct expr *dep, *dep2;
+	struct menu *menu;
+};
+
+#define for_all_symbols(i, sym) for (i = 0; i < 257; i++) for (sym = symbol_hash[i]; sym; sym = sym->next) if (sym->type != S_OTHER)
+
+#ifdef CML1
+#define SYMBOL_UNKNOWN		S_UNKNOWN
+#define SYMBOL_BOOLEAN		S_BOOLEAN
+#define SYMBOL_TRISTATE		S_TRISTATE
+#define SYMBOL_INT		S_INT
+#define SYMBOL_HEX		S_HEX
+#define SYMBOL_STRING		S_STRING
+#define SYMBOL_OTHER		S_OTHER
+#endif
+
+#define SYMBOL_YES		0x0001
+#define SYMBOL_MOD		0x0002
+#define SYMBOL_NO		0x0004
+#define SYMBOL_CONST		0x0007
+#define SYMBOL_CHECK		0x0008
+#define SYMBOL_CHOICE		0x0010
+#define SYMBOL_CHOICEVAL	0x0020
+#define SYMBOL_PRINTED		0x0040
+#define SYMBOL_VALID		0x0080
+#define SYMBOL_OPTIONAL		0x0100
+#define SYMBOL_WRITE		0x0200
+#define SYMBOL_CHANGED		0x0400
+#define SYMBOL_NEW		0x0800
+#define SYMBOL_AUTO		0x1000
+
+#define SYMBOL_MAXLENGTH	256
+#define SYMBOL_HASHSIZE		257
+#define SYMBOL_HASHMASK		0xff
+
+enum prop_type {
+	P_UNKNOWN, P_PROMPT, P_COMMENT, P_MENU, P_ROOTMENU, P_DEFAULT, P_CHOICE
+};
+
+struct property {
+	struct property *next;
+	struct symbol *sym;
+#ifdef CML1
+	int token;
+#else
+	enum prop_type type;
+#endif
+	const char *text;
+	struct symbol *def;
+	struct expr_value visible;
+	struct expr *dep;
+	struct expr *dep2;
+	struct menu *menu;
+	struct file *file;
+	int lineno;
+#ifdef CML1
+	struct property *next_pos;
+#endif
+};
+
+#define for_all_properties(sym, st, tok) \
+	for (st = sym->prop; st; st = st->next) \
+		if (st->type == (tok))
+#define for_all_prompts(sym, st) for_all_properties(sym, st, P_PROMPT)
+#define for_all_defaults(sym, st) for_all_properties(sym, st, P_DEFAULT)
+#define for_all_choices(sym, st) for_all_properties(sym, st, P_CHOICE)
+
+struct menu {
+	struct menu *next;
+	struct menu *parent;
+	struct menu *list;
+	struct symbol *sym;
+	struct property *prompt;
+	struct expr *dep;
+	//char *help;
+	struct file *file;
+	int lineno;
+	//void *data;
+};
+
+#ifndef SWIG
+
+extern struct file *file_list;
+extern struct file *current_file;
+struct file *lookup_file(const char *name);
+
+extern struct symbol symbol_yes, symbol_no, symbol_mod;
+extern struct symbol *modules_sym;
+extern int cdebug;
+extern int print_type;
+struct expr *expr_alloc_symbol(struct symbol *sym);
+#ifdef CML1
+struct expr *expr_alloc_one(int token, struct expr *ce);
+struct expr *expr_alloc_two(int token, struct expr *e1, struct expr *e2);
+struct expr *expr_alloc_comp(int token, struct symbol *s1, struct symbol *s2);
+#else
+struct expr *expr_alloc_one(enum expr_type type, struct expr *ce);
+struct expr *expr_alloc_two(enum expr_type type, struct expr *e1, struct expr *e2);
+struct expr *expr_alloc_comp(enum expr_type type, struct symbol *s1, struct symbol *s2);
+#endif
+struct expr *expr_alloc_and(struct expr *e1, struct expr *e2);
+struct expr *expr_copy(struct expr *org);
+void expr_free(struct expr *e);
+int expr_eq(struct expr *e1, struct expr *e2);
+void expr_eliminate_eq(struct expr **ep1, struct expr **ep2);
+tristate expr_calc_value(struct expr *e);
+struct expr *expr_eliminate_yn(struct expr *e);
+struct expr *expr_trans_bool(struct expr *e);
+struct expr *expr_eliminate_dups(struct expr *e);
+struct expr *expr_transform(struct expr *e);
+int expr_contains_symbol(struct expr *dep, struct symbol *sym);
+bool expr_depends_symbol(struct expr *dep, struct symbol *sym);
+struct expr *expr_extract_eq_and(struct expr **ep1, struct expr **ep2);
+struct expr *expr_extract_eq_or(struct expr **ep1, struct expr **ep2);
+void expr_extract_eq(enum expr_type type, struct expr **ep, struct expr **ep1, struct expr **ep2);
+struct expr *expr_trans_compare(struct expr *e, enum expr_type type, struct symbol *sym);
+
+void expr_fprint(struct expr *e, FILE *out);
+void print_expr(int mask, struct expr *e, int prevtoken);
+
+#ifdef CML1
+static inline int expr_is_yes(struct expr *e)
+{
+	return !e || (e->token == WORD && e->left.sym == &symbol_yes);
+}
+
+static inline int expr_is_no(struct expr *e)
+{
+	return e && (e->token == WORD && e->left.sym == &symbol_no);
+}
+#else
+static inline int expr_is_yes(struct expr *e)
+{
+	return !e || (e->type == E_SYMBOL && e->left.sym == &symbol_yes);
+}
+
+static inline int expr_is_no(struct expr *e)
+{
+	return e && (e->type == E_SYMBOL && e->left.sym == &symbol_no);
+}
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* EXPR_H */
diff --git a/extra/config/lex.zconf.c b/extra/config/lex.zconf.c
new file mode 100644
index 000000000..4507671a4
--- /dev/null
+++ b/extra/config/lex.zconf.c
@@ -0,0 +1,3270 @@
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_scan_buffer zconf_scan_buffer
+#define yy_scan_string zconf_scan_string
+#define yy_scan_bytes zconf_scan_bytes
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /var/cvs/uClibc/extra/config/Attic/lex.zconf.c,v 1.1 2002/10/31 18:19:05 andersen Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#include <stdio.h>
+#include <errno.h>
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+#ifndef _WIN32
+#include <unistd.h>
+#endif
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+
+extern int yyleng;
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		yyless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		*yy_cp = yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yytext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int yy_size_t;
+
+
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER yy_current_buffer
+
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+
+
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 1;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart YY_PROTO(( FILE *input_file ));
+
+void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void yy_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
+void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+
+YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
+YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
+YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+
+static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
+static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
+static void yy_flex_free YY_PROTO(( void * ));
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+
+
+#define yywrap() 1
+#define YY_SKIP_YYWRAP
+typedef unsigned char YY_CHAR;
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+typedef int yy_state_type;
+extern char *yytext;
+#define yytext_ptr yytext
+static yyconst short yy_nxt[][37] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   18,   19,   20,   21,
+       22,   18,   18,   23,   24,   18,   25,   18,   26,   27,
+       18,   28,   29,   30,   18,   18,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   18,   19,   20,   21,
+       22,   18,   18,   23,   24,   18,   25,   18,   26,   27,
+       18,   28,   29,   30,   18,   18,   16
+
+    },
+
+    {
+       11,   31,   32,   33,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31
+    },
+
+    {
+       11,   31,   32,   33,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31
+    },
+
+    {
+       11,   34,   34,   35,   34,   36,   34,   34,   36,   34,
+       34,   34,   34,   34,   34,   37,   34,   34,   34,   34,
+
+       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
+       34,   34,   34,   34,   34,   34,   34
+    },
+
+    {
+       11,   34,   34,   35,   34,   36,   34,   34,   36,   34,
+       34,   34,   34,   34,   34,   37,   34,   34,   34,   34,
+       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
+       34,   34,   34,   34,   34,   34,   34
+    },
+
+    {
+       11,   38,   38,   39,   40,   41,   38,   42,   41,   43,
+       44,   45,   46,   46,   47,   38,   46,   46,   46,   46,
+       46,   46,   46,   46,   48,   46,   46,   46,   49,   46,
+       46,   46,   46,   46,   46,   46,   50
+
+    },
+
+    {
+       11,   38,   38,   39,   40,   41,   38,   42,   41,   43,
+       44,   45,   46,   46,   47,   38,   46,   46,   46,   46,
+       46,   46,   46,   46,   48,   46,   46,   46,   49,   46,
+       46,   46,   46,   46,   46,   46,   50
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   51,   52,  -13,  -13,   53,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   56,  -18,  -18,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -18
+    },
+
+    {
+       11,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,   56,  -19,  -19,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   57,   56,
+       56,   56,   56,   56,   56,   56,  -19
+
+    },
+
+    {
+       11,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,   56,  -20,  -20,   56,   56,   56,   56,
+       56,   56,   56,   58,   56,   56,   56,   56,   59,   56,
+       56,   56,   56,   56,   56,   56,  -20
+    },
+
+    {
+       11,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,   56,  -21,  -21,   56,   56,   56,   56,
+       60,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -21
+    },
+
+    {
+       11,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,   56,  -22,  -22,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   61,   56,   56,
+       56,   56,   56,   56,   56,   56,  -22
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,   56,  -23,  -23,   56,   56,   56,   56,
+       62,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,   56,  -24,  -24,   56,   56,   56,   56,
+       56,   63,   56,   56,   56,   56,   56,   64,   56,   56,
+       56,   56,   56,   56,   56,   56,  -24
+
+    },
+
+    {
+       11,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,   56,  -25,  -25,   65,   56,   56,   56,
+       66,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -25
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,   56,  -26,  -26,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   67,
+       56,   56,   56,   56,   56,   56,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,   56,  -27,  -27,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   68,   56,   56,   56,   56,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,   56,  -28,  -28,   56,   56,   56,   56,
+       69,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,   56,  -29,  -29,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   70,   56,
+       56,   56,   56,   71,   56,   56,  -29
+
+    },
+
+    {
+       11,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,   56,  -30,  -30,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   72,   56,   56,   56,   56,  -30
+    },
+
+    {
+       11,   73,   73,  -31,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73
+    },
+
+    {
+       11,  -32,   74,   75,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,   76,  -33,  -33,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76
+    },
+
+    {
+       11,   77,   77,  -34,   77,  -34,   77,   77,  -34,   77,
+       77,   77,   77,   77,   77,  -34,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,   78,   79,   80,   78,   78,   78,   78,   78,   78,
+       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
+
+       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
+       78,   78,   78,   78,   78,   78,   78
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38
+    },
+
+    {
+       11,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,   81,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41
+    },
+
+    {
+       11,  -42,  -42,  -42,  -42,  -42,  -42,   82,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,   83,   84,   84,  -45,  -45,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -45
+    },
+
+    {
+       11,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,   84,   84,   84,  -46,  -46,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -46
+    },
+
+    {
+       11,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,   84,   84,   84,  -48,  -48,   84,   84,   84,   84,
+       84,   85,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -48
+    },
+
+    {
+       11,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,   84,   84,   84,  -49,  -49,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   86,   84,   84,
+       84,   84,   84,   84,   84,   84,  -49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,   87
+    },
+
+    {
+       11,  -51,   51,   52,  -51,  -51,   53,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,  -56,  -56,   56,  -56,  -56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,  -57,  -57,   56,  -57,  -57,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   88,   56,
+       56,   56,   56,   56,   56,   56,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,   56,  -58,  -58,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   89,   56,
+       56,   56,   56,   56,   56,   56,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,   56,  -59,  -59,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   90,   91,   56,   56,
+       56,   56,   56,   56,   56,   56,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,  -60,  -60,   56,  -60,  -60,   56,   56,   56,   56,
+       56,   92,   56,   56,   56,   56,   56,   56,   56,   93,
+       56,   56,   56,   56,   56,   56,  -60
+    },
+
+    {
+       11,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
+      -61,  -61,  -61,   56,  -61,  -61,   56,   56,   56,   94,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -61
+    },
+
+    {
+       11,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
+      -62,  -62,  -62,   56,  -62,  -62,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   95,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   96,  -62
+    },
+
+    {
+       11,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,
+      -63,  -63,  -63,   56,  -63,  -63,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -63
+    },
+
+    {
+       11,  -64,  -64,  -64,  -64,  -64,  -64,  -64,  -64,  -64,
+      -64,  -64,  -64,   56,  -64,  -64,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   97,   56,   56,  -64
+
+    },
+
+    {
+       11,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,
+      -65,  -65,  -65,   56,  -65,  -65,   56,   56,   56,   56,
+       56,   56,   56,   56,   98,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -65
+    },
+
+    {
+       11,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
+      -66,  -66,  -66,   56,  -66,  -66,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   99,   56,   56,
+       56,   56,   56,   56,   56,   56,  -66
+    },
+
+    {
+       11,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
+      -67,  -67,  -67,   56,  -67,  -67,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  100,   56,   56,  -67
+    },
+
+    {
+       11,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,
+      -68,  -68,  -68,   56,  -68,  -68,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,  101,   56,
+       56,   56,   56,   56,   56,   56,  -68
+    },
+
+    {
+       11,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
+      -69,  -69,  -69,   56,  -69,  -69,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+      102,   56,   56,   56,   56,   56,  -69
+
+    },
+
+    {
+       11,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,
+      -70,  -70,  -70,   56,  -70,  -70,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  103,   56,  -70
+    },
+
+    {
+       11,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,
+      -71,  -71,  -71,   56,  -71,  -71,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,  104,   56,   56,   56,   56,  -71
+    },
+
+    {
+       11,  -72,  -72,  -72,  -72,  -72,  -72,  -72,  -72,  -72,
+      -72,  -72,  -72,   56,  -72,  -72,   56,   56,   56,   56,
+
+       56,   56,   56,   56,  105,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -72
+    },
+
+    {
+       11,   73,   73,  -73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73
+    },
+
+    {
+       11,  -74,   74,   75,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74,  -74,  -74,  -74
+
+    },
+
+    {
+       11,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
+      -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
+      -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
+      -75,  -75,  -75,  -75,  -75,  -75,  -75
+    },
+
+    {
+       11,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
+      -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
+      -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
+      -76,  -76,  -76,  -76,  -76,  -76,  -76
+    },
+
+    {
+       11,   77,   77,  -77,   77,  -77,   77,   77,  -77,   77,
+       77,   77,   77,   77,   77,  -77,   77,   77,   77,   77,
+
+       77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77
+    },
+
+    {
+       11,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
+      -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
+      -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
+      -78,  -78,  -78,  -78,  -78,  -78,  -78
+    },
+
+    {
+       11,  -79,  106,   80,  -79,  -79,  -79,  -79,  -79,  -79,
+      -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,
+      -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,
+      -79,  -79,  -79,  -79,  -79,  -79,  -79
+
+    },
+
+    {
+       11,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,  -80,  -80
+    },
+
+    {
+       11,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81,  -81,  -81,  -81
+    },
+
+    {
+       11,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
+      -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
+
+      -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
+      -82,  -82,  -82,  -82,  -82,  -82,  -82
+    },
+
+    {
+       11,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  107,   84,   84,  -83,  -83,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -83
+    },
+
+    {
+       11,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,   84,   84,   84,  -84,  -84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -84
+
+    },
+
+    {
+       11,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,   84,   84,   84,  -85,  -85,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -85
+    },
+
+    {
+       11,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,   84,   84,   84,  -86,  -86,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -86
+    },
+
+    {
+       11,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+
+      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+      -87,  -87,  -87,  -87,  -87,  -87,  -87
+    },
+
+    {
+       11,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,
+      -88,  -88,  -88,   56,  -88,  -88,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,  108,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -88
+    },
+
+    {
+       11,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,
+      -89,  -89,  -89,   56,  -89,  -89,   56,   56,   56,   56,
+       56,   56,   56,   56,  109,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -89
+
+    },
+
+    {
+       11,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,   56,  -90,  -90,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  110,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -90
+    },
+
+    {
+       11,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,
+      -91,  -91,  -91,   56,  -91,  -91,   56,   56,   56,   56,
+       56,  111,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -91
+    },
+
+    {
+       11,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,
+      -92,  -92,  -92,   56,  -92,  -92,  112,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -92
+    },
+
+    {
+       11,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,   56,  -93,  -93,   56,   56,   56,   56,
+      113,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -93
+    },
+
+    {
+       11,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,
+      -94,  -94,  -94,   56,  -94,  -94,   56,   56,  114,   56,
+       56,   56,   56,   56,  115,   56,  116,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -94
+
+    },
+
+    {
+       11,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,
+      -95,  -95,  -95,   56,  -95,  -95,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,  117,
+       56,   56,   56,   56,   56,   56,  -95
+    },
+
+    {
+       11,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,
+      -96,  -96,  -96,   56,  -96,  -96,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -96
+    },
+
+    {
+       11,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,
+      -97,  -97,  -97,   56,  -97,  -97,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -97
+    },
+
+    {
+       11,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,
+      -98,  -98,  -98,   56,  -98,  -98,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  118,   56,   56,
+       56,   56,   56,   56,   56,   56,  -98
+    },
+
+    {
+       11,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
+      -99,  -99,  -99,   56,  -99,  -99,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  119,   56,  -99
+
+    },
+
+    {
+       11, -100, -100, -100, -100, -100, -100, -100, -100, -100,
+     -100, -100, -100,   56, -100, -100,   56,   56,   56,   56,
+       56,   56,   56,   56,  120,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -100
+    },
+
+    {
+       11, -101, -101, -101, -101, -101, -101, -101, -101, -101,
+     -101, -101, -101,   56, -101, -101,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  121,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -101
+    },
+
+    {
+       11, -102, -102, -102, -102, -102, -102, -102, -102, -102,
+     -102, -102, -102,   56, -102, -102,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  122,   56, -102
+    },
+
+    {
+       11, -103, -103, -103, -103, -103, -103, -103, -103, -103,
+     -103, -103, -103,   56, -103, -103,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,  123,   56,   56,   56,   56, -103
+    },
+
+    {
+       11, -104, -104, -104, -104, -104, -104, -104, -104, -104,
+     -104, -104, -104,   56, -104, -104,   56,   56,   56,   56,
+       56,   56,   56,   56,  124,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -104
+
+    },
+
+    {
+       11, -105, -105, -105, -105, -105, -105, -105, -105, -105,
+     -105, -105, -105,   56, -105, -105,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,  125,   56,   56,   56, -105
+    },
+
+    {
+       11, -106,  106,   80, -106, -106, -106, -106, -106, -106,
+     -106, -106, -106, -106, -106, -106, -106, -106, -106, -106,
+     -106, -106, -106, -106, -106, -106, -106, -106, -106, -106,
+     -106, -106, -106, -106, -106, -106, -106
+    },
+
+    {
+       11, -107, -107, -107, -107, -107, -107, -107, -107, -107,
+     -107,   84,   84,   84, -107, -107,   84,   84,   84,   84,
+
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84, -107
+    },
+
+    {
+       11, -108, -108, -108, -108, -108, -108, -108, -108, -108,
+     -108, -108, -108,   56, -108, -108,   56,   56,   56,   56,
+      126,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -108
+    },
+
+    {
+       11, -109, -109, -109, -109, -109, -109, -109, -109, -109,
+     -109, -109, -109,   56, -109, -109,   56,   56,  127,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -109
+
+    },
+
+    {
+       11, -110, -110, -110, -110, -110, -110, -110, -110, -110,
+     -110, -110, -110,   56, -110, -110,   56,   56,   56,   56,
+      128,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -110
+    },
+
+    {
+       11, -111, -111, -111, -111, -111, -111, -111, -111, -111,
+     -111, -111, -111,   56, -111, -111,   56,   56,   56,   56,
+       56,   56,   56,   56,  129,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -111
+    },
+
+    {
+       11, -112, -112, -112, -112, -112, -112, -112, -112, -112,
+     -112, -112, -112,   56, -112, -112,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  130,   56, -112
+    },
+
+    {
+       11, -113, -113, -113, -113, -113, -113, -113, -113, -113,
+     -113, -113, -113,   56, -113, -113,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  131,   56,   56,
+       56,   56,   56,   56,   56,   56, -113
+    },
+
+    {
+       11, -114, -114, -114, -114, -114, -114, -114, -114, -114,
+     -114, -114, -114,   56, -114, -114,   56,   56,   56,   56,
+       56,   56,   56,  132,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -114
+
+    },
+
+    {
+       11, -115, -115, -115, -115, -115, -115, -115, -115, -115,
+     -115, -115, -115,   56, -115, -115,   56,   56,   56,   56,
+       56,  133,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -115
+    },
+
+    {
+       11, -116, -116, -116, -116, -116, -116, -116, -116, -116,
+     -116, -116, -116,   56, -116, -116,   56,   56,   56,   56,
+      134,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -116
+    },
+
+    {
+       11, -117, -117, -117, -117, -117, -117, -117, -117, -117,
+     -117, -117, -117,   56, -117, -117,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -117
+    },
+
+    {
+       11, -118, -118, -118, -118, -118, -118, -118, -118, -118,
+     -118, -118, -118,   56, -118, -118,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  135,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -118
+    },
+
+    {
+       11, -119, -119, -119, -119, -119, -119, -119, -119, -119,
+     -119, -119, -119,   56, -119, -119,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -119
+
+    },
+
+    {
+       11, -120, -120, -120, -120, -120, -120, -120, -120, -120,
+     -120, -120, -120,   56, -120, -120,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,  136,   56,
+       56,   56,   56,   56,   56,   56, -120
+    },
+
+    {
+       11, -121, -121, -121, -121, -121, -121, -121, -121, -121,
+     -121, -121, -121,   56, -121, -121,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,  137,
+       56,   56,   56,   56,   56,   56, -121
+    },
+
+    {
+       11, -122, -122, -122, -122, -122, -122, -122, -122, -122,
+     -122, -122, -122,   56, -122, -122,   56,   56,   56,   56,
+
+       56,   56,   56,   56,  138,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -122
+    },
+
+    {
+       11, -123, -123, -123, -123, -123, -123, -123, -123, -123,
+     -123, -123, -123,   56, -123, -123,   56,   56,  139,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -123
+    },
+
+    {
+       11, -124, -124, -124, -124, -124, -124, -124, -124, -124,
+     -124, -124, -124,   56, -124, -124,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  140,   56,   56,
+       56,   56,   56,   56,   56,   56, -124
+
+    },
+
+    {
+       11, -125, -125, -125, -125, -125, -125, -125, -125, -125,
+     -125, -125, -125,   56, -125, -125,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  141,   56,   56, -125
+    },
+
+    {
+       11, -126, -126, -126, -126, -126, -126, -126, -126, -126,
+     -126, -126, -126,   56, -126, -126,  142,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -126
+    },
+
+    {
+       11, -127, -127, -127, -127, -127, -127, -127, -127, -127,
+     -127, -127, -127,   56, -127, -127,   56,   56,   56,   56,
+
+      143,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -127
+    },
+
+    {
+       11, -128, -128, -128, -128, -128, -128, -128, -128, -128,
+     -128, -128, -128,   56, -128, -128,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  144,   56,   56,
+       56,   56,   56,   56,   56,   56, -128
+    },
+
+    {
+       11, -129, -129, -129, -129, -129, -129, -129, -129, -129,
+     -129, -129, -129,   56, -129, -129,   56,   56,   56,   56,
+       56,   56,  145,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -129
+
+    },
+
+    {
+       11, -130, -130, -130, -130, -130, -130, -130, -130, -130,
+     -130, -130, -130,   56, -130, -130,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,  146,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -130
+    },
+
+    {
+       11, -131, -131, -131, -131, -131, -131, -131, -131, -131,
+     -131, -131, -131,   56, -131, -131,   56,   56,   56,  147,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -131
+    },
+
+    {
+       11, -132, -132, -132, -132, -132, -132, -132, -132, -132,
+     -132, -132, -132,   56, -132, -132,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,  148,   56,
+       56,   56,   56,   56,   56,   56, -132
+    },
+
+    {
+       11, -133, -133, -133, -133, -133, -133, -133, -133, -133,
+     -133, -133, -133,   56, -133, -133,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -133
+    },
+
+    {
+       11, -134, -134, -134, -134, -134, -134, -134, -134, -134,
+     -134, -134, -134,   56, -134, -134,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  149,   56,   56,
+       56,   56,   56,   56,   56,   56, -134
+
+    },
+
+    {
+       11, -135, -135, -135, -135, -135, -135, -135, -135, -135,
+     -135, -135, -135,   56, -135, -135,   56,   56,   56,   56,
+      150,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -135
+    },
+
+    {
+       11, -136, -136, -136, -136, -136, -136, -136, -136, -136,
+     -136, -136, -136,   56, -136, -136,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  151,   56,   56,
+       56,   56,   56,   56,   56,   56, -136
+    },
+
+    {
+       11, -137, -137, -137, -137, -137, -137, -137, -137, -137,
+     -137, -137, -137,   56, -137, -137,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  152,   56,   56, -137
+    },
+
+    {
+       11, -138, -138, -138, -138, -138, -138, -138, -138, -138,
+     -138, -138, -138,   56, -138, -138,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,  153,   56,   56,   56,   56, -138
+    },
+
+    {
+       11, -139, -139, -139, -139, -139, -139, -139, -139, -139,
+     -139, -139, -139,   56, -139, -139,   56,   56,   56,   56,
+      154,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -139
+
+    },
+
+    {
+       11, -140, -140, -140, -140, -140, -140, -140, -140, -140,
+     -140, -140, -140,   56, -140, -140,   56,   56,   56,   56,
+       56,   56,  155,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -140
+    },
+
+    {
+       11, -141, -141, -141, -141, -141, -141, -141, -141, -141,
+     -141, -141, -141,   56, -141, -141,  156,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -141
+    },
+
+    {
+       11, -142, -142, -142, -142, -142, -142, -142, -142, -142,
+     -142, -142, -142,   56, -142, -142,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,  157,   56,   56,
+       56,   56,   56,   56,   56,   56, -142
+    },
+
+    {
+       11, -143, -143, -143, -143, -143, -143, -143, -143, -143,
+     -143, -143, -143,   56, -143, -143,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -143
+    },
+
+    {
+       11, -144, -144, -144, -144, -144, -144, -144, -144, -144,
+     -144, -144, -144,   56, -144, -144,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  158,   56,   56, -144
+
+    },
+
+    {
+       11, -145, -145, -145, -145, -145, -145, -145, -145, -145,
+     -145, -145, -145,   56, -145, -145,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -145
+    },
+
+    {
+       11, -146, -146, -146, -146, -146, -146, -146, -146, -146,
+     -146, -146, -146,   56, -146, -146,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  159,   56,   56, -146
+    },
+
+    {
+       11, -147, -147, -147, -147, -147, -147, -147, -147, -147,
+     -147, -147, -147,   56, -147, -147,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,  160,   56,   56,   56, -147
+    },
+
+    {
+       11, -148, -148, -148, -148, -148, -148, -148, -148, -148,
+     -148, -148, -148,   56, -148, -148,   56,   56,   56,   56,
+       56,   56,   56,   56,  161,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -148
+    },
+
+    {
+       11, -149, -149, -149, -149, -149, -149, -149, -149, -149,
+     -149, -149, -149,   56, -149, -149,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  162,   56, -149
+
+    },
+
+    {
+       11, -150, -150, -150, -150, -150, -150, -150, -150, -150,
+     -150, -150, -150,   56, -150, -150,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  163,   56,   56,
+       56,   56,   56,   56,   56,   56, -150
+    },
+
+    {
+       11, -151, -151, -151, -151, -151, -151, -151, -151, -151,
+     -151, -151, -151,   56, -151, -151,  164,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -151
+    },
+
+    {
+       11, -152, -152, -152, -152, -152, -152, -152, -152, -152,
+     -152, -152, -152,   56, -152, -152,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -152
+    },
+
+    {
+       11, -153, -153, -153, -153, -153, -153, -153, -153, -153,
+     -153, -153, -153,   56, -153, -153,   56,   56,   56,   56,
+      165,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -153
+    },
+
+    {
+       11, -154, -154, -154, -154, -154, -154, -154, -154, -154,
+     -154, -154, -154,   56, -154, -154,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -154
+
+    },
+
+    {
+       11, -155, -155, -155, -155, -155, -155, -155, -155, -155,
+     -155, -155, -155,   56, -155, -155,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -155
+    },
+
+    {
+       11, -156, -156, -156, -156, -156, -156, -156, -156, -156,
+     -156, -156, -156,   56, -156, -156,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  166,   56,   56, -156
+    },
+
+    {
+       11, -157, -157, -157, -157, -157, -157, -157, -157, -157,
+     -157, -157, -157,   56, -157, -157,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -157
+    },
+
+    {
+       11, -158, -158, -158, -158, -158, -158, -158, -158, -158,
+     -158, -158, -158,   56, -158, -158,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -158
+    },
+
+    {
+       11, -159, -159, -159, -159, -159, -159, -159, -159, -159,
+     -159, -159, -159,   56, -159, -159,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -159
+
+    },
+
+    {
+       11, -160, -160, -160, -160, -160, -160, -160, -160, -160,
+     -160, -160, -160,   56, -160, -160,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -160
+    },
+
+    {
+       11, -161, -161, -161, -161, -161, -161, -161, -161, -161,
+     -161, -161, -161,   56, -161, -161,   56,   56,  167,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -161
+    },
+
+    {
+       11, -162, -162, -162, -162, -162, -162, -162, -162, -162,
+     -162, -162, -162,   56, -162, -162,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -162
+    },
+
+    {
+       11, -163, -163, -163, -163, -163, -163, -163, -163, -163,
+     -163, -163, -163,   56, -163, -163,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  168,   56, -163
+    },
+
+    {
+       11, -164, -164, -164, -164, -164, -164, -164, -164, -164,
+     -164, -164, -164,   56, -164, -164,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,  169,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -164
+
+    },
+
+    {
+       11, -165, -165, -165, -165, -165, -165, -165, -165, -165,
+     -165, -165, -165,   56, -165, -165,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,  170,   56,   56,   56, -165
+    },
+
+    {
+       11, -166, -166, -166, -166, -166, -166, -166, -166, -166,
+     -166, -166, -166,   56, -166, -166,   56,   56,   56,   56,
+      171,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -166
+    },
+
+    {
+       11, -167, -167, -167, -167, -167, -167, -167, -167, -167,
+     -167, -167, -167,   56, -167, -167,   56,   56,   56,   56,
+
+      172,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -167
+    },
+
+    {
+       11, -168, -168, -168, -168, -168, -168, -168, -168, -168,
+     -168, -168, -168,   56, -168, -168,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -168
+    },
+
+    {
+       11, -169, -169, -169, -169, -169, -169, -169, -169, -169,
+     -169, -169, -169,   56, -169, -169,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -169
+
+    },
+
+    {
+       11, -170, -170, -170, -170, -170, -170, -170, -170, -170,
+     -170, -170, -170,   56, -170, -170,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -170
+    },
+
+    {
+       11, -171, -171, -171, -171, -171, -171, -171, -171, -171,
+     -171, -171, -171,   56, -171, -171,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -171
+    },
+
+    {
+       11, -172, -172, -172, -172, -172, -172, -172, -172, -172,
+     -172, -172, -172,   56, -172, -172,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -172
+    },
+
+    } ;
+
+
+static yy_state_type yy_get_previous_state YY_PROTO(( void ));
+static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
+static int yy_get_next_buffer YY_PROTO(( void ));
+static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 55
+#define YY_END_OF_BUFFER 56
+static yyconst short int yy_accept[173] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       56,    5,    4,    3,    2,   29,   30,   28,   28,   28,
+       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
+       54,   51,   53,   45,   50,   46,   48,   44,   41,   35,
+       40,   44,   33,   34,   43,   43,   36,   43,   43,   44,
+        4,    3,    2,    2,    1,   28,   28,   28,   28,   28,
+       28,   28,   15,   28,   28,   28,   28,   28,   28,   28,
+       28,   28,   54,   51,   53,   52,   45,   49,   48,   47,
+       37,   31,   43,   43,   38,   39,   32,   28,   28,   28,
+       28,   28,   28,   28,   28,   26,   25,   28,   28,   28,
+
+       28,   28,   28,   28,   28,   48,   42,   23,   28,   28,
+       28,   28,   28,   28,   28,   28,   14,   28,    7,   28,
+       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
+       28,   28,   16,   28,   28,   28,   28,   28,   28,   28,
+       28,   28,   10,   28,   13,   28,   28,   28,   28,   28,
+       28,   21,   28,    9,   27,   28,   24,   12,   20,   17,
+       28,    8,   28,   28,   28,   28,   28,    6,   19,   18,
+       22,   11
+    } ;
+
+static yyconst int yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   16,   17,   18,   19,
+
+       20,   21,   22,   23,   24,   13,   13,   25,   26,   27,
+       28,   29,   30,   31,   32,   33,   34,   13,   13,   35,
+       13,   13,    1,   36,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "zconf.l"
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#line 5 "zconf.l"
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+#include "zconf.tab.h"
+
+#define START_STRSIZE	16
+
+char *text;
+static char *text_ptr;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static struct buffer *zconf_endfile(void);
+
+void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_ptr = text;
+	text_size = 0;
+	*text_ptr = 0;
+}
+
+void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		text = realloc(text, new_size);
+		text_asize = new_size;
+		text_ptr = text + text_size;
+	}
+	memcpy(text_ptr, str, size);
+	text_ptr += size;
+	text_size += size;
+	*text_ptr = 0;
+}
+
+void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+#line 1726 "lex.zconf.c"
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap YY_PROTO(( void ));
+#else
+extern int yywrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int yy_start_stack_ptr = 0;
+static int yy_start_stack_depth = 0;
+static int *yy_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void yy_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(yyin); \
+	}
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int yylex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+
+#line 71 "zconf.l"
+
+	int str = 0;
+	int ts, i;
+
+#line 1878 "lex.zconf.c"
+
+	if ( yy_init )
+		{
+		yy_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yy_start )
+			yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! yy_current_buffer )
+			yy_current_buffer =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+
+		yy_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yy_start;
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][yy_ec[YY_SC_TO_UI(*yy_cp)]]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+YY_RULE_SETUP
+#line 75 "zconf.l"
+current_file->lineno++;
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 76 "zconf.l"
+
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 78 "zconf.l"
+current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 80 "zconf.l"
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 84 "zconf.l"
+{
+	unput(yytext[0]);
+	//printf("new config: ");
+	//symbol_end(NULL);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+#line 93 "zconf.l"
+BEGIN(PARAM); return T_MAINMENU;
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 94 "zconf.l"
+BEGIN(PARAM); return T_MENU;
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 95 "zconf.l"
+BEGIN(PARAM); return T_ENDMENU;
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 96 "zconf.l"
+BEGIN(PARAM); return T_SOURCE;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 97 "zconf.l"
+BEGIN(PARAM); return T_CHOICE;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 98 "zconf.l"
+BEGIN(PARAM); return T_ENDCHOICE;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 99 "zconf.l"
+BEGIN(PARAM); return T_COMMENT;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 100 "zconf.l"
+BEGIN(PARAM); return T_CONFIG;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 101 "zconf.l"
+BEGIN(PARAM); return T_HELP;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 102 "zconf.l"
+BEGIN(PARAM); return T_IF;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 103 "zconf.l"
+BEGIN(PARAM); return T_ENDIF;
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 104 "zconf.l"
+BEGIN(PARAM); return T_DEPENDS;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 105 "zconf.l"
+BEGIN(PARAM); return T_REQUIRES;
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 106 "zconf.l"
+BEGIN(PARAM); return T_OPTIONAL;
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 107 "zconf.l"
+BEGIN(PARAM); return T_DEFAULT;
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 108 "zconf.l"
+BEGIN(PARAM); return T_PROMPT;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 109 "zconf.l"
+BEGIN(PARAM); return T_TRISTATE;
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 110 "zconf.l"
+BEGIN(PARAM); return T_BOOLEAN;
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 111 "zconf.l"
+BEGIN(PARAM); return T_BOOLEAN;
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 112 "zconf.l"
+BEGIN(PARAM); return T_INT;
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 113 "zconf.l"
+BEGIN(PARAM); return T_HEX;
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 114 "zconf.l"
+BEGIN(PARAM); return T_STRING;
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 115 "zconf.l"
+{
+		alloc_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 120 "zconf.l"
+
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 121 "zconf.l"
+current_file->lineno++; BEGIN(INITIAL);
+	YY_BREAK
+
+
+case 31:
+YY_RULE_SETUP
+#line 125 "zconf.l"
+return T_AND;
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 126 "zconf.l"
+return T_OR;
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 127 "zconf.l"
+return T_OPEN_PAREN;
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 128 "zconf.l"
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 129 "zconf.l"
+return T_NOT;
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 130 "zconf.l"
+return T_EQUAL;
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 131 "zconf.l"
+return T_UNEQUAL;
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 132 "zconf.l"
+return T_IF;
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 133 "zconf.l"
+return T_ON;
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 134 "zconf.l"
+{
+		str = yytext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 139 "zconf.l"
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 140 "zconf.l"
+/* ignore */
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 141 "zconf.l"
+{
+		alloc_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 146 "zconf.l"
+
+	YY_BREAK
+
+
+case 45:
+YY_RULE_SETUP
+#line 150 "zconf.l"
+{
+		append_string(yytext, yyleng);
+	}
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 153 "zconf.l"
+{
+		if (str == yytext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			//printf("s:%s\n", text);
+			return T_STRING;
+		} else
+			append_string(yytext, 1);
+	}
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 162 "zconf.l"
+append_string(yytext+yyleng-1, 1); current_file->lineno++;
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 163 "zconf.l"
+append_string(yytext+1, yyleng-1);
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 164 "zconf.l"
+append_string(yytext+1, 1);
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 165 "zconf.l"
+{
+		//printf(":%d: open string!\n", current_file->lineno+1);
+		exit(0);
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+#line 169 "zconf.l"
+{
+		//printf(":%d: open string!\n", current_file->lineno+1);
+		exit(0);
+	}
+	YY_BREAK
+
+
+case 51:
+YY_RULE_SETUP
+#line 176 "zconf.l"
+{
+		ts = 0;
+		for (i = 0; i < yyleng; i++) {
+			if (yytext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+		
+	}
+	YY_BREAK
+case 52:
+*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
+yy_c_buf_p = yy_cp = yy_bp + 1;
+YY_DO_BEFORE_ACTION; /* set up yytext again */
+YY_RULE_SETUP
+#line 199 "zconf.l"
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 204 "zconf.l"
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 208 "zconf.l"
+{
+		append_string(yytext, yyleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+#line 213 "zconf.l"
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+case YY_STATE_EOF(PARAM):
+#line 219 "zconf.l"
+{
+	if (current_buf) {
+		zconf_endfile();
+		return T_EOF;
+	}
+	yyterminate();
+}
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 227 "zconf.l"
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+#line 2311 "lex.zconf.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between yy_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yy_n_chars = yy_current_buffer->yy_n_chars;
+			yy_current_buffer->yy_input_file = yyin;
+			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yy_c_buf_p;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap() )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yy_c_buf_p =
+					yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yy_c_buf_p =
+				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of yylex */
+
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int yy_get_next_buffer()
+	{
+	register char *dest = yy_current_buffer->yy_ch_buf;
+	register char *source = yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( yy_current_buffer->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = yy_current_buffer;
+
+			int yy_c_buf_p_offset =
+				(int) (yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yy_flex_realloc( (void *) b->yy_ch_buf,
+							 b->yy_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = yy_current_buffer->yy_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+			yy_n_chars, num_to_read );
+
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	if ( yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			yy_current_buffer->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	yy_n_chars += number_to_move;
+	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+static yy_state_type yy_get_previous_state()
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = yy_start;
+
+	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+	}
+
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
+#else
+static yy_state_type yy_try_NUL_trans( yy_current_state )
+yy_state_type yy_current_state;
+#endif
+	{
+	register int yy_is_jam;
+
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void yyunput( int c, register char *yy_bp )
+#else
+static void yyunput( c, yy_bp )
+int c;
+register char *yy_bp;
+#endif
+	{
+	register char *yy_cp = yy_c_buf_p;
+
+	/* undo effects of setting up yytext */
+	*yy_cp = yy_hold_char;
+
+	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = yy_n_chars + 2;
+		register char *dest = &yy_current_buffer->yy_ch_buf[
+					yy_current_buffer->yy_buf_size + 2];
+		register char *source =
+				&yy_current_buffer->yy_ch_buf[number_to_move];
+
+		while ( source > yy_current_buffer->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		yy_current_buffer->yy_n_chars =
+			yy_n_chars = yy_current_buffer->yy_buf_size;
+
+		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+
+	yytext_ptr = yy_bp;
+	yy_hold_char = *yy_cp;
+	yy_c_buf_p = yy_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int yyinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*yy_c_buf_p = yy_hold_char;
+
+	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			/* This was really a NUL. */
+			*yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = yy_c_buf_p - yytext_ptr;
+			++yy_c_buf_p;
+
+			switch ( yy_get_next_buffer() )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/* fall through */
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap() )
+						return EOF;
+
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yy_c_buf_p = yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+	*yy_c_buf_p = '\0';	/* preserve yytext */
+	yy_hold_char = *++yy_c_buf_p;
+
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yyrestart( FILE *input_file )
+#else
+void yyrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! yy_current_buffer )
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+
+	yy_init_buffer( yy_current_buffer, input_file );
+	yy_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void yy_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( yy_current_buffer == new_buffer )
+		return;
+
+	if ( yy_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*yy_c_buf_p = yy_hold_char;
+		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	yy_current_buffer = new_buffer;
+	yy_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yy_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_load_buffer_state( void )
+#else
+void yy_load_buffer_state()
+#endif
+	{
+	yy_n_chars = yy_current_buffer->yy_n_chars;
+	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+	yyin = yy_current_buffer->yy_input_file;
+	yy_hold_char = *yy_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_delete_buffer( YY_BUFFER_STATE b )
+#else
+void yy_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == yy_current_buffer )
+		yy_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yy_flex_free( (void *) b->yy_ch_buf );
+
+	yy_flex_free( (void *) b );
+	}
+
+
+#ifndef _WIN32
+#include <unistd.h>
+#else
+#ifndef YY_ALWAYS_INTERACTIVE
+#ifndef YY_NEVER_INTERACTIVE
+extern int isatty YY_PROTO(( int ));
+#endif
+#endif
+#endif
+
+#ifdef YY_USE_PROTOS
+void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void yy_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->yy_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->yy_is_interactive = 0;
+#else
+	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_flush_buffer( YY_BUFFER_STATE b )
+#else
+void yy_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == yy_current_buffer )
+		yy_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
+#else
+YY_BUFFER_STATE yy_scan_buffer( base, size )
+char *base;
+yy_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
+#else
+YY_BUFFER_STATE yy_scan_string( yy_str )
+yyconst char *yy_str;
+#endif
+	{
+	int len;
+	for ( len = 0; yy_str[len]; ++len )
+		;
+
+	return yy_scan_bytes( yy_str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
+#else
+YY_BUFFER_STATE yy_scan_bytes( bytes, len )
+yyconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) yy_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void yy_push_state( int new_state )
+#else
+static void yy_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yy_start_stack_depth * sizeof( int );
+
+		if ( ! yy_start_stack )
+			yy_start_stack = (int *) yy_flex_alloc( new_size );
+
+		else
+			yy_start_stack = (int *) yy_flex_realloc(
+					(void *) yy_start_stack, new_size );
+
+		if ( ! yy_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state()
+	{
+	if ( --yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yy_start_stack[yy_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state()
+	{
+	return yy_start_stack[yy_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void yy_fatal_error( yyconst char msg[] )
+#else
+static void yy_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		yytext[yyleng] = yy_hold_char; \
+		yy_c_buf_p = yytext + n; \
+		yy_hold_char = *yy_c_buf_p; \
+		*yy_c_buf_p = '\0'; \
+		yyleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef yytext_ptr
+#ifdef YY_USE_PROTOS
+static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
+#else
+static void yy_flex_strncpy( s1, s2, n )
+char *s1;
+yyconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+#ifdef YY_NEED_STRLEN
+#ifdef YY_USE_PROTOS
+static int yy_flex_strlen( yyconst char *s )
+#else
+static int yy_flex_strlen( s )
+yyconst char *s;
+#endif
+	{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_alloc( yy_size_t size )
+#else
+static void *yy_flex_alloc( size )
+yy_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_realloc( void *ptr, yy_size_t size )
+#else
+static void *yy_flex_realloc( ptr, size )
+void *ptr;
+yy_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void yy_flex_free( void *ptr )
+#else
+static void yy_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	yylex();
+	return 0;
+	}
+#endif
+#line 227 "zconf.l"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL); 
+}
+
+void zconf_initscan(const char *name)
+{
+	yyin = fopen(name, "r");
+	if (!yyin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+	//fprintf(stderr, "zconf_initscan: %s\n", name);
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+	current_file->flags = FILE_BUSY;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	yyin = fopen(name, "r");
+	if (!yyin) {
+		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
+		exit(1);
+	}
+	yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	//fprintf(stderr, "zconf_nextfile: %s\n", name);
+
+	if (file->flags & FILE_BUSY) {
+		printf("recursive scan (%s)?\n", name);
+		exit(1);
+	}
+	if (file->flags & FILE_SCANNED) {
+		printf("file %s already scanned?\n", name);
+		exit(1);
+	}
+	file->flags |= FILE_BUSY;
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static struct buffer *zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file->flags |= FILE_SCANNED;
+	current_file->flags &= ~FILE_BUSY;
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		yy_delete_buffer(YY_CURRENT_BUFFER);
+		yy_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+
+	return parent;
+}
+
+int zconf_lineno(void)
+{
+	if (current_buf)
+		return current_file->lineno;
+	else
+		return 0;
+}
+
+char *zconf_curname(void)
+{
+	if (current_buf)
+		return current_file->name;
+	else
+		return "<none>";
+}
diff --git a/extra/config/lex.zconf.c_shipped b/extra/config/lex.zconf.c_shipped
new file mode 100644
index 000000000..b6cb1188f
--- /dev/null
+++ b/extra/config/lex.zconf.c_shipped
@@ -0,0 +1,3270 @@
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_scan_buffer zconf_scan_buffer
+#define yy_scan_string zconf_scan_string
+#define yy_scan_bytes zconf_scan_bytes
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /var/cvs/uClibc/extra/config/lex.zconf.c_shipped,v 1.1 2002/10/31 18:19:06 andersen Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#include <stdio.h>
+#include <errno.h>
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+#ifndef _WIN32
+#include <unistd.h>
+#endif
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+
+extern int yyleng;
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		yyless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		*yy_cp = yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yytext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int yy_size_t;
+
+
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER yy_current_buffer
+
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+
+
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 1;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart YY_PROTO(( FILE *input_file ));
+
+void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void yy_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
+void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+
+YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
+YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
+YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+
+static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
+static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
+static void yy_flex_free YY_PROTO(( void * ));
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+
+
+#define yywrap() 1
+#define YY_SKIP_YYWRAP
+typedef unsigned char YY_CHAR;
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+typedef int yy_state_type;
+extern char *yytext;
+#define yytext_ptr yytext
+static yyconst short yy_nxt[][37] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   18,   19,   20,   21,
+       22,   18,   18,   23,   24,   18,   25,   18,   26,   27,
+       18,   28,   29,   30,   18,   18,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   18,   19,   20,   21,
+       22,   18,   18,   23,   24,   18,   25,   18,   26,   27,
+       18,   28,   29,   30,   18,   18,   16
+
+    },
+
+    {
+       11,   31,   32,   33,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31
+    },
+
+    {
+       11,   31,   32,   33,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
+       31,   31,   31,   31,   31,   31,   31
+    },
+
+    {
+       11,   34,   34,   35,   34,   36,   34,   34,   36,   34,
+       34,   34,   34,   34,   34,   37,   34,   34,   34,   34,
+
+       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
+       34,   34,   34,   34,   34,   34,   34
+    },
+
+    {
+       11,   34,   34,   35,   34,   36,   34,   34,   36,   34,
+       34,   34,   34,   34,   34,   37,   34,   34,   34,   34,
+       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
+       34,   34,   34,   34,   34,   34,   34
+    },
+
+    {
+       11,   38,   38,   39,   40,   41,   38,   42,   41,   43,
+       44,   45,   46,   46,   47,   38,   46,   46,   46,   46,
+       46,   46,   46,   46,   48,   46,   46,   46,   49,   46,
+       46,   46,   46,   46,   46,   46,   50
+
+    },
+
+    {
+       11,   38,   38,   39,   40,   41,   38,   42,   41,   43,
+       44,   45,   46,   46,   47,   38,   46,   46,   46,   46,
+       46,   46,   46,   46,   48,   46,   46,   46,   49,   46,
+       46,   46,   46,   46,   46,   46,   50
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   51,   52,  -13,  -13,   53,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   56,  -18,  -18,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -18
+    },
+
+    {
+       11,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,   56,  -19,  -19,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   57,   56,
+       56,   56,   56,   56,   56,   56,  -19
+
+    },
+
+    {
+       11,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,   56,  -20,  -20,   56,   56,   56,   56,
+       56,   56,   56,   58,   56,   56,   56,   56,   59,   56,
+       56,   56,   56,   56,   56,   56,  -20
+    },
+
+    {
+       11,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,   56,  -21,  -21,   56,   56,   56,   56,
+       60,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -21
+    },
+
+    {
+       11,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,   56,  -22,  -22,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   61,   56,   56,
+       56,   56,   56,   56,   56,   56,  -22
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,   56,  -23,  -23,   56,   56,   56,   56,
+       62,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,   56,  -24,  -24,   56,   56,   56,   56,
+       56,   63,   56,   56,   56,   56,   56,   64,   56,   56,
+       56,   56,   56,   56,   56,   56,  -24
+
+    },
+
+    {
+       11,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,   56,  -25,  -25,   65,   56,   56,   56,
+       66,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -25
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,   56,  -26,  -26,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   67,
+       56,   56,   56,   56,   56,   56,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,   56,  -27,  -27,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   68,   56,   56,   56,   56,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,   56,  -28,  -28,   56,   56,   56,   56,
+       69,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,   56,  -29,  -29,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   70,   56,
+       56,   56,   56,   71,   56,   56,  -29
+
+    },
+
+    {
+       11,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,   56,  -30,  -30,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   72,   56,   56,   56,   56,  -30
+    },
+
+    {
+       11,   73,   73,  -31,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73
+    },
+
+    {
+       11,  -32,   74,   75,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,   76,  -33,  -33,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,   76,   76
+    },
+
+    {
+       11,   77,   77,  -34,   77,  -34,   77,   77,  -34,   77,
+       77,   77,   77,   77,   77,  -34,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,   78,   79,   80,   78,   78,   78,   78,   78,   78,
+       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
+
+       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
+       78,   78,   78,   78,   78,   78,   78
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38
+    },
+
+    {
+       11,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,   81,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41
+    },
+
+    {
+       11,  -42,  -42,  -42,  -42,  -42,  -42,   82,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,   83,   84,   84,  -45,  -45,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -45
+    },
+
+    {
+       11,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,   84,   84,   84,  -46,  -46,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -46
+    },
+
+    {
+       11,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,   84,   84,   84,  -48,  -48,   84,   84,   84,   84,
+       84,   85,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -48
+    },
+
+    {
+       11,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,   84,   84,   84,  -49,  -49,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   86,   84,   84,
+       84,   84,   84,   84,   84,   84,  -49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,   87
+    },
+
+    {
+       11,  -51,   51,   52,  -51,  -51,   53,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,   54,   54,   55,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,  -56,  -56,   56,  -56,  -56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,  -57,  -57,   56,  -57,  -57,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   88,   56,
+       56,   56,   56,   56,   56,   56,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,   56,  -58,  -58,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   89,   56,
+       56,   56,   56,   56,   56,   56,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,   56,  -59,  -59,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   90,   91,   56,   56,
+       56,   56,   56,   56,   56,   56,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,  -60,  -60,   56,  -60,  -60,   56,   56,   56,   56,
+       56,   92,   56,   56,   56,   56,   56,   56,   56,   93,
+       56,   56,   56,   56,   56,   56,  -60
+    },
+
+    {
+       11,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,  -61,
+      -61,  -61,  -61,   56,  -61,  -61,   56,   56,   56,   94,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -61
+    },
+
+    {
+       11,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
+      -62,  -62,  -62,   56,  -62,  -62,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   95,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   96,  -62
+    },
+
+    {
+       11,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,  -63,
+      -63,  -63,  -63,   56,  -63,  -63,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -63
+    },
+
+    {
+       11,  -64,  -64,  -64,  -64,  -64,  -64,  -64,  -64,  -64,
+      -64,  -64,  -64,   56,  -64,  -64,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   97,   56,   56,  -64
+
+    },
+
+    {
+       11,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,  -65,
+      -65,  -65,  -65,   56,  -65,  -65,   56,   56,   56,   56,
+       56,   56,   56,   56,   98,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -65
+    },
+
+    {
+       11,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
+      -66,  -66,  -66,   56,  -66,  -66,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   99,   56,   56,
+       56,   56,   56,   56,   56,   56,  -66
+    },
+
+    {
+       11,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,  -67,
+      -67,  -67,  -67,   56,  -67,  -67,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  100,   56,   56,  -67
+    },
+
+    {
+       11,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,  -68,
+      -68,  -68,  -68,   56,  -68,  -68,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,  101,   56,
+       56,   56,   56,   56,   56,   56,  -68
+    },
+
+    {
+       11,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,  -69,
+      -69,  -69,  -69,   56,  -69,  -69,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+      102,   56,   56,   56,   56,   56,  -69
+
+    },
+
+    {
+       11,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,  -70,
+      -70,  -70,  -70,   56,  -70,  -70,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  103,   56,  -70
+    },
+
+    {
+       11,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,  -71,
+      -71,  -71,  -71,   56,  -71,  -71,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,  104,   56,   56,   56,   56,  -71
+    },
+
+    {
+       11,  -72,  -72,  -72,  -72,  -72,  -72,  -72,  -72,  -72,
+      -72,  -72,  -72,   56,  -72,  -72,   56,   56,   56,   56,
+
+       56,   56,   56,   56,  105,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -72
+    },
+
+    {
+       11,   73,   73,  -73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
+       73,   73,   73,   73,   73,   73,   73
+    },
+
+    {
+       11,  -74,   74,   75,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,  -74,
+      -74,  -74,  -74,  -74,  -74,  -74,  -74
+
+    },
+
+    {
+       11,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
+      -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
+      -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,  -75,
+      -75,  -75,  -75,  -75,  -75,  -75,  -75
+    },
+
+    {
+       11,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
+      -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
+      -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,  -76,
+      -76,  -76,  -76,  -76,  -76,  -76,  -76
+    },
+
+    {
+       11,   77,   77,  -77,   77,  -77,   77,   77,  -77,   77,
+       77,   77,   77,   77,   77,  -77,   77,   77,   77,   77,
+
+       77,   77,   77,   77,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   77,   77
+    },
+
+    {
+       11,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
+      -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
+      -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,  -78,
+      -78,  -78,  -78,  -78,  -78,  -78,  -78
+    },
+
+    {
+       11,  -79,  106,   80,  -79,  -79,  -79,  -79,  -79,  -79,
+      -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,
+      -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,  -79,
+      -79,  -79,  -79,  -79,  -79,  -79,  -79
+
+    },
+
+    {
+       11,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,  -80,
+      -80,  -80,  -80,  -80,  -80,  -80,  -80
+    },
+
+    {
+       11,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,  -81,
+      -81,  -81,  -81,  -81,  -81,  -81,  -81
+    },
+
+    {
+       11,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
+      -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
+
+      -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,  -82,
+      -82,  -82,  -82,  -82,  -82,  -82,  -82
+    },
+
+    {
+       11,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,  -83,
+      -83,  107,   84,   84,  -83,  -83,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -83
+    },
+
+    {
+       11,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,  -84,
+      -84,   84,   84,   84,  -84,  -84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -84
+
+    },
+
+    {
+       11,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,  -85,
+      -85,   84,   84,   84,  -85,  -85,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -85
+    },
+
+    {
+       11,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,  -86,
+      -86,   84,   84,   84,  -86,  -86,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84,  -86
+    },
+
+    {
+       11,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+
+      -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,  -87,
+      -87,  -87,  -87,  -87,  -87,  -87,  -87
+    },
+
+    {
+       11,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,  -88,
+      -88,  -88,  -88,   56,  -88,  -88,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,  108,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -88
+    },
+
+    {
+       11,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,  -89,
+      -89,  -89,  -89,   56,  -89,  -89,   56,   56,   56,   56,
+       56,   56,   56,   56,  109,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -89
+
+    },
+
+    {
+       11,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,  -90,
+      -90,  -90,  -90,   56,  -90,  -90,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  110,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -90
+    },
+
+    {
+       11,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,  -91,
+      -91,  -91,  -91,   56,  -91,  -91,   56,   56,   56,   56,
+       56,  111,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -91
+    },
+
+    {
+       11,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,  -92,
+      -92,  -92,  -92,   56,  -92,  -92,  112,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -92
+    },
+
+    {
+       11,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,  -93,
+      -93,  -93,  -93,   56,  -93,  -93,   56,   56,   56,   56,
+      113,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -93
+    },
+
+    {
+       11,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,  -94,
+      -94,  -94,  -94,   56,  -94,  -94,   56,   56,  114,   56,
+       56,   56,   56,   56,  115,   56,  116,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -94
+
+    },
+
+    {
+       11,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,  -95,
+      -95,  -95,  -95,   56,  -95,  -95,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,  117,
+       56,   56,   56,   56,   56,   56,  -95
+    },
+
+    {
+       11,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,  -96,
+      -96,  -96,  -96,   56,  -96,  -96,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -96
+    },
+
+    {
+       11,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,  -97,
+      -97,  -97,  -97,   56,  -97,  -97,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  -97
+    },
+
+    {
+       11,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,  -98,
+      -98,  -98,  -98,   56,  -98,  -98,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  118,   56,   56,
+       56,   56,   56,   56,   56,   56,  -98
+    },
+
+    {
+       11,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,  -99,
+      -99,  -99,  -99,   56,  -99,  -99,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  119,   56,  -99
+
+    },
+
+    {
+       11, -100, -100, -100, -100, -100, -100, -100, -100, -100,
+     -100, -100, -100,   56, -100, -100,   56,   56,   56,   56,
+       56,   56,   56,   56,  120,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -100
+    },
+
+    {
+       11, -101, -101, -101, -101, -101, -101, -101, -101, -101,
+     -101, -101, -101,   56, -101, -101,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  121,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -101
+    },
+
+    {
+       11, -102, -102, -102, -102, -102, -102, -102, -102, -102,
+     -102, -102, -102,   56, -102, -102,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  122,   56, -102
+    },
+
+    {
+       11, -103, -103, -103, -103, -103, -103, -103, -103, -103,
+     -103, -103, -103,   56, -103, -103,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,  123,   56,   56,   56,   56, -103
+    },
+
+    {
+       11, -104, -104, -104, -104, -104, -104, -104, -104, -104,
+     -104, -104, -104,   56, -104, -104,   56,   56,   56,   56,
+       56,   56,   56,   56,  124,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -104
+
+    },
+
+    {
+       11, -105, -105, -105, -105, -105, -105, -105, -105, -105,
+     -105, -105, -105,   56, -105, -105,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,  125,   56,   56,   56, -105
+    },
+
+    {
+       11, -106,  106,   80, -106, -106, -106, -106, -106, -106,
+     -106, -106, -106, -106, -106, -106, -106, -106, -106, -106,
+     -106, -106, -106, -106, -106, -106, -106, -106, -106, -106,
+     -106, -106, -106, -106, -106, -106, -106
+    },
+
+    {
+       11, -107, -107, -107, -107, -107, -107, -107, -107, -107,
+     -107,   84,   84,   84, -107, -107,   84,   84,   84,   84,
+
+       84,   84,   84,   84,   84,   84,   84,   84,   84,   84,
+       84,   84,   84,   84,   84,   84, -107
+    },
+
+    {
+       11, -108, -108, -108, -108, -108, -108, -108, -108, -108,
+     -108, -108, -108,   56, -108, -108,   56,   56,   56,   56,
+      126,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -108
+    },
+
+    {
+       11, -109, -109, -109, -109, -109, -109, -109, -109, -109,
+     -109, -109, -109,   56, -109, -109,   56,   56,  127,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -109
+
+    },
+
+    {
+       11, -110, -110, -110, -110, -110, -110, -110, -110, -110,
+     -110, -110, -110,   56, -110, -110,   56,   56,   56,   56,
+      128,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -110
+    },
+
+    {
+       11, -111, -111, -111, -111, -111, -111, -111, -111, -111,
+     -111, -111, -111,   56, -111, -111,   56,   56,   56,   56,
+       56,   56,   56,   56,  129,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -111
+    },
+
+    {
+       11, -112, -112, -112, -112, -112, -112, -112, -112, -112,
+     -112, -112, -112,   56, -112, -112,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  130,   56, -112
+    },
+
+    {
+       11, -113, -113, -113, -113, -113, -113, -113, -113, -113,
+     -113, -113, -113,   56, -113, -113,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  131,   56,   56,
+       56,   56,   56,   56,   56,   56, -113
+    },
+
+    {
+       11, -114, -114, -114, -114, -114, -114, -114, -114, -114,
+     -114, -114, -114,   56, -114, -114,   56,   56,   56,   56,
+       56,   56,   56,  132,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -114
+
+    },
+
+    {
+       11, -115, -115, -115, -115, -115, -115, -115, -115, -115,
+     -115, -115, -115,   56, -115, -115,   56,   56,   56,   56,
+       56,  133,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -115
+    },
+
+    {
+       11, -116, -116, -116, -116, -116, -116, -116, -116, -116,
+     -116, -116, -116,   56, -116, -116,   56,   56,   56,   56,
+      134,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -116
+    },
+
+    {
+       11, -117, -117, -117, -117, -117, -117, -117, -117, -117,
+     -117, -117, -117,   56, -117, -117,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -117
+    },
+
+    {
+       11, -118, -118, -118, -118, -118, -118, -118, -118, -118,
+     -118, -118, -118,   56, -118, -118,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,  135,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -118
+    },
+
+    {
+       11, -119, -119, -119, -119, -119, -119, -119, -119, -119,
+     -119, -119, -119,   56, -119, -119,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -119
+
+    },
+
+    {
+       11, -120, -120, -120, -120, -120, -120, -120, -120, -120,
+     -120, -120, -120,   56, -120, -120,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,  136,   56,
+       56,   56,   56,   56,   56,   56, -120
+    },
+
+    {
+       11, -121, -121, -121, -121, -121, -121, -121, -121, -121,
+     -121, -121, -121,   56, -121, -121,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,  137,
+       56,   56,   56,   56,   56,   56, -121
+    },
+
+    {
+       11, -122, -122, -122, -122, -122, -122, -122, -122, -122,
+     -122, -122, -122,   56, -122, -122,   56,   56,   56,   56,
+
+       56,   56,   56,   56,  138,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -122
+    },
+
+    {
+       11, -123, -123, -123, -123, -123, -123, -123, -123, -123,
+     -123, -123, -123,   56, -123, -123,   56,   56,  139,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -123
+    },
+
+    {
+       11, -124, -124, -124, -124, -124, -124, -124, -124, -124,
+     -124, -124, -124,   56, -124, -124,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  140,   56,   56,
+       56,   56,   56,   56,   56,   56, -124
+
+    },
+
+    {
+       11, -125, -125, -125, -125, -125, -125, -125, -125, -125,
+     -125, -125, -125,   56, -125, -125,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  141,   56,   56, -125
+    },
+
+    {
+       11, -126, -126, -126, -126, -126, -126, -126, -126, -126,
+     -126, -126, -126,   56, -126, -126,  142,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -126
+    },
+
+    {
+       11, -127, -127, -127, -127, -127, -127, -127, -127, -127,
+     -127, -127, -127,   56, -127, -127,   56,   56,   56,   56,
+
+      143,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -127
+    },
+
+    {
+       11, -128, -128, -128, -128, -128, -128, -128, -128, -128,
+     -128, -128, -128,   56, -128, -128,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  144,   56,   56,
+       56,   56,   56,   56,   56,   56, -128
+    },
+
+    {
+       11, -129, -129, -129, -129, -129, -129, -129, -129, -129,
+     -129, -129, -129,   56, -129, -129,   56,   56,   56,   56,
+       56,   56,  145,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -129
+
+    },
+
+    {
+       11, -130, -130, -130, -130, -130, -130, -130, -130, -130,
+     -130, -130, -130,   56, -130, -130,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,  146,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -130
+    },
+
+    {
+       11, -131, -131, -131, -131, -131, -131, -131, -131, -131,
+     -131, -131, -131,   56, -131, -131,   56,   56,   56,  147,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -131
+    },
+
+    {
+       11, -132, -132, -132, -132, -132, -132, -132, -132, -132,
+     -132, -132, -132,   56, -132, -132,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,  148,   56,
+       56,   56,   56,   56,   56,   56, -132
+    },
+
+    {
+       11, -133, -133, -133, -133, -133, -133, -133, -133, -133,
+     -133, -133, -133,   56, -133, -133,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -133
+    },
+
+    {
+       11, -134, -134, -134, -134, -134, -134, -134, -134, -134,
+     -134, -134, -134,   56, -134, -134,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  149,   56,   56,
+       56,   56,   56,   56,   56,   56, -134
+
+    },
+
+    {
+       11, -135, -135, -135, -135, -135, -135, -135, -135, -135,
+     -135, -135, -135,   56, -135, -135,   56,   56,   56,   56,
+      150,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -135
+    },
+
+    {
+       11, -136, -136, -136, -136, -136, -136, -136, -136, -136,
+     -136, -136, -136,   56, -136, -136,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  151,   56,   56,
+       56,   56,   56,   56,   56,   56, -136
+    },
+
+    {
+       11, -137, -137, -137, -137, -137, -137, -137, -137, -137,
+     -137, -137, -137,   56, -137, -137,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  152,   56,   56, -137
+    },
+
+    {
+       11, -138, -138, -138, -138, -138, -138, -138, -138, -138,
+     -138, -138, -138,   56, -138, -138,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,  153,   56,   56,   56,   56, -138
+    },
+
+    {
+       11, -139, -139, -139, -139, -139, -139, -139, -139, -139,
+     -139, -139, -139,   56, -139, -139,   56,   56,   56,   56,
+      154,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -139
+
+    },
+
+    {
+       11, -140, -140, -140, -140, -140, -140, -140, -140, -140,
+     -140, -140, -140,   56, -140, -140,   56,   56,   56,   56,
+       56,   56,  155,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -140
+    },
+
+    {
+       11, -141, -141, -141, -141, -141, -141, -141, -141, -141,
+     -141, -141, -141,   56, -141, -141,  156,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -141
+    },
+
+    {
+       11, -142, -142, -142, -142, -142, -142, -142, -142, -142,
+     -142, -142, -142,   56, -142, -142,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,  157,   56,   56,
+       56,   56,   56,   56,   56,   56, -142
+    },
+
+    {
+       11, -143, -143, -143, -143, -143, -143, -143, -143, -143,
+     -143, -143, -143,   56, -143, -143,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -143
+    },
+
+    {
+       11, -144, -144, -144, -144, -144, -144, -144, -144, -144,
+     -144, -144, -144,   56, -144, -144,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  158,   56,   56, -144
+
+    },
+
+    {
+       11, -145, -145, -145, -145, -145, -145, -145, -145, -145,
+     -145, -145, -145,   56, -145, -145,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -145
+    },
+
+    {
+       11, -146, -146, -146, -146, -146, -146, -146, -146, -146,
+     -146, -146, -146,   56, -146, -146,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  159,   56,   56, -146
+    },
+
+    {
+       11, -147, -147, -147, -147, -147, -147, -147, -147, -147,
+     -147, -147, -147,   56, -147, -147,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,  160,   56,   56,   56, -147
+    },
+
+    {
+       11, -148, -148, -148, -148, -148, -148, -148, -148, -148,
+     -148, -148, -148,   56, -148, -148,   56,   56,   56,   56,
+       56,   56,   56,   56,  161,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -148
+    },
+
+    {
+       11, -149, -149, -149, -149, -149, -149, -149, -149, -149,
+     -149, -149, -149,   56, -149, -149,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  162,   56, -149
+
+    },
+
+    {
+       11, -150, -150, -150, -150, -150, -150, -150, -150, -150,
+     -150, -150, -150,   56, -150, -150,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,  163,   56,   56,
+       56,   56,   56,   56,   56,   56, -150
+    },
+
+    {
+       11, -151, -151, -151, -151, -151, -151, -151, -151, -151,
+     -151, -151, -151,   56, -151, -151,  164,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -151
+    },
+
+    {
+       11, -152, -152, -152, -152, -152, -152, -152, -152, -152,
+     -152, -152, -152,   56, -152, -152,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -152
+    },
+
+    {
+       11, -153, -153, -153, -153, -153, -153, -153, -153, -153,
+     -153, -153, -153,   56, -153, -153,   56,   56,   56,   56,
+      165,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -153
+    },
+
+    {
+       11, -154, -154, -154, -154, -154, -154, -154, -154, -154,
+     -154, -154, -154,   56, -154, -154,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -154
+
+    },
+
+    {
+       11, -155, -155, -155, -155, -155, -155, -155, -155, -155,
+     -155, -155, -155,   56, -155, -155,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -155
+    },
+
+    {
+       11, -156, -156, -156, -156, -156, -156, -156, -156, -156,
+     -156, -156, -156,   56, -156, -156,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,  166,   56,   56, -156
+    },
+
+    {
+       11, -157, -157, -157, -157, -157, -157, -157, -157, -157,
+     -157, -157, -157,   56, -157, -157,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -157
+    },
+
+    {
+       11, -158, -158, -158, -158, -158, -158, -158, -158, -158,
+     -158, -158, -158,   56, -158, -158,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -158
+    },
+
+    {
+       11, -159, -159, -159, -159, -159, -159, -159, -159, -159,
+     -159, -159, -159,   56, -159, -159,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -159
+
+    },
+
+    {
+       11, -160, -160, -160, -160, -160, -160, -160, -160, -160,
+     -160, -160, -160,   56, -160, -160,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -160
+    },
+
+    {
+       11, -161, -161, -161, -161, -161, -161, -161, -161, -161,
+     -161, -161, -161,   56, -161, -161,   56,   56,  167,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -161
+    },
+
+    {
+       11, -162, -162, -162, -162, -162, -162, -162, -162, -162,
+     -162, -162, -162,   56, -162, -162,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -162
+    },
+
+    {
+       11, -163, -163, -163, -163, -163, -163, -163, -163, -163,
+     -163, -163, -163,   56, -163, -163,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,  168,   56, -163
+    },
+
+    {
+       11, -164, -164, -164, -164, -164, -164, -164, -164, -164,
+     -164, -164, -164,   56, -164, -164,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,  169,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -164
+
+    },
+
+    {
+       11, -165, -165, -165, -165, -165, -165, -165, -165, -165,
+     -165, -165, -165,   56, -165, -165,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,  170,   56,   56,   56, -165
+    },
+
+    {
+       11, -166, -166, -166, -166, -166, -166, -166, -166, -166,
+     -166, -166, -166,   56, -166, -166,   56,   56,   56,   56,
+      171,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -166
+    },
+
+    {
+       11, -167, -167, -167, -167, -167, -167, -167, -167, -167,
+     -167, -167, -167,   56, -167, -167,   56,   56,   56,   56,
+
+      172,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -167
+    },
+
+    {
+       11, -168, -168, -168, -168, -168, -168, -168, -168, -168,
+     -168, -168, -168,   56, -168, -168,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -168
+    },
+
+    {
+       11, -169, -169, -169, -169, -169, -169, -169, -169, -169,
+     -169, -169, -169,   56, -169, -169,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -169
+
+    },
+
+    {
+       11, -170, -170, -170, -170, -170, -170, -170, -170, -170,
+     -170, -170, -170,   56, -170, -170,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -170
+    },
+
+    {
+       11, -171, -171, -171, -171, -171, -171, -171, -171, -171,
+     -171, -171, -171,   56, -171, -171,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -171
+    },
+
+    {
+       11, -172, -172, -172, -172, -172, -172, -172, -172, -172,
+     -172, -172, -172,   56, -172, -172,   56,   56,   56,   56,
+
+       56,   56,   56,   56,   56,   56,   56,   56,   56,   56,
+       56,   56,   56,   56,   56,   56, -172
+    },
+
+    } ;
+
+
+static yy_state_type yy_get_previous_state YY_PROTO(( void ));
+static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
+static int yy_get_next_buffer YY_PROTO(( void ));
+static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 55
+#define YY_END_OF_BUFFER 56
+static yyconst short int yy_accept[173] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       56,    5,    4,    3,    2,   29,   30,   28,   28,   28,
+       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
+       54,   51,   53,   45,   50,   46,   48,   44,   41,   35,
+       40,   44,   33,   34,   43,   43,   36,   43,   43,   44,
+        4,    3,    2,    2,    1,   28,   28,   28,   28,   28,
+       28,   28,   15,   28,   28,   28,   28,   28,   28,   28,
+       28,   28,   54,   51,   53,   52,   45,   49,   48,   47,
+       37,   31,   43,   43,   38,   39,   32,   28,   28,   28,
+       28,   28,   28,   28,   28,   26,   25,   28,   28,   28,
+
+       28,   28,   28,   28,   28,   48,   42,   23,   28,   28,
+       28,   28,   28,   28,   28,   28,   14,   28,    7,   28,
+       28,   28,   28,   28,   28,   28,   28,   28,   28,   28,
+       28,   28,   16,   28,   28,   28,   28,   28,   28,   28,
+       28,   28,   10,   28,   13,   28,   28,   28,   28,   28,
+       28,   21,   28,    9,   27,   28,   24,   12,   20,   17,
+       28,    8,   28,   28,   28,   28,   28,    6,   19,   18,
+       22,   11
+    } ;
+
+static yyconst int yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   16,   17,   18,   19,
+
+       20,   21,   22,   23,   24,   13,   13,   25,   26,   27,
+       28,   29,   30,   31,   32,   33,   34,   13,   13,   35,
+       13,   13,    1,   36,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "zconf.l"
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#line 5 "zconf.l"
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+#include "zconf.tab.h"
+
+#define START_STRSIZE	16
+
+char *text;
+static char *text_ptr;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static struct buffer *zconf_endfile(void);
+
+void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_ptr = text;
+	text_size = 0;
+	*text_ptr = 0;
+}
+
+void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		text = realloc(text, new_size);
+		text_asize = new_size;
+		text_ptr = text + text_size;
+	}
+	memcpy(text_ptr, str, size);
+	text_ptr += size;
+	text_size += size;
+	*text_ptr = 0;
+}
+
+void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+#line 1726 "lex.zconf.c"
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap YY_PROTO(( void ));
+#else
+extern int yywrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int yy_start_stack_ptr = 0;
+static int yy_start_stack_depth = 0;
+static int *yy_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void yy_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(yyin); \
+	}
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int yylex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+
+#line 71 "zconf.l"
+
+	int str = 0;
+	int ts, i;
+
+#line 1878 "lex.zconf.c"
+
+	if ( yy_init )
+		{
+		yy_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yy_start )
+			yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! yy_current_buffer )
+			yy_current_buffer =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+
+		yy_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yy_start;
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][yy_ec[YY_SC_TO_UI(*yy_cp)]]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+YY_RULE_SETUP
+#line 75 "zconf.l"
+current_file->lineno++;
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 76 "zconf.l"
+
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 78 "zconf.l"
+current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 80 "zconf.l"
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 84 "zconf.l"
+{
+	unput(yytext[0]);
+	//printf("new config: ");
+	//symbol_end(NULL);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+#line 93 "zconf.l"
+BEGIN(PARAM); return T_MAINMENU;
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 94 "zconf.l"
+BEGIN(PARAM); return T_MENU;
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 95 "zconf.l"
+BEGIN(PARAM); return T_ENDMENU;
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 96 "zconf.l"
+BEGIN(PARAM); return T_SOURCE;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 97 "zconf.l"
+BEGIN(PARAM); return T_CHOICE;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 98 "zconf.l"
+BEGIN(PARAM); return T_ENDCHOICE;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 99 "zconf.l"
+BEGIN(PARAM); return T_COMMENT;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 100 "zconf.l"
+BEGIN(PARAM); return T_CONFIG;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 101 "zconf.l"
+BEGIN(PARAM); return T_HELP;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 102 "zconf.l"
+BEGIN(PARAM); return T_IF;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 103 "zconf.l"
+BEGIN(PARAM); return T_ENDIF;
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 104 "zconf.l"
+BEGIN(PARAM); return T_DEPENDS;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 105 "zconf.l"
+BEGIN(PARAM); return T_REQUIRES;
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 106 "zconf.l"
+BEGIN(PARAM); return T_OPTIONAL;
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 107 "zconf.l"
+BEGIN(PARAM); return T_DEFAULT;
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 108 "zconf.l"
+BEGIN(PARAM); return T_PROMPT;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 109 "zconf.l"
+BEGIN(PARAM); return T_TRISTATE;
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 110 "zconf.l"
+BEGIN(PARAM); return T_BOOLEAN;
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 111 "zconf.l"
+BEGIN(PARAM); return T_BOOLEAN;
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 112 "zconf.l"
+BEGIN(PARAM); return T_INT;
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 113 "zconf.l"
+BEGIN(PARAM); return T_HEX;
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 114 "zconf.l"
+BEGIN(PARAM); return T_STRING;
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 115 "zconf.l"
+{
+		alloc_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 120 "zconf.l"
+
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 121 "zconf.l"
+current_file->lineno++; BEGIN(INITIAL);
+	YY_BREAK
+
+
+case 31:
+YY_RULE_SETUP
+#line 125 "zconf.l"
+return T_AND;
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 126 "zconf.l"
+return T_OR;
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 127 "zconf.l"
+return T_OPEN_PAREN;
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 128 "zconf.l"
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 129 "zconf.l"
+return T_NOT;
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 130 "zconf.l"
+return T_EQUAL;
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 131 "zconf.l"
+return T_UNEQUAL;
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 132 "zconf.l"
+return T_IF;
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 133 "zconf.l"
+return T_ON;
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 134 "zconf.l"
+{
+		str = yytext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 139 "zconf.l"
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 140 "zconf.l"
+/* ignore */
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 141 "zconf.l"
+{
+		alloc_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 146 "zconf.l"
+
+	YY_BREAK
+
+
+case 45:
+YY_RULE_SETUP
+#line 150 "zconf.l"
+{
+		append_string(yytext, yyleng);
+	}
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 153 "zconf.l"
+{
+		if (str == yytext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			//printf("s:%s\n", text);
+			return T_STRING;
+		} else
+			append_string(yytext, 1);
+	}
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 162 "zconf.l"
+append_string(yytext+yyleng-1, 1); current_file->lineno++;
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 163 "zconf.l"
+append_string(yytext+1, yyleng-1);
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 164 "zconf.l"
+append_string(yytext+1, 1);
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 165 "zconf.l"
+{
+		//printf(":%d: open string!\n", current_file->lineno+1);
+		exit(0);
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+#line 169 "zconf.l"
+{
+		//printf(":%d: open string!\n", current_file->lineno+1);
+		exit(0);
+	}
+	YY_BREAK
+
+
+case 51:
+YY_RULE_SETUP
+#line 176 "zconf.l"
+{
+		ts = 0;
+		for (i = 0; i < yyleng; i++) {
+			if (yytext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+		
+	}
+	YY_BREAK
+case 52:
+*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
+yy_c_buf_p = yy_cp = yy_bp + 1;
+YY_DO_BEFORE_ACTION; /* set up yytext again */
+YY_RULE_SETUP
+#line 199 "zconf.l"
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 204 "zconf.l"
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 208 "zconf.l"
+{
+		append_string(yytext, yyleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+#line 213 "zconf.l"
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+case YY_STATE_EOF(PARAM):
+#line 219 "zconf.l"
+{
+	if (current_buf) {
+		zconf_endfile();
+		return T_EOF;
+	}
+	yyterminate();
+}
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 227 "zconf.l"
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+#line 2311 "lex.zconf.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between yy_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yy_n_chars = yy_current_buffer->yy_n_chars;
+			yy_current_buffer->yy_input_file = yyin;
+			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yy_c_buf_p;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap() )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yy_c_buf_p =
+					yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yy_c_buf_p =
+				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of yylex */
+
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int yy_get_next_buffer()
+	{
+	register char *dest = yy_current_buffer->yy_ch_buf;
+	register char *source = yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( yy_current_buffer->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = yy_current_buffer;
+
+			int yy_c_buf_p_offset =
+				(int) (yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yy_flex_realloc( (void *) b->yy_ch_buf,
+							 b->yy_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = yy_current_buffer->yy_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+			yy_n_chars, num_to_read );
+
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	if ( yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			yy_current_buffer->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	yy_n_chars += number_to_move;
+	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+static yy_state_type yy_get_previous_state()
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = yy_start;
+
+	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+	}
+
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
+#else
+static yy_state_type yy_try_NUL_trans( yy_current_state )
+yy_state_type yy_current_state;
+#endif
+	{
+	register int yy_is_jam;
+
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void yyunput( int c, register char *yy_bp )
+#else
+static void yyunput( c, yy_bp )
+int c;
+register char *yy_bp;
+#endif
+	{
+	register char *yy_cp = yy_c_buf_p;
+
+	/* undo effects of setting up yytext */
+	*yy_cp = yy_hold_char;
+
+	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = yy_n_chars + 2;
+		register char *dest = &yy_current_buffer->yy_ch_buf[
+					yy_current_buffer->yy_buf_size + 2];
+		register char *source =
+				&yy_current_buffer->yy_ch_buf[number_to_move];
+
+		while ( source > yy_current_buffer->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		yy_current_buffer->yy_n_chars =
+			yy_n_chars = yy_current_buffer->yy_buf_size;
+
+		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+
+	yytext_ptr = yy_bp;
+	yy_hold_char = *yy_cp;
+	yy_c_buf_p = yy_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int yyinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*yy_c_buf_p = yy_hold_char;
+
+	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			/* This was really a NUL. */
+			*yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = yy_c_buf_p - yytext_ptr;
+			++yy_c_buf_p;
+
+			switch ( yy_get_next_buffer() )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/* fall through */
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap() )
+						return EOF;
+
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yy_c_buf_p = yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+	*yy_c_buf_p = '\0';	/* preserve yytext */
+	yy_hold_char = *++yy_c_buf_p;
+
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yyrestart( FILE *input_file )
+#else
+void yyrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! yy_current_buffer )
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+
+	yy_init_buffer( yy_current_buffer, input_file );
+	yy_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void yy_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( yy_current_buffer == new_buffer )
+		return;
+
+	if ( yy_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*yy_c_buf_p = yy_hold_char;
+		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	yy_current_buffer = new_buffer;
+	yy_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yy_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_load_buffer_state( void )
+#else
+void yy_load_buffer_state()
+#endif
+	{
+	yy_n_chars = yy_current_buffer->yy_n_chars;
+	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+	yyin = yy_current_buffer->yy_input_file;
+	yy_hold_char = *yy_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_delete_buffer( YY_BUFFER_STATE b )
+#else
+void yy_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == yy_current_buffer )
+		yy_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yy_flex_free( (void *) b->yy_ch_buf );
+
+	yy_flex_free( (void *) b );
+	}
+
+
+#ifndef _WIN32
+#include <unistd.h>
+#else
+#ifndef YY_ALWAYS_INTERACTIVE
+#ifndef YY_NEVER_INTERACTIVE
+extern int isatty YY_PROTO(( int ));
+#endif
+#endif
+#endif
+
+#ifdef YY_USE_PROTOS
+void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void yy_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->yy_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->yy_is_interactive = 0;
+#else
+	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_flush_buffer( YY_BUFFER_STATE b )
+#else
+void yy_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == yy_current_buffer )
+		yy_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
+#else
+YY_BUFFER_STATE yy_scan_buffer( base, size )
+char *base;
+yy_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
+#else
+YY_BUFFER_STATE yy_scan_string( yy_str )
+yyconst char *yy_str;
+#endif
+	{
+	int len;
+	for ( len = 0; yy_str[len]; ++len )
+		;
+
+	return yy_scan_bytes( yy_str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
+#else
+YY_BUFFER_STATE yy_scan_bytes( bytes, len )
+yyconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) yy_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void yy_push_state( int new_state )
+#else
+static void yy_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yy_start_stack_depth * sizeof( int );
+
+		if ( ! yy_start_stack )
+			yy_start_stack = (int *) yy_flex_alloc( new_size );
+
+		else
+			yy_start_stack = (int *) yy_flex_realloc(
+					(void *) yy_start_stack, new_size );
+
+		if ( ! yy_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state()
+	{
+	if ( --yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yy_start_stack[yy_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state()
+	{
+	return yy_start_stack[yy_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void yy_fatal_error( yyconst char msg[] )
+#else
+static void yy_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		yytext[yyleng] = yy_hold_char; \
+		yy_c_buf_p = yytext + n; \
+		yy_hold_char = *yy_c_buf_p; \
+		*yy_c_buf_p = '\0'; \
+		yyleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef yytext_ptr
+#ifdef YY_USE_PROTOS
+static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
+#else
+static void yy_flex_strncpy( s1, s2, n )
+char *s1;
+yyconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+#ifdef YY_NEED_STRLEN
+#ifdef YY_USE_PROTOS
+static int yy_flex_strlen( yyconst char *s )
+#else
+static int yy_flex_strlen( s )
+yyconst char *s;
+#endif
+	{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_alloc( yy_size_t size )
+#else
+static void *yy_flex_alloc( size )
+yy_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_realloc( void *ptr, yy_size_t size )
+#else
+static void *yy_flex_realloc( ptr, size )
+void *ptr;
+yy_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void yy_flex_free( void *ptr )
+#else
+static void yy_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	yylex();
+	return 0;
+	}
+#endif
+#line 227 "zconf.l"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL); 
+}
+
+void zconf_initscan(const char *name)
+{
+	yyin = fopen(name, "r");
+	if (!yyin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+	//fprintf(stderr, "zconf_initscan: %s\n", name);
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+	current_file->flags = FILE_BUSY;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	yyin = fopen(name, "r");
+	if (!yyin) {
+		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
+		exit(1);
+	}
+	yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	//fprintf(stderr, "zconf_nextfile: %s\n", name);
+
+	if (file->flags & FILE_BUSY) {
+		printf("recursive scan (%s)?\n", name);
+		exit(1);
+	}
+	if (file->flags & FILE_SCANNED) {
+		printf("file %s already scanned?\n", name);
+		exit(1);
+	}
+	file->flags |= FILE_BUSY;
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static struct buffer *zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file->flags |= FILE_SCANNED;
+	current_file->flags &= ~FILE_BUSY;
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		yy_delete_buffer(YY_CURRENT_BUFFER);
+		yy_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+
+	return parent;
+}
+
+int zconf_lineno(void)
+{
+	if (current_buf)
+		return current_file->lineno;
+	else
+		return 0;
+}
+
+char *zconf_curname(void)
+{
+	if (current_buf)
+		return current_file->name;
+	else
+		return "<none>";
+}
diff --git a/extra/config/lkc.h b/extra/config/lkc.h
new file mode 100644
index 000000000..688945b87
--- /dev/null
+++ b/extra/config/lkc.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#ifndef LKC_H
+#define LKC_H
+
+#include "expr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef LKC_DIRECT_LINK
+#define P(name,type,arg)	extern type name arg
+#else
+#include "lkc_defs.h"
+#define P(name,type,arg)	extern type (*name ## _p) arg
+#endif
+#include "lkc_proto.h"
+#undef P
+
+void symbol_end(char *help);
+int zconfparse(void);
+void zconfdump(FILE *out);
+
+extern int zconfdebug;
+void zconf_starthelp(void);
+void zconf_initscan(const char *name);
+void zconf_nextfile(const char *name);
+int zconf_lineno(void);
+char *zconf_curname(void);
+
+/* confdata.c */
+extern const char conf_def_filename[];
+extern char conf_filename[];
+
+char *conf_get_default_confname(void);
+
+/* kconfig_load.c */
+void kconfig_load(void);
+
+/* menu.c */
+void menu_init(void);
+void menu_add_menu(void);
+void menu_end_menu(void);
+void menu_add_entry(struct symbol *sym);
+void menu_end_entry(void);
+struct property *create_prop(enum prop_type type);
+void menu_add_dep(struct expr *dep);
+struct property *menu_add_prop(int token, char *prompt, struct symbol *def, struct expr *dep);
+void menu_finalize(struct menu *parent);
+void menu_set_type(int type);
+struct file *file_lookup(const char *name);
+int file_write_dep(const char *name);
+
+extern struct menu *current_entry;
+extern struct menu *current_menu;
+
+/* symbol.c */
+void sym_init(void);
+void sym_clear_all_valid(void);
+
+static inline tristate sym_get_tristate_value(struct symbol *sym)
+{
+	return S_TRI(sym->curr);
+}
+
+
+static inline struct symbol *sym_get_choice_value(struct symbol *sym)
+{
+	return (struct symbol *)S_VAL(sym->curr);
+}
+
+static inline bool sym_set_choice_value(struct symbol *ch, struct symbol *chval)
+{
+	return sym_set_tristate_value(chval, yes);
+}
+
+static inline bool sym_is_choice(struct symbol *sym)
+{
+	return sym->flags & SYMBOL_CHOICE ? true : false;
+}
+
+static inline bool sym_is_choice_value(struct symbol *sym)
+{
+	return sym->flags & SYMBOL_CHOICEVAL ? true : false;
+}
+
+static inline bool sym_is_optional(struct symbol *sym)
+{
+	return sym->flags & SYMBOL_OPTIONAL ? true : false;
+}
+
+static inline bool sym_has_value(struct symbol *sym)
+{
+	//return S_VAL(sym->def) != NULL;
+	return sym->flags & SYMBOL_NEW ? false : true;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LKC_H */
diff --git a/extra/config/lkc_defs.h b/extra/config/lkc_defs.h
new file mode 100644
index 000000000..ab7441263
--- /dev/null
+++ b/extra/config/lkc_defs.h
@@ -0,0 +1,38 @@
+
+/* confdata.c */
+#define conf_parse (*conf_parse_p)
+#define conf_read (*conf_read_p)
+#define conf_write (*conf_write_p)
+
+/* menu.c */
+#define rootmenu (*rootmenu_p)
+
+#define menu_is_visible (*menu_is_visible_p)
+#define menu_get_prompt (*menu_get_prompt_p)
+#define menu_get_root_menu (*menu_get_root_menu_p)
+#define menu_get_parent_menu (*menu_get_parent_menu_p)
+
+/* symbol.c */
+#define symbol_hash (*symbol_hash_p)
+#define sym_change_count (*sym_change_count_p)
+
+#define sym_lookup (*sym_lookup_p)
+#define sym_find (*sym_find_p)
+#define sym_type_name (*sym_type_name_p)
+#define sym_calc_value (*sym_calc_value_p)
+#define sym_get_type (*sym_get_type_p)
+#define sym_tristate_within_range (*sym_tristate_within_range_p)
+#define sym_set_tristate_value (*sym_set_tristate_value_p)
+#define sym_toggle_tristate_value (*sym_toggle_tristate_value_p)
+#define sym_string_valid (*sym_string_valid_p)
+#define sym_set_string_value (*sym_set_string_value_p)
+#define sym_is_changable (*sym_is_changable_p)
+#define sym_get_choice_prop (*sym_get_choice_prop_p)
+#define sym_get_default_prop (*sym_get_default_prop_p)
+#define sym_get_string_value (*sym_get_string_value_p)
+
+#define prop_get_type_name (*prop_get_type_name_p)
+
+/* expr.c */
+#define expr_compare_type (*expr_compare_type_p)
+#define expr_print (*expr_print_p)
diff --git a/extra/config/lkc_proto.h b/extra/config/lkc_proto.h
new file mode 100644
index 000000000..116d7593b
--- /dev/null
+++ b/extra/config/lkc_proto.h
@@ -0,0 +1,38 @@
+
+/* confdata.c */
+P(conf_parse,void,(const char *name));
+P(conf_read,int,(const char *name));
+P(conf_write,int,(const char *name));
+
+/* menu.c */
+P(rootmenu,struct menu,);
+
+P(menu_is_visible,bool,(struct menu *menu));
+P(menu_get_prompt,const char *,(struct menu *menu));
+P(menu_get_root_menu,struct menu *,(struct menu *menu));
+P(menu_get_parent_menu,struct menu *,(struct menu *menu));
+
+/* symbol.c */
+P(symbol_hash,struct symbol *,[SYMBOL_HASHSIZE]);
+P(sym_change_count,int,);
+
+P(sym_lookup,struct symbol *,(const char *name, int isconst));
+P(sym_find,struct symbol *,(const char *name));
+P(sym_type_name,const char *,(int type));
+P(sym_calc_value,void,(struct symbol *sym));
+P(sym_get_type,int,(struct symbol *sym));
+P(sym_tristate_within_range,bool,(struct symbol *sym,tristate tri));
+P(sym_set_tristate_value,bool,(struct symbol *sym,tristate tri));
+P(sym_toggle_tristate_value,tristate,(struct symbol *sym));
+P(sym_string_valid,bool,(struct symbol *sym, const char *newval));
+P(sym_set_string_value,bool,(struct symbol *sym, const char *newval));
+P(sym_is_changable,bool,(struct symbol *sym));
+P(sym_get_choice_prop,struct property *,(struct symbol *sym));
+P(sym_get_default_prop,struct property *,(struct symbol *sym));
+P(sym_get_string_value,const char *,(struct symbol *sym));
+
+P(prop_get_type_name,const char *,(enum prop_type type));
+
+/* expr.c */
+P(expr_compare_type,int,(enum expr_type t1, enum expr_type t2));
+P(expr_print,void,(struct expr *e, void (*fn)(void *, const char *), void *data, int prevtoken));
diff --git a/extra/config/lxdialog/BIG.FAT.WARNING b/extra/config/lxdialog/BIG.FAT.WARNING
new file mode 100644
index 000000000..a8999d82b
--- /dev/null
+++ b/extra/config/lxdialog/BIG.FAT.WARNING
@@ -0,0 +1,4 @@
+This is NOT the official version of dialog.  This version has been
+significantly modified from the original.  It is for use by the Linux
+kernel configuration script.  Please do not bother Savio Lam with 
+questions about this program.
diff --git a/extra/config/lxdialog/Makefile b/extra/config/lxdialog/Makefile
new file mode 100644
index 000000000..fa83c31ab
--- /dev/null
+++ b/extra/config/lxdialog/Makefile
@@ -0,0 +1,51 @@
+TOPDIR=../../../
+include $(TOPDIR)Rules.mak
+
+HOSTCFLAGS += -DLOCALE 
+LIBS = -lncurses
+
+ifeq (/usr/include/ncurses/ncurses.h, $(wildcard /usr/include/ncurses/ncurses.h))
+	NATIVE_CFLAGS += -I/usr/include/ncurses -DCURSES_LOC="<ncurses.h>"
+else
+ifeq (/usr/include/ncurses/curses.h, $(wildcard /usr/include/ncurses/curses.h))
+	NATIVE_CFLAGS += -I/usr/include/ncurses -DCURSES_LOC="<ncurses/curses.h>"
+else
+ifeq (/usr/include/ncurses.h, $(wildcard /usr/include/ncurses.h))
+	NATIVE_CFLAGS += -DCURSES_LOC="<ncurses.h>"
+else
+	NATIVE_CFLAGS += -DCURSES_LOC="<curses.h>"
+endif
+endif
+endif
+
+
+OBJS = checklist.o menubox.o textbox.o yesno.o inputbox.o \
+       util.o lxdialog.o msgbox.o
+
+%.o: %.c
+	$(NATIVE_CC) $(NATIVE_CFLAGS) -c -o $@ $<
+
+all: ncurses lxdialog
+
+lxdialog: $(OBJS)
+	$(NATIVE_CC) -o lxdialog $(OBJS) $(LIBS)
+
+.PHONY: ncurses
+
+ncurses:
+	@echo "main() {}" > lxtemp.c
+	@if $(NATIVE_CC) lxtemp.c $(LIBS) ; then \
+		rm -f lxtemp.c a.out; \
+	else \
+		rm -f lxtemp.c; \
+		echo -e "\007" ;\
+		echo ">> Unable to find the Ncurses libraries." ;\
+		echo ">>" ;\
+		echo ">> You must have Ncurses installed in order" ;\
+		echo ">> to use 'make menuconfig'" ;\
+		echo ;\
+		exit 1 ;\
+	fi
+
+clean:
+	rm -f core *.o *~ lxdialog
diff --git a/extra/config/lxdialog/checklist.c b/extra/config/lxdialog/checklist.c
new file mode 100644
index 000000000..4f78688ed
--- /dev/null
+++ b/extra/config/lxdialog/checklist.c
@@ -0,0 +1,369 @@
+/*
+ *  checklist.c -- implements the checklist box
+ *
+ *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *     Stuart Herbert - S.Herbert@sheffield.ac.uk: radiolist extension
+ *     Alessandro Rubini - rubini@ipvvis.unipv.it: merged the two
+ *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dialog.h"
+
+static int list_width, check_x, item_x, checkflag;
+
+/*
+ * Print list item
+ */
+static void
+print_item (WINDOW * win, const char *item, int status,
+	    int choice, int selected)
+{
+    int i;
+
+    /* Clear 'residue' of last item */
+    wattrset (win, menubox_attr);
+    wmove (win, choice, 0);
+    for (i = 0; i < list_width; i++)
+	waddch (win, ' ');
+
+    wmove (win, choice, check_x);
+    wattrset (win, selected ? check_selected_attr : check_attr);
+    if (checkflag == FLAG_CHECK)
+	wprintw (win, "[%c]", status ? 'X' : ' ');
+    else
+	wprintw (win, "(%c)", status ? 'X' : ' ');
+
+    wattrset (win, selected ? tag_selected_attr : tag_attr);
+    mvwaddch(win, choice, item_x, item[0]);
+    wattrset (win, selected ? item_selected_attr : item_attr);
+    waddstr (win, (char *)item+1);
+    if (selected) {
+    	wmove (win, choice, check_x+1);
+    	wrefresh (win);
+    }
+}
+
+/*
+ * Print the scroll indicators.
+ */
+static void
+print_arrows (WINDOW * win, int choice, int item_no, int scroll,
+		int y, int x, int height)
+{
+    wmove(win, y, x);
+
+    if (scroll > 0) {
+	wattrset (win, uarrow_attr);
+	waddch (win, ACS_UARROW);
+	waddstr (win, "(-)");
+    }
+    else {
+	wattrset (win, menubox_attr);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+    }
+
+   y = y + height + 1;
+   wmove(win, y, x);
+
+   if ((height < item_no) && (scroll + choice < item_no - 1)) {
+	wattrset (win, darrow_attr);
+	waddch (win, ACS_DARROW);
+	waddstr (win, "(+)");
+    }
+    else {
+	wattrset (win, menubox_border_attr);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+   }
+}
+
+/*
+ *  Display the termination buttons
+ */
+static void
+print_buttons( WINDOW *dialog, int height, int width, int selected)
+{
+    int x = width / 2 - 11;
+    int y = height - 2;
+
+    print_button (dialog, "Select", y, x, selected == 0);
+    print_button (dialog, " Help ", y, x + 14, selected == 1);
+
+    wmove(dialog, y, x+1 + 14*selected);
+    wrefresh (dialog);
+}
+
+/*
+ * Display a dialog box with a list of options that can be turned on or off
+ * The `flag' parameter is used to select between radiolist and checklist.
+ */
+int
+dialog_checklist (const char *title, const char *prompt, int height, int width,
+	int list_height, int item_no, const char * const * items, int flag)
+	
+{
+    int i, x, y, box_x, box_y;
+    int key = 0, button = 0, choice = 0, scroll = 0, max_choice, *status;
+    WINDOW *dialog, *list;
+
+    checkflag = flag;
+
+    /* Allocate space for storing item on/off status */
+    if ((status = malloc (sizeof (int) * item_no)) == NULL) {
+	endwin ();
+	fprintf (stderr,
+		 "\nCan't allocate memory in dialog_checklist().\n");
+	exit (-1);
+    }
+
+    /* Initializes status */
+    for (i = 0; i < item_no; i++) {
+	status[i] = !strcasecmp (items[i * 3 + 2], "on");
+	if (!choice && status[i])
+            choice = i;
+    }
+
+    max_choice = MIN (list_height, item_no);
+
+    /* center dialog box on screen */
+    x = (COLS - width) / 2;
+    y = (LINES - height) / 2;
+
+    draw_shadow (stdscr, y, x, height, width);
+
+    dialog = newwin (height, width, y, x);
+    keypad (dialog, TRUE);
+
+    draw_box (dialog, 0, 0, height, width, dialog_attr, border_attr);
+    wattrset (dialog, border_attr);
+    mvwaddch (dialog, height-3, 0, ACS_LTEE);
+    for (i = 0; i < width - 2; i++)
+	waddch (dialog, ACS_HLINE);
+    wattrset (dialog, dialog_attr);
+    waddch (dialog, ACS_RTEE);
+
+    if (title != NULL && strlen(title) >= width-2 ) {
+	/* truncate long title -- mec */
+	char * title2 = malloc(width-2+1);
+	memcpy( title2, title, width-2 );
+	title2[width-2] = '\0';
+	title = title2;
+    }
+
+    if (title != NULL) {
+	wattrset (dialog, title_attr);
+	mvwaddch (dialog, 0, (width - strlen(title))/2 - 1, ' ');
+	waddstr (dialog, (char *)title);
+	waddch (dialog, ' ');
+    }
+
+    wattrset (dialog, dialog_attr);
+    print_autowrap (dialog, prompt, width - 2, 1, 3);
+
+    list_width = width - 6;
+    box_y = height - list_height - 5;
+    box_x = (width - list_width) / 2 - 1;
+
+    /* create new window for the list */
+    list = subwin (dialog, list_height, list_width, y+box_y+1, x+box_x+1);
+
+    keypad (list, TRUE);
+
+    /* draw a box around the list items */
+    draw_box (dialog, box_y, box_x, list_height + 2, list_width + 2,
+	      menubox_border_attr, menubox_attr);
+
+    /* Find length of longest item in order to center checklist */
+    check_x = 0;
+    for (i = 0; i < item_no; i++) 
+	check_x = MAX (check_x, + strlen (items[i * 3 + 1]) + 4);
+
+    check_x = (list_width - check_x) / 2;
+    item_x = check_x + 4;
+
+    if (choice >= list_height) {
+	scroll = choice - list_height + 1;
+	choice -= scroll;
+    }
+
+    /* Print the list */
+    for (i = 0; i < max_choice; i++) {
+	print_item (list, items[(scroll+i) * 3 + 1],
+		    status[i+scroll], i, i == choice);
+    }
+
+    print_arrows(dialog, choice, item_no, scroll,
+			box_y, box_x + check_x + 5, list_height);
+
+    print_buttons(dialog, height, width, 0);
+
+    wnoutrefresh (list);
+    wnoutrefresh (dialog);
+    doupdate ();
+
+    while (key != ESC) {
+	key = wgetch (dialog);
+
+    	for (i = 0; i < max_choice; i++)
+            if (toupper(key) == toupper(items[(scroll+i)*3+1][0]))
+                break;
+
+
+	if ( i < max_choice || key == KEY_UP || key == KEY_DOWN || 
+	    key == '+' || key == '-' ) {
+	    if (key == KEY_UP || key == '-') {
+		if (!choice) {
+		    if (!scroll)
+			continue;
+		    /* Scroll list down */
+		    if (list_height > 1) {
+			/* De-highlight current first item */
+			print_item (list, items[scroll * 3 + 1],
+					status[scroll], 0, FALSE);
+			scrollok (list, TRUE);
+			wscrl (list, -1);
+			scrollok (list, FALSE);
+		    }
+		    scroll--;
+		    print_item (list, items[scroll * 3 + 1],
+				status[scroll], 0, TRUE);
+		    wnoutrefresh (list);
+
+    		    print_arrows(dialog, choice, item_no, scroll,
+				box_y, box_x + check_x + 5, list_height);
+
+		    wrefresh (dialog);
+
+		    continue;	/* wait for another key press */
+		} else
+		    i = choice - 1;
+	    } else if (key == KEY_DOWN || key == '+') {
+		if (choice == max_choice - 1) {
+		    if (scroll + choice >= item_no - 1)
+			continue;
+		    /* Scroll list up */
+		    if (list_height > 1) {
+			/* De-highlight current last item before scrolling up */
+			print_item (list, items[(scroll + max_choice - 1) * 3 + 1],
+				    status[scroll + max_choice - 1],
+				    max_choice - 1, FALSE);
+			scrollok (list, TRUE);
+			scroll (list);
+			scrollok (list, FALSE);
+		    }
+		    scroll++;
+		    print_item (list, items[(scroll + max_choice - 1) * 3 + 1],
+				status[scroll + max_choice - 1],
+				max_choice - 1, TRUE);
+		    wnoutrefresh (list);
+
+    		    print_arrows(dialog, choice, item_no, scroll,
+				box_y, box_x + check_x + 5, list_height);
+
+		    wrefresh (dialog);
+
+		    continue;	/* wait for another key press */
+		} else
+		    i = choice + 1;
+	    }
+	    if (i != choice) {
+		/* De-highlight current item */
+		print_item (list, items[(scroll + choice) * 3 + 1],
+			    status[scroll + choice], choice, FALSE);
+		/* Highlight new item */
+		choice = i;
+		print_item (list, items[(scroll + choice) * 3 + 1],
+			    status[scroll + choice], choice, TRUE);
+		wnoutrefresh (list);
+		wrefresh (dialog);
+	    }
+	    continue;		/* wait for another key press */
+	}
+	switch (key) {
+	case 'H':
+	case 'h':
+	case '?':
+	    delwin (dialog);
+	    free (status);
+	    return 1;
+	case TAB:
+	case KEY_LEFT:
+	case KEY_RIGHT:
+	    button = ((key == KEY_LEFT ? --button : ++button) < 0)
+			? 1 : (button > 1 ? 0 : button);
+
+	    print_buttons(dialog, height, width, button);
+	    wrefresh (dialog);
+	    break;
+	case 'S':
+	case 's':
+	case ' ':
+	case '\n':
+	    if (!button) {
+		if (flag == FLAG_CHECK) {
+		    status[scroll + choice] = !status[scroll + choice];
+		    wmove (list, choice, check_x);
+		    wattrset (list, check_selected_attr);
+		    wprintw (list, "[%c]", status[scroll + choice] ? 'X' : ' ');
+		} else {
+		    if (!status[scroll + choice]) {
+			for (i = 0; i < item_no; i++)
+			    status[i] = 0;
+			status[scroll + choice] = 1;
+			for (i = 0; i < max_choice; i++)
+			    print_item (list, items[(scroll + i) * 3 + 1],
+					status[scroll + i], i, i == choice);
+		    }
+		}
+		wnoutrefresh (list);
+		wrefresh (dialog);
+            
+		for (i = 0; i < item_no; i++) {
+		    if (status[i]) {
+			if (flag == FLAG_CHECK) {
+			    fprintf (stderr, "\"%s\" ", items[i * 3]);
+			} else {
+			    fprintf (stderr, "%s", items[i * 3]);
+			}
+
+		    }
+		}
+            }
+	    delwin (dialog);
+	    free (status);
+	    return button;
+	case 'X':
+	case 'x':
+	    key = ESC;
+	case ESC:
+	    break;
+	}
+
+	/* Now, update everything... */
+	doupdate ();
+    }
+    
+
+    delwin (dialog);
+    free (status);
+    return -1;			/* ESC pressed */
+}
diff --git a/extra/config/lxdialog/colors.h b/extra/config/lxdialog/colors.h
new file mode 100644
index 000000000..d34dd37c6
--- /dev/null
+++ b/extra/config/lxdialog/colors.h
@@ -0,0 +1,161 @@
+/*
+ *  colors.h -- color attribute definitions
+ *
+ *  AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+/*
+ *   Default color definitions
+ *
+ *   *_FG = foreground
+ *   *_BG = background
+ *   *_HL = highlight?
+ */
+#define SCREEN_FG                    COLOR_CYAN
+#define SCREEN_BG                    COLOR_BLUE
+#define SCREEN_HL                    TRUE
+
+#define SHADOW_FG                    COLOR_BLACK
+#define SHADOW_BG                    COLOR_BLACK
+#define SHADOW_HL                    TRUE
+
+#define DIALOG_FG                    COLOR_BLACK
+#define DIALOG_BG                    COLOR_WHITE
+#define DIALOG_HL                    FALSE
+
+#define TITLE_FG                     COLOR_YELLOW
+#define TITLE_BG                     COLOR_WHITE
+#define TITLE_HL                     TRUE
+
+#define BORDER_FG                    COLOR_WHITE
+#define BORDER_BG                    COLOR_WHITE
+#define BORDER_HL                    TRUE
+
+#define BUTTON_ACTIVE_FG             COLOR_WHITE
+#define BUTTON_ACTIVE_BG             COLOR_BLUE
+#define BUTTON_ACTIVE_HL             TRUE
+
+#define BUTTON_INACTIVE_FG           COLOR_BLACK
+#define BUTTON_INACTIVE_BG           COLOR_WHITE
+#define BUTTON_INACTIVE_HL           FALSE
+
+#define BUTTON_KEY_ACTIVE_FG         COLOR_WHITE
+#define BUTTON_KEY_ACTIVE_BG         COLOR_BLUE
+#define BUTTON_KEY_ACTIVE_HL         TRUE
+
+#define BUTTON_KEY_INACTIVE_FG       COLOR_RED
+#define BUTTON_KEY_INACTIVE_BG       COLOR_WHITE
+#define BUTTON_KEY_INACTIVE_HL       FALSE
+
+#define BUTTON_LABEL_ACTIVE_FG       COLOR_YELLOW
+#define BUTTON_LABEL_ACTIVE_BG       COLOR_BLUE
+#define BUTTON_LABEL_ACTIVE_HL       TRUE
+
+#define BUTTON_LABEL_INACTIVE_FG     COLOR_BLACK
+#define BUTTON_LABEL_INACTIVE_BG     COLOR_WHITE
+#define BUTTON_LABEL_INACTIVE_HL     TRUE
+
+#define INPUTBOX_FG                  COLOR_BLACK
+#define INPUTBOX_BG                  COLOR_WHITE
+#define INPUTBOX_HL                  FALSE
+
+#define INPUTBOX_BORDER_FG           COLOR_BLACK
+#define INPUTBOX_BORDER_BG           COLOR_WHITE
+#define INPUTBOX_BORDER_HL           FALSE
+
+#define SEARCHBOX_FG                 COLOR_BLACK
+#define SEARCHBOX_BG                 COLOR_WHITE
+#define SEARCHBOX_HL                 FALSE
+
+#define SEARCHBOX_TITLE_FG           COLOR_YELLOW
+#define SEARCHBOX_TITLE_BG           COLOR_WHITE
+#define SEARCHBOX_TITLE_HL           TRUE
+
+#define SEARCHBOX_BORDER_FG          COLOR_WHITE
+#define SEARCHBOX_BORDER_BG          COLOR_WHITE
+#define SEARCHBOX_BORDER_HL          TRUE
+
+#define POSITION_INDICATOR_FG        COLOR_YELLOW
+#define POSITION_INDICATOR_BG        COLOR_WHITE
+#define POSITION_INDICATOR_HL        TRUE
+
+#define MENUBOX_FG                   COLOR_BLACK
+#define MENUBOX_BG                   COLOR_WHITE
+#define MENUBOX_HL                   FALSE
+
+#define MENUBOX_BORDER_FG            COLOR_WHITE
+#define MENUBOX_BORDER_BG            COLOR_WHITE
+#define MENUBOX_BORDER_HL            TRUE
+
+#define ITEM_FG                      COLOR_BLACK
+#define ITEM_BG                      COLOR_WHITE
+#define ITEM_HL                      FALSE
+
+#define ITEM_SELECTED_FG             COLOR_WHITE
+#define ITEM_SELECTED_BG             COLOR_BLUE
+#define ITEM_SELECTED_HL             TRUE
+
+#define TAG_FG                       COLOR_YELLOW
+#define TAG_BG                       COLOR_WHITE
+#define TAG_HL                       TRUE
+
+#define TAG_SELECTED_FG              COLOR_YELLOW
+#define TAG_SELECTED_BG              COLOR_BLUE
+#define TAG_SELECTED_HL              TRUE
+
+#define TAG_KEY_FG                   COLOR_YELLOW
+#define TAG_KEY_BG                   COLOR_WHITE
+#define TAG_KEY_HL                   TRUE
+
+#define TAG_KEY_SELECTED_FG          COLOR_YELLOW
+#define TAG_KEY_SELECTED_BG          COLOR_BLUE
+#define TAG_KEY_SELECTED_HL          TRUE
+
+#define CHECK_FG                     COLOR_BLACK
+#define CHECK_BG                     COLOR_WHITE
+#define CHECK_HL                     FALSE
+
+#define CHECK_SELECTED_FG            COLOR_WHITE
+#define CHECK_SELECTED_BG            COLOR_BLUE
+#define CHECK_SELECTED_HL            TRUE
+
+#define UARROW_FG                    COLOR_GREEN
+#define UARROW_BG                    COLOR_WHITE
+#define UARROW_HL                    TRUE
+
+#define DARROW_FG                    COLOR_GREEN
+#define DARROW_BG                    COLOR_WHITE
+#define DARROW_HL                    TRUE
+
+/* End of default color definitions */
+
+#define C_ATTR(x,y)                  ((x ? A_BOLD : 0) | COLOR_PAIR((y)))
+#define COLOR_NAME_LEN               10
+#define COLOR_COUNT                  8
+
+/*
+ * Global variables
+ */
+
+typedef struct {
+    char name[COLOR_NAME_LEN];
+    int value;
+} color_names_st;
+
+extern color_names_st color_names[];
+extern int color_table[][3];
diff --git a/extra/config/lxdialog/dialog.h b/extra/config/lxdialog/dialog.h
new file mode 100644
index 000000000..0e30d00d0
--- /dev/null
+++ b/extra/config/lxdialog/dialog.h
@@ -0,0 +1,184 @@
+
+/*
+ *  dialog.h -- common declarations for all dialog modules
+ *
+ *  AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include CURSES_LOC
+
+/*
+ * Colors in ncurses 1.9.9e do not work properly since foreground and
+ * background colors are OR'd rather than separately masked.  This version
+ * of dialog was hacked to work with ncurses 1.9.9e, making it incompatible
+ * with standard curses.  The simplest fix (to make this work with standard
+ * curses) uses the wbkgdset() function, not used in the original hack.
+ * Turn it off if we're building with 1.9.9e, since it just confuses things.
+ */
+#if defined(NCURSES_VERSION) && defined(_NEED_WRAP) && !defined(GCC_PRINTFLIKE)
+#define OLD_NCURSES 1
+#undef  wbkgdset
+#define wbkgdset(w,p) /*nothing*/
+#else
+#define OLD_NCURSES 0
+#endif
+
+#define TR(params) _tracef params
+
+#define ESC 27
+#define TAB 9
+#define MAX_LEN 2048
+#define BUF_SIZE (10*1024)
+#define MIN(x,y) (x < y ? x : y)
+#define MAX(x,y) (x > y ? x : y)
+
+
+#ifndef ACS_ULCORNER
+#define ACS_ULCORNER '+'
+#endif
+#ifndef ACS_LLCORNER
+#define ACS_LLCORNER '+'
+#endif
+#ifndef ACS_URCORNER
+#define ACS_URCORNER '+'
+#endif
+#ifndef ACS_LRCORNER
+#define ACS_LRCORNER '+'
+#endif
+#ifndef ACS_HLINE
+#define ACS_HLINE '-'
+#endif
+#ifndef ACS_VLINE
+#define ACS_VLINE '|'
+#endif
+#ifndef ACS_LTEE
+#define ACS_LTEE '+'
+#endif
+#ifndef ACS_RTEE
+#define ACS_RTEE '+'
+#endif
+#ifndef ACS_UARROW
+#define ACS_UARROW '^'
+#endif
+#ifndef ACS_DARROW
+#define ACS_DARROW 'v'
+#endif
+
+/* 
+ * Attribute names
+ */
+#define screen_attr                   attributes[0]
+#define shadow_attr                   attributes[1]
+#define dialog_attr                   attributes[2]
+#define title_attr                    attributes[3]
+#define border_attr                   attributes[4]
+#define button_active_attr            attributes[5]
+#define button_inactive_attr          attributes[6]
+#define button_key_active_attr        attributes[7]
+#define button_key_inactive_attr      attributes[8]
+#define button_label_active_attr      attributes[9]
+#define button_label_inactive_attr    attributes[10]
+#define inputbox_attr                 attributes[11]
+#define inputbox_border_attr          attributes[12]
+#define searchbox_attr                attributes[13]
+#define searchbox_title_attr          attributes[14]
+#define searchbox_border_attr         attributes[15]
+#define position_indicator_attr       attributes[16]
+#define menubox_attr                  attributes[17]
+#define menubox_border_attr           attributes[18]
+#define item_attr                     attributes[19]
+#define item_selected_attr            attributes[20]
+#define tag_attr                      attributes[21]
+#define tag_selected_attr             attributes[22]
+#define tag_key_attr                  attributes[23]
+#define tag_key_selected_attr         attributes[24]
+#define check_attr                    attributes[25]
+#define check_selected_attr           attributes[26]
+#define uarrow_attr                   attributes[27]
+#define darrow_attr                   attributes[28]
+
+/* number of attributes */
+#define ATTRIBUTE_COUNT               29
+
+/*
+ * Global variables
+ */
+extern bool use_colors;
+extern bool use_shadow;
+
+extern chtype attributes[];
+
+extern const char *backtitle;
+
+/*
+ * Function prototypes
+ */
+extern void create_rc (const char *filename);
+extern int parse_rc (void);
+
+
+void init_dialog (void);
+void end_dialog (void);
+void attr_clear (WINDOW * win, int height, int width, chtype attr);
+void dialog_clear (void);
+void color_setup (void);
+void print_autowrap (WINDOW * win, const char *prompt, int width, int y, int x);
+void print_button (WINDOW * win, const char *label, int y, int x, int selected);
+void draw_box (WINDOW * win, int y, int x, int height, int width, chtype box,
+		chtype border);
+void draw_shadow (WINDOW * win, int y, int x, int height, int width);
+
+int first_alpha (const char *string, const char *exempt);
+int dialog_yesno (const char *title, const char *prompt, int height, int width);
+int dialog_msgbox (const char *title, const char *prompt, int height,
+		int width, int pause);
+int dialog_textbox (const char *title, const char *file, int height, int width);
+int dialog_menu (const char *title, const char *prompt, int height, int width,
+		int menu_height, const char *choice, int item_no, 
+		const char * const * items);
+int dialog_checklist (const char *title, const char *prompt, int height,
+		int width, int list_height, int item_no,
+		const char * const * items, int flag);
+extern unsigned char dialog_input_result[];
+int dialog_inputbox (const char *title, const char *prompt, int height,
+		int width, const char *init);
+
+/*
+ * This is the base for fictitious keys, which activate
+ * the buttons.
+ *
+ * Mouse-generated keys are the following:
+ *   -- the first 32 are used as numbers, in addition to '0'-'9'
+ *   -- the lowercase are used to signal mouse-enter events (M_EVENT + 'o')
+ *   -- uppercase chars are used to invoke the button (M_EVENT + 'O')
+ */
+#define M_EVENT (KEY_MAX+1)
+
+
+/*
+ * The `flag' parameter in checklist is used to select between
+ * radiolist and checklist
+ */
+#define FLAG_CHECK 1
+#define FLAG_RADIO 0
diff --git a/extra/config/lxdialog/inputbox.c b/extra/config/lxdialog/inputbox.c
new file mode 100644
index 000000000..fa7bebc69
--- /dev/null
+++ b/extra/config/lxdialog/inputbox.c
@@ -0,0 +1,240 @@
+/*
+ *  inputbox.c -- implements the input box
+ *
+ *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dialog.h"
+
+unsigned char dialog_input_result[MAX_LEN + 1];
+
+/*
+ *  Print the termination buttons
+ */
+static void
+print_buttons(WINDOW *dialog, int height, int width, int selected)
+{
+    int x = width / 2 - 11;
+    int y = height - 2;
+
+    print_button (dialog, "  Ok  ", y, x, selected==0);
+    print_button (dialog, " Help ", y, x + 14, selected==1);
+
+    wmove(dialog, y, x+1+14*selected);
+    wrefresh(dialog);
+}
+
+/*
+ * Display a dialog box for inputing a string
+ */
+int
+dialog_inputbox (const char *title, const char *prompt, int height, int width,
+		 const char *init)
+{
+    int i, x, y, box_y, box_x, box_width;
+    int input_x = 0, scroll = 0, key = 0, button = -1;
+    unsigned char *instr = dialog_input_result;
+    WINDOW *dialog;
+
+    /* center dialog box on screen */
+    x = (COLS - width) / 2;
+    y = (LINES - height) / 2;
+
+
+    draw_shadow (stdscr, y, x, height, width);
+
+    dialog = newwin (height, width, y, x);
+    keypad (dialog, TRUE);
+
+    draw_box (dialog, 0, 0, height, width, dialog_attr, border_attr);
+    wattrset (dialog, border_attr);
+    mvwaddch (dialog, height-3, 0, ACS_LTEE);
+    for (i = 0; i < width - 2; i++)
+	waddch (dialog, ACS_HLINE);
+    wattrset (dialog, dialog_attr);
+    waddch (dialog, ACS_RTEE);
+
+    if (title != NULL && strlen(title) >= width-2 ) {
+	/* truncate long title -- mec */
+	char * title2 = malloc(width-2+1);
+	memcpy( title2, title, width-2 );
+	title2[width-2] = '\0';
+	title = title2;
+    }
+
+    if (title != NULL) {
+	wattrset (dialog, title_attr);
+	mvwaddch (dialog, 0, (width - strlen(title))/2 - 1, ' ');
+	waddstr (dialog, (char *)title);
+	waddch (dialog, ' ');
+    }
+
+    wattrset (dialog, dialog_attr);
+    print_autowrap (dialog, prompt, width - 2, 1, 3);
+
+    /* Draw the input field box */
+    box_width = width - 6;
+    getyx (dialog, y, x);
+    box_y = y + 2;
+    box_x = (width - box_width) / 2;
+    draw_box (dialog, y + 1, box_x - 1, 3, box_width + 2,
+	      border_attr, dialog_attr);
+
+    print_buttons(dialog, height, width, 0);
+
+    /* Set up the initial value */
+    wmove (dialog, box_y, box_x);
+    wattrset (dialog, inputbox_attr);
+
+    if (!init)
+	instr[0] = '\0';
+    else
+	strcpy (instr, init);
+
+    input_x = strlen (instr);
+
+    if (input_x >= box_width) {
+	scroll = input_x - box_width + 1;
+	input_x = box_width - 1;
+	for (i = 0; i < box_width - 1; i++)
+	    waddch (dialog, instr[scroll + i]);
+    } else
+	waddstr (dialog, instr);
+
+    wmove (dialog, box_y, box_x + input_x);
+
+    wrefresh (dialog);
+
+    while (key != ESC) {
+	key = wgetch (dialog);
+
+	if (button == -1) {	/* Input box selected */
+	    switch (key) {
+	    case TAB:
+	    case KEY_UP:
+	    case KEY_DOWN:
+		break;
+	    case KEY_LEFT:
+		continue;
+	    case KEY_RIGHT:
+		continue;
+	    case KEY_BACKSPACE:
+	    case 127:
+		if (input_x || scroll) {
+		    wattrset (dialog, inputbox_attr);
+		    if (!input_x) {
+			scroll = scroll < box_width - 1 ?
+			    0 : scroll - (box_width - 1);
+			wmove (dialog, box_y, box_x);
+			for (i = 0; i < box_width; i++)
+			    waddch (dialog, instr[scroll + input_x + i] ?
+				    instr[scroll + input_x + i] : ' ');
+			input_x = strlen (instr) - scroll;
+		    } else
+			input_x--;
+		    instr[scroll + input_x] = '\0';
+		    mvwaddch (dialog, box_y, input_x + box_x, ' ');
+		    wmove (dialog, box_y, input_x + box_x);
+		    wrefresh (dialog);
+		}
+		continue;
+	    default:
+		if (key < 0x100 && isprint (key)) {
+		    if (scroll + input_x < MAX_LEN) {
+			wattrset (dialog, inputbox_attr);
+			instr[scroll + input_x] = key;
+			instr[scroll + input_x + 1] = '\0';
+			if (input_x == box_width - 1) {
+			    scroll++;
+			    wmove (dialog, box_y, box_x);
+			    for (i = 0; i < box_width - 1; i++)
+				waddch (dialog, instr[scroll + i]);
+			} else {
+			    wmove (dialog, box_y, input_x++ + box_x);
+			    waddch (dialog, key);
+			}
+			wrefresh (dialog);
+		    } else
+			flash ();	/* Alarm user about overflow */
+		    continue;
+		}
+	    }
+	}
+	switch (key) {
+	case 'O':
+	case 'o':
+	    delwin (dialog);
+	    return 0;
+	case 'H':
+	case 'h':
+	    delwin (dialog);
+	    return 1;
+	case KEY_UP:
+	case KEY_LEFT:
+	    switch (button) {
+	    case -1:
+		button = 1;	/* Indicates "Cancel" button is selected */
+		print_buttons(dialog, height, width, 1);
+		break;
+	    case 0:
+		button = -1;	/* Indicates input box is selected */
+		print_buttons(dialog, height, width, 0);
+		wmove (dialog, box_y, box_x + input_x);
+		wrefresh (dialog);
+		break;
+	    case 1:
+		button = 0;	/* Indicates "OK" button is selected */
+		print_buttons(dialog, height, width, 0);
+		break;
+	    }
+	    break;
+	case TAB:
+	case KEY_DOWN:
+	case KEY_RIGHT:
+	    switch (button) {
+	    case -1:
+		button = 0;	/* Indicates "OK" button is selected */
+		print_buttons(dialog, height, width, 0);
+		break;
+	    case 0:
+		button = 1;	/* Indicates "Cancel" button is selected */
+		print_buttons(dialog, height, width, 1);
+		break;
+	    case 1:
+		button = -1;	/* Indicates input box is selected */
+		print_buttons(dialog, height, width, 0);
+		wmove (dialog, box_y, box_x + input_x);
+		wrefresh (dialog);
+		break;
+	    }
+	    break;
+	case ' ':
+	case '\n':
+	    delwin (dialog);
+	    return (button == -1 ? 0 : button);
+	case 'X':
+	case 'x':
+	    key = ESC;
+	case ESC:
+	    break;
+	}
+    }
+
+    delwin (dialog);
+    return -1;			/* ESC pressed */
+}
diff --git a/extra/config/lxdialog/lxdialog b/extra/config/lxdialog/lxdialog
new file mode 100755
index 000000000..8a36532bc
Binary files /dev/null and b/extra/config/lxdialog/lxdialog differ
diff --git a/extra/config/lxdialog/lxdialog.c b/extra/config/lxdialog/lxdialog.c
new file mode 100644
index 000000000..6f4c1fd4e
--- /dev/null
+++ b/extra/config/lxdialog/lxdialog.c
@@ -0,0 +1,226 @@
+/*
+ *  dialog - Display simple dialog boxes from shell scripts
+ *
+ *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dialog.h"
+
+static void Usage (const char *name);
+
+typedef int (jumperFn) (const char *title, int argc, const char * const * argv);
+
+struct Mode {
+    char *name;
+    int argmin, argmax, argmod;
+    jumperFn *jumper;
+};
+
+jumperFn j_menu, j_checklist, j_radiolist, j_yesno, j_textbox, j_inputbox;
+jumperFn j_msgbox, j_infobox;
+
+static struct Mode modes[] =
+{
+    {"--menu", 9, 0, 3, j_menu},
+    {"--checklist", 9, 0, 3, j_checklist},
+    {"--radiolist", 9, 0, 3, j_radiolist},
+    {"--yesno",    5,5,1, j_yesno},
+    {"--textbox",  5,5,1, j_textbox},
+    {"--inputbox", 5, 6, 1, j_inputbox},
+    {"--msgbox", 5, 5, 1, j_msgbox},
+    {"--infobox", 5, 5, 1, j_infobox},
+    {NULL, 0, 0, 0, NULL}
+};
+
+static struct Mode *modePtr;
+
+#ifdef LOCALE
+#include <locale.h>
+#endif
+
+int
+main (int argc, const char * const * argv)
+{
+    int offset = 0, clear_screen = 0, end_common_opts = 0, retval;
+    const char *title = NULL;
+
+#ifdef LOCALE
+    (void) setlocale (LC_ALL, "");
+#endif
+
+#ifdef TRACE
+    trace(TRACE_CALLS|TRACE_UPDATE);
+#endif
+    if (argc < 2) {
+	Usage (argv[0]);
+	exit (-1);
+    }
+
+    while (offset < argc - 1 && !end_common_opts) {	/* Common options */
+	if (!strcmp (argv[offset + 1], "--title")) {
+	    if (argc - offset < 3 || title != NULL) {
+		Usage (argv[0]);
+		exit (-1);
+	    } else {
+		title = argv[offset + 2];
+		offset += 2;
+	    }
+        } else if (!strcmp (argv[offset + 1], "--backtitle")) {
+            if (backtitle != NULL) {
+                Usage (argv[0]);
+                exit (-1);
+            } else {
+                backtitle = argv[offset + 2];
+                offset += 2;
+            }
+	} else if (!strcmp (argv[offset + 1], "--clear")) {
+	    if (clear_screen) {	/* Hey, "--clear" can't appear twice! */
+		Usage (argv[0]);
+		exit (-1);
+	    } else if (argc == 2) {	/* we only want to clear the screen */
+		init_dialog ();
+		refresh ();	/* init_dialog() will clear the screen for us */
+		end_dialog ();
+		return 0;
+	    } else {
+		clear_screen = 1;
+		offset++;
+	    }
+	} else			/* no more common options */
+	    end_common_opts = 1;
+    }
+
+    if (argc - 1 == offset) {	/* no more options */
+	Usage (argv[0]);
+	exit (-1);
+    }
+    /* use a table to look for the requested mode, to avoid code duplication */
+
+    for (modePtr = modes; modePtr->name; modePtr++)	/* look for the mode */
+	if (!strcmp (argv[offset + 1], modePtr->name))
+	    break;
+
+    if (!modePtr->name)
+	Usage (argv[0]);
+    if (argc - offset < modePtr->argmin)
+	Usage (argv[0]);
+    if (modePtr->argmax && argc - offset > modePtr->argmax)
+	Usage (argv[0]);
+
+
+
+    init_dialog ();
+    retval = (*(modePtr->jumper)) (title, argc - offset, argv + offset);
+
+    if (clear_screen) {		/* clear screen before exit */
+	attr_clear (stdscr, LINES, COLS, screen_attr);
+	refresh ();
+    }
+    end_dialog();
+
+    exit (retval);
+}
+
+/*
+ * Print program usage
+ */
+static void
+Usage (const char *name)
+{
+    fprintf (stderr, "\
+\ndialog, by Savio Lam (lam836@cs.cuhk.hk).\
+\n  patched by Stuart Herbert (S.Herbert@shef.ac.uk)\
+\n  modified/gutted for use as a Linux kernel config tool by \
+\n  William Roadcap (roadcapw@cfw.com)\
+\n\
+\n* Display dialog boxes from shell scripts *\
+\n\
+\nUsage: %s --clear\
+\n       %s [--title <title>] [--backtitle <backtitle>] --clear <Box options>\
+\n\
+\nBox options:\
+\n\
+\n  --menu      <text> <height> <width> <menu height> <tag1> <item1>...\
+\n  --checklist <text> <height> <width> <list height> <tag1> <item1> <status1>...\
+\n  --radiolist <text> <height> <width> <list height> <tag1> <item1> <status1>...\
+\n  --textbox   <file> <height> <width>\
+\n  --inputbox  <text> <height> <width> [<init>]\
+\n  --yesno     <text> <height> <width>\
+\n", name, name);
+    exit (-1);
+}
+
+/*
+ * These are the program jumpers
+ */
+
+int
+j_menu (const char *t, int ac, const char * const * av)
+{
+    return dialog_menu (t, av[2], atoi (av[3]), atoi (av[4]),
+			atoi (av[5]), av[6], (ac - 6) / 2, av + 7);
+}
+
+int
+j_checklist (const char *t, int ac, const char * const * av)
+{
+    return dialog_checklist (t, av[2], atoi (av[3]), atoi (av[4]),
+	atoi (av[5]), (ac - 6) / 3, av + 6, FLAG_CHECK);
+}
+
+int
+j_radiolist (const char *t, int ac, const char * const * av)
+{
+    return dialog_checklist (t, av[2], atoi (av[3]), atoi (av[4]),
+	atoi (av[5]), (ac - 6) / 3, av + 6, FLAG_RADIO);
+}
+
+int
+j_textbox (const char *t, int ac, const char * const * av)
+{
+    return dialog_textbox (t, av[2], atoi (av[3]), atoi (av[4]));
+}
+
+int
+j_yesno (const char *t, int ac, const char * const * av)
+{
+    return dialog_yesno (t, av[2], atoi (av[3]), atoi (av[4]));
+}
+
+int
+j_inputbox (const char *t, int ac, const char * const * av)
+{
+    int ret = dialog_inputbox (t, av[2], atoi (av[3]), atoi (av[4]),
+                            ac == 6 ? av[5] : (char *) NULL);
+    if (ret == 0)
+        fprintf(stderr, dialog_input_result);
+    return ret;
+}
+
+int
+j_msgbox (const char *t, int ac, const char * const * av)
+{
+    return dialog_msgbox (t, av[2], atoi (av[3]), atoi (av[4]), 1);
+}
+
+int
+j_infobox (const char *t, int ac, const char * const * av)
+{
+    return dialog_msgbox (t, av[2], atoi (av[3]), atoi (av[4]), 0);
+}
+
diff --git a/extra/config/lxdialog/menubox.c b/extra/config/lxdialog/menubox.c
new file mode 100644
index 000000000..a234e9f3b
--- /dev/null
+++ b/extra/config/lxdialog/menubox.c
@@ -0,0 +1,443 @@
+/*
+ *  menubox.c -- implements the menu box
+ *
+ *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcapw@cfw.com)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ *  Changes by Clifford Wolf (god@clifford.at)
+ *
+ *  [ 1998-06-13 ]
+ *
+ *    *)  A bugfix for the Page-Down problem
+ *
+ *    *)  Formerly when I used Page Down and Page Up, the cursor would be set 
+ *        to the first position in the menu box.  Now lxdialog is a bit
+ *        smarter and works more like other menu systems (just have a look at
+ *        it).
+ *
+ *    *)  Formerly if I selected something my scrolling would be broken because
+ *        lxdialog is re-invoked by the Menuconfig shell script, can't
+ *        remember the last scrolling position, and just sets it so that the
+ *        cursor is at the bottom of the box.  Now it writes the temporary file
+ *        lxdialog.scrltmp which contains this information. The file is
+ *        deleted by lxdialog if the user leaves a submenu or enters a new
+ *        one, but it would be nice if Menuconfig could make another "rm -f"
+ *        just to be sure.  Just try it out - you will recognise a difference!
+ *
+ *  [ 1998-06-14 ]
+ *
+ *    *)  Now lxdialog is crash-safe against broken "lxdialog.scrltmp" files
+ *        and menus change their size on the fly.
+ *
+ *    *)  If for some reason the last scrolling position is not saved by
+ *        lxdialog, it sets the scrolling so that the selected item is in the
+ *        middle of the menu box, not at the bottom.
+ *
+ * 02 January 1999, Michael Elizabeth Chastain (mec@shout.net)
+ * Reset 'scroll' to 0 if the value from lxdialog.scrltmp is bogus.
+ * This fixes a bug in Menuconfig where using ' ' to descend into menus
+ * would leave mis-synchronized lxdialog.scrltmp files lying around,
+ * fscanf would read in 'scroll', and eventually that value would get used.
+ */
+
+#include "dialog.h"
+
+static int menu_width, item_x;
+
+/*
+ * Print menu item
+ */
+static void
+print_item (WINDOW * win, const char *item, int choice, int selected, int hotkey)
+{
+    int j;
+    char menu_item[menu_width+1];
+
+    strncpy(menu_item, item, menu_width);
+    menu_item[menu_width] = 0;
+    j = first_alpha(menu_item, "YyNnMm");
+
+    /* Clear 'residue' of last item */
+    wattrset (win, menubox_attr);
+    wmove (win, choice, 0);
+#if OLD_NCURSES
+    {
+        int i;
+        for (i = 0; i < menu_width; i++)
+	    waddch (win, ' ');
+    }
+#else
+    wclrtoeol(win);
+#endif
+    wattrset (win, selected ? item_selected_attr : item_attr);
+    mvwaddstr (win, choice, item_x, menu_item);
+    if (hotkey) {
+    	wattrset (win, selected ? tag_key_selected_attr : tag_key_attr);
+    	mvwaddch(win, choice, item_x+j, menu_item[j]);
+    }
+    if (selected) {
+	wmove (win, choice, item_x+1);
+	wrefresh (win);
+    }
+}
+
+/*
+ * Print the scroll indicators.
+ */
+static void
+print_arrows (WINDOW * win, int item_no, int scroll,
+		int y, int x, int height)
+{
+    int cur_y, cur_x;
+
+    getyx(win, cur_y, cur_x);
+
+    wmove(win, y, x);
+
+    if (scroll > 0) {
+	wattrset (win, uarrow_attr);
+	waddch (win, ACS_UARROW);
+	waddstr (win, "(-)");
+    }
+    else {
+	wattrset (win, menubox_attr);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+    }
+
+   y = y + height + 1;
+   wmove(win, y, x);
+
+   if ((height < item_no) && (scroll + height < item_no)) {
+	wattrset (win, darrow_attr);
+	waddch (win, ACS_DARROW);
+	waddstr (win, "(+)");
+    }
+    else {
+	wattrset (win, menubox_border_attr);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+	waddch (win, ACS_HLINE);
+   }
+
+   wmove(win, cur_y, cur_x);
+}
+
+/*
+ * Display the termination buttons.
+ */
+static void
+print_buttons (WINDOW *win, int height, int width, int selected)
+{
+    int x = width / 2 - 16;
+    int y = height - 2;
+
+    print_button (win, "Select", y, x, selected == 0);
+    print_button (win, " Exit ", y, x + 12, selected == 1);
+    print_button (win, " Help ", y, x + 24, selected == 2);
+
+    wmove(win, y, x+1+12*selected);
+    wrefresh (win);
+}
+
+/*
+ * Display a menu for choosing among a number of options
+ */
+int
+dialog_menu (const char *title, const char *prompt, int height, int width,
+		int menu_height, const char *current, int item_no,
+		const char * const * items)
+
+{
+    int i, j, x, y, box_x, box_y;
+    int key = 0, button = 0, scroll = 0, choice = 0, first_item = 0, max_choice;
+    WINDOW *dialog, *menu;
+    FILE *f;
+
+    max_choice = MIN (menu_height, item_no);
+
+    /* center dialog box on screen */
+    x = (COLS - width) / 2;
+    y = (LINES - height) / 2;
+
+    draw_shadow (stdscr, y, x, height, width);
+
+    dialog = newwin (height, width, y, x);
+    keypad (dialog, TRUE);
+
+    draw_box (dialog, 0, 0, height, width, dialog_attr, border_attr);
+    wattrset (dialog, border_attr);
+    mvwaddch (dialog, height - 3, 0, ACS_LTEE);
+    for (i = 0; i < width - 2; i++)
+	waddch (dialog, ACS_HLINE);
+    wattrset (dialog, dialog_attr);
+    wbkgdset (dialog, dialog_attr & A_COLOR);
+    waddch (dialog, ACS_RTEE);
+
+    if (title != NULL && strlen(title) >= width-2 ) {
+	/* truncate long title -- mec */
+	char * title2 = malloc(width-2+1);
+	memcpy( title2, title, width-2 );
+	title2[width-2] = '\0';
+	title = title2;
+    }
+
+    if (title != NULL) {
+	wattrset (dialog, title_attr);
+	mvwaddch (dialog, 0, (width - strlen(title))/2 - 1, ' ');
+	waddstr (dialog, (char *)title);
+	waddch (dialog, ' ');
+    }
+
+    wattrset (dialog, dialog_attr);
+    print_autowrap (dialog, prompt, width - 2, 1, 3);
+
+    menu_width = width - 6;
+    box_y = height - menu_height - 5;
+    box_x = (width - menu_width) / 2 - 1;
+
+    /* create new window for the menu */
+    menu = subwin (dialog, menu_height, menu_width,
+		y + box_y + 1, x + box_x + 1);
+    keypad (menu, TRUE);
+
+    /* draw a box around the menu items */
+    draw_box (dialog, box_y, box_x, menu_height + 2, menu_width + 2,
+	      menubox_border_attr, menubox_attr);
+
+    /*
+     * Find length of longest item in order to center menu.
+     * Set 'choice' to default item. 
+     */
+    item_x = 0;
+    for (i = 0; i < item_no; i++) {
+	item_x = MAX (item_x, MIN(menu_width, strlen (items[i * 2 + 1]) + 2));
+	if (strcmp(current, items[i*2]) == 0) choice = i;
+    }
+
+    item_x = (menu_width - item_x) / 2;
+
+    /* get the scroll info from the temp file */
+    if ( (f=fopen("lxdialog.scrltmp","r")) != NULL ) {
+	if ( (fscanf(f,"%d\n",&scroll) == 1) && (scroll <= choice) &&
+	     (scroll+max_choice > choice) && (scroll >= 0) &&
+	     (scroll+max_choice <= item_no) ) {
+	    first_item = scroll;
+	    choice = choice - scroll;
+	    fclose(f);
+	} else {
+	    scroll=0;
+	    remove("lxdialog.scrltmp");
+	    fclose(f);
+	    f=NULL;
+	}
+    }
+    if ( (choice >= max_choice) || (f==NULL && choice >= max_choice/2) ) {
+	if (choice >= item_no-max_choice/2)
+	    scroll = first_item = item_no-max_choice;
+	else
+	    scroll = first_item = choice - max_choice/2;
+	choice = choice - scroll;
+    }
+
+    /* Print the menu */
+    for (i=0; i < max_choice; i++) {
+	print_item (menu, items[(first_item + i) * 2 + 1], i, i == choice,
+                    (items[(first_item + i)*2][0] != ':'));
+    }
+
+    wnoutrefresh (menu);
+
+    print_arrows(dialog, item_no, scroll,
+		 box_y, box_x+item_x+1, menu_height);
+
+    print_buttons (dialog, height, width, 0);
+    wmove (menu, choice, item_x+1);
+    wrefresh (menu);
+
+    while (key != ESC) {
+	key = wgetch(menu);
+
+	if (key < 256 && isalpha(key)) key = tolower(key);
+
+	if (strchr("ynm", key))
+		i = max_choice;
+	else {
+        for (i = choice+1; i < max_choice; i++) {
+		j = first_alpha(items[(scroll+i)*2+1], "YyNnMm");
+		if (key == tolower(items[(scroll+i)*2+1][j]))
+                	break;
+	}
+	if (i == max_choice)
+       		for (i = 0; i < max_choice; i++) {
+			j = first_alpha(items[(scroll+i)*2+1], "YyNnMm");
+			if (key == tolower(items[(scroll+i)*2+1][j]))
+                		break;
+		}
+	}
+
+	if (i < max_choice || 
+            key == KEY_UP || key == KEY_DOWN ||
+            key == '-' || key == '+' ||
+            key == KEY_PPAGE || key == KEY_NPAGE) {
+
+            print_item (menu, items[(scroll+choice)*2+1], choice, FALSE,
+                       (items[(scroll+choice)*2][0] != ':'));
+
+	    if (key == KEY_UP || key == '-') {
+                if (choice < 2 && scroll) {
+	            /* Scroll menu down */
+                    scrollok (menu, TRUE);
+                    wscrl (menu, -1);
+                    scrollok (menu, FALSE);
+
+                    scroll--;
+
+                    print_item (menu, items[scroll * 2 + 1], 0, FALSE,
+                               (items[scroll*2][0] != ':'));
+		} else
+		    choice = MAX(choice - 1, 0);
+
+	    } else if (key == KEY_DOWN || key == '+')  {
+
+		print_item (menu, items[(scroll+choice)*2+1], choice, FALSE,
+                                (items[(scroll+choice)*2][0] != ':'));
+
+                if ((choice > max_choice-3) &&
+                    (scroll + max_choice < item_no)
+                   ) {
+		    /* Scroll menu up */
+		    scrollok (menu, TRUE);
+                    scroll (menu);
+                    scrollok (menu, FALSE);
+
+                    scroll++;
+
+                    print_item (menu, items[(scroll+max_choice-1)*2+1],
+                               max_choice-1, FALSE,
+                               (items[(scroll+max_choice-1)*2][0] != ':'));
+                } else
+                    choice = MIN(choice+1, max_choice-1);
+
+	    } else if (key == KEY_PPAGE) {
+	        scrollok (menu, TRUE);
+                for (i=0; (i < max_choice); i++) {
+                    if (scroll > 0) {
+                	wscrl (menu, -1);
+                	scroll--;
+                	print_item (menu, items[scroll * 2 + 1], 0, FALSE,
+                	(items[scroll*2][0] != ':'));
+                    } else {
+                        if (choice > 0)
+                            choice--;
+                    }
+                }
+                scrollok (menu, FALSE);
+
+            } else if (key == KEY_NPAGE) {
+                for (i=0; (i < max_choice); i++) {
+                    if (scroll+max_choice < item_no) {
+			scrollok (menu, TRUE);
+			scroll(menu);
+			scrollok (menu, FALSE);
+                	scroll++;
+                	print_item (menu, items[(scroll+max_choice-1)*2+1],
+			            max_choice-1, FALSE,
+			            (items[(scroll+max_choice-1)*2][0] != ':'));
+		    } else {
+			if (choice+1 < max_choice)
+			    choice++;
+		    }
+                }
+
+            } else
+                choice = i;
+
+            print_item (menu, items[(scroll+choice)*2+1], choice, TRUE,
+                       (items[(scroll+choice)*2][0] != ':'));
+
+            print_arrows(dialog, item_no, scroll,
+                         box_y, box_x+item_x+1, menu_height);
+
+            wnoutrefresh (dialog);
+            wrefresh (menu);
+
+	    continue;		/* wait for another key press */
+        }
+
+	switch (key) {
+	case KEY_LEFT:
+	case TAB:
+	case KEY_RIGHT:
+	    button = ((key == KEY_LEFT ? --button : ++button) < 0)
+			? 2 : (button > 2 ? 0 : button);
+
+	    print_buttons(dialog, height, width, button);
+	    wrefresh (menu);
+	    break;
+	case ' ':
+	case 's':
+	case 'y':
+	case 'n':
+	case 'm':
+	    /* save scroll info */
+	    if ( (f=fopen("lxdialog.scrltmp","w")) != NULL ) {
+		fprintf(f,"%d\n",scroll);
+		fclose(f);
+	    }
+	    delwin (dialog);
+            fprintf(stderr, "%s\n", items[(scroll + choice) * 2]);
+            switch (key) {
+            case 's': return 3;
+            case 'y': return 3;
+            case 'n': return 4;
+            case 'm': return 5;
+            case ' ': return 6;
+            }
+	    return 0;
+	case 'h':
+	case '?':
+	    button = 2;
+	case '\n':
+	    delwin (dialog);
+	    if (button == 2) 
+            	fprintf(stderr, "%s \"%s\"\n", 
+			items[(scroll + choice) * 2],
+			items[(scroll + choice) * 2 + 1] +
+			first_alpha(items[(scroll + choice) * 2 + 1],""));
+	    else
+            	fprintf(stderr, "%s\n", items[(scroll + choice) * 2]);
+
+	    remove("lxdialog.scrltmp");
+	    return button;
+	case 'e':
+	case 'x':
+	    key = ESC;
+	case ESC:
+	    break;
+	}
+    }
+
+    delwin (dialog);
+    remove("lxdialog.scrltmp");
+    return -1;			/* ESC pressed */
+}
diff --git a/extra/config/lxdialog/msgbox.c b/extra/config/lxdialog/msgbox.c
new file mode 100644
index 000000000..93692e1fb
--- /dev/null
+++ b/extra/config/lxdialog/msgbox.c
@@ -0,0 +1,85 @@
+/*
+ *  msgbox.c -- implements the message box and info box
+ *
+ *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcapw@cfw.com)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dialog.h"
+
+/*
+ * Display a message box. Program will pause and display an "OK" button
+ * if the parameter 'pause' is non-zero.
+ */
+int
+dialog_msgbox (const char *title, const char *prompt, int height, int width,
+		int pause)
+{
+    int i, x, y, key = 0;
+    WINDOW *dialog;
+
+    /* center dialog box on screen */
+    x = (COLS - width) / 2;
+    y = (LINES - height) / 2;
+
+    draw_shadow (stdscr, y, x, height, width);
+
+    dialog = newwin (height, width, y, x);
+    keypad (dialog, TRUE);
+
+    draw_box (dialog, 0, 0, height, width, dialog_attr, border_attr);
+
+    if (title != NULL && strlen(title) >= width-2 ) {
+	/* truncate long title -- mec */
+	char * title2 = malloc(width-2+1);
+	memcpy( title2, title, width-2 );
+	title2[width-2] = '\0';
+	title = title2;
+    }
+
+    if (title != NULL) {
+	wattrset (dialog, title_attr);
+	mvwaddch (dialog, 0, (width - strlen(title))/2 - 1, ' ');
+	waddstr (dialog, (char *)title);
+	waddch (dialog, ' ');
+    }
+    wattrset (dialog, dialog_attr);
+    print_autowrap (dialog, prompt, width - 2, 1, 2);
+
+    if (pause) {
+	wattrset (dialog, border_attr);
+	mvwaddch (dialog, height - 3, 0, ACS_LTEE);
+	for (i = 0; i < width - 2; i++)
+	    waddch (dialog, ACS_HLINE);
+	wattrset (dialog, dialog_attr);
+	waddch (dialog, ACS_RTEE);
+
+	print_button (dialog, "  Ok  ",
+		      height - 2, width / 2 - 4, TRUE);
+
+	wrefresh (dialog);
+	while (key != ESC && key != '\n' && key != ' ' &&
+               key != 'O' && key != 'o' && key != 'X' && key != 'x')
+	    key = wgetch (dialog);
+    } else {
+	key = '\n';
+	wrefresh (dialog);
+    }
+
+    delwin (dialog);
+    return key == ESC ? -1 : 0;
+}
diff --git a/extra/config/lxdialog/textbox.c b/extra/config/lxdialog/textbox.c
new file mode 100644
index 000000000..ecf55410e
--- /dev/null
+++ b/extra/config/lxdialog/textbox.c
@@ -0,0 +1,556 @@
+/*
+ *  textbox.c -- implements the text box
+ *
+ *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dialog.h"
+
+static void back_lines (int n);
+static void print_page (WINDOW * win, int height, int width);
+static void print_line (WINDOW * win, int row, int width);
+static char *get_line (void);
+static void print_position (WINDOW * win, int height, int width);
+
+static int hscroll = 0, fd, file_size, bytes_read;
+static int begin_reached = 1, end_reached = 0, page_length;
+static char *buf, *page;
+
+/*
+ * Display text from a file in a dialog box.
+ */
+int
+dialog_textbox (const char *title, const char *file, int height, int width)
+{
+    int i, x, y, cur_x, cur_y, fpos, key = 0;
+    int passed_end;
+    char search_term[MAX_LEN + 1];
+    WINDOW *dialog, *text;
+
+    search_term[0] = '\0';	/* no search term entered yet */
+
+    /* Open input file for reading */
+    if ((fd = open (file, O_RDONLY)) == -1) {
+	endwin ();
+	fprintf (stderr,
+		 "\nCan't open input file in dialog_textbox().\n");
+	exit (-1);
+    }
+    /* Get file size. Actually, 'file_size' is the real file size - 1,
+       since it's only the last byte offset from the beginning */
+    if ((file_size = lseek (fd, 0, SEEK_END)) == -1) {
+	endwin ();
+	fprintf (stderr, "\nError getting file size in dialog_textbox().\n");
+	exit (-1);
+    }
+    /* Restore file pointer to beginning of file after getting file size */
+    if (lseek (fd, 0, SEEK_SET) == -1) {
+	endwin ();
+	fprintf (stderr, "\nError moving file pointer in dialog_textbox().\n");
+	exit (-1);
+    }
+    /* Allocate space for read buffer */
+    if ((buf = malloc (BUF_SIZE + 1)) == NULL) {
+	endwin ();
+	fprintf (stderr, "\nCan't allocate memory in dialog_textbox().\n");
+	exit (-1);
+    }
+    if ((bytes_read = read (fd, buf, BUF_SIZE)) == -1) {
+	endwin ();
+	fprintf (stderr, "\nError reading file in dialog_textbox().\n");
+	exit (-1);
+    }
+    buf[bytes_read] = '\0';	/* mark end of valid data */
+    page = buf;			/* page is pointer to start of page to be displayed */
+
+    /* center dialog box on screen */
+    x = (COLS - width) / 2;
+    y = (LINES - height) / 2;
+
+
+    draw_shadow (stdscr, y, x, height, width);
+
+    dialog = newwin (height, width, y, x);
+    keypad (dialog, TRUE);
+
+    /* Create window for text region, used for scrolling text */
+    text = subwin (dialog, height - 4, width - 2, y + 1, x + 1);
+    wattrset (text, dialog_attr);
+    wbkgdset (text, dialog_attr & A_COLOR);
+
+    keypad (text, TRUE);
+
+    /* register the new window, along with its borders */
+    draw_box (dialog, 0, 0, height, width, dialog_attr, border_attr);
+
+    wattrset (dialog, border_attr);
+    mvwaddch (dialog, height-3, 0, ACS_LTEE);
+    for (i = 0; i < width - 2; i++)
+	waddch (dialog, ACS_HLINE);
+    wattrset (dialog, dialog_attr);
+    wbkgdset (dialog, dialog_attr & A_COLOR);
+    waddch (dialog, ACS_RTEE);
+
+    if (title != NULL && strlen(title) >= width-2 ) {
+	/* truncate long title -- mec */
+	char * title2 = malloc(width-2+1);
+	memcpy( title2, title, width-2 );
+	title2[width-2] = '\0';
+	title = title2;
+    }
+
+    if (title != NULL) {
+	wattrset (dialog, title_attr);
+	mvwaddch (dialog, 0, (width - strlen(title))/2 - 1, ' ');
+	waddstr (dialog, (char *)title);
+	waddch (dialog, ' ');
+    }
+    print_button (dialog, " Exit ", height - 2, width / 2 - 4, TRUE);
+    wnoutrefresh (dialog);
+    getyx (dialog, cur_y, cur_x);	/* Save cursor position */
+
+    /* Print first page of text */
+    attr_clear (text, height - 4, width - 2, dialog_attr);
+    print_page (text, height - 4, width - 2);
+    print_position (dialog, height, width);
+    wmove (dialog, cur_y, cur_x);	/* Restore cursor position */
+    wrefresh (dialog);
+
+    while ((key != ESC) && (key != '\n')) {
+	key = wgetch (dialog);
+	switch (key) {
+	case 'E':		/* Exit */
+	case 'e':
+	case 'X':
+	case 'x':
+	    delwin (dialog);
+	    free (buf);
+	    close (fd);
+	    return 0;
+	case 'g':		/* First page */
+	case KEY_HOME:
+	    if (!begin_reached) {
+		begin_reached = 1;
+		/* First page not in buffer? */
+		if ((fpos = lseek (fd, 0, SEEK_CUR)) == -1) {
+		    endwin ();
+		    fprintf (stderr,
+		      "\nError moving file pointer in dialog_textbox().\n");
+		    exit (-1);
+		}
+		if (fpos > bytes_read) {	/* Yes, we have to read it in */
+		    if (lseek (fd, 0, SEEK_SET) == -1) {
+			endwin ();
+			fprintf (stderr, "\nError moving file pointer in "
+				 "dialog_textbox().\n");
+			exit (-1);
+		    }
+		    if ((bytes_read = read (fd, buf, BUF_SIZE)) == -1) {
+			endwin ();
+			fprintf (stderr,
+			     "\nError reading file in dialog_textbox().\n");
+			exit (-1);
+		    }
+		    buf[bytes_read] = '\0';
+		}
+		page = buf;
+		print_page (text, height - 4, width - 2);
+		print_position (dialog, height, width);
+		wmove (dialog, cur_y, cur_x);	/* Restore cursor position */
+		wrefresh (dialog);
+	    }
+	    break;
+	case 'G':		/* Last page */
+	case KEY_END:
+
+	    end_reached = 1;
+	    /* Last page not in buffer? */
+	    if ((fpos = lseek (fd, 0, SEEK_CUR)) == -1) {
+		endwin ();
+		fprintf (stderr,
+		      "\nError moving file pointer in dialog_textbox().\n");
+		exit (-1);
+	    }
+	    if (fpos < file_size) {	/* Yes, we have to read it in */
+		if (lseek (fd, -BUF_SIZE, SEEK_END) == -1) {
+		    endwin ();
+		    fprintf (stderr,
+		      "\nError moving file pointer in dialog_textbox().\n");
+		    exit (-1);
+		}
+		if ((bytes_read = read (fd, buf, BUF_SIZE)) == -1) {
+		    endwin ();
+		    fprintf (stderr,
+			     "\nError reading file in dialog_textbox().\n");
+		    exit (-1);
+		}
+		buf[bytes_read] = '\0';
+	    }
+	    page = buf + bytes_read;
+	    back_lines (height - 4);
+	    print_page (text, height - 4, width - 2);
+	    print_position (dialog, height, width);
+	    wmove (dialog, cur_y, cur_x);	/* Restore cursor position */
+	    wrefresh (dialog);
+	    break;
+	case 'K':		/* Previous line */
+	case 'k':
+	case KEY_UP:
+	    if (!begin_reached) {
+		back_lines (page_length + 1);
+
+		/* We don't call print_page() here but use scrolling to ensure
+		   faster screen update. However, 'end_reached' and
+		   'page_length' should still be updated, and 'page' should
+		   point to start of next page. This is done by calling
+		   get_line() in the following 'for' loop. */
+		scrollok (text, TRUE);
+		wscrl (text, -1);	/* Scroll text region down one line */
+		scrollok (text, FALSE);
+		page_length = 0;
+		passed_end = 0;
+		for (i = 0; i < height - 4; i++) {
+		    if (!i) {
+			/* print first line of page */
+			print_line (text, 0, width - 2);
+			wnoutrefresh (text);
+		    } else
+			/* Called to update 'end_reached' and 'page' */
+			get_line ();
+		    if (!passed_end)
+			page_length++;
+		    if (end_reached && !passed_end)
+			passed_end = 1;
+		}
+
+		print_position (dialog, height, width);
+		wmove (dialog, cur_y, cur_x);	/* Restore cursor position */
+		wrefresh (dialog);
+	    }
+	    break;
+	case 'B':		/* Previous page */
+	case 'b':
+	case KEY_PPAGE:
+	    if (begin_reached)
+		break;
+	    back_lines (page_length + height - 4);
+	    print_page (text, height - 4, width - 2);
+	    print_position (dialog, height, width);
+	    wmove (dialog, cur_y, cur_x);
+	    wrefresh (dialog);
+	    break;
+	case 'J':		/* Next line */
+	case 'j':
+	case KEY_DOWN:
+	    if (!end_reached) {
+		begin_reached = 0;
+		scrollok (text, TRUE);
+		scroll (text);	/* Scroll text region up one line */
+		scrollok (text, FALSE);
+		print_line (text, height - 5, width - 2);
+		wnoutrefresh (text);
+		print_position (dialog, height, width);
+		wmove (dialog, cur_y, cur_x);	/* Restore cursor position */
+		wrefresh (dialog);
+	    }
+	    break;
+	case KEY_NPAGE:		/* Next page */
+	case ' ':
+	    if (end_reached)
+		break;
+
+	    begin_reached = 0;
+	    print_page (text, height - 4, width - 2);
+	    print_position (dialog, height, width);
+	    wmove (dialog, cur_y, cur_x);
+	    wrefresh (dialog);
+	    break;
+	case '0':		/* Beginning of line */
+	case 'H':		/* Scroll left */
+	case 'h':
+	case KEY_LEFT:
+	    if (hscroll <= 0)
+		break;
+
+	    if (key == '0')
+		hscroll = 0;
+	    else
+		hscroll--;
+	    /* Reprint current page to scroll horizontally */
+	    back_lines (page_length);
+	    print_page (text, height - 4, width - 2);
+	    wmove (dialog, cur_y, cur_x);
+	    wrefresh (dialog);
+	    break;
+	case 'L':		/* Scroll right */
+	case 'l':
+	case KEY_RIGHT:
+	    if (hscroll >= MAX_LEN)
+		break;
+	    hscroll++;
+	    /* Reprint current page to scroll horizontally */
+	    back_lines (page_length);
+	    print_page (text, height - 4, width - 2);
+	    wmove (dialog, cur_y, cur_x);
+	    wrefresh (dialog);
+	    break;
+	case ESC:
+	    break;
+	}
+    }
+
+    delwin (dialog);
+    free (buf);
+    close (fd);
+    return -1;			/* ESC pressed */
+}
+
+/*
+ * Go back 'n' lines in text file. Called by dialog_textbox().
+ * 'page' will be updated to point to the desired line in 'buf'.
+ */
+static void
+back_lines (int n)
+{
+    int i, fpos;
+
+    begin_reached = 0;
+    /* We have to distinguish between end_reached and !end_reached
+       since at end of file, the line is not ended by a '\n'.
+       The code inside 'if' basically does a '--page' to move one
+       character backward so as to skip '\n' of the previous line */
+    if (!end_reached) {
+	/* Either beginning of buffer or beginning of file reached? */
+	if (page == buf) {
+	    if ((fpos = lseek (fd, 0, SEEK_CUR)) == -1) {
+		endwin ();
+		fprintf (stderr, "\nError moving file pointer in "
+			 "back_lines().\n");
+		exit (-1);
+	    }
+	    if (fpos > bytes_read) {	/* Not beginning of file yet */
+		/* We've reached beginning of buffer, but not beginning of
+		   file yet, so read previous part of file into buffer.
+		   Note that we only move backward for BUF_SIZE/2 bytes,
+		   but not BUF_SIZE bytes to avoid re-reading again in
+		   print_page() later */
+		/* Really possible to move backward BUF_SIZE/2 bytes? */
+		if (fpos < BUF_SIZE / 2 + bytes_read) {
+		    /* No, move less then */
+		    if (lseek (fd, 0, SEEK_SET) == -1) {
+			endwin ();
+			fprintf (stderr, "\nError moving file pointer in "
+				 "back_lines().\n");
+			exit (-1);
+		    }
+		    page = buf + fpos - bytes_read;
+		} else {	/* Move backward BUF_SIZE/2 bytes */
+		    if (lseek (fd, -(BUF_SIZE / 2 + bytes_read), SEEK_CUR)
+			== -1) {
+			endwin ();
+			fprintf (stderr, "\nError moving file pointer "
+				 "in back_lines().\n");
+			exit (-1);
+		    }
+		    page = buf + BUF_SIZE / 2;
+		}
+		if ((bytes_read = read (fd, buf, BUF_SIZE)) == -1) {
+		    endwin ();
+		    fprintf (stderr, "\nError reading file in back_lines().\n");
+		    exit (-1);
+		}
+		buf[bytes_read] = '\0';
+	    } else {		/* Beginning of file reached */
+		begin_reached = 1;
+		return;
+	    }
+	}
+	if (*(--page) != '\n') {	/* '--page' here */
+	    /* Something's wrong... */
+	    endwin ();
+	    fprintf (stderr, "\nInternal error in back_lines().\n");
+	    exit (-1);
+	}
+    }
+    /* Go back 'n' lines */
+    for (i = 0; i < n; i++)
+	do {
+	    if (page == buf) {
+		if ((fpos = lseek (fd, 0, SEEK_CUR)) == -1) {
+		    endwin ();
+		    fprintf (stderr,
+			  "\nError moving file pointer in back_lines().\n");
+		    exit (-1);
+		}
+		if (fpos > bytes_read) {
+		    /* Really possible to move backward BUF_SIZE/2 bytes? */
+		    if (fpos < BUF_SIZE / 2 + bytes_read) {
+			/* No, move less then */
+			if (lseek (fd, 0, SEEK_SET) == -1) {
+			    endwin ();
+			    fprintf (stderr, "\nError moving file pointer "
+				     "in back_lines().\n");
+			    exit (-1);
+			}
+			page = buf + fpos - bytes_read;
+		    } else {	/* Move backward BUF_SIZE/2 bytes */
+			if (lseek (fd, -(BUF_SIZE / 2 + bytes_read),
+				   SEEK_CUR) == -1) {
+			    endwin ();
+			    fprintf (stderr, "\nError moving file pointer"
+				     " in back_lines().\n");
+			    exit (-1);
+			}
+			page = buf + BUF_SIZE / 2;
+		    }
+		    if ((bytes_read = read (fd, buf, BUF_SIZE)) == -1) {
+			endwin ();
+			fprintf (stderr, "\nError reading file in "
+				 "back_lines().\n");
+			exit (-1);
+		    }
+		    buf[bytes_read] = '\0';
+		} else {	/* Beginning of file reached */
+		    begin_reached = 1;
+		    return;
+		}
+	    }
+	} while (*(--page) != '\n');
+    page++;
+}
+
+/*
+ * Print a new page of text. Called by dialog_textbox().
+ */
+static void
+print_page (WINDOW * win, int height, int width)
+{
+    int i, passed_end = 0;
+
+    page_length = 0;
+    for (i = 0; i < height; i++) {
+	print_line (win, i, width);
+	if (!passed_end)
+	    page_length++;
+	if (end_reached && !passed_end)
+	    passed_end = 1;
+    }
+    wnoutrefresh (win);
+}
+
+/*
+ * Print a new line of text. Called by dialog_textbox() and print_page().
+ */
+static void
+print_line (WINDOW * win, int row, int width)
+{
+    int y, x;
+    char *line;
+
+    line = get_line ();
+    line += MIN (strlen (line), hscroll);	/* Scroll horizontally */
+    wmove (win, row, 0);	/* move cursor to correct line */
+    waddch (win, ' ');
+    waddnstr (win, line, MIN (strlen (line), width - 2));
+
+    getyx (win, y, x);
+    /* Clear 'residue' of previous line */
+#if OLD_NCURSES
+    {
+        int i;
+        for (i = 0; i < width - x; i++)
+	    waddch (win, ' ');
+    }
+#else
+    wclrtoeol(win);
+#endif
+}
+
+/*
+ * Return current line of text. Called by dialog_textbox() and print_line().
+ * 'page' should point to start of current line before calling, and will be
+ * updated to point to start of next line.
+ */
+static char *
+get_line (void)
+{
+    int i = 0, fpos;
+    static char line[MAX_LEN + 1];
+
+    end_reached = 0;
+    while (*page != '\n') {
+	if (*page == '\0') {
+	    /* Either end of file or end of buffer reached */
+	    if ((fpos = lseek (fd, 0, SEEK_CUR)) == -1) {
+		endwin ();
+		fprintf (stderr, "\nError moving file pointer in "
+			 "get_line().\n");
+		exit (-1);
+	    }
+	    if (fpos < file_size) {	/* Not end of file yet */
+		/* We've reached end of buffer, but not end of file yet,
+		   so read next part of file into buffer */
+		if ((bytes_read = read (fd, buf, BUF_SIZE)) == -1) {
+		    endwin ();
+		    fprintf (stderr, "\nError reading file in get_line().\n");
+		    exit (-1);
+		}
+		buf[bytes_read] = '\0';
+		page = buf;
+	    } else {
+		if (!end_reached)
+		    end_reached = 1;
+		break;
+	    }
+	} else if (i < MAX_LEN)
+	    line[i++] = *(page++);
+	else {
+	    /* Truncate lines longer than MAX_LEN characters */
+	    if (i == MAX_LEN)
+		line[i++] = '\0';
+	    page++;
+	}
+    }
+    if (i <= MAX_LEN)
+	line[i] = '\0';
+    if (!end_reached)
+	page++;			/* move pass '\n' */
+
+    return line;
+}
+
+/*
+ * Print current position
+ */
+static void
+print_position (WINDOW * win, int height, int width)
+{
+    int fpos, percent;
+
+    if ((fpos = lseek (fd, 0, SEEK_CUR)) == -1) {
+	endwin ();
+	fprintf (stderr, "\nError moving file pointer in print_position().\n");
+	exit (-1);
+    }
+    wattrset (win, position_indicator_attr);
+    wbkgdset (win, position_indicator_attr & A_COLOR);
+    percent = !file_size ?
+	100 : ((fpos - bytes_read + page - buf) * 100) / file_size;
+    wmove (win, height - 3, width - 9);
+    wprintw (win, "(%3d%%)", percent);
+}
diff --git a/extra/config/lxdialog/util.c b/extra/config/lxdialog/util.c
new file mode 100644
index 000000000..b3a7af9d2
--- /dev/null
+++ b/extra/config/lxdialog/util.c
@@ -0,0 +1,359 @@
+/*
+ *  util.c
+ *
+ *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dialog.h"
+
+
+/* use colors by default? */
+bool use_colors = 1;
+
+const char *backtitle = NULL;
+
+const char *dialog_result;
+
+/* 
+ * Attribute values, default is for mono display
+ */
+chtype attributes[] =
+{
+    A_NORMAL,			/* screen_attr */
+    A_NORMAL,			/* shadow_attr */
+    A_NORMAL,			/* dialog_attr */
+    A_BOLD,			/* title_attr */
+    A_NORMAL,			/* border_attr */
+    A_REVERSE,			/* button_active_attr */
+    A_DIM,			/* button_inactive_attr */
+    A_REVERSE,			/* button_key_active_attr */
+    A_BOLD,			/* button_key_inactive_attr */
+    A_REVERSE,			/* button_label_active_attr */
+    A_NORMAL,			/* button_label_inactive_attr */
+    A_NORMAL,			/* inputbox_attr */
+    A_NORMAL,			/* inputbox_border_attr */
+    A_NORMAL,			/* searchbox_attr */
+    A_BOLD,			/* searchbox_title_attr */
+    A_NORMAL,			/* searchbox_border_attr */
+    A_BOLD,			/* position_indicator_attr */
+    A_NORMAL,			/* menubox_attr */
+    A_NORMAL,			/* menubox_border_attr */
+    A_NORMAL,			/* item_attr */
+    A_REVERSE,			/* item_selected_attr */
+    A_BOLD,			/* tag_attr */
+    A_REVERSE,			/* tag_selected_attr */
+    A_BOLD,			/* tag_key_attr */
+    A_REVERSE,			/* tag_key_selected_attr */
+    A_BOLD,			/* check_attr */
+    A_REVERSE,			/* check_selected_attr */
+    A_BOLD,			/* uarrow_attr */
+    A_BOLD			/* darrow_attr */
+};
+
+
+#include "colors.h"
+
+/*
+ * Table of color values
+ */
+int color_table[][3] =
+{
+    {SCREEN_FG, SCREEN_BG, SCREEN_HL},
+    {SHADOW_FG, SHADOW_BG, SHADOW_HL},
+    {DIALOG_FG, DIALOG_BG, DIALOG_HL},
+    {TITLE_FG, TITLE_BG, TITLE_HL},
+    {BORDER_FG, BORDER_BG, BORDER_HL},
+    {BUTTON_ACTIVE_FG, BUTTON_ACTIVE_BG, BUTTON_ACTIVE_HL},
+    {BUTTON_INACTIVE_FG, BUTTON_INACTIVE_BG, BUTTON_INACTIVE_HL},
+    {BUTTON_KEY_ACTIVE_FG, BUTTON_KEY_ACTIVE_BG, BUTTON_KEY_ACTIVE_HL},
+    {BUTTON_KEY_INACTIVE_FG, BUTTON_KEY_INACTIVE_BG, BUTTON_KEY_INACTIVE_HL},
+    {BUTTON_LABEL_ACTIVE_FG, BUTTON_LABEL_ACTIVE_BG, BUTTON_LABEL_ACTIVE_HL},
+    {BUTTON_LABEL_INACTIVE_FG, BUTTON_LABEL_INACTIVE_BG,
+     BUTTON_LABEL_INACTIVE_HL},
+    {INPUTBOX_FG, INPUTBOX_BG, INPUTBOX_HL},
+    {INPUTBOX_BORDER_FG, INPUTBOX_BORDER_BG, INPUTBOX_BORDER_HL},
+    {SEARCHBOX_FG, SEARCHBOX_BG, SEARCHBOX_HL},
+    {SEARCHBOX_TITLE_FG, SEARCHBOX_TITLE_BG, SEARCHBOX_TITLE_HL},
+    {SEARCHBOX_BORDER_FG, SEARCHBOX_BORDER_BG, SEARCHBOX_BORDER_HL},
+    {POSITION_INDICATOR_FG, POSITION_INDICATOR_BG, POSITION_INDICATOR_HL},
+    {MENUBOX_FG, MENUBOX_BG, MENUBOX_HL},
+    {MENUBOX_BORDER_FG, MENUBOX_BORDER_BG, MENUBOX_BORDER_HL},
+    {ITEM_FG, ITEM_BG, ITEM_HL},
+    {ITEM_SELECTED_FG, ITEM_SELECTED_BG, ITEM_SELECTED_HL},
+    {TAG_FG, TAG_BG, TAG_HL},
+    {TAG_SELECTED_FG, TAG_SELECTED_BG, TAG_SELECTED_HL},
+    {TAG_KEY_FG, TAG_KEY_BG, TAG_KEY_HL},
+    {TAG_KEY_SELECTED_FG, TAG_KEY_SELECTED_BG, TAG_KEY_SELECTED_HL},
+    {CHECK_FG, CHECK_BG, CHECK_HL},
+    {CHECK_SELECTED_FG, CHECK_SELECTED_BG, CHECK_SELECTED_HL},
+    {UARROW_FG, UARROW_BG, UARROW_HL},
+    {DARROW_FG, DARROW_BG, DARROW_HL},
+};				/* color_table */
+
+/*
+ * Set window to attribute 'attr'
+ */
+void
+attr_clear (WINDOW * win, int height, int width, chtype attr)
+{
+    int i, j;
+
+    wattrset (win, attr);
+    for (i = 0; i < height; i++) {
+	wmove (win, i, 0);
+	for (j = 0; j < width; j++)
+	    waddch (win, ' ');
+    }
+    touchwin (win);
+}
+
+void dialog_clear (void)
+{
+    attr_clear (stdscr, LINES, COLS, screen_attr);
+    /* Display background title if it exists ... - SLH */
+    if (backtitle != NULL) {
+        int i;
+
+        wattrset (stdscr, screen_attr);
+        mvwaddstr (stdscr, 0, 1, (char *)backtitle);
+        wmove (stdscr, 1, 1);
+        for (i = 1; i < COLS - 1; i++)
+            waddch (stdscr, ACS_HLINE);
+    }
+    wnoutrefresh (stdscr);
+}
+
+/*
+ * Do some initialization for dialog
+ */
+void
+init_dialog (void)
+{
+    initscr ();			/* Init curses */
+    keypad (stdscr, TRUE);
+    cbreak ();
+    noecho ();
+
+
+    if (use_colors)	/* Set up colors */
+	color_setup ();
+
+
+    dialog_clear ();
+}
+
+/*
+ * Setup for color display
+ */
+void
+color_setup (void)
+{
+    int i;
+
+    if (has_colors ()) {	/* Terminal supports color? */
+	start_color ();
+
+	/* Initialize color pairs */
+	for (i = 0; i < ATTRIBUTE_COUNT; i++)
+	    init_pair (i + 1, color_table[i][0], color_table[i][1]);
+
+	/* Setup color attributes */
+	for (i = 0; i < ATTRIBUTE_COUNT; i++)
+	    attributes[i] = C_ATTR (color_table[i][2], i + 1);
+    }
+}
+
+/*
+ * End using dialog functions.
+ */
+void
+end_dialog (void)
+{
+    endwin ();
+}
+
+
+/*
+ * Print a string of text in a window, automatically wrap around to the
+ * next line if the string is too long to fit on one line. Newline
+ * characters '\n' are replaced by spaces.  We start on a new line
+ * if there is no room for at least 4 nonblanks following a double-space.
+ */
+void
+print_autowrap (WINDOW * win, const char *prompt, int width, int y, int x)
+{
+    int newl, cur_x, cur_y;
+    int i, prompt_len, room, wlen;
+    char tempstr[MAX_LEN + 1], *word, *sp, *sp2;
+
+    strcpy (tempstr, prompt);
+
+    prompt_len = strlen(tempstr);
+	
+    /*
+     * Remove newlines
+     */
+    for(i=0; i<prompt_len; i++) {
+	if(tempstr[i] == '\n') tempstr[i] = ' ';
+    }
+
+    if (prompt_len <= width - x * 2) {	/* If prompt is short */
+	wmove (win, y, (width - prompt_len) / 2);
+	waddstr (win, tempstr);
+    } else {
+	cur_x = x;
+	cur_y = y;
+	newl = 1;
+	word = tempstr;
+	while (word && *word) {
+	    sp = index(word, ' ');
+	    if (sp)
+	        *sp++ = 0;
+
+	    /* Wrap to next line if either the word does not fit,
+	       or it is the first word of a new sentence, and it is
+	       short, and the next word does not fit. */
+	    room = width - cur_x;
+	    wlen = strlen(word);
+	    if (wlen > room ||
+	       (newl && wlen < 4 && sp && wlen+1+strlen(sp) > room
+		     && (!(sp2 = index(sp, ' ')) || wlen+1+(sp2-sp) > room))) {
+		cur_y++;
+		cur_x = x;
+	    }
+	    wmove (win, cur_y, cur_x);
+	    waddstr (win, word);
+	    getyx (win, cur_y, cur_x);
+	    cur_x++;
+	    if (sp && *sp == ' ') {
+	        cur_x++;	/* double space */
+		while (*++sp == ' ');
+		newl = 1;
+	    } else
+	        newl = 0;
+	    word = sp;
+	}
+    }
+}
+
+/*
+ * Print a button
+ */
+void
+print_button (WINDOW * win, const char *label, int y, int x, int selected)
+{
+    int i, temp;
+
+    wmove (win, y, x);
+    wattrset (win, selected ? button_active_attr : button_inactive_attr);
+    waddstr (win, "<");
+    temp = strspn (label, " ");
+    label += temp;
+    wattrset (win, selected ? button_label_active_attr
+	      : button_label_inactive_attr);
+    for (i = 0; i < temp; i++)
+	waddch (win, ' ');
+    wattrset (win, selected ? button_key_active_attr
+	      : button_key_inactive_attr);
+    waddch (win, label[0]);
+    wattrset (win, selected ? button_label_active_attr
+	      : button_label_inactive_attr);
+    waddstr (win, (char *)label + 1);
+    wattrset (win, selected ? button_active_attr : button_inactive_attr);
+    waddstr (win, ">");
+    wmove (win, y, x + temp + 1);
+}
+
+/*
+ * Draw a rectangular box with line drawing characters
+ */
+void
+draw_box (WINDOW * win, int y, int x, int height, int width,
+	  chtype box, chtype border)
+{
+    int i, j;
+
+    wattrset (win, 0);
+    for (i = 0; i < height; i++) {
+	wmove (win, y + i, x);
+	for (j = 0; j < width; j++)
+	    if (!i && !j)
+		waddch (win, border | ACS_ULCORNER);
+	    else if (i == height - 1 && !j)
+		waddch (win, border | ACS_LLCORNER);
+	    else if (!i && j == width - 1)
+		waddch (win, box | ACS_URCORNER);
+	    else if (i == height - 1 && j == width - 1)
+		waddch (win, box | ACS_LRCORNER);
+	    else if (!i)
+		waddch (win, border | ACS_HLINE);
+	    else if (i == height - 1)
+		waddch (win, box | ACS_HLINE);
+	    else if (!j)
+		waddch (win, border | ACS_VLINE);
+	    else if (j == width - 1)
+		waddch (win, box | ACS_VLINE);
+	    else
+		waddch (win, box | ' ');
+    }
+}
+
+/*
+ * Draw shadows along the right and bottom edge to give a more 3D look
+ * to the boxes
+ */
+void
+draw_shadow (WINDOW * win, int y, int x, int height, int width)
+{
+    int i;
+
+    if (has_colors ()) {	/* Whether terminal supports color? */
+	wattrset (win, shadow_attr);
+	wmove (win, y + height, x + 2);
+	for (i = 0; i < width; i++)
+	    waddch (win, winch (win) & A_CHARTEXT);
+	for (i = y + 1; i < y + height + 1; i++) {
+	    wmove (win, i, x + width);
+	    waddch (win, winch (win) & A_CHARTEXT);
+	    waddch (win, winch (win) & A_CHARTEXT);
+	}
+	wnoutrefresh (win);
+    }
+}
+
+/*
+ *  Return the position of the first alphabetic character in a string.
+ */
+int
+first_alpha(const char *string, const char *exempt)
+{
+	int i, in_paren=0, c;
+
+	for (i = 0; i < strlen(string); i++) {
+		c = tolower(string[i]);
+
+		if (strchr("<[(", c)) ++in_paren;
+		if (strchr(">])", c)) --in_paren;
+
+		if ((! in_paren) && isalpha(c) && 
+		     strchr(exempt, c) == 0)
+			return i;
+	}
+
+	return 0;
+}
diff --git a/extra/config/lxdialog/yesno.c b/extra/config/lxdialog/yesno.c
new file mode 100644
index 000000000..11fcc25f5
--- /dev/null
+++ b/extra/config/lxdialog/yesno.c
@@ -0,0 +1,118 @@
+/*
+ *  yesno.c -- implements the yes/no box
+ *
+ *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)
+ *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dialog.h"
+
+/*
+ * Display termination buttons
+ */
+static void
+print_buttons(WINDOW *dialog, int height, int width, int selected)
+{
+    int x = width / 2 - 10;
+    int y = height - 2;
+
+    print_button (dialog, " Yes ", y, x, selected == 0);
+    print_button (dialog, "  No  ", y, x + 13, selected == 1);
+
+    wmove(dialog, y, x+1 + 13*selected );
+    wrefresh (dialog);
+}
+
+/*
+ * Display a dialog box with two buttons - Yes and No
+ */
+int
+dialog_yesno (const char *title, const char *prompt, int height, int width)
+{
+    int i, x, y, key = 0, button = 0;
+    WINDOW *dialog;
+
+    /* center dialog box on screen */
+    x = (COLS - width) / 2;
+    y = (LINES - height) / 2;
+
+    draw_shadow (stdscr, y, x, height, width);
+
+    dialog = newwin (height, width, y, x);
+    keypad (dialog, TRUE);
+
+    draw_box (dialog, 0, 0, height, width, dialog_attr, border_attr);
+    wattrset (dialog, border_attr);
+    mvwaddch (dialog, height-3, 0, ACS_LTEE);
+    for (i = 0; i < width - 2; i++)
+	waddch (dialog, ACS_HLINE);
+    wattrset (dialog, dialog_attr);
+    waddch (dialog, ACS_RTEE);
+
+    if (title != NULL && strlen(title) >= width-2 ) {
+	/* truncate long title -- mec */
+	char * title2 = malloc(width-2+1);
+	memcpy( title2, title, width-2 );
+	title2[width-2] = '\0';
+	title = title2;
+    }
+
+    if (title != NULL) {
+	wattrset (dialog, title_attr);
+	mvwaddch (dialog, 0, (width - strlen(title))/2 - 1, ' ');
+	waddstr (dialog, (char *)title);
+	waddch (dialog, ' ');
+    }
+
+    wattrset (dialog, dialog_attr);
+    print_autowrap (dialog, prompt, width - 2, 1, 3);
+
+    print_buttons(dialog, height, width, 0);
+
+    while (key != ESC) {
+	key = wgetch (dialog);
+	switch (key) {
+	case 'Y':
+	case 'y':
+	    delwin (dialog);
+	    return 0;
+	case 'N':
+	case 'n':
+	    delwin (dialog);
+	    return 1;
+
+	case TAB:
+	case KEY_LEFT:
+	case KEY_RIGHT:
+	    button = ((key == KEY_LEFT ? --button : ++button) < 0)
+			? 1 : (button > 1 ? 0 : button);
+
+	    print_buttons(dialog, height, width, button);
+	    wrefresh (dialog);
+	    break;
+	case ' ':
+	case '\n':
+	    delwin (dialog);
+	    return button;
+	case ESC:
+	    break;
+	}
+    }
+
+    delwin (dialog);
+    return -1;			/* ESC pressed */
+}
diff --git a/extra/config/mconf b/extra/config/mconf
new file mode 100755
index 000000000..c9299e121
Binary files /dev/null and b/extra/config/mconf differ
diff --git a/extra/config/mconf.c b/extra/config/mconf.c
new file mode 100644
index 000000000..c738a3f35
--- /dev/null
+++ b/extra/config/mconf.c
@@ -0,0 +1,711 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <sys/ioctl.h>
+#include <sys/wait.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+static char menu_backtitle[128];
+static const char menu_instructions[] =
+	"Arrow keys navigate the menu.  "
+	"<Enter> selects submenus --->.  "
+	"Highlighted letters are hotkeys.  "
+	"Pressing <Y> selectes a feature, while <N> will exclude a feature.  "
+	"Press <Esc><Esc> to exit, <?> for Help.  "
+	"Legend: [*] feature is selected  [ ] feature is excluded",
+radiolist_instructions[] =
+	"Use the arrow keys to navigate this window or "
+	"press the hotkey of the item you wish to select "
+	"followed by the <SPACE BAR>. "
+	"Press <?> for additional information about this option.",
+inputbox_instructions_int[] =
+	"Please enter a decimal value. "
+	"Fractions will not be accepted.  "
+	"Use the <TAB> key to move from the input field to the buttons below it.",
+inputbox_instructions_hex[] =
+	"Please enter a hexadecimal value. "
+	"Use the <TAB> key to move from the input field to the buttons below it.",
+inputbox_instructions_string[] =
+	"Please enter a string value. "
+	"Use the <TAB> key to move from the input field to the buttons below it.",
+setmod_text[] =
+	"This feature depends on another which has been configured as a module.\n"
+	"As a result, this feature will be built as a module.",
+nohelp_text[] =
+	"There is no help available for this option.\n",
+load_config_text[] =
+	"Enter the name of the configuration file you wish to load.  "
+	"Accept the name shown to restore the configuration you "
+	"last retrieved.  Leave blank to abort.",
+load_config_help[] =
+	"\n"
+	"For various reasons, one may wish to keep several different uClibc\n"
+	"configurations available on a single machine.\n"
+	"\n"
+	"If you have saved a previous configuration in a file other than the\n"
+	"uClibc's default, entering the name of the file here will allow you\n"
+	"to modify that configuration.\n"
+	"\n"
+	"If you are uncertain, then you have probably never used alternate\n"
+	"configuration files.  You should therefor leave this blank to abort.\n",
+save_config_text[] =
+	"Enter a filename to which this configuration should be saved "
+	"as an alternate.  Leave blank to abort.",
+save_config_help[] =
+	"\n"
+	"For various reasons, one may wish to keep different uClibc\n"
+	"configurations available on a single machine.\n"
+	"\n"
+	"Entering a file name here will allow you to later retrieve, modify\n"
+	"and use the current configuration as an alternate to whatever\n"
+	"configuration options you have selected at that time.\n"
+	"\n"
+	"If you are uncertain what all this means then you should probably\n"
+	"leave this blank.\n"
+;
+
+static char buf[4096], *bufptr = buf;
+static char input_buf[4096];
+static char *args[1024], **argptr = args;
+static int indent = 0;
+static int rows, cols;
+static struct menu *current_menu;
+static int child_count;
+static int do_resize;
+
+static void conf(struct menu *menu);
+static void conf_choice(struct menu *menu);
+static void conf_string(struct menu *menu);
+static void conf_load(void);
+static void conf_save(void);
+static void show_textbox(const char *title, const char *text, int r, int c);
+static void show_helptext(const char *title, const char *text);
+static void show_help(struct menu *menu);
+static void show_readme(void);
+
+static void cprint_init(void);
+static int cprint1(const char *fmt, ...);
+static void cprint_done(void);
+static int cprint(const char *fmt, ...);
+
+static void init_wsize(void)
+{
+	struct winsize ws;
+
+	if (ioctl(1, TIOCGWINSZ, &ws) == -1) {
+		rows = 24;
+		cols = 80;
+	} else {
+		rows = ws.ws_row;
+		cols = ws.ws_col;
+	}
+
+	if (rows < 19 || cols < 80) {
+		fprintf(stderr, "Your display is too small to run Menuconfig!\n");
+		fprintf(stderr, "It must be at least 19 lines by 80 columns.\n");
+		exit(1);
+	}
+
+	rows -= 4;
+	cols -= 5;
+}
+
+static void cprint_init(void)
+{
+	bufptr = buf;
+	argptr = args;
+	memset(args, 0, sizeof(args));
+	indent = 0;
+	child_count = 0;
+	cprint("./extra/config/lxdialog/lxdialog");
+	cprint("--backtitle");
+	cprint(menu_backtitle);
+}
+
+static int cprint1(const char *fmt, ...)
+{
+	va_list ap;
+	int res;
+
+	if (!*argptr)
+		*argptr = bufptr;
+	va_start(ap, fmt);
+	res = vsprintf(bufptr, fmt, ap);
+	va_end(ap);
+	bufptr += res;
+
+	return res;
+}
+
+static void cprint_done(void)
+{
+	*bufptr++ = 0;
+	argptr++;
+}
+
+static int cprint(const char *fmt, ...)
+{
+	va_list ap;
+	int res;
+
+	*argptr++ = bufptr;
+	va_start(ap, fmt);
+	res = vsprintf(bufptr, fmt, ap);
+	va_end(ap);
+	bufptr += res;
+	*bufptr++ = 0;
+
+	return res;
+}
+
+pid_t pid;
+
+static void winch_handler(int sig)
+{
+	if (!do_resize) {
+		kill(pid, SIGINT);
+		do_resize = 1;
+	}
+}
+
+static int exec_conf(void)
+{
+	int pipefd[2], stat, size;
+	struct sigaction sa;
+	sigset_t sset, osset;
+
+	sigemptyset(&sset);
+	sigaddset(&sset, SIGINT);
+	sigprocmask(SIG_BLOCK, &sset, &osset);
+
+	signal(SIGINT, SIG_DFL);
+
+	sa.sa_handler = winch_handler;
+	sigemptyset(&sa.sa_mask);
+	sa.sa_flags = SA_RESTART;
+	sigaction(SIGWINCH, &sa, NULL);
+
+	*argptr++ = NULL;
+
+	pipe(pipefd);
+	pid = fork();
+	if (pid == 0) {
+		sigprocmask(SIG_SETMASK, &osset, NULL);
+		dup2(pipefd[1], 2);
+		close(pipefd[0]);
+		close(pipefd[1]);
+		execv(args[0], args);
+		_exit(EXIT_FAILURE);
+	}
+
+	close(pipefd[1]);
+	bufptr = input_buf;
+	while (1) {
+		size = input_buf + sizeof(input_buf) - bufptr;
+		size = read(pipefd[0], bufptr, size);
+		if (size <= 0) {
+			if (size < 0) {
+				if (errno == EINTR || errno == EAGAIN)
+					continue;
+				perror("read");
+			}
+			break;
+		}
+		bufptr += size;
+	}
+	*bufptr++ = 0;
+	close(pipefd[0]);
+	waitpid(pid, &stat, 0);
+
+	if (do_resize) {
+		init_wsize();
+		do_resize = 0;
+		sigprocmask(SIG_SETMASK, &osset, NULL);
+		return -1;
+	}
+	if (WIFSIGNALED(stat)) {
+		printf("\finterrupted(%d)\n", WTERMSIG(stat));
+		exit(1);
+	}
+#if 0
+	printf("\fexit state: %d\nexit data: '%s'\n", WEXITSTATUS(stat), input_buf);
+	sleep(1);
+#endif
+	sigpending(&sset);
+	if (sigismember(&sset, SIGINT)) {
+		printf("\finterrupted\n");
+		exit(1);
+	}
+	sigprocmask(SIG_SETMASK, &osset, NULL);
+
+	return WEXITSTATUS(stat);
+}
+
+static void build_conf(struct menu *menu)
+{
+	struct symbol *sym;
+	struct property *prop;
+	struct menu *child;
+	int type, tmp, doint = 2;
+	tristate val;
+	char ch;
+
+	if (!menu_is_visible(menu))
+		return;
+
+	sym = menu->sym;
+	prop = menu->prompt;
+	if (!sym) {
+		if (prop && menu != current_menu) {
+			const char *prompt = menu_get_prompt(menu);
+			switch (prop->type) {
+			case P_MENU:
+				child_count++;
+				cprint("m%p", menu);
+				if (menu->parent != &rootmenu)
+					cprint1("   %*c", indent + 1, ' ');
+				cprint1("%s  --->", prompt);
+				cprint_done();
+				return;
+			default:
+				if (prompt) {
+					child_count++;
+					cprint(":%p", menu);
+					cprint("---%*c%s", indent + 1, ' ', prompt);
+				}
+			}
+		} else
+			doint = 0;
+		goto conf_childs;
+	}
+
+	type = sym_get_type(sym);
+	if (sym_is_choice(sym)) {
+		struct symbol *def_sym = sym_get_choice_value(sym);
+		struct menu *def_menu = NULL;
+
+		child_count++;
+		for (child = menu->list; child; child = child->next) {
+			if (menu_is_visible(child) && child->sym == def_sym)
+				def_menu = child;
+		}
+
+		val = sym_get_tristate_value(sym);
+		if (sym_is_changable(sym)) {
+			cprint("t%p", menu);
+			switch (type) {
+			case S_BOOLEAN:
+				cprint1("[%c]", val == no ? ' ' : '*');
+				break;
+			case S_TRISTATE:
+				switch (val) {
+				case yes: ch = '*'; break;
+				case mod: ch = 'M'; break;
+				default:  ch = ' '; break;
+				}
+				cprint1("<%c>", ch);
+				break;
+			}
+		} else {
+			cprint("%c%p", def_menu ? 't' : ':', menu);
+			cprint1("   ");
+		}
+
+		cprint1("%*c%s", indent + 1, ' ', menu_get_prompt(menu));
+		if (val == yes) {
+			if (def_menu) {
+				cprint1(" (%s)", menu_get_prompt(def_menu));
+				cprint1("  --->");
+				cprint_done();
+				if (def_menu->list) {
+					indent += 2;
+					build_conf(def_menu);
+					indent -= 2;
+				}
+			} else
+				cprint_done();
+			return;
+		}
+		cprint_done();
+	} else {
+		child_count++;
+		val = sym_get_tristate_value(sym);
+		if (sym_is_choice_value(sym) && val == yes) {
+			cprint(":%p", menu);
+			cprint1("   ");
+		} else {
+			switch (type) {
+			case S_BOOLEAN:
+				cprint("t%p", menu);
+				cprint1("[%c]", val == no ? ' ' : '*');
+				break;
+			case S_TRISTATE:
+				cprint("t%p", menu);
+				switch (val) {
+				case yes: ch = '*'; break;
+				case mod: ch = 'M'; break;
+				default:  ch = ' '; break;
+				}
+				cprint1("<%c>", ch);
+				break;
+			default:
+				cprint("s%p", menu);
+				tmp = cprint1("(%s)", sym_get_string_value(sym));
+				tmp = indent - tmp + 4;
+				if (tmp < 0)
+					tmp = 0;
+				cprint1("%*c%s%s", tmp, ' ', menu_get_prompt(menu),
+					sym_has_value(sym) ? "" : " (NEW)");
+				cprint_done();
+				goto conf_childs;
+			}
+		}
+		cprint1("%*c%s%s", indent + 1, ' ', menu_get_prompt(menu),
+			sym_has_value(sym) ? "" : " (NEW)");
+		cprint_done();
+	}
+
+conf_childs:
+	indent += doint;
+	for (child = menu->list; child; child = child->next)
+		build_conf(child);
+	indent -= doint;
+}
+
+static void conf(struct menu *menu)
+{
+	struct menu *submenu;
+	const char *prompt = menu_get_prompt(menu);
+	struct symbol *sym;
+	char active_entry[40];
+	int stat, type, i;
+
+	active_entry[0] = 0;
+	while (1) {
+		cprint_init();
+		cprint("--title");
+		cprint("%s", prompt ? prompt : "Main Menu");
+		cprint("--menu");
+		cprint(menu_instructions);
+		cprint("%d", rows);
+		cprint("%d", cols);
+		cprint("%d", rows - 10);
+		cprint("%s", active_entry);
+		current_menu = menu;
+		build_conf(menu);
+		if (!child_count)
+			break;
+		if (menu == &rootmenu) {
+			cprint(":");
+			cprint("--- ");
+			cprint("L");
+			cprint("Load an Alternate Configuration File");
+			cprint("S");
+			cprint("Save Configuration to an Alternate File");
+		}
+		stat = exec_conf();
+		if (stat < 0)
+			continue;
+
+		if (stat == 1 || stat == 255)
+			break;
+
+		type = input_buf[0];
+		if (!type)
+			continue;
+
+		for (i = 0; input_buf[i] && !isspace(input_buf[i]); i++)
+			;
+		if (i >= sizeof(active_entry))
+			i = sizeof(active_entry) - 1;
+		input_buf[i] = 0;
+		strcpy(active_entry, input_buf);
+
+		sym = NULL;
+		submenu = NULL;
+		if (sscanf(input_buf + 1, "%p", &submenu) == 1)
+			sym = submenu->sym;
+
+		switch (stat) {
+		case 0:
+			switch (type) {
+			case 'm':
+				conf(submenu);
+				break;
+			case 't':
+				if (sym_is_choice(sym) && sym_get_tristate_value(sym) == yes)
+					conf_choice(submenu);
+				break;
+			case 's':
+				conf_string(submenu);
+				break;
+			case 'L':
+				conf_load();
+				break;
+			case 'S':
+				conf_save();
+				break;
+			}
+			break;
+		case 2:
+			if (sym)
+				show_help(submenu);
+			else
+				show_readme();
+			break;
+		case 3:
+			if (type == 't') {
+				if (sym_set_tristate_value(sym, yes))
+					break;
+				if (sym_set_tristate_value(sym, mod))
+					show_textbox(NULL, setmod_text, 6, 74);
+			}
+			break;
+		case 4:
+			if (type == 't')
+				sym_set_tristate_value(sym, no);
+			break;
+		case 5:
+			if (type == 't')
+				sym_set_tristate_value(sym, mod);
+			break;
+		case 6:
+			if (type == 't')
+				sym_toggle_tristate_value(sym);
+			break;
+		}
+	}
+}
+
+static void show_textbox(const char *title, const char *text, int r, int c)
+{
+	int fd;
+
+	fd = creat(".help.tmp", 0777);
+	write(fd, text, strlen(text));
+	close(fd);
+	do {
+		cprint_init();
+		if (title) {
+			cprint("--title");
+			cprint("%s", title);
+		}
+		cprint("--textbox");
+		cprint(".help.tmp");
+		cprint("%d", r);
+		cprint("%d", c);
+	} while (exec_conf() < 0);
+	unlink(".help.tmp");
+}
+
+static void show_helptext(const char *title, const char *text)
+{
+	show_textbox(title, text, rows, cols);
+}
+
+static void show_help(struct menu *menu)
+{
+	const char *help;
+
+	help = menu->sym->help;
+	if (!help)
+		help = nohelp_text;
+	show_helptext(menu_get_prompt(menu), help);
+}
+
+static void show_readme(void)
+{
+	do {
+		cprint_init();
+		cprint("--textbox");
+		cprint("scripts/README.Menuconfig");
+		cprint("%d", rows);
+		cprint("%d", cols);
+	} while (exec_conf() == -1);
+}
+
+static void conf_choice(struct menu *menu)
+{
+	const char *prompt = menu_get_prompt(menu);
+	struct menu *child;
+	struct symbol *active;
+	int stat;
+
+	while (1) {
+		cprint_init();
+		cprint("--title");
+		cprint("%s", prompt ? prompt : "Main Menu");
+		cprint("--radiolist");
+		cprint(radiolist_instructions);
+		cprint("15");
+		cprint("70");
+		cprint("6");
+
+		current_menu = menu;
+		active = sym_get_choice_value(menu->sym);
+		for (child = menu->list; child; child = child->next) {
+			if (!menu_is_visible(child))
+				continue;
+			cprint("%p", child);
+			cprint("%s", menu_get_prompt(child));
+			cprint(child->sym == active ? "ON" : "OFF");
+		}
+
+		stat = exec_conf();
+		switch (stat) {
+		case 0:
+			if (sscanf(input_buf, "%p", &menu) != 1)
+				break;
+			sym_set_tristate_value(menu->sym, yes);
+			return;
+		case 1:
+			show_help(menu);
+			break;
+		case 255:
+			return;
+		}
+	}
+}
+
+static void conf_string(struct menu *menu)
+{
+	const char *prompt = menu_get_prompt(menu);
+	int stat;
+
+	while (1) {
+		cprint_init();
+		cprint("--title");
+		cprint("%s", prompt ? prompt : "Main Menu");
+		cprint("--inputbox");
+		switch (sym_get_type(menu->sym)) {
+		case S_INT:
+			cprint(inputbox_instructions_int);
+			break;
+		case S_HEX:
+			cprint(inputbox_instructions_hex);
+			break;
+		case S_STRING:
+			cprint(inputbox_instructions_string);
+			break;
+		default:
+			/* panic? */;
+		}
+		cprint("10");
+		cprint("75");
+		cprint("%s", sym_get_string_value(menu->sym));
+		stat = exec_conf();
+		switch (stat) {
+		case 0:
+			if (sym_set_string_value(menu->sym, input_buf))
+				return;
+			show_textbox(NULL, "You have made an invalid entry.", 5, 43);
+			break;
+		case 1:
+			show_help(menu);
+			break;
+		case 255:
+			return;
+		}
+	}
+}
+
+static void conf_load(void)
+{
+	int stat;
+
+	while (1) {
+		cprint_init();
+		cprint("--inputbox");
+		cprint(load_config_text);
+		cprint("11");
+		cprint("55");
+		cprint("%s", conf_filename);
+		stat = exec_conf();
+		switch(stat) {
+		case 0:
+			if (!input_buf[0])
+				return;
+			if (!conf_read(input_buf))
+				return;
+			show_textbox(NULL, "File does not exist!", 5, 38);
+			break;
+		case 1:
+			show_helptext("Load Alternate Configuration", load_config_help);
+			break;
+		case 255:
+			return;
+		}
+	}
+}
+
+static void conf_save(void)
+{
+	int stat;
+
+	while (1) {
+		cprint_init();
+		cprint("--inputbox");
+		cprint(save_config_text);
+		cprint("11");
+		cprint("55");
+		cprint("%s", conf_filename);
+		stat = exec_conf();
+		switch(stat) {
+		case 0:
+			if (!input_buf[0])
+				return;
+			if (!conf_write(input_buf))
+				return;
+			show_textbox(NULL, "Can't create file!  Probably a nonexistent directory.", 5, 60);
+			break;
+		case 1:
+			show_helptext("Save Alternate Configuration", save_config_help);
+			break;
+		case 255:
+			return;
+		}
+	}
+}
+
+int main(int ac, char **av)
+{
+	int stat;
+	conf_parse(av[1]);
+	conf_read(NULL);
+
+	sprintf(menu_backtitle, "uClibc v%s Configuration", getenv("VERSION"));
+
+	init_wsize();
+	conf(&rootmenu);
+
+	do {
+		cprint_init();
+		cprint("--yesno");
+		cprint("Do you wish to save your new uClibc configuration?");
+		cprint("5");
+		cprint("60");
+		stat = exec_conf();
+	} while (stat < 0);
+
+	if (stat == 0) {
+		conf_write(NULL);
+		printf("\n\n"
+			"*** End of uClibc configuration.\n"
+			"*** Check the top-level Makefile for additional configuration options.\n\n");
+	} else
+		printf("\n\nYour uClibc configuration changes were NOT saved.\n\n");
+
+	return 0;
+}
diff --git a/extra/config/menu.c b/extra/config/menu.c
new file mode 100644
index 000000000..1beec1687
--- /dev/null
+++ b/extra/config/menu.c
@@ -0,0 +1,309 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+struct menu rootmenu;
+struct menu *current_menu, *current_entry;
+static struct menu **last_entry_ptr;
+
+struct file *file_list;
+struct file *current_file;
+
+void menu_init(void)
+{
+	current_entry = current_menu = &rootmenu;
+	last_entry_ptr = &rootmenu.list;
+}
+
+void menu_add_entry(struct symbol *sym)
+{
+	struct menu *menu;
+
+	menu = malloc(sizeof(*menu));
+	memset(menu, 0, sizeof(*menu));
+	menu->sym = sym;
+	menu->parent = current_menu;
+	menu->file = current_file;
+	menu->lineno = zconf_lineno();
+
+	*last_entry_ptr = menu;
+	last_entry_ptr = &menu->next;
+	current_entry = menu;
+}
+
+void menu_end_entry(void)
+{
+}
+
+void menu_add_menu(void)
+{
+	current_menu = current_entry;
+	last_entry_ptr = &current_entry->list;
+}
+
+void menu_end_menu(void)
+{
+	last_entry_ptr = &current_menu->next;
+	current_menu = current_menu->parent;
+}
+
+void menu_add_dep(struct expr *dep)
+{
+	current_entry->dep = expr_alloc_and(current_entry->dep, dep);
+}
+
+void menu_set_type(int type)
+{
+	struct symbol *sym = current_entry->sym;
+
+	if (sym->type == type)
+		return;
+	if (sym->type == S_UNKNOWN) {
+		sym->type = type;
+		return;
+	}
+	fprintf(stderr, "%s:%d: type of '%s' redefined from '%s' to '%s'\n",
+		current_entry->file->name, current_entry->lineno,
+		sym->name ? sym->name : "<choice>", sym_type_name(sym->type), sym_type_name(type));
+}
+
+struct property *create_prop(enum prop_type type)
+{
+	struct property *prop;
+
+	prop = malloc(sizeof(*prop));
+	memset(prop, 0, sizeof(*prop));
+	prop->type = type;
+	prop->file = current_file;
+	prop->lineno = zconf_lineno();
+
+	return prop;
+}
+
+struct property *menu_add_prop(int token, char *prompt, struct symbol *def, struct expr *dep)
+{
+	struct property *prop = create_prop(token);
+	struct property **propp;
+
+	prop->sym = current_entry->sym;
+	prop->menu = current_entry;
+	prop->text = prompt;
+	prop->def = def;
+	E_EXPR(prop->visible) = dep;
+
+	if (prompt)
+		current_entry->prompt = prop;
+
+	/* append property to the prop list of symbol */
+	if (prop->sym) {
+		for (propp = &prop->sym->prop; *propp; propp = &(*propp)->next)
+			;
+		*propp = prop;
+	}
+
+	return prop;
+}
+
+void menu_add_prompt(int token, char *prompt, struct expr *dep)
+{
+	current_entry->prompt = menu_add_prop(token, prompt, NULL, dep);
+}
+
+void menu_add_default(int token, struct symbol *def, struct expr *dep)
+{
+	current_entry->prompt = menu_add_prop(token, NULL, def, dep);
+}
+
+void menu_finalize(struct menu *parent)
+{
+	struct menu *menu, *last_menu;
+	struct symbol *sym;
+	struct property *prop;
+	struct expr *parentdep, *basedep, *dep, *dep2;
+
+	sym = parent->sym;
+	if (parent->list) {
+		if (sym && sym_is_choice(sym)) {
+			/* find the first choice value and find out choice type */
+			for (menu = parent->list; menu; menu = menu->next) {
+				if (menu->sym) {
+					current_entry = parent;
+					menu_set_type(menu->sym->type);
+					current_entry = menu;
+					menu_set_type(sym->type);
+					break;
+				}
+			}
+			parentdep = expr_alloc_symbol(sym);
+		} else if (parent->prompt)
+			parentdep = E_EXPR(parent->prompt->visible);
+		else
+			parentdep = parent->dep;
+
+		for (menu = parent->list; menu; menu = menu->next) {
+			basedep = expr_transform(menu->dep);
+			basedep = expr_alloc_and(expr_copy(parentdep), basedep);
+			basedep = expr_eliminate_dups(basedep);
+			menu->dep = basedep;
+			if (menu->sym)
+				prop = menu->sym->prop;
+			else
+				prop = menu->prompt;
+			for (; prop; prop = prop->next) {
+				if (prop->menu != menu)
+					continue;
+				dep = expr_transform(E_EXPR(prop->visible));
+				dep = expr_alloc_and(expr_copy(basedep), dep);
+				dep = expr_eliminate_dups(dep);
+				if (menu->sym && menu->sym->type != S_TRISTATE)
+					dep = expr_trans_bool(dep);
+				E_EXPR(prop->visible) = dep;
+			}
+		}
+		for (menu = parent->list; menu; menu = menu->next)
+			menu_finalize(menu);
+	} else if (sym && parent->prompt) {
+		basedep = E_EXPR(parent->prompt->visible);
+		basedep = expr_trans_compare(basedep, E_UNEQUAL, &symbol_no);
+		basedep = expr_eliminate_dups(expr_transform(basedep));
+		last_menu = NULL;
+		for (menu = parent->next; menu; menu = menu->next) {
+			dep = menu->prompt ? E_EXPR(menu->prompt->visible) : menu->dep;
+			if (!expr_contains_symbol(dep, sym))
+				break;
+			if (expr_depends_symbol(dep, sym))
+				goto next;
+			dep = expr_trans_compare(dep, E_UNEQUAL, &symbol_no);
+			dep = expr_eliminate_dups(expr_transform(dep));
+			dep2 = expr_copy(basedep);
+			expr_eliminate_eq(&dep, &dep2);
+			expr_free(dep);
+			if (!expr_is_yes(dep2)) {
+				expr_free(dep2);
+				break;
+			}
+			expr_free(dep2);
+		next:
+			menu_finalize(menu);
+			menu->parent = parent;
+			last_menu = menu;
+		}
+		if (last_menu) {
+			parent->list = parent->next;
+			parent->next = last_menu->next;
+			last_menu->next = NULL;
+		}
+	}
+	for (menu = parent->list; menu; menu = menu->next) {
+		if (sym && sym_is_choice(sym) && menu->sym) {
+			menu->sym->flags |= SYMBOL_CHOICEVAL;
+			current_entry = menu;
+			menu_set_type(sym->type);
+			menu_add_prop(P_CHOICE, NULL, parent->sym, NULL);
+			prop = sym_get_choice_prop(parent->sym);
+			//dep = expr_alloc_one(E_CHOICE, dep);
+			//dep->right.sym = menu->sym;
+			prop->dep = expr_alloc_one(E_CHOICE, prop->dep);
+			prop->dep->right.sym = menu->sym;
+		}
+		if (menu->list && (!menu->prompt || !menu->prompt->text)) {
+			for (last_menu = menu->list; ; last_menu = last_menu->next) {
+				last_menu->parent = parent;
+				if (!last_menu->next)
+					break;
+			}
+			last_menu->next = menu->next;
+			menu->next = menu->list;
+			menu->list = NULL;
+		}
+	}
+}
+
+bool menu_is_visible(struct menu *menu)
+{
+	tristate visible;
+
+	if (!menu->prompt)
+		return false;
+	if (menu->sym) {
+		sym_calc_value(menu->sym);
+		visible = E_TRI(menu->prompt->visible);
+	} else
+		visible = E_CALC(menu->prompt->visible);
+	return visible != no;
+}
+
+const char *menu_get_prompt(struct menu *menu)
+{
+	if (menu->prompt)
+		return menu->prompt->text;
+	else if (menu->sym)
+		return menu->sym->name;
+	return NULL;
+}
+
+struct menu *menu_get_root_menu(struct menu *menu)
+{
+	return &rootmenu;
+}
+
+struct menu *menu_get_parent_menu(struct menu *menu)
+{
+	enum prop_type type;
+
+	while (menu != &rootmenu) {
+		menu = menu->parent;
+		type = menu->prompt ? menu->prompt->type : 0;
+		if (type == P_MENU || type == P_ROOTMENU)
+			break;
+	}
+	return menu;
+}
+
+struct file *file_lookup(const char *name)
+{
+	struct file *file;
+
+	for (file = file_list; file; file = file->next) {
+		if (!strcmp(name, file->name))
+			return file;
+	}
+
+	file = malloc(sizeof(*file));
+	memset(file, 0, sizeof(*file));
+	file->name = strdup(name);
+	file->next = file_list;
+	file_list = file;
+	return file;
+}
+
+int file_write_dep(const char *name)
+{
+	struct file *file;
+	FILE *out;
+
+	if (!name)
+		name = ".config.cmd";
+	out = fopen(".config.tmp", "w");
+	if (!out)
+		return 1;
+	fprintf(out, "deps_config := \\\n");
+	for (file = file_list; file; file = file->next) {
+		if (file->next)
+			fprintf(out, "\t%s \\\n", file->name);
+		else
+			fprintf(out, "\t%s\n", file->name);
+	}
+	fprintf(out, "\n.config include/bits/uClibc_config.h: $(deps_config)\n\n$(deps_config):\n");
+	fclose(out);
+	rename(".config.tmp", name);
+	return 0;
+}
+
diff --git a/extra/config/symbol.c b/extra/config/symbol.c
new file mode 100644
index 000000000..59c88d253
--- /dev/null
+++ b/extra/config/symbol.c
@@ -0,0 +1,618 @@
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/utsname.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+struct symbol symbol_yes = {
+	name: "y",
+	curr: { "y", yes },
+	flags: SYMBOL_YES|SYMBOL_VALID,
+}, symbol_mod = {
+	name: "m",
+	curr: { "m", mod },
+	flags: SYMBOL_MOD|SYMBOL_VALID,
+}, symbol_no = {
+	name: "n",
+	curr: { "n", no },
+	flags: SYMBOL_NO|SYMBOL_VALID,
+}, symbol_empty = {
+	name: "",
+	curr: { "", no },
+	flags: SYMBOL_VALID,
+};
+
+int sym_change_count;
+struct symbol *modules_sym;
+
+void sym_add_default(struct symbol *sym, const char *def)
+{
+	struct property *prop = create_prop(P_DEFAULT);
+	struct property **propp;
+
+	prop->sym = sym;
+	prop->def = sym_lookup(def, 1);
+
+	/* append property to the prop list of symbol */
+	if (prop->sym) {
+		for (propp = &prop->sym->prop; *propp; propp = &(*propp)->next)
+			;
+		*propp = prop;
+	}
+}
+
+void sym_init(void)
+{
+	struct symbol *sym;
+	struct utsname uts;
+	char *p;
+	static bool inited = false;
+
+	if (inited)
+		return;
+	inited = true;
+
+	uname(&uts);
+
+	sym = sym_lookup("ARCH", 0);
+	sym->type = S_STRING;
+	sym->flags |= SYMBOL_AUTO;
+	p = getenv("ARCH");
+	if (p)
+		sym_add_default(sym, p);
+
+	sym = sym_lookup("KERNELRELEASE", 0);
+	sym->type = S_STRING;
+	sym->flags |= SYMBOL_AUTO;
+	p = getenv("KERNELRELEASE");
+	if (p)
+		sym_add_default(sym, p);
+
+	sym = sym_lookup("UNAME_RELEASE", 0);
+	sym->type = S_STRING;
+	sym->flags |= SYMBOL_AUTO;
+	sym_add_default(sym, uts.release);
+}
+
+int sym_get_type(struct symbol *sym)
+{
+	int type = sym->type;
+	if (type == S_TRISTATE) {
+		if (sym_is_choice_value(sym) && sym->visible == yes)
+			type = S_BOOLEAN;
+		else {
+			sym_calc_value(modules_sym);
+			if (S_TRI(modules_sym->curr) == no)
+				type = S_BOOLEAN;
+		}
+	}
+	return type;
+}
+
+const char *sym_type_name(int type)
+{
+	switch (type) {
+	case S_BOOLEAN:
+		return "boolean";
+	case S_TRISTATE:
+		return "tristate";
+	case S_INT:
+		return "integer";
+	case S_HEX:
+		return "hex";
+	case S_STRING:
+		return "string";
+	case S_UNKNOWN:
+		return "unknown";
+	}
+	return "???";
+}
+
+struct property *sym_get_choice_prop(struct symbol *sym)
+{
+	struct property *prop;
+
+	for_all_choices(sym, prop)
+		return prop;
+	return NULL;
+}
+
+struct property *sym_get_default_prop(struct symbol *sym)
+{
+	struct property *prop;
+	tristate visible;
+
+	for_all_defaults(sym, prop) {
+		visible = E_CALC(prop->visible);
+		if (visible != no)
+			return prop;
+	}
+	return NULL;
+}
+
+void sym_calc_visibility(struct symbol *sym)
+{
+	struct property *prop;
+	tristate visible, oldvisible;
+
+	/* any prompt visible? */
+	oldvisible = sym->visible;
+	visible = no;
+	for_all_prompts(sym, prop)
+		visible = E_OR(visible, E_CALC(prop->visible));
+	if (oldvisible != visible) {
+		sym->visible = visible;
+		sym->flags |= SYMBOL_CHANGED;
+	}
+}
+
+void sym_calc_value(struct symbol *sym)
+{
+	struct symbol_value newval, oldval;
+	struct property *prop, *def_prop;
+	struct symbol *def_sym;
+	struct expr *e;
+
+	if (sym->flags & SYMBOL_VALID)
+		return;
+
+	oldval = sym->curr;
+
+	switch (sym->type) {
+	case S_INT:
+	case S_HEX:
+	case S_STRING:
+		newval = symbol_empty.curr;
+		break;
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		newval = symbol_no.curr;
+		break;
+	default:
+		S_VAL(newval) = sym->name;
+		S_TRI(newval) = no;
+		if (sym->flags & SYMBOL_CONST) {
+			goto out;
+		}
+		//newval = symbol_empty.curr;
+		// generate warning somewhere here later
+		//S_TRI(newval) = yes;
+		goto out;
+	}
+	sym->flags |= SYMBOL_VALID;
+	if (!sym_is_choice_value(sym))
+		sym->flags &= ~SYMBOL_WRITE;
+
+	sym_calc_visibility(sym);
+
+	/* set default if recursively called */
+	sym->curr = newval;
+
+	if (sym->visible != no) {
+		sym->flags |= SYMBOL_WRITE;
+		if (!sym_has_value(sym)) {
+			if (!sym_is_choice(sym)) {
+				prop = sym_get_default_prop(sym);
+				if (prop) {
+					sym_calc_value(prop->def);
+					newval = prop->def->curr;
+				}
+			}
+		} else
+			newval = sym->def;
+
+		S_TRI(newval) = E_AND(S_TRI(newval), sym->visible);
+		/* if the symbol is visible and not optionial,
+		 * possibly ignore old user choice. */
+		if (!sym_is_optional(sym) && S_TRI(newval) == no)
+			S_TRI(newval) = sym->visible;
+		if (sym_is_choice_value(sym) && sym->visible == yes) {
+			prop = sym_get_choice_prop(sym);
+			S_TRI(newval) = (S_VAL(prop->def->curr) == sym) ? yes : no;
+		}
+	} else {
+		prop = sym_get_default_prop(sym);
+		if (prop) {
+			sym->flags |= SYMBOL_WRITE;
+			sym_calc_value(prop->def);
+			newval = prop->def->curr;
+		}
+	}
+
+	switch (sym_get_type(sym)) {
+	case S_TRISTATE:
+		if (S_TRI(newval) != mod)
+			break;
+		sym_calc_value(modules_sym);
+		if (S_TRI(modules_sym->curr) == no)
+			S_TRI(newval) = yes;
+		break;
+	case S_BOOLEAN:
+		if (S_TRI(newval) == mod)
+			S_TRI(newval) = yes;
+	}
+
+out:
+	sym->curr = newval;
+
+	if (sym_is_choice(sym) && S_TRI(newval) == yes) {
+		def_sym = S_VAL(sym->def);
+		if (def_sym) {
+			sym_calc_visibility(def_sym);
+			if (def_sym->visible == no)
+				def_sym = NULL;
+		}
+		if (!def_sym) {
+			for_all_defaults(sym, def_prop) {
+				if (E_CALC(def_prop->visible) == no)
+					continue;
+				sym_calc_visibility(def_prop->def);
+				if (def_prop->def->visible != no) {
+					def_sym = def_prop->def;
+					break;
+				}
+			}
+		}
+
+		if (!def_sym) {
+			prop = sym_get_choice_prop(sym);
+			for (e = prop->dep; e; e = e->left.expr) {
+				sym_calc_visibility(e->right.sym);
+				if (e->right.sym->visible != no) {
+					def_sym = e->right.sym;
+					break;
+				}
+			}
+		}
+
+		S_VAL(newval) = def_sym;
+	}
+
+	if (memcmp(&oldval, &newval, sizeof(newval)))
+		sym->flags |= SYMBOL_CHANGED;
+	sym->curr = newval;
+
+	if (sym_is_choice(sym)) {
+		int flags = sym->flags & (SYMBOL_CHANGED | SYMBOL_WRITE);
+		prop = sym_get_choice_prop(sym);
+		for (e = prop->dep; e; e = e->left.expr)
+			e->right.sym->flags |= flags;
+	}
+}
+
+void sym_clear_all_valid(void)
+{
+	struct symbol *sym;
+	int i;
+
+	for_all_symbols(i, sym)
+		sym->flags &= ~SYMBOL_VALID;
+	sym_change_count++;
+}
+
+void sym_set_all_changed(void)
+{
+	struct symbol *sym;
+	int i;
+
+	for_all_symbols(i, sym)
+		sym->flags |= SYMBOL_CHANGED;
+}
+
+bool sym_tristate_within_range(struct symbol *sym, tristate val)
+{
+	int type = sym_get_type(sym);
+
+	if (sym->visible == no)
+		return false;
+
+	if (type != S_BOOLEAN && type != S_TRISTATE)
+		return false;
+
+	switch (val) {
+	case no:
+		if (sym_is_choice_value(sym) && sym->visible == yes)
+			return false;
+		return sym_is_optional(sym);
+	case mod:
+		if (sym_is_choice_value(sym) && sym->visible == yes)
+			return false;
+		return type == S_TRISTATE;
+	case yes:
+		return type == S_BOOLEAN || sym->visible == yes;
+	}
+	return false;
+}
+
+bool sym_set_tristate_value(struct symbol *sym, tristate val)
+{
+	tristate oldval = sym_get_tristate_value(sym);
+
+	if (oldval != val && !sym_tristate_within_range(sym, val))
+		return false;
+
+	if (sym->flags & SYMBOL_NEW) {
+		sym->flags &= ~SYMBOL_NEW;
+		sym->flags |= SYMBOL_CHANGED;
+	}
+	if (sym_is_choice_value(sym) && val == yes) {
+		struct property *prop = sym_get_choice_prop(sym);
+
+		S_VAL(prop->def->def) = sym;
+		prop->def->flags &= ~SYMBOL_NEW;
+	}
+
+	S_TRI(sym->def) = val;
+	if (oldval != val) {
+		sym_clear_all_valid();
+		if (sym == modules_sym)
+			sym_set_all_changed();
+	}
+
+	return true;
+}
+
+tristate sym_toggle_tristate_value(struct symbol *sym)
+{
+	tristate oldval, newval;
+
+	oldval = newval = sym_get_tristate_value(sym);
+	do {
+		switch (newval) {
+		case no:
+			newval = mod;
+			break;
+		case mod:
+			newval = yes;
+			break;
+		case yes:
+			newval = no;
+			break;
+		}
+		if (sym_set_tristate_value(sym, newval))
+			break;
+	} while (oldval != newval);
+	return newval;
+}
+
+bool sym_string_valid(struct symbol *sym, const char *str)
+{
+	char ch;
+
+	switch (sym->type) {
+	case S_STRING:
+		return true;
+	case S_INT:
+		ch = *str++;
+		if (ch == '-')
+			ch = *str++;
+		if (!isdigit(ch))
+			return false;
+		if (ch == '0' && *str != 0)
+			return false;
+		while ((ch = *str++)) {
+			if (!isdigit(ch))
+				return false;
+		}
+		return true;
+	case S_HEX:
+		if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))
+			str += 2;
+		ch = *str++;
+		do {
+			if (!isxdigit(ch))
+				return false;
+		} while ((ch = *str++));
+		return true;
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		switch (str[0]) {
+		case 'y':
+		case 'Y':
+			return sym_tristate_within_range(sym, yes);
+		case 'm':
+		case 'M':
+			return sym_tristate_within_range(sym, mod);
+		case 'n':
+		case 'N':
+			return sym_tristate_within_range(sym, no);
+		}
+		return false;
+	default:
+		return false;
+	}
+}
+
+bool sym_set_string_value(struct symbol *sym, const char *newval)
+{
+	const char *oldval;
+	char *val;
+	int size;
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		switch (newval[0]) {
+		case 'y':
+		case 'Y':
+			return sym_set_tristate_value(sym, yes);
+		case 'm':
+		case 'M':
+			return sym_set_tristate_value(sym, mod);
+		case 'n':
+		case 'N':
+			return sym_set_tristate_value(sym, no);
+		}
+		return false;
+	default:
+		;
+	}
+
+	if (!sym_string_valid(sym, newval))
+		return false;
+
+	if (sym->flags & SYMBOL_NEW) {
+		sym->flags &= ~SYMBOL_NEW;
+		sym->flags |= SYMBOL_CHANGED;
+	}
+
+	oldval = S_VAL(sym->def);
+	size = strlen(newval) + 1;
+	if (sym->type == S_HEX && (newval[0] != '0' || (newval[1] != 'x' && newval[1] != 'X'))) {
+		size += 2;
+		S_VAL(sym->def) = val = malloc(size);
+		*val++ = '0';
+		*val++ = 'x';
+	} else if (!oldval || strcmp(oldval, newval))
+		S_VAL(sym->def) = val = malloc(size);
+	else
+		return true;
+
+	strcpy(val, newval);
+	free((void *)oldval);
+	sym_clear_all_valid();
+
+	return true;
+}
+
+const char *sym_get_string_value(struct symbol *sym)
+{
+	tristate val;
+
+	switch (sym->type) {
+	case S_BOOLEAN:
+	case S_TRISTATE:
+		val = sym_get_tristate_value(sym);
+		switch (val) {
+		case no:
+			return "n";
+		case mod:
+			return "m";
+		case yes:
+			return "y";
+		}
+		break;
+	default:
+		;
+	}
+	return (const char *)S_VAL(sym->curr);
+}
+
+bool sym_is_changable(struct symbol *sym)
+{
+	if (sym->visible == no)
+		return false;
+	/* at least 'n' and 'y'/'m' is selectable */
+	if (sym_is_optional(sym))
+		return true;
+	/* no 'n', so 'y' and 'm' must be selectable */
+	if (sym_get_type(sym) == S_TRISTATE && sym->visible == yes)
+		return true;
+	return false;
+}
+
+struct symbol *sym_lookup(const char *name, int isconst)
+{
+	struct symbol *symbol;
+	const char *ptr;
+	char *new_name;
+	int hash = 0;
+
+	//printf("lookup: %s -> ", name);
+	if (name) {
+		if (name[0] && !name[1]) {
+			switch (name[0]) {
+			case 'y': return &symbol_yes;
+			case 'm': return &symbol_mod;
+			case 'n': return &symbol_no;
+			}
+		}
+		for (ptr = name; *ptr; ptr++)
+			hash += *ptr;
+		hash &= 0xff;
+
+		for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
+			if (!strcmp(symbol->name, name)) {
+				if ((isconst && symbol->flags & SYMBOL_CONST) ||
+				    (!isconst && !(symbol->flags & SYMBOL_CONST))) {
+					//printf("h:%p\n", symbol);
+					return symbol;
+				}
+			}
+		}
+		new_name = strdup(name);
+	} else {
+		new_name = NULL;
+		hash = 256;
+	}
+
+	symbol = malloc(sizeof(*symbol));
+	memset(symbol, 0, sizeof(*symbol));
+	symbol->name = new_name;
+	symbol->type = S_UNKNOWN;
+	symbol->flags = SYMBOL_NEW;
+	if (isconst)
+		symbol->flags |= SYMBOL_CONST;
+
+	symbol->next = symbol_hash[hash];
+	symbol_hash[hash] = symbol;
+
+	//printf("n:%p\n", symbol);
+	return symbol;
+}
+
+struct symbol *sym_find(const char *name)
+{
+	struct symbol *symbol = NULL;
+	const char *ptr;
+	int hash = 0;
+
+	if (!name)
+		return NULL;
+
+	if (name[0] && !name[1]) {
+		switch (name[0]) {
+		case 'y': return &symbol_yes;
+		case 'm': return &symbol_mod;
+		case 'n': return &symbol_no;
+		}
+	}
+	for (ptr = name; *ptr; ptr++)
+		hash += *ptr;
+	hash &= 0xff;
+
+	for (symbol = symbol_hash[hash]; symbol; symbol = symbol->next) {
+		if (!strcmp(symbol->name, name) &&
+		    !(symbol->flags & SYMBOL_CONST))
+				break;
+	}
+
+	return symbol;
+}
+
+const char *prop_get_type_name(enum prop_type type)
+{
+	switch (type) {
+	case P_PROMPT:
+		return "prompt";
+	case P_COMMENT:
+		return "comment";
+	case P_MENU:
+		return "menu";
+	case P_ROOTMENU:
+		return "rootmenu";
+	case P_DEFAULT:
+		return "default";
+	case P_CHOICE:
+		return "choice";
+	default:
+		return "unknown";
+	}
+}
diff --git a/extra/config/zconf.l b/extra/config/zconf.l
new file mode 100644
index 000000000..6d81e5eb7
--- /dev/null
+++ b/extra/config/zconf.l
@@ -0,0 +1,323 @@
+%option backup nostdinit noyywrap full ecs
+%option 8bit backup nodefault perf-report perf-report
+%x COMMAND HELP STRING PARAM
+%{
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+#include "zconf.tab.h"
+
+#define START_STRSIZE	16
+
+char *text;
+static char *text_ptr;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static struct buffer *zconf_endfile(void);
+
+void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_ptr = text;
+	text_size = 0;
+	*text_ptr = 0;
+}
+
+void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		text = realloc(text, new_size);
+		text_asize = new_size;
+		text_ptr = text + text_size;
+	}
+	memcpy(text_ptr, str, size);
+	text_ptr += size;
+	text_size += size;
+	*text_ptr = 0;
+}
+
+void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+%}
+
+ws	[ \n\t]
+n	[A-Za-z0-9_]
+
+%%
+	int str = 0;
+	int ts, i;
+
+[ \t]*#.*\n	current_file->lineno++;
+[ \t]*#.*
+
+[ \t]*\n	current_file->lineno++; return T_EOL;
+
+[ \t]+	{
+	BEGIN(COMMAND);
+}
+
+.	{
+	unput(yytext[0]);
+	//printf("new config: ");
+	//symbol_end(NULL);
+	BEGIN(COMMAND);
+}
+
+
+<COMMAND>{
+	"mainmenu"		BEGIN(PARAM); return T_MAINMENU;
+	"menu"			BEGIN(PARAM); return T_MENU;
+	"endmenu"		BEGIN(PARAM); return T_ENDMENU;
+	"source"		BEGIN(PARAM); return T_SOURCE;
+	"choice"		BEGIN(PARAM); return T_CHOICE;
+	"endchoice"		BEGIN(PARAM); return T_ENDCHOICE;
+	"comment"		BEGIN(PARAM); return T_COMMENT;
+	"config"		BEGIN(PARAM); return T_CONFIG;
+	"help"			BEGIN(PARAM); return T_HELP;
+	"if"			BEGIN(PARAM); return T_IF;
+	"endif"			BEGIN(PARAM); return T_ENDIF;
+	"depends"		BEGIN(PARAM); return T_DEPENDS;
+	"requires"		BEGIN(PARAM); return T_REQUIRES;
+	"optional"		BEGIN(PARAM); return T_OPTIONAL;
+	"default"		BEGIN(PARAM); return T_DEFAULT;
+	"prompt"		BEGIN(PARAM); return T_PROMPT;
+	"tristate"		BEGIN(PARAM); return T_TRISTATE;
+	"bool"			BEGIN(PARAM); return T_BOOLEAN;
+	"boolean"		BEGIN(PARAM); return T_BOOLEAN;
+	"int"			BEGIN(PARAM); return T_INT;
+	"hex"			BEGIN(PARAM); return T_HEX;
+	"string"		BEGIN(PARAM); return T_STRING;
+	{n}+	{
+		alloc_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	.
+	\n	current_file->lineno++; BEGIN(INITIAL);
+}
+
+<PARAM>{
+	"&&"	return T_AND;
+	"||"	return T_OR;
+	"("	return T_OPEN_PAREN;
+	")"	return T_CLOSE_PAREN;
+	"!"	return T_NOT;
+	"="	return T_EQUAL;
+	"!="	return T_UNEQUAL;
+	"if"	return T_IF;
+	"on"	return T_ON;
+	\"|\'	{
+		str = yytext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	\n	BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	---	/* ignore */
+	({n}|[-/.])+	{
+		alloc_string(yytext, yyleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	.
+}
+
+<STRING>{
+	[^'"\n\\]+	{
+		append_string(yytext, yyleng);
+	}
+	\'|\"	{
+		if (str == yytext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			//printf("s:%s\n", text);
+			return T_STRING;
+		} else
+			append_string(yytext, 1);
+	}
+	\\[ \t]*\n	append_string(yytext+yyleng-1, 1); current_file->lineno++;
+	\\[ \t]*	append_string(yytext+1, yyleng-1);
+	\\.		append_string(yytext+1, 1);
+	\n	{
+		//printf(":%d: open string!\n", current_file->lineno+1);
+		exit(0);
+	}
+	<<EOF>>	{
+		//printf(":%d: open string!\n", current_file->lineno+1);
+		exit(0);
+	}
+}
+
+<HELP>{
+	[ \t]+	{
+		ts = 0;
+		for (i = 0; i < yyleng; i++) {
+			if (yytext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+		
+	}
+	\n/[^ \t\n] {
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	[ \t]*\n	{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	[^ \t\n].* {
+		append_string(yytext, yyleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	<<EOF>>	{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+}
+
+<<EOF>>	{
+	if (current_buf) {
+		zconf_endfile();
+		return T_EOF;
+	}
+	yyterminate();
+}
+
+%%
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL); 
+}
+
+void zconf_initscan(const char *name)
+{
+	yyin = fopen(name, "r");
+	if (!yyin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+	//fprintf(stderr, "zconf_initscan: %s\n", name);
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+	current_file->flags = FILE_BUSY;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	yyin = fopen(name, "r");
+	if (!yyin) {
+		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
+		exit(1);
+	}
+	yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	//fprintf(stderr, "zconf_nextfile: %s\n", name);
+
+	if (file->flags & FILE_BUSY) {
+		printf("recursive scan (%s)?\n", name);
+		exit(1);
+	}
+	if (file->flags & FILE_SCANNED) {
+		printf("file %s already scanned?\n", name);
+		exit(1);
+	}
+	file->flags |= FILE_BUSY;
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static struct buffer *zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file->flags |= FILE_SCANNED;
+	current_file->flags &= ~FILE_BUSY;
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		yy_delete_buffer(YY_CURRENT_BUFFER);
+		yy_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+
+	return parent;
+}
+
+int zconf_lineno(void)
+{
+	if (current_buf)
+		return current_file->lineno;
+	else
+		return 0;
+}
+
+char *zconf_curname(void)
+{
+	if (current_buf)
+		return current_file->name;
+	else
+		return "<none>";
+}
diff --git a/extra/config/zconf.tab.c b/extra/config/zconf.tab.c
new file mode 100644
index 000000000..da46314d8
--- /dev/null
+++ b/extra/config/zconf.tab.c
@@ -0,0 +1,1866 @@
+/* A Bison parser, made from zconf.y
+   by GNU bison 1.35.  */
+
+#define YYBISON 1  /* Identify Bison output.  */
+
+#define yyparse zconfparse
+#define yylex zconflex
+#define yyerror zconferror
+#define yylval zconflval
+#define yychar zconfchar
+#define yydebug zconfdebug
+#define yynerrs zconfnerrs
+# define	T_MAINMENU	257
+# define	T_MENU	258
+# define	T_ENDMENU	259
+# define	T_SOURCE	260
+# define	T_CHOICE	261
+# define	T_ENDCHOICE	262
+# define	T_COMMENT	263
+# define	T_CONFIG	264
+# define	T_HELP	265
+# define	T_HELPTEXT	266
+# define	T_IF	267
+# define	T_ENDIF	268
+# define	T_DEPENDS	269
+# define	T_REQUIRES	270
+# define	T_OPTIONAL	271
+# define	T_PROMPT	272
+# define	T_DEFAULT	273
+# define	T_TRISTATE	274
+# define	T_BOOLEAN	275
+# define	T_INT	276
+# define	T_HEX	277
+# define	T_WORD	278
+# define	T_STRING	279
+# define	T_UNEQUAL	280
+# define	T_EOF	281
+# define	T_EOL	282
+# define	T_CLOSE_PAREN	283
+# define	T_OPEN_PAREN	284
+# define	T_ON	285
+# define	T_OR	286
+# define	T_AND	287
+# define	T_EQUAL	288
+# define	T_NOT	289
+
+#line 1 "zconf.y"
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(int token, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[257];
+
+#define YYERROR_VERBOSE
+
+#line 32 "zconf.y"
+#ifndef YYSTYPE
+typedef union
+{
+	int token;
+	char *string;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+} yystype;
+# define YYSTYPE yystype
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+#line 83 "zconf.y"
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+
+
+#define	YYFINAL		145
+#define	YYFLAG		-32768
+#define	YYNTBASE	36
+
+/* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
+#define YYTRANSLATE(x) ((unsigned)(x) <= 289 ? yytranslate[x] : 74)
+
+/* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
+static const char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     3,     4,     5,
+       6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    35
+};
+
+#if YYDEBUG
+static const short yyprhs[] =
+{
+       0,     0,     1,     4,     6,     8,    10,    14,    16,    18,
+      20,    23,    25,    27,    29,    31,    33,    36,    40,    41,
+      45,    49,    52,    55,    58,    61,    64,    67,    70,    74,
+      78,    80,    84,    86,    91,    94,    95,    99,   103,   106,
+     109,   113,   115,   118,   119,   122,   125,   127,   133,   137,
+     138,   141,   144,   147,   150,   154,   156,   161,   164,   165,
+     168,   171,   174,   178,   181,   184,   187,   191,   194,   197,
+     198,   202,   205,   209,   212,   215,   216,   218,   222,   224,
+     226,   228,   230,   232,   234,   236,   237,   240,   242,   246,
+     250,   254,   257,   261,   265,   267
+};
+static const short yyrhs[] =
+{
+      -1,    36,    37,     0,    38,     0,    46,     0,    57,     0,
+       3,    68,    70,     0,     5,     0,    14,     0,     8,     0,
+       1,    70,     0,    52,     0,    62,     0,    40,     0,    60,
+       0,    70,     0,    10,    24,     0,    39,    28,    41,     0,
+       0,    41,    42,    28,     0,    41,    66,    28,     0,    41,
+      64,     0,    41,    28,     0,    20,    67,     0,    21,    67,
+       0,    22,    67,     0,    23,    67,     0,    25,    67,     0,
+      18,    68,    71,     0,    19,    73,    71,     0,     7,     0,
+      43,    28,    47,     0,    69,     0,    44,    49,    45,    28,
+       0,    44,    49,     0,     0,    47,    48,    28,     0,    47,
+      66,    28,     0,    47,    64,     0,    47,    28,     0,    18,
+      68,    71,     0,    17,     0,    19,    73,     0,     0,    49,
+      38,     0,    13,    72,     0,    69,     0,    50,    28,    53,
+      51,    28,     0,    50,    28,    53,     0,     0,    53,    38,
+       0,    53,    57,     0,    53,    46,     0,     4,    68,     0,
+      54,    28,    65,     0,    69,     0,    55,    58,    56,    28,
+       0,    55,    58,     0,     0,    58,    38,     0,    58,    57,
+       0,    58,    46,     0,    58,     1,    28,     0,     6,    68,
+       0,    59,    28,     0,     9,    68,     0,    61,    28,    65,
+       0,    11,    28,     0,    63,    12,     0,     0,    65,    66,
+      28,     0,    65,    28,     0,    15,    31,    72,     0,    15,
+      72,     0,    16,    72,     0,     0,    68,     0,    68,    13,
+      72,     0,    24,     0,    25,     0,     5,     0,     8,     0,
+      14,     0,    28,     0,    27,     0,     0,    13,    72,     0,
+      73,     0,    73,    34,    73,     0,    73,    26,    73,     0,
+      30,    72,    29,     0,    35,    72,     0,    72,    32,    72,
+       0,    72,    33,    72,     0,    24,     0,    25,     0
+};
+
+#endif
+
+#if YYDEBUG
+/* YYRLINE[YYN] -- source line where rule number YYN was defined. */
+static const short yyrline[] =
+{
+       0,    88,    89,    92,    93,    94,    95,    96,    97,    98,
+      99,   102,   104,   105,   106,   107,   113,   121,   127,   129,
+     130,   131,   132,   135,   141,   147,   153,   159,   165,   171,
+     179,   188,   194,   202,   204,   210,   212,   213,   214,   215,
+     218,   224,   230,   237,   239,   244,   254,   262,   264,   270,
+     272,   273,   274,   279,   286,   292,   300,   302,   308,   310,
+     311,   312,   313,   316,   322,   329,   336,   343,   349,   356,
+     357,   358,   361,   366,   371,   379,   381,   385,   390,   391,
+     394,   395,   396,   399,   400,   402,   403,   406,   407,   408,
+     409,   410,   411,   412,   415,   416
+};
+#endif
+
+
+#if (YYDEBUG) || defined YYERROR_VERBOSE
+
+/* YYTNAME[TOKEN_NUM] -- String name of the token TOKEN_NUM. */
+static const char *const yytname[] =
+{
+  "$", "error", "$undefined.", "T_MAINMENU", "T_MENU", "T_ENDMENU", 
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG", 
+  "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS", "T_REQUIRES", 
+  "T_OPTIONAL", "T_PROMPT", "T_DEFAULT", "T_TRISTATE", "T_BOOLEAN", 
+  "T_INT", "T_HEX", "T_WORD", "T_STRING", "T_UNEQUAL", "T_EOF", "T_EOL", 
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_ON", "T_OR", "T_AND", "T_EQUAL", 
+  "T_NOT", "input", "block", "common_block", "config_entry_start", 
+  "config_stmt", "config_option_list", "config_option", "choice", 
+  "choice_entry", "choice_end", "choice_stmt", "choice_option_list", 
+  "choice_option", "choice_block", "if", "if_end", "if_stmt", "if_block", 
+  "menu", "menu_entry", "menu_end", "menu_stmt", "menu_block", "source", 
+  "source_stmt", "comment", "comment_stmt", "help_start", "help", 
+  "depends_list", "depends", "prompt_stmt_opt", "prompt", "end", 
+  "nl_or_eof", "if_expr", "expr", "symbol", 0
+};
+#endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
+static const short yyr1[] =
+{
+       0,    36,    36,    37,    37,    37,    37,    37,    37,    37,
+      37,    38,    38,    38,    38,    38,    39,    40,    41,    41,
+      41,    41,    41,    42,    42,    42,    42,    42,    42,    42,
+      43,    44,    45,    46,    46,    47,    47,    47,    47,    47,
+      48,    48,    48,    49,    49,    50,    51,    52,    52,    53,
+      53,    53,    53,    54,    55,    56,    57,    57,    58,    58,
+      58,    58,    58,    59,    60,    61,    62,    63,    64,    65,
+      65,    65,    66,    66,    66,    67,    67,    67,    68,    68,
+      69,    69,    69,    70,    70,    71,    71,    72,    72,    72,
+      72,    72,    72,    72,    73,    73
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
+static const short yyr2[] =
+{
+       0,     0,     2,     1,     1,     1,     3,     1,     1,     1,
+       2,     1,     1,     1,     1,     1,     2,     3,     0,     3,
+       3,     2,     2,     2,     2,     2,     2,     2,     3,     3,
+       1,     3,     1,     4,     2,     0,     3,     3,     2,     2,
+       3,     1,     2,     0,     2,     2,     1,     5,     3,     0,
+       2,     2,     2,     2,     3,     1,     4,     2,     0,     2,
+       2,     2,     3,     2,     2,     2,     3,     2,     2,     0,
+       3,     2,     3,     2,     2,     0,     1,     3,     1,     1,
+       1,     1,     1,     1,     1,     0,     2,     1,     3,     3,
+       3,     2,     3,     3,     1,     1
+};
+
+/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
+   doesn't specify something else to do.  Zero means the default is an
+   error. */
+static const short yydefact[] =
+{
+       1,     0,     0,     0,     0,     7,     0,    30,     9,     0,
+       0,     0,     8,    84,    83,     2,     3,     0,    13,     0,
+      43,     4,     0,    11,     0,    58,     5,     0,    14,     0,
+      12,    15,    10,    78,    79,     0,    53,    63,    65,    16,
+      94,    95,     0,     0,    45,    87,    18,    35,    34,    49,
+      69,     0,    64,    69,     6,     0,    91,     0,     0,     0,
+       0,    17,    31,    80,    81,    82,    44,     0,    32,    48,
+      54,     0,    59,    61,     0,    60,    55,    66,    90,    92,
+      93,    89,    88,     0,     0,     0,     0,     0,    75,    75,
+      75,    75,    75,    22,     0,     0,    21,     0,    41,     0,
+       0,    39,     0,    38,     0,    33,    50,    52,     0,    51,
+      46,    71,     0,    62,    56,    67,     0,    73,    74,    85,
+      85,    23,    76,    24,    25,    26,    27,    19,    68,    20,
+      85,    42,    36,    37,    47,    70,    72,     0,    28,    29,
+       0,    40,    86,    77,     0,     0
+};
+
+static const short yydefgoto[] =
+{
+       1,    15,    16,    17,    18,    61,    94,    19,    20,    67,
+      21,    62,   102,    48,    22,   108,    23,    69,    24,    25,
+      74,    26,    51,    27,    28,    29,    30,    95,    96,    70,
+     112,   121,   122,    68,    31,   138,    44,    45
+};
+
+static const short yypact[] =
+{
+  -32768,    17,    41,    65,    65,-32768,    65,-32768,-32768,    65,
+     -11,    40,-32768,-32768,-32768,-32768,-32768,    13,-32768,    23,
+  -32768,-32768,    66,-32768,    72,-32768,-32768,    77,-32768,    81,
+  -32768,-32768,-32768,-32768,-32768,    41,-32768,-32768,-32768,-32768,
+  -32768,-32768,    40,    40,    64,    59,-32768,-32768,    98,-32768,
+  -32768,    49,-32768,-32768,-32768,     7,-32768,    40,    40,    67,
+      67,    99,   117,-32768,-32768,-32768,-32768,    85,-32768,    74,
+      18,    88,-32768,-32768,    95,-32768,-32768,    18,-32768,    96,
+  -32768,-32768,-32768,   102,    36,    40,    65,    67,    65,    65,
+      65,    65,    65,-32768,   103,   129,-32768,   114,-32768,    65,
+      67,-32768,   115,-32768,   116,-32768,-32768,-32768,   118,-32768,
+  -32768,-32768,   119,-32768,-32768,-32768,    40,    64,    64,   135,
+     135,-32768,   136,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
+     135,-32768,-32768,-32768,-32768,-32768,    64,    40,-32768,-32768,
+      40,-32768,    64,    64,   150,-32768
+};
+
+static const short yypgoto[] =
+{
+  -32768,-32768,   -37,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
+     -41,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
+  -32768,   -32,-32768,-32768,-32768,-32768,-32768,-32768,    89,   100,
+      11,    48,     0,   -22,     3,  -118,   -42,   -52
+};
+
+
+#define	YYLAST		153
+
+
+static const short yytable[] =
+{
+      55,    56,   139,    35,    36,    32,    37,    81,    82,    38,
+      73,    66,   141,    39,    72,    79,    80,   144,     2,    75,
+       3,     4,     5,     6,     7,     8,     9,    10,   107,    76,
+      11,    12,   106,    84,    85,   120,    78,   109,    54,    57,
+      58,    46,   117,   118,    13,    14,   111,   110,   131,   -57,
+      71,    47,   -57,     4,    63,     6,     7,    64,     9,    10,
+      40,    41,    11,    65,    40,    41,    42,   116,    13,    14,
+      42,    43,    97,   104,   136,    43,    13,    14,     4,    63,
+       6,     7,    64,     9,    10,    59,   119,    11,    65,    33,
+      34,    40,    41,    60,    49,   142,    57,    58,   143,   130,
+      50,    13,    14,    63,     6,    52,    64,     9,    10,    53,
+      83,    11,    65,   105,    84,    85,   113,    86,    87,    88,
+      89,    90,    91,   114,    92,    13,    14,    93,    83,    58,
+     115,   127,    84,    85,    98,    99,   100,   123,   124,   125,
+     126,   128,   129,   132,   133,   101,   134,   135,   137,   140,
+     145,   103,     0,    77
+};
+
+static const short yycheck[] =
+{
+      42,    43,   120,     3,     4,     2,     6,    59,    60,     9,
+      51,    48,   130,    24,    51,    57,    58,     0,     1,    51,
+       3,     4,     5,     6,     7,     8,     9,    10,    69,    51,
+      13,    14,    69,    15,    16,    87,    29,    69,    35,    32,
+      33,    28,    84,    85,    27,    28,    28,    69,   100,     0,
+       1,    28,     3,     4,     5,     6,     7,     8,     9,    10,
+      24,    25,    13,    14,    24,    25,    30,    31,    27,    28,
+      30,    35,    61,    62,   116,    35,    27,    28,     4,     5,
+       6,     7,     8,     9,    10,    26,    86,    13,    14,    24,
+      25,    24,    25,    34,    28,   137,    32,    33,   140,    99,
+      28,    27,    28,     5,     6,    28,     8,     9,    10,    28,
+      11,    13,    14,    28,    15,    16,    28,    18,    19,    20,
+      21,    22,    23,    28,    25,    27,    28,    28,    11,    33,
+      28,    28,    15,    16,    17,    18,    19,    89,    90,    91,
+      92,    12,    28,    28,    28,    28,    28,    28,    13,    13,
+       0,    62,    -1,    53
+};
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+#line 3 "/usr/share/bison/bison.simple"
+
+/* Skeleton output parser for bison,
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software
+   Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* This is the parser code that is written into each bison parser when
+   the %semantic_parser declaration is not specified in the grammar.
+   It was written by Richard Stallman by simplifying the hairy parser
+   used when %semantic_parser is specified.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+#if ! defined (yyoverflow) || defined (YYERROR_VERBOSE)
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# if YYSTACK_USE_ALLOCA
+#  define YYSTACK_ALLOC alloca
+# else
+#  ifndef YYSTACK_USE_ALLOCA
+#   if defined (alloca) || defined (_ALLOCA_H)
+#    define YYSTACK_ALLOC alloca
+#   else
+#    ifdef __GNUC__
+#     define YYSTACK_ALLOC __builtin_alloca
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+# else
+#  if defined (__STDC__) || defined (__cplusplus)
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   define YYSIZE_T size_t
+#  endif
+#  define YYSTACK_ALLOC malloc
+#  define YYSTACK_FREE free
+# endif
+#endif /* ! defined (yyoverflow) || defined (YYERROR_VERBOSE) */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short yyss;
+  YYSTYPE yyvs;
+# if YYLSP_NEEDED
+  YYLTYPE yyls;
+# endif
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# if YYLSP_NEEDED
+#  define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
+      + 2 * YYSTACK_GAP_MAX)
+# else
+#  define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+      + YYSTACK_GAP_MAX)
+# endif
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  register YYSIZE_T yyi;		\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
+
+#endif
+
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# if defined (__STDC__) || defined (__cplusplus)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
+#define YYERROR		goto yyerrlab1
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL		goto yyerrlab
+#define YYRECOVERING()  (!!yyerrstatus)
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yychar1 = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { 								\
+      yyerror ("syntax error: cannot back up");			\
+      YYERROR;							\
+    }								\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).
+
+   When YYLLOC_DEFAULT is run, CURRENT is set the location of the
+   first token.  By default, to implement support for ranges, extend
+   its range to the last symbol.  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)       	\
+   Current.last_line   = Rhs[N].last_line;	\
+   Current.last_column = Rhs[N].last_column;
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#if YYPURE
+# if YYLSP_NEEDED
+#  ifdef YYLEX_PARAM
+#   define YYLEX		yylex (&yylval, &yylloc, YYLEX_PARAM)
+#  else
+#   define YYLEX		yylex (&yylval, &yylloc)
+#  endif
+# else /* !YYLSP_NEEDED */
+#  ifdef YYLEX_PARAM
+#   define YYLEX		yylex (&yylval, YYLEX_PARAM)
+#  else
+#   define YYLEX		yylex (&yylval)
+#  endif
+# endif /* !YYLSP_NEEDED */
+#else /* !YYPURE */
+# define YYLEX			yylex ()
+#endif /* !YYPURE */
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+#endif /* !YYDEBUG */
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#if YYMAXDEPTH == 0
+# undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+#ifdef YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  register const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+#endif
+
+#line 315 "/usr/share/bison/bison.simple"
+
+
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL
+# else
+#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+# endif
+#else /* !YYPARSE_PARAM */
+# define YYPARSE_PARAM_ARG
+# define YYPARSE_PARAM_DECL
+#endif /* !YYPARSE_PARAM */
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+# ifdef YYPARSE_PARAM
+int yyparse (void *);
+# else
+int yyparse (void);
+# endif
+#endif
+
+/* YY_DECL_VARIABLES -- depending whether we use a pure parser,
+   variables are global, or local to YYPARSE.  */
+
+#define YY_DECL_NON_LSP_VARIABLES			\
+/* The lookahead symbol.  */				\
+int yychar;						\
+							\
+/* The semantic value of the lookahead symbol. */	\
+YYSTYPE yylval;						\
+							\
+/* Number of parse errors so far.  */			\
+int yynerrs;
+
+#if YYLSP_NEEDED
+# define YY_DECL_VARIABLES			\
+YY_DECL_NON_LSP_VARIABLES			\
+						\
+/* Location data for the lookahead symbol.  */	\
+YYLTYPE yylloc;
+#else
+# define YY_DECL_VARIABLES			\
+YY_DECL_NON_LSP_VARIABLES
+#endif
+
+
+/* If nonreentrant, generate the variables here. */
+
+#if !YYPURE
+YY_DECL_VARIABLES
+#endif  /* !YYPURE */
+
+int
+yyparse (YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
+{
+  /* If reentrant, generate the variables here. */
+#if YYPURE
+  YY_DECL_VARIABLES
+#endif  /* !YYPURE */
+
+  register int yystate;
+  register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yychar1 = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack. */
+  short	yyssa[YYINITDEPTH];
+  short *yyss = yyssa;
+  register short *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  register YYSTYPE *yyvsp;
+
+#if YYLSP_NEEDED
+  /* The location stack.  */
+  YYLTYPE yylsa[YYINITDEPTH];
+  YYLTYPE *yyls = yylsa;
+  YYLTYPE *yylsp;
+#endif
+
+#if YYLSP_NEEDED
+# define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#else
+# define YYPOPSTACK   (yyvsp--, yyssp--)
+#endif
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+#if YYLSP_NEEDED
+  YYLTYPE yyloc;
+#endif
+
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule. */
+  int yylen;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+#if YYLSP_NEEDED
+  yylsp = yyls;
+#endif
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  */
+# if YYLSP_NEEDED
+	YYLTYPE *yyls1 = yyls;
+	/* This used to be a conditional around just the two extra args,
+	   but that might be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yyls1, yysize * sizeof (*yylsp),
+		    &yystacksize);
+	yyls = yyls1;
+# else
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+# endif
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyoverflowlab;
+# else
+      /* Extend the stack our own way.  */
+      if (yystacksize >= YYMAXDEPTH)
+	goto yyoverflowlab;
+      yystacksize *= 2;
+      if (yystacksize > YYMAXDEPTH)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	short *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+# if YYLSP_NEEDED
+	YYSTACK_RELOCATE (yyls);
+# endif
+# undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+#if YYLSP_NEEDED
+      yylsp = yyls + yysize - 1;
+#endif
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyssp >= yyss + yystacksize - 1)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  /* Convert token to internal form (in yychar1) for indexing tables with */
+
+  if (yychar <= 0)		/* This means end of input. */
+    {
+      yychar1 = 0;
+      yychar = YYEOF;		/* Don't call YYLEX any more */
+
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yychar1 = YYTRANSLATE (yychar);
+
+#if YYDEBUG
+     /* We have to keep this `#if YYDEBUG', since we use variables
+	which are defined only if `YYDEBUG' is set.  */
+      if (yydebug)
+	{
+	  YYFPRINTF (stderr, "Next token is %d (%s",
+		     yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise
+	     meaning of a token, for further debugging info.  */
+# ifdef YYPRINT
+	  YYPRINT (stderr, yychar, yylval);
+# endif
+	  YYFPRINTF (stderr, ")\n");
+	}
+#endif
+    }
+
+  yyn += yychar1;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+
+  /* yyn is what to do for this token type in this state.
+     Negative => reduce, -yyn is rule number.
+     Positive => shift, yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
+
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrlab;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
+	      yychar, yytname[yychar1]));
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+#if YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to the semantic value of
+     the lookahead token.  This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+#if YYLSP_NEEDED
+  /* Similarly for the default location.  Let the user run additional
+     commands if for instance locations are ranges.  */
+  yyloc = yylsp[1-yylen];
+  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
+#endif
+
+#if YYDEBUG
+  /* We have to keep this `#if YYDEBUG', since we use variables which
+     are defined only if `YYDEBUG' is set.  */
+  if (yydebug)
+    {
+      int yyi;
+
+      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
+		 yyn, yyrline[yyn]);
+
+      /* Print the symbols being reduced, and their result.  */
+      for (yyi = yyprhs[yyn]; yyrhs[yyi] > 0; yyi++)
+	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
+      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+    }
+#endif
+
+  switch (yyn) {
+
+case 7:
+#line 96 "zconf.y"
+{ zconfprint("unexpected 'endmenu' statement"); ;
+    break;}
+case 8:
+#line 97 "zconf.y"
+{ zconfprint("unexpected 'endif' statement"); ;
+    break;}
+case 9:
+#line 98 "zconf.y"
+{ zconfprint("unexpected 'endchoice' statement"); ;
+    break;}
+case 10:
+#line 99 "zconf.y"
+{ zconfprint("syntax error"); yyerrok; ;
+    break;}
+case 16:
+#line 114 "zconf.y"
+{
+	struct symbol *sym = sym_lookup(yyvsp[0].string, 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), yyvsp[0].string);
+;
+    break;}
+case 17:
+#line 122 "zconf.y"
+{
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 22:
+#line 133 "zconf.y"
+{ ;
+    break;}
+case 23:
+#line 136 "zconf.y"
+{
+	menu_set_type(S_TRISTATE);
+	printd(DEBUG_PARSE, "%s:%d:tristate\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 24:
+#line 142 "zconf.y"
+{
+	menu_set_type(S_BOOLEAN);
+	printd(DEBUG_PARSE, "%s:%d:boolean\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 25:
+#line 148 "zconf.y"
+{
+	menu_set_type(S_INT);
+	printd(DEBUG_PARSE, "%s:%d:int\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 26:
+#line 154 "zconf.y"
+{
+	menu_set_type(S_HEX);
+	printd(DEBUG_PARSE, "%s:%d:hex\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 27:
+#line 160 "zconf.y"
+{
+	menu_set_type(S_STRING);
+	printd(DEBUG_PARSE, "%s:%d:string\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 28:
+#line 166 "zconf.y"
+{
+	menu_add_prop(P_PROMPT, yyvsp[-1].string, NULL, yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 29:
+#line 172 "zconf.y"
+{
+	menu_add_prop(P_DEFAULT, NULL, yyvsp[-1].symbol, yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 30:
+#line 180 "zconf.y"
+{
+	struct symbol *sym = sym_lookup(NULL, 0);
+	sym->flags |= SYMBOL_CHOICE;
+	menu_add_entry(sym);
+	menu_add_prop(P_CHOICE, NULL, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 31:
+#line 189 "zconf.y"
+{
+	menu_end_entry();
+	menu_add_menu();
+;
+    break;}
+case 32:
+#line 195 "zconf.y"
+{
+	if (zconf_endtoken(yyvsp[0].token, T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;
+    break;}
+case 34:
+#line 205 "zconf.y"
+{
+	printf("%s:%d: missing 'endchoice' for this 'choice' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+;
+    break;}
+case 40:
+#line 219 "zconf.y"
+{
+	menu_add_prop(P_PROMPT, yyvsp[-1].string, NULL, yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 41:
+#line 225 "zconf.y"
+{
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 42:
+#line 231 "zconf.y"
+{
+	menu_add_prop(P_DEFAULT, NULL, yyvsp[0].symbol, NULL);
+	//current_choice->prop->def = $2;
+	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 45:
+#line 245 "zconf.y"
+{
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	//current_entry->prompt = menu_add_prop(T_IF, NULL, NULL, $2);
+	menu_add_dep(yyvsp[0].expr);
+	menu_end_entry();
+	menu_add_menu();
+;
+    break;}
+case 46:
+#line 255 "zconf.y"
+{
+	if (zconf_endtoken(yyvsp[0].token, T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;
+    break;}
+case 48:
+#line 265 "zconf.y"
+{
+	printf("%s:%d: missing 'endif' for this 'if' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+;
+    break;}
+case 53:
+#line 280 "zconf.y"
+{
+	menu_add_entry(NULL);
+	menu_add_prop(P_MENU, yyvsp[0].string, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 54:
+#line 287 "zconf.y"
+{
+	menu_end_entry();
+	menu_add_menu();
+;
+    break;}
+case 55:
+#line 293 "zconf.y"
+{
+	if (zconf_endtoken(yyvsp[0].token, T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;
+    break;}
+case 57:
+#line 303 "zconf.y"
+{
+	printf("%s:%d: missing 'endmenu' for this 'menu' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+;
+    break;}
+case 62:
+#line 313 "zconf.y"
+{ zconfprint("invalid menu option"); yyerrok; ;
+    break;}
+case 63:
+#line 317 "zconf.y"
+{
+	yyval.string = yyvsp[0].string;
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), yyvsp[0].string);
+;
+    break;}
+case 64:
+#line 323 "zconf.y"
+{
+	zconf_nextfile(yyvsp[-1].string);
+;
+    break;}
+case 65:
+#line 330 "zconf.y"
+{
+	menu_add_entry(NULL);
+	menu_add_prop(P_COMMENT, yyvsp[0].string, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 66:
+#line 337 "zconf.y"
+{
+	menu_end_entry();
+;
+    break;}
+case 67:
+#line 344 "zconf.y"
+{
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;
+    break;}
+case 68:
+#line 350 "zconf.y"
+{
+	current_entry->sym->help = yyvsp[0].string;
+;
+    break;}
+case 71:
+#line 359 "zconf.y"
+{ ;
+    break;}
+case 72:
+#line 362 "zconf.y"
+{
+	menu_add_dep(yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 73:
+#line 367 "zconf.y"
+{
+	menu_add_dep(yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:depends\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 74:
+#line 372 "zconf.y"
+{
+	menu_add_dep(yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:requires\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 76:
+#line 382 "zconf.y"
+{
+	menu_add_prop(P_PROMPT, yyvsp[0].string, NULL, NULL);
+;
+    break;}
+case 77:
+#line 386 "zconf.y"
+{
+	menu_add_prop(P_PROMPT, yyvsp[-2].string, NULL, yyvsp[0].expr);
+;
+    break;}
+case 80:
+#line 394 "zconf.y"
+{ yyval.token = T_ENDMENU; ;
+    break;}
+case 81:
+#line 395 "zconf.y"
+{ yyval.token = T_ENDCHOICE; ;
+    break;}
+case 82:
+#line 396 "zconf.y"
+{ yyval.token = T_ENDIF; ;
+    break;}
+case 85:
+#line 402 "zconf.y"
+{ yyval.expr = NULL; ;
+    break;}
+case 86:
+#line 403 "zconf.y"
+{ yyval.expr = yyvsp[0].expr; ;
+    break;}
+case 87:
+#line 406 "zconf.y"
+{ yyval.expr = expr_alloc_symbol(yyvsp[0].symbol); ;
+    break;}
+case 88:
+#line 407 "zconf.y"
+{ yyval.expr = expr_alloc_comp(E_EQUAL, yyvsp[-2].symbol, yyvsp[0].symbol); ;
+    break;}
+case 89:
+#line 408 "zconf.y"
+{ yyval.expr = expr_alloc_comp(E_UNEQUAL, yyvsp[-2].symbol, yyvsp[0].symbol); ;
+    break;}
+case 90:
+#line 409 "zconf.y"
+{ yyval.expr = yyvsp[-1].expr; ;
+    break;}
+case 91:
+#line 410 "zconf.y"
+{ yyval.expr = expr_alloc_one(E_NOT, yyvsp[0].expr); ;
+    break;}
+case 92:
+#line 411 "zconf.y"
+{ yyval.expr = expr_alloc_two(E_OR, yyvsp[-2].expr, yyvsp[0].expr); ;
+    break;}
+case 93:
+#line 412 "zconf.y"
+{ yyval.expr = expr_alloc_two(E_AND, yyvsp[-2].expr, yyvsp[0].expr); ;
+    break;}
+case 94:
+#line 415 "zconf.y"
+{ yyval.symbol = sym_lookup(yyvsp[0].string, 0); free(yyvsp[0].string); ;
+    break;}
+case 95:
+#line 416 "zconf.y"
+{ yyval.symbol = sym_lookup(yyvsp[0].string, 1); free(yyvsp[0].string); ;
+    break;}
+}
+
+#line 705 "/usr/share/bison/bison.simple"
+
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+#if YYLSP_NEEDED
+  yylsp -= yylen;
+#endif
+
+#if YYDEBUG
+  if (yydebug)
+    {
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
+    }
+#endif
+
+  *++yyvsp = yyval;
+#if YYLSP_NEEDED
+  *++yylsp = yyloc;
+#endif
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+
+#ifdef YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (yyn > YYFLAG && yyn < YYLAST)
+	{
+	  YYSIZE_T yysize = 0;
+	  char *yymsg;
+	  int yyx, yycount;
+
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  for (yyx = yyn < 0 ? -yyn : 0;
+	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
+	    if (yycheck[yyx + yyn] == yyx)
+	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
+	  yysize += yystrlen ("parse error, unexpected ") + 1;
+	  yysize += yystrlen (yytname[YYTRANSLATE (yychar)]);
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
+	    {
+	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[YYTRANSLATE (yychar)]);
+
+	      if (yycount < 5)
+		{
+		  yycount = 0;
+		  for (yyx = yyn < 0 ? -yyn : 0;
+		       yyx < (int) (sizeof (yytname) / sizeof (char *));
+		       yyx++)
+		    if (yycheck[yyx + yyn] == yyx)
+		      {
+			const char *yyq = ! yycount ? ", expecting " : " or ";
+			yyp = yystpcpy (yyp, yyq);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yycount++;
+		      }
+		}
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
+	    }
+	  else
+	    yyerror ("parse error; also virtual memory exhausted");
+	}
+      else
+#endif /* defined (YYERROR_VERBOSE) */
+	yyerror ("parse error");
+    }
+  goto yyerrlab1;
+
+
+/*--------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action |
+`--------------------------------------------------*/
+yyerrlab1:
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      /* return failure if at end of input */
+      if (yychar == YYEOF)
+	YYABORT;
+      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
+		  yychar, yytname[yychar1]));
+      yychar = YYEMPTY;
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+
+  yyerrstatus = 3;		/* Each real token shifted decrements this */
+
+  goto yyerrhandle;
+
+
+/*-------------------------------------------------------------------.
+| yyerrdefault -- current state does not do anything special for the |
+| error token.                                                       |
+`-------------------------------------------------------------------*/
+yyerrdefault:
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+
+  /* If its default is to accept any token, ok.  Otherwise pop it.  */
+  yyn = yydefact[yystate];
+  if (yyn)
+    goto yydefault;
+#endif
+
+
+/*---------------------------------------------------------------.
+| yyerrpop -- pop the current state because it cannot handle the |
+| error token                                                    |
+`---------------------------------------------------------------*/
+yyerrpop:
+  if (yyssp == yyss)
+    YYABORT;
+  yyvsp--;
+  yystate = *--yyssp;
+#if YYLSP_NEEDED
+  yylsp--;
+#endif
+
+#if YYDEBUG
+  if (yydebug)
+    {
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "Error: state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
+    }
+#endif
+
+/*--------------.
+| yyerrhandle.  |
+`--------------*/
+yyerrhandle:
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yyerrdefault;
+
+  yyn += YYTERROR;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
+    goto yyerrdefault;
+
+  yyn = yytable[yyn];
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrpop;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrpop;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  YYDPRINTF ((stderr, "Shifting error token, "));
+
+  *++yyvsp = yylval;
+#if YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+/*---------------------------------------------.
+| yyoverflowab -- parser overflow comes here.  |
+`---------------------------------------------*/
+yyoverflowlab:
+  yyerror ("parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
+}
+#line 419 "zconf.y"
+
+
+void conf_parse(const char *name)
+{
+	zconf_initscan(name);
+
+	sym_init();
+	menu_init();
+	rootmenu.prompt = menu_add_prop(P_MENU, "Linux Kernel Configuration", NULL, NULL);
+
+	//zconfdebug = 1;
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	menu_finalize(&rootmenu);
+
+	modules_sym = sym_lookup("MODULES", 0);
+
+	sym_change_count = 1;
+}
+
+const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	}
+	return "<token>";
+} 
+
+static bool zconf_endtoken(int token, int starttoken, int endtoken)
+{
+	if (token != endtoken) {
+		zconfprint("unexpected '%s' within %s block", zconf_tokenname(token), zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconfprint("'%s' in different file than '%s'", zconf_tokenname(token), zconf_tokenname(starttoken));
+		zconfprint("location of the '%s'", zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno(), err);
+}
+
+void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	//sym->flags |= SYMBOL_PRINTED;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "choice\n");
+	else
+		fprintf(out, "config %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+#if 0
+	if (!expr_is_yes(sym->dep)) {
+		fputs("  depends ", out);
+		expr_fprint(sym->dep, out);
+		fputc('\n', out);
+	}
+#endif
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (prop->def) {
+				fputc(' ', out);
+				if (prop->def->flags & SYMBOL_CONST)
+					print_quoted_string(out, prop->def->name);
+				else
+					fputs(prop->def->name, out);
+			}
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs(" if ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			print_quoted_string(out, prop->def->name);
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs(" if ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (sym->help) {
+		int len = strlen(sym->help);
+		while (sym->help[--len] == '\n')
+			sym->help[len] = 0;
+		fprintf(out, "  help\n%s\n", sym->help);
+	}
+	fputc('\n', out);
+}
+
+void zconfdump(FILE *out)
+{
+	//struct file *file;
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			//case T_MAINMENU:
+			//	fputs("\nmainmenu ", out);
+			//	print_quoted_string(out, prop->text);
+			//	fputs("\n", out);
+			//	break;
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			//case T_SOURCE:
+			//	fputs("\nsource ", out);
+			//	print_quoted_string(out, prop->text);
+			//	fputs("\n", out);
+			//	break;
+			//case T_IF:
+			//	fputs("\nif\n", out);
+			default:
+				;
+			}
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs("  depends ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+				fputc('\n', out);
+			}
+			fputs("\n", out);
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "lex.zconf.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
diff --git a/extra/config/zconf.tab.c_shipped b/extra/config/zconf.tab.c_shipped
new file mode 100644
index 000000000..da46314d8
--- /dev/null
+++ b/extra/config/zconf.tab.c_shipped
@@ -0,0 +1,1866 @@
+/* A Bison parser, made from zconf.y
+   by GNU bison 1.35.  */
+
+#define YYBISON 1  /* Identify Bison output.  */
+
+#define yyparse zconfparse
+#define yylex zconflex
+#define yyerror zconferror
+#define yylval zconflval
+#define yychar zconfchar
+#define yydebug zconfdebug
+#define yynerrs zconfnerrs
+# define	T_MAINMENU	257
+# define	T_MENU	258
+# define	T_ENDMENU	259
+# define	T_SOURCE	260
+# define	T_CHOICE	261
+# define	T_ENDCHOICE	262
+# define	T_COMMENT	263
+# define	T_CONFIG	264
+# define	T_HELP	265
+# define	T_HELPTEXT	266
+# define	T_IF	267
+# define	T_ENDIF	268
+# define	T_DEPENDS	269
+# define	T_REQUIRES	270
+# define	T_OPTIONAL	271
+# define	T_PROMPT	272
+# define	T_DEFAULT	273
+# define	T_TRISTATE	274
+# define	T_BOOLEAN	275
+# define	T_INT	276
+# define	T_HEX	277
+# define	T_WORD	278
+# define	T_STRING	279
+# define	T_UNEQUAL	280
+# define	T_EOF	281
+# define	T_EOL	282
+# define	T_CLOSE_PAREN	283
+# define	T_OPEN_PAREN	284
+# define	T_ON	285
+# define	T_OR	286
+# define	T_AND	287
+# define	T_EQUAL	288
+# define	T_NOT	289
+
+#line 1 "zconf.y"
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(int token, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[257];
+
+#define YYERROR_VERBOSE
+
+#line 32 "zconf.y"
+#ifndef YYSTYPE
+typedef union
+{
+	int token;
+	char *string;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+} yystype;
+# define YYSTYPE yystype
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+#line 83 "zconf.y"
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+
+
+#define	YYFINAL		145
+#define	YYFLAG		-32768
+#define	YYNTBASE	36
+
+/* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
+#define YYTRANSLATE(x) ((unsigned)(x) <= 289 ? yytranslate[x] : 74)
+
+/* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
+static const char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     3,     4,     5,
+       6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    34,    35
+};
+
+#if YYDEBUG
+static const short yyprhs[] =
+{
+       0,     0,     1,     4,     6,     8,    10,    14,    16,    18,
+      20,    23,    25,    27,    29,    31,    33,    36,    40,    41,
+      45,    49,    52,    55,    58,    61,    64,    67,    70,    74,
+      78,    80,    84,    86,    91,    94,    95,    99,   103,   106,
+     109,   113,   115,   118,   119,   122,   125,   127,   133,   137,
+     138,   141,   144,   147,   150,   154,   156,   161,   164,   165,
+     168,   171,   174,   178,   181,   184,   187,   191,   194,   197,
+     198,   202,   205,   209,   212,   215,   216,   218,   222,   224,
+     226,   228,   230,   232,   234,   236,   237,   240,   242,   246,
+     250,   254,   257,   261,   265,   267
+};
+static const short yyrhs[] =
+{
+      -1,    36,    37,     0,    38,     0,    46,     0,    57,     0,
+       3,    68,    70,     0,     5,     0,    14,     0,     8,     0,
+       1,    70,     0,    52,     0,    62,     0,    40,     0,    60,
+       0,    70,     0,    10,    24,     0,    39,    28,    41,     0,
+       0,    41,    42,    28,     0,    41,    66,    28,     0,    41,
+      64,     0,    41,    28,     0,    20,    67,     0,    21,    67,
+       0,    22,    67,     0,    23,    67,     0,    25,    67,     0,
+      18,    68,    71,     0,    19,    73,    71,     0,     7,     0,
+      43,    28,    47,     0,    69,     0,    44,    49,    45,    28,
+       0,    44,    49,     0,     0,    47,    48,    28,     0,    47,
+      66,    28,     0,    47,    64,     0,    47,    28,     0,    18,
+      68,    71,     0,    17,     0,    19,    73,     0,     0,    49,
+      38,     0,    13,    72,     0,    69,     0,    50,    28,    53,
+      51,    28,     0,    50,    28,    53,     0,     0,    53,    38,
+       0,    53,    57,     0,    53,    46,     0,     4,    68,     0,
+      54,    28,    65,     0,    69,     0,    55,    58,    56,    28,
+       0,    55,    58,     0,     0,    58,    38,     0,    58,    57,
+       0,    58,    46,     0,    58,     1,    28,     0,     6,    68,
+       0,    59,    28,     0,     9,    68,     0,    61,    28,    65,
+       0,    11,    28,     0,    63,    12,     0,     0,    65,    66,
+      28,     0,    65,    28,     0,    15,    31,    72,     0,    15,
+      72,     0,    16,    72,     0,     0,    68,     0,    68,    13,
+      72,     0,    24,     0,    25,     0,     5,     0,     8,     0,
+      14,     0,    28,     0,    27,     0,     0,    13,    72,     0,
+      73,     0,    73,    34,    73,     0,    73,    26,    73,     0,
+      30,    72,    29,     0,    35,    72,     0,    72,    32,    72,
+       0,    72,    33,    72,     0,    24,     0,    25,     0
+};
+
+#endif
+
+#if YYDEBUG
+/* YYRLINE[YYN] -- source line where rule number YYN was defined. */
+static const short yyrline[] =
+{
+       0,    88,    89,    92,    93,    94,    95,    96,    97,    98,
+      99,   102,   104,   105,   106,   107,   113,   121,   127,   129,
+     130,   131,   132,   135,   141,   147,   153,   159,   165,   171,
+     179,   188,   194,   202,   204,   210,   212,   213,   214,   215,
+     218,   224,   230,   237,   239,   244,   254,   262,   264,   270,
+     272,   273,   274,   279,   286,   292,   300,   302,   308,   310,
+     311,   312,   313,   316,   322,   329,   336,   343,   349,   356,
+     357,   358,   361,   366,   371,   379,   381,   385,   390,   391,
+     394,   395,   396,   399,   400,   402,   403,   406,   407,   408,
+     409,   410,   411,   412,   415,   416
+};
+#endif
+
+
+#if (YYDEBUG) || defined YYERROR_VERBOSE
+
+/* YYTNAME[TOKEN_NUM] -- String name of the token TOKEN_NUM. */
+static const char *const yytname[] =
+{
+  "$", "error", "$undefined.", "T_MAINMENU", "T_MENU", "T_ENDMENU", 
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG", 
+  "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS", "T_REQUIRES", 
+  "T_OPTIONAL", "T_PROMPT", "T_DEFAULT", "T_TRISTATE", "T_BOOLEAN", 
+  "T_INT", "T_HEX", "T_WORD", "T_STRING", "T_UNEQUAL", "T_EOF", "T_EOL", 
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_ON", "T_OR", "T_AND", "T_EQUAL", 
+  "T_NOT", "input", "block", "common_block", "config_entry_start", 
+  "config_stmt", "config_option_list", "config_option", "choice", 
+  "choice_entry", "choice_end", "choice_stmt", "choice_option_list", 
+  "choice_option", "choice_block", "if", "if_end", "if_stmt", "if_block", 
+  "menu", "menu_entry", "menu_end", "menu_stmt", "menu_block", "source", 
+  "source_stmt", "comment", "comment_stmt", "help_start", "help", 
+  "depends_list", "depends", "prompt_stmt_opt", "prompt", "end", 
+  "nl_or_eof", "if_expr", "expr", "symbol", 0
+};
+#endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
+static const short yyr1[] =
+{
+       0,    36,    36,    37,    37,    37,    37,    37,    37,    37,
+      37,    38,    38,    38,    38,    38,    39,    40,    41,    41,
+      41,    41,    41,    42,    42,    42,    42,    42,    42,    42,
+      43,    44,    45,    46,    46,    47,    47,    47,    47,    47,
+      48,    48,    48,    49,    49,    50,    51,    52,    52,    53,
+      53,    53,    53,    54,    55,    56,    57,    57,    58,    58,
+      58,    58,    58,    59,    60,    61,    62,    63,    64,    65,
+      65,    65,    66,    66,    66,    67,    67,    67,    68,    68,
+      69,    69,    69,    70,    70,    71,    71,    72,    72,    72,
+      72,    72,    72,    72,    73,    73
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
+static const short yyr2[] =
+{
+       0,     0,     2,     1,     1,     1,     3,     1,     1,     1,
+       2,     1,     1,     1,     1,     1,     2,     3,     0,     3,
+       3,     2,     2,     2,     2,     2,     2,     2,     3,     3,
+       1,     3,     1,     4,     2,     0,     3,     3,     2,     2,
+       3,     1,     2,     0,     2,     2,     1,     5,     3,     0,
+       2,     2,     2,     2,     3,     1,     4,     2,     0,     2,
+       2,     2,     3,     2,     2,     2,     3,     2,     2,     0,
+       3,     2,     3,     2,     2,     0,     1,     3,     1,     1,
+       1,     1,     1,     1,     1,     0,     2,     1,     3,     3,
+       3,     2,     3,     3,     1,     1
+};
+
+/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
+   doesn't specify something else to do.  Zero means the default is an
+   error. */
+static const short yydefact[] =
+{
+       1,     0,     0,     0,     0,     7,     0,    30,     9,     0,
+       0,     0,     8,    84,    83,     2,     3,     0,    13,     0,
+      43,     4,     0,    11,     0,    58,     5,     0,    14,     0,
+      12,    15,    10,    78,    79,     0,    53,    63,    65,    16,
+      94,    95,     0,     0,    45,    87,    18,    35,    34,    49,
+      69,     0,    64,    69,     6,     0,    91,     0,     0,     0,
+       0,    17,    31,    80,    81,    82,    44,     0,    32,    48,
+      54,     0,    59,    61,     0,    60,    55,    66,    90,    92,
+      93,    89,    88,     0,     0,     0,     0,     0,    75,    75,
+      75,    75,    75,    22,     0,     0,    21,     0,    41,     0,
+       0,    39,     0,    38,     0,    33,    50,    52,     0,    51,
+      46,    71,     0,    62,    56,    67,     0,    73,    74,    85,
+      85,    23,    76,    24,    25,    26,    27,    19,    68,    20,
+      85,    42,    36,    37,    47,    70,    72,     0,    28,    29,
+       0,    40,    86,    77,     0,     0
+};
+
+static const short yydefgoto[] =
+{
+       1,    15,    16,    17,    18,    61,    94,    19,    20,    67,
+      21,    62,   102,    48,    22,   108,    23,    69,    24,    25,
+      74,    26,    51,    27,    28,    29,    30,    95,    96,    70,
+     112,   121,   122,    68,    31,   138,    44,    45
+};
+
+static const short yypact[] =
+{
+  -32768,    17,    41,    65,    65,-32768,    65,-32768,-32768,    65,
+     -11,    40,-32768,-32768,-32768,-32768,-32768,    13,-32768,    23,
+  -32768,-32768,    66,-32768,    72,-32768,-32768,    77,-32768,    81,
+  -32768,-32768,-32768,-32768,-32768,    41,-32768,-32768,-32768,-32768,
+  -32768,-32768,    40,    40,    64,    59,-32768,-32768,    98,-32768,
+  -32768,    49,-32768,-32768,-32768,     7,-32768,    40,    40,    67,
+      67,    99,   117,-32768,-32768,-32768,-32768,    85,-32768,    74,
+      18,    88,-32768,-32768,    95,-32768,-32768,    18,-32768,    96,
+  -32768,-32768,-32768,   102,    36,    40,    65,    67,    65,    65,
+      65,    65,    65,-32768,   103,   129,-32768,   114,-32768,    65,
+      67,-32768,   115,-32768,   116,-32768,-32768,-32768,   118,-32768,
+  -32768,-32768,   119,-32768,-32768,-32768,    40,    64,    64,   135,
+     135,-32768,   136,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
+     135,-32768,-32768,-32768,-32768,-32768,    64,    40,-32768,-32768,
+      40,-32768,    64,    64,   150,-32768
+};
+
+static const short yypgoto[] =
+{
+  -32768,-32768,   -37,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
+     -41,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
+  -32768,   -32,-32768,-32768,-32768,-32768,-32768,-32768,    89,   100,
+      11,    48,     0,   -22,     3,  -118,   -42,   -52
+};
+
+
+#define	YYLAST		153
+
+
+static const short yytable[] =
+{
+      55,    56,   139,    35,    36,    32,    37,    81,    82,    38,
+      73,    66,   141,    39,    72,    79,    80,   144,     2,    75,
+       3,     4,     5,     6,     7,     8,     9,    10,   107,    76,
+      11,    12,   106,    84,    85,   120,    78,   109,    54,    57,
+      58,    46,   117,   118,    13,    14,   111,   110,   131,   -57,
+      71,    47,   -57,     4,    63,     6,     7,    64,     9,    10,
+      40,    41,    11,    65,    40,    41,    42,   116,    13,    14,
+      42,    43,    97,   104,   136,    43,    13,    14,     4,    63,
+       6,     7,    64,     9,    10,    59,   119,    11,    65,    33,
+      34,    40,    41,    60,    49,   142,    57,    58,   143,   130,
+      50,    13,    14,    63,     6,    52,    64,     9,    10,    53,
+      83,    11,    65,   105,    84,    85,   113,    86,    87,    88,
+      89,    90,    91,   114,    92,    13,    14,    93,    83,    58,
+     115,   127,    84,    85,    98,    99,   100,   123,   124,   125,
+     126,   128,   129,   132,   133,   101,   134,   135,   137,   140,
+     145,   103,     0,    77
+};
+
+static const short yycheck[] =
+{
+      42,    43,   120,     3,     4,     2,     6,    59,    60,     9,
+      51,    48,   130,    24,    51,    57,    58,     0,     1,    51,
+       3,     4,     5,     6,     7,     8,     9,    10,    69,    51,
+      13,    14,    69,    15,    16,    87,    29,    69,    35,    32,
+      33,    28,    84,    85,    27,    28,    28,    69,   100,     0,
+       1,    28,     3,     4,     5,     6,     7,     8,     9,    10,
+      24,    25,    13,    14,    24,    25,    30,    31,    27,    28,
+      30,    35,    61,    62,   116,    35,    27,    28,     4,     5,
+       6,     7,     8,     9,    10,    26,    86,    13,    14,    24,
+      25,    24,    25,    34,    28,   137,    32,    33,   140,    99,
+      28,    27,    28,     5,     6,    28,     8,     9,    10,    28,
+      11,    13,    14,    28,    15,    16,    28,    18,    19,    20,
+      21,    22,    23,    28,    25,    27,    28,    28,    11,    33,
+      28,    28,    15,    16,    17,    18,    19,    89,    90,    91,
+      92,    12,    28,    28,    28,    28,    28,    28,    13,    13,
+       0,    62,    -1,    53
+};
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+#line 3 "/usr/share/bison/bison.simple"
+
+/* Skeleton output parser for bison,
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software
+   Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* This is the parser code that is written into each bison parser when
+   the %semantic_parser declaration is not specified in the grammar.
+   It was written by Richard Stallman by simplifying the hairy parser
+   used when %semantic_parser is specified.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+#if ! defined (yyoverflow) || defined (YYERROR_VERBOSE)
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# if YYSTACK_USE_ALLOCA
+#  define YYSTACK_ALLOC alloca
+# else
+#  ifndef YYSTACK_USE_ALLOCA
+#   if defined (alloca) || defined (_ALLOCA_H)
+#    define YYSTACK_ALLOC alloca
+#   else
+#    ifdef __GNUC__
+#     define YYSTACK_ALLOC __builtin_alloca
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+# else
+#  if defined (__STDC__) || defined (__cplusplus)
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   define YYSIZE_T size_t
+#  endif
+#  define YYSTACK_ALLOC malloc
+#  define YYSTACK_FREE free
+# endif
+#endif /* ! defined (yyoverflow) || defined (YYERROR_VERBOSE) */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short yyss;
+  YYSTYPE yyvs;
+# if YYLSP_NEEDED
+  YYLTYPE yyls;
+# endif
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# if YYLSP_NEEDED
+#  define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
+      + 2 * YYSTACK_GAP_MAX)
+# else
+#  define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+      + YYSTACK_GAP_MAX)
+# endif
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  register YYSIZE_T yyi;		\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
+
+#endif
+
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# if defined (__STDC__) || defined (__cplusplus)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
+#define YYERROR		goto yyerrlab1
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL		goto yyerrlab
+#define YYRECOVERING()  (!!yyerrstatus)
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yychar1 = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { 								\
+      yyerror ("syntax error: cannot back up");			\
+      YYERROR;							\
+    }								\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).
+
+   When YYLLOC_DEFAULT is run, CURRENT is set the location of the
+   first token.  By default, to implement support for ranges, extend
+   its range to the last symbol.  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)       	\
+   Current.last_line   = Rhs[N].last_line;	\
+   Current.last_column = Rhs[N].last_column;
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#if YYPURE
+# if YYLSP_NEEDED
+#  ifdef YYLEX_PARAM
+#   define YYLEX		yylex (&yylval, &yylloc, YYLEX_PARAM)
+#  else
+#   define YYLEX		yylex (&yylval, &yylloc)
+#  endif
+# else /* !YYLSP_NEEDED */
+#  ifdef YYLEX_PARAM
+#   define YYLEX		yylex (&yylval, YYLEX_PARAM)
+#  else
+#   define YYLEX		yylex (&yylval)
+#  endif
+# endif /* !YYLSP_NEEDED */
+#else /* !YYPURE */
+# define YYLEX			yylex ()
+#endif /* !YYPURE */
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+#endif /* !YYDEBUG */
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#if YYMAXDEPTH == 0
+# undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+#ifdef YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  register const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+#endif
+
+#line 315 "/usr/share/bison/bison.simple"
+
+
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL
+# else
+#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+# endif
+#else /* !YYPARSE_PARAM */
+# define YYPARSE_PARAM_ARG
+# define YYPARSE_PARAM_DECL
+#endif /* !YYPARSE_PARAM */
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+# ifdef YYPARSE_PARAM
+int yyparse (void *);
+# else
+int yyparse (void);
+# endif
+#endif
+
+/* YY_DECL_VARIABLES -- depending whether we use a pure parser,
+   variables are global, or local to YYPARSE.  */
+
+#define YY_DECL_NON_LSP_VARIABLES			\
+/* The lookahead symbol.  */				\
+int yychar;						\
+							\
+/* The semantic value of the lookahead symbol. */	\
+YYSTYPE yylval;						\
+							\
+/* Number of parse errors so far.  */			\
+int yynerrs;
+
+#if YYLSP_NEEDED
+# define YY_DECL_VARIABLES			\
+YY_DECL_NON_LSP_VARIABLES			\
+						\
+/* Location data for the lookahead symbol.  */	\
+YYLTYPE yylloc;
+#else
+# define YY_DECL_VARIABLES			\
+YY_DECL_NON_LSP_VARIABLES
+#endif
+
+
+/* If nonreentrant, generate the variables here. */
+
+#if !YYPURE
+YY_DECL_VARIABLES
+#endif  /* !YYPURE */
+
+int
+yyparse (YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
+{
+  /* If reentrant, generate the variables here. */
+#if YYPURE
+  YY_DECL_VARIABLES
+#endif  /* !YYPURE */
+
+  register int yystate;
+  register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yychar1 = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack. */
+  short	yyssa[YYINITDEPTH];
+  short *yyss = yyssa;
+  register short *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  register YYSTYPE *yyvsp;
+
+#if YYLSP_NEEDED
+  /* The location stack.  */
+  YYLTYPE yylsa[YYINITDEPTH];
+  YYLTYPE *yyls = yylsa;
+  YYLTYPE *yylsp;
+#endif
+
+#if YYLSP_NEEDED
+# define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#else
+# define YYPOPSTACK   (yyvsp--, yyssp--)
+#endif
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+#if YYLSP_NEEDED
+  YYLTYPE yyloc;
+#endif
+
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule. */
+  int yylen;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+#if YYLSP_NEEDED
+  yylsp = yyls;
+#endif
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  */
+# if YYLSP_NEEDED
+	YYLTYPE *yyls1 = yyls;
+	/* This used to be a conditional around just the two extra args,
+	   but that might be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yyls1, yysize * sizeof (*yylsp),
+		    &yystacksize);
+	yyls = yyls1;
+# else
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+# endif
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyoverflowlab;
+# else
+      /* Extend the stack our own way.  */
+      if (yystacksize >= YYMAXDEPTH)
+	goto yyoverflowlab;
+      yystacksize *= 2;
+      if (yystacksize > YYMAXDEPTH)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	short *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+# if YYLSP_NEEDED
+	YYSTACK_RELOCATE (yyls);
+# endif
+# undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+#if YYLSP_NEEDED
+      yylsp = yyls + yysize - 1;
+#endif
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyssp >= yyss + yystacksize - 1)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  /* Convert token to internal form (in yychar1) for indexing tables with */
+
+  if (yychar <= 0)		/* This means end of input. */
+    {
+      yychar1 = 0;
+      yychar = YYEOF;		/* Don't call YYLEX any more */
+
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yychar1 = YYTRANSLATE (yychar);
+
+#if YYDEBUG
+     /* We have to keep this `#if YYDEBUG', since we use variables
+	which are defined only if `YYDEBUG' is set.  */
+      if (yydebug)
+	{
+	  YYFPRINTF (stderr, "Next token is %d (%s",
+		     yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise
+	     meaning of a token, for further debugging info.  */
+# ifdef YYPRINT
+	  YYPRINT (stderr, yychar, yylval);
+# endif
+	  YYFPRINTF (stderr, ")\n");
+	}
+#endif
+    }
+
+  yyn += yychar1;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+
+  /* yyn is what to do for this token type in this state.
+     Negative => reduce, -yyn is rule number.
+     Positive => shift, yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
+
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrlab;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
+	      yychar, yytname[yychar1]));
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+#if YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to the semantic value of
+     the lookahead token.  This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+#if YYLSP_NEEDED
+  /* Similarly for the default location.  Let the user run additional
+     commands if for instance locations are ranges.  */
+  yyloc = yylsp[1-yylen];
+  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
+#endif
+
+#if YYDEBUG
+  /* We have to keep this `#if YYDEBUG', since we use variables which
+     are defined only if `YYDEBUG' is set.  */
+  if (yydebug)
+    {
+      int yyi;
+
+      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
+		 yyn, yyrline[yyn]);
+
+      /* Print the symbols being reduced, and their result.  */
+      for (yyi = yyprhs[yyn]; yyrhs[yyi] > 0; yyi++)
+	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
+      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+    }
+#endif
+
+  switch (yyn) {
+
+case 7:
+#line 96 "zconf.y"
+{ zconfprint("unexpected 'endmenu' statement"); ;
+    break;}
+case 8:
+#line 97 "zconf.y"
+{ zconfprint("unexpected 'endif' statement"); ;
+    break;}
+case 9:
+#line 98 "zconf.y"
+{ zconfprint("unexpected 'endchoice' statement"); ;
+    break;}
+case 10:
+#line 99 "zconf.y"
+{ zconfprint("syntax error"); yyerrok; ;
+    break;}
+case 16:
+#line 114 "zconf.y"
+{
+	struct symbol *sym = sym_lookup(yyvsp[0].string, 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), yyvsp[0].string);
+;
+    break;}
+case 17:
+#line 122 "zconf.y"
+{
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 22:
+#line 133 "zconf.y"
+{ ;
+    break;}
+case 23:
+#line 136 "zconf.y"
+{
+	menu_set_type(S_TRISTATE);
+	printd(DEBUG_PARSE, "%s:%d:tristate\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 24:
+#line 142 "zconf.y"
+{
+	menu_set_type(S_BOOLEAN);
+	printd(DEBUG_PARSE, "%s:%d:boolean\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 25:
+#line 148 "zconf.y"
+{
+	menu_set_type(S_INT);
+	printd(DEBUG_PARSE, "%s:%d:int\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 26:
+#line 154 "zconf.y"
+{
+	menu_set_type(S_HEX);
+	printd(DEBUG_PARSE, "%s:%d:hex\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 27:
+#line 160 "zconf.y"
+{
+	menu_set_type(S_STRING);
+	printd(DEBUG_PARSE, "%s:%d:string\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 28:
+#line 166 "zconf.y"
+{
+	menu_add_prop(P_PROMPT, yyvsp[-1].string, NULL, yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 29:
+#line 172 "zconf.y"
+{
+	menu_add_prop(P_DEFAULT, NULL, yyvsp[-1].symbol, yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 30:
+#line 180 "zconf.y"
+{
+	struct symbol *sym = sym_lookup(NULL, 0);
+	sym->flags |= SYMBOL_CHOICE;
+	menu_add_entry(sym);
+	menu_add_prop(P_CHOICE, NULL, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 31:
+#line 189 "zconf.y"
+{
+	menu_end_entry();
+	menu_add_menu();
+;
+    break;}
+case 32:
+#line 195 "zconf.y"
+{
+	if (zconf_endtoken(yyvsp[0].token, T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;
+    break;}
+case 34:
+#line 205 "zconf.y"
+{
+	printf("%s:%d: missing 'endchoice' for this 'choice' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+;
+    break;}
+case 40:
+#line 219 "zconf.y"
+{
+	menu_add_prop(P_PROMPT, yyvsp[-1].string, NULL, yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 41:
+#line 225 "zconf.y"
+{
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 42:
+#line 231 "zconf.y"
+{
+	menu_add_prop(P_DEFAULT, NULL, yyvsp[0].symbol, NULL);
+	//current_choice->prop->def = $2;
+	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 45:
+#line 245 "zconf.y"
+{
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	//current_entry->prompt = menu_add_prop(T_IF, NULL, NULL, $2);
+	menu_add_dep(yyvsp[0].expr);
+	menu_end_entry();
+	menu_add_menu();
+;
+    break;}
+case 46:
+#line 255 "zconf.y"
+{
+	if (zconf_endtoken(yyvsp[0].token, T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;
+    break;}
+case 48:
+#line 265 "zconf.y"
+{
+	printf("%s:%d: missing 'endif' for this 'if' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+;
+    break;}
+case 53:
+#line 280 "zconf.y"
+{
+	menu_add_entry(NULL);
+	menu_add_prop(P_MENU, yyvsp[0].string, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 54:
+#line 287 "zconf.y"
+{
+	menu_end_entry();
+	menu_add_menu();
+;
+    break;}
+case 55:
+#line 293 "zconf.y"
+{
+	if (zconf_endtoken(yyvsp[0].token, T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;
+    break;}
+case 57:
+#line 303 "zconf.y"
+{
+	printf("%s:%d: missing 'endmenu' for this 'menu' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+;
+    break;}
+case 62:
+#line 313 "zconf.y"
+{ zconfprint("invalid menu option"); yyerrok; ;
+    break;}
+case 63:
+#line 317 "zconf.y"
+{
+	yyval.string = yyvsp[0].string;
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), yyvsp[0].string);
+;
+    break;}
+case 64:
+#line 323 "zconf.y"
+{
+	zconf_nextfile(yyvsp[-1].string);
+;
+    break;}
+case 65:
+#line 330 "zconf.y"
+{
+	menu_add_entry(NULL);
+	menu_add_prop(P_COMMENT, yyvsp[0].string, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 66:
+#line 337 "zconf.y"
+{
+	menu_end_entry();
+;
+    break;}
+case 67:
+#line 344 "zconf.y"
+{
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;
+    break;}
+case 68:
+#line 350 "zconf.y"
+{
+	current_entry->sym->help = yyvsp[0].string;
+;
+    break;}
+case 71:
+#line 359 "zconf.y"
+{ ;
+    break;}
+case 72:
+#line 362 "zconf.y"
+{
+	menu_add_dep(yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 73:
+#line 367 "zconf.y"
+{
+	menu_add_dep(yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:depends\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 74:
+#line 372 "zconf.y"
+{
+	menu_add_dep(yyvsp[0].expr);
+	printd(DEBUG_PARSE, "%s:%d:requires\n", zconf_curname(), zconf_lineno());
+;
+    break;}
+case 76:
+#line 382 "zconf.y"
+{
+	menu_add_prop(P_PROMPT, yyvsp[0].string, NULL, NULL);
+;
+    break;}
+case 77:
+#line 386 "zconf.y"
+{
+	menu_add_prop(P_PROMPT, yyvsp[-2].string, NULL, yyvsp[0].expr);
+;
+    break;}
+case 80:
+#line 394 "zconf.y"
+{ yyval.token = T_ENDMENU; ;
+    break;}
+case 81:
+#line 395 "zconf.y"
+{ yyval.token = T_ENDCHOICE; ;
+    break;}
+case 82:
+#line 396 "zconf.y"
+{ yyval.token = T_ENDIF; ;
+    break;}
+case 85:
+#line 402 "zconf.y"
+{ yyval.expr = NULL; ;
+    break;}
+case 86:
+#line 403 "zconf.y"
+{ yyval.expr = yyvsp[0].expr; ;
+    break;}
+case 87:
+#line 406 "zconf.y"
+{ yyval.expr = expr_alloc_symbol(yyvsp[0].symbol); ;
+    break;}
+case 88:
+#line 407 "zconf.y"
+{ yyval.expr = expr_alloc_comp(E_EQUAL, yyvsp[-2].symbol, yyvsp[0].symbol); ;
+    break;}
+case 89:
+#line 408 "zconf.y"
+{ yyval.expr = expr_alloc_comp(E_UNEQUAL, yyvsp[-2].symbol, yyvsp[0].symbol); ;
+    break;}
+case 90:
+#line 409 "zconf.y"
+{ yyval.expr = yyvsp[-1].expr; ;
+    break;}
+case 91:
+#line 410 "zconf.y"
+{ yyval.expr = expr_alloc_one(E_NOT, yyvsp[0].expr); ;
+    break;}
+case 92:
+#line 411 "zconf.y"
+{ yyval.expr = expr_alloc_two(E_OR, yyvsp[-2].expr, yyvsp[0].expr); ;
+    break;}
+case 93:
+#line 412 "zconf.y"
+{ yyval.expr = expr_alloc_two(E_AND, yyvsp[-2].expr, yyvsp[0].expr); ;
+    break;}
+case 94:
+#line 415 "zconf.y"
+{ yyval.symbol = sym_lookup(yyvsp[0].string, 0); free(yyvsp[0].string); ;
+    break;}
+case 95:
+#line 416 "zconf.y"
+{ yyval.symbol = sym_lookup(yyvsp[0].string, 1); free(yyvsp[0].string); ;
+    break;}
+}
+
+#line 705 "/usr/share/bison/bison.simple"
+
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+#if YYLSP_NEEDED
+  yylsp -= yylen;
+#endif
+
+#if YYDEBUG
+  if (yydebug)
+    {
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
+    }
+#endif
+
+  *++yyvsp = yyval;
+#if YYLSP_NEEDED
+  *++yylsp = yyloc;
+#endif
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+
+#ifdef YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (yyn > YYFLAG && yyn < YYLAST)
+	{
+	  YYSIZE_T yysize = 0;
+	  char *yymsg;
+	  int yyx, yycount;
+
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  for (yyx = yyn < 0 ? -yyn : 0;
+	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
+	    if (yycheck[yyx + yyn] == yyx)
+	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
+	  yysize += yystrlen ("parse error, unexpected ") + 1;
+	  yysize += yystrlen (yytname[YYTRANSLATE (yychar)]);
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
+	    {
+	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[YYTRANSLATE (yychar)]);
+
+	      if (yycount < 5)
+		{
+		  yycount = 0;
+		  for (yyx = yyn < 0 ? -yyn : 0;
+		       yyx < (int) (sizeof (yytname) / sizeof (char *));
+		       yyx++)
+		    if (yycheck[yyx + yyn] == yyx)
+		      {
+			const char *yyq = ! yycount ? ", expecting " : " or ";
+			yyp = yystpcpy (yyp, yyq);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yycount++;
+		      }
+		}
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
+	    }
+	  else
+	    yyerror ("parse error; also virtual memory exhausted");
+	}
+      else
+#endif /* defined (YYERROR_VERBOSE) */
+	yyerror ("parse error");
+    }
+  goto yyerrlab1;
+
+
+/*--------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action |
+`--------------------------------------------------*/
+yyerrlab1:
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      /* return failure if at end of input */
+      if (yychar == YYEOF)
+	YYABORT;
+      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
+		  yychar, yytname[yychar1]));
+      yychar = YYEMPTY;
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+
+  yyerrstatus = 3;		/* Each real token shifted decrements this */
+
+  goto yyerrhandle;
+
+
+/*-------------------------------------------------------------------.
+| yyerrdefault -- current state does not do anything special for the |
+| error token.                                                       |
+`-------------------------------------------------------------------*/
+yyerrdefault:
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+
+  /* If its default is to accept any token, ok.  Otherwise pop it.  */
+  yyn = yydefact[yystate];
+  if (yyn)
+    goto yydefault;
+#endif
+
+
+/*---------------------------------------------------------------.
+| yyerrpop -- pop the current state because it cannot handle the |
+| error token                                                    |
+`---------------------------------------------------------------*/
+yyerrpop:
+  if (yyssp == yyss)
+    YYABORT;
+  yyvsp--;
+  yystate = *--yyssp;
+#if YYLSP_NEEDED
+  yylsp--;
+#endif
+
+#if YYDEBUG
+  if (yydebug)
+    {
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "Error: state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
+    }
+#endif
+
+/*--------------.
+| yyerrhandle.  |
+`--------------*/
+yyerrhandle:
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yyerrdefault;
+
+  yyn += YYTERROR;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
+    goto yyerrdefault;
+
+  yyn = yytable[yyn];
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrpop;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrpop;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  YYDPRINTF ((stderr, "Shifting error token, "));
+
+  *++yyvsp = yylval;
+#if YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+/*---------------------------------------------.
+| yyoverflowab -- parser overflow comes here.  |
+`---------------------------------------------*/
+yyoverflowlab:
+  yyerror ("parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
+}
+#line 419 "zconf.y"
+
+
+void conf_parse(const char *name)
+{
+	zconf_initscan(name);
+
+	sym_init();
+	menu_init();
+	rootmenu.prompt = menu_add_prop(P_MENU, "Linux Kernel Configuration", NULL, NULL);
+
+	//zconfdebug = 1;
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	menu_finalize(&rootmenu);
+
+	modules_sym = sym_lookup("MODULES", 0);
+
+	sym_change_count = 1;
+}
+
+const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	}
+	return "<token>";
+} 
+
+static bool zconf_endtoken(int token, int starttoken, int endtoken)
+{
+	if (token != endtoken) {
+		zconfprint("unexpected '%s' within %s block", zconf_tokenname(token), zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconfprint("'%s' in different file than '%s'", zconf_tokenname(token), zconf_tokenname(starttoken));
+		zconfprint("location of the '%s'", zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno(), err);
+}
+
+void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	//sym->flags |= SYMBOL_PRINTED;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "choice\n");
+	else
+		fprintf(out, "config %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+#if 0
+	if (!expr_is_yes(sym->dep)) {
+		fputs("  depends ", out);
+		expr_fprint(sym->dep, out);
+		fputc('\n', out);
+	}
+#endif
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (prop->def) {
+				fputc(' ', out);
+				if (prop->def->flags & SYMBOL_CONST)
+					print_quoted_string(out, prop->def->name);
+				else
+					fputs(prop->def->name, out);
+			}
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs(" if ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			print_quoted_string(out, prop->def->name);
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs(" if ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (sym->help) {
+		int len = strlen(sym->help);
+		while (sym->help[--len] == '\n')
+			sym->help[len] = 0;
+		fprintf(out, "  help\n%s\n", sym->help);
+	}
+	fputc('\n', out);
+}
+
+void zconfdump(FILE *out)
+{
+	//struct file *file;
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			//case T_MAINMENU:
+			//	fputs("\nmainmenu ", out);
+			//	print_quoted_string(out, prop->text);
+			//	fputs("\n", out);
+			//	break;
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			//case T_SOURCE:
+			//	fputs("\nsource ", out);
+			//	print_quoted_string(out, prop->text);
+			//	fputs("\n", out);
+			//	break;
+			//case T_IF:
+			//	fputs("\nif\n", out);
+			default:
+				;
+			}
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs("  depends ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+				fputc('\n', out);
+			}
+			fputs("\n", out);
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "lex.zconf.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
diff --git a/extra/config/zconf.tab.h b/extra/config/zconf.tab.h
new file mode 100644
index 000000000..1dcffa989
--- /dev/null
+++ b/extra/config/zconf.tab.h
@@ -0,0 +1,53 @@
+#ifndef BISON_ZCONF_TAB_H
+# define BISON_ZCONF_TAB_H
+
+#ifndef YYSTYPE
+typedef union
+{
+	int token;
+	char *string;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+} yystype;
+# define YYSTYPE yystype
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+# define	T_MAINMENU	257
+# define	T_MENU	258
+# define	T_ENDMENU	259
+# define	T_SOURCE	260
+# define	T_CHOICE	261
+# define	T_ENDCHOICE	262
+# define	T_COMMENT	263
+# define	T_CONFIG	264
+# define	T_HELP	265
+# define	T_HELPTEXT	266
+# define	T_IF	267
+# define	T_ENDIF	268
+# define	T_DEPENDS	269
+# define	T_REQUIRES	270
+# define	T_OPTIONAL	271
+# define	T_PROMPT	272
+# define	T_DEFAULT	273
+# define	T_TRISTATE	274
+# define	T_BOOLEAN	275
+# define	T_INT	276
+# define	T_HEX	277
+# define	T_WORD	278
+# define	T_STRING	279
+# define	T_UNEQUAL	280
+# define	T_EOF	281
+# define	T_EOL	282
+# define	T_CLOSE_PAREN	283
+# define	T_OPEN_PAREN	284
+# define	T_ON	285
+# define	T_OR	286
+# define	T_AND	287
+# define	T_EQUAL	288
+# define	T_NOT	289
+
+
+extern YYSTYPE zconflval;
+
+#endif /* not BISON_ZCONF_TAB_H */
diff --git a/extra/config/zconf.tab.h_shipped b/extra/config/zconf.tab.h_shipped
new file mode 100644
index 000000000..1dcffa989
--- /dev/null
+++ b/extra/config/zconf.tab.h_shipped
@@ -0,0 +1,53 @@
+#ifndef BISON_ZCONF_TAB_H
+# define BISON_ZCONF_TAB_H
+
+#ifndef YYSTYPE
+typedef union
+{
+	int token;
+	char *string;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+} yystype;
+# define YYSTYPE yystype
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+# define	T_MAINMENU	257
+# define	T_MENU	258
+# define	T_ENDMENU	259
+# define	T_SOURCE	260
+# define	T_CHOICE	261
+# define	T_ENDCHOICE	262
+# define	T_COMMENT	263
+# define	T_CONFIG	264
+# define	T_HELP	265
+# define	T_HELPTEXT	266
+# define	T_IF	267
+# define	T_ENDIF	268
+# define	T_DEPENDS	269
+# define	T_REQUIRES	270
+# define	T_OPTIONAL	271
+# define	T_PROMPT	272
+# define	T_DEFAULT	273
+# define	T_TRISTATE	274
+# define	T_BOOLEAN	275
+# define	T_INT	276
+# define	T_HEX	277
+# define	T_WORD	278
+# define	T_STRING	279
+# define	T_UNEQUAL	280
+# define	T_EOF	281
+# define	T_EOL	282
+# define	T_CLOSE_PAREN	283
+# define	T_OPEN_PAREN	284
+# define	T_ON	285
+# define	T_OR	286
+# define	T_AND	287
+# define	T_EQUAL	288
+# define	T_NOT	289
+
+
+extern YYSTYPE zconflval;
+
+#endif /* not BISON_ZCONF_TAB_H */
diff --git a/extra/config/zconf.y b/extra/config/zconf.y
new file mode 100644
index 000000000..79cb983a6
--- /dev/null
+++ b/extra/config/zconf.y
@@ -0,0 +1,651 @@
+%{
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(int token, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[257];
+
+#define YYERROR_VERBOSE
+%}
+%expect 36
+
+%union
+{
+	int token;
+	char *string;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+}
+
+%token T_MAINMENU
+%token T_MENU
+%token T_ENDMENU
+%token T_SOURCE
+%token T_CHOICE
+%token T_ENDCHOICE
+%token T_COMMENT
+%token T_CONFIG
+%token T_HELP
+%token <string> T_HELPTEXT
+%token T_IF
+%token T_ENDIF
+%token T_DEPENDS
+%token T_REQUIRES
+%token T_OPTIONAL
+%token T_PROMPT
+%token T_DEFAULT
+%token T_TRISTATE
+%token T_BOOLEAN
+%token T_INT
+%token T_HEX
+%token <string> T_WORD
+%token <string> T_STRING
+%token T_UNEQUAL
+%token T_EOF
+%token T_EOL
+%token T_CLOSE_PAREN
+%token T_OPEN_PAREN
+%token T_ON
+
+%left T_OR
+%left T_AND
+%left T_EQUAL T_UNEQUAL
+%nonassoc T_NOT
+
+%type <string> prompt
+%type <string> source
+%type <symbol> symbol
+%type <expr> expr
+%type <expr> if_expr
+%type <token> end
+
+%{
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+%}
+%%
+input:	  /* empty */
+	| input block
+;
+
+block:	  common_block
+	| choice_stmt
+	| menu_stmt
+	| T_MAINMENU prompt nl_or_eof
+	| T_ENDMENU		{ zconfprint("unexpected 'endmenu' statement"); }
+	| T_ENDIF		{ zconfprint("unexpected 'endif' statement"); }
+	| T_ENDCHOICE		{ zconfprint("unexpected 'endchoice' statement"); }
+	| error nl_or_eof	{ zconfprint("syntax error"); yyerrok; }
+;
+
+common_block:
+	  if_stmt
+	| comment_stmt
+	| config_stmt
+	| source_stmt
+	| nl_or_eof
+;
+
+
+/* config entry */
+
+config_entry_start: T_CONFIG T_WORD
+{
+	struct symbol *sym = sym_lookup($2, 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), $2);
+};
+
+config_stmt: config_entry_start T_EOL config_option_list
+{
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+};
+
+config_option_list:
+	  /* empty */
+	| config_option_list config_option T_EOL
+	| config_option_list depends T_EOL
+	| config_option_list help
+	| config_option_list T_EOL
+{ };
+
+config_option: T_TRISTATE prompt_stmt_opt
+{
+	menu_set_type(S_TRISTATE);
+	printd(DEBUG_PARSE, "%s:%d:tristate\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_BOOLEAN prompt_stmt_opt
+{
+	menu_set_type(S_BOOLEAN);
+	printd(DEBUG_PARSE, "%s:%d:boolean\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_INT prompt_stmt_opt
+{
+	menu_set_type(S_INT);
+	printd(DEBUG_PARSE, "%s:%d:int\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_HEX prompt_stmt_opt
+{
+	menu_set_type(S_HEX);
+	printd(DEBUG_PARSE, "%s:%d:hex\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_STRING prompt_stmt_opt
+{
+	menu_set_type(S_STRING);
+	printd(DEBUG_PARSE, "%s:%d:string\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_PROMPT prompt if_expr
+{
+	menu_add_prop(P_PROMPT, $2, NULL, $3);
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+};
+
+config_option: T_DEFAULT symbol if_expr
+{
+	menu_add_prop(P_DEFAULT, NULL, $2, $3);
+	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
+};
+
+/* choice entry */
+
+choice: T_CHOICE
+{
+	struct symbol *sym = sym_lookup(NULL, 0);
+	sym->flags |= SYMBOL_CHOICE;
+	menu_add_entry(sym);
+	menu_add_prop(P_CHOICE, NULL, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+};
+
+choice_entry: choice T_EOL choice_option_list
+{
+	menu_end_entry();
+	menu_add_menu();
+};
+
+choice_end: end
+{
+	if (zconf_endtoken($1, T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+};
+
+choice_stmt:
+	  choice_entry choice_block choice_end T_EOL
+	| choice_entry choice_block
+{
+	printf("%s:%d: missing 'endchoice' for this 'choice' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+};
+
+choice_option_list:
+	  /* empty */
+	| choice_option_list choice_option T_EOL
+	| choice_option_list depends T_EOL
+	| choice_option_list help
+	| choice_option_list T_EOL
+;
+
+choice_option: T_PROMPT prompt if_expr
+{
+	menu_add_prop(P_PROMPT, $2, NULL, $3);
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+};
+
+choice_option: T_OPTIONAL
+{
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+};
+
+choice_option: T_DEFAULT symbol
+{
+	menu_add_prop(P_DEFAULT, NULL, $2, NULL);
+	//current_choice->prop->def = $2;
+	printd(DEBUG_PARSE, "%s:%d:default\n", zconf_curname(), zconf_lineno());
+};
+
+choice_block:
+	  /* empty */
+	| choice_block common_block
+;
+
+/* if entry */
+
+if: T_IF expr
+{
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	//current_entry->prompt = menu_add_prop(T_IF, NULL, NULL, $2);
+	menu_add_dep($2);
+	menu_end_entry();
+	menu_add_menu();
+};
+
+if_end: end
+{
+	if (zconf_endtoken($1, T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+};
+
+if_stmt:
+	  if T_EOL if_block if_end T_EOL
+	| if T_EOL if_block
+{
+	printf("%s:%d: missing 'endif' for this 'if' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+};
+
+if_block:
+	  /* empty */
+	| if_block common_block
+	| if_block menu_stmt
+	| if_block choice_stmt
+;
+
+/* menu entry */
+
+menu: T_MENU prompt
+{
+	menu_add_entry(NULL);
+	menu_add_prop(P_MENU, $2, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+};
+
+menu_entry: menu T_EOL depends_list
+{
+	menu_end_entry();
+	menu_add_menu();
+};
+
+menu_end: end
+{
+	if (zconf_endtoken($1, T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+};
+
+menu_stmt:
+	  menu_entry menu_block menu_end T_EOL
+	| menu_entry menu_block
+{
+	printf("%s:%d: missing 'endmenu' for this 'menu' statement\n", current_menu->file->name, current_menu->lineno);
+	zconfnerrs++;
+};
+
+menu_block:
+	  /* empty */
+	| menu_block common_block
+	| menu_block menu_stmt
+	| menu_block choice_stmt
+	| menu_block error T_EOL		{ zconfprint("invalid menu option"); yyerrok; }
+;
+
+source: T_SOURCE prompt
+{
+	$$ = $2;
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), $2);
+};
+
+source_stmt: source T_EOL
+{
+	zconf_nextfile($1);
+};
+
+/* comment entry */
+
+comment: T_COMMENT prompt
+{
+	menu_add_entry(NULL);
+	menu_add_prop(P_COMMENT, $2, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+};
+
+comment_stmt: comment T_EOL depends_list
+{
+	menu_end_entry();
+};
+
+/* help option */
+
+help_start: T_HELP T_EOL
+{
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+};
+
+help: help_start T_HELPTEXT
+{
+	current_entry->sym->help = $2;
+};
+
+/* depends option */
+
+depends_list:	  /* empty */
+		| depends_list depends T_EOL
+		| depends_list T_EOL
+{ };
+
+depends: T_DEPENDS T_ON expr
+{
+	menu_add_dep($3);
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+}
+	| T_DEPENDS expr
+{
+	menu_add_dep($2);
+	printd(DEBUG_PARSE, "%s:%d:depends\n", zconf_curname(), zconf_lineno());
+}
+	| T_REQUIRES expr
+{
+	menu_add_dep($2);
+	printd(DEBUG_PARSE, "%s:%d:requires\n", zconf_curname(), zconf_lineno());
+};
+
+/* prompt statement */
+
+prompt_stmt_opt:
+	  /* empty */
+	| prompt
+{
+	menu_add_prop(P_PROMPT, $1, NULL, NULL);
+}
+	| prompt T_IF expr
+{
+	menu_add_prop(P_PROMPT, $1, NULL, $3);
+};
+
+prompt:	  T_WORD
+	| T_STRING
+;
+
+end:	  T_ENDMENU		{ $$ = T_ENDMENU; }
+	| T_ENDCHOICE		{ $$ = T_ENDCHOICE; }
+	| T_ENDIF		{ $$ = T_ENDIF; }
+;
+
+nl_or_eof:
+	T_EOL | T_EOF;
+
+if_expr:  /* empty */			{ $$ = NULL; }
+	| T_IF expr			{ $$ = $2; }
+;
+
+expr:	  symbol				{ $$ = expr_alloc_symbol($1); }
+	| symbol T_EQUAL symbol			{ $$ = expr_alloc_comp(E_EQUAL, $1, $3); }
+	| symbol T_UNEQUAL symbol		{ $$ = expr_alloc_comp(E_UNEQUAL, $1, $3); }
+	| T_OPEN_PAREN expr T_CLOSE_PAREN	{ $$ = $2; }
+	| T_NOT expr				{ $$ = expr_alloc_one(E_NOT, $2); }
+	| expr T_OR expr			{ $$ = expr_alloc_two(E_OR, $1, $3); }
+	| expr T_AND expr			{ $$ = expr_alloc_two(E_AND, $1, $3); }
+;
+
+symbol:	  T_WORD	{ $$ = sym_lookup($1, 0); free($1); }
+	| T_STRING	{ $$ = sym_lookup($1, 1); free($1); }
+;
+
+%%
+
+void conf_parse(const char *name)
+{
+	zconf_initscan(name);
+
+	sym_init();
+	menu_init();
+	rootmenu.prompt = menu_add_prop(P_MENU, "Linux Kernel Configuration", NULL, NULL);
+
+	//zconfdebug = 1;
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	menu_finalize(&rootmenu);
+
+	modules_sym = sym_lookup("MODULES", 0);
+
+	sym_change_count = 1;
+}
+
+const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	}
+	return "<token>";
+} 
+
+static bool zconf_endtoken(int token, int starttoken, int endtoken)
+{
+	if (token != endtoken) {
+		zconfprint("unexpected '%s' within %s block", zconf_tokenname(token), zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconfprint("'%s' in different file than '%s'", zconf_tokenname(token), zconf_tokenname(starttoken));
+		zconfprint("location of the '%s'", zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno(), err);
+}
+
+void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	//sym->flags |= SYMBOL_PRINTED;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "choice\n");
+	else
+		fprintf(out, "config %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+#if 0
+	if (!expr_is_yes(sym->dep)) {
+		fputs("  depends ", out);
+		expr_fprint(sym->dep, out);
+		fputc('\n', out);
+	}
+#endif
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (prop->def) {
+				fputc(' ', out);
+				if (prop->def->flags & SYMBOL_CONST)
+					print_quoted_string(out, prop->def->name);
+				else
+					fputs(prop->def->name, out);
+			}
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs(" if ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			print_quoted_string(out, prop->def->name);
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs(" if ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (sym->help) {
+		int len = strlen(sym->help);
+		while (sym->help[--len] == '\n')
+			sym->help[len] = 0;
+		fprintf(out, "  help\n%s\n", sym->help);
+	}
+	fputc('\n', out);
+}
+
+void zconfdump(FILE *out)
+{
+	//struct file *file;
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			//case T_MAINMENU:
+			//	fputs("\nmainmenu ", out);
+			//	print_quoted_string(out, prop->text);
+			//	fputs("\n", out);
+			//	break;
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			//case T_SOURCE:
+			//	fputs("\nsource ", out);
+			//	print_quoted_string(out, prop->text);
+			//	fputs("\n", out);
+			//	break;
+			//case T_IF:
+			//	fputs("\nif\n", out);
+			default:
+				;
+			}
+			if (!expr_is_yes(E_EXPR(prop->visible))) {
+				fputs("  depends ", out);
+				expr_fprint(E_EXPR(prop->visible), out);
+				fputc('\n', out);
+			}
+			fputs("\n", out);
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "lex.zconf.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
diff --git a/extra/gcc-uClibc/Makefile b/extra/gcc-uClibc/Makefile
index 19d9a4dbd..d5113bd7c 100644
--- a/extra/gcc-uClibc/Makefile
+++ b/extra/gcc-uClibc/Makefile
@@ -27,15 +27,15 @@ gcc-uClibc.h: $(TOPDIR)/Config
 	@echo "#define TARGET_ARCH " \"$(TARGET_ARCH)\" >> gcc-uClibc.h
 	@echo "#define DYNAMIC_LINKER " \"$(DYNAMIC_LINKER)\" >> gcc-uClibc.h
 	@echo "#define BUILD_DYNAMIC_LINKER " \"$(UCLIBC_DIR)/lib/$(UCLIBC_LDSO)\" >> gcc-uClibc.h
-ifeq ($(strip $(HAS_MMU)),true)
-	@echo "#define HAS_MMU 1" >> gcc-uClibc.h
+ifeq ($(strip $(UCLIBC_HAS_MMU)),y)
+	@echo "#define __UCLIBC_HAS_MMU__ 1" >> gcc-uClibc.h
 else
-	@echo "#undef HAS_MMU" >> gcc-uClibc.h
+	@echo "#undef __UCLIBC_HAS_MMU__" >> gcc-uClibc.h
 endif
-ifeq ($(strip $(HAS_ELF)),true)
-	@echo "#define HAS_ELF 1" >> gcc-uClibc.h
+ifeq ($(strip $(HAS_ELF)),y)
+	@echo "#define __HAS_ELF__ 1" >> gcc-uClibc.h
 else
-	@echo "#undef HAS_ELF" >> gcc-uClibc.h
+	@echo "#undef __HAS_ELF__" >> gcc-uClibc.h
 endif
 
 gcc-uClibc: gcc-uClibc.h gcc-uClibc.c
diff --git a/extra/gcc-uClibc/gcc-uClibc.c b/extra/gcc-uClibc/gcc-uClibc.c
index 24f49d216..1974cc150 100644
--- a/extra/gcc-uClibc/gcc-uClibc.c
+++ b/extra/gcc-uClibc/gcc-uClibc.c
@@ -337,7 +337,7 @@ int main(int argc, char **argv)
 	}
 
 	if (linking && source_count) {
-#if defined HAVE_ELF && ! defined HAS_MMU
+#if defined __HAVE_ELF__ && ! defined __UCLIBC_HAS_MMU__
 	    gcc_argv[i++] = "-Wl,-elf2flt";
 #endif
 	    gcc_argv[i++] = nostdlib;
diff --git a/extra/locale/Makefile b/extra/locale/Makefile
index d97dba25b..bdad5cea7 100644
--- a/extra/locale/Makefile
+++ b/extra/locale/Makefile
@@ -5,7 +5,7 @@ include $(TOPDIR)Rules.mak
 
 CFLAGS_wc8bit=-DCTYPE_PACKED=1
 CFLAGS_mmap=
-ifeq ($(strip $(HAS_WCHAR)),true)
+ifeq ($(strip $(UCLIBC_HAS_WCHAR)),y)
     CFLAGS_wc8bit += -DDO_WIDE_CHAR=1
     CFLAGS_mmap += -D__WCHAR_ENABLED=1
 endif
diff --git a/include/features.h b/include/features.h
index ca3641688..f5fd52163 100644
--- a/include/features.h
+++ b/include/features.h
@@ -337,7 +337,7 @@
 #undef __need_uClibc_config_h
 
 /* Make sure users large file options agree with uClibc's configuration. */
-#ifndef __UCLIBC_HAVE_LFS__
+#ifndef __UCLIBC_HAS_LFS__
 
 /* If uClibc was built without large file support, output an error if
  * and 64-bit file offsets were requested, output an error.
@@ -371,7 +371,7 @@ uClibc was built without large file support enabled.
 
 /* Some nice features only work properly with ELF */
 #if defined _LIBC 
-#if defined HAVE_ELF	
+#if defined __HAVE_ELF__
 /* Define ALIASNAME as a weak alias for NAME. */
 #  define weak_alias(name, aliasname) _weak_alias (name, aliasname)
 #  define _weak_alias(name, aliasname) \
@@ -390,12 +390,12 @@ uClibc was built without large file support enabled.
 	asm (".section "  ".gnu.warning." #symbol  "\n\t.previous");	      \
 	    static const char __evoke_link_warning_##symbol[]		      \
 	    __attribute__ ((section (".gnu.warning." #symbol "\n\t#"))) = msg;
-#else /* !defined HAVE_ELF */
+#else /* !defined __HAVE_ELF__ */
 #  define strong_alias(name, aliasname) _strong_alias (name, aliasname)
 #  define weak_alias(name, aliasname) _strong_alias (name, aliasname)
 #  define _strong_alias(name, aliasname) \
-	__asm__(".global " C_SYMBOL_PREFIX #aliasname "\n" \
-                ".set " C_SYMBOL_PREFIX #aliasname "," C_SYMBOL_PREFIX #name);
+	__asm__(".global " __C_SYMBOL_PREFIX__ #aliasname "\n" \
+                ".set " __C_SYMBOL_PREFIX__ #aliasname "," __C_SYMBOL_PREFIX__ #name);
 #  define link_warning(symbol, msg) \
 	asm (".stabs \"" msg "\",30,0,0,0\n\t" \
 	      ".stabs \"" #symbol "\",1,0,0,0\n");
diff --git a/include/sys/cdefs.h b/include/sys/cdefs.h
index e1d732529..3ae52c7a8 100644
--- a/include/sys/cdefs.h
+++ b/include/sys/cdefs.h
@@ -124,7 +124,7 @@
 #if defined __GNUC__ && __GNUC__ >= 2
 
 # define __REDIRECT(name, proto, alias) name proto __asm__ (__ASMNAME (#alias))
-# define __ASMNAME(cname) C_SYMBOL_PREFIX cname
+# define __ASMNAME(cname) __C_SYMBOL_PREFIX__ cname
 
 /*
 #elif __SOME_OTHER_COMPILER__
diff --git a/ldso/Makefile b/ldso/Makefile
index c1c907101..d0a133bf7 100644
--- a/ldso/Makefile
+++ b/ldso/Makefile
@@ -27,14 +27,14 @@ ALL_SUBDIRS = ldso libdl util
 
 
 all:
-ifeq ($(strip $(BUILD_UCLIBC_LDSO)),true)
+ifeq ($(strip $(BUILD_UCLIBC_LDSO)),y)
 	$(MAKE) -C ldso;
 else
 	echo "Not building ld-uClibc"
 endif
 
 shared: utils
-ifeq ($(strip $(BUILD_UCLIBC_LDSO)),true)
+ifeq ($(strip $(BUILD_UCLIBC_LDSO)),y)
 	$(MAKE) -C libdl;
 else
 	echo "Not building libdl"
diff --git a/ldso/ldso/Makefile b/ldso/ldso/Makefile
index 262ec5073..3ecbe9f77 100644
--- a/ldso/ldso/Makefile
+++ b/ldso/ldso/Makefile
@@ -23,10 +23,8 @@
 
 
 TOPDIR=../../
-DOPIC=true
 include $(TOPDIR)Rules.mak
 LDSO_FULLNAME=ld-uClibc-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so
-LIBGCC:=$(shell $(CC) -print-libgcc-file-name)
 
 # Enable this to enable all the code needed to support traditional ldd
 # (i.e. where the shared library loader does all the heavy lifting)
diff --git a/libc/inet/Makefile b/libc/inet/Makefile
index 67699506a..efc8cb621 100644
--- a/libc/inet/Makefile
+++ b/libc/inet/Makefile
@@ -24,7 +24,7 @@
 TOPDIR=../../
 include $(TOPDIR)Rules.mak
 
-ifeq ($(strip $(INCLUDE_RPC)),true)
+ifeq ($(strip $(UCLIBC_HAS_RPC)),y)
 	DIRS=rpc
 else
 	DIRS=
diff --git a/libc/inet/rpc/Makefile b/libc/inet/rpc/Makefile
index 67691e4b6..0cfa64d8d 100644
--- a/libc/inet/rpc/Makefile
+++ b/libc/inet/rpc/Makefile
@@ -25,20 +25,7 @@ TOPDIR=../../../
 include $(TOPDIR)Rules.mak
 CFLAGS+=-I$(TOPDIR)libpthread/linuxthreads/sysdeps/pthread
 
-# If INCLUDE_FULL_RPC is not defined, default to `false' if shared
-# libraries are enabled, and `true' otherwise (because the main
-# advantage of not including everything is that it reduces the size of
-# shared libraries; the size of static libraries doesn't typically
-# matter as much, since they need not be present at runtime).
-ifeq ($(strip $(INCLUDE_FULL_RPC)),)
-  ifeq ($(strip $(HAVE_SHARED)),false)
-    INCLUDE_FULL_RPC = true
-  else
-    INCLUDE_FULL_RPC = false
-  endif
-endif
-
-ifeq ($(strip $(INCLUDE_FULL_RPC)),true)
+ifeq ($(strip $(UCLIBC_HAS_FULL_RPC)),y)
 CSRC :=auth_none.c auth_unix.c authunix_prot.c bindresvport.c \
 	clnt_generic.c clnt_perror.c clnt_raw.c clnt_simple.c clnt_tcp.c \
 	clnt_udp.c rpc_dtablesize.c get_myaddress.c getrpcent.c getrpcport.c \
diff --git a/libc/misc/Makefile b/libc/misc/Makefile
index 8278a5767..2a74a4e54 100644
--- a/libc/misc/Makefile
+++ b/libc/misc/Makefile
@@ -28,13 +28,13 @@ include $(TOPDIR)Rules.mak
 DIRS = assert ctype dirent file fnmatch glob internals lsearch \
        mntent syslog time utmp tsearch locale sysvipc statfs \
        error insremque ttyent gnu
-ifeq ($(strip $(INCLUDE_REGEX)),true)
+ifeq ($(strip $(UCLIBC_HAS_REGEX)),y)
 DIRS += regex
 endif
-ifeq ($(strip $(INCLUDE_THREADS)),true)
+ifeq ($(strip $(UCLIBC_HAS_THREADS)),y)
 DIRS += pthread
 endif
-ifeq ($(strip $(HAS_WCHAR)),true)
+ifeq ($(strip $(UCLIBC_HAS_WCHAR)),y)
 DIRS += wctype wchar
 endif
 
diff --git a/libc/misc/dirent/alphasort64.c b/libc/misc/dirent/alphasort64.c
index e98d7138a..bcae8108f 100644
--- a/libc/misc/dirent/alphasort64.c
+++ b/libc/misc/dirent/alphasort64.c
@@ -1,5 +1,5 @@
 #include <features.h>
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS != 64 
 #undef _FILE_OFFSET_BITS
 #define	_FILE_OFFSET_BITS   64
@@ -22,5 +22,5 @@ int alphasort64(const void * a, const void * b)
     return strcmp ((*(const struct dirent64 **) a)->d_name,
 	    (*(const struct dirent64 **) b)->d_name);
 }
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 
diff --git a/libc/misc/dirent/readdir64.c b/libc/misc/dirent/readdir64.c
index b845b8139..d30a4398f 100644
--- a/libc/misc/dirent/readdir64.c
+++ b/libc/misc/dirent/readdir64.c
@@ -1,5 +1,5 @@
 #include <features.h>
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS != 64 
 #undef _FILE_OFFSET_BITS
 #define	_FILE_OFFSET_BITS   64
@@ -68,4 +68,4 @@ all_done:
 	return de;
 }
 
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
diff --git a/libc/misc/dirent/readdir64_r.c b/libc/misc/dirent/readdir64_r.c
index 6735db8d8..f4aeb7869 100644
--- a/libc/misc/dirent/readdir64_r.c
+++ b/libc/misc/dirent/readdir64_r.c
@@ -1,5 +1,5 @@
 #include <features.h>
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS != 64 
 #undef _FILE_OFFSET_BITS
 #define	_FILE_OFFSET_BITS   64
@@ -75,5 +75,5 @@ all_done:
 #endif
         return((de != NULL)? 0 : ret);
 }
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 
diff --git a/libc/misc/dirent/scandir64.c b/libc/misc/dirent/scandir64.c
index 476193c94..d7543a61e 100644
--- a/libc/misc/dirent/scandir64.c
+++ b/libc/misc/dirent/scandir64.c
@@ -24,7 +24,7 @@
 */
 
 #include <features.h>
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS != 64 
 #undef _FILE_OFFSET_BITS
 #define	_FILE_OFFSET_BITS   64
@@ -99,5 +99,5 @@ int scandir64(const char *dir, struct dirent64 ***namelist,
 
     return pos;
 }
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 
diff --git a/libc/misc/glob/glob64.c b/libc/misc/glob/glob64.c
index 56d48444d..c053de4f0 100644
--- a/libc/misc/glob/glob64.c
+++ b/libc/misc/glob/glob64.c
@@ -1,6 +1,6 @@
 #include <features.h>
 
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS != 64 
 #undef _FILE_OFFSET_BITS
diff --git a/libc/misc/internals/Makefile b/libc/misc/internals/Makefile
index a33afef60..1e772ce60 100644
--- a/libc/misc/internals/Makefile
+++ b/libc/misc/internals/Makefile
@@ -43,7 +43,7 @@ ar-target: $(OBJS)
 interp.c: Makefile
 	echo "/* Force shared libraries to know about the correct library loader */" > interp.c
 	echo "#include <features.h>" >> interp.c
-	echo "#ifdef HAVE_ELF" >> interp.c
+	echo "#ifdef __HAVE_ELF__" >> interp.c
 	echo "const char __dl_ldso__[] __attribute__ ((section " \
 		"(\".interp\"))) =\""$(DYNAMIC_LINKER)"\";" >> interp.c
 	echo "#endif" >> interp.c
diff --git a/libc/misc/internals/tempname.c b/libc/misc/internals/tempname.c
index 31b16c18a..236a62e85 100644
--- a/libc/misc/internals/tempname.c
+++ b/libc/misc/internals/tempname.c
@@ -189,7 +189,7 @@ int __gen_tempname (char *tmpl, int kind)
 	    case __GT_FILE:
 		fd = open (tmpl, O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);
 		break;
-#if defined __UCLIBC_HAVE_LFS__
+#if defined __UCLIBC_HAS_LFS__
 	    case __GT_BIGFILE:
 		fd = open64 (tmpl, O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);
 		break;
diff --git a/libc/misc/locale/Makefile b/libc/misc/locale/Makefile
index 881b0c0e5..29c8cd5a0 100644
--- a/libc/misc/locale/Makefile
+++ b/libc/misc/locale/Makefile
@@ -29,7 +29,7 @@ MOBJ= setlocale.o localeconv.o _locale_init.o nl_langinfo.o
 
 OBJS= $(MOBJ)
 
-ifeq ($(HAS_LOCALE),true)
+ifeq ($(UCLIBC_HAS_LOCALE),y)
 	OBJS += locale_data.o
 endif
 
@@ -47,7 +47,7 @@ $(MOBJ): $(MSRC)
 $(OBJS): Makefile
 
 data:
-ifeq ($(HAS_LOCALE),true)
+ifeq ($(UCLIBC_HAS_LOCALE),y)
 	make -C $(TOPDIR)/extra/locale
 endif
 
diff --git a/libc/misc/statfs/Makefile b/libc/misc/statfs/Makefile
index e8fcf21e4..89eb7fd89 100644
--- a/libc/misc/statfs/Makefile
+++ b/libc/misc/statfs/Makefile
@@ -22,7 +22,7 @@
 TOPDIR=../../../
 include $(TOPDIR)Rules.mak
 
-ifeq ($(strip $(DOLFS)),true)
+ifeq ($(strip $(UCLIBC_HAS_LFS)),y)
 CSRC = fstatfs64.c statfs64.c statvfs.c statvfs64.c fstatvfs.c fstatvfs64.c
 else
 CSRC = statvfs.c fstatvfs.c
diff --git a/libc/misc/statfs/fstatfs64.c b/libc/misc/statfs/fstatfs64.c
index acc25d2e0..1040e1fe1 100644
--- a/libc/misc/statfs/fstatfs64.c
+++ b/libc/misc/statfs/fstatfs64.c
@@ -19,7 +19,7 @@
 
 #include <features.h>
 
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS != 64 
 #undef _FILE_OFFSET_BITS
@@ -62,5 +62,5 @@ int fstatfs64 (int fd, struct statfs64 *buf)
     return 0;
 }
 
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 
diff --git a/libc/misc/statfs/fstatvfs64.c b/libc/misc/statfs/fstatvfs64.c
index 84f68ae9b..ed4b63234 100644
--- a/libc/misc/statfs/fstatvfs64.c
+++ b/libc/misc/statfs/fstatvfs64.c
@@ -19,7 +19,7 @@
 
 #include <features.h>
 
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS != 64 
 #undef _FILE_OFFSET_BITS
 #define	_FILE_OFFSET_BITS   64
diff --git a/libc/misc/statfs/statfs64.c b/libc/misc/statfs/statfs64.c
index b237624c3..0b954c675 100644
--- a/libc/misc/statfs/statfs64.c
+++ b/libc/misc/statfs/statfs64.c
@@ -36,7 +36,7 @@
 #include <stddef.h>
 #include <sys/statfs.h>
 
-#if defined __UCLIBC_HAVE_LFS__
+#if defined __UCLIBC_HAS_LFS__
 
 /* Return information about the filesystem on which FILE resides.  */
 int statfs64 (const char *file, struct statfs64 *buf)
diff --git a/libc/misc/statfs/statvfs64.c b/libc/misc/statfs/statvfs64.c
index 1e3ec0a36..78d1a4c3f 100644
--- a/libc/misc/statfs/statvfs64.c
+++ b/libc/misc/statfs/statvfs64.c
@@ -19,7 +19,7 @@
 
 #include <features.h>
 
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS != 64 
 #undef _FILE_OFFSET_BITS
 #define	_FILE_OFFSET_BITS   64
diff --git a/libc/misc/time/Makefile b/libc/misc/time/Makefile
index 841c19600..b187e5555 100644
--- a/libc/misc/time/Makefile
+++ b/libc/misc/time/Makefile
@@ -29,7 +29,7 @@ MOBJ= asctime.o asctime_r.o clock.o ctime.o ctime_r.o gmtime.o gmtime_r.o \
 	localtime.o localtime_r.o mktime.o strftime.o strptime.o tzset.o \
 	_time_t2tm.o __time_tm.o _time_mktime.o
 
-ifeq ($(HAS_FLOATING_POINT),true)
+ifeq ($(UCLIBC_HAS_FLOATS),y)
 	MOBJ += difftime.o 
 endif
 
diff --git a/libc/pwd_grp/Makefile b/libc/pwd_grp/Makefile
index 5efa1414e..c34142d6b 100644
--- a/libc/pwd_grp/Makefile
+++ b/libc/pwd_grp/Makefile
@@ -28,7 +28,7 @@ CSRC= pwent.c getpwnam.c getpwuid.c putpwent.c getpw.c fgetpwent.c \
 	__getgrent.c grent.c getgrnam.c getgrgid.c fgetgrent.c \
 	initgroups.c __getpwent_r.c
 
-ifeq ($(HAS_SHADOW),true)
+ifeq ($(HAS_SHADOW),y)
 CSRC+= lckpwdf.c spent.c getspnam.c getspuid.c putspent.c sgetspent.c \
 	fgetspent.c __getspent_r.c __sgetspent_r.c
 endif
diff --git a/libc/stdio/Makefile b/libc/stdio/Makefile
index 011f3a7f8..09cb0710a 100644
--- a/libc/stdio/Makefile
+++ b/libc/stdio/Makefile
@@ -24,21 +24,8 @@
 TOPDIR=../../
 include $(TOPDIR)Rules.mak
 
-# Set to true to use the old vfprintf instead of the new.  The old is roughly
-# C89 compliant, but doesn't deal with qualifiers on %n and doesn't deal with
-# %h correctly or %hh at all on the interger conversions.  But on i386 it is
-# over 1.5k smaller than the new code.  Of course, the new code fixes the
-# above mentioned deficiencies and adds custom specifier support similar to
-# glibc, as well as handling positional args.  This option is here temporarily
-# until the configuration system gets rewritten.  Note also that the old
-# vfprintf code will be rewritten at some point to bring it into at least C89
-# standards compliance.
-
-USE_OLD_VFPRINTF = false
-
 # Note: The *64.o objects are empty when compiled without large file support.
-#       To not build them at all, remove the appropriate line from the MOBJ
-#       definition and uncomment the DOLFS test below.
+#
 
 # Note: Use the libpthreads of: flockfile.o ftrylockfile.o funlockfile.o
 #       Also, maybe move __fsetlocking.o as well?
@@ -60,15 +47,11 @@ MOBJ = fclose.o fflush.o fopen.o freopen.o perror.o remove.o \
 	_stdio_fsfopen.o _stdio_fdout.o _uintmaxtostr.o _stdio_strerror_r.o \
 	getdelim.o getline.o ctermid.o
 
-# ifeq ($(DOLFS),true)
-# 	MOBJ += fopen64.o freopen64.o ftello64.o fseeko64.o fsetpos64.o fgetpos64.o
-# endif
-
 MSRC2= printf.c
 MOBJ2=  vsnprintf.o vdprintf.o vasprintf.o vprintf.o vsprintf.o \
 	fprintf.o  snprintf.o  dprintf.o  asprintf.o  printf.o  sprintf.o
 
-ifneq ($(USE_OLD_VFPRINTF),true)
+ifneq ($(USE_OLD_VFPRINTF),y)
 	MOBJ2 += _ppfs_init.o _ppfs_prepargs.o _ppfs_setargs.o \
 		 _ppfs_parsespec.o _do_one_spec.o vfprintf.o \
 		 _store_inttype.o _load_inttype.o \
@@ -77,7 +60,7 @@ endif
 
 
 
-ifeq ($(HAS_FLOATING_POINT),true)
+ifeq ($(UCLIBC_HAS_FLOATS),y)
 	MOBJ2 += _dtostr.o
 endif
 
@@ -85,7 +68,7 @@ MSRC3=scanf.c
 MOBJ3=scanf.o sscanf.o fscanf.o vscanf.o vsscanf.o vfscanf.o
 
 CSRC=popen.c tmpfile.c tmpnam.c tmpnam_r.c tempnam.c
-ifeq ($(USE_OLD_VFPRINTF),true)
+ifeq ($(USE_OLD_VFPRINTF),y)
 	CSRC += old_vfprintf.c
 endif
 COBJS=$(patsubst %.c,%.o, $(CSRC))
diff --git a/libc/stdio/tmpfile.c b/libc/stdio/tmpfile.c
index d7940b139..5484d5d6c 100644
--- a/libc/stdio/tmpfile.c
+++ b/libc/stdio/tmpfile.c
@@ -46,6 +46,6 @@ FILE * tmpfile (void)
 
     return f;
 }
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 weak_alias(tmpfile, tmpfile64);
 #endif
diff --git a/libc/stdlib/Makefile b/libc/stdlib/Makefile
index aa311afcb..5bf12b322 100644
--- a/libc/stdlib/Makefile
+++ b/libc/stdlib/Makefile
@@ -24,15 +24,21 @@
 TOPDIR=../../
 include $(TOPDIR)Rules.mak
 
-DIRS = $(MALLOC)
-ALL_SUBDIRS = malloc malloc-930716
+DIRS:=
+ifeq ($(MALLOC),y)
+    DIRS+=malloc
+endif
+ifeq ($(MALLOC_930716),y)
+    DIRS+=malloc-930716
+endif
+
 
 MSRC = stdlib.c
 MOBJ = abs.o labs.o atoi.o atol.o strtol.o strtoul.o _stdlib_strto_l.o \
        qsort.o bsearch.o
 MOBJ +=  llabs.o atoll.o strtoll.o strtoull.o _stdlib_strto_ll.o
 
-ifeq ($(HAS_WCHAR),true)
+ifeq ($(UCLIBC_HAS_WCHAR),y)
 	MOBJ += mblen.o mbtowc.o wctomb.o mbstowcs.o wcstombs.o \
 		_stdlib_mb_cur_max.o 
 endif
@@ -46,7 +52,7 @@ CSRC =	abort.c getenv.c mkdtemp.c mktemp.c realpath.c mkstemp.c mkstemp64.c \
 	drand48_r.c erand48.c erand48_r.c jrand48.c jrand48_r.c lrand48.c \
 	lrand48_r.c mrand48.c mrand48_r.c nrand48.c nrand48_r.c rand_r.c \
 	srand48.c srand48_r.c calloc.c valloc.c
-ifeq ($(HAS_FLOATING_POINT),true)
+ifeq ($(UCLIBC_HAS_FLOATS),y)
 	CSRC += strtod.c strtof.c strtold.c
 endif
 COBJS=$(patsubst %.c,%.o, $(CSRC))
diff --git a/libc/stdlib/getpt.c b/libc/stdlib/getpt.c
index f4e52f672..71d7d6c5f 100644
--- a/libc/stdlib/getpt.c
+++ b/libc/stdlib/getpt.c
@@ -23,7 +23,7 @@
 #include <unistd.h>
 #include <paths.h>
 
-#if !defined ASSUME_DEVPTS
+#if !defined __ASSUME_DEVPTS__
 # include <sys/statfs.h>
 
 /* Constant that identifies the `devpts' filesystem.  */
@@ -37,7 +37,7 @@
 /* Directory containing the UNIX98 pseudo terminals.  */
 #define _PATH_DEVPTS _PATH_DEV "pts"
 
-#if !defined UNIX98PTY_ONLY
+#if !defined __UNIX98PTY_ONLY__
 /* Prototype for function that opens BSD-style master pseudo-terminals.  */
 int __bsd_getpt (void);
 #endif
@@ -46,19 +46,19 @@ int __bsd_getpt (void);
 int
 getpt (void)
 {
-#if !defined UNIX98PTY_ONLY
+#if !defined __UNIX98PTY_ONLY__
   static int have_no_dev_ptmx;
 #endif
   int fd;
 
-#if !defined UNIX98PTY_ONLY
+#if !defined __UNIX98PTY_ONLY__
   if (!have_no_dev_ptmx)
 #endif
     {
       fd = open (_PATH_DEVPTMX, O_RDWR);
       if (fd != -1)
 	{
-#if defined ASSUME_DEVPTS
+#if defined __ASSUME_DEVPTS__
 	  return fd;
 #else
 	  struct statfs fsbuf;
@@ -80,14 +80,14 @@ getpt (void)
 	  /* If /dev/pts is not mounted then the UNIX98 pseudo terminals
              are not usable.  */
 	  close (fd);
-#if !defined UNIX98PTY_ONLY
+#if !defined __UNIX98PTY_ONLY__
 	  have_no_dev_ptmx = 1;
 #endif
 #endif
 	}
       else
 	{
-#if !defined UNIX98PTY_ONLY
+#if !defined __UNIX98PTY_ONLY__
 	  if (errno == ENOENT || errno == ENODEV)
 	    have_no_dev_ptmx = 1;
 	  else
@@ -96,12 +96,12 @@ getpt (void)
 	}
     }
 
-#if !defined UNIX98PTY_ONLY
+#if !defined __UNIX98PTY_ONLY__
   return __bsd_getpt ();
 #endif
 }
 
-#if !defined UNIX98PTY_ONLY
+#if !defined __UNIX98PTY_ONLY__
 # define PTYNAME1 "pqrstuvwxyzabcde";
 # define PTYNAME2 "0123456789abcdef";
 
diff --git a/libc/stdlib/grantpt.c b/libc/stdlib/grantpt.c
index d49f0af4f..5b4427a0c 100644
--- a/libc/stdlib/grantpt.c
+++ b/libc/stdlib/grantpt.c
@@ -19,10 +19,10 @@
 #include <limits.h>
 #include <stdlib.h>
 
-/* If ASSUME_DEVPTS is defined, grantpt() reduces to a stub since we
+/* If __ASSUME_DEVPTS__ is defined, grantpt() reduces to a stub since we
    assume that the devfs/devpts filesystem automatically manages the
    permissions. */
-#if !defined ASSUME_DEVPTS
+#if !defined __ASSUME_DEVPTS__
 #include <sys/statfs.h>
 
 /* Constant that identifies the `devpts' filesystem.  */
@@ -47,7 +47,7 @@ static int pts_name (int fd, char **pts, size_t buf_len);
 int
 grantpt (int fd)
 {
-#if !defined ASSUME_DEVPTS
+#if !defined __ASSUME_DEVPTS__
   struct statfs fsbuf;
 # ifdef PATH_MAX
   char _buf[PATH_MAX];
@@ -70,7 +70,7 @@ grantpt (int fd)
   return 0;
 }
 
-#if !defined ASSUME_DEVPTS
+#if !defined __ASSUME_DEVPTS__
 # define grantpt __unix_grantpt
 # include "unix_grantpt.c"
 #endif
diff --git a/libc/stdlib/ptsname.c b/libc/stdlib/ptsname.c
index 7f9b04e93..2472edb3f 100644
--- a/libc/stdlib/ptsname.c
+++ b/libc/stdlib/ptsname.c
@@ -30,7 +30,7 @@
 #include <unistd.h>
 
 
-#if !defined UNIX98PTY_ONLY
+#if !defined __UNIX98PTY_ONLY__
 
 /* Check if DEV corresponds to a master pseudo terminal device.  */
 #define MASTER_P(Dev)                                                         \
@@ -64,7 +64,7 @@ extern const char _ptyname2[];
 int ptsname_r (int fd, char *buf, size_t buflen)
 {
   int save_errno = errno;
-#if !defined UNIX98PTY_ONLY
+#if !defined __UNIX98PTY_ONLY__
   struct stat st;
 #endif
   int ptyno;
@@ -75,14 +75,14 @@ int ptsname_r (int fd, char *buf, size_t buflen)
       return EINVAL;
     }
 
-#if !defined UNIX98PTY_ONLY
+#if !defined __UNIX98PTY_ONLY__
   if (!isatty (fd))
     {
       errno = ENOTTY;
       return ENOTTY;
     }
 #elif !defined TIOCGPTN
-# error "UNIX98PTY_ONLY enabled but TIOCGPTN ioctl not supported by your kernel."
+# error "__UNIX98PTY_ONLY__ enabled but TIOCGPTN ioctl not supported by your kernel."
 #endif
 #ifdef TIOCGPTN
   if (ioctl (fd, TIOCGPTN, &ptyno) == 0)
@@ -113,7 +113,7 @@ int ptsname_r (int fd, char *buf, size_t buflen)
       return 0;
     }
 #endif
-#if defined UNIX98PTY_ONLY
+#if defined __UNIX98PTY_ONLY__
   else
     {
       /* If the ioctl fails it wasn't a Unix 98 master PTY */
diff --git a/libc/string/Makefile b/libc/string/Makefile
index 6c29bb9ec..7bd2ea3dd 100644
--- a/libc/string/Makefile
+++ b/libc/string/Makefile
@@ -46,7 +46,7 @@ CSRC=strxfrm.c
 COBJS=$(patsubst %.c,%.o, $(CSRC))
 OBJS=$(MOBJ) $(MOBJ1) $(MOBJ2) $(COBJS) $(MOBJW)
 
-ifeq ($(HAS_WCHAR),true)
+ifeq ($(UCLIBC_HAS_WCHAR),y)
 	OBJS += $(MOBJW2)
 endif
 
diff --git a/libc/sysdeps/linux/common/Makefile b/libc/sysdeps/linux/common/Makefile
index 6e6f716a2..5139b52f5 100644
--- a/libc/sysdeps/linux/common/Makefile
+++ b/libc/sysdeps/linux/common/Makefile
@@ -25,7 +25,7 @@ TOPDIR=../../../../
 include $(TOPDIR)Rules.mak
 
 SAFECFLAGS=$(WARNINGS) $(OPTIMIZATION) -fno-builtin
-ifeq ($(strip $(DOPIC)),true)
+ifeq ($(strip $(DOPIC)),y)
 SAFECFLAGS+=-fPIC
 endif
 
@@ -35,7 +35,7 @@ CSRC=	waitpid.c getdnnm.c gethstnm.c getcwd.c \
 	cmsg_nxthdr.c longjmp.c open64.c ftruncate64.c \
 	truncate64.c getrlimit64.c setrlimit64.c creat64.c mmap64.c \
 	llseek.c pread_write.c _exit.c setuid.c sync.c getdirname.c
-ifneq ($(strip $(EXCLUDE_BRK)),true)
+ifneq ($(strip $(EXCLUDE_BRK)),y)
 CSRC+=sbrk.c
 endif
 COBJS=$(patsubst %.c,%.o, $(CSRC))
diff --git a/libc/sysdeps/linux/common/bits/posix_opt.h b/libc/sysdeps/linux/common/bits/posix_opt.h
index 4f7d78eb9..73fa007d2 100644
--- a/libc/sysdeps/linux/common/bits/posix_opt.h
+++ b/libc/sysdeps/linux/common/bits/posix_opt.h
@@ -130,14 +130,14 @@
 #define _LFS_ASYNCHRONOUS_IO	1
 
 /* The LFS support in asynchronous I/O is also available.  */
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 # define _LFS64_ASYNCHRONOUS_IO	1
 #else
 # undef _LFS64_ASYNCHRONOUS_IO
 #endif
 
 /* The rest of the LFS is also available.  */
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 # define _LFS_LARGEFILE		1
 # define _LFS64_LARGEFILE	1
 # define _LFS64_STDIO		1
diff --git a/libc/sysdeps/linux/common/bits/uClibc_stdio.h b/libc/sysdeps/linux/common/bits/uClibc_stdio.h
index 24f2ec39e..83c082f75 100644
--- a/libc/sysdeps/linux/common/bits/uClibc_stdio.h
+++ b/libc/sysdeps/linux/common/bits/uClibc_stdio.h
@@ -36,9 +36,9 @@
 #define __STDIO_THREADSAFE
 #endif
 
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 #define __STDIO_LARGE_FILES
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 
 #ifdef __UCLIBC_HAS_WCHAR__
 #define __STDIO_WIDE
@@ -47,22 +47,22 @@
 /* Make sure defines related to large files are consistent. */
 #ifdef _LIBC
 
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 #undef __USE_LARGEFILE
 #undef __USE_LARGEFILE64
 #undef __USE_FILE_OFFSET64
 /* if we're actually building uClibc with large file support, only define... */
 #define __USE_LARGEFILE64	1
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 
 #else  /* not _LIBC */
 
-#ifndef __UCLIBC_HAVE_LFS__
+#ifndef __UCLIBC_HAS_LFS__
 #if defined(__LARGEFILE64_SOURCE) || defined(__USE_LARGEFILE64) \
     || defined(__USE_FILE_OFFSET64)
 #error Sorry... uClibc was built without large file support!
 #endif
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 
 #endif /* _LIBC */
 
diff --git a/libc/sysdeps/linux/common/creat64.c b/libc/sysdeps/linux/common/creat64.c
index 28b897384..deeda3892 100644
--- a/libc/sysdeps/linux/common/creat64.c
+++ b/libc/sysdeps/linux/common/creat64.c
@@ -20,7 +20,7 @@
 #include <fcntl.h>
 #include <sys/types.h>
 
-#if defined __UCLIBC_HAVE_LFS__
+#if defined __UCLIBC_HAS_LFS__
 
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS != 64 
 #undef _FILE_OFFSET_BITS
@@ -42,5 +42,5 @@ int creat64 (const char *file, mode_t mode)
 {
     return open64 (file, O_WRONLY|O_CREAT|O_TRUNC, mode);
 }
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 
diff --git a/libc/sysdeps/linux/common/ftruncate64.c b/libc/sysdeps/linux/common/ftruncate64.c
index fb95450c1..703ba490b 100644
--- a/libc/sysdeps/linux/common/ftruncate64.c
+++ b/libc/sysdeps/linux/common/ftruncate64.c
@@ -19,7 +19,7 @@
 #include <stdint.h>
 #include <sys/syscall.h>
 
-#if defined __UCLIBC_HAVE_LFS__ && defined __NR_ftruncate64
+#if defined __UCLIBC_HAS_LFS__ && defined __NR_ftruncate64
 #ifndef INLINE_SYSCALL
 #define INLINE_SYSCALL(name, nr, args...) __syscall_ftruncate64 (args)
 #define __NR___syscall_ftruncate64 __NR_ftruncate64
@@ -41,4 +41,4 @@ int ftruncate64 (int fd, __off64_t length)
 #else
 #error Your machine is not 64 bit or 32 bit, I am dazed and confused.
 #endif
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
diff --git a/libc/sysdeps/linux/common/getdirname.c b/libc/sysdeps/linux/common/getdirname.c
index 6ea76cca9..4cc528fc7 100644
--- a/libc/sysdeps/linux/common/getdirname.c
+++ b/libc/sysdeps/linux/common/getdirname.c
@@ -31,7 +31,7 @@ char *
 get_current_dir_name (void)
 {
 	char *pwd;
-#if defined __UCLIBC_HAVE_LFS__
+#if defined __UCLIBC_HAS_LFS__
 	struct stat64 dotstat, pwdstat;
 #else
 	struct stat dotstat, pwdstat;
@@ -39,7 +39,7 @@ get_current_dir_name (void)
 
 	pwd = getenv ("PWD");
 	if (pwd != NULL
-#if defined __UCLIBC_HAVE_LFS__
+#if defined __UCLIBC_HAS_LFS__
 		&& stat64 (".", &dotstat) == 0
 		&& stat64 (pwd, &pwdstat) == 0
 #else
diff --git a/libc/sysdeps/linux/common/getrlimit64.c b/libc/sysdeps/linux/common/getrlimit64.c
index 2d423f5f3..1af7870af 100644
--- a/libc/sysdeps/linux/common/getrlimit64.c
+++ b/libc/sysdeps/linux/common/getrlimit64.c
@@ -34,7 +34,7 @@
 #include <sys/types.h>
 #include <sys/resource.h>
 
-#if defined __UCLIBC_HAVE_LFS__
+#if defined __UCLIBC_HAS_LFS__
 
 /* Put the soft and hard limits for RESOURCE in *RLIMITS.
    Returns 0 if successful, -1 if not (and sets errno).  */
diff --git a/libc/sysdeps/linux/common/initfini.c b/libc/sysdeps/linux/common/initfini.c
index 4a6ebee75..4ff7c8218 100644
--- a/libc/sysdeps/linux/common/initfini.c
+++ b/libc/sysdeps/linux/common/initfini.c
@@ -46,7 +46,7 @@
 
 /* Declare symbols as hidden. Hidden symbols are only seen by
  * the link editor and not by the dynamic loader. */
-#ifdef HAVE_DOT_HIDDEN
+#ifdef __HAVE_DOT_HIDDEN__
 #  define HIDDEN(func)  asm (".hidden  " #func );
 #else
 #  define HIDDEN(func)
diff --git a/libc/sysdeps/linux/common/llseek.c b/libc/sysdeps/linux/common/llseek.c
index 63534fa71..8683157b9 100644
--- a/libc/sysdeps/linux/common/llseek.c
+++ b/libc/sysdeps/linux/common/llseek.c
@@ -34,7 +34,7 @@
 #include <sys/syscall.h>
 
 
-#if defined __NR__llseek && defined __UCLIBC_HAVE_LFS__
+#if defined __NR__llseek && defined __UCLIBC_HAS_LFS__
 
 #ifndef INLINE_SYSCALL
 #define INLINE_SYSCALL(name, nr, args...) __syscall_llseek (args)
diff --git a/libc/sysdeps/linux/common/mmap64.c b/libc/sysdeps/linux/common/mmap64.c
index 33a4f404a..73407c4cf 100644
--- a/libc/sysdeps/linux/common/mmap64.c
+++ b/libc/sysdeps/linux/common/mmap64.c
@@ -22,7 +22,7 @@
 #include <sysdep.h>
 #include <sys/mman.h>
 
-#if defined __UCLIBC_HAVE_LFS__
+#if defined __UCLIBC_HAS_LFS__
 
 #if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS != 64 
 #undef _FILE_OFFSET_BITS
@@ -48,5 +48,5 @@ __ptr_t mmap64(__ptr_t addr, size_t len, int prot, int flags, int fd, __off64_t
 
     return mmap (addr, len, prot, flags, fd, (off_t) offset);
 }
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 
diff --git a/libc/sysdeps/linux/common/open64.c b/libc/sysdeps/linux/common/open64.c
index 840ec6938..543aa138f 100644
--- a/libc/sysdeps/linux/common/open64.c
+++ b/libc/sysdeps/linux/common/open64.c
@@ -25,7 +25,7 @@
 #define O_LARGEFILE	0100000
 #endif
 
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 extern int __libc_open (__const char *file, int oflag, mode_t mode);
 
 /* Open FILE with access OFLAG.  If OFLAG includes O_CREAT,
@@ -45,4 +45,4 @@ int __libc_open64 (const char *file, int oflag, ...)
   return __libc_open(file, oflag | O_LARGEFILE, mode);
 }
 weak_alias (__libc_open64, open64);
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
diff --git a/libc/sysdeps/linux/common/pread_write.c b/libc/sysdeps/linux/common/pread_write.c
index 801359276..98a059416 100644
--- a/libc/sysdeps/linux/common/pread_write.c
+++ b/libc/sysdeps/linux/common/pread_write.c
@@ -53,14 +53,14 @@ ssize_t __libc_pread(int fd, void *buf, size_t count, off_t offset)
 }
 weak_alias (__libc_pread, pread)
 
-#if defined __UCLIBC_HAVE_LFS__ 
+#if defined __UCLIBC_HAS_LFS__ 
 ssize_t __libc_pread64(int fd, void *buf, size_t count, off64_t offset)
 { 
 	return(__syscall_pread(fd, buf, count,
 			__LONG_LONG_PAIR((off_t)(offset>>32),(off_t)(offset&0xffffffff))));
 }
 weak_alias (__libc_pread64, pread64)
-#endif /* __UCLIBC_HAVE_LFS__  */
+#endif /* __UCLIBC_HAS_LFS__  */
 
 #endif /* __NR_pread */
 
@@ -78,14 +78,14 @@ ssize_t __libc_pwrite(int fd, const void *buf, size_t count, off_t offset)
 }
 weak_alias (__libc_pwrite, pwrite)
 
-#if defined __UCLIBC_HAVE_LFS__ 
+#if defined __UCLIBC_HAS_LFS__ 
 ssize_t __libc_pwrite64(int fd, const void *buf, size_t count, off64_t offset)
 { 
 	return(__syscall_pwrite(fd, buf, count,
 			__LONG_LONG_PAIR((off_t)(offset>>32),(off_t)(offset&0xffffffff))));
 }
 weak_alias (__libc_pwrite64, pwrite64)
-#endif /* __UCLIBC_HAVE_LFS__  */
+#endif /* __UCLIBC_HAS_LFS__  */
 #endif /* __NR_pwrite */
 
 
@@ -128,7 +128,7 @@ static ssize_t __fake_pread_write(int fd, void *buf,
 	return(result);
 }
 
-#if defined __UCLIBC_HAVE_LFS__ 
+#if defined __UCLIBC_HAS_LFS__ 
 static ssize_t __fake_pread_write64(int fd, void *buf, 
 		size_t count, off64_t offset, int do_pwrite)
 {
@@ -163,7 +163,7 @@ static ssize_t __fake_pread_write64(int fd, void *buf,
 	__set_errno (save_errno);
 	return result;
 }
-#endif /* __UCLIBC_HAVE_LFS__  */
+#endif /* __UCLIBC_HAS_LFS__  */
 #endif /*  ! defined __NR_pread || ! defined __NR_pwrite */
 
 #ifndef __NR_pread
@@ -173,13 +173,13 @@ ssize_t __libc_pread(int fd, void *buf, size_t count, off_t offset)
 }
 weak_alias (__libc_pread, pread)
 
-#if defined __UCLIBC_HAVE_LFS__ 
+#if defined __UCLIBC_HAS_LFS__ 
 ssize_t __libc_pread64(int fd, void *buf, size_t count, off64_t offset)
 { 
 	return(__fake_pread_write64(fd, buf, count, offset, 0));
 }
 weak_alias (__libc_pread64, pread64)
-#endif /* __UCLIBC_HAVE_LFS__  */
+#endif /* __UCLIBC_HAS_LFS__  */
 #endif /* ! __NR_pread */
 
 
@@ -190,12 +190,12 @@ ssize_t __libc_pwrite(int fd, const void *buf, size_t count, off_t offset)
 }
 weak_alias (__libc_pwrite, pwrite)
 
-#if defined __UCLIBC_HAVE_LFS__ 
+#if defined __UCLIBC_HAS_LFS__ 
 ssize_t __libc_pwrite64(int fd, const void *buf, size_t count, off64_t offset)
 { 
 	return(__fake_pread_write64(fd, (void*)buf, count, offset, 1));
 }
 weak_alias (__libc_pwrite64, pwrite64)
-#endif /* __UCLIBC_HAVE_LFS__  */
+#endif /* __UCLIBC_HAS_LFS__  */
 #endif /* ! __NR_pwrite */
 
diff --git a/libc/sysdeps/linux/common/setrlimit64.c b/libc/sysdeps/linux/common/setrlimit64.c
index 29fad3e36..8d190f573 100644
--- a/libc/sysdeps/linux/common/setrlimit64.c
+++ b/libc/sysdeps/linux/common/setrlimit64.c
@@ -35,7 +35,7 @@
 #include <sys/types.h>
 #include <sys/resource.h>
 
-#if defined __UCLIBC_HAVE_LFS__
+#if defined __UCLIBC_HAS_LFS__
 
 /* Set the soft and hard limits for RESOURCE to *RLIMITS.
    Only the super-user can increase hard limits.
diff --git a/libc/sysdeps/linux/common/syscalls.c b/libc/sysdeps/linux/common/syscalls.c
index 0229880a6..e0dbdf39d 100644
--- a/libc/sysdeps/linux/common/syscalls.c
+++ b/libc/sysdeps/linux/common/syscalls.c
@@ -962,7 +962,7 @@ _syscall2(int, getitimer, __itimer_which_t, which, struct itimerval *, value);
 #include <unistd.h>
 #include <sys/stat.h>
 _syscall2(int, stat, const char *, file_name, struct stat *, buf);
-#if ! defined __NR_stat64 && defined __UCLIBC_HAVE_LFS__
+#if ! defined __NR_stat64 && defined __UCLIBC_HAS_LFS__
 weak_alias(stat, stat64);
 #endif
 #endif
@@ -972,7 +972,7 @@ weak_alias(stat, stat64);
 #include <unistd.h>
 #include <sys/stat.h>
 _syscall2(int, lstat, const char *, file_name, struct stat *, buf);
-#if ! defined __NR_lstat64 && defined __UCLIBC_HAVE_LFS__
+#if ! defined __NR_lstat64 && defined __UCLIBC_HAS_LFS__
 weak_alias(lstat, lstat64);
 #endif
 #endif
@@ -982,7 +982,7 @@ weak_alias(lstat, lstat64);
 #include <unistd.h>
 #include <sys/stat.h>
 _syscall2(int, fstat, int, filedes, struct stat *, buf);
-#if ! defined __NR_fstat64 && defined __UCLIBC_HAVE_LFS__
+#if ! defined __NR_fstat64 && defined __UCLIBC_HAS_LFS__
 weak_alias(fstat, fstat64);
 #endif
 #endif
@@ -1621,29 +1621,29 @@ int getrlimit (__rlimit_resource_t resource, struct rlimit *rlimits)
 
 //#define __NR_stat64             195
 #ifdef L_stat64
-#if defined __NR_stat64 && defined __UCLIBC_HAVE_LFS__
+#if defined __NR_stat64 && defined __UCLIBC_HAS_LFS__
 #include <unistd.h>
 #include <sys/stat.h>
 _syscall2(int, stat64, const char *, file_name, struct stat64 *, buf);
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 #endif
 
 //#define __NR_lstat64            196
 #ifdef L_lstat64
-#if defined __NR_lstat64 && defined __UCLIBC_HAVE_LFS__
+#if defined __NR_lstat64 && defined __UCLIBC_HAS_LFS__
 #include <unistd.h>
 #include <sys/stat.h>
 _syscall2(int, lstat64, const char *, file_name, struct stat64 *, buf);
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 #endif
 
 //#define __NR_fstat64            197
 #ifdef L_fstat64
-#if defined __NR_fstat64 && defined __UCLIBC_HAVE_LFS__
+#if defined __NR_fstat64 && defined __UCLIBC_HAS_LFS__
 #include <unistd.h>
 #include <sys/stat.h>
 _syscall2(int, fstat64, int, filedes, struct stat64 *, buf);
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 #endif
 
 
@@ -1679,16 +1679,16 @@ _syscall2(int, pivot_root, const char *, new_root, const char *, put_old)
 
 //#define __NR_getdents64		220
 #ifdef L_getdents64
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 #include <unistd.h>
 #include <dirent.h>
 _syscall3(int, getdents64, int, fd, char *, dirp, size_t, count);
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
 #endif
 
 //#define __NR_fcntl64		221
 #ifdef L__fcntl64
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 #ifdef __NR_fcntl64
 #define __NR__fcntl64 __NR_fcntl64
 #include <stdarg.h>
diff --git a/libc/sysdeps/linux/common/truncate64.c b/libc/sysdeps/linux/common/truncate64.c
index 3205f748d..fa5000107 100644
--- a/libc/sysdeps/linux/common/truncate64.c
+++ b/libc/sysdeps/linux/common/truncate64.c
@@ -19,7 +19,7 @@
 #include <stdint.h>
 #include <sys/syscall.h>
 
-#if defined __UCLIBC_HAVE_LFS__ && defined __NR_truncate64
+#if defined __UCLIBC_HAS_LFS__ && defined __NR_truncate64
 #ifndef INLINE_SYSCALL
 #define INLINE_SYSCALL(name, nr, args...) __syscall_truncate64 (args)
 #define __NR___syscall_truncate64 __NR_truncate64
@@ -40,4 +40,4 @@ int truncate64 (const char * path, __off64_t length)
 #else
 #error Your machine is not 64 bit or 32 bit, I am dazed and confused.
 #endif
-#endif /* __UCLIBC_HAVE_LFS__ */
+#endif /* __UCLIBC_HAS_LFS__ */
diff --git a/libc/sysdeps/linux/cris/Makefile b/libc/sysdeps/linux/cris/Makefile
index 737ca1f9e..6b9931ebb 100644
--- a/libc/sysdeps/linux/cris/Makefile
+++ b/libc/sysdeps/linux/cris/Makefile
@@ -20,7 +20,7 @@ CRT0=crt0.c
 CRT0_OBJ=$(patsubst %.c,%.o, $(CRT0))
 
 SSRC= setjmp.S __longjmp.S clone.S sysdep.S syscall.S
-ifeq ($(UNIFIED_SYSCALL),true)
+ifeq ($(UNIFIED_SYSCALL),y)
 	SSRC += __uClibc_syscall.S
 endif
 SOBJS=$(patsubst %.S,%.o, $(SSRC))
diff --git a/libc/sysdeps/linux/h8300/Makefile b/libc/sysdeps/linux/h8300/Makefile
index 68093e132..d6d0b7c2a 100644
--- a/libc/sysdeps/linux/h8300/Makefile
+++ b/libc/sysdeps/linux/h8300/Makefile
@@ -63,7 +63,7 @@ headers:
 
 clean:
 	rm -f *.[oa] *~ core
-ifeq ($(strip $(HAVE_ELF)),false)
+ifeq ($(strip $(HAVE_ELF)),n)
 	rm -f $(TOPDIR)/include/float.h
 endif
 
diff --git a/libc/sysdeps/linux/h8300/crt0.S b/libc/sysdeps/linux/h8300/crt0.S
index cbd40f317..2fe9d0d53 100644
--- a/libc/sysdeps/linux/h8300/crt0.S
+++ b/libc/sysdeps/linux/h8300/crt0.S
@@ -46,7 +46,7 @@ __exit:
  */
 empty_func:
 	rts
-#if defined(HAVE_ELF)
+#if defined(__HAVE_ELF__)
 	.weak atexit
 	atexit = empty_func
 #else
diff --git a/libc/sysdeps/linux/h8300/vfork.S b/libc/sysdeps/linux/h8300/vfork.S
index 889b43ace..aa8520d89 100644
--- a/libc/sysdeps/linux/h8300/vfork.S
+++ b/libc/sysdeps/linux/h8300/vfork.S
@@ -10,7 +10,7 @@
 	.align 2
 	.globl _errno
 	.globl _vfork
-#if defined HAVE_ELF
+#if defined __HAVE_ELF__
 	.type	 vfork,@function
 #endif
 _vfork:
diff --git a/libc/sysdeps/linux/i960/README b/libc/sysdeps/linux/i960/README
index db4567a55..0ec5bb63a 100644
--- a/libc/sysdeps/linux/i960/README
+++ b/libc/sysdeps/linux/i960/README
@@ -16,8 +16,8 @@ prepended underscore
 --------------------
 
 As the i960 compiler prepends an underscore to symbols, it is critical that
-the Config file define C_SYMBOL_PREFIX as
-    C_SYMBOL_PREFIX = _
+the Config file define __C_SYMBOL_PREFIX__ as
+    __C_SYMBOL_PREFIX__ = _
 to make sure that underscores are applied to symbol names when needed.
 
 
diff --git a/libc/sysdeps/linux/m68k/Makefile b/libc/sysdeps/linux/m68k/Makefile
index 751f7072c..7130c58d6 100644
--- a/libc/sysdeps/linux/m68k/Makefile
+++ b/libc/sysdeps/linux/m68k/Makefile
@@ -28,7 +28,7 @@ ASFLAGS=$(CFLAGS)
 # If you're looking for vfork(), it is defined in include/unistd.h
 
 
-ifeq ($(HAS_MMU),true)
+ifeq ($(UCLIBC_HAS_MMU),y)
 CRT0=crt0.c
 CRT0_OBJ=$(patsubst %.c,%.o, $(CRT0))
 else
@@ -54,7 +54,7 @@ ar-target: $(OBJS) $(CRT0_OBJ)
 	$(AR) $(ARFLAGS) $(LIBC) $(OBJS)
 	cp $(CRT0_OBJ) $(TOPDIR)lib/$(CRT0_OBJ)
 
-ifeq ($(HAS_MMU),true)
+ifeq ($(UCLIBC_HAS_MMU),y)
 $(CRT0_OBJ): %.o : %.c
 else
 $(CRT0_OBJ): %.o : %.S
@@ -71,7 +71,7 @@ $(COBJS): %.o : %.c
 	$(STRIPTOOL) -x -R .note -R .comment $*.o
 
 headers:
-ifeq ($(strip $(HAVE_ELF)),false)
+ifeq ($(strip $(HAVE_ELF)),n)
 	echo "Working around compiler bug in the m68k-pic-coff toolchain"
 	cd $(TOPDIR)/include && ln -fs ../libc/sysdeps/linux/m68k/float.h .
 endif
@@ -80,7 +80,7 @@ endif
 clean:
 	rm -f *.[oa] *~ core
 	rm -f bits/sysnum.h
-ifeq ($(strip $(HAVE_ELF)),false)
+ifeq ($(strip $(HAVE_ELF)),n)
 	rm -f $(TOPDIR)/include/float.h
 endif
 
diff --git a/libc/sysdeps/linux/m68k/clone.S b/libc/sysdeps/linux/m68k/clone.S
index d1e4fd850..731587db4 100644
--- a/libc/sysdeps/linux/m68k/clone.S
+++ b/libc/sysdeps/linux/m68k/clone.S
@@ -76,7 +76,7 @@ thread_start:
 	trap	#0
 	/*jsr    exit*/
 
-#if defined(HAVE_ELF)
+#if defined(__HAVE_ELF__)
 	.weak clone
 	clone = __clone
 #else
diff --git a/libc/sysdeps/linux/m68k/crt0.S b/libc/sysdeps/linux/m68k/crt0.S
index c09146fa5..8d7f6802d 100644
--- a/libc/sysdeps/linux/m68k/crt0.S
+++ b/libc/sysdeps/linux/m68k/crt0.S
@@ -53,7 +53,7 @@ __exit:
  */
 empty_func:
 	rts
-#if defined(HAVE_ELF)
+#if defined(__HAVE_ELF__)
 	.weak atexit
 	atexit = empty_func
 #else
diff --git a/libc/sysdeps/linux/m68k/vfork.S b/libc/sysdeps/linux/m68k/vfork.S
index 9aacf5916..5db163bf5 100644
--- a/libc/sysdeps/linux/m68k/vfork.S
+++ b/libc/sysdeps/linux/m68k/vfork.S
@@ -11,7 +11,7 @@
 	.align 2
 	.globl errno
 	.globl vfork
-#if defined HAVE_ELF
+#if defined __HAVE_ELF__
 	.type	 vfork,@function
 #endif
 vfork:
diff --git a/libc/sysdeps/linux/powerpc/Makefile b/libc/sysdeps/linux/powerpc/Makefile
index da11f940c..2cf67849d 100644
--- a/libc/sysdeps/linux/powerpc/Makefile
+++ b/libc/sysdeps/linux/powerpc/Makefile
@@ -21,7 +21,7 @@
 # other sundry sources.  Files within this library are copyright by their
 # respective copyright holders.
 
-USE_CRT0_C=y
+USE_CRT0_C=true
 
 TOPDIR=../../../../
 include $(TOPDIR)Rules.mak
@@ -29,7 +29,7 @@ ASFLAGS=$(CFLAGS)
 
 TARGET_MACHINE_TYPE=$(shell $(CC) -dumpmachine)
 
-ifeq ($(USE_CRT0_C),y)
+ifeq ($(USE_CRT0_C),true)
 CRT0=crt0.c
 CRT0_OBJ=$(patsubst %.c,%.o, $(CRT0))
 else
@@ -55,7 +55,7 @@ ar-target: $(OBJS) $(CRT0_OBJ)
 	cp $(CRT0_OBJ) $(TOPDIR)lib/
 
 
-ifeq ($(USE_CRT0_C),y)
+ifeq ($(USE_CRT0_C),true)
 $(CRT0_OBJ): %.o : %.c
 else
 $(CRT0_OBJ): %.o : %.S
diff --git a/libc/sysdeps/linux/sh/sysdep.h b/libc/sysdeps/linux/sh/sysdep.h
index 759753415..f88cedefb 100644
--- a/libc/sysdeps/linux/sh/sysdep.h
+++ b/libc/sysdeps/linux/sh/sysdep.h
@@ -21,7 +21,7 @@
 #include <bits/uClibc_config.h>
 
 /* Define a macro we can use to construct the asm name for a C symbol.  */
-#ifdef	NO_UNDERSCORES
+#ifdef	__NO_UNDERSCORES__
 #ifdef	__STDC__
 #define C_LABEL(name)		name##:
 #else
@@ -53,7 +53,7 @@
 
 /* Syntactic details of assembler.  */
 
-#ifdef HAVE_ELF
+#ifdef __HAVE_ELF__
 
 #define ALIGNARG(log2) log2
 /* For ELF we need the `.type' directive to make shared libs work right.  */
@@ -95,7 +95,7 @@
 #define CALL_MCOUNT		/* Do nothing.  */
 #endif
 
-#ifdef	NO_UNDERSCORES
+#ifdef	__NO_UNDERSCORES__
 /* Since C identifiers are not normally prefixed with an underscore
    on this system, the asm identifier `syscall_error' intrudes on the
    C name space.  Make sure we use an innocuous name.  */
diff --git a/libc/unistd/Makefile b/libc/unistd/Makefile
index 11a33cecf..0d05e6d49 100644
--- a/libc/unistd/Makefile
+++ b/libc/unistd/Makefile
@@ -29,7 +29,7 @@ CSRC=execl.c execlp.c execv.c execvep.c execvp.c execle.c \
 	sleep.c usleep.c getpass.c sysconf_src.c getlogin.c \
 	fpathconf.c confstr.c pathconf.c swab.c usershell.c \
 	getopt.c getsubopt.c
-ifeq ($(strip $(HAS_MMU)),true)
+ifeq ($(strip $(UCLIBC_HAS_MMU)),y)
     CSRC+=daemon.c
 endif
 
diff --git a/libc/unistd/daemon.c b/libc/unistd/daemon.c
index bfad7a363..d4c2e0448 100644
--- a/libc/unistd/daemon.c
+++ b/libc/unistd/daemon.c
@@ -48,6 +48,11 @@ int daemon( int nochdir, int noclose )
 	if (setsid() == -1)
 		return(-1);
 
+	/* Make certain we are not a session leader, or else we
+	 * might reacquire a controlling terminal */
+	if (fork())
+		_exit(0);
+
 	if (!nochdir)
 		chdir("/");
 
diff --git a/libc/unistd/fpathconf.c b/libc/unistd/fpathconf.c
index f896e934b..2f6cf7214 100644
--- a/libc/unistd/fpathconf.c
+++ b/libc/unistd/fpathconf.c
@@ -196,7 +196,7 @@ long int fpathconf(int fd, int name)
 #endif
 
 	case _PC_ASYNC_IO:
-#if defined _POSIX_ASYNC_IO && defined __UCLIBC_HAVE_LFS__ 
+#if defined _POSIX_ASYNC_IO && defined __UCLIBC_HAS_LFS__ 
 	    {
 		/* AIO is only allowed on regular files and block devices.  */
 		struct stat st;
diff --git a/libc/unistd/pathconf.c b/libc/unistd/pathconf.c
index d7fa99f50..affec4e69 100644
--- a/libc/unistd/pathconf.c
+++ b/libc/unistd/pathconf.c
@@ -200,7 +200,7 @@ long int pathconf(const char *path, int name)
 #endif
 
 	case _PC_ASYNC_IO:
-#if defined _POSIX_ASYNC_IO && defined __UCLIBC_HAVE_LFS__ 
+#if defined _POSIX_ASYNC_IO && defined __UCLIBC_HAS_LFS__ 
 	    {
 		/* AIO is only allowed on regular files and block devices.  */
 		struct stat st;
diff --git a/libm/Makefile b/libm/Makefile
index 4c6f27924..7723b180d 100644
--- a/libm/Makefile
+++ b/libm/Makefile
@@ -47,7 +47,7 @@ LIBM_SHARED=libm.so
 LIBM_SHARED_FULLNAME=libm-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so
 CFLAGS+=-D_IEEE_LIBM -D_ISOC99_SOURCE -D_SVID_SOURCE
 
-ifeq ($(strip $(DO_C99_MATH)),true)
+ifeq ($(strip $(DO_C99_MATH)),y)
 CSRC =   e_acos.c e_acosh.c e_asin.c e_atan2.c e_atanh.c e_cosh.c\
          e_exp.c e_fmod.c e_gamma.c e_gamma_r.c e_hypot.c e_j0.c\
          e_j1.c e_jn.c e_lgamma.c e_lgamma_r.c e_log.c e_log10.c\
@@ -78,7 +78,7 @@ COBJS=$(patsubst %.c,%.o, $(CSRC))
 OBJS=$(COBJS)
 
 
-ifneq ($(strip $(HAS_FLOATING_POINT)),true)
+ifneq ($(strip $(UCLIBC_HAS_FLOATS)),y)
 all:  clean subdirs
 else
 all: $(OBJS) $(LIBM) subdirs
diff --git a/libm/powerpc/Makefile b/libm/powerpc/Makefile
index 58ab7fbf5..10dacb07e 100644
--- a/libm/powerpc/Makefile
+++ b/libm/powerpc/Makefile
@@ -37,7 +37,7 @@ include $(TOPDIR)Rules.mak
 LIBM=../libm.a
 CFLAGS+=-D_IEEE_LIBM -D_ISOC99_SOURCE -D_SVID_SOURCE
 
-ifeq ($(strip $(DO_C99_MATH)),true)
+ifeq ($(strip $(DO_C99_MATH)),y)
 CSRC = s_ceil.c s_floor.c s_ldexp.c s_frexp.c s_logb.c s_modf.c w_scalb.c s_copysign.c s_rint.c
 else
 CSRC =
@@ -46,7 +46,7 @@ COBJS=$(patsubst %.c,%.o, $(CSRC))
 OBJS=$(COBJS)
 
 
-ifneq ($(strip $(HAS_FLOATING_POINT)),true)
+ifneq ($(strip $(UCLIBC_HAS_FLOATS)),y)
 all:  clean
 else
 all: $(OBJS) $(LIBM)
diff --git a/libpthread/Makefile b/libpthread/Makefile
index 7edf34f66..c76b0a8cd 100644
--- a/libpthread/Makefile
+++ b/libpthread/Makefile
@@ -29,15 +29,15 @@ LIBTHREAD_DB_SHARED=libthread_db.so
 LIBTHREAD_DB_SHARED_FULLNAME=libthread_db-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so
 
 DIRS=
-ifeq ($(strip $(INCLUDE_THREADS)),true)
+ifeq ($(strip $(UCLIBC_HAS_THREADS)),y)
 	DIRS+=linuxthreads
-ifeq ($(strip $(DODEBUG)),true)
+ifeq ($(strip $(DODEBUG)),y)
 	DIRS+=linuxthreads_db
 endif
 endif
 
 GCC_LIB_DIR = $(dir $(shell $(CC) -print-libgcc-file-name ))
-ifeq ($(strip $(DOPIC)),true)
+ifeq ($(strip $(DOPIC)),y)
     START_FILES  = $(TOPDIR)lib/crti.o     $(GCC_LIB_DIR)crtbeginS.o
     END_FILES    = $(GCC_LIB_DIR)crtendS.o $(TOPDIR)lib/crtn.o
 else
diff --git a/libpthread/linuxthreads/attr.c b/libpthread/linuxthreads/attr.c
index 2907a56a8..db5809cbc 100644
--- a/libpthread/linuxthreads/attr.c
+++ b/libpthread/linuxthreads/attr.c
@@ -50,7 +50,7 @@ int pthread_attr_init(pthread_attr_t *attr)
 
 /* uClibc: leave out this for now. */
 #if DO_PTHREAD_VERSIONING_WITH_UCLIBC
-#if defined HAVE_ELF && defined PIC && defined DO_VERSIONING
+#if defined __HAVE_ELF__ && defined PIC && defined DO_VERSIONING
 default_symbol_version (__pthread_attr_init_2_1, pthread_attr_init, GLIBC_2.1);
 
 int __pthread_attr_init_2_0(pthread_attr_t *attr)
diff --git a/libpthread/linuxthreads/weaks.c b/libpthread/linuxthreads/weaks.c
index 5281a2a5b..80ee11185 100644
--- a/libpthread/linuxthreads/weaks.c
+++ b/libpthread/linuxthreads/weaks.c
@@ -30,7 +30,7 @@ extern void __pthread_return_void __P ((void));
  */
 
 /* Those are pthread functions which return 0 if successful. */
-//#if defined HAVE_ELF && defined PIC && defined DO_VERSIONING
+//#if defined __HAVE_ELF__ && defined PIC && defined DO_VERSIONING
 //weak_alias (__pthread_return_0, __libc_pthread_attr_init_2_0)
 //symbol_version (__libc_pthread_attr_init_2_0, pthread_attr_init, GLIBC_2.0);
 //weak_alias (__pthread_return_0, __libc_pthread_attr_init_2_1)
diff --git a/libpthread/linuxthreads/wrapsyscall.c b/libpthread/linuxthreads/wrapsyscall.c
index ba6d1b860..fa5b24dc4 100644
--- a/libpthread/linuxthreads/wrapsyscall.c
+++ b/libpthread/linuxthreads/wrapsyscall.c
@@ -90,7 +90,7 @@ CANCELABLE_SYSCALL (int, fsync, (int fd), (fd))
 CANCELABLE_SYSCALL (off_t, lseek, (int fd, off_t offset, int whence),
 		    (fd, offset, whence))
 
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 /* lseek64(2).  */
 CANCELABLE_SYSCALL (off64_t, lseek64, (int fd, off64_t offset, int whence),
 		    (fd, offset, whence))
@@ -112,7 +112,7 @@ CANCELABLE_SYSCALL_VA (int, open, (const char *pathname, int flags, ...),
 		       (pathname, flags, va_arg (ap, mode_t)), flags)
 
 
-#ifdef __UCLIBC_HAVE_LFS__
+#ifdef __UCLIBC_HAS_LFS__
 /* open64(3).  */
 CANCELABLE_SYSCALL_VA (int, open64, (const char *pathname, int flags, ...),
 		       (pathname, flags, va_arg (ap, mode_t)), flags)
@@ -129,7 +129,7 @@ CANCELABLE_SYSCALL (ssize_t, pread, (int fd, void *buf, size_t count,
 		    (fd, buf, count, offset))
 
 
-#if defined __UCLIBC_HAVE_LFS__ && defined __NR_pread64
+#if defined __UCLIBC_HAS_LFS__ && defined __NR_pread64
 /* pread64(3).  */
 CANCELABLE_SYSCALL (ssize_t, pread64, (int fd, void *buf, size_t count,
 				       off64_t offset),
@@ -142,7 +142,7 @@ CANCELABLE_SYSCALL (ssize_t, pwrite, (int fd, const void *buf, size_t n,
 		    (fd, buf, n, offset))
 
 
-#if defined __UCLIBC_HAVE_LFS__ && defined __NR_pwrited64
+#if defined __UCLIBC_HAS_LFS__ && defined __NR_pwrited64
 /* pwrite64(3).  */
 CANCELABLE_SYSCALL (ssize_t, pwrite64, (int fd, const void *buf, size_t n,
 					off64_t offset),
diff --git a/libutil/Makefile b/libutil/Makefile
index ab85a242d..e3126e055 100644
--- a/libutil/Makefile
+++ b/libutil/Makefile
@@ -30,7 +30,7 @@ LIBUTIL_SHARED=libutil.so
 LIBUTIL_SHARED_FULLNAME=libutil-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so
 
 CSRC=login.c login_tty.c logout.c logwtmp.c openpty.c
-ifeq ($(strip $(HAS_MMU)),true)
+ifeq ($(strip $(UCLIBC_HAS_MMU)),y)
     CSRC+=forkpty.c
 endif
 OBJS=$(patsubst %.c,%.o, $(CSRC))