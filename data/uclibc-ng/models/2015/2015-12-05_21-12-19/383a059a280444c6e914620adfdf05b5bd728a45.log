"2015-12-05 21:12:19 +0100"
diff --git a/Rules.mak b/Rules.mak
index 973a890bb..7dc13c17e 100644
--- a/Rules.mak
+++ b/Rules.mak
@@ -439,10 +439,6 @@ ifeq ($(TARGET_ARCH),i960)
 	OPTIMIZATION+=-mh -mint32 #-fsigned-char
 endif
 
-ifeq ($(TARGET_ARCH),e1)
-	OPTIMIZATION+=-mgnu-param
-endif
-
 ifeq ($(TARGET_ARCH),cris)
 	CPU_LDFLAGS-$(CONFIG_CRIS)+=-Wl,-mcrislinux
 	CPU_LDFLAGS-$(CONFIG_CRISV32)+=-Wl,-mcrislinux
diff --git a/extra/Configs/Config.e1 b/extra/Configs/Config.e1
deleted file mode 100644
index 284bbfaee..000000000
--- a/extra/Configs/Config.e1
+++ /dev/null
@@ -1,16 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see extra/config/Kconfig-language.txt
-#
-
-config TARGET_ARCH
-	string
-	default "e1"
-
-config FORCE_OPTIONS_FOR_ARCH
-	bool
-	default y
-	select ARCH_BIG_ENDIAN
-	select ARCH_HAS_NO_MMU
-	select ARCH_HAS_NO_SHARED
-	select ARCH_HAS_DEPRECATED_SYSCALLS
diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
index df99a5c88..48df4b742 100644
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -21,7 +21,6 @@ choice
 	default TARGET_avr32 if DESIRED_TARGET_ARCH = "avr32"
 	default TARGET_bfin if DESIRED_TARGET_ARCH = "bfin"
 	default TARGET_cris if DESIRED_TARGET_ARCH = "cris"
-	default TARGET_e1 if DESIRED_TARGET_ARCH = "e1"
 	default TARGET_frv if DESIRED_TARGET_ARCH = "frv"
 	default TARGET_h8300 if DESIRED_TARGET_ARCH = "h8300"
 	default TARGET_hppa if DESIRED_TARGET_ARCH = "hppa"
@@ -68,9 +67,6 @@ config TARGET_c6x
 config TARGET_cris
 	bool "cris"
 
-#config TARGET_e1
-#	bool "e1 (BROKEN)"
-
 #config TARGET_frv
 #	bool "frv (BROKEN)"
 
@@ -156,10 +152,6 @@ if TARGET_cris
 source "extra/Configs/Config.cris"
 endif
 
-if TARGET_e1
-source "extra/Configs/Config.e1"
-endif
-
 if TARGET_frv
 source "extra/Configs/Config.frv"
 endif
diff --git a/extra/Configs/defconfigs/e1/defconfig b/extra/Configs/defconfigs/e1/defconfig
deleted file mode 100644
index e204c8778..000000000
--- a/extra/Configs/defconfigs/e1/defconfig
+++ /dev/null
@@ -1 +0,0 @@
-TARGET_e1=y
diff --git a/libc/sysdeps/linux/e1/Makefile b/libc/sysdeps/linux/e1/Makefile
deleted file mode 100644
index 29d1c9e47..000000000
--- a/libc/sysdeps/linux/e1/Makefile
+++ /dev/null
@@ -1,56 +0,0 @@
-# Makefile for uClibc
-#
-# Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
-#
-# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
-
-TOPDIR=../../../../
-include $(TOPDIR)Rules.mak
-
-#FIXME -- this arch should include its own crti.S and crtn.S
-UCLIBC_CTOR_DTOR=n
-
-# If you're looking for vfork(), it is defined in include/unistd.h
-
-CRT_SRC := crt0.S
-CRT_OBJ := crt0.o
-CTOR_TARGETS := $(TOPDIR)lib/crti.o $(TOPDIR)lib/crtn.o
-
-# why is crt1.c listed in CSRC ?
-CSRC := crt1.c syscalls.c longjmp.c setjmp.c
-OBJS := $(patsubst %.c,%.o, $(CSRC))
-
-OBJ_LIST := ../../../obj.sysdeps.$(TARGET_ARCH)
-
-all: $(OBJ_LIST) $(CTOR_TARGETS)
-
-$(OBJ_LIST): $(OBJS) $(CRT_OBJ)
-	$(STRIPTOOL) -x -R .note -R .comment $^
-	$(INSTALL) -d $(TOPDIR)lib/
-	cp $(CRT_OBJ) $(TOPDIR)lib/
-	echo $(patsubst %, sysdeps/linux/$(TARGET_ARCH)/%, $(OBJS)) > $@
-
-$(CRT_OBJ): %.o : %.S
-	$(CC) $(ASFLAGS) -c $< -o $@
-
-$(OBJS): %.o : %.c
-	$(CC) $(CFLAGS) -c $< -o $@
-
-ifeq ($(UCLIBC_CTOR_DTOR),y)
-$(TOPDIR)lib/crti.o: crti.S
-	$(INSTALL) -d $(TOPDIR)lib/
-	$(CC) $(ASFLAGS) $(SSP_DISABLE_FLAGS) -c $< -o $@
-
-$(TOPDIR)lib/crtn.o: crtn.S
-	$(INSTALL) -d $(TOPDIR)lib/
-	$(CC) $(ASFLAGS) $(SSP_DISABLE_FLAGS) -c $< -o $@
-else
-$(CTOR_TARGETS):
-	$(INSTALL) -d $(TOPDIR)lib/
-	$(AR) $(ARFLAGS) $@
-endif
-
-headers:
-
-clean:
-	$(RM) *.o *~ core
diff --git a/libc/sysdeps/linux/e1/bits/endian.h b/libc/sysdeps/linux/e1/bits/endian.h
deleted file mode 100644
index 0d38c1caa..000000000
--- a/libc/sysdeps/linux/e1/bits/endian.h
+++ /dev/null
@@ -1,7 +0,0 @@
-/* e1 is big-endian.  */
-
-#ifndef _ENDIAN_H
-# error "Never use <bits/endian.h> directly; include <endian.h> instead."
-#endif
-
-#define __BYTE_ORDER __BIG_ENDIAN
diff --git a/libc/sysdeps/linux/e1/bits/fcntl.h b/libc/sysdeps/linux/e1/bits/fcntl.h
deleted file mode 100644
index 2e0e6ba60..000000000
--- a/libc/sysdeps/linux/e1/bits/fcntl.h
+++ /dev/null
@@ -1,234 +0,0 @@
-/* O_*, F_*, FD_* bit values for Linux.
-   Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef	_FCNTL_H
-# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
-#endif
-
-
-#include <sys/types.h>
-
-/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
-   located on an ext2 file system */
-#define O_ACCMODE	   0003
-#define O_RDONLY	     00
-#define O_WRONLY	     01
-#define O_RDWR		     02
-#define O_CREAT		   0100	/* not fcntl */
-#define O_EXCL		   0200	/* not fcntl */
-#define O_NOCTTY	   0400	/* not fcntl */
-#define O_TRUNC		  01000	/* not fcntl */
-#define O_APPEND	  02000
-#define O_NONBLOCK	  04000
-#define O_NDELAY	O_NONBLOCK
-#define O_SYNC		 010000
-#define O_FSYNC		 O_SYNC
-#define O_ASYNC		 020000
-
-#ifdef __USE_GNU
-# define O_DIRECTORY	 040000	/* Must be a directory.	 */
-# define O_NOFOLLOW	0100000	/* Do not follow links.	 */
-# define O_DIRECT	0200000	/* Direct disk access.	*/
-#endif
-
-/* For now Linux has synchronisity options for data and read operations.
-   We define the symbols here but let them do the same as O_SYNC since
-   this is a superset.	*/
-#if defined __USE_POSIX199309 || defined __USE_UNIX98
-# define O_DSYNC	O_SYNC	/* Synchronize data.  */
-# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
-#endif
-
-#ifdef __USE_LARGEFILE64
-# define O_LARGEFILE	0400000
-#endif
-
-/* Values for the second argument to `fcntl'.  */
-#define F_DUPFD		0	/* Duplicate file descriptor.  */
-#define F_GETFD		1	/* Get file descriptor flags.  */
-#define F_SETFD		2	/* Set file descriptor flags.  */
-#define F_GETFL		3	/* Get file status flags.  */
-#define F_SETFL		4	/* Set file status flags.  */
-#ifndef __USE_FILE_OFFSET64
-# define F_GETLK	5	/* Get record locking info.  */
-# define F_SETLK	6	/* Set record locking info (non-blocking).  */
-# define F_SETLKW	7	/* Set record locking info (blocking).	*/
-#else
-# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
-# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
-# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
-#endif
-#define F_GETLK64	12	/* Get record locking info.  */
-#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
-#define F_SETLKW64	14	/* Set record locking info (blocking).	*/
-
-#if defined __USE_BSD || defined __USE_XOPEN2K
-# define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
-# define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
-#endif
-
-#ifdef __USE_GNU
-# define F_SETSIG	10	/* Set number of signal to be sent.  */
-# define F_GETSIG	11	/* Get number of signal to be sent.  */
-#endif
-
-#ifdef __USE_GNU
-# define F_SETLEASE	1024	/* Set a lease.	 */
-# define F_GETLEASE	1025	/* Enquire what lease is active.  */
-# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
-# define F_DUPFD_CLOEXEC 1030	/* Duplicate file descriptor with
-				   close-on-exit set on new fd.  */
-# define F_SETPIPE_SZ	1031    /* Set pipe page size array.  */
-# define F_GETPIPE_SZ	1032    /* Get pipe page size array.  */
-#endif
-
-/* For F_[GET|SET]FL.  */
-#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
-
-/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
-#define F_RDLCK		0	/* Read lock.  */
-#define F_WRLCK		1	/* Write lock.	*/
-#define F_UNLCK		2	/* Remove lock.	 */
-
-/* For old implementation of bsd flock().  */
-#define F_EXLCK		4	/* or 3 */
-#define F_SHLCK		8	/* or 4 */
-
-#ifdef __USE_BSD
-/* Operations for bsd flock(), also used by the kernel implementation.	*/
-# define LOCK_SH	1	/* shared lock */
-# define LOCK_EX	2	/* exclusive lock */
-# define LOCK_NB	4	/* or'd with one of the above to prevent
-				   blocking */
-# define LOCK_UN	8	/* remove lock */
-#endif
-
-#ifdef __USE_GNU
-# define LOCK_MAND	32	/* This is a mandatory flock:	*/
-# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
-# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
-# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
-#endif
-
-#ifdef __USE_GNU
-/* Types of directory notifications that may be requested with F_NOTIFY.  */
-# define DN_ACCESS	0x00000001	/* File accessed.  */
-# define DN_MODIFY	0x00000002	/* File modified.  */
-# define DN_CREATE	0x00000004	/* File created.  */
-# define DN_DELETE	0x00000008	/* File removed.  */
-# define DN_RENAME	0x00000010	/* File renamed.  */
-# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
-# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
-#endif
-
-struct flock
-  {
-    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
-    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
-#ifndef __USE_FILE_OFFSET64
-    __off_t l_start;	/* Offset where the lock begins.  */
-    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
-#else
-    __off64_t l_start;	/* Offset where the lock begins.  */
-    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
-#endif
-    __pid_t l_pid;	/* Process holding the lock.  */
-  };
-
-#ifdef __USE_LARGEFILE64
-struct flock64
-  {
-    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
-    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
-    __off64_t l_start;	/* Offset where the lock begins.  */
-    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
-    __pid_t l_pid;	/* Process holding the lock.  */
-  };
-#endif
-
-/* Define some more compatibility macros to be backward compatible with
-   BSD systems which did not managed to hide these kernel macros.  */
-#ifdef	__USE_BSD
-# define FAPPEND	O_APPEND
-# define FFSYNC		O_FSYNC
-# define FASYNC		O_ASYNC
-# define FNONBLOCK	O_NONBLOCK
-# define FNDELAY	O_NDELAY
-#endif /* Use BSD.  */
-
-/* Advise to `posix_fadvise'.  */
-#ifdef __USE_XOPEN2K
-# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
-# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
-# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
-# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
-# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
-# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
-#endif
-
-
-#if defined __USE_GNU && defined __UCLIBC_LINUX_SPECIFIC__
-/* Flags for SYNC_FILE_RANGE.  */
-# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
-					     in the range before performing the
-					     write.  */
-# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
-					     dirty pages in the range which are
-					     not presently under writeback.  */
-# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
-					     the range after performing the
-					     write.  */
-
-/* Flags for SPLICE and VMSPLICE.  */
-# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
-# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
-					   (but we may still block on the fd
-					   we splice from/to).  */
-# define SPLICE_F_MORE		4	/* Expect more data.  */
-# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
-#endif
-
-__BEGIN_DECLS
-
-#if defined __USE_GNU && defined __UCLIBC_LINUX_SPECIFIC__
-
-/* Provide kernel hint to read ahead.  */
-extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
-    __THROW;
-
-
-/* Selective file content synch'ing.  */
-extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
-			    unsigned int __flags);
-
-/* Splice address range into a pipe.  */
-extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
-			 size_t __count, unsigned int __flags);
-
-/* Splice two files together.  */
-extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
-		       __off64_t *__offout, size_t __len,
-		       unsigned int __flags);
-
-/* In-kernel implementation of tee for pipe buffers.  */
-extern ssize_t tee (int __fdin, int __fdout, size_t __len,
-		    unsigned int __flags);
-
-#endif
-__END_DECLS
-#endif /* LINUX_SPECIFIC */
diff --git a/libc/sysdeps/linux/e1/bits/fenv.h b/libc/sysdeps/linux/e1/bits/fenv.h
deleted file mode 100644
index 3bcc5d901..000000000
--- a/libc/sysdeps/linux/e1/bits/fenv.h
+++ /dev/null
@@ -1,87 +0,0 @@
-
-/*  Copyright (C) 2002-2003,    George Thanos <george.thanos@gdt.gr>
-                                Yannis Mitsos <yannis.mitsos@gdt.gr>
-
-   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _FENV_H
-# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
-#endif
-
-
-/* Define bits representing the exception.  We use the bit positions of
-   the appropriate bits in the SR.  */
-enum
-  {
-    FE_INEXACT = (1 << 8),
-#define FE_INEXACT	FE_INEXACT
-    FE_UNDERFLOW = (1 << 9),
-#define FE_UNDERFLOW	FE_UNDERFLOW
-    FE_OVERFLOW = (1 << 10),
-#define FE_OVERFLOW	FE_OVERFLOW
-    FE_DIVBYZERO = (1 << 11),
-#define FE_DIVBYZERO	FE_DIVBYZERO
-    FE_INVALID = (1 << 12)
-#define FE_INVALID	FE_INVALID
-  };
-
-#define FE_ALL_EXCEPT \
-	(FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
-
-/* We support all of the four defined rounding modes.  We use
-   the bit positions in the FPCR Mode Control Byte as the values for the
-   appropriate macros.  */
-enum
-  {
-    FE_TONEAREST = 0,
-#define FE_TONEAREST	FE_TONEAREST
-    FE_TOWARDZERO = 1 << 13 ,
-#define FE_TOWARDZERO	FE_TOWARDZERO
-    FE_DOWNWARD = 2 << 13,
-#define FE_DOWNWARD	FE_DOWNWARD
-    FE_UPWARD = 3 << 13
-#define FE_UPWARD	FE_UPWARD
-  };
-
-
-/* Type representing exception flags.  */
-typedef unsigned int fexcept_t;
-
-
-/* Type representing floating-point environment.*/
-typedef struct
-{
-    unsigned int round_mode;
-    unsigned int trap_enabled;
-    unsigned int accrued_except;
-    unsigned int actual_except;
-} fenv_t;
-
-#if 0
-/* If the default argument is used we use this value.  */
-const fenv FE_DFL_ENV_OBJ = {0, 0x1C00, 0}
-#define FE_DFL_ENV	(&FE_DFL_ENV_OBJ)
-
-#ifdef __USE_GNU
-/* Floating-point environment where none of the exceptions are masked.  */
-const fenv_t FE_NOMASK_ENV_OBJ = { 0, 0x1F00, 0 };
-# define FE_NOMASK_ENV	(&FE_NOMASK_ENV_OBJ)
-#endif
-
-#endif
-
-#include <bits/fenvinline.h>
diff --git a/libc/sysdeps/linux/e1/bits/fenvinline.h b/libc/sysdeps/linux/e1/bits/fenvinline.h
deleted file mode 100644
index 21d258cda..000000000
--- a/libc/sysdeps/linux/e1/bits/fenvinline.h
+++ /dev/null
@@ -1,297 +0,0 @@
-/*
-   Inline floating-point environment handling functions for Hyperstone e1-32X.
-   Copyright (C) 2002-2003,    George Thanos <george.thanos@gdt.gr>
-                               Yannis Mitsos <yannis.mitsos@gdt.gr>
-
-   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#if defined __GNUC__ && !defined _SOFT_FLOAT && !defined __NO_MATH_INLINES
-
-/**********************************************************
- *  --- A small description of the E1-16/32X FP unit. ---
- * FP exceptions can be enabled and disabled through
- * <feenableexcept>, <fedisableexcept>.
- *
- * - When an enabled exception takes place a SIGFPE signal
- * is sent to the process by the exception handler. User
- * can test for the exception that took place through
- * <fetestexcept>.
- * feraiseexcept works only for accrued exceptions.
- *
- * - When a disabld exception takes place it does not generate
- * a trap. The user can check if any exception took place after
- * an FP instruction by issuing an <fetestexcept> command.
- * User should first clear the G2 register by issuing an
- * <feclearexcept> function.
- * The following program is a typical example of how the user
- * should check for exceptions that did not generate a SIGFPE
- * signal :
- * {
- *   double f;
- *   int raised;
- *   feclearexcept (FE_ALL_EXCEPT);
- *   f = compute ();
- *   raised = fetestexcept (FE_OVERFLOW | FE_INVALID);
- *   if (raised & FE_OVERFLOW) {  ...  }
- *   if (raised & FE_INVALID) {  ...  }
- *    ...
- * }
- ***********************************************************/
-
-/* Get FPU rounding mode  */
-#define fegetround()                     \
-({                                       \
-	unsigned int tmp;                \
-	__asm__ __volatile__("mov %0, SR"        \
-			:"=l"(tmp)       \
-			:/*no input*/);  \
-	tmp &= (3<<13);                  \
-	(tmp);                           \
-})
-
-/* Set FPU rounding mode  */
-#define fesetround(round)                \
-({                                       \
-	unsigned int tmp = (3 << 13);    \
-	while(1) {                       \
-	/* Clear SR.FRM field */         \
-	__asm__ __volatile__("andn SR, %0"       \
-			:/*no output*/   \
-			:"l"(tmp) );     \
-	tmp &= round;                    \
-                                         \
-	if(tmp) {                        \
-		tmp = -1;                \
-		break;                   \
-	}                                \
-                                         \
-	__asm__ __volatile__("or SR, %0"         \
-			:/*no input*/    \
-			:"l"(round) );   \
-	tmp = 0;                         \
-	break;                           \
-	}                                \
-	(tmp);                           \
-})
-
-/* The following functions test for accrued exceptions.
- * No trap is generated on an FP exception.
- */
-static __inline__ feclearexcept(int __excepts)
-{
-	unsigned int enabled_excepts, disabled_excepts;
-
-	/* Check that __excepts is correctly set */
-	if( __excepts & (~0x1F00) )
-		return -1;
-
-	__asm__ __volatile__("mov %0, SR"
-		     :"=l"(enabled_excepts)
-		     :/*no input*/ );
-
-	enabled_excepts  &= 0x1F00;
-	disabled_excepts = ~enabled_excepts;
-	disabled_excepts &= 0x1F00;
-
-	enabled_excepts  &= __excepts;
-	disabled_excepts &= __excepts;
-
-	/* Clear accrued exceptions */
-	__asm__ __volatile__("andn G2, %0\n\t"
-		     "andn G2, %1\n\t"
-			:/*no output*/
-			:"l"(enabled_excepts),
-			 "l"(disabled_excepts >> 8) );
-	return 0;
-}
-
-/* fetestexcepts tests both for actual and accrued
- * excepts. You can test for an exception either after
- * an FP instruction or within a SIGFPE handler
- */
-__inline__ int fetestexcept(int __excepts)
-{
-	unsigned int G2, G2en, G2dis;
-	unsigned int enabled_excepts, disabled_excepts;
-
-	/* Check that __excepts is correctly set */
-	if( __excepts & (~0x1F00) )
-		return -1;
-
-	__asm__ __volatile__("mov %0, SR"
-		     :"=l"(enabled_excepts)
-		     :/*no input*/ );
-
-	enabled_excepts &= 0x1F00;
-	disabled_excepts = ~enabled_excepts;
-	disabled_excepts &= 0x1F00;
-
- 	__asm__ __volatile__("mov %0, G2"
-		    :"=l"(G2)
-		    :/*no input*/ );
-
-	G2en  = G2 & 0x1F00;
-	G2dis = G2 & 0x1F;
-	G2en  &= enabled_excepts;
-	G2dis &= (disabled_excepts >> 8);
-	return ( G2en | (G2dis << 8) );
-}
-
-static __inline__ int feraiseexcept(int __excepts)
-{
-	__asm__ __volatile__("or G2, %0"
-			:/*no output*/
-			:"l"( __excepts >> 8  ) );
-	return 0;
-}
-
-/* The following functions enable/disable individual exceptions.
- * If enabling an exception trap is going to occur, in case of error.
- */
-#define feenableexcept(__excepts)          \
-({                                         \
-	int __retval, __pexcepts;          \
-	int __tmpexcepts = __excepts;      \
-                                           \
-	while(1) {                         \
-	    __asm__ __volatile__("mov %0, SR"      \
-		     :"=l"(__pexcepts)     \
-		     :/*no input*/ );      \
-	    __pexcepts &= 0x1F00;          \
-	                                   \
-/* Check if __except values are valid */   \
-	    if( __tmpexcepts & ~0x1F00 ) { \
-	        __retval = -1;             \
-		fprintf(stderr,"Non valid excepts\n");\
-	        break;                     \
-	    }                              \
-	                                   \
-	    __asm__ __volatile__("or SR, %0"       \
-			:/*no output*/     \
-			:"l"(__tmpexcepts) ); \
-	    __retval = __pexcepts;         \
-	    break;                         \
-	}                                  \
-	(__retval);                        \
-})
-
-
-#define fedisableexcept(__excepts)         \
-({                                         \
-	int __retval, __pexcepts;          \
-	int __tmpexcepts = __excepts;      \
-	                                   \
-	while(1) {                         \
-	    __asm__ __volatile__("mov %0, SR"      \
-		     :"=l"(__pexcepts)     \
-		     :/*no input*/ );      \
-	    __pexcepts &= 0x1F00;          \
-	                                   \
-/* Check if __except values are valid */   \
-	    if( __tmpexcepts & ~0x1F00 ) { \
-	        __retval = -1;             \
-		fprintf(stderr,"Non valid excepts\n");\
-	        break;                     \
-	    }                              \
-	                                   \
-	    __asm__ __volatile__("andn SR, %0"     \
-			:/*no output*/     \
-			:"l"(__tmpexcepts) ); \
-	    __retval = __pexcepts;         \
-	    break;                         \
-	}                                  \
-	(__retval);                        \
-})
-
-static __inline__ int fegetexcept(int excepts)
-{
-	unsigned int tmp;
-	__asm__ __volatile__("mov %0, SR"
-		    :"=l"(tmp)
-		    :/*no input*/ );
-	tmp &= 0x1F00;
-	return tmp;
-}
-
-static __inline__ int fegetenv(fenv_t *envp)
-{
-	__asm__ __volatile__("mov %0, SR\n\t
-		      mov %1, SR\n\t
-		      mov %2, G2\n\t
-		      mov %3, G2\n\t"
-		     :"=l"(envp->round_mode),
-		      "=l"(envp->trap_enabled),
-		      "=l"(envp->accrued_except),
-		      "=l"(envp->actual_except)
-		     :/*no input*/ );
-	envp->round_mode &= (3<<13);
-	envp->trap_enabled &= 0x1F00;
-	envp->accrued_except &= 0x1F;
-	envp->accrued_except <<= 8;
-	envp->actual_except &= 0x1F00;
-}
-
-#define feholdexcept(envp)        \
-(                                         \
-	fegetenv(envp);                   \
-	fedisableexcept(FE_ALL_EXCEPT);   \
-	feclearexcept(FE_ALL_EXCEPT);     \
-	(0);                              \
-)
-
-#define fesetenv(envp)                \
-({                                                  \
-	/* Clear FRM & FTE field of SR */           \
-	unsigned long clearSR = ( 127<<8 );         \
-	__asm__ __volatile__("andn SR, %0\n\t"              \
-		     "or   SR, %1\n\t"              \
-		     "or   SR, %2\n\t"              \
-		     :/*no output*/                 \
-		     :"l"(clearSR),                 \
-		      "l"(envp->round_mode),        \
-		      "l"(envp->trap_enabled) );    \
-	__asm__ __volatile__("andn G2, 0x1F1F\n\t"          \
-		     "or   G2, %0\n\t"              \
-		     "or   G2, %1\n\t"              \
-		     :/*no output*/                 \
-		     :"l"( envp->accrued_except >> 8),\
-		     :"l"( envp->actual_except ) ); \
-	(0); /* return 0 */                         \
-})
-
-#define feupdateenv(envp)                           \
-({                                                  \
-	/* Clear FRM & FTE field of SR */           \
-	__asm__ __volatile__(/* We dont clear the prev SR*/ \
-		     "or   SR, %1\n\t"              \
-		     "or   SR, %2\n\t"              \
-		     :/*no output*/                 \
-		     :"l"(clearSR),                 \
-		      "l"(envp->round_mode),        \
-		      "l"(envp->accrued_except) );  \
-	__asm__ __volatile__(/* We dont clear the prev SR*/ \
-		     "or   G2, %0\n\t"              \
-		     "or   G2, %1\n\t"              \
-		     :/*no output*/                 \
-		     :"l"( envp->accrued_except >> 8),\
-		     :"l"( envp->actual_except ) ); \
-	(0); /* return 0 */                         \
-})
-
-
-#endif /* __GNUC__ && !_SOFT_FLOAT */
-
diff --git a/libc/sysdeps/linux/e1/bits/kernel_stat.h b/libc/sysdeps/linux/e1/bits/kernel_stat.h
deleted file mode 100644
index 99a6cba97..000000000
--- a/libc/sysdeps/linux/e1/bits/kernel_stat.h
+++ /dev/null
@@ -1,50 +0,0 @@
-#ifndef _BITS_STAT_STRUCT_H
-#define _BITS_STAT_STRUCT_H
-
-/* This file provides whatever this particular arch's kernel thinks
- * struct kernel_stat should look like...  It turns out each arch has a
- * different opinion on the subject... */
-
-struct kernel_stat {
-	unsigned short st_dev;
-	unsigned short __pad1;
-	unsigned long st_ino;
-	unsigned short st_mode;
-	unsigned short st_nlink;
-	unsigned short st_uid;
-	unsigned short st_gid;
-	unsigned short st_rdev;
-	unsigned short __pad2;
-	unsigned long  st_size;
-	unsigned long  st_blksize;
-	unsigned long  st_blocks;
-	struct timespec st_atim;
-	struct timespec st_mtim;
-	struct timespec st_ctim;
-	unsigned long  __unused4;
-	unsigned long  __unused5;
-};
-
-struct kernel_stat64 {
-	unsigned short	st_dev;
-	unsigned char	__pad0[10];
-#define _HAVE_STAT64___ST_INO
-	unsigned long	__st_ino;
-	unsigned int	st_mode;
-	unsigned int	st_nlink;
-	unsigned long	st_uid;
-	unsigned long	st_gid;
-	unsigned short	st_rdev;
-	unsigned char	__pad3[10];
-	long long	st_size;
-	unsigned long	st_blksize;
-	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
-	unsigned long	__pad4;		/* future possible st_blocks high bits */
-	struct timespec	st_atim;
-	struct timespec	st_mtim;
-	struct timespec	st_ctim;
-	unsigned long long	st_ino;
-};
-
-#endif	/*  _BITS_STAT_STRUCT_H */
-
diff --git a/libc/sysdeps/linux/e1/bits/kernel_types.h b/libc/sysdeps/linux/e1/bits/kernel_types.h
deleted file mode 100644
index f55a12903..000000000
--- a/libc/sysdeps/linux/e1/bits/kernel_types.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/* Note that we use the exact same include guard #define names
- * as asm/posix_types.h.  This will avoid gratuitous conflicts
- * with the posix_types.h kernel header, and will ensure that
- * our private content, and not the kernel header, will win.
- *  -Erik
- */
-#ifndef __ARCH_E1_POSIX_TYPES_H
-#define __ARCH_E1_POSIX_TYPES_H
-
-typedef unsigned short	__kernel_dev_t;
-typedef unsigned long	__kernel_ino_t;
-typedef unsigned short	__kernel_mode_t;
-typedef unsigned short	__kernel_nlink_t;
-typedef long		__kernel_off_t;
-typedef int		__kernel_pid_t;
-typedef unsigned short	__kernel_ipc_pid_t;
-typedef unsigned short	__kernel_uid_t;
-typedef unsigned short	__kernel_gid_t;
-typedef unsigned int	__kernel_size_t;
-typedef int		__kernel_ssize_t;
-typedef int		__kernel_ptrdiff_t;
-typedef long		__kernel_time_t;
-typedef long		__kernel_suseconds_t;
-typedef long		__kernel_clock_t;
-typedef int		__kernel_daddr_t;
-typedef char *		__kernel_caddr_t;
-typedef unsigned short	__kernel_uid16_t;
-typedef unsigned short	__kernel_gid16_t;
-typedef unsigned int	__kernel_uid32_t;
-typedef unsigned int	__kernel_gid32_t;
-typedef unsigned short	__kernel_old_uid_t;
-typedef unsigned short	__kernel_old_gid_t;
-typedef __kernel_dev_t	__kernel_old_dev_t;
-typedef long		__kernel_long_t;
-typedef unsigned long	__kernel_ulong_t;
-typedef long long	__kernel_loff_t;
-
-/*
-typedef struct {
-#ifdef __USE_ALL
-	int val[2];
-#else
-	int __val[2];
-#endif
-} __kernel_fsid_t;
-*/
-
-#endif /* __ARCH_E1_POSIX_TYPES_H */
diff --git a/libc/sysdeps/linux/e1/bits/proto.h b/libc/sysdeps/linux/e1/bits/proto.h
deleted file mode 100644
index 7aa38ffe5..000000000
--- a/libc/sysdeps/linux/e1/bits/proto.h
+++ /dev/null
@@ -1,5 +0,0 @@
-#ifndef _E1_PROTO_H_
-#define _E1_PROTO_H_
-int kprintf( char *msg, int len);
-#define KPRINTF(msg)  kprintf(msg, strlen(msg)+1)
-#endif
diff --git a/libc/sysdeps/linux/e1/bits/setjmp.h b/libc/sysdeps/linux/e1/bits/setjmp.h
deleted file mode 100644
index 88fa76fdf..000000000
--- a/libc/sysdeps/linux/e1/bits/setjmp.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* This file is lisenced under LGPL.
- * Copyright (C) 2002-2003,    George Thanos <george.thanos@gdt.gr>
- *                             Yannis Mitsos <yannis.mitsos@gdt.gr>
- */
-
-#ifndef _BITS_SETJMP_H
-#define _BITS_SETJMP_H	1
-
-#if !defined _SETJMP_H && !defined _PTHREAD_H
-# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
-#endif
-
-typedef struct {
-	unsigned long G3;
-	unsigned long G4;
-	unsigned long SavedSP;
-	unsigned long SavedPC;
-	unsigned long SavedSR;
-	unsigned long ReturnValue;
-} __jmp_buf[1];
-
-#endif	/* bits/setjmp.h */
diff --git a/libc/sysdeps/linux/e1/bits/syscalls.h b/libc/sysdeps/linux/e1/bits/syscalls.h
deleted file mode 100644
index 8852a0f55..000000000
--- a/libc/sysdeps/linux/e1/bits/syscalls.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/* This file is licensed under LGPL.
- * Copyright (C) 2002-2003,    George Thanos <george.thanos@gdt.gr>
- *                             Yannis Mitsos <yannis.mitsos@gdt.gr>
- */
-#ifndef _BITS_SYSCALLS_H
-#define _BITS_SYSCALLS_H
-#ifndef _SYSCALL_H
-# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
-#endif
-
-#include <features.h>
-
-/* Include the library _syscallx macros */
-#include <bits/unistd.h>
-
-#endif /* _BITS_SYSCALLS_H */
-
diff --git a/libc/sysdeps/linux/e1/bits/uClibc_arch_features.h b/libc/sysdeps/linux/e1/bits/uClibc_arch_features.h
deleted file mode 100644
index 293cc9b00..000000000
--- a/libc/sysdeps/linux/e1/bits/uClibc_arch_features.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Track misc arch-specific features that aren't config options
- */
-
-#ifndef _BITS_UCLIBC_ARCH_FEATURES_H
-#define _BITS_UCLIBC_ARCH_FEATURES_H
-
-/* instruction used when calling abort() to kill yourself */
-/*#define __UCLIBC_ABORT_INSTRUCTION__ "asm instruction"*/
-#undef __UCLIBC_ABORT_INSTRUCTION__
-
-/* can your target use syscall6() for mmap ? */
-#undef __UCLIBC_MMAP_HAS_6_ARGS__
-
-/* does your target align 64bit values in register pairs ? (32bit arches only) */
-#undef __UCLIBC_SYSCALL_ALIGN_64BIT__
-
-/* does your target have a broken create_module() ? */
-#undef __UCLIBC_BROKEN_CREATE_MODULE__
-
-/* does your target have to worry about older [gs]etrlimit() ? */
-#undef __UCLIBC_HANDLE_OLDER_RLIMIT__
-
-/* does your target have an asm .set ? */
-#define __UCLIBC_HAVE_ASM_SET_DIRECTIVE__
-
-/* define if target supports .weak */
-#define __UCLIBC_HAVE_ASM_WEAK_DIRECTIVE__
-
-/* define if target supports .weakext */
-#undef __UCLIBC_HAVE_ASM_WEAKEXT_DIRECTIVE__
-
-/* define if target supports CFI pseudo ops */
-#undef __UCLIBC_HAVE_ASM_CFI_DIRECTIVES__
-
-/* define if target supports IEEE signed zero floats */
-#define __UCLIBC_HAVE_SIGNED_ZERO__
-
-/* only weird assemblers generally need this */
-#undef __UCLIBC_ASM_LINE_SEP__
-
-#endif /* _BITS_UCLIBC_ARCH_FEATURES_H */
diff --git a/libc/sysdeps/linux/e1/bits/unistd.h b/libc/sysdeps/linux/e1/bits/unistd.h
deleted file mode 100644
index 9288a3a8f..000000000
--- a/libc/sysdeps/linux/e1/bits/unistd.h
+++ /dev/null
@@ -1,457 +0,0 @@
- /* This file is lisenced under LGPL.
-  * Copyright (C) 2002-2003,    George Thanos <george.thanos@gdt.gr>
-  *                             Yannis Mitsos <yannis.mitsos@gdt.gr>
-  */
-#ifndef _BITS_UNISTD_H_
-#define _BITS_UNISTD_H_
-
-#include <bits/proto.h>
-#include <errno.h>
-
-#define __E1_COFF_GCC__
-
-/* The following macros have been provided by C.Baumhof
- * They can be inlined in contrast to the previous ones*/
-#define _syscall0(type, name)  \
-type name(void)              \
-{                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-    par1 = -1;              \
-	par2 = __NR_##name;         \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1), "l"(par2)  \
-		:"memory","L14","L15");   \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define _syscall1(type, name,atype, a)  \
-type name(atype a)              \
-{                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-    par1 = -1;              \
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1), "l"(par2), "l"(par3)  \
-		:"memory","L13","L14","L15");   \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define _syscall2(type, name,atype, a, btype, b)  \
-type name(atype a, btype b)              \
-{                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-	register int par4 __asm__("L12");   \
-    par1 = -1;              \
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	par4 = (int)b;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1), "l"(par2), "l"(par3), "l"(par4) \
-		:"memory","L12","L13","L14","L15");   \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define _syscall3(type, name,atype, a, btype, b, ctype, c)  \
-type name(atype a, btype b, ctype c)                      \
-{                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-	register int par4 __asm__("L12");   \
-	register int par5 __asm__("L11");   \
-    par1 = -1;              \
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	par4 = (int)b;              \
-	par5 = (int)c;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1), "l"(par2), "l"(par3), "l"(par4), "l"(par5) \
-		:"memory","L11","L12","L13","L14","L15");    \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define _syscall4(type, name,atype, a, btype, b, ctype, c, dtype, d)  \
-type name(atype a, btype b, ctype c,dtype d)                      \
-{                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-	register int par4 __asm__("L12");   \
-	register int par5 __asm__("L11");   \
-	register int par6 __asm__("L10");   \
-    par1 = -1;              \
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	par4 = (int)b;              \
-	par5 = (int)c;              \
-	par6 = (int)d;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1),"l"(par2),"l"(par3),"l"(par4),"l"(par5),"l"(par6) \
-		:"memory","L10","L11","L12","L13","L14","L15");    \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define _syscall5(type, name,atype, a, btype, b, ctype, c, dtype, d, etype, e)  \
-type name(atype a, btype b, ctype c,dtype d, etype e)                      \
-{                                                       \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-	register int par4 __asm__("L12");   \
-	register int par5 __asm__("L11");   \
-	register int par6 __asm__("L10");   \
-	register int par7 __asm__("L9");   \
-    par1 = -1;              	\
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	par4 = (int)b;              \
-	par5 = (int)c;              \
-	par6 = (int)d;              \
-	par7 = (int)e;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1),"l"(par2),"l"(par3),"l"(par4),"l"(par5),"l"(par6),"l"(par7) \
-		:"memory","L9","L10","L11","L12","L13","L14","L15");    \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-	return (type)(par1);                    \
-}
-
-#define _syscall6(type, name,atype, a, btype, b, ctype, c, dtype, d, etype, e, ftype, f)  \
-type name(atype a, btype b, ctype c,dtype d, etype e, ftype f)                      \
-{                                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-	register int par4 __asm__("L12");   \
-	register int par5 __asm__("L11");   \
-	register int par6 __asm__("L10");   \
-	register int par7 __asm__("L9");   \
-	register int par8 __asm__("L8");   \
-	int sys_retval;				\
-    par1 = -1;              	\
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	par4 = (int)b;              \
-	par5 = (int)c;              \
-	par6 = (int)d;              \
-	par7 = (int)e;              \
-	par7 = (int)f;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1),"l"(par2),"l"(par3),"l"(par4),"l"(par5),"l"(par6),"l"(par7),"l"(par8) \
-		:"memory","L8","L9","L10","L11","L12","L13","L14","L15");	\
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define __syscall0(type, name)  \
-type name(...)                      \
-{                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	par1 = -1;              \
-	par2 = __NR_##name;         \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1), "l"(par2)\
-		:"memory","L14","L15");    \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define __syscall1(type, name, atype, a)  \
-type name(atype a, ...)                      \
-{                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-	par1 = -1;              \
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1), "l"(par2), "l"(par3)\
-		:"memory","L13","L14","L15");    \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define __syscall2(type, name,atype, a, btype, b)  \
-type name(atype a, btype b, ...)                      \
-{                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-	register int par4 __asm__("L12");   \
-	par1 = -1;              \
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	par4 = (int)b;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1), "l"(par2), "l"(par3), "l"(par4)\
-		:"memory","L12","L13","L14","L15");    \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define __syscall3(type, name,atype, a, btype, b, ctype, c)  \
-type name(atype a, btype b, ctype c, ...)                      \
-{                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-	register int par4 __asm__("L12");   \
-	register int par5 __asm__("L11");   \
-	par1 = -1;              \
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	par4 = (int)b;              \
-	par5 = (int)c;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1), "l"(par2), "l"(par3), "l"(par4), "l"(par5) \
-		:"memory","L11","L12","L13","L14","L15");    \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define __syscall4(type, name,atype, a, btype, b, ctype, c, dtype, d)  \
-type name(atype a, btype b, ctype c,dtype d, ...)                      \
-{                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-	register int par4 __asm__("L12");   \
-	register int par5 __asm__("L11");   \
-	register int par6 __asm__("L10");   \
-	par1 = -1;              \
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	par4 = (int)b;              \
-	par5 = (int)c;              \
-	par6 = (int)d;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1),"l"(par2),"l"(par3),"l"(par4),"l"(par5),"l"(par6) \
-		:"memory","L10","L11","L12","L13","L14","L15");    \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define __syscall5(type, name,atype, a, btype, b, ctype, c, dtype, d, etype, e)  \
-type name(atype a, btype b, ctype c,dtype d, etype e, ...)                      \
-{                                                       \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-	register int par4 __asm__("L12");   \
-	register int par5 __asm__("L11");   \
-	register int par6 __asm__("L10");   \
-	register int par7 __asm__("L9");   \
-	par1 = -1;                  \
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	par4 = (int)b;              \
-	par5 = (int)c;              \
-	par6 = (int)d;              \
-	par7 = (int)e;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1),"l"(par2),"l"(par3),"l"(par4),"l"(par5),"l"(par6),"l"(par7) \
-		:"memory","L9","L10","L11","L12","L13","L14","L15");    \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#define __syscall6(type, name,atype, a, btype, b, ctype, c, dtype, d, etype, e, ftype, f)  \
-type name(atype a, btype b, ctype c,dtype d, etype e, ftype f, ...)                      \
-{                                                               \
-	register int par1 __asm__("L15");   \
-	register int par2 __asm__("L14");   \
-	register int par3 __asm__("L13");   \
-	register int par4 __asm__("L12");   \
-	register int par5 __asm__("L11");   \
-	register int par6 __asm__("L10");   \
-	register int par7 __asm__("L9");   \
-	register int par8 __asm__("L8");   \
-	par1 = -1;                  \
-	par2 = __NR_##name;         \
-	par3 = (int)a;              \
-	par4 = (int)b;              \
-	par5 = (int)c;              \
-	par6 = (int)d;              \
-	par7 = (int)e;              \
-	par7 = (int)f;              \
-	__asm__ __volatile__(                   \
-		"trap    47"                        \
-		:"=l"(par1)                             \
-		:"0"(par1),"l"(par2),"l"(par3),"l"(par4),"l"(par5),"l"(par6),"l"(par7),"l"(par8) \
-		:"memory","L8","L9","L10","L11","L12","L13","L14","L15");    \
-																	\
-	if( par1 < 0 ) {													\
-			__set_errno( -par1 );										\
-			return -1;											\
-	} else															\
-		return (type)(par1);                    					\
-}
-
-#if 0
-#define _syscall3(type, name,atype, a , btype, b, ctype, c)  \
-type name(atype a, btype b, ctype c,)                      \
-{                                               \
-		__asm__ __volatile__(					\
-			"movi  L9, -1\n\t"                  \
-			"movi  L8, %0\n\t"					\
-			"ldw.d G3, L7, 0\n\t"				\
-			"ldw.d G3, L6, 4\n\t"				\
-			"ldw.d G3, L5, 8\n\t"				\
-		:/* no output */						\
-		:"i"(__NR_##name)						\
-		:"cc","memory","%L5","L6","L7","L8","L9");\
-        __asm__ __volatile__(                   \
-			"trap    47\n\t"                    \
-			"mov L2, L9\n\t");                  \
-}
-
-#define _syscall4(type, name,atype, a, btype, b, ctype, c, dtype, d)  \
-type name(atype a, btype b, ctype c,dtype d)                      \
-{                                               \
-		__asm__ __volatile__(					\
-			"movi  L11, -1\n\t"                  \
-			"movi  L10, %0\n\t"					\
-			"ldw.d G3, L9, 0\n\t"				\
-			"ldw.d G3, L8, 4\n\t"				\
-			"ldw.d G3, L7, 8\n\t"				\
-			"ldw.d G3, L6, 12\n\t"				\
-		:/* no output */						\
-		:"i"(__NR_##name)						\
-		:"cc","memory","L6","L7","L8","L9","L10","L11");\
-        __asm__ __volatile__(                   \
-			"trap    47\n\t"                    \
-			"mov L2, L11\n\t");                  \
-}
-
-#define _syscall5(type, name,atype, a, btype, b, ctype, c, dtype, d, etype, e)  \
-type name(atype a, btype b, ctype c,dtype d, etype e)                      \
-{                                                       \
-		__asm__ __volatile__(					\
-			"movi  L13, -1\n\t"                  \
-			"movi  L12, %0\n\t"					\
-			"ldw.d G3, L11, 0\n\t"				\
-			"ldw.d G3, L10, 4\n\t"				\
-			"ldw.d G3, L9, 8\n\t"				\
-			"ldw.d G3, L8, 12\n\t"				\
-			"ldw.d G3, L7, 16\n\t"				\
-		:/* no output */						\
-		:"i"(__NR_##name)						\
-		:"cc","memory","L7","L8","L9","L10","L11","L12","L13");\
-        __asm__ __volatile__(                   \
-			"trap    47\n\t"                    \
-			"mov L2, L13\n\t");                  \
-}
-
-#define _syscall6(type, name,atype, a, btype, b, ctype, c, dtype, d, etype, e, ftype, f)  \
-type name(atype a, btype b, ctype c,dtype d, etype e, ftype f)                      \
-{                                                               \
-		__asm__ __volatile__(					\
-			"movi  L15, -1\n\t"                  \
-			"movi  L14, %0\n\t"					\
-			"ldw.d G3, L13, 0\n\t"				\
-			"ldw.d G3, L12, 4\n\t"				\
-			"ldw.d G3, L11, 8\n\t"				\
-			"ldw.d G3, L10, 12\n\t"				\
-			"ldw.d G3, L9, 16\n\t"				\
-			"ldw.d G3, L8, 20\n\t"				\
-		:/* no output */						\
-		:"i"(__NR_##name)						\
-		:"cc","memory","L8","L9","L10","L11","L12","L13","L14","L15");\
-        __asm__ __volatile__(                   \
-			"trap    47\n\t"                    \
-			"mov L2, L15\n\t");                  \
-}
-#endif
-
-#endif /* !_HYPERSTONE_NOMMU_UNISTD_H_ */
diff --git a/libc/sysdeps/linux/e1/bits/wordsize.h b/libc/sysdeps/linux/e1/bits/wordsize.h
deleted file mode 100644
index 112446979..000000000
--- a/libc/sysdeps/linux/e1/bits/wordsize.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* Copyright (C) 2002-2003,    George Thanos <george.thanos@gdt.gr>
-                               Yannis Mitsos <yannis.mitsos@gdt.gr>
-
-   Copyright (C) 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#define __WORDSIZE	32
diff --git a/libc/sysdeps/linux/e1/crt0.S b/libc/sysdeps/linux/e1/crt0.S
deleted file mode 100644
index 9d5e98d30..000000000
--- a/libc/sysdeps/linux/e1/crt0.S
+++ /dev/null
@@ -1,17 +0,0 @@
-/*  This file is lisenced under LGPL
- *  Copyright (C) 2002-2003,    George Thanos <george.thanos@gdt.gr>
- *                              Yannis Mitsos <yannis.mitsos@gdt.gr>
- */
-
-.global __start
-__start:
-	call L1, 0, __uClibc_start
-
-/* Define a symbol for the first piece of initialized data.  */
-	.data
-	.globl __data_start
-__data_start:
-	.long 0
-	.weak data_start
-	data_start = __data_start
-
diff --git a/libc/sysdeps/linux/e1/crt1.c b/libc/sysdeps/linux/e1/crt1.c
deleted file mode 100644
index 7d51e6695..000000000
--- a/libc/sysdeps/linux/e1/crt1.c
+++ /dev/null
@@ -1,48 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/* uClibc/sysdeps/linux/m68k/crt0.S
- * Pull stuff off the stack and get uClibc moving.
- *
- * Copyright (C) 2002-2003,    George Thanos <george.thanos@gdt.gr>
- *                             Yannis Mitsos <yannis.mitsos@gdt.gr>
- *
- * Copyright (C) 2000,2001 by Erik Andersen <andersen@uclibc.org>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU Library General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at your
- * option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Library General Public License
- * along with this program; see the file COPYING.LIB.  If not, see
- * <http://www.gnu.org/licenses/>.
- */
-
-/* Stick in a dummy reference to main(), so that if an application
- * is linking when the main() function is in a static library (.a)
- * we can be sure that main() actually gets linked in */
-extern void main(int argc,void *argv,void *envp);
-/* void (*mainp)(int argc,void *argv,void *envp) = main; */
-
-void __uClibc_main(int argc,void *argv,void *envp);
-
-void _uClibc_start(unsigned int first_arg)
-{
-	unsigned int argc;
-	char **argv, **envp;
-	unsigned long *stack;
-
-	stack = (unsigned long*) first_arg;
-	argc = *(stack);
-	argv = (char **)(stack + 1);
-	envp = (char **)(stack + 1 + argc + 1);
-
-	__uClibc_main(argc, argv, envp);
-}
-
-void __main() { }
-
diff --git a/libc/sysdeps/linux/e1/longjmp.c b/libc/sysdeps/linux/e1/longjmp.c
deleted file mode 100644
index 3d188c423..000000000
--- a/libc/sysdeps/linux/e1/longjmp.c
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2002-2003,    George Thanos <george.thanos@gdt.gr>
- *                             Yannis Mitsos <yannis.mitsos@gdt.gr>
- * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
- *
- * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
- */
-
-#include <syscall.h>
-#include <setjmp.h>
-#include <stdio.h>
-#include <signal.h>
-
-#define __NR_e1newSP  224
-static __inline__ _syscall1(int, e1newSP, unsigned long, SavedSP )
-
-unsigned long jmpbuf_ptr;
-
-void longjmp(jmp_buf state, int value )
-{
-	if(!value)
-		state->__jmpbuf->ReturnValue = 1;
-	else
-		state->__jmpbuf->ReturnValue = value;
-
-	jmpbuf_ptr = (unsigned long)state;
-	e1newSP(state->__jmpbuf->SavedSP);
-
-#define _state_ ((struct __jmp_buf_tag*)jmpbuf_ptr)
-	__asm__ __volatile__("mov L0, %0\n\t"
-		     "mov L1, %1\n\t"
-		     "mov L2, %2\n\t"
-		     "mov G3, %3\n\t"
-		     "mov G4, %4\n\t"
-		     "ret PC, L1\n\t"
-		     :/*no output*/
-		     :"l"(_state_->__jmpbuf->ReturnValue),
-		      "l"(_state_->__jmpbuf->SavedPC),
-		      "l"(_state_->__jmpbuf->SavedSR),
-		      "l"(_state_->__jmpbuf->G3),
-		      "l"(_state_->__jmpbuf->G4)
-		     :"%G3", "%G4", "%L0", "%L1" );
-#undef _state_
-}
-
-
-void siglongjmp(sigjmp_buf state, int value )
-{
-	if( state->__mask_was_saved )
-		sigprocmask(SIG_SETMASK, &state->__saved_mask, NULL);
-
-	if(!value)
-		state->__jmpbuf->ReturnValue = 1;
-	else
-		state->__jmpbuf->ReturnValue = value;
-
-	jmpbuf_ptr = (unsigned long)state;
-	e1newSP(state->__jmpbuf->SavedSP);
-
-
-#define _state_ ((struct __jmp_buf_tag*)jmpbuf_ptr)
-	__asm__ __volatile__("mov L0, %0\n\t"
-		     "mov L1, %1\n\t"
-		     "mov L2, %2\n\t"
-		     "mov G3, %3\n\t"
-		     "mov G4, %4\n\t"
-		     "ret PC, L1\n\t"
-		     :/*no output*/
-		     :"l"(_state_->__jmpbuf->ReturnValue),
-		      "l"(_state_->__jmpbuf->SavedPC),
-		      "l"(_state_->__jmpbuf->SavedSR),
-		      "l"(_state_->__jmpbuf->G3),
-		      "l"(_state_->__jmpbuf->G4)
-		     :"%G3", "%G4", "%L0", "%L1" );
-#undef _state_
-}
diff --git a/libc/sysdeps/linux/e1/setjmp.c b/libc/sysdeps/linux/e1/setjmp.c
deleted file mode 100644
index e8a758c9b..000000000
--- a/libc/sysdeps/linux/e1/setjmp.c
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  This file is lisenced under LGPL
- *  Copyright (C) 2002-2003,    George Thanos <george.thanos@gdt.gr>
- *                              Yannis Mitsos <yannis.mitsos@gdt.gr>
- */
-
-#include <setjmp.h>
-#include <stdio.h>
-#include <signal.h>
-
-
-int setjmp( jmp_buf state)
-{
-	__asm__ __volatile__(	"mov %0, G3\n\t"
-			"mov %1, G4\n\t"
-			:"=l"(state->__jmpbuf->G3),
-			 "=l"(state->__jmpbuf->G4)
-			:/*no input*/
-			:"%G3", "%G4" );
-
-	__asm__ __volatile__(   "setadr  %0\n\t"
-			"mov %1, L1\n\t"
-			"mov %2, L2\n\t"
-			:"=l"(state->__jmpbuf->SavedSP),
-			 "=l"(state->__jmpbuf->SavedPC),
-			 "=l"(state->__jmpbuf->SavedSR)
-			:/*no input*/);
-	return 0;
-}
-
-int sigsetjmp( sigjmp_buf state , int savesigs)
-{
-
-	if(savesigs) {
-		state->__mask_was_saved = 1;
-		/* how arg in <sigprocmask> is not significant */
-		sigprocmask(SIG_SETMASK, NULL, &state->__saved_mask);
-	} else
-		state->__mask_was_saved = 0;
-
-	__asm__ __volatile__(	"mov %0, G3\n\t"
-			"mov %1, G4\n\t"
-			:"=l"(state->__jmpbuf->G3),
-			 "=l"(state->__jmpbuf->G4)
-			:/*no input*/
-			:"%G3", "%G4" );
-
-	__asm__ __volatile__(   "setadr  %0\n\t"
-			"mov %1, L2\n\t"
-			"mov %2, L3\n\t"
-			:"=l"(state->__jmpbuf->SavedSP),
-			 "=l"(state->__jmpbuf->SavedPC),
-			 "=l"(state->__jmpbuf->SavedSR)
-			:/*no input*/);
-	return 0;
-}
diff --git a/libc/sysdeps/linux/e1/sys/procfs.h b/libc/sysdeps/linux/e1/sys/procfs.h
deleted file mode 100644
index 1dc34b18b..000000000
--- a/libc/sysdeps/linux/e1/sys/procfs.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* Copyright (C) 1996, 1997, 1999, 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _SYS_PROCFS_H
-#define _SYS_PROCFS_H	1
-
-/* This is somewhat modelled after the file of the same name on SVR4
-   systems.  It provides a definition of the core file format for ELF
-   used on Linux.  It doesn't have anything to do with the /proc file
-   system, even though Linux has one.
-
-   Anyway, the whole purpose of this file is for GDB and GDB only.
-   Don't read too much into it.  Don't use it for anything other than
-   GDB unless you know what you are doing.  */
-
-#endif	/* sys/procfs.h */
diff --git a/libc/sysdeps/linux/e1/sys/reg.h b/libc/sysdeps/linux/e1/sys/reg.h
deleted file mode 100644
index 1d7cb90bd..000000000
--- a/libc/sysdeps/linux/e1/sys/reg.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* Copyright (C) 1998 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _SYS_REG_H
-#define _SYS_REG_H	1
-
-/* Index into an array of 4 byte integers returned from ptrace for
-   location of the users' stored general purpose registers. */
-
-#endif	/* _SYS_REG_H */
diff --git a/libc/sysdeps/linux/e1/sys/ucontext.h b/libc/sysdeps/linux/e1/sys/ucontext.h
deleted file mode 100644
index 85d2dd90e..000000000
--- a/libc/sysdeps/linux/e1/sys/ucontext.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/* Copyright (C) 1997, 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-/* System V/m68k ABI compliant context switching support.  */
-
-#ifndef _SYS_UCONTEXT_H
-#define _SYS_UCONTEXT_H	1
-
-#include <features.h>
-#include <signal.h>
-
-/* Type for general register.  */
-typedef int greg_t;
-
-/* Number of general registers.  */
-#define NGREG	18
-
-/* Container for all general registers.  */
-typedef greg_t gregset_t[NGREG];
-
-/* Number of each register is the `gregset_t' array.  */
-enum
-{
-  R_D0 = 0,
-#define R_D0	R_D0
-  R_D1 = 1,
-#define R_D1	R_D1
-  R_D2 = 2,
-#define R_D2	R_D2
-  R_D3 = 3,
-#define R_D3	R_D3
-  R_D4 = 4,
-#define R_D4	R_D4
-  R_D5 = 5,
-#define R_D5	R_D5
-  R_D6 = 6,
-#define R_D6	R_D6
-  R_D7 = 7,
-#define R_D7	R_D7
-  R_A0 = 8,
-#define R_A0	R_A0
-  R_A1 = 9,
-#define R_A1	R_A1
-  R_A2 = 10,
-#define R_A2	R_A2
-  R_A3 = 11,
-#define R_A3	R_A3
-  R_A4 = 12,
-#define R_A4	R_A4
-  R_A5 = 13,
-#define R_A5	R_A5
-  R_A6 = 14,
-#define R_A6	R_A6
-  R_A7 = 15,
-#define R_A7	R_A7
-  R_SP = 15,
-#define R_SP	R_SP
-  R_PC = 16,
-#define R_PC	R_PC
-  R_PS = 17
-#define R_PS	R_PS
-};
-
-/* Structure to describe FPU registers.  */
-typedef struct fpregset
-{
-  int f_fpregs[8][3];
-  int f_pcr;
-  int f_psr;
-  int f_fpiaddr;
-} fpregset_t;
-
-/* Context to describe whole processor state.  */
-typedef struct
-{
-  int version;
-  gregset_t gregs;
-  fpregset_t fpregs;
-} mcontext_t;
-
-#define MCONTEXT_VERSION 2
-
-/* Userlevel context.  */
-typedef struct ucontext
-{
-  unsigned long int uc_flags;
-  struct ucontext *uc_link;
-  __sigset_t uc_sigmask;
-  stack_t uc_stack;
-  mcontext_t uc_mcontext;
-  long int uc_filler[174];
-} ucontext_t;
-
-#endif /* sys/ucontext.h */
diff --git a/libc/sysdeps/linux/e1/syscalls.c b/libc/sysdeps/linux/e1/syscalls.c
deleted file mode 100644
index e58ad5f79..000000000
--- a/libc/sysdeps/linux/e1/syscalls.c
+++ /dev/null
@@ -1,11 +0,0 @@
-/*  This file is lisenced under LGPL
- *  Copyright (C) 2002-2003,    George Thanos <george.thanos@gdt.gr>
- *                              Yannis Mitsos <yannis.mitsos@gdt.gr>
- */
-
-#include <syscall.h>
-
-/* We now need a declaration of the `errno' variable.  */
-extern int errno;
-#   define __set_errno(val) ((errno) = (val))
-_syscall2( int, kprintf, char *, msg, int, len)