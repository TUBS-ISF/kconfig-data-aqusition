"2015-02-14 23:00:19 -0600"
diff --git a/Makefile.in b/Makefile.in
index 5d60ddaba..6dd473a0f 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -385,7 +385,7 @@ else
 endif
 	echo "$(UBACKTRACE_ASNEEDED)" >> $(PREFIX)$(DEVEL_PREFIX)$(MULTILIB_DIR)/libc.so
 ifeq ($(UCLIBC_HAS_THREADS),y)
-ifneq ($(LINUXTHREADS_OLD),y)
+ifneq ($(UCLIBC_HAS_LINUXTHREADS),y)
 ifeq ($(HARDWIRED_ABSPATH),y)
 	if [ -f $(top_builddir)lib/libpthread.so -a -f $(PREFIX)$(RUNTIME_PREFIX)$(MULTILIB_DIR)/libpthread.so.$(ABI_VERSION) ] ; then \
 		$(RM) $(PREFIX)$(DEVEL_PREFIX)$(MULTILIB_DIR)/libpthread.so; \
diff --git a/Rules.mak b/Rules.mak
index 2a73d7f0f..e7ec0f9e7 100644
--- a/Rules.mak
+++ b/Rules.mak
@@ -723,9 +723,7 @@ ifeq ($(UCLIBC_HAS_THREADS_NATIVE),y)
 	PTNAME := nptl
 	CFLAGS += -DHAVE_FORCED_UNWIND -D_LIBC_REENTRANT
 else
-ifeq ($(LINUXTHREADS_OLD),y)
-	PTNAME := linuxthreads.old
-else
+ifeq ($(UCLIBC_HAS_LINUXTHREADS),y)
 	PTNAME := linuxthreads
 endif
 endif
diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
index c1a2d5ac9..1d382017b 100644
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -3,7 +3,7 @@
 # see extra/config/Kconfig-language.txt
 #
 
-mainmenu "uClibc $VERSION C Library Configuration"
+mainmenu "uClibc-ng $VERSION C Library Configuration"
 
 config DESIRED_TARGET_ARCH
 	string
@@ -506,7 +506,6 @@ config LDSO_GNU_HASH_SUPPORT
 
 choice
 	prompt "Thread support"
-	#default UCLIBC_HAS_THREADS_NATIVE if (TARGET_alpha || TARGET_arm || TARGET_i386 || TARGET_mips || TARGET_powerpc || TARGET_sh || TARGET_sh64)
 	default HAS_NO_THREADS
 	help
 	  If you want to compile uClibc with pthread support, then answer Y.
@@ -519,9 +518,9 @@ config HAS_NO_THREADS
 	help
 	  Disable thread support.
 
-config LINUXTHREADS_OLD
-	bool "older (stable) version of linuxthreads"
-	# linuxthreads and linuxthreads.old need nanosleep()
+config UCLIBC_HAS_LINUXTHREADS
+	bool "Enable support for linuxthreads"
+	# linuxthreads need nanosleep()
 	select UCLIBC_HAS_REALTIME
 	depends on !TARGET_arc && \
 		   !TARGET_i386 && \
@@ -533,29 +532,8 @@ config LINUXTHREADS_OLD
 		   !TARGET_x86_64 && \
 		   !TARGET_xtensa
 	help
-	  There are two versions of linuxthreads.  The older (stable) version
-	  has been in uClibc for quite a long time but hasn't seen too many
-	  updates other than bugfixes.
-
-
-config LINUXTHREADS_NEW
-	bool "slightly newer version of linuxthreads"
-	depends on ARCH_HAS_DEPRECATED_SYSCALLS
-	depends on !TARGET_arc && \
-		   !TARGET_arm && \
-		   !TARGET_i386 && \
-		   !TARGET_metag && \
-		   !TARGET_mips && \
-		   !TARGET_powerpc && \
-		   !TARGET_sh && \
-		   !TARGET_sparc && \
-		   !TARGET_x86_64 && \
-		   !TARGET_xtensa
-	help
-	  The new version has not been tested much, and lacks ports for arches
-	  which glibc does not support (like bfin/frv/etc...), but is based on
-	  the latest code from glibc, so it may be the only choice for the
-	  newer ports (like alpha/amd64/64bit arches and hppa).
+	  See here for information about linuxthreads:
+	  http://en.wikipedia.org/wiki/LinuxThreads
 
 config UCLIBC_HAS_THREADS_NATIVE
 	bool "Native POSIX Threading (NPTL)"
@@ -608,7 +586,6 @@ config PTHREADS_DEBUG_SUPPORT
 	  If you are doing development and want to debug applications using
 	  uClibc's pthread library, answer Y.  Otherwise, answer N.
 
-
 config UCLIBC_HAS_SYSLOG
 	bool "Syslog support"
 	default y
@@ -2356,7 +2333,7 @@ config DODEBUG
 
 config DODEBUG_PT
 	bool "Build pthread with debugging output"
-	depends on UCLIBC_HAS_THREADS && LINUXTHREADS_OLD
+	depends on UCLIBC_HAS_THREADS && UCLIBC_HAS_LINUXTHREADS
 	help
 	  Enable debug output in libpthread.  This is only useful when doing
 	  development in libpthread itself.
diff --git a/extra/Configs/defconfigs/arc/tb10x_defconfig b/extra/Configs/defconfigs/arc/tb10x_defconfig
index 60065f97d..218a17d56 100644
--- a/extra/Configs/defconfigs/arc/tb10x_defconfig
+++ b/extra/Configs/defconfigs/arc/tb10x_defconfig
@@ -6,7 +6,7 @@ KERNEL_HEADERS="%KERNEL_HEADERS%"
 # LDSO_CACHE_SUPPORT is not set
 LDSO_RUNPATH=y
 # LDSO_SAFE_RUNPATH is not set
-LINUXTHREADS_OLD=y
+UCLIBC_HAS_LINUXTHREADS=y
 PTHREADS_DEBUG_SUPPORT=y
 MALLOC_GLIBC_COMPAT=y
 UCLIBC_SUSV3_LEGACY=y
diff --git a/include/cancel.h b/include/cancel.h
index ac6f6b64d..b60d21808 100644
--- a/include/cancel.h
+++ b/include/cancel.h
@@ -48,7 +48,7 @@
 #define __NC_PROTO(name) extern __typeof(name) __NC(name) attribute_hidden;
 #define __NC_OLD_PROTO(name) extern __typeof(name) __NC_OLD(name);
 
-#if defined __UCLIBC_HAS_THREADS__ && !defined __LINUXTHREADS_OLD__
+#if defined __UCLIBC_HAS_THREADS__ && !defined __UCLIBC_HAS_LINUXTHREADS__
 # define __NEW_THREADS 1
 #else
 # define SINGLE_THREAD_P 1
@@ -71,7 +71,7 @@ res_type weak_function name param_list					\
 # define lt_strong_alias(name)
 # define lt_libc_hidden(name) libc_hidden_def(name)
 
-#elif defined __LINUXTHREADS_OLD__
+#elif defined __UCLIBC_HAS_LINUXTHREADS__
 
 # define CANCELLABLE_SYSCALL(res_type, name, param_list, params)	\
 weak_alias(__NC(name),name)						\
diff --git a/libc/signal/allocrtsig.c b/libc/signal/allocrtsig.c
index 974418761..d93966a46 100644
--- a/libc/signal/allocrtsig.c
+++ b/libc/signal/allocrtsig.c
@@ -32,7 +32,7 @@ static int current_rtmax = -1;
 #else
 # ifdef __UCLIBC_HAS_THREADS_NATIVE__
 static int current_rtmin = __SIGRTMIN + 2;
-# elif defined __UCLIBC_HAS_THREADS__ && !defined __LINUXTHREADS_OLD__
+# elif defined __UCLIBC_HAS_THREADS__ && !defined __UCLIBC_HAS_LINUXTHREADS__
 /* psm: might be good for LT old as well, do not want to break it for now */
 /* Sanity check */
 #  if !defined __SIGRTMIN || (__SIGRTMAX - __SIGRTMIN) < 3
diff --git a/libc/stdlib/malloc-standard/malloc.h b/libc/stdlib/malloc-standard/malloc.h
index 1a4cc5a62..f3e2d2a2a 100644
--- a/libc/stdlib/malloc-standard/malloc.h
+++ b/libc/stdlib/malloc-standard/malloc.h
@@ -27,7 +27,7 @@
 
 
 __UCLIBC_MUTEX_EXTERN(__malloc_lock)
-#if defined __UCLIBC_HAS_THREADS__ && !defined __LINUXTHREADS_OLD__
+#if defined __UCLIBC_HAS_THREADS__ && !defined __UCLIBC_HAS_LINUXTHREADS__
 	attribute_hidden
 #endif
 	;
diff --git a/libc/stdlib/malloc/malloc.h b/libc/stdlib/malloc/malloc.h
index 53683c479..75262593f 100644
--- a/libc/stdlib/malloc/malloc.h
+++ b/libc/stdlib/malloc/malloc.h
@@ -199,13 +199,13 @@ extern void __malloc_debug_printf (int indent, const char *fmt, ...) attribute_h
 extern struct heap_free_area *__malloc_heap attribute_hidden;
 #ifdef __UCLIBC_HAS_THREADS__
 __UCLIBC_MUTEX_EXTERN(__malloc_heap_lock)
-# ifndef __LINUXTHREADS_OLD__
+# ifndef __UCLIBC_HAS_LINUXTHREADS__
 	attribute_hidden
 # endif
 	;
 # ifdef __UCLIBC_UCLINUX_BROKEN_MUNMAP__
 __UCLIBC_MUTEX_EXTERN(__malloc_mmb_heap_lock)
-#  ifndef __LINUXTHREADS_OLD__
+#  ifndef __UCLIBC_HAS_LINUXTHREADS__
 	attribute_hidden
 #  endif
 	;
diff --git a/libc/sysdeps/linux/common/bits/uClibc_local_lim.h b/libc/sysdeps/linux/common/bits/uClibc_local_lim.h
index 0727ebf55..ce166a15b 100644
--- a/libc/sysdeps/linux/common/bits/uClibc_local_lim.h
+++ b/libc/sysdeps/linux/common/bits/uClibc_local_lim.h
@@ -20,7 +20,7 @@
 /* glibc uses 16384 */
 # define PTHREAD_THREADS_MAX	1024
 # define TIMER_MAX		256
-# ifdef __LINUXTHREADS_OLD__
+# ifdef __UCLIBC_HAS_LINUXTHREADS__
 #  undef SEM_VALUE_MAX
 #  define SEM_VALUE_MAX	((int) ((~0u) >> 1))
 # endif
diff --git a/libc/sysdeps/linux/common/not-cancel.h b/libc/sysdeps/linux/common/not-cancel.h
index acf8e39e8..ac32366a6 100644
--- a/libc/sysdeps/linux/common/not-cancel.h
+++ b/libc/sysdeps/linux/common/not-cancel.h
@@ -70,12 +70,6 @@ extern int __openat64_nocancel (int fd, const char *fname, int oflag,
 #define read_not_cancel(fd, buf, n) \
   INLINE_SYSCALL (read, 3, (fd), (buf), (n))
 
-#ifdef __LINUXTHREADS_NEW__
-/* Uncancelable write.  */
-#define write_not_cancel(fd, buf, n) \
-  INLINE_SYSCALL (write, 3, (fd), (buf), (n))
-#endif
-
 #if 0
 /* Uncancelable writev.  */
 #define writev_not_cancel_no_status(fd, iov, n) \
@@ -87,17 +81,6 @@ extern int __openat64_nocancel (int fd, const char *fname, int oflag,
   __fcntl_nocancel (fd, cmd, val)
 #endif
 
-#ifdef __LINUXTHREADS_NEW__
-/* Uncancelable waitpid.  */
-#if 0 /*def __NR_waitpid*/
-# define waitpid_not_cancel(pid, stat_loc, options) \
-  INLINE_SYSCALL (waitpid, 3, pid, stat_loc, options)
-#else
-# define waitpid_not_cancel(pid, stat_loc, options) \
-  INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL)
-#endif
-#endif
-
 /* Uncancelable pause.  */
 #ifdef __NR_pause
 # define pause_not_cancel() \
diff --git a/libc/sysdeps/linux/common/pause.c b/libc/sysdeps/linux/common/pause.c
index c35ecd5d5..95d064ab5 100644
--- a/libc/sysdeps/linux/common/pause.c
+++ b/libc/sysdeps/linux/common/pause.c
@@ -22,7 +22,7 @@ CANCELLABLE_SYSCALL(int, pause, (void), ())
 # include <signal.h>
 
 int
-# ifdef __LINUXTHREADS_OLD__
+# ifdef __UCLIBC_HAS_LINUXTHREADS__
 weak_function
 # endif
 __NC(pause)(void)
diff --git a/libc/sysdeps/linux/common/pread_write.c b/libc/sysdeps/linux/common/pread_write.c
index 4f96f681d..d0abd90e4 100644
--- a/libc/sysdeps/linux/common/pread_write.c
+++ b/libc/sysdeps/linux/common/pread_write.c
@@ -102,7 +102,7 @@ static ssize_t __NC(pwrite64)(int fd, const void *buf, size_t count, off64_t off
 CANCELLABLE_SYSCALL(ssize_t, pwrite64, (int fd, const void *buf, size_t count, off64_t offset),
 		    (fd, buf, count, offset))
 # else
-#  ifdef __LINUXTHREADS_OLD__
+#  ifdef __UCLIBC_HAS_LINUXTHREADS__
 weak_alias(pread,pread64)
 weak_alias(pwrite,pwrite64)
 lt_strong_alias(pread64)
diff --git a/libc/unistd/confstr.c b/libc/unistd/confstr.c
index 373644265..4d4c217e5 100644
--- a/libc/unistd/confstr.c
+++ b/libc/unistd/confstr.c
@@ -43,12 +43,9 @@ size_t confstr (int name, char *buf, size_t len)
       break;
 #ifdef __UCLIBC_HAS_THREADS__
     case _CS_GNU_LIBPTHREAD_VERSION:
-# if defined __LINUXTHREADS_OLD__
+# if defined __UCLIBC_HAS_LINUXTHREADS__
       string = "linuxthreads-0.01";
       string_len = sizeof("linuxthreads-x.xx");
-# elif defined __LINUXTHREADS_NEW__
-      string = "linuxthreads-0.10";
-      string_len = sizeof("linuxthreads-x.xx");
 # elif defined __UCLIBC_HAS_THREADS_NATIVE__
 #  define __NPTL_VERSION ("NPTL " \
 		__stringify(__UCLIBC_MAJOR__) "." \
diff --git a/libpthread/linuxthreads.old/Makefile b/libpthread/linuxthreads.old/Makefile
deleted file mode 100644
index f9100219a..000000000
--- a/libpthread/linuxthreads.old/Makefile
+++ /dev/null
@@ -1,13 +0,0 @@
-# Makefile for uClibc
-#
-# Copyright (C) 2000-2005 Erik Andersen <andersen@uclibc.org>
-#
-# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
-#
-
-top_srcdir=../../
-top_builddir=../../
-include $(top_builddir)Rules.mak
-all: libs
-include Makefile.in
-include $(top_srcdir)Makerules
diff --git a/libpthread/linuxthreads.old/Makefile.in b/libpthread/linuxthreads.old/Makefile.in
deleted file mode 100644
index 6be2099d2..000000000
--- a/libpthread/linuxthreads.old/Makefile.in
+++ /dev/null
@@ -1,119 +0,0 @@
-# Makefile for uClibc
-#
-# Copyright (C) 2003 Paul Mundt <lethal@linux-sh.org>
-# Copyright (C) 2000-2008 Erik Andersen <andersen@uclibc.org>
-#
-# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
-#
-
-subdirs += libpthread/linuxthreads.old
-
-CFLAGS-dir_linuxthreads.old := -DNOT_IN_libc -DIS_IN_libpthread
-CFLAGS-libpthread/linuxthreads.old := $(CFLAGS-dir_linuxthreads.old) $(SSP_ALL_CFLAGS)
-
-ifeq ($(PTHREADS_DEBUG_SUPPORT),y)
-LDFLAGS-libpthread.so := $(LDFLAGS_NOSTRIP) -Wl,-z,defs
-else
-LDFLAGS-libpthread.so := $(LDFLAGS)
-endif
-LDFLAGS-$(UCLIBC_FORMAT_DSBT_ELF)-libpthread.so := -Wl,--dsbt-index=10
-
-LIBS-libpthread.so := $(LIBS) $(ldso)
-
-START_FILE-libpthread.so := $(SHARED_START_FILES)
-END_FILE-libpthread.so := $(SHARED_END_FILES)
-
-libpthread_FULL_NAME := libpthread-$(VERSION).so
-
-libpthread_DIR := $(top_srcdir)libpthread/linuxthreads.old
-libpthread_OUT := $(top_builddir)libpthread/linuxthreads.old
-
--include $(libpthread_DIR)/sysdeps/$(TARGET_ARCH)/Makefile.arch
-
-libpthread_SRC := \
-	attr.c cancel.c condvar.c errno.c events.c join.c lockfile.c manager.c \
-	mutex.c pt-machine.c ptfork.c pthread.c ptlongjmp.c \
-	rwlock.c semaphore.c signals.c specific.c spinlock.c wrapsyscall.c
-ifeq ($(UCLIBC_HAS_XLOCALE),y)
-libpthread_SRC += locale.c
-endif
-
-# remove generic sources, if arch specific version is present
-ifneq ($(strip $(libpthread_ARCH_SRC)),)
-libpthread_SRC := $(filter-out $(patsubst %.c,$(libpthread_DIR)/%.c,$(notdir $(libpthread_ARCH_SRC))),$(libpthread_SRC))
-endif
-
-libpthread_SRC := $(patsubst %,$(libpthread_DIR)/%,$(libpthread_SRC))
-
-libpthread_OBJ := $(patsubst $(libpthread_DIR)/%.c,$(libpthread_OUT)/%.o,$(libpthread_SRC))
-
-#
-# Stuff that goes into libc.so, not libpthread.so
-#
-CFLAGS-OMIT-forward.c := $(CFLAGS-dir_linuxthreads.old)
-CFLAGS-OMIT-libc_pthread_init.c := $(CFLAGS-dir_linuxthreads.old)
-libpthread_libc_CSRC := forward.c libc_pthread_init.c
-libpthread_libc_OBJ  := $(patsubst %.c, $(libpthread_OUT)/%.o,$(libpthread_libc_CSRC))
-libc-static-y += $(libpthread_OUT)/libc_pthread_init.o
-libc-shared-y += $(libpthread_libc_OBJ:.o=.oS)
-
-ifeq ($(DOPIC),y)
-libpthread-a-y  += $(libpthread_OBJ:.o=.os)
-else
-libpthread-a-y  += $(libpthread_OBJ)
-endif
-libpthread-so-y += $(libpthread_OBJ:.o=.oS)
-
-lib-a-$(UCLIBC_HAS_THREADS) += $(top_builddir)lib/libpthread.a
-lib-so-$(UCLIBC_HAS_THREADS) += $(top_builddir)lib/libpthread.so
-
-#ifeq ($(DOMULTI),n)
-$(top_builddir)lib/libpthread.so: $(libpthread_OUT)/libpthread_so.a $(libc.depend)
-	$(call link.so,$(libpthread_FULL_NAME),$(ABI_VERSION))
-#else
-#$(top_builddir)lib/libpthread.so: $(libpthread_OUT)/libpthread.oS | $(libc.depend)
-#	$(call linkm.so,$(libpthread_FULL_NAME),$(ABI_VERSION))
-#endif
-
-ifeq ($(PTHREADS_DEBUG_SUPPORT),y)
-$(libpthread_OUT)/libpthread_so.a: STRIP_FLAGS:=$(STRIP_FLAGS:-x=-X --strip-debug)
-endif
-$(libpthread_OUT)/libpthread_so.a: $(libpthread-so-y)
-	$(Q)$(RM) $@
-	$(do_ar)
-
-ifeq ($(PTHREADS_DEBUG_SUPPORT),y)
-$(libpthread_OUT)/libpthread.oS: STRIP_FLAGS:=$(STRIP_FLAGS:-x=-X --strip-debug)
-endif
-$(libpthread_OUT)/libpthread.oS: $(libpthread_SRC)
-	$(Q)$(RM) $@
-	$(compile-m)
-
-ifeq ($(PTHREADS_DEBUG_SUPPORT),y)
-$(top_builddir)lib/libpthread.a: STRIP_FLAGS:=$(STRIP_FLAGS:-x=-X --strip-debug)
-endif
-$(top_builddir)lib/libpthread.a: $(libpthread-a-y)
-	$(Q)$(INSTALL) -d $(dir $@)
-	$(Q)$(RM) $@
-	$(do_ar)
-
-$(top_builddir)include/pthread.h:
-	$(do_ln) $(call rel_srcdir)$(PTDIR)/sysdeps/pthread/$(@F) $@
-$(top_builddir)include/semaphore.h:
-	$(do_ln) $(call rel_srcdir)$(PTDIR)/$(@F) $@
-$(top_builddir)include/bits/pthreadtypes.h: | $(top_builddir)include/bits
-	$(do_ln) $(call rel_srcdir)$(PTDIR)/sysdeps/pthread/bits/$(@F) $@
-
-linuxthreads_headers := $(top_builddir)include/pthread.h \
-			$(top_builddir)include/semaphore.h \
-			$(top_builddir)include/bits/pthreadtypes.h
-$(linuxthreads_headers): $(wildcard $(addprefix $(top_builddir)include/config/linuxthreads/,old.h new.h))
-headers-$(UCLIBC_HAS_THREADS) += $(linuxthreads_headers)
-
-objclean-y += CLEAN_libpthread/linuxthreads.old
-headers_clean-y += HEADERCLEAN_libpthread/linuxthreads.old
-HEADERCLEAN_libpthread/linuxthreads.old:
-	$(do_rm) $(linuxthreads_headers)
-
-CLEAN_libpthread/linuxthreads.old:
-	$(do_rm) $(addprefix $(libpthread_OUT)/*., o os oS a)
diff --git a/libpthread/linuxthreads.old/attr.c b/libpthread/linuxthreads.old/attr.c
deleted file mode 100644
index 8465c234c..000000000
--- a/libpthread/linuxthreads.old/attr.c
+++ /dev/null
@@ -1,240 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* changed for uClibc */
-#define __sched_get_priority_min sched_get_priority_min
-#define __sched_get_priority_max sched_get_priority_max
-
-/* Handling of thread attributes */
-
-#include <errno.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/param.h>
-#include "pthread.h"
-#include "internals.h"
-
-libpthread_hidden_proto(pthread_attr_destroy)
-libpthread_hidden_proto(pthread_attr_init)
-libpthread_hidden_proto(pthread_attr_getdetachstate)
-libpthread_hidden_proto(pthread_attr_setdetachstate)
-libpthread_hidden_proto(pthread_attr_getinheritsched)
-libpthread_hidden_proto(pthread_attr_setinheritsched)
-libpthread_hidden_proto(pthread_attr_setschedparam)
-libpthread_hidden_proto(pthread_attr_getschedparam)
-libpthread_hidden_proto(pthread_attr_getschedpolicy)
-libpthread_hidden_proto(pthread_attr_setschedpolicy)
-libpthread_hidden_proto(pthread_attr_getscope)
-libpthread_hidden_proto(pthread_attr_setscope)
-
-/* NOTE: With uClibc I don't think we need this versioning stuff.
- * Therefore, define the function pthread_attr_init() here using
- * a strong symbol. */
-
-/*int __pthread_attr_init_2_1(pthread_attr_t *attr)*/
-int pthread_attr_init(pthread_attr_t *attr)
-{
-  size_t ps = getpagesize ();
-
-  attr->__detachstate = PTHREAD_CREATE_JOINABLE;
-  attr->__schedpolicy = SCHED_OTHER;
-  attr->__schedparam.sched_priority = 0;
-  attr->__inheritsched = PTHREAD_EXPLICIT_SCHED;
-  attr->__scope = PTHREAD_SCOPE_SYSTEM;
-  attr->__guardsize = ps;
-  attr->__stackaddr = NULL;
-  attr->__stackaddr_set = 0;
-  attr->__stacksize = STACK_SIZE - ps;
-  return 0;
-}
-libpthread_hidden_def(pthread_attr_init)
-
-/* uClibc: leave out this for now. */
-#if defined DO_PTHREAD_VERSIONING_WITH_UCLIBC
-#if defined __PIC__ && defined DO_VERSIONING
-default_symbol_version (__pthread_attr_init_2_1, pthread_attr_init, GLIBC_2.1);
-
-int __pthread_attr_init_2_0(pthread_attr_t *attr)
-{
-  attr->__detachstate = PTHREAD_CREATE_JOINABLE;
-  attr->__schedpolicy = SCHED_OTHER;
-  attr->__schedparam.sched_priority = 0;
-  attr->__inheritsched = PTHREAD_EXPLICIT_SCHED;
-  attr->__scope = PTHREAD_SCOPE_SYSTEM;
-  return 0;
-}
-symbol_version (__pthread_attr_init_2_0, pthread_attr_init, GLIBC_2.0);
-#else
-strong_alias (__pthread_attr_init_2_1, pthread_attr_init)
-#endif
-#endif /* DO_PTHREAD_VERSIONING_WITH_UCLIBC */
-
-int pthread_attr_destroy(pthread_attr_t *attr attribute_unused)
-{
-  return 0;
-}
-libpthread_hidden_def(pthread_attr_destroy)
-
-
-int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate)
-{
-  if (detachstate < PTHREAD_CREATE_JOINABLE ||
-      detachstate > PTHREAD_CREATE_DETACHED)
-    return EINVAL;
-  attr->__detachstate = detachstate;
-  return 0;
-}
-libpthread_hidden_def(pthread_attr_setdetachstate)
-
-int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate)
-{
-  *detachstate = attr->__detachstate;
-  return 0;
-}
-libpthread_hidden_def(pthread_attr_getdetachstate)
-
-int pthread_attr_setschedparam(pthread_attr_t *attr,
-                               const struct sched_param *param)
-{
-  int max_prio = __sched_get_priority_max(attr->__schedpolicy);
-  int min_prio = __sched_get_priority_min(attr->__schedpolicy);
-
-  if (param->sched_priority < min_prio || param->sched_priority > max_prio)
-    return EINVAL;
-  memcpy (&attr->__schedparam, param, sizeof (struct sched_param));
-  return 0;
-}
-libpthread_hidden_def(pthread_attr_setschedparam)
-
-int pthread_attr_getschedparam(const pthread_attr_t *attr,
-                               struct sched_param *param)
-{
-  memcpy (param, &attr->__schedparam, sizeof (struct sched_param));
-  return 0;
-}
-libpthread_hidden_def(pthread_attr_getschedparam)
-
-int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
-{
-  if (policy != SCHED_OTHER && policy != SCHED_FIFO && policy != SCHED_RR)
-    return EINVAL;
-  attr->__schedpolicy = policy;
-  return 0;
-}
-libpthread_hidden_def(pthread_attr_setschedpolicy)
-
-int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
-{
-  *policy = attr->__schedpolicy;
-  return 0;
-}
-libpthread_hidden_def(pthread_attr_getschedpolicy)
-
-int pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit)
-{
-  if (inherit != PTHREAD_INHERIT_SCHED && inherit != PTHREAD_EXPLICIT_SCHED)
-    return EINVAL;
-  attr->__inheritsched = inherit;
-  return 0;
-}
-libpthread_hidden_def(pthread_attr_setinheritsched)
-
-int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit)
-{
-  *inherit = attr->__inheritsched;
-  return 0;
-}
-libpthread_hidden_def(pthread_attr_getinheritsched)
-
-int pthread_attr_setscope(pthread_attr_t *attr, int scope)
-{
-  switch (scope) {
-  case PTHREAD_SCOPE_SYSTEM:
-    attr->__scope = scope;
-    return 0;
-  case PTHREAD_SCOPE_PROCESS:
-    return ENOTSUP;
-  default:
-    return EINVAL;
-  }
-}
-libpthread_hidden_def(pthread_attr_setscope)
-
-int pthread_attr_getscope(const pthread_attr_t *attr, int *scope)
-{
-  *scope = attr->__scope;
-  return 0;
-}
-libpthread_hidden_def(pthread_attr_getscope)
-
-int __pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize)
-{
-  size_t ps = getpagesize ();
-
-  /* First round up the guard size.  */
-  guardsize = roundup (guardsize, ps);
-
-  /* The guard size must not be larger than the stack itself */
-  if (guardsize >= attr->__stacksize) return EINVAL;
-
-  attr->__guardsize = guardsize;
-
-  return 0;
-}
-weak_alias (__pthread_attr_setguardsize, pthread_attr_setguardsize)
-
-int __pthread_attr_getguardsize(const pthread_attr_t *attr, size_t *guardsize)
-{
-  *guardsize = attr->__guardsize;
-  return 0;
-}
-weak_alias (__pthread_attr_getguardsize, pthread_attr_getguardsize)
-
-#if 0 /* uClibc: deprecated stuff disabled */
-int __pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr)
-{
-  attr->__stackaddr = stackaddr;
-  attr->__stackaddr_set = 1;
-  return 0;
-}
-weak_alias (__pthread_attr_setstackaddr, pthread_attr_setstackaddr)
-
-int __pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackaddr)
-{
-  /* XXX This function has a stupid definition.  The standard specifies
-     no error value but what is if no stack address was set?  We simply
-     return the value we have in the member.  */
-  *stackaddr = attr->__stackaddr;
-  return 0;
-}
-weak_alias (__pthread_attr_getstackaddr, pthread_attr_getstackaddr)
-#endif
-
-int __pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize)
-{
-  /* We don't accept value smaller than PTHREAD_STACK_MIN.  */
-  if (stacksize < PTHREAD_STACK_MIN)
-    return EINVAL;
-
-  attr->__stacksize = stacksize;
-  return 0;
-}
-weak_alias (__pthread_attr_setstacksize, pthread_attr_setstacksize)
-
-int __pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize)
-{
-  *stacksize = attr->__stacksize;
-  return 0;
-}
-weak_alias (__pthread_attr_getstacksize, pthread_attr_getstacksize)
diff --git a/libpthread/linuxthreads.old/cancel.c b/libpthread/linuxthreads.old/cancel.c
deleted file mode 100644
index 392d1d586..000000000
--- a/libpthread/linuxthreads.old/cancel.c
+++ /dev/null
@@ -1,219 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Thread cancellation */
-
-#include <errno.h>
-#include "pthread.h"
-#include "internals.h"
-#include "spinlock.h"
-#include "restart.h"
-#ifdef __UCLIBC_HAS_RPC__
-#include <rpc/rpc.h>
-extern void __rpc_thread_destroy(void);
-#endif
-#include <bits/stackinfo.h>
-
-#include <stdio.h>
-
-#ifdef _STACK_GROWS_DOWN
-# define FRAME_LEFT(frame, other) ((char *) frame >= (char *) other)
-#elif defined _STACK_GROWS_UP
-# define FRAME_LEFT(frame, other) ((char *) frame <= (char *) other)
-#else
-# error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
-#endif
-
-libpthread_hidden_proto(pthread_setcancelstate)
-libpthread_hidden_proto(pthread_setcanceltype)
-
-int pthread_setcancelstate(int state, int * oldstate)
-{
-  pthread_descr self = thread_self();
-  if (state < PTHREAD_CANCEL_ENABLE || state > PTHREAD_CANCEL_DISABLE)
-    return EINVAL;
-  if (oldstate != NULL) *oldstate = THREAD_GETMEM(self, p_cancelstate);
-  THREAD_SETMEM(self, p_cancelstate, state);
-  if (THREAD_GETMEM(self, p_canceled) &&
-      THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE &&
-      THREAD_GETMEM(self, p_canceltype) == PTHREAD_CANCEL_ASYNCHRONOUS)
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-  return 0;
-}
-libpthread_hidden_def(pthread_setcancelstate)
-
-int pthread_setcanceltype(int type, int * oldtype)
-{
-  pthread_descr self = thread_self();
-  if (type < PTHREAD_CANCEL_DEFERRED || type > PTHREAD_CANCEL_ASYNCHRONOUS)
-    return EINVAL;
-  if (oldtype != NULL) *oldtype = THREAD_GETMEM(self, p_canceltype);
-  THREAD_SETMEM(self, p_canceltype, type);
-  if (THREAD_GETMEM(self, p_canceled) &&
-      THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE &&
-      THREAD_GETMEM(self, p_canceltype) == PTHREAD_CANCEL_ASYNCHRONOUS)
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-  return 0;
-}
-libpthread_hidden_def(pthread_setcanceltype)
-
-int pthread_cancel(pthread_t thread)
-{
-  pthread_handle handle = thread_handle(thread);
-  int pid;
-  int dorestart = 0;
-  pthread_descr th;
-  pthread_extricate_if *pextricate;
-  int already_canceled;
-
-  __pthread_lock(&handle->h_lock, NULL);
-  if (invalid_handle(handle, thread)) {
-    __pthread_unlock(&handle->h_lock);
-    return ESRCH;
-  }
-
-  th = handle->h_descr;
-
-  already_canceled = th->p_canceled;
-  th->p_canceled = 1;
-
-  if (th->p_cancelstate == PTHREAD_CANCEL_DISABLE || already_canceled) {
-    __pthread_unlock(&handle->h_lock);
-    return 0;
-  }
-
-  pextricate = th->p_extricate;
-  pid = th->p_pid;
-
-  /* If the thread has registered an extrication interface, then
-     invoke the interface. If it returns 1, then we succeeded in
-     dequeuing the thread from whatever waiting object it was enqueued
-     with. In that case, it is our responsibility to wake it up.
-     And also to set the p_woken_by_cancel flag so the woken thread
-     can tell that it was woken by cancellation. */
-
-  if (pextricate != NULL) {
-    dorestart = pextricate->pu_extricate_func(pextricate->pu_object, th);
-    th->p_woken_by_cancel = dorestart;
-  }
-
-  __pthread_unlock(&handle->h_lock);
-
-  /* If the thread has suspended or is about to, then we unblock it by
-     issuing a restart, instead of a cancel signal. Otherwise we send
-     the cancel signal to unblock the thread from a cancellation point,
-     or to initiate asynchronous cancellation. The restart is needed so
-     we have proper accounting of restarts; suspend decrements the thread's
-     resume count, and restart() increments it.  This also means that suspend's
-     handling of the cancel signal is obsolete. */
-
-  if (dorestart)
-    restart(th);
-  else
-    kill(pid, __pthread_sig_cancel);
-
-  return 0;
-}
-
-void pthread_testcancel(void)
-{
-  pthread_descr self = thread_self();
-  if (THREAD_GETMEM(self, p_canceled)
-      && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE)
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-}
-
-void _pthread_cleanup_push(struct _pthread_cleanup_buffer * buffer,
-			   void (*routine)(void *), void * arg)
-{
-  pthread_descr self = thread_self();
-  buffer->__routine = routine;
-  buffer->__arg = arg;
-  buffer->__prev = THREAD_GETMEM(self, p_cleanup);
-  if (buffer->__prev != NULL && FRAME_LEFT (buffer, buffer->__prev))
-    buffer->__prev = NULL;
-  THREAD_SETMEM(self, p_cleanup, buffer);
-}
-
-void _pthread_cleanup_pop(struct _pthread_cleanup_buffer * buffer,
-			  int execute)
-{
-  pthread_descr self = thread_self();
-  if (execute) buffer->__routine(buffer->__arg);
-  THREAD_SETMEM(self, p_cleanup, buffer->__prev);
-}
-
-void _pthread_cleanup_push_defer(struct _pthread_cleanup_buffer * buffer,
-				 void (*routine)(void *), void * arg)
-{
-  pthread_descr self = thread_self();
-  buffer->__routine = routine;
-  buffer->__arg = arg;
-  buffer->__canceltype = THREAD_GETMEM(self, p_canceltype);
-  buffer->__prev = THREAD_GETMEM(self, p_cleanup);
-  if (buffer->__prev != NULL && FRAME_LEFT (buffer, buffer->__prev))
-    buffer->__prev = NULL;
-  THREAD_SETMEM(self, p_canceltype, PTHREAD_CANCEL_DEFERRED);
-  THREAD_SETMEM(self, p_cleanup, buffer);
-}
-strong_alias(_pthread_cleanup_push_defer,__pthread_cleanup_push_defer)
-
-void _pthread_cleanup_pop_restore(struct _pthread_cleanup_buffer * buffer,
-				  int execute)
-{
-  pthread_descr self = thread_self();
-  if (execute) buffer->__routine(buffer->__arg);
-  THREAD_SETMEM(self, p_cleanup, buffer->__prev);
-  THREAD_SETMEM(self, p_canceltype, buffer->__canceltype);
-  if (THREAD_GETMEM(self, p_canceled) &&
-      THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE &&
-      THREAD_GETMEM(self, p_canceltype) == PTHREAD_CANCEL_ASYNCHRONOUS)
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-}
-strong_alias(_pthread_cleanup_pop_restore,__pthread_cleanup_pop_restore)
-
-
-void __pthread_perform_cleanup(char *currentframe)
-{
-  pthread_descr self = thread_self();
-  struct _pthread_cleanup_buffer * c;
-
-  for (c = THREAD_GETMEM(self, p_cleanup); c != NULL; c = c->__prev)
-    {
-#ifdef _STACK_GROWS_DOWN
-      if ((char *) c <= currentframe)
-	break;
-#elif defined _STACK_GROWS_UP
-      if ((char *) c >= currentframe)
-	break;
-#else
-# error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
-#endif
-      c->__routine(c->__arg);
-    }
-
-#ifdef __UCLIBC_HAS_RPC__
-  /* And the TSD which needs special help.  */
-  if (THREAD_GETMEM(self, p_libc_specific[_LIBC_TSD_KEY_RPC_VARS]) != NULL)
-      __rpc_thread_destroy ();
-#endif
-}
-
-#ifndef __PIC__
-/* We need a hook to force the cancellation wrappers to be linked in when
-   static libpthread is used.  */
-extern const char __pthread_provide_wrappers;
-static const char *const __pthread_require_wrappers =
-  &__pthread_provide_wrappers;
-#endif
diff --git a/libpthread/linuxthreads.old/condvar.c b/libpthread/linuxthreads.old/condvar.c
deleted file mode 100644
index 35daacf15..000000000
--- a/libpthread/linuxthreads.old/condvar.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/* and Pavel Krauz (krauz@fsid.cvut.cz).                                */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Condition variables */
-
-#include <errno.h>
-#include <sched.h>
-#include <stddef.h>
-#include <sys/time.h>
-#include "pthread.h"
-#include "internals.h"
-#include "spinlock.h"
-#include "queue.h"
-#include "restart.h"
-
-int pthread_cond_init(pthread_cond_t *cond,
-                      const pthread_condattr_t *cond_attr attribute_unused)
-{
-  __pthread_init_lock(&cond->__c_lock);
-  cond->__c_waiting = NULL;
-  return 0;
-}
-libpthread_hidden_def(pthread_cond_init)
-
-int pthread_cond_destroy(pthread_cond_t *cond)
-{
-  if (cond->__c_waiting != NULL) return EBUSY;
-  return 0;
-}
-libpthread_hidden_def(pthread_cond_destroy)
-
-/* Function called by pthread_cancel to remove the thread from
-   waiting on a condition variable queue. */
-
-static int cond_extricate_func(void *obj, pthread_descr th)
-{
-  volatile pthread_descr self = thread_self();
-  pthread_cond_t *cond = obj;
-  int did_remove = 0;
-
-  __pthread_lock(&cond->__c_lock, self);
-  did_remove = remove_from_queue(&cond->__c_waiting, th);
-  __pthread_unlock(&cond->__c_lock);
-
-  return did_remove;
-}
-
-int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
-{
-  volatile pthread_descr self = thread_self();
-  pthread_extricate_if extr;
-  int already_canceled = 0;
-  int spurious_wakeup_count;
-
-  /* Check whether the mutex is locked and owned by this thread.  */
-  if (mutex->__m_kind != PTHREAD_MUTEX_TIMED_NP
-      && mutex->__m_kind != PTHREAD_MUTEX_ADAPTIVE_NP
-      && mutex->__m_owner != self)
-    return EINVAL;
-
-  /* Set up extrication interface */
-  extr.pu_object = cond;
-  extr.pu_extricate_func = cond_extricate_func;
-
-  /* Register extrication interface */
-  THREAD_SETMEM(self, p_condvar_avail, 0);
-  __pthread_set_own_extricate_if(self, &extr);
-
-  /* Atomically enqueue thread for waiting, but only if it is not
-     canceled. If the thread is canceled, then it will fall through the
-     suspend call below, and then call pthread_exit without
-     having to worry about whether it is still on the condition variable queue.
-     This depends on pthread_cancel setting p_canceled before calling the
-     extricate function. */
-
-  __pthread_lock(&cond->__c_lock, self);
-  if (!(THREAD_GETMEM(self, p_canceled)
-      && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE))
-    enqueue(&cond->__c_waiting, self);
-  else
-    already_canceled = 1;
-  __pthread_unlock(&cond->__c_lock);
-
-  if (already_canceled) {
-    __pthread_set_own_extricate_if(self, 0);
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-  }
-
-  __pthread_mutex_unlock(mutex);
-
-  spurious_wakeup_count = 0;
-  while (1)
-    {
-      suspend(self);
-      if (THREAD_GETMEM(self, p_condvar_avail) == 0
-	  && (THREAD_GETMEM(self, p_woken_by_cancel) == 0
-	      || THREAD_GETMEM(self, p_cancelstate) != PTHREAD_CANCEL_ENABLE))
-	{
-	  /* Count resumes that don't belong to us. */
-	  spurious_wakeup_count++;
-	  continue;
-	}
-      break;
-    }
-
-  __pthread_set_own_extricate_if(self, 0);
-
-  /* Check for cancellation again, to provide correct cancellation
-     point behavior */
-
-  if (THREAD_GETMEM(self, p_woken_by_cancel)
-      && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE) {
-    THREAD_SETMEM(self, p_woken_by_cancel, 0);
-    __pthread_mutex_lock(mutex);
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-  }
-
-  /* Put back any resumes we caught that don't belong to us. */
-  while (spurious_wakeup_count--)
-    restart(self);
-
-  __pthread_mutex_lock(mutex);
-  return 0;
-}
-libpthread_hidden_def(pthread_cond_wait)
-
-static int
-pthread_cond_timedwait_relative(pthread_cond_t *cond,
-				pthread_mutex_t *mutex,
-				const struct timespec * abstime)
-{
-  volatile pthread_descr self = thread_self();
-  int already_canceled = 0;
-  pthread_extricate_if extr;
-  int spurious_wakeup_count;
-
-  /* Check whether the mutex is locked and owned by this thread.  */
-  if (mutex->__m_kind != PTHREAD_MUTEX_TIMED_NP
-      && mutex->__m_kind != PTHREAD_MUTEX_ADAPTIVE_NP
-      && mutex->__m_owner != self)
-    return EINVAL;
-
-  /* Set up extrication interface */
-  extr.pu_object = cond;
-  extr.pu_extricate_func = cond_extricate_func;
-
-  /* Register extrication interface */
-  THREAD_SETMEM(self, p_condvar_avail, 0);
-  __pthread_set_own_extricate_if(self, &extr);
-
-  /* Enqueue to wait on the condition and check for cancellation. */
-  __pthread_lock(&cond->__c_lock, self);
-  if (!(THREAD_GETMEM(self, p_canceled)
-      && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE))
-    enqueue(&cond->__c_waiting, self);
-  else
-    already_canceled = 1;
-  __pthread_unlock(&cond->__c_lock);
-
-  if (already_canceled) {
-    __pthread_set_own_extricate_if(self, 0);
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-  }
-
-  __pthread_mutex_unlock(mutex);
-
-  spurious_wakeup_count = 0;
-  while (1)
-    {
-      if (!timedsuspend(self, abstime)) {
-	int was_on_queue;
-
-	/* __pthread_lock will queue back any spurious restarts that
-	   may happen to it. */
-
-	__pthread_lock(&cond->__c_lock, self);
-	was_on_queue = remove_from_queue(&cond->__c_waiting, self);
-	__pthread_unlock(&cond->__c_lock);
-
-	if (was_on_queue) {
-	  __pthread_set_own_extricate_if(self, 0);
-	  __pthread_mutex_lock(mutex);
-	  return ETIMEDOUT;
-	}
-
-	/* Eat the outstanding restart() from the signaller */
-	suspend(self);
-      }
-
-      if (THREAD_GETMEM(self, p_condvar_avail) == 0
-	  && (THREAD_GETMEM(self, p_woken_by_cancel) == 0
-	      || THREAD_GETMEM(self, p_cancelstate) != PTHREAD_CANCEL_ENABLE))
-	{
-	  /* Count resumes that don't belong to us. */
-	  spurious_wakeup_count++;
-	  continue;
-	}
-      break;
-    }
-
-  __pthread_set_own_extricate_if(self, 0);
-
-  /* The remaining logic is the same as in other cancellable waits,
-     such as pthread_join sem_wait or pthread_cond wait. */
-
-  if (THREAD_GETMEM(self, p_woken_by_cancel)
-      && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE) {
-    THREAD_SETMEM(self, p_woken_by_cancel, 0);
-    __pthread_mutex_lock(mutex);
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-  }
-
-  /* Put back any resumes we caught that don't belong to us. */
-  while (spurious_wakeup_count--)
-    restart(self);
-
-  __pthread_mutex_lock(mutex);
-  return 0;
-}
-
-int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
-                           const struct timespec * abstime)
-{
-  /* Indirect call through pointer! */
-  return pthread_cond_timedwait_relative(cond, mutex, abstime);
-}
-libpthread_hidden_def(pthread_cond_timedwait)
-
-int pthread_cond_signal(pthread_cond_t *cond)
-{
-  pthread_descr th;
-
-  __pthread_lock(&cond->__c_lock, NULL);
-  th = dequeue(&cond->__c_waiting);
-  __pthread_unlock(&cond->__c_lock);
-  if (th != NULL) {
-    th->p_condvar_avail = 1;
-    WRITE_MEMORY_BARRIER();
-    restart(th);
-  }
-  return 0;
-}
-libpthread_hidden_def(pthread_cond_signal)
-
-int pthread_cond_broadcast(pthread_cond_t *cond)
-{
-  pthread_descr tosignal, th;
-
-  __pthread_lock(&cond->__c_lock, NULL);
-  /* Copy the current state of the waiting queue and empty it */
-  tosignal = cond->__c_waiting;
-  cond->__c_waiting = NULL;
-  __pthread_unlock(&cond->__c_lock);
-  /* Now signal each process in the queue */
-  while ((th = dequeue(&tosignal)) != NULL) {
-    th->p_condvar_avail = 1;
-    WRITE_MEMORY_BARRIER();
-    restart(th);
-  }
-  return 0;
-}
-libpthread_hidden_def(pthread_cond_broadcast)
-
-int pthread_condattr_init(pthread_condattr_t *attr attribute_unused)
-{
-  return 0;
-}
-libpthread_hidden_def(pthread_condattr_init)
-
-int pthread_condattr_destroy(pthread_condattr_t *attr attribute_unused)
-{
-  return 0;
-}
-libpthread_hidden_def(pthread_condattr_destroy)
-
-int pthread_condattr_getpshared (const pthread_condattr_t *attr attribute_unused, int *pshared)
-{
-  *pshared = PTHREAD_PROCESS_PRIVATE;
-  return 0;
-}
-
-int pthread_condattr_setpshared (pthread_condattr_t *attr attribute_unused, int pshared)
-{
-  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
-    return EINVAL;
-
-  /* For now it is not possible to shared a conditional variable.  */
-  if (pshared != PTHREAD_PROCESS_PRIVATE)
-    return ENOSYS;
-
-  return 0;
-}
diff --git a/libpthread/linuxthreads.old/errno.c b/libpthread/linuxthreads.old/errno.c
deleted file mode 100644
index 748c1d512..000000000
--- a/libpthread/linuxthreads.old/errno.c
+++ /dev/null
@@ -1,35 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Define the location of errno for the remainder of the C library */
-
-#include <errno.h>
-#include <netdb.h>
-#include "pthread.h"
-#include "internals.h"
-#include <stdio.h>
-
-int *
-__errno_location (void)
-{
-  pthread_descr self = thread_self();
-  return THREAD_GETMEM (self, p_errnop);
-}
-
-int *
-__h_errno_location (void)
-{
-  pthread_descr self = thread_self();
-  return THREAD_GETMEM (self, p_h_errnop);
-}
diff --git a/libpthread/linuxthreads.old/events.c b/libpthread/linuxthreads.old/events.c
deleted file mode 100644
index 2a76f91d4..000000000
--- a/libpthread/linuxthreads.old/events.c
+++ /dev/null
@@ -1,36 +0,0 @@
-/* Event functions used while debugging.
-   Copyright (C) 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-/* The functions contained here do nothing, they just return.  */
-
-#include "internals.h"
-
-void
-__linuxthreads_create_event (void)
-{
-}
-
-void
-__linuxthreads_death_event (void)
-{
-}
-
-void
-__linuxthreads_reap_event (void)
-{
-}
diff --git a/libpthread/linuxthreads.old/forward.c b/libpthread/linuxthreads.old/forward.c
deleted file mode 100644
index 5a1771b90..000000000
--- a/libpthread/linuxthreads.old/forward.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <features.h>
-#include <stdlib.h>
-#include <dlfcn.h>
-
-/* psm: keep this before internals.h */
-#if 0
-vda: here is why:
-headers contain libc_hidden_proto(foo).
-In libpthread/linuxthreads.old/sysdeps/pthread/bits/libc-lock.h
-adding libc_hidden_proto(foo) just before weak_extern (__pthread_initialize)
-will not warn:
-    /* libc_hidden_proto(foo) */
-    weak_extern (__pthread_initialize)
-    /* libc_hidden_proto(foo) */
-but adding after will! Which is extremely strange -
-weak_extern expands into just "#pragma weak __pthread_initialize".
-TODO: determine whether it is a gcc bug or what
-(see gcc.gnu.org/PR36282).
-For now, just include all headers before internals.h
-(they are again included in internals.h - maybe remove them there later)
-#endif
-
-#include <string.h>
-#include <limits.h>
-#include <setjmp.h>
-#include <signal.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <sys/time.h>
-
-#include "internals.h"
-
-/* Pointers to the libc functions.  */
-struct pthread_functions __libc_pthread_functions attribute_hidden;
-
-
-# define FORWARD2(name, rettype, decl, params, defaction) \
-rettype									      \
-name decl								      \
-{									      \
-  if (__libc_pthread_functions.ptr_##name == NULL)			      \
-    defaction;								      \
-									      \
-  return __libc_pthread_functions.ptr_##name params;			      \
-}
-
-# define FORWARD(name, decl, params, defretval) \
-  FORWARD2 (name, int, decl, params, return defretval)
-
-FORWARD (pthread_attr_destroy, (pthread_attr_t *attr), (attr), 0)
-
-FORWARD (pthread_attr_init, (pthread_attr_t *attr), (attr), 0)
-
-FORWARD (pthread_attr_getdetachstate,
-	 (const pthread_attr_t *attr, int *detachstate), (attr, detachstate),
-	 0)
-FORWARD (pthread_attr_setdetachstate, (pthread_attr_t *attr, int detachstate),
-	 (attr, detachstate), 0)
-
-FORWARD (pthread_attr_getinheritsched,
-	 (const pthread_attr_t *attr, int *inherit), (attr, inherit), 0)
-FORWARD (pthread_attr_setinheritsched, (pthread_attr_t *attr, int inherit),
-	 (attr, inherit), 0)
-
-FORWARD (pthread_attr_getschedparam,
-	 (const pthread_attr_t *attr, struct sched_param *param),
-	 (attr, param), 0)
-FORWARD (pthread_attr_setschedparam,
-	 (pthread_attr_t *attr, const struct sched_param *param),
-	 (attr, param), 0)
-
-FORWARD (pthread_attr_getschedpolicy,
-	 (const pthread_attr_t *attr, int *policy), (attr, policy), 0)
-FORWARD (pthread_attr_setschedpolicy, (pthread_attr_t *attr, int policy),
-	 (attr, policy), 0)
-
-FORWARD (pthread_attr_getscope,
-	 (const pthread_attr_t *attr, int *scope), (attr, scope), 0)
-FORWARD (pthread_attr_setscope, (pthread_attr_t *attr, int scope),
-	 (attr, scope), 0)
-
-
-FORWARD (pthread_condattr_destroy, (pthread_condattr_t *attr), (attr), 0)
-FORWARD (pthread_condattr_init, (pthread_condattr_t *attr), (attr), 0)
-
-
-FORWARD (pthread_cond_broadcast, (pthread_cond_t *cond), (cond), 0)
-
-FORWARD (pthread_cond_destroy, (pthread_cond_t *cond), (cond), 0)
-
-FORWARD (pthread_cond_init,
-	 (pthread_cond_t *cond, const pthread_condattr_t *cond_attr),
-	 (cond, cond_attr), 0)
-
-FORWARD (pthread_cond_signal, (pthread_cond_t *cond), (cond), 0)
-
-FORWARD (pthread_cond_wait, (pthread_cond_t *cond, pthread_mutex_t *mutex),
-	 (cond, mutex), 0)
-
-FORWARD (pthread_cond_timedwait,
-	 (pthread_cond_t *cond, pthread_mutex_t *mutex,
-	  const struct timespec *abstime), (cond, mutex, abstime), 0)
-
-
-FORWARD (pthread_equal, (pthread_t thread1, pthread_t thread2),
-	 (thread1, thread2), 1)
-
-
-/* Use an alias to avoid warning, as pthread_exit is declared noreturn.  */
-FORWARD2 (__pthread_exit, void, (void *retval), (retval), exit (EXIT_SUCCESS))
-strong_alias (__pthread_exit, pthread_exit)
-
-
-FORWARD (pthread_getschedparam,
-	 (pthread_t target_thread, int *policy, struct sched_param *param),
-	 (target_thread, policy, param), 0)
-FORWARD (pthread_setschedparam,
-	 (pthread_t target_thread, int policy,
-	  const struct sched_param *param), (target_thread, policy, param), 0)
-
-
-FORWARD (pthread_mutex_destroy, (pthread_mutex_t *mutex), (mutex), 0)
-
-FORWARD (pthread_mutex_init,
-	 (pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr),
-	 (mutex, mutexattr), 0)
-strong_alias(pthread_mutex_init, __pthread_mutex_init)
-
-FORWARD (pthread_mutex_lock, (pthread_mutex_t *mutex), (mutex), 0)
-strong_alias(pthread_mutex_lock, __pthread_mutex_lock)
-
-FORWARD (pthread_mutex_trylock, (pthread_mutex_t *mutex), (mutex), 0)
-strong_alias(pthread_mutex_trylock, __pthread_mutex_trylock)
-
-FORWARD (pthread_mutex_unlock, (pthread_mutex_t *mutex), (mutex), 0)
-strong_alias(pthread_mutex_unlock, __pthread_mutex_unlock)
-
-FORWARD2 (pthread_self, pthread_t, (void), (), return 0)
-
-
-FORWARD (pthread_setcancelstate, (int state, int *oldstate), (state, oldstate),
-	 0)
-
-FORWARD (pthread_setcanceltype, (int type, int *oldtype), (type, oldtype), 0)
-
-#if 0
-FORWARD2 (_pthread_cleanup_push, void, (struct _pthread_cleanup_buffer * buffer, void (*routine)(void *), void * arg), (buffer, routine, arg), return)
-#endif
-FORWARD2 (_pthread_cleanup_push_defer, void, (struct _pthread_cleanup_buffer * buffer, void (*routine)(void *), void * arg), (buffer, routine, arg), return)
-
-#if 0
-FORWARD2 (_pthread_cleanup_pop, void, (struct _pthread_cleanup_buffer * buffer, int execute), (buffer, execute), return)
-#endif
-FORWARD2 (_pthread_cleanup_pop_restore, void, (struct _pthread_cleanup_buffer * buffer, int execute), (buffer, execute), return)
diff --git a/libpthread/linuxthreads.old/internals.h b/libpthread/linuxthreads.old/internals.h
deleted file mode 100644
index ea274d824..000000000
--- a/libpthread/linuxthreads.old/internals.h
+++ /dev/null
@@ -1,529 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-#ifndef _INTERNALS_H
-#define _INTERNALS_H   1
-
-/* Internal data structures */
-
-/* Includes */
-
-#include <bits/libc-tsd.h> /* for _LIBC_TSD_KEY_N */
-#include <limits.h>
-#include <setjmp.h>
-#include <signal.h>
-#include <unistd.h>
-#include <bits/stackinfo.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include "pt-machine.h"
-#include "semaphore.h"
-#include "../linuxthreads.old_db/thread_dbP.h"
-#ifdef __UCLIBC_HAS_XLOCALE__
-#include <bits/uClibc_locale.h>
-#endif /* __UCLIBC_HAS_XLOCALE__ */
-
-/* Use a funky version in a probably vein attempt at preventing gdb
- * from dlopen()'ing glibc's libthread_db library... */
-#define VERSION __stringify(__UCLIBC_MAJOR__) "." __stringify(__UCLIBC_MINOR__) "." __stringify(__UCLIBC_SUBLEVEL__)
-
-#ifndef THREAD_GETMEM
-# define THREAD_GETMEM(descr, member) descr->member
-#endif
-#ifndef THREAD_GETMEM_NC
-# define THREAD_GETMEM_NC(descr, member) descr->member
-#endif
-#ifndef THREAD_SETMEM
-# define THREAD_SETMEM(descr, member, value) descr->member = (value)
-#endif
-#ifndef THREAD_SETMEM_NC
-# define THREAD_SETMEM_NC(descr, member, value) descr->member = (value)
-#endif
-
-/* Arguments passed to thread creation routine */
-
-struct pthread_start_args {
-  void * (*start_routine)(void *); /* function to run */
-  void * arg;                   /* its argument */
-  sigset_t mask;                /* initial signal mask for thread */
-  int schedpolicy;              /* initial scheduling policy (if any) */
-  struct sched_param schedparam; /* initial scheduling parameters (if any) */
-};
-
-
-/* We keep thread specific data in a special data structure, a two-level
-   array.  The top-level array contains pointers to dynamically allocated
-   arrays of a certain number of data pointers.  So we can implement a
-   sparse array.  Each dynamic second-level array has
-	PTHREAD_KEY_2NDLEVEL_SIZE
-   entries.  This value shouldn't be too large.  */
-#define PTHREAD_KEY_2NDLEVEL_SIZE	32
-
-/* We need to address PTHREAD_KEYS_MAX key with PTHREAD_KEY_2NDLEVEL_SIZE
-   keys in each subarray.  */
-#define PTHREAD_KEY_1STLEVEL_SIZE \
-  ((PTHREAD_KEYS_MAX + PTHREAD_KEY_2NDLEVEL_SIZE - 1) \
-   / PTHREAD_KEY_2NDLEVEL_SIZE)
-
-typedef void (*destr_function)(void *);
-
-struct pthread_key_struct {
-  int in_use;                   /* already allocated? */
-  destr_function destr;         /* destruction routine */
-};
-
-
-#define PTHREAD_START_ARGS_INITIALIZER { NULL, NULL, {{0, }}, 0, { 0 } }
-
-/* The type of thread descriptors */
-
-typedef struct _pthread_descr_struct * pthread_descr;
-
-/* Callback interface for removing the thread from waiting on an
-   object if it is cancelled while waiting or about to wait.
-   This hold a pointer to the object, and a pointer to a function
-   which ``extricates'' the thread from its enqueued state.
-   The function takes two arguments: pointer to the wait object,
-   and a pointer to the thread. It returns 1 if an extrication
-   actually occured, and hence the thread must also be signalled.
-   It returns 0 if the thread had already been extricated. */
-
-typedef struct _pthread_extricate_struct {
-    void *pu_object;
-    int (*pu_extricate_func)(void *, pthread_descr);
-} pthread_extricate_if;
-
-/* Atomic counter made possible by compare_and_swap */
-
-struct pthread_atomic {
-  long p_count;
-  int p_spinlock;
-};
-
-/* Context info for read write locks. The pthread_rwlock_info structure
-   is information about a lock that has been read-locked by the thread
-   in whose list this structure appears. The pthread_rwlock_context
-   is embedded in the thread context and contains a pointer to the
-   head of the list of lock info structures, as well as a count of
-   read locks that are untracked, because no info structure could be
-   allocated for them. */
-
-struct _pthread_rwlock_t;
-
-typedef struct _pthread_rwlock_info {
-  struct _pthread_rwlock_info *pr_next;
-  struct _pthread_rwlock_t *pr_lock;
-  int pr_lock_count;
-} pthread_readlock_info;
-
-struct _pthread_descr_struct {
-  pthread_descr p_nextlive, p_prevlive;
-                                /* Double chaining of active threads */
-  pthread_descr p_nextwaiting;  /* Next element in the queue holding the thr */
-  pthread_descr p_nextlock;	/* can be on a queue and waiting on a lock */
-  pthread_t p_tid;              /* Thread identifier */
-  int p_pid;                    /* PID of Unix process */
-  int p_priority;               /* Thread priority (== 0 if not realtime) */
-  struct _pthread_fastlock * p_lock; /* Spinlock for synchronized accesses */
-  int p_signal;                 /* last signal received */
-  sigjmp_buf * p_signal_jmp;    /* where to siglongjmp on a signal or NULL */
-  sigjmp_buf * p_cancel_jmp;    /* where to siglongjmp on a cancel or NULL */
-  char p_terminated;            /* true if terminated e.g. by pthread_exit */
-  char p_detached;              /* true if detached */
-  char p_exited;                /* true if the assoc. process terminated */
-  void * p_retval;              /* placeholder for return value */
-  int p_retcode;                /* placeholder for return code */
-  pthread_descr p_joining;      /* thread joining on that thread or NULL */
-  struct _pthread_cleanup_buffer * p_cleanup; /* cleanup functions */
-  char p_cancelstate;           /* cancellation state */
-  char p_canceltype;            /* cancellation type (deferred/async) */
-  char p_canceled;              /* cancellation request pending */
-  int * p_errnop;               /* pointer to used errno variable */
-  int p_errno;                  /* error returned by last system call */
-  int * p_h_errnop;             /* pointer to used h_errno variable */
-  int p_h_errno;                /* error returned by last netdb function */
-  char * p_in_sighandler;       /* stack address of sighandler, or NULL */
-  char p_sigwaiting;            /* true if a sigwait() is in progress */
-  struct pthread_start_args p_start_args; /* arguments for thread creation */
-  void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE]; /* thread-specific data */
-  void * p_libc_specific[_LIBC_TSD_KEY_N]; /* thread-specific data for libc */
-  int p_userstack;		/* nonzero if the user provided the stack */
-  void *p_guardaddr;		/* address of guard area or NULL */
-  size_t p_guardsize;		/* size of guard area */
-  pthread_descr p_self;		/* Pointer to this structure */
-  int p_nr;                     /* Index of descriptor in __pthread_handles */
-  int p_report_events;         /* Nonzero if events must be reported.  */
-  td_eventbuf_t p_eventbuf;     /* Data for event.  */
-  struct pthread_atomic p_resume_count; /* number of times restart() was
-					   called on thread */
-  char p_woken_by_cancel;       /* cancellation performed wakeup */
-  char p_condvar_avail;         /* flag if conditional variable became avail */
-  char p_sem_avail;             /* flag if semaphore became available */
-  pthread_extricate_if *p_extricate; /* See above */
-  pthread_readlock_info *p_readlock_list;  /* List of readlock info structs */
-  pthread_readlock_info *p_readlock_free;  /* Free list of structs */
-  int p_untracked_readlock_count;	/* Readlocks not tracked by list */
-  /* New elements must be added at the end.  */
-#ifdef __UCLIBC_HAS_XLOCALE__
-  __locale_t locale; /* thread-specific locale from uselocale() only! */
-#endif /* __UCLIBC_HAS_XLOCALE__ */
-} __attribute__ ((aligned(32))); /* We need to align the structure so that
-				    doubles are aligned properly.  This is 8
-				    bytes on MIPS and 16 bytes on MIPS64.
-				    32 bytes might give better cache
-				    utilization.  */
-
-/* The type of thread handles. */
-
-typedef struct pthread_handle_struct * pthread_handle;
-
-struct pthread_handle_struct {
-  struct _pthread_fastlock h_lock; /* Fast lock for sychronized access */
-  pthread_descr h_descr;        /* Thread descriptor or NULL if invalid */
-  char * h_bottom;              /* Lowest address in the stack thread */
-};
-
-/* The type of messages sent to the thread manager thread */
-
-struct pthread_request {
-  pthread_descr req_thread;     /* Thread doing the request */
-  enum {                        /* Request kind */
-    REQ_CREATE, REQ_FREE, REQ_PROCESS_EXIT, REQ_MAIN_THREAD_EXIT,
-    REQ_POST, REQ_DEBUG, REQ_KICK
-  } req_kind;
-  union {                       /* Arguments for request */
-    struct {                    /* For REQ_CREATE: */
-      const pthread_attr_t * attr; /* thread attributes */
-      void * (*fn)(void *);     /*   start function */
-      void * arg;               /*   argument to start function */
-      sigset_t mask;            /*   signal mask */
-    } create;
-    struct {                    /* For REQ_FREE: */
-      pthread_t thread_id;      /*   identifier of thread to free */
-    } free;
-    struct {                    /* For REQ_PROCESS_EXIT: */
-      int code;                 /*   exit status */
-    } exit;
-    void * post;                /* For REQ_POST: the semaphore */
-  } req_args;
-};
-
-
-/* Signals used for suspend/restart and for cancellation notification.  */
-
-extern int __pthread_sig_restart;
-extern int __pthread_sig_cancel;
-
-/* Signal used for interfacing with gdb */
-
-extern int __pthread_sig_debug;
-
-/* Global array of thread handles, used for validating a thread id
-   and retrieving the corresponding thread descriptor. Also used for
-   mapping the available stack segments. */
-
-extern struct pthread_handle_struct __pthread_handles[PTHREAD_THREADS_MAX];
-
-/* Descriptor of the initial thread */
-
-extern struct _pthread_descr_struct __pthread_initial_thread;
-
-/* Descriptor of the manager thread */
-
-extern struct _pthread_descr_struct __pthread_manager_thread;
-
-/* Descriptor of the main thread */
-
-extern pthread_descr __pthread_main_thread;
-
-/* Limit between the stack of the initial thread (above) and the
-   stacks of other threads (below). Aligned on a STACK_SIZE boundary.
-   Initially 0, meaning that the current thread is (by definition)
-   the initial thread. */
-
-extern char *__pthread_initial_thread_bos;
-#ifndef __ARCH_USE_MMU__
-/* For non-MMU systems, we have no idea the bounds of the initial thread
- * stack, so we have to track it on the fly relative to other stacks.  Do
- * so by scaling back our assumptions on the limits of the bos/tos relative
- * to the known mid point.  See also the comments in pthread_initialize(). */
-extern char *__pthread_initial_thread_tos, *__pthread_initial_thread_mid;
-#define NOMMU_INITIAL_THREAD_BOUNDS(tos,bos) \
-	do { \
-		char *__tos = (tos); \
-		char *__bos = (bos); \
-		if (__tos >= __pthread_initial_thread_bos && \
-		    __bos < __pthread_initial_thread_tos) { \
-			if (__bos < __pthread_initial_thread_mid) \
-				__pthread_initial_thread_bos = __tos; \
-			else \
-				__pthread_initial_thread_tos = __bos; \
-		} \
-	} while (0)
-#else
-#define NOMMU_INITIAL_THREAD_BOUNDS(tos,bos) /* empty */
-#endif /* __ARCH_USE_MMU__ */
-
-
-/* Indicate whether at least one thread has a user-defined stack (if 1),
-   or all threads have stacks supplied by LinuxThreads (if 0). */
-
-extern int __pthread_nonstandard_stacks;
-
-/* File descriptor for sending requests to the thread manager.
-   Initially -1, meaning that __pthread_initialize_manager must be called. */
-
-extern int __pthread_manager_request;
-
-/* Other end of the pipe for sending requests to the thread manager. */
-
-extern int __pthread_manager_reader;
-
-/* Limits of the thread manager stack. */
-
-extern char *__pthread_manager_thread_bos;
-extern char *__pthread_manager_thread_tos;
-
-/* Pending request for a process-wide exit */
-
-extern int __pthread_exit_requested, __pthread_exit_code;
-
-/* Set to 1 by gdb if we're debugging */
-
-extern volatile int __pthread_threads_debug;
-
-/* Globally enabled events.  */
-extern volatile td_thr_events_t __pthread_threads_events;
-
-/* Pointer to descriptor of thread with last event.  */
-extern volatile pthread_descr __pthread_last_event;
-
-/* Return the handle corresponding to a thread id */
-
-static __inline__ pthread_handle thread_handle(pthread_t id)
-{
-  return &__pthread_handles[id % PTHREAD_THREADS_MAX];
-}
-
-/* Validate a thread handle. Must have acquired h->h_spinlock before. */
-
-static __inline__ int invalid_handle(pthread_handle h, pthread_t id)
-{
-  return h->h_descr == NULL || h->h_descr->p_tid != id;
-}
-
-/* Fill in defaults left unspecified by pt-machine.h.  */
-
-/* The page size we can get from the system.  This should likely not be
-   changed by the machine file but, you never know.  */
-#define __PAGE_SIZE  (sysconf (_SC_PAGESIZE))
-
-/* The max size of the thread stack segments.  If the default
-   THREAD_SELF implementation is used, this must be a power of two and
-   a multiple of __PAGE_SIZE.  */
-#ifndef STACK_SIZE
-#ifdef __ARCH_USE_MMU__
-#define STACK_SIZE  (2 * 1024 * 1024)
-#else
-#define STACK_SIZE  (4 * __PAGE_SIZE)
-#endif
-#endif
-
-/* The initial size of the thread stack.  Must be a multiple of __PAGE_SIZE.  */
-#ifndef INITIAL_STACK_SIZE
-#define INITIAL_STACK_SIZE  (4 * __PAGE_SIZE)
-#endif
-
-/* Size of the thread manager stack. The "- 32" avoids wasting space
-   with some malloc() implementations. */
-#ifndef THREAD_MANAGER_STACK_SIZE
-#define THREAD_MANAGER_STACK_SIZE  (2 * __PAGE_SIZE - 32)
-#endif
-
-/* The base of the "array" of thread stacks.  The array will grow down from
-   here.  Defaults to the calculated bottom of the initial application
-   stack.  */
-#ifndef THREAD_STACK_START_ADDRESS
-#define THREAD_STACK_START_ADDRESS  __pthread_initial_thread_bos
-#endif
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#ifndef CURRENT_STACK_FRAME
-#define CURRENT_STACK_FRAME  ({ char __csf; &__csf; })
-#endif
-
-/* If MEMORY_BARRIER isn't defined in pt-machine.h, assume the
-   architecture doesn't need a memory barrier instruction (e.g. Intel
-   x86).  Still we need the compiler to respect the barrier and emit
-   all outstanding operations which modify memory.  Some architectures
-   distinguish between full, read and write barriers.  */
-#ifndef MEMORY_BARRIER
-#define MEMORY_BARRIER() __asm__ ("" : : : "memory")
-#endif
-#ifndef READ_MEMORY_BARRIER
-#define READ_MEMORY_BARRIER() MEMORY_BARRIER()
-#endif
-#ifndef WRITE_MEMORY_BARRIER
-#define WRITE_MEMORY_BARRIER() MEMORY_BARRIER()
-#endif
-
-/* Recover thread descriptor for the current thread */
-
-extern pthread_descr __pthread_find_self (void) __attribute__ ((const)) attribute_hidden;
-
-static __inline__ pthread_descr thread_self (void) __attribute__ ((const));
-static __inline__ pthread_descr thread_self (void)
-{
-#ifdef THREAD_SELF
-  return THREAD_SELF;
-#else
-  char *sp = CURRENT_STACK_FRAME;
-#ifdef __ARCH_USE_MMU__
-  if (sp >= __pthread_initial_thread_bos)
-    return &__pthread_initial_thread;
-  else if (sp >= __pthread_manager_thread_bos
-	   && sp < __pthread_manager_thread_tos)
-    return &__pthread_manager_thread;
-  else if (__pthread_nonstandard_stacks)
-    return __pthread_find_self();
-  else
-    return (pthread_descr)(((unsigned long)sp | (STACK_SIZE-1))+1) - 1;
-#else
-  /* For non-MMU we need to be more careful about the initial thread stack.
-   * We refine the initial thread stack bounds dynamically as we allocate
-   * the other stack frame such that it doesn't overlap with them. Then
-   * we can be sure to pick the right thread according to the current SP */
-
-  /* Since we allow other stack frames to be above or below, we need to
-   * treat this case special. When pthread_initialize() wasn't called yet,
-   * only the initial thread is there. */
-  if (__pthread_initial_thread_bos == NULL) {
-      return &__pthread_initial_thread;
-  }
-  else if (sp >= __pthread_initial_thread_bos
-	   && sp < __pthread_initial_thread_tos) {
-      return &__pthread_initial_thread;
-  }
-  else if (sp >= __pthread_manager_thread_bos
-	   && sp < __pthread_manager_thread_tos) {
-      return &__pthread_manager_thread;
-  }
-  else {
-      return __pthread_find_self();
-  }
-#endif /* __ARCH_USE_MMU__ */
-#endif
-}
-
-/* Max number of times we must spin on a spinlock calling sched_yield().
-   After MAX_SPIN_COUNT iterations, we put the calling thread to sleep. */
-
-#ifndef MAX_SPIN_COUNT
-#define MAX_SPIN_COUNT 50
-#endif
-
-/* Duration of sleep (in nanoseconds) when we can't acquire a spinlock
-   after MAX_SPIN_COUNT iterations of sched_yield().
-   With the 2.0 and 2.1 kernels, this MUST BE > 2ms.
-   (Otherwise the kernel does busy-waiting for realtime threads,
-    giving other threads no chance to run.) */
-
-#ifndef SPIN_SLEEP_DURATION
-#define SPIN_SLEEP_DURATION 2000001
-#endif
-
-/* Defined and used in libc.so.  */
-extern int __libc_multiple_threads attribute_hidden;
-extern int __librt_multiple_threads;
-
-/* Internal global functions */
-
-void __pthread_do_exit (void *retval, char *currentframe)
-     __attribute__ ((__noreturn__)) attribute_hidden;
-void __pthread_destroy_specifics(void) attribute_hidden;
-void __pthread_perform_cleanup(char *currentframe) attribute_hidden;
-int __pthread_initialize_manager(void) attribute_hidden;
-void __pthread_message(char * fmt, ...)
-     __attribute__ ((__format__ (printf, 1, 2))) attribute_hidden;
-int __pthread_manager(void *reqfd) attribute_hidden;
-int __pthread_manager_event(void *reqfd) attribute_hidden;
-void __pthread_manager_sighandler(int sig) attribute_hidden;
-void __pthread_reset_main_thread(void) attribute_hidden;
-void __fresetlockfiles(void) attribute_hidden;
-void __pthread_manager_adjust_prio(int thread_prio) attribute_hidden;
-void __pthread_initialize_minimal (void);
-
-extern void __pthread_exit (void *retval)
-#if defined NOT_IN_libc && defined IS_IN_libpthread
-	attribute_noreturn
-#endif
-	;
-
-extern int __pthread_attr_setguardsize(pthread_attr_t *__attr,
-				       size_t __guardsize) attribute_hidden;
-extern int __pthread_attr_getguardsize(const pthread_attr_t *__attr,
-				       size_t *__guardsize) attribute_hidden;
-extern int __pthread_attr_setstackaddr(pthread_attr_t *__attr,
-				       void *__stackaddr) attribute_hidden;
-extern int __pthread_attr_getstackaddr(const pthread_attr_t *__attr,
-				       void **__stackaddr) attribute_hidden;
-extern int __pthread_attr_setstacksize(pthread_attr_t *__attr,
-				       size_t __stacksize) attribute_hidden;
-extern int __pthread_attr_getstacksize(const pthread_attr_t *__attr,
-				       size_t *__stacksize) attribute_hidden;
-extern int __pthread_getconcurrency(void) attribute_hidden;
-extern int __pthread_setconcurrency(int __level) attribute_hidden;
-extern void __pthread_kill_other_threads_np(void) attribute_hidden;
-
-extern void __pthread_restart_old(pthread_descr th) attribute_hidden;
-extern void __pthread_suspend_old(pthread_descr self) attribute_hidden;
-extern int __pthread_timedsuspend_old(pthread_descr self, const struct timespec *abstime) attribute_hidden;
-
-extern void __pthread_restart_new(pthread_descr th) attribute_hidden;
-extern void __pthread_suspend_new(pthread_descr self) attribute_hidden;
-extern int __pthread_timedsuspend_new(pthread_descr self, const struct timespec *abstime) attribute_hidden;
-
-extern void __pthread_wait_for_restart_signal(pthread_descr self) attribute_hidden;
-
-/* Global pointers to old or new suspend functions */
-
-extern void (*__pthread_restart)(pthread_descr) attribute_hidden;
-extern void (*__pthread_suspend)(pthread_descr) attribute_hidden;
-
-#if defined NOT_IN_libc && defined IS_IN_libpthread
-extern __typeof(pthread_mutex_init) __pthread_mutex_init attribute_hidden;
-extern __typeof(pthread_mutex_destroy) __pthread_mutex_destroy attribute_hidden;
-extern __typeof(pthread_mutex_lock) __pthread_mutex_lock attribute_hidden;
-extern __typeof(pthread_mutex_trylock) __pthread_mutex_trylock attribute_hidden;
-extern __typeof(pthread_mutex_unlock) __pthread_mutex_unlock attribute_hidden;
-#endif
-
-/* Prototypes for some of the new semaphore functions.  */
-/*extern int __new_sem_post (sem_t * sem);*/
-
-/* TSD.  */
-extern int __pthread_internal_tsd_set (int key, const void * pointer);
-extern void * __pthread_internal_tsd_get (int key);
-extern void ** __attribute__ ((__const__))
-  __pthread_internal_tsd_address (int key);
-
-/* The functions called the signal events.  */
-extern void __linuxthreads_create_event (void) attribute_hidden;
-extern void __linuxthreads_death_event (void) attribute_hidden;
-extern void __linuxthreads_reap_event (void) attribute_hidden;
-
-#include <pthread-functions.h>
-
-#endif /* internals.h */
diff --git a/libpthread/linuxthreads.old/join.c b/libpthread/linuxthreads.old/join.c
deleted file mode 100644
index 4a7c0d8ac..000000000
--- a/libpthread/linuxthreads.old/join.c
+++ /dev/null
@@ -1,231 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Thread termination and joining */
-
-#include <features.h>
-#include <errno.h>
-#include <sched.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include "pthread.h"
-#include "internals.h"
-#include "spinlock.h"
-#include "restart.h"
-#include "debug.h" /* PDEBUG, added by StS */
-
-libpthread_hidden_proto(pthread_exit)
-void pthread_exit(void * retval)
-{
-  __pthread_do_exit (retval, CURRENT_STACK_FRAME);
-}
-libpthread_hidden_def (pthread_exit)
-
-void __pthread_do_exit(void *retval, char *currentframe)
-{
-  pthread_descr self = thread_self();
-  pthread_descr joining;
-  struct pthread_request request;
-  PDEBUG("self=%p, pid=%d\n", self, self->p_pid);
-
-  /* obey POSIX behavior and prevent cancellation functions from
-   * being called more than once.
-   * http://sourceware.org/ml/libc-ports/2006-10/msg00043.html
-   */
-  THREAD_SETMEM(self, p_cancelstate, PTHREAD_CANCEL_DISABLE);
-  THREAD_SETMEM(self, p_canceltype, PTHREAD_CANCEL_DEFERRED);
-
-  /* Call cleanup functions and destroy the thread-specific data */
-  __pthread_perform_cleanup(currentframe);
-  __pthread_destroy_specifics();
-  /* Store return value */
-  __pthread_lock(THREAD_GETMEM(self, p_lock), self);
-  THREAD_SETMEM(self, p_retval, retval);
-  /* See whether we have to signal the death.  */
-  if (THREAD_GETMEM(self, p_report_events))
-    {
-      /* See whether TD_DEATH is in any of the mask.  */
-      int idx = __td_eventword (TD_DEATH);
-      uint32_t mask = __td_eventmask (TD_DEATH);
-
-      if ((mask & (__pthread_threads_events.event_bits[idx]
-		   | THREAD_GETMEM_NC(self,
-				   p_eventbuf.eventmask).event_bits[idx]))
-	  != 0)
-	{
-	  /* Yep, we have to signal the death.  */
-	  THREAD_SETMEM(self, p_eventbuf.eventnum, TD_DEATH);
-	  THREAD_SETMEM(self, p_eventbuf.eventdata, self);
-	  __pthread_last_event = self;
-
-	  /* Now call the function to signal the event.  */
-	  __linuxthreads_death_event();
-	}
-    }
-  /* Say that we've terminated */
-  THREAD_SETMEM(self, p_terminated, 1);
-  /* See if someone is joining on us */
-  joining = THREAD_GETMEM(self, p_joining);
-  PDEBUG("joining = %p, pid=%d\n", joining, joining ? joining->p_pid : 0);
-  __pthread_unlock(THREAD_GETMEM(self, p_lock));
-  /* Restart joining thread if any */
-  if (joining != NULL) restart(joining);
-  /* If this is the initial thread, block until all threads have terminated.
-     If another thread calls exit, we'll be terminated from our signal
-     handler. */
-  if (self == __pthread_main_thread && __pthread_manager_request >= 0) {
-    request.req_thread = self;
-    request.req_kind = REQ_MAIN_THREAD_EXIT;
-    TEMP_FAILURE_RETRY(write(__pthread_manager_request,
-		(char *)&request, sizeof(request)));
-    suspend(self);
-    /* Main thread flushes stdio streams and runs atexit functions.
-     * It also calls a handler within LinuxThreads which sends a process exit
-     * request to the thread manager. */
-    exit(0);
-  }
-  /* Exit the process (but don't flush stdio streams, and don't run
-     atexit functions). */
-  _exit(0);
-}
-
-/* Function called by pthread_cancel to remove the thread from
-   waiting on a condition variable queue. */
-
-static int join_extricate_func(void *obj, pthread_descr th attribute_unused)
-{
-  volatile pthread_descr self = thread_self();
-  pthread_handle handle = obj;
-  pthread_descr jo;
-  int did_remove = 0;
-
-  __pthread_lock(&handle->h_lock, self);
-  jo = handle->h_descr;
-  did_remove = jo->p_joining != NULL;
-  jo->p_joining = NULL;
-  __pthread_unlock(&handle->h_lock);
-
-  return did_remove;
-}
-
-int pthread_join(pthread_t thread_id, void ** thread_return)
-{
-  volatile pthread_descr self = thread_self();
-  struct pthread_request request;
-  pthread_handle handle = thread_handle(thread_id);
-  pthread_descr th;
-  pthread_extricate_if extr;
-  int already_canceled = 0;
-  PDEBUG("\n");
-
-  /* Set up extrication interface */
-  extr.pu_object = handle;
-  extr.pu_extricate_func = join_extricate_func;
-
-  __pthread_lock(&handle->h_lock, self);
-  if (invalid_handle(handle, thread_id)) {
-    __pthread_unlock(&handle->h_lock);
-    return ESRCH;
-  }
-  th = handle->h_descr;
-  if (th == self) {
-    __pthread_unlock(&handle->h_lock);
-    return EDEADLK;
-  }
-  /* If detached or already joined, error */
-  if (th->p_detached || th->p_joining != NULL) {
-    __pthread_unlock(&handle->h_lock);
-    return EINVAL;
-  }
-  /* If not terminated yet, suspend ourselves. */
-  if (! th->p_terminated) {
-    /* Register extrication interface */
-    __pthread_set_own_extricate_if(self, &extr);
-    if (!(THREAD_GETMEM(self, p_canceled)
-	&& THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE))
-      th->p_joining = self;
-    else
-      already_canceled = 1;
-    __pthread_unlock(&handle->h_lock);
-
-    if (already_canceled) {
-      __pthread_set_own_extricate_if(self, 0);
-      __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-    }
-
-  PDEBUG("before suspend\n");
-    suspend(self);
-  PDEBUG("after suspend\n");
-    /* Deregister extrication interface */
-    __pthread_set_own_extricate_if(self, 0);
-
-    /* This is a cancellation point */
-    if (THREAD_GETMEM(self, p_woken_by_cancel)
-	&& THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE) {
-      THREAD_SETMEM(self, p_woken_by_cancel, 0);
-      __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-    }
-    __pthread_lock(&handle->h_lock, self);
-  }
-  /* Get return value */
-  if (thread_return != NULL) *thread_return = th->p_retval;
-  __pthread_unlock(&handle->h_lock);
-  /* Send notification to thread manager */
-  if (__pthread_manager_request >= 0) {
-    request.req_thread = self;
-    request.req_kind = REQ_FREE;
-    request.req_args.free.thread_id = thread_id;
-    TEMP_FAILURE_RETRY(write(__pthread_manager_request,
-		(char *) &request, sizeof(request)));
-  }
-  return 0;
-}
-
-int pthread_detach(pthread_t thread_id)
-{
-  int terminated;
-  struct pthread_request request;
-  pthread_handle handle = thread_handle(thread_id);
-  pthread_descr th;
-
-  __pthread_lock(&handle->h_lock, NULL);
-  if (invalid_handle(handle, thread_id)) {
-    __pthread_unlock(&handle->h_lock);
-    return ESRCH;
-  }
-  th = handle->h_descr;
-  /* If already detached, error */
-  if (th->p_detached) {
-    __pthread_unlock(&handle->h_lock);
-    return EINVAL;
-  }
-  /* If already joining, don't do anything. */
-  if (th->p_joining != NULL) {
-    __pthread_unlock(&handle->h_lock);
-    return 0;
-  }
-  /* Mark as detached */
-  th->p_detached = 1;
-  terminated = th->p_terminated;
-  __pthread_unlock(&handle->h_lock);
-  /* If already terminated, notify thread manager to reclaim resources */
-  if (terminated && __pthread_manager_request >= 0) {
-    request.req_thread = thread_self();
-    request.req_kind = REQ_FREE;
-    request.req_args.free.thread_id = thread_id;
-    TEMP_FAILURE_RETRY(write(__pthread_manager_request,
-		(char *) &request, sizeof(request)));
-  }
-  return 0;
-}
diff --git a/libpthread/linuxthreads.old/libc_pthread_init.c b/libpthread/linuxthreads.old/libc_pthread_init.c
deleted file mode 100644
index dfdcbcccc..000000000
--- a/libpthread/linuxthreads.old/libc_pthread_init.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <locale.h>
-#include <string.h>
-#include <linuxthreads.old/sysdeps/pthread/pthread-functions.h>
-
-
-int __libc_multiple_threads attribute_hidden __attribute__((nocommon));
-
-int * __libc_pthread_init (const struct pthread_functions *functions)
-{
-#ifdef SHARED
-  /* We copy the content of the variable pointed to by the FUNCTIONS
-     parameter to one in libc.so since this means access to the array
-     can be done with one memory access instead of two.  */
-  memcpy (&__libc_pthread_functions, functions,
-	  sizeof (__libc_pthread_functions));
-#endif
-
-#if !defined __UCLIBC_HAS_TLS__ && defined __UCLIBC_HAS_XLOCALE__
-  /* Initialize thread-locale current locale to point to the global one.
-     With __thread support, the variable's initializer takes care of this.  */
-  uselocale (LC_GLOBAL_LOCALE);
-#endif
-
-  return &__libc_multiple_threads;
-}
diff --git a/libpthread/linuxthreads.old/lockfile.c b/libpthread/linuxthreads.old/lockfile.c
deleted file mode 100644
index de834c476..000000000
--- a/libpthread/linuxthreads.old/lockfile.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/* lockfile - Handle locking and unlocking of stream.
-   Copyright (C) 1996, 1998, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <stdio.h>
-#include <pthread.h>
-
-extern __typeof(pthread_mutexattr_init) __pthread_mutexattr_init attribute_hidden;
-extern __typeof(pthread_mutexattr_settype) __pthread_mutexattr_settype attribute_hidden;
-extern __typeof(pthread_mutexattr_destroy) __pthread_mutexattr_destroy attribute_hidden;
-
-/* Note: glibc puts flockfile, funlockfile, and ftrylockfile in both
- * libc and libpthread.  In uClibc, they are now in libc only.  */
-
-void __fresetlockfiles (void);
-void __fresetlockfiles (void)
-{
-  FILE *fp;
-  pthread_mutexattr_t attr;
-
-  __pthread_mutexattr_init(&attr);
-  __pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE_NP);
-
-  for (fp = _stdio_openlist; fp != NULL; fp = fp->__nextopen)
-    __pthread_mutex_init(&fp->__lock, &attr);
-
-  __pthread_mutexattr_destroy(&attr);
-}
diff --git a/libpthread/linuxthreads.old/manager.c b/libpthread/linuxthreads.old/manager.c
deleted file mode 100644
index e4022f8ea..000000000
--- a/libpthread/linuxthreads.old/manager.c
+++ /dev/null
@@ -1,933 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* The "thread manager" thread: manages creation and termination of threads */
-
-#include <features.h>
-#include <errno.h>
-#include <sched.h>
-#include <stddef.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/poll.h>		/* for poll */
-#include <sys/mman.h>           /* for mmap */
-#include <sys/param.h>
-#include <sys/time.h>
-#include <sys/wait.h>           /* for waitpid macros */
-
-#include "pthread.h"
-#include "internals.h"
-#include "spinlock.h"
-#include "restart.h"
-#include "semaphore.h"
-#include "debug.h" /* PDEBUG, added by StS */
-
-#ifndef THREAD_STACK_OFFSET
-#define THREAD_STACK_OFFSET 0
-#endif
-
-/* poll() is not supported in kernel <= 2.0, therefore is __NR_poll is
- * not available, we assume an old Linux kernel is in use and we will
- * use select() instead. */
-#include <sys/syscall.h>
-#ifndef __NR_poll
-# define USE_SELECT
-#endif
-
-libpthread_hidden_proto(waitpid)
-libpthread_hidden_proto(raise)
-
-/* Array of active threads. Entry 0 is reserved for the initial thread. */
-struct pthread_handle_struct __pthread_handles[PTHREAD_THREADS_MAX] =
-{ { __LOCK_INITIALIZER, &__pthread_initial_thread, 0},
-  { __LOCK_INITIALIZER, &__pthread_manager_thread, 0}, /* All NULLs */ };
-
-/* For debugging purposes put the maximum number of threads in a variable.  */
-const int __linuxthreads_pthread_threads_max = PTHREAD_THREADS_MAX;
-
-/* Indicate whether at least one thread has a user-defined stack (if 1),
-   or if all threads have stacks supplied by LinuxThreads (if 0). */
-int __pthread_nonstandard_stacks;
-
-/* Number of active entries in __pthread_handles (used by gdb) */
-volatile int __pthread_handles_num = 2;
-
-/* Whether to use debugger additional actions for thread creation
-   (set to 1 by gdb) */
-volatile int __pthread_threads_debug;
-
-/* Globally enabled events.  */
-volatile td_thr_events_t __pthread_threads_events;
-
-/* Pointer to thread descriptor with last event.  */
-volatile pthread_descr __pthread_last_event;
-
-/* Mapping from stack segment to thread descriptor. */
-/* Stack segment numbers are also indices into the __pthread_handles array. */
-/* Stack segment number 0 is reserved for the initial thread. */
-
-static __inline__ pthread_descr thread_segment(int seg)
-{
-  return (pthread_descr)(THREAD_STACK_START_ADDRESS - (seg - 1) * STACK_SIZE)
-         - 1;
-}
-
-/* Flag set in signal handler to record child termination */
-
-static volatile int terminated_children = 0;
-
-/* Flag set when the initial thread is blocked on pthread_exit waiting
-   for all other threads to terminate */
-
-static int main_thread_exiting = 0;
-
-/* Counter used to generate unique thread identifier.
-   Thread identifier is pthread_threads_counter + segment. */
-
-static pthread_t pthread_threads_counter = 0;
-
-/* Forward declarations */
-
-static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
-                                 void * (*start_routine)(void *), void *arg,
-                                 sigset_t *mask, int father_pid,
-				 int report_events,
-				 td_thr_events_t *event_maskp);
-static void pthread_handle_free(pthread_t th_id);
-static void pthread_handle_exit(pthread_descr issuing_thread, int exitcode) attribute_noreturn;
-static void pthread_reap_children(void);
-static void pthread_kill_all_threads(int sig, int main_thread_also);
-
-/* The server thread managing requests for thread creation and termination */
-
-int attribute_noreturn __pthread_manager(void *arg)
-{
-  int reqfd = (int) (long int) arg;
-#ifdef USE_SELECT
-  struct timeval tv;
-  fd_set fd;
-#else
-  struct pollfd ufd;
-#endif
-  sigset_t manager_mask;
-  int n;
-  struct pthread_request request;
-
-  /* If we have special thread_self processing, initialize it.  */
-#ifdef INIT_THREAD_SELF
-  INIT_THREAD_SELF(&__pthread_manager_thread, 1);
-#endif
-  /* Set the error variable.  */
-  __pthread_manager_thread.p_errnop = &__pthread_manager_thread.p_errno;
-  __pthread_manager_thread.p_h_errnop = &__pthread_manager_thread.p_h_errno;
-
-#ifdef __UCLIBC_HAS_XLOCALE__
-  /* Initialize thread's locale to the global locale. */
-  __pthread_manager_thread.locale = __global_locale;
-#endif /* __UCLIBC_HAS_XLOCALE__ */
-
-  /* Block all signals except __pthread_sig_cancel and SIGTRAP */
-  __sigfillset(&manager_mask);
-  sigdelset(&manager_mask, __pthread_sig_cancel); /* for thread termination */
-  sigdelset(&manager_mask, SIGTRAP);            /* for debugging purposes */
-  if (__pthread_threads_debug && __pthread_sig_debug > 0)
-      sigdelset(&manager_mask, __pthread_sig_debug);
-  sigprocmask(SIG_SETMASK, &manager_mask, NULL);
-  /* Raise our priority to match that of main thread */
-  __pthread_manager_adjust_prio(__pthread_main_thread->p_priority);
-  /* Synchronize debugging of the thread manager */
-  n = TEMP_FAILURE_RETRY(read(reqfd, (char *)&request,
-				     sizeof(request)));
-#ifndef USE_SELECT
-  ufd.fd = reqfd;
-  ufd.events = POLLIN;
-#endif
-  /* Enter server loop */
-  while(1) {
-#ifdef USE_SELECT
-    tv.tv_sec = 2;
-    tv.tv_usec = 0;
-    FD_ZERO (&fd);
-    FD_SET (reqfd, &fd);
-    n = select (reqfd + 1, &fd, NULL, NULL, &tv);
-#else
-    PDEBUG("before poll\n");
-    n = poll(&ufd, 1, 2000);
-    PDEBUG("after poll\n");
-#endif
-    /* Check for termination of the main thread */
-    if (getppid() == 1) {
-      pthread_kill_all_threads(SIGKILL, 0);
-      _exit(0);
-    }
-    /* Check for dead children */
-    if (terminated_children) {
-      terminated_children = 0;
-      pthread_reap_children();
-    }
-    /* Read and execute request */
-#ifdef USE_SELECT
-    if (n == 1)
-#else
-    if (n == 1 && (ufd.revents & POLLIN))
-#endif
-    {
-
-      PDEBUG("before read\n");
-      n = read(reqfd, (char *)&request, sizeof(request));
-      PDEBUG("after read, n=%d\n", n);
-      switch(request.req_kind) {
-      case REQ_CREATE:
-        PDEBUG("got REQ_CREATE\n");
-        request.req_thread->p_retcode =
-          pthread_handle_create((pthread_t *) &request.req_thread->p_retval,
-                                request.req_args.create.attr,
-                                request.req_args.create.fn,
-                                request.req_args.create.arg,
-                                &request.req_args.create.mask,
-                                request.req_thread->p_pid,
-                                request.req_thread->p_report_events,
-                                &request.req_thread->p_eventbuf.eventmask);
-        PDEBUG("restarting %p\n", request.req_thread);
-        restart(request.req_thread);
-        break;
-      case REQ_FREE:
-        PDEBUG("got REQ_FREE\n");
-        pthread_handle_free(request.req_args.free.thread_id);
-        break;
-      case REQ_PROCESS_EXIT:
-        PDEBUG("got REQ_PROCESS_EXIT from %p, exit code = %d\n",
-        request.req_thread, request.req_args.exit.code);
-        pthread_handle_exit(request.req_thread,
-                            request.req_args.exit.code);
-        break;
-      case REQ_MAIN_THREAD_EXIT:
-        PDEBUG("got REQ_MAIN_THREAD_EXIT\n");
-        main_thread_exiting = 1;
-	/* Reap children in case all other threads died and the signal handler
-	   went off before we set main_thread_exiting to 1, and therefore did
-	   not do REQ_KICK. */
-	pthread_reap_children();
-
-        if (__pthread_main_thread->p_nextlive == __pthread_main_thread) {
-          restart(__pthread_main_thread);
-	  /* The main thread will now call exit() which will trigger an
-	     __on_exit handler, which in turn will send REQ_PROCESS_EXIT
-	     to the thread manager. In case you are wondering how the
-	     manager terminates from its loop here. */
-	}
-        break;
-      case REQ_POST:
-        PDEBUG("got REQ_POST\n");
-        sem_post(request.req_args.post);
-        break;
-      case REQ_DEBUG:
-        PDEBUG("got REQ_DEBUG\n");
-	/* Make gdb aware of new thread and gdb will restart the
-	   new thread when it is ready to handle the new thread. */
-	if (__pthread_threads_debug && __pthread_sig_debug > 0) {
-	  PDEBUG("about to call raise(__pthread_sig_debug)\n");
-	  raise(__pthread_sig_debug);
-	}
-      case REQ_KICK:
-	/* This is just a prod to get the manager to reap some
-	   threads right away, avoiding a potential delay at shutdown. */
-	break;
-      }
-    }
-  }
-}
-
-int attribute_noreturn __pthread_manager_event(void *arg)
-{
-  /* If we have special thread_self processing, initialize it.  */
-#ifdef INIT_THREAD_SELF
-  INIT_THREAD_SELF(&__pthread_manager_thread, 1);
-#endif
-
-  /* Get the lock the manager will free once all is correctly set up.  */
-  __pthread_lock (THREAD_GETMEM((&__pthread_manager_thread), p_lock), NULL);
-  /* Free it immediately.  */
-  __pthread_unlock (THREAD_GETMEM((&__pthread_manager_thread), p_lock));
-
-  __pthread_manager(arg);
-}
-
-/* Process creation */
-static int
-attribute_noreturn
-pthread_start_thread(void *arg)
-{
-  pthread_descr self = (pthread_descr) arg;
-  struct pthread_request request;
-  void * outcome;
-  /* Initialize special thread_self processing, if any.  */
-#ifdef INIT_THREAD_SELF
-  INIT_THREAD_SELF(self, self->p_nr);
-#endif
-  PDEBUG("\n");
-  /* Make sure our pid field is initialized, just in case we get there
-     before our father has initialized it. */
-  THREAD_SETMEM(self, p_pid, getpid());
-  /* Initial signal mask is that of the creating thread. (Otherwise,
-     we'd just inherit the mask of the thread manager.) */
-  sigprocmask(SIG_SETMASK, &self->p_start_args.mask, NULL);
-  /* Set the scheduling policy and priority for the new thread, if needed */
-  if (THREAD_GETMEM(self, p_start_args.schedpolicy) >= 0)
-    /* Explicit scheduling attributes were provided: apply them */
-    sched_setscheduler(THREAD_GETMEM(self, p_pid),
-			 THREAD_GETMEM(self, p_start_args.schedpolicy),
-                         &self->p_start_args.schedparam);
-  else if (__pthread_manager_thread.p_priority > 0)
-    /* Default scheduling required, but thread manager runs in realtime
-       scheduling: switch new thread to SCHED_OTHER policy */
-    {
-      struct sched_param default_params;
-      default_params.sched_priority = 0;
-      sched_setscheduler(THREAD_GETMEM(self, p_pid),
-                           SCHED_OTHER, &default_params);
-    }
-  /* Make gdb aware of new thread */
-  if (__pthread_threads_debug && __pthread_sig_debug > 0) {
-    request.req_thread = self;
-    request.req_kind = REQ_DEBUG;
-    TEMP_FAILURE_RETRY(write(__pthread_manager_request,
-		(char *) &request, sizeof(request)));
-    suspend(self);
-  }
-  /* Run the thread code */
-  outcome = self->p_start_args.start_routine(THREAD_GETMEM(self,
-							   p_start_args.arg));
-  /* Exit with the given return value */
-  __pthread_do_exit(outcome, CURRENT_STACK_FRAME);
-}
-
-static int
-attribute_noreturn
-pthread_start_thread_event(void *arg)
-{
-  pthread_descr self = (pthread_descr) arg;
-
-#ifdef INIT_THREAD_SELF
-  INIT_THREAD_SELF(self, self->p_nr);
-#endif
-  /* Make sure our pid field is initialized, just in case we get there
-     before our father has initialized it. */
-  THREAD_SETMEM(self, p_pid, getpid());
-  /* Get the lock the manager will free once all is correctly set up.  */
-  __pthread_lock (THREAD_GETMEM(self, p_lock), NULL);
-  /* Free it immediately.  */
-  __pthread_unlock (THREAD_GETMEM(self, p_lock));
-
-  /* Continue with the real function.  */
-  pthread_start_thread (arg);
-}
-
-static int pthread_allocate_stack(const pthread_attr_t *attr,
-                                  pthread_descr default_new_thread,
-                                  int pagesize,
-                                  pthread_descr * out_new_thread,
-                                  char ** out_new_thread_bottom,
-                                  char ** out_guardaddr,
-                                  size_t * out_guardsize)
-{
-  pthread_descr new_thread;
-  char * new_thread_bottom;
-  char * guardaddr;
-  size_t stacksize, guardsize;
-
-  if (attr != NULL && attr->__stackaddr_set)
-    {
-      /* The user provided a stack. */
-      new_thread = (pthread_descr) ((long)(attr->__stackaddr) & -sizeof(void *)) - 1;
-      new_thread_bottom = (char *) attr->__stackaddr - attr->__stacksize;
-      guardaddr = NULL;
-      guardsize = 0;
-      __pthread_nonstandard_stacks = 1;
-#ifndef __ARCH_USE_MMU__
-      /* check the initial thread stack boundaries so they don't overlap */
-      NOMMU_INITIAL_THREAD_BOUNDS((char *) new_thread, (char *) new_thread_bottom);
-
-      PDEBUG("initial stack: bos=%p, tos=%p\n", __pthread_initial_thread_bos,
-            __pthread_initial_thread_tos);
-#endif
-    }
-  else
-    {
-#ifdef __ARCH_USE_MMU__
-      stacksize = STACK_SIZE - pagesize;
-      if (attr != NULL)
-        stacksize = MIN(stacksize, roundup(attr->__stacksize, pagesize));
-      /* Allocate space for stack and thread descriptor at default address */
-      new_thread = default_new_thread;
-      new_thread_bottom = (char *) (new_thread + 1) - stacksize;
-      if (mmap((caddr_t)((char *)(new_thread + 1) - INITIAL_STACK_SIZE),
-               INITIAL_STACK_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC,
-               MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED | MAP_GROWSDOWN,
-               -1, 0) == MAP_FAILED)
-        /* Bad luck, this segment is already mapped. */
-        return -1;
-      /* We manage to get a stack.  Now see whether we need a guard
-         and allocate it if necessary.  Notice that the default
-         attributes (stack_size = STACK_SIZE - pagesize) do not need
-	 a guard page, since the RLIMIT_STACK soft limit prevents stacks
-	 from running into one another. */
-      if (stacksize == (size_t) (STACK_SIZE - pagesize))
-        {
-          /* We don't need a guard page. */
-          guardaddr = NULL;
-          guardsize = 0;
-        }
-      else
-        {
-          /* Put a bad page at the bottom of the stack */
-          guardsize = attr->__guardsize;
-          guardaddr = (void *)new_thread_bottom - guardsize;
-          if (mmap((caddr_t) guardaddr, guardsize, 0, MAP_FIXED, -1, 0)
-              == MAP_FAILED)
-            {
-              /* We don't make this an error.  */
-              guardaddr = NULL;
-              guardsize = 0;
-            }
-        }
-#else
-      /* We cannot mmap to this huge chunk of stack space when we don't have
-       * an MMU. Pretend we are using a user provided stack even if there was
-       * none provided by the user. Thus, we get around the mmap and reservation
-       * of a huge stack segment. -StS */
-
-      stacksize = INITIAL_STACK_SIZE;
-      /* The user may want to use a non-default stacksize */
-      if (attr != NULL)
-	{
-	  stacksize = attr->__stacksize;
-	}
-
-      /* malloc a stack - memory from the bottom up */
-      if ((new_thread_bottom = malloc(stacksize)) == NULL)
-	{
-	  /* bad luck, we cannot malloc any more */
-	  return -1 ;
-	}
-      PDEBUG("malloced chunk: base=%p, size=0x%04x\n", new_thread_bottom, stacksize);
-
-      /* Set up the pointers. new_thread marks the TOP of the stack frame and
-       * the address of the pthread_descr struct at the same time. Therefore we
-       * must account for its size and fit it in the malloc()'ed block. The
-       * value of `new_thread' is then passed to clone() as the stack argument.
-       *
-       *               ^ +------------------------+
-       *               | |  pthread_descr struct  |
-       *               | +------------------------+  <- new_thread
-       * malloc block  | |                        |
-       *               | |  thread stack          |
-       *               | |                        |
-       *               v +------------------------+  <- new_thread_bottom
-       *
-       * Note: The calculated value of new_thread must be word aligned otherwise
-       * the kernel chokes on a non-aligned stack frame. Choose the lower
-       * available word boundary.
-       */
-      new_thread = ((pthread_descr) ((int)(new_thread_bottom + stacksize) & -sizeof(void*))) - 1;
-      guardaddr = NULL;
-      guardsize = 0;
-
-      PDEBUG("thread stack: bos=%p, tos=%p\n", new_thread_bottom, new_thread);
-
-      /* check the initial thread stack boundaries so they don't overlap */
-      NOMMU_INITIAL_THREAD_BOUNDS((char *) new_thread, (char *) new_thread_bottom);
-
-      PDEBUG("initial stack: bos=%p, tos=%p\n", __pthread_initial_thread_bos,
-	     __pthread_initial_thread_tos);
-
-      /* on non-MMU systems we always have non-standard stack frames */
-      __pthread_nonstandard_stacks = 1;
-
-#endif /* __ARCH_USE_MMU__ */
-    }
-
-  /* Clear the thread data structure.  */
-  memset (new_thread, '\0', sizeof (*new_thread));
-  *out_new_thread = new_thread;
-  *out_new_thread_bottom = new_thread_bottom;
-  *out_guardaddr = guardaddr;
-  *out_guardsize = guardsize;
-  return 0;
-}
-
-static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
-				 void * (*start_routine)(void *), void *arg,
-				 sigset_t * mask, int father_pid,
-				 int report_events,
-				 td_thr_events_t *event_maskp)
-{
-  size_t sseg;
-  int pid;
-  pthread_descr new_thread;
-  char * new_thread_bottom;
-  char * new_thread_top;
-  pthread_t new_thread_id;
-  char *guardaddr = NULL;
-  size_t guardsize = 0;
-  int pagesize = getpagesize();
-  int saved_errno = 0;
-
-  /* First check whether we have to change the policy and if yes, whether
-     we can  do this.  Normally this should be done by examining the
-     return value of the sched_setscheduler call in pthread_start_thread
-     but this is hard to implement.  FIXME  */
-  if (attr != NULL && attr->__schedpolicy != SCHED_OTHER && geteuid () != 0)
-    return EPERM;
-  /* Find a free segment for the thread, and allocate a stack if needed */
-  for (sseg = 2; ; sseg++)
-    {
-      if (sseg >= PTHREAD_THREADS_MAX)
-	return EAGAIN;
-      if (__pthread_handles[sseg].h_descr != NULL)
-	continue;
-      if (pthread_allocate_stack(attr, thread_segment(sseg), pagesize,
-                                 &new_thread, &new_thread_bottom,
-                                 &guardaddr, &guardsize) == 0)
-        break;
-#ifndef __ARCH_USE_MMU__
-      else
-        /* When there is MMU, mmap () is used to allocate the stack. If one
-         * segment is already mapped, we should continue to see if we can
-         * use the next one. However, when there is no MMU, malloc () is used.
-         * It's waste of CPU cycles to continue to try if it fails.  */
-        return EAGAIN;
-#endif
-    }
-  __pthread_handles_num++;
-  /* Allocate new thread identifier */
-  pthread_threads_counter += PTHREAD_THREADS_MAX;
-  new_thread_id = sseg + pthread_threads_counter;
-  /* Initialize the thread descriptor.  Elements which have to be
-     initialized to zero already have this value.  */
-  new_thread->p_tid = new_thread_id;
-  new_thread->p_lock = &(__pthread_handles[sseg].h_lock);
-  new_thread->p_cancelstate = PTHREAD_CANCEL_ENABLE;
-  new_thread->p_canceltype = PTHREAD_CANCEL_DEFERRED;
-  new_thread->p_errnop = &new_thread->p_errno;
-  new_thread->p_h_errnop = &new_thread->p_h_errno;
-#ifdef __UCLIBC_HAS_XLOCALE__
-  /* Initialize thread's locale to the global locale. */
-  new_thread->locale = __global_locale;
-#endif /* __UCLIBC_HAS_XLOCALE__ */
-  new_thread->p_guardaddr = guardaddr;
-  new_thread->p_guardsize = guardsize;
-  new_thread->p_self = new_thread;
-  new_thread->p_nr = sseg;
-  /* Initialize the thread handle */
-  __pthread_init_lock(&__pthread_handles[sseg].h_lock);
-  __pthread_handles[sseg].h_descr = new_thread;
-  __pthread_handles[sseg].h_bottom = new_thread_bottom;
-  /* Determine scheduling parameters for the thread */
-  new_thread->p_start_args.schedpolicy = -1;
-  if (attr != NULL) {
-    new_thread->p_detached = attr->__detachstate;
-    new_thread->p_userstack = attr->__stackaddr_set;
-
-    switch(attr->__inheritsched) {
-    case PTHREAD_EXPLICIT_SCHED:
-      new_thread->p_start_args.schedpolicy = attr->__schedpolicy;
-      memcpy (&new_thread->p_start_args.schedparam, &attr->__schedparam,
-	      sizeof (struct sched_param));
-      break;
-    case PTHREAD_INHERIT_SCHED:
-      new_thread->p_start_args.schedpolicy = sched_getscheduler(father_pid);
-      sched_getparam(father_pid, &new_thread->p_start_args.schedparam);
-      break;
-    }
-    new_thread->p_priority =
-      new_thread->p_start_args.schedparam.sched_priority;
-  }
-  /* Finish setting up arguments to pthread_start_thread */
-  new_thread->p_start_args.start_routine = start_routine;
-  new_thread->p_start_args.arg = arg;
-  new_thread->p_start_args.mask = *mask;
-  /* Raise priority of thread manager if needed */
-  __pthread_manager_adjust_prio(new_thread->p_priority);
-  /* Do the cloning.  We have to use two different functions depending
-     on whether we are debugging or not.  */
-  pid = 0;     /* Note that the thread never can have PID zero.  */
-  new_thread_top = ((char *)new_thread - THREAD_STACK_OFFSET);
-
-  /* ******************************************************** */
-  /*  This code was moved from below to cope with running threads
-   *  on uClinux systems.  See comment below...
-   * Insert new thread in doubly linked list of active threads */
-  new_thread->p_prevlive = __pthread_main_thread;
-  new_thread->p_nextlive = __pthread_main_thread->p_nextlive;
-  __pthread_main_thread->p_nextlive->p_prevlive = new_thread;
-  __pthread_main_thread->p_nextlive = new_thread;
-  /* ********************************************************* */
-
-  if (report_events)
-    {
-      /* See whether the TD_CREATE event bit is set in any of the
-         masks.  */
-      int idx = __td_eventword (TD_CREATE);
-      uint32_t m = __td_eventmask (TD_CREATE);
-
-      if ((m & (__pthread_threads_events.event_bits[idx]
-		   | event_maskp->event_bits[idx])) != 0)
-	{
-	  /* Lock the mutex the child will use now so that it will stop.  */
-	  __pthread_lock(new_thread->p_lock, NULL);
-
-	  /* We have to report this event.  */
-#ifdef __ia64__
-	  pid = __clone2(pthread_start_thread_event, new_thread_top,
-			new_thread_top - new_thread_bottom,
-			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
-			__pthread_sig_cancel, new_thread);
-#else
-	  pid = clone(pthread_start_thread_event, new_thread_top,
-			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
-			__pthread_sig_cancel, new_thread);
-#endif
-
-	  saved_errno = errno;
-	  if (pid != -1)
-	    {
-	      /* Now fill in the information about the new thread in
-	         the newly created thread's data structure.  We cannot let
-	         the new thread do this since we don't know whether it was
-	         already scheduled when we send the event.  */
-	      new_thread->p_eventbuf.eventdata = new_thread;
-	      new_thread->p_eventbuf.eventnum = TD_CREATE;
-	      __pthread_last_event = new_thread;
-
-	      /* We have to set the PID here since the callback function
-		 in the debug library will need it and we cannot guarantee
-		 the child got scheduled before the debugger.  */
-	      new_thread->p_pid = pid;
-
-	      /* Now call the function which signals the event.  */
-	      __linuxthreads_create_event ();
-
-	      /* Now restart the thread.  */
-	      __pthread_unlock(new_thread->p_lock);
-	    }
-	}
-    }
-  if (pid == 0)
-    {
-      PDEBUG("cloning new_thread = %p\n", new_thread);
-#ifdef __ia64__
-      pid = __clone2(pthread_start_thread, new_thread_top,
-		    new_thread_top - new_thread_bottom,
-		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
-		    __pthread_sig_cancel, new_thread);
-#else
-      pid = clone(pthread_start_thread, new_thread_top,
-		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
-		    __pthread_sig_cancel, new_thread);
-#endif
-      saved_errno = errno;
-    }
-  /* Check if cloning succeeded */
-  if (pid == -1) {
-    /********************************************************
-     * Code inserted to remove the thread from our list of active
-     * threads in case of failure (needed to cope with uClinux),
-     * See comment below. */
-    new_thread->p_nextlive->p_prevlive = new_thread->p_prevlive;
-    new_thread->p_prevlive->p_nextlive = new_thread->p_nextlive;
-    /********************************************************/
-
-    /* Free the stack if we allocated it */
-    if (attr == NULL || !attr->__stackaddr_set)
-      {
-#ifdef __ARCH_USE_MMU__
-	if (new_thread->p_guardsize != 0)
-	  munmap(new_thread->p_guardaddr, new_thread->p_guardsize);
-	munmap((caddr_t)((char *)(new_thread+1) - INITIAL_STACK_SIZE),
-	       INITIAL_STACK_SIZE);
-#else
-	free(new_thread_bottom);
-#endif /* __ARCH_USE_MMU__ */
-      }
-    __pthread_handles[sseg].h_descr = NULL;
-    __pthread_handles[sseg].h_bottom = NULL;
-    __pthread_handles_num--;
-    return saved_errno;
-  }
-  PDEBUG("new thread pid = %d\n", pid);
-
-#if 0
-  /* ***********************************************************
-   This code has been moved before the call to clone().  In uClinux,
-   the use of wait on a semaphore is dependant upon that the child so
-   the child must be in the active threads list. This list is used in
-   pthread_find_self() to get the pthread_descr of self. So, if the
-   child calls sem_wait before this code is executed , it will hang
-   forever and initial_thread will instead be posted by a sem_post
-   call. */
-
-  /* Insert new thread in doubly linked list of active threads */
-  new_thread->p_prevlive = __pthread_main_thread;
-  new_thread->p_nextlive = __pthread_main_thread->p_nextlive;
-  __pthread_main_thread->p_nextlive->p_prevlive = new_thread;
-  __pthread_main_thread->p_nextlive = new_thread;
-  /************************************************************/
-#endif
-
-  /* Set pid field of the new thread, in case we get there before the
-     child starts. */
-  new_thread->p_pid = pid;
-  /* We're all set */
-  *thread = new_thread_id;
-  return 0;
-}
-
-
-/* Try to free the resources of a thread when requested by pthread_join
-   or pthread_detach on a terminated thread. */
-
-static void pthread_free(pthread_descr th)
-{
-  pthread_handle handle;
-  pthread_readlock_info *iter, *next;
-#ifndef __ARCH_USE_MMU__
-  char *h_bottom_save;
-#endif
-
-  /* Make the handle invalid */
-  handle =  thread_handle(th->p_tid);
-  __pthread_lock(&handle->h_lock, NULL);
-#ifndef __ARCH_USE_MMU__
-  h_bottom_save = handle->h_bottom;
-#endif
-  handle->h_descr = NULL;
-  handle->h_bottom = (char *)(-1L);
-  __pthread_unlock(&handle->h_lock);
-#ifdef FREE_THREAD_SELF
-  FREE_THREAD_SELF(th, th->p_nr);
-#endif
-  /* One fewer threads in __pthread_handles */
-  __pthread_handles_num--;
-
-  /* Destroy read lock list, and list of free read lock structures.
-     If the former is not empty, it means the thread exited while
-     holding read locks! */
-
-  for (iter = th->p_readlock_list; iter != NULL; iter = next)
-    {
-      next = iter->pr_next;
-      free(iter);
-    }
-
-  for (iter = th->p_readlock_free; iter != NULL; iter = next)
-    {
-      next = iter->pr_next;
-      free(iter);
-    }
-
-  /* If initial thread, nothing to free */
-  if (th == &__pthread_initial_thread) return;
-  if (!th->p_userstack)
-    {
-#ifdef __ARCH_USE_MMU__
-      /* Free the stack and thread descriptor area */
-      if (th->p_guardsize != 0)
-	munmap(th->p_guardaddr, th->p_guardsize);
-      munmap((caddr_t) ((char *)(th+1) - STACK_SIZE), STACK_SIZE);
-#else
-      /* For non-MMU systems we always malloc the stack, so free it here. -StS */
-      free(h_bottom_save);
-#endif /* __ARCH_USE_MMU__ */
-    }
-}
-
-/* Handle threads that have exited */
-
-static void pthread_exited(pid_t pid)
-{
-  pthread_descr th;
-  int detached;
-  /* Find thread with that pid */
-  for (th = __pthread_main_thread->p_nextlive;
-       th != __pthread_main_thread;
-       th = th->p_nextlive) {
-    if (th->p_pid == pid) {
-      /* Remove thread from list of active threads */
-      th->p_nextlive->p_prevlive = th->p_prevlive;
-      th->p_prevlive->p_nextlive = th->p_nextlive;
-      /* Mark thread as exited, and if detached, free its resources */
-      __pthread_lock(th->p_lock, NULL);
-      th->p_exited = 1;
-      /* If we have to signal this event do it now.  */
-      if (th->p_report_events)
-	{
-	  /* See whether TD_REAP is in any of the mask.  */
-	  int idx = __td_eventword (TD_REAP);
-	  uint32_t mask = __td_eventmask (TD_REAP);
-
-	  if ((mask & (__pthread_threads_events.event_bits[idx]
-		       | th->p_eventbuf.eventmask.event_bits[idx])) != 0)
-	    {
-	      /* Yep, we have to signal the reapage.  */
-	      th->p_eventbuf.eventnum = TD_REAP;
-	      th->p_eventbuf.eventdata = th;
-	      __pthread_last_event = th;
-
-	      /* Now call the function to signal the event.  */
-	      __linuxthreads_reap_event();
-	    }
-	}
-      detached = th->p_detached;
-      __pthread_unlock(th->p_lock);
-      if (detached)
-	pthread_free(th);
-      break;
-    }
-  }
-  /* If all threads have exited and the main thread is pending on a
-     pthread_exit, wake up the main thread and terminate ourselves. */
-  if (main_thread_exiting &&
-      __pthread_main_thread->p_nextlive == __pthread_main_thread) {
-    restart(__pthread_main_thread);
-    /* Same logic as REQ_MAIN_THREAD_EXIT. */
-  }
-}
-
-static void pthread_reap_children(void)
-{
-  pid_t pid;
-  int status;
-  PDEBUG("\n");
-
-  while ((pid = waitpid(-1, &status, WNOHANG | __WCLONE)) > 0) {
-    pthread_exited(pid);
-    if (WIFSIGNALED(status)) {
-      /* If a thread died due to a signal, send the same signal to
-         all other threads, including the main thread. */
-      pthread_kill_all_threads(WTERMSIG(status), 1);
-      _exit(0);
-    }
-  }
-}
-
-/* Try to free the resources of a thread when requested by pthread_join
-   or pthread_detach on a terminated thread. */
-
-static void pthread_handle_free(pthread_t th_id)
-{
-  pthread_handle handle = thread_handle(th_id);
-  pthread_descr th;
-
-  __pthread_lock(&handle->h_lock, NULL);
-  if (invalid_handle(handle, th_id)) {
-    /* pthread_reap_children has deallocated the thread already,
-       nothing needs to be done */
-    __pthread_unlock(&handle->h_lock);
-    return;
-  }
-  th = handle->h_descr;
-  if (th->p_exited) {
-    __pthread_unlock(&handle->h_lock);
-    pthread_free(th);
-  } else {
-    /* The Unix process of the thread is still running.
-       Mark the thread as detached so that the thread manager will
-       deallocate its resources when the Unix process exits. */
-    th->p_detached = 1;
-    __pthread_unlock(&handle->h_lock);
-  }
-}
-
-/* Send a signal to all running threads */
-
-static void pthread_kill_all_threads(int sig, int main_thread_also)
-{
-  pthread_descr th;
-  for (th = __pthread_main_thread->p_nextlive;
-       th != __pthread_main_thread;
-       th = th->p_nextlive) {
-    kill(th->p_pid, sig);
-  }
-  if (main_thread_also) {
-    kill(__pthread_main_thread->p_pid, sig);
-  }
-}
-
-/* Process-wide exit() */
-
-static void pthread_handle_exit(pthread_descr issuing_thread, int exitcode)
-{
-  pthread_descr th;
-  __pthread_exit_requested = 1;
-  __pthread_exit_code = exitcode;
-  /* Send the CANCEL signal to all running threads, including the main
-     thread, but excluding the thread from which the exit request originated
-     (that thread must complete the exit, e.g. calling atexit functions
-     and flushing stdio buffers). */
-  for (th = issuing_thread->p_nextlive;
-       th != issuing_thread;
-       th = th->p_nextlive) {
-    kill(th->p_pid, __pthread_sig_cancel);
-  }
-  /* Now, wait for all these threads, so that they don't become zombies
-     and their times are properly added to the thread manager's times. */
-  for (th = issuing_thread->p_nextlive;
-       th != issuing_thread;
-       th = th->p_nextlive) {
-    waitpid(th->p_pid, NULL, __WCLONE);
-  }
-  restart(issuing_thread);
-  _exit(0);
-}
-
-/* Handler for __pthread_sig_cancel in thread manager thread */
-
-void __pthread_manager_sighandler(int sig attribute_unused)
-{
-    int kick_manager = terminated_children == 0 && main_thread_exiting;
-    terminated_children = 1;
-
-    /* If the main thread is terminating, kick the thread manager loop
-       each time some threads terminate. This eliminates a two second
-       shutdown delay caused by the thread manager sleeping in the
-       call to __poll(). Instead, the thread manager is kicked into
-       action, reaps the outstanding threads and resumes the main thread
-       so that it can complete the shutdown. */
-
-    if (kick_manager) {
-	struct pthread_request request;
-	request.req_thread = 0;
-	request.req_kind = REQ_KICK;
-	TEMP_FAILURE_RETRY(write(__pthread_manager_request,
-		    (char *) &request, sizeof(request)));
-    }
-}
-
-/* Adjust priority of thread manager so that it always run at a priority
-   higher than all threads */
-
-void __pthread_manager_adjust_prio(int thread_prio)
-{
-  struct sched_param param;
-
-  if (thread_prio <= __pthread_manager_thread.p_priority) return;
-  param.sched_priority =
-    thread_prio < sched_get_priority_max(SCHED_FIFO)
-    ? thread_prio + 1 : thread_prio;
-  sched_setscheduler(__pthread_manager_thread.p_pid, SCHED_FIFO, &param);
-  __pthread_manager_thread.p_priority = thread_prio;
-}
diff --git a/libpthread/linuxthreads.old/mutex.c b/libpthread/linuxthreads.old/mutex.c
deleted file mode 100644
index 890841452..000000000
--- a/libpthread/linuxthreads.old/mutex.c
+++ /dev/null
@@ -1,362 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Mutexes */
-
-#include <errno.h>
-#include <sched.h>
-#include <stddef.h>
-#include <limits.h>
-#include "pthread.h"
-#include "internals.h"
-#include "spinlock.h"
-#include "queue.h"
-#include "restart.h"
-
-int attribute_hidden __pthread_mutex_init(pthread_mutex_t * mutex,
-                       const pthread_mutexattr_t * mutex_attr)
-{
-  __pthread_init_lock(&mutex->__m_lock);
-  mutex->__m_kind =
-    mutex_attr == NULL ? PTHREAD_MUTEX_TIMED_NP : mutex_attr->__mutexkind;
-  mutex->__m_count = 0;
-  mutex->__m_owner = NULL;
-  return 0;
-}
-strong_alias (__pthread_mutex_init, pthread_mutex_init)
-
-int attribute_hidden __pthread_mutex_destroy(pthread_mutex_t * mutex)
-{
-  switch (mutex->__m_kind) {
-  case PTHREAD_MUTEX_ADAPTIVE_NP:
-  case PTHREAD_MUTEX_RECURSIVE_NP:
-    if ((mutex->__m_lock.__status & 1) != 0)
-      return EBUSY;
-    return 0;
-  case PTHREAD_MUTEX_ERRORCHECK_NP:
-  case PTHREAD_MUTEX_TIMED_NP:
-    if (mutex->__m_lock.__status != 0)
-      return EBUSY;
-    return 0;
-  default:
-    return EINVAL;
-  }
-}
-strong_alias (__pthread_mutex_destroy, pthread_mutex_destroy)
-
-int attribute_hidden __pthread_mutex_trylock(pthread_mutex_t * mutex)
-{
-  pthread_descr self;
-  int retcode;
-
-  switch(mutex->__m_kind) {
-  case PTHREAD_MUTEX_ADAPTIVE_NP:
-    retcode = __pthread_trylock(&mutex->__m_lock);
-    return retcode;
-  case PTHREAD_MUTEX_RECURSIVE_NP:
-    self = thread_self();
-    if (mutex->__m_owner == self) {
-      mutex->__m_count++;
-      return 0;
-    }
-    retcode = __pthread_trylock(&mutex->__m_lock);
-    if (retcode == 0) {
-      mutex->__m_owner = self;
-      mutex->__m_count = 0;
-    }
-    return retcode;
-  case PTHREAD_MUTEX_ERRORCHECK_NP:
-    retcode = __pthread_alt_trylock(&mutex->__m_lock);
-    if (retcode == 0) {
-      mutex->__m_owner = thread_self();
-    }
-    return retcode;
-  case PTHREAD_MUTEX_TIMED_NP:
-    retcode = __pthread_alt_trylock(&mutex->__m_lock);
-    return retcode;
-  default:
-    return EINVAL;
-  }
-}
-strong_alias (__pthread_mutex_trylock, pthread_mutex_trylock)
-
-int attribute_hidden __pthread_mutex_lock(pthread_mutex_t * mutex)
-{
-  pthread_descr self;
-
-  switch(mutex->__m_kind) {
-  case PTHREAD_MUTEX_ADAPTIVE_NP:
-    __pthread_lock(&mutex->__m_lock, NULL);
-    return 0;
-  case PTHREAD_MUTEX_RECURSIVE_NP:
-    self = thread_self();
-    if (mutex->__m_owner == self) {
-      mutex->__m_count++;
-      return 0;
-    }
-    __pthread_lock(&mutex->__m_lock, self);
-    mutex->__m_owner = self;
-    mutex->__m_count = 0;
-    return 0;
-  case PTHREAD_MUTEX_ERRORCHECK_NP:
-    self = thread_self();
-    if (mutex->__m_owner == self) return EDEADLK;
-    __pthread_alt_lock(&mutex->__m_lock, self);
-    mutex->__m_owner = self;
-    return 0;
-  case PTHREAD_MUTEX_TIMED_NP:
-    __pthread_alt_lock(&mutex->__m_lock, NULL);
-    return 0;
-  default:
-    return EINVAL;
-  }
-}
-strong_alias (__pthread_mutex_lock, pthread_mutex_lock)
-
-int pthread_mutex_timedlock (pthread_mutex_t *mutex,
-			       const struct timespec *abstime)
-{
-  pthread_descr self;
-  int res;
-
-  if (__builtin_expect (abstime->tv_nsec, 0) < 0
-      || __builtin_expect (abstime->tv_nsec, 0) >= 1000000000)
-    return EINVAL;
-
-  switch(mutex->__m_kind) {
-  case PTHREAD_MUTEX_ADAPTIVE_NP:
-    __pthread_lock(&mutex->__m_lock, NULL);
-    return 0;
-  case PTHREAD_MUTEX_RECURSIVE_NP:
-    self = thread_self();
-    if (mutex->__m_owner == self) {
-      mutex->__m_count++;
-      return 0;
-    }
-    __pthread_lock(&mutex->__m_lock, self);
-    mutex->__m_owner = self;
-    mutex->__m_count = 0;
-    return 0;
-  case PTHREAD_MUTEX_ERRORCHECK_NP:
-    self = thread_self();
-    if (mutex->__m_owner == self) return EDEADLK;
-    res = __pthread_alt_timedlock(&mutex->__m_lock, self, abstime);
-    if (res != 0)
-      {
-	mutex->__m_owner = self;
-	return 0;
-      }
-    return ETIMEDOUT;
-  case PTHREAD_MUTEX_TIMED_NP:
-    /* Only this type supports timed out lock. */
-    return (__pthread_alt_timedlock(&mutex->__m_lock, NULL, abstime)
-	    ? 0 : ETIMEDOUT);
-  default:
-    return EINVAL;
-  }
-}
-
-int attribute_hidden __pthread_mutex_unlock(pthread_mutex_t * mutex)
-{
-  switch (mutex->__m_kind) {
-  case PTHREAD_MUTEX_ADAPTIVE_NP:
-    __pthread_unlock(&mutex->__m_lock);
-    return 0;
-  case PTHREAD_MUTEX_RECURSIVE_NP:
-    if (mutex->__m_owner != thread_self())
-      return EPERM;
-    if (mutex->__m_count > 0) {
-      mutex->__m_count--;
-      return 0;
-    }
-    mutex->__m_owner = NULL;
-    __pthread_unlock(&mutex->__m_lock);
-    return 0;
-  case PTHREAD_MUTEX_ERRORCHECK_NP:
-    if (mutex->__m_owner != thread_self() || mutex->__m_lock.__status == 0)
-      return EPERM;
-    mutex->__m_owner = NULL;
-    __pthread_alt_unlock(&mutex->__m_lock);
-    return 0;
-  case PTHREAD_MUTEX_TIMED_NP:
-    __pthread_alt_unlock(&mutex->__m_lock);
-    return 0;
-  default:
-    return EINVAL;
-  }
-}
-strong_alias (__pthread_mutex_unlock, pthread_mutex_unlock)
-
-int attribute_hidden __pthread_mutexattr_init(pthread_mutexattr_t *attr)
-{
-  attr->__mutexkind = PTHREAD_MUTEX_TIMED_NP;
-  return 0;
-}
-strong_alias(__pthread_mutexattr_init,pthread_mutexattr_init)
-
-int attribute_hidden __pthread_mutexattr_destroy(pthread_mutexattr_t *attr attribute_unused)
-{
-  return 0;
-}
-strong_alias(__pthread_mutexattr_destroy,pthread_mutexattr_destroy)
-
-int attribute_hidden __pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind)
-{
-  if (kind != PTHREAD_MUTEX_ADAPTIVE_NP
-      && kind != PTHREAD_MUTEX_RECURSIVE_NP
-      && kind != PTHREAD_MUTEX_ERRORCHECK_NP
-      && kind != PTHREAD_MUTEX_TIMED_NP)
-    return EINVAL;
-  attr->__mutexkind = kind;
-  return 0;
-}
-strong_alias(__pthread_mutexattr_settype,pthread_mutexattr_settype)
-strong_alias (__pthread_mutexattr_settype, __pthread_mutexattr_setkind_np)
-weak_alias (__pthread_mutexattr_setkind_np, pthread_mutexattr_setkind_np)
-
-int __pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *kind) attribute_hidden;
-int __pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *kind)
-{
-  *kind = attr->__mutexkind;
-  return 0;
-}
-weak_alias (__pthread_mutexattr_gettype, pthread_mutexattr_gettype)
-strong_alias (__pthread_mutexattr_gettype, __pthread_mutexattr_getkind_np)
-weak_alias (__pthread_mutexattr_getkind_np, pthread_mutexattr_getkind_np)
-
-int __pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr attribute_unused,
-				   int *pshared) attribute_hidden;
-int __pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr attribute_unused,
-				   int *pshared)
-{
-  *pshared = PTHREAD_PROCESS_PRIVATE;
-  return 0;
-}
-weak_alias (__pthread_mutexattr_getpshared, pthread_mutexattr_getpshared)
-
-int __pthread_mutexattr_setpshared (pthread_mutexattr_t *attr attribute_unused, int pshared) attribute_hidden;
-int __pthread_mutexattr_setpshared (pthread_mutexattr_t *attr attribute_unused, int pshared)
-{
-  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
-    return EINVAL;
-
-  /* For now it is not possible to shared a conditional variable.  */
-  if (pshared != PTHREAD_PROCESS_PRIVATE)
-    return ENOSYS;
-
-  return 0;
-}
-weak_alias (__pthread_mutexattr_setpshared, pthread_mutexattr_setpshared)
-
-/* Once-only execution */
-
-static pthread_mutex_t once_masterlock = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t once_finished = PTHREAD_COND_INITIALIZER;
-static int fork_generation = 0;	/* Child process increments this after fork. */
-
-enum { NEVER = 0, IN_PROGRESS = 1, DONE = 2 };
-
-/* If a thread is canceled while calling the init_routine out of
-   pthread once, this handler will reset the once_control variable
-   to the NEVER state. */
-
-static void pthread_once_cancelhandler(void *arg)
-{
-    pthread_once_t *once_control = arg;
-
-    __pthread_mutex_lock(&once_masterlock);
-    *once_control = NEVER;
-    __pthread_mutex_unlock(&once_masterlock);
-    pthread_cond_broadcast(&once_finished);
-}
-
-int __pthread_once(pthread_once_t * once_control, void (*init_routine)(void))
-{
-  /* flag for doing the condition broadcast outside of mutex */
-  int state_changed;
-
-  /* Test without locking first for speed */
-  if (*once_control == DONE) {
-    READ_MEMORY_BARRIER();
-    return 0;
-  }
-  /* Lock and test again */
-
-  state_changed = 0;
-
-  __pthread_mutex_lock(&once_masterlock);
-
-  /* If this object was left in an IN_PROGRESS state in a parent
-     process (indicated by stale generation field), reset it to NEVER. */
-  if ((*once_control & 3) == IN_PROGRESS && (*once_control & ~3) != fork_generation)
-    *once_control = NEVER;
-
-  /* If init_routine is being called from another routine, wait until
-     it completes. */
-  while ((*once_control & 3) == IN_PROGRESS) {
-    pthread_cond_wait(&once_finished, &once_masterlock);
-  }
-  /* Here *once_control is stable and either NEVER or DONE. */
-  if (*once_control == NEVER) {
-    *once_control = IN_PROGRESS | fork_generation;
-    __pthread_mutex_unlock(&once_masterlock);
-    pthread_cleanup_push(pthread_once_cancelhandler, once_control);
-    init_routine();
-    pthread_cleanup_pop(0);
-    __pthread_mutex_lock(&once_masterlock);
-    WRITE_MEMORY_BARRIER();
-    *once_control = DONE;
-    state_changed = 1;
-  }
-  __pthread_mutex_unlock(&once_masterlock);
-
-  if (state_changed)
-    pthread_cond_broadcast(&once_finished);
-
-  return 0;
-}
-strong_alias (__pthread_once, pthread_once)
-
-/*
- * Handle the state of the pthread_once mechanism across forks.  The
- * once_masterlock is acquired in the parent process prior to a fork to ensure
- * that no thread is in the critical region protected by the lock.  After the
- * fork, the lock is released. In the child, the lock and the condition
- * variable are simply reset.  The child also increments its generation
- * counter which lets pthread_once calls detect stale IN_PROGRESS states
- * and reset them back to NEVER.
- */
-
-void __pthread_once_fork_prepare(void);
-void __pthread_once_fork_prepare(void)
-{
-  __pthread_mutex_lock(&once_masterlock);
-}
-
-void __pthread_once_fork_parent(void);
-void __pthread_once_fork_parent(void)
-{
-  __pthread_mutex_unlock(&once_masterlock);
-}
-
-void __pthread_once_fork_child(void);
-void __pthread_once_fork_child(void)
-{
-  __pthread_mutex_init(&once_masterlock, NULL);
-  pthread_cond_init(&once_finished, NULL);
-  if (fork_generation <= INT_MAX - 4)
-    fork_generation += 4;	/* leave least significant two bits zero */
-  else
-    fork_generation = 0;
-}
diff --git a/libpthread/linuxthreads.old/pt-machine.c b/libpthread/linuxthreads.old/pt-machine.c
deleted file mode 100644
index 6963dfcab..000000000
--- a/libpthread/linuxthreads.old/pt-machine.c
+++ /dev/null
@@ -1,21 +0,0 @@
-/* "Instantiation of machine-dependent pthreads inline functions.
-   Copyright (C) 1998 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-#define PT_EI
-
-#include <pt-machine.h>
diff --git a/libpthread/linuxthreads.old/ptfork.c b/libpthread/linuxthreads.old/ptfork.c
deleted file mode 100644
index 6f1e2d3c9..000000000
--- a/libpthread/linuxthreads.old/ptfork.c
+++ /dev/null
@@ -1,167 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* mods for uClibc: removed strong alias and defined funcs properly */
-
-/* The "atfork" stuff */
-
-#include <errno.h>
-
-#ifdef __ARCH_USE_MMU__
-
-#include <bits/uClibc_mutex.h>
-#include <stddef.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include "pthread.h"
-#include "internals.h"
-
-struct handler_list {
-  void (*handler)(void);
-  struct handler_list * next;
-};
-
-static pthread_mutex_t pthread_atfork_lock = PTHREAD_MUTEX_INITIALIZER;
-static struct handler_list * pthread_atfork_prepare = NULL;
-static struct handler_list * pthread_atfork_parent = NULL;
-static struct handler_list * pthread_atfork_child = NULL;
-
-#ifdef __MALLOC__
-__UCLIBC_MUTEX_EXTERN(__malloc_heap_lock);
-__UCLIBC_MUTEX_EXTERN(__malloc_sbrk_lock);
-#ifdef __UCLIBC_UCLINUX_BROKEN_MUNMAP__
-__UCLIBC_MUTEX_EXTERN(__malloc_mmb_heap_lock);
-#endif
-#elif defined(__MALLOC_STANDARD__) || defined(__MALLOC_SIMPLE__)
-__UCLIBC_MUTEX_EXTERN(__malloc_lock);
-#endif
-
-static void pthread_insert_list(struct handler_list ** list,
-                                void (*handler)(void),
-                                struct handler_list * newlist,
-                                int at_end)
-{
-  if (handler == NULL) return;
-  if (at_end) {
-    while(*list != NULL) list = &((*list)->next);
-  }
-  newlist->handler = handler;
-  newlist->next = *list;
-  *list = newlist;
-}
-
-struct handler_list_block {
-  struct handler_list prepare, parent, child;
-};
-
-int pthread_atfork(void (*prepare)(void),
-		     void (*parent)(void),
-		     void (*child)(void))
-{
-  struct handler_list_block * block =
-    (struct handler_list_block *) malloc(sizeof(struct handler_list_block));
-  if (block == NULL) return ENOMEM;
-  __pthread_mutex_lock(&pthread_atfork_lock);
-  /* "prepare" handlers are called in LIFO */
-  pthread_insert_list(&pthread_atfork_prepare, prepare, &block->prepare, 0);
-  /* "parent" handlers are called in FIFO */
-  pthread_insert_list(&pthread_atfork_parent, parent, &block->parent, 1);
-  /* "child" handlers are called in FIFO */
-  pthread_insert_list(&pthread_atfork_child, child, &block->child, 1);
-  __pthread_mutex_unlock(&pthread_atfork_lock);
-  return 0;
-}
-/*strong_alias (__pthread_atfork, pthread_atfork)*/
-
-static __inline__ void pthread_call_handlers(struct handler_list * list)
-{
-  for (/*nothing*/; list != NULL; list = list->next) (list->handler)();
-}
-
-void __pthread_once_fork_prepare(void);
-void __pthread_once_fork_child(void);
-void __pthread_once_fork_parent(void);
-
-static pid_t __fork(void)
-{
-  pid_t pid;
-  struct handler_list * prepare, * child, * parent;
-
-  __pthread_mutex_lock(&pthread_atfork_lock);
-  prepare = pthread_atfork_prepare;
-  child = pthread_atfork_child;
-  parent = pthread_atfork_parent;
-  pthread_call_handlers(prepare);
-
-  __pthread_once_fork_prepare();
-#ifdef __MALLOC__
-  __pthread_mutex_lock(&__malloc_sbrk_lock);
-  __pthread_mutex_lock(&__malloc_heap_lock);
-#ifdef __UCLIBC_UCLINUX_BROKEN_MUNMAP__
-  __pthread_mutex_lock(&__malloc_mmb_heap_lock);
-#endif
-#elif defined(__MALLOC_STANDARD__) || defined(__MALLOC_SIMPLE__)
-  __pthread_mutex_lock(&__malloc_lock);
-#endif
-
-  pid = __libc_fork();
-  if (pid == 0) {
-#if defined(__MALLOC_STANDARD__) || defined(__MALLOC_SIMPLE__)
-    __libc_lock_init_recursive(__malloc_lock);
-#elif defined(__MALLOC__)
-#ifdef __UCLIBC_UCLINUX_BROKEN_MUNMAP__
-    __libc_lock_init_adaptive(__malloc_mmb_heap_lock);
-#endif
-    __libc_lock_init_adaptive(__malloc_heap_lock);
-    __libc_lock_init(__malloc_sbrk_lock);
-#endif
-    __libc_lock_init_adaptive(pthread_atfork_lock);
-    __pthread_reset_main_thread();
-    __fresetlockfiles();
-    __pthread_once_fork_child();
-    pthread_call_handlers(child);
-  } else {
-#if defined(__MALLOC_STANDARD__) || defined(__MALLOC_SIMPLE__)
-    __pthread_mutex_unlock(&__malloc_lock);
-#elif defined(__MALLOC__)
-#ifdef __UCLIBC_UCLINUX_BROKEN_MUNMAP__
-    __pthread_mutex_unlock(&__malloc_mmb_heap_lock);
-#endif
-    __pthread_mutex_unlock(&__malloc_heap_lock);
-    __pthread_mutex_unlock(&__malloc_sbrk_lock);
-#endif
-    __pthread_mutex_unlock(&pthread_atfork_lock);
-    __pthread_once_fork_parent();
-    pthread_call_handlers(parent);
-  }
-  return pid;
-}
-strong_alias(__fork,fork)
-strong_alias(__fork,vfork)
-
-#else
-
-/* We can't support pthread_atfork without MMU, since we don't have
-   fork(), and we can't offer the correct semantics for vfork().  */
-int pthread_atfork(void (*prepare)(void),
-		   void (*parent)(void),
-		   void (*child)(void))
-{
-  /* ENOMEM is probably pushing it a little bit.
-     Take it as `no *virtual* memory' :-)  */
-  errno = ENOMEM;
-  return -1;
-}
-
-#endif
diff --git a/libpthread/linuxthreads.old/pthread.c b/libpthread/linuxthreads.old/pthread.c
deleted file mode 100644
index 00197b158..000000000
--- a/libpthread/linuxthreads.old/pthread.c
+++ /dev/null
@@ -1,1165 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Thread creation, initialization, and basic low-level routines */
-
-#include <errno.h>
-#include <netdb.h>	/* for h_errno */
-#include <stddef.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/wait.h>
-#include <sys/resource.h>
-#include "pthread.h"
-#include "internals.h"
-#include "spinlock.h"
-#include "restart.h"
-#include "debug.h"      /* added to linuxthreads -StS */
-
-
-/* Mods for uClibc: Some includes */
-#include <signal.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-
-libpthread_hidden_proto(waitpid)
-libpthread_hidden_proto(raise)
-
-/* These variables are used by the setup code.  */
-extern int _errno;
-extern int _h_errno;
-
-
-/* Descriptor of the initial thread */
-
-struct _pthread_descr_struct __pthread_initial_thread = {
-  &__pthread_initial_thread,  /* pthread_descr p_nextlive */
-  &__pthread_initial_thread,  /* pthread_descr p_prevlive */
-  NULL,                       /* pthread_descr p_nextwaiting */
-  NULL,			      /* pthread_descr p_nextlock */
-  PTHREAD_THREADS_MAX,        /* pthread_t p_tid */
-  0,                          /* int p_pid */
-  0,                          /* int p_priority */
-  &__pthread_handles[0].h_lock, /* struct _pthread_fastlock * p_lock */
-  0,                          /* int p_signal */
-  NULL,                       /* sigjmp_buf * p_signal_buf */
-  NULL,                       /* sigjmp_buf * p_cancel_buf */
-  0,                          /* char p_terminated */
-  0,                          /* char p_detached */
-  0,                          /* char p_exited */
-  NULL,                       /* void * p_retval */
-  0,                          /* int p_retval */
-  NULL,                       /* pthread_descr p_joining */
-  NULL,                       /* struct _pthread_cleanup_buffer * p_cleanup */
-  0,                          /* char p_cancelstate */
-  0,                          /* char p_canceltype */
-  0,                          /* char p_canceled */
-  &_errno,                       /* int *p_errnop */
-  0,                          /* int p_errno */
-  &_h_errno,                       /* int *p_h_errnop */
-  0,                          /* int p_h_errno */
-  NULL,                       /* char * p_in_sighandler */
-  0,                          /* char p_sigwaiting */
-  PTHREAD_START_ARGS_INITIALIZER, /* struct pthread_start_args p_start_args */
-  {NULL},                     /* void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE] */
-  {NULL},                     /* void * p_libc_specific[_LIBC_TSD_KEY_N] */
-  0,                          /* int p_userstack */
-  NULL,                       /* void * p_guardaddr */
-  0,                          /* size_t p_guardsize */
-  &__pthread_initial_thread,  /* pthread_descr p_self */
-  0,                          /* Always index 0 */
-  0,                          /* int p_report_events */
-  {{{0, }}, 0, NULL},         /* td_eventbuf_t p_eventbuf */
-  __ATOMIC_INITIALIZER,         /* struct pthread_atomic p_resume_count */
-  0,                          /* char p_woken_by_cancel */
-  0,                          /* char p_condvar_avail */
-  0,                          /* char p_sem_avail */
-  NULL,                       /* struct pthread_extricate_if *p_extricate */
-  NULL,	                      /* pthread_readlock_info *p_readlock_list; */
-  NULL,                       /* pthread_readlock_info *p_readlock_free; */
-  0                           /* int p_untracked_readlock_count; */
-#ifdef __UCLIBC_HAS_XLOCALE__
-  ,
-  &__global_locale_data,      /* __locale_t locale; */
-#endif /* __UCLIBC_HAS_XLOCALE__ */
-};
-
-/* Descriptor of the manager thread; none of this is used but the error
-   variables, the p_pid and p_priority fields,
-   and the address for identification.  */
-#define manager_thread (&__pthread_manager_thread)
-struct _pthread_descr_struct __pthread_manager_thread = {
-  NULL,                       /* pthread_descr p_nextlive */
-  NULL,                       /* pthread_descr p_prevlive */
-  NULL,                       /* pthread_descr p_nextwaiting */
-  NULL,			      /* pthread_descr p_nextlock */
-  0,                          /* int p_tid */
-  0,                          /* int p_pid */
-  0,                          /* int p_priority */
-  &__pthread_handles[1].h_lock, /* struct _pthread_fastlock * p_lock */
-  0,                          /* int p_signal */
-  NULL,                       /* sigjmp_buf * p_signal_buf */
-  NULL,                       /* sigjmp_buf * p_cancel_buf */
-  0,                          /* char p_terminated */
-  0,                          /* char p_detached */
-  0,                          /* char p_exited */
-  NULL,                       /* void * p_retval */
-  0,                          /* int p_retval */
-  NULL,                       /* pthread_descr p_joining */
-  NULL,                       /* struct _pthread_cleanup_buffer * p_cleanup */
-  0,                          /* char p_cancelstate */
-  0,                          /* char p_canceltype */
-  0,                          /* char p_canceled */
-  &__pthread_manager_thread.p_errno, /* int *p_errnop */
-  0,                          /* int p_errno */
-  NULL,                       /* int *p_h_errnop */
-  0,                          /* int p_h_errno */
-  NULL,                       /* char * p_in_sighandler */
-  0,                          /* char p_sigwaiting */
-  PTHREAD_START_ARGS_INITIALIZER, /* struct pthread_start_args p_start_args */
-  {NULL},                     /* void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE] */
-  {NULL},                     /* void * p_libc_specific[_LIBC_TSD_KEY_N] */
-  0,                          /* int p_userstack */
-  NULL,                       /* void * p_guardaddr */
-  0,                          /* size_t p_guardsize */
-  &__pthread_manager_thread,  /* pthread_descr p_self */
-  1,                          /* Always index 1 */
-  0,                          /* int p_report_events */
-  {{{0, }}, 0, NULL},         /* td_eventbuf_t p_eventbuf */
-  __ATOMIC_INITIALIZER,         /* struct pthread_atomic p_resume_count */
-  0,                          /* char p_woken_by_cancel */
-  0,                          /* char p_condvar_avail */
-  0,                          /* char p_sem_avail */
-  NULL,                       /* struct pthread_extricate_if *p_extricate */
-  NULL,	                      /* pthread_readlock_info *p_readlock_list; */
-  NULL,                       /* pthread_readlock_info *p_readlock_free; */
-  0                           /* int p_untracked_readlock_count; */
-#ifdef __UCLIBC_HAS_XLOCALE__
-  ,
-  &__global_locale_data,      /* __locale_t locale; */
-#endif /* __UCLIBC_HAS_XLOCALE__ */
-};
-
-/* Pointer to the main thread (the father of the thread manager thread) */
-/* Originally, this is the initial thread, but this changes after fork() */
-
-pthread_descr __pthread_main_thread = &__pthread_initial_thread;
-
-/* Limit between the stack of the initial thread (above) and the
-   stacks of other threads (below). Aligned on a STACK_SIZE boundary. */
-
-char *__pthread_initial_thread_bos = NULL;
-
-#ifndef __ARCH_USE_MMU__
-/* See nommu notes in internals.h and pthread_initialize() below. */
-char *__pthread_initial_thread_tos = NULL;
-char *__pthread_initial_thread_mid = NULL;
-#endif /* __ARCH_USE_MMU__ */
-
-/* File descriptor for sending requests to the thread manager. */
-/* Initially -1, meaning that the thread manager is not running. */
-
-int __pthread_manager_request = -1;
-
-/* Other end of the pipe for sending requests to the thread manager. */
-
-int __pthread_manager_reader;
-
-/* Limits of the thread manager stack */
-
-char *__pthread_manager_thread_bos = NULL;
-char *__pthread_manager_thread_tos = NULL;
-
-/* For process-wide exit() */
-
-int __pthread_exit_requested = 0;
-int __pthread_exit_code = 0;
-
-/* Communicate relevant LinuxThreads constants to gdb */
-
-const int __pthread_threads_max = PTHREAD_THREADS_MAX;
-const int __pthread_sizeof_handle = sizeof(struct pthread_handle_struct);
-const int __pthread_offsetof_descr = offsetof(struct pthread_handle_struct, h_descr);
-const int __pthread_offsetof_pid = offsetof(struct _pthread_descr_struct,
-                                            p_pid);
-const int __linuxthreads_pthread_sizeof_descr
-  = sizeof(struct _pthread_descr_struct);
-
-const int __linuxthreads_initial_report_events;
-
-const char __linuxthreads_version[] = VERSION;
-
-/* Forward declarations */
-static void pthread_onexit_process(int retcode, void *arg);
-static void pthread_handle_sigcancel(int sig);
-static void pthread_handle_sigrestart(int sig);
-static void pthread_handle_sigdebug(int sig);
-int __pthread_timedsuspend_new(pthread_descr self, const struct timespec *abstime);
-
-/* Signal numbers used for the communication.
-   In these variables we keep track of the used variables.  If the
-   platform does not support any real-time signals we will define the
-   values to some unreasonable value which will signal failing of all
-   the functions below.  */
-#ifndef __NR_rt_sigaction
-static int current_rtmin = -1;
-static int current_rtmax = -1;
-int __pthread_sig_restart = SIGUSR1;
-int __pthread_sig_cancel = SIGUSR2;
-int __pthread_sig_debug;
-#else
-
-#if __SIGRTMAX - __SIGRTMIN >= 3
-static int current_rtmin = __SIGRTMIN + 3;
-static int current_rtmax = __SIGRTMAX;
-int __pthread_sig_restart = __SIGRTMIN;
-int __pthread_sig_cancel = __SIGRTMIN + 1;
-int __pthread_sig_debug = __SIGRTMIN + 2;
-void (*__pthread_restart)(pthread_descr) = __pthread_restart_new;
-void (*__pthread_suspend)(pthread_descr) = __pthread_wait_for_restart_signal;
-int (*__pthread_timedsuspend)(pthread_descr, const struct timespec *) = __pthread_timedsuspend_new;
-#else
-static int current_rtmin = __SIGRTMIN;
-static int current_rtmax = __SIGRTMAX;
-int __pthread_sig_restart = SIGUSR1;
-int __pthread_sig_cancel = SIGUSR2;
-int __pthread_sig_debug;
-void (*__pthread_restart)(pthread_descr) = __pthread_restart_old;
-void (*__pthread_suspend)(pthread_descr) = __pthread_suspend_old;
-int (*__pthread_timedsuspend)(pthread_descr, const struct timespec *) = __pthread_timedsuspend_old;
-
-#endif
-
-/* Return number of available real-time signal with highest priority.  */
-int __libc_current_sigrtmin (void)
-{
-    return current_rtmin;
-}
-
-/* Return number of available real-time signal with lowest priority.  */
-int __libc_current_sigrtmax (void)
-{
-    return current_rtmax;
-}
-
-#if 0
-/* Allocate real-time signal with highest/lowest available
-   priority.  Please note that we don't use a lock since we assume
-   this function to be called at program start.  */
-int __libc_allocate_rtsig (int high);
-int __libc_allocate_rtsig (int high)
-{
-    if (current_rtmin == -1 || current_rtmin > current_rtmax)
-	/* We don't have anymore signal available.  */
-	return -1;
-    return high ? current_rtmin++ : current_rtmax--;
-}
-#endif
-#endif
-
-/* Initialize the pthread library.
-   Initialization is split in two functions:
-   - a constructor function that blocks the __pthread_sig_restart signal
-     (must do this very early, since the program could capture the signal
-      mask with e.g. sigsetjmp before creating the first thread);
-   - a regular function called from pthread_create when needed. */
-
-static void pthread_initialize(void) __attribute__((constructor));
-
-libpthread_hidden_proto(pthread_attr_destroy)
-libpthread_hidden_proto(pthread_attr_init)
-libpthread_hidden_proto(pthread_attr_getdetachstate)
-libpthread_hidden_proto(pthread_attr_setdetachstate)
-libpthread_hidden_proto(pthread_attr_getinheritsched)
-libpthread_hidden_proto(pthread_attr_setinheritsched)
-libpthread_hidden_proto(pthread_attr_setschedparam)
-libpthread_hidden_proto(pthread_attr_getschedparam)
-libpthread_hidden_proto(pthread_attr_getschedpolicy)
-libpthread_hidden_proto(pthread_attr_setschedpolicy)
-libpthread_hidden_proto(pthread_attr_getscope)
-libpthread_hidden_proto(pthread_attr_setscope)
-
-libpthread_hidden_proto(pthread_exit)
-
-libpthread_hidden_proto(pthread_equal)
-libpthread_hidden_proto(pthread_self)
-libpthread_hidden_proto(pthread_getschedparam)
-libpthread_hidden_proto(pthread_setschedparam)
-
-libpthread_hidden_proto(pthread_setcancelstate)
-libpthread_hidden_proto(pthread_setcanceltype)
-libpthread_hidden_proto(_pthread_cleanup_push_defer)
-libpthread_hidden_proto(_pthread_cleanup_pop_restore)
-
-libpthread_hidden_proto(pthread_cond_broadcast)
-libpthread_hidden_proto(pthread_cond_destroy)
-libpthread_hidden_proto(pthread_cond_init)
-libpthread_hidden_proto(pthread_cond_signal)
-libpthread_hidden_proto(pthread_cond_wait)
-libpthread_hidden_proto(pthread_cond_timedwait)
-
-libpthread_hidden_proto(pthread_condattr_destroy)
-libpthread_hidden_proto(pthread_condattr_init)
-
-struct pthread_functions __pthread_functions =
-  {
-#if !defined __UCLIBC_HAS_TLS__ && defined __UCLIBC_HAS_RPC__
-    .ptr_pthread_internal_tsd_set = __pthread_internal_tsd_set,
-    .ptr_pthread_internal_tsd_get = __pthread_internal_tsd_get,
-    .ptr_pthread_internal_tsd_address = __pthread_internal_tsd_address,
-#endif
-/*
-    .ptr_pthread_fork = __pthread_fork,
-*/
-    .ptr_pthread_attr_destroy = pthread_attr_destroy,
-    .ptr_pthread_attr_init = pthread_attr_init,
-    .ptr_pthread_attr_getdetachstate = pthread_attr_getdetachstate,
-    .ptr_pthread_attr_setdetachstate = pthread_attr_setdetachstate,
-    .ptr_pthread_attr_getinheritsched = pthread_attr_getinheritsched,
-    .ptr_pthread_attr_setinheritsched = pthread_attr_setinheritsched,
-    .ptr_pthread_attr_getschedparam = pthread_attr_getschedparam,
-    .ptr_pthread_attr_setschedparam = pthread_attr_setschedparam,
-    .ptr_pthread_attr_getschedpolicy = pthread_attr_getschedpolicy,
-    .ptr_pthread_attr_setschedpolicy = pthread_attr_setschedpolicy,
-    .ptr_pthread_attr_getscope = pthread_attr_getscope,
-    .ptr_pthread_attr_setscope = pthread_attr_setscope,
-    .ptr_pthread_condattr_destroy = pthread_condattr_destroy,
-    .ptr_pthread_condattr_init = pthread_condattr_init,
-    .ptr_pthread_cond_broadcast = pthread_cond_broadcast,
-    .ptr_pthread_cond_destroy = pthread_cond_destroy,
-    .ptr_pthread_cond_init = pthread_cond_init,
-    .ptr_pthread_cond_signal = pthread_cond_signal,
-    .ptr_pthread_cond_wait = pthread_cond_wait,
-    .ptr_pthread_cond_timedwait = pthread_cond_timedwait,
-    .ptr_pthread_equal = pthread_equal,
-    .ptr___pthread_exit = pthread_exit,
-    .ptr_pthread_getschedparam = pthread_getschedparam,
-    .ptr_pthread_setschedparam = pthread_setschedparam,
-    .ptr_pthread_mutex_destroy = __pthread_mutex_destroy,
-    .ptr_pthread_mutex_init = __pthread_mutex_init,
-    .ptr_pthread_mutex_lock = __pthread_mutex_lock,
-    .ptr_pthread_mutex_trylock = __pthread_mutex_trylock,
-    .ptr_pthread_mutex_unlock = __pthread_mutex_unlock,
-    .ptr_pthread_self = pthread_self,
-    .ptr_pthread_setcancelstate = pthread_setcancelstate,
-    .ptr_pthread_setcanceltype = pthread_setcanceltype,
-/*
-    .ptr_pthread_do_exit = pthread_do_exit,
-    .ptr_pthread_thread_self = pthread_thread_self,
-    .ptr_pthread_cleanup_upto = pthread_cleanup_upto,
-    .ptr_pthread_sigaction = pthread_sigaction,
-    .ptr_pthread_sigwait = pthread_sigwait,
-    .ptr_pthread_raise = pthread_raise,
-    .ptr__pthread_cleanup_push = _pthread_cleanup_push,
-    .ptr__pthread_cleanup_pop = _pthread_cleanup_pop,
-*/
-    .ptr__pthread_cleanup_push_defer = __pthread_cleanup_push_defer,
-    .ptr__pthread_cleanup_pop_restore = __pthread_cleanup_pop_restore
-  };
-#ifdef SHARED
-# define ptr_pthread_functions &__pthread_functions
-#else
-# define ptr_pthread_functions NULL
-#endif
-
-static int *__libc_multiple_threads_ptr;
-
- /* Do some minimal initialization which has to be done during the
-    startup of the C library.  */
-void __pthread_initialize_minimal(void)
-{
-    /* If we have special thread_self processing, initialize
-     * that for the main thread now.  */
-#ifdef INIT_THREAD_SELF
-    INIT_THREAD_SELF(&__pthread_initial_thread, 0);
-#endif
-
-    __libc_multiple_threads_ptr = __libc_pthread_init (ptr_pthread_functions);
-}
-
-
-static void pthread_initialize(void)
-{
-  struct sigaction sa;
-  sigset_t mask;
-#ifdef __ARCH_USE_MMU__
-  struct rlimit limit;
-  rlim_t max_stack;
-#endif
-
-  /* If already done (e.g. by a constructor called earlier!), bail out */
-  if (__pthread_initial_thread_bos != NULL) return;
-#ifdef TEST_FOR_COMPARE_AND_SWAP
-  /* Test if compare-and-swap is available */
-  __pthread_has_cas = compare_and_swap_is_available();
-#endif
-  /* For the initial stack, reserve at least STACK_SIZE bytes of stack
-     below the current stack address, and align that on a
-     STACK_SIZE boundary. */
-  __pthread_initial_thread_bos =
-    (char *)(((long)CURRENT_STACK_FRAME - 2 * STACK_SIZE) & ~(STACK_SIZE - 1));
-  /* Update the descriptor for the initial thread. */
-  __pthread_initial_thread.p_pid = getpid();
-  /* If we have special thread_self processing, initialize that for the
-     main thread now.  */
-#ifdef INIT_THREAD_SELF
-  INIT_THREAD_SELF(&__pthread_initial_thread, 0);
-#endif
-  /* The errno/h_errno variable of the main thread are the global ones.  */
-  __pthread_initial_thread.p_errnop = &_errno;
-  __pthread_initial_thread.p_h_errnop = &_h_errno;
-
-#ifdef __UCLIBC_HAS_XLOCALE__
-  /* The locale of the main thread is the current locale in use. */
-  __pthread_initial_thread.locale = __curlocale_var;
-#endif /* __UCLIBC_HAS_XLOCALE__ */
-
- {			   /* uClibc-specific stdio initialization for threads. */
-	 FILE *fp;
-
-	 _stdio_user_locking = 0;	/* 2 if threading not initialized */
-	 for (fp = _stdio_openlist; fp != NULL; fp = fp->__nextopen) {
-		 if (fp->__user_locking != 1) {
-			 fp->__user_locking = 0;
-		 }
-	 }
- }
-
-  /* Play with the stack size limit to make sure that no stack ever grows
-     beyond STACK_SIZE minus two pages (one page for the thread descriptor
-     immediately beyond, and one page to act as a guard page). */
-
-#ifdef __ARCH_USE_MMU__
-  /* We cannot allocate a huge chunk of memory to mmap all thread stacks later
-   * on a non-MMU system. Thus, we don't need the rlimit either. -StS */
-  getrlimit(RLIMIT_STACK, &limit);
-  max_stack = STACK_SIZE - 2 * getpagesize();
-  if (limit.rlim_cur > max_stack) {
-    limit.rlim_cur = max_stack;
-    setrlimit(RLIMIT_STACK, &limit);
-  }
-#else
-  /* For non-MMU, the initial thread stack can reside anywhere in memory.
-   * We don't have a way of knowing where the kernel started things -- top
-   * or bottom (well, that isn't exactly true, but the solution is fairly
-   * complex and error prone).  All we can determine here is an address
-   * that lies within that stack.  Save that address as a reference so that
-   * as other thread stacks are created, we can adjust the estimated bounds
-   * of the initial thread's stack appropriately.
-   *
-   * This checking is handled in NOMMU_INITIAL_THREAD_BOUNDS(), so see that
-   * for a few more details.
-   */
-  __pthread_initial_thread_mid = CURRENT_STACK_FRAME;
-  __pthread_initial_thread_tos = (char *) -1;
-  __pthread_initial_thread_bos = (char *) 1; /* set it non-zero so we know we have been here */
-  PDEBUG("initial thread stack bounds: bos=%p, tos=%p\n",
-	 __pthread_initial_thread_bos, __pthread_initial_thread_tos);
-#endif /* __ARCH_USE_MMU__ */
-
-  /* Setup signal handlers for the initial thread.
-     Since signal handlers are shared between threads, these settings
-     will be inherited by all other threads. */
-  memset(&sa, 0, sizeof(sa));
-  sa.sa_handler = pthread_handle_sigrestart;
-  __libc_sigaction(__pthread_sig_restart, &sa, NULL);
-  sa.sa_handler = pthread_handle_sigcancel;
-  sigaddset(&sa.sa_mask, __pthread_sig_restart);
-  __libc_sigaction(__pthread_sig_cancel, &sa, NULL);
-  if (__pthread_sig_debug > 0) {
-      sa.sa_handler = pthread_handle_sigdebug;
-      __sigemptyset(&sa.sa_mask);
-      __libc_sigaction(__pthread_sig_debug, &sa, NULL);
-  }
-  /* Initially, block __pthread_sig_restart. Will be unblocked on demand. */
-  __sigemptyset(&mask);
-  sigaddset(&mask, __pthread_sig_restart);
-  sigprocmask(SIG_BLOCK, &mask, NULL);
-  /* And unblock __pthread_sig_cancel if it has been blocked. */
-  sigdelset(&mask, __pthread_sig_restart);
-  sigaddset(&mask, __pthread_sig_cancel);
-  sigprocmask(SIG_UNBLOCK, &mask, NULL);
-  /* Register an exit function to kill all other threads. */
-  /* Do it early so that user-registered atexit functions are called
-     before pthread_onexit_process. */
-  on_exit(pthread_onexit_process, NULL);
-}
-
-void __pthread_initialize(void);
-void __pthread_initialize(void)
-{
-  pthread_initialize();
-}
-
-int __pthread_initialize_manager(void)
-{
-  int manager_pipe[2];
-  int pid;
-  int report_events;
-  struct pthread_request request;
-
-  *__libc_multiple_threads_ptr = 1;
-
-  /* If basic initialization not done yet (e.g. we're called from a
-     constructor run before our constructor), do it now */
-  if (__pthread_initial_thread_bos == NULL) pthread_initialize();
-  /* Setup stack for thread manager */
-  __pthread_manager_thread_bos = malloc(THREAD_MANAGER_STACK_SIZE);
-  if (__pthread_manager_thread_bos == NULL) return -1;
-  __pthread_manager_thread_tos =
-    __pthread_manager_thread_bos + THREAD_MANAGER_STACK_SIZE;
-
-  /* On non-MMU systems we make sure that the initial thread bounds don't overlap
-   * with the manager stack frame */
-  NOMMU_INITIAL_THREAD_BOUNDS(__pthread_manager_thread_tos,__pthread_manager_thread_bos);
-  PDEBUG("manager stack: size=%ld, bos=%p, tos=%p\n", THREAD_MANAGER_STACK_SIZE,
-	 __pthread_manager_thread_bos, __pthread_manager_thread_tos);
-#if 0
-  PDEBUG("initial stack: estimate bos=%p, tos=%p\n",
-	 __pthread_initial_thread_bos, __pthread_initial_thread_tos);
-#endif
-
-  /* Setup pipe to communicate with thread manager */
-  if (pipe(manager_pipe) == -1) {
-    free(__pthread_manager_thread_bos);
-    return -1;
-  }
-  /* Start the thread manager */
-  pid = 0;
-#if defined(USE_TLS) && USE_TLS
-  if (__linuxthreads_initial_report_events != 0)
-    THREAD_SETMEM (((pthread_descr) NULL), p_report_events,
-		   __linuxthreads_initial_report_events);
-  report_events = THREAD_GETMEM (((pthread_descr) NULL), p_report_events);
-#else
-  if (__linuxthreads_initial_report_events != 0)
-    __pthread_initial_thread.p_report_events
-      = __linuxthreads_initial_report_events;
-  report_events = __pthread_initial_thread.p_report_events;
-#endif
-  if (__builtin_expect (report_events, 0))
-    {
-      /* It's a bit more complicated.  We have to report the creation of
-	 the manager thread.  */
-      int idx = __td_eventword (TD_CREATE);
-      uint32_t mask = __td_eventmask (TD_CREATE);
-
-      if ((mask & (__pthread_threads_events.event_bits[idx]
-		   | __pthread_initial_thread.p_eventbuf.eventmask.event_bits[idx]))
-	  != 0)
-	{
-
-	 __pthread_lock(__pthread_manager_thread.p_lock, NULL);
-
-#ifdef __ia64__
-	  pid = __clone2(__pthread_manager_event,
-			(void **) __pthread_manager_thread_tos,
-			THREAD_MANAGER_STACK_SIZE,
-			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,
-			(void *)(long)manager_pipe[0]);
-#else
-	  pid = clone(__pthread_manager_event,
-			(void **) __pthread_manager_thread_tos,
-			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,
-			(void *)(long)manager_pipe[0]);
-#endif
-
-	  if (pid != -1)
-	    {
-	      /* Now fill in the information about the new thread in
-	         the newly created thread's data structure.  We cannot let
-	         the new thread do this since we don't know whether it was
-	         already scheduled when we send the event.  */
-	      __pthread_manager_thread.p_eventbuf.eventdata =
-		  &__pthread_manager_thread;
-	      __pthread_manager_thread.p_eventbuf.eventnum = TD_CREATE;
-	      __pthread_last_event = &__pthread_manager_thread;
-	      __pthread_manager_thread.p_tid = 2* PTHREAD_THREADS_MAX + 1;
-	      __pthread_manager_thread.p_pid = pid;
-
-	      /* Now call the function which signals the event.  */
-	      __linuxthreads_create_event ();
-	    }
-	  /* Now restart the thread.  */
-	  __pthread_unlock(__pthread_manager_thread.p_lock);
-	}
-    }
-
-  if (pid == 0) {
-#ifdef __ia64__
-    pid = __clone2(__pthread_manager, (void **) __pthread_manager_thread_tos,
-		  THREAD_MANAGER_STACK_SIZE,
-		  CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,
-		  (void *)(long)manager_pipe[0]);
-#else
-    pid = clone(__pthread_manager, (void **) __pthread_manager_thread_tos,
-		  CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,
-		  (void *)(long)manager_pipe[0]);
-#endif
-  }
-  if (pid == -1) {
-    free(__pthread_manager_thread_bos);
-    close(manager_pipe[0]);
-    close(manager_pipe[1]);
-    return -1;
-  }
-  __pthread_manager_request = manager_pipe[1]; /* writing end */
-  __pthread_manager_reader = manager_pipe[0]; /* reading end */
-  __pthread_manager_thread.p_tid = 2* PTHREAD_THREADS_MAX + 1;
-  __pthread_manager_thread.p_pid = pid;
-
-  /* Make gdb aware of new thread manager */
-  if (__pthread_threads_debug && __pthread_sig_debug > 0)
-    {
-      raise(__pthread_sig_debug);
-      /* We suspend ourself and gdb will wake us up when it is
-	 ready to handle us. */
-      __pthread_wait_for_restart_signal(thread_self());
-    }
-  /* Synchronize debugging of the thread manager */
-  PDEBUG("send REQ_DEBUG to manager thread\n");
-  request.req_kind = REQ_DEBUG;
-  TEMP_FAILURE_RETRY(write(__pthread_manager_request,
-	      (char *) &request, sizeof(request)));
-  return 0;
-}
-
-/* Thread creation */
-
-int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
-			 void * (*start_routine)(void *), void *arg)
-{
-  pthread_descr self = thread_self();
-  struct pthread_request request;
-  if (__pthread_manager_request < 0) {
-    if (__pthread_initialize_manager() < 0) return EAGAIN;
-  }
-  request.req_thread = self;
-  request.req_kind = REQ_CREATE;
-  request.req_args.create.attr = attr;
-  request.req_args.create.fn = start_routine;
-  request.req_args.create.arg = arg;
-  sigprocmask(SIG_SETMASK, NULL, &request.req_args.create.mask);
-  PDEBUG("write REQ_CREATE to manager thread\n");
-  TEMP_FAILURE_RETRY(write(__pthread_manager_request,
-	      (char *) &request, sizeof(request)));
-  PDEBUG("before suspend(self)\n");
-  suspend(self);
-  PDEBUG("after suspend(self)\n");
-  if (THREAD_GETMEM(self, p_retcode) == 0)
-    *thread = (pthread_t) THREAD_GETMEM(self, p_retval);
-  return THREAD_GETMEM(self, p_retcode);
-}
-
-/* Simple operations on thread identifiers */
-
-pthread_t pthread_self(void)
-{
-  pthread_descr self = thread_self();
-  return THREAD_GETMEM(self, p_tid);
-}
-libpthread_hidden_def (pthread_self)
-
-int pthread_equal(pthread_t thread1, pthread_t thread2)
-{
-  return thread1 == thread2;
-}
-libpthread_hidden_def (pthread_equal)
-
-/* Helper function for thread_self in the case of user-provided stacks */
-
-#ifndef THREAD_SELF
-
-pthread_descr __pthread_find_self(void)
-{
-  char * sp = CURRENT_STACK_FRAME;
-  pthread_handle h;
-
-  /* __pthread_handles[0] is the initial thread, __pthread_handles[1] is
-     the manager threads handled specially in thread_self(), so start at 2 */
-  h = __pthread_handles + 2;
-  while (! (sp <= (char *) h->h_descr && sp >= h->h_bottom)) h++;
-
-#ifdef DEBUG_PT
-  if (h->h_descr == NULL) {
-      printf("*** %s ERROR descriptor is NULL!!!!! ***\n\n", __FUNCTION__);
-      _exit(1);
-  }
-#endif
-
-  return h->h_descr;
-}
-#else
-
-static pthread_descr thread_self_stack(void)
-{
-    char *sp = CURRENT_STACK_FRAME;
-    pthread_handle h;
-
-    if (sp >= __pthread_manager_thread_bos && sp < __pthread_manager_thread_tos)
-	return manager_thread;
-    h = __pthread_handles + 2;
-# if defined(USE_TLS) && USE_TLS
-    while (h->h_descr == NULL
-	    || ! (sp <= (char *) h->h_descr->p_stackaddr && sp >= h->h_bottom))
-	h++;
-# else
-    while (! (sp <= (char *) h->h_descr && sp >= h->h_bottom))
-	h++;
-# endif
-    return h->h_descr;
-}
-
-#endif
-
-/* Thread scheduling */
-
-int pthread_setschedparam(pthread_t thread, int policy,
-                          const struct sched_param *param)
-{
-  pthread_handle handle = thread_handle(thread);
-  pthread_descr th;
-
-  __pthread_lock(&handle->h_lock, NULL);
-  if (invalid_handle(handle, thread)) {
-    __pthread_unlock(&handle->h_lock);
-    return ESRCH;
-  }
-  th = handle->h_descr;
-  if (sched_setscheduler(th->p_pid, policy, param) == -1) {
-    __pthread_unlock(&handle->h_lock);
-    return errno;
-  }
-  th->p_priority = policy == SCHED_OTHER ? 0 : param->sched_priority;
-  __pthread_unlock(&handle->h_lock);
-  if (__pthread_manager_request >= 0)
-    __pthread_manager_adjust_prio(th->p_priority);
-  return 0;
-}
-libpthread_hidden_def(pthread_setschedparam)
-
-int pthread_getschedparam(pthread_t thread, int *policy,
-                          struct sched_param *param)
-{
-  pthread_handle handle = thread_handle(thread);
-  int pid, pol;
-
-  __pthread_lock(&handle->h_lock, NULL);
-  if (invalid_handle(handle, thread)) {
-    __pthread_unlock(&handle->h_lock);
-    return ESRCH;
-  }
-  pid = handle->h_descr->p_pid;
-  __pthread_unlock(&handle->h_lock);
-  pol = sched_getscheduler(pid);
-  if (pol == -1) return errno;
-  if (sched_getparam(pid, param) == -1) return errno;
-  *policy = pol;
-  return 0;
-}
-libpthread_hidden_def(pthread_getschedparam)
-
-/* Process-wide exit() request */
-
-static void pthread_onexit_process(int retcode, void *arg attribute_unused)
-{
-    struct pthread_request request;
-    pthread_descr self = thread_self();
-
-    if (__pthread_manager_request >= 0) {
-	request.req_thread = self;
-	request.req_kind = REQ_PROCESS_EXIT;
-	request.req_args.exit.code = retcode;
-	TEMP_FAILURE_RETRY(write(__pthread_manager_request,
-		    (char *) &request, sizeof(request)));
-	suspend(self);
-	/* Main thread should accumulate times for thread manager and its
-	   children, so that timings for main thread account for all threads. */
-	if (self == __pthread_main_thread) {
-	    waitpid(__pthread_manager_thread.p_pid, NULL, __WCLONE);
-	    /* Since all threads have been asynchronously terminated
-	     * (possibly holding locks), free cannot be used any more.  */
-	    __pthread_manager_thread_bos = __pthread_manager_thread_tos = NULL;
-	}
-    }
-}
-
-/* The handler for the RESTART signal just records the signal received
-   in the thread descriptor, and optionally performs a siglongjmp
-   (for pthread_cond_timedwait). */
-
-static void pthread_handle_sigrestart(int sig)
-{
-    pthread_descr self = thread_self();
-    THREAD_SETMEM(self, p_signal, sig);
-    if (THREAD_GETMEM(self, p_signal_jmp) != NULL)
-	siglongjmp(*THREAD_GETMEM(self, p_signal_jmp), 1);
-}
-
-/* The handler for the CANCEL signal checks for cancellation
-   (in asynchronous mode), for process-wide exit and exec requests.
-   For the thread manager thread, redirect the signal to
-   __pthread_manager_sighandler. */
-
-static void pthread_handle_sigcancel(int sig)
-{
-  pthread_descr self = thread_self();
-  sigjmp_buf * jmpbuf;
-
-
-  if (self == &__pthread_manager_thread)
-    {
-#ifdef THREAD_SELF
-      /* A new thread might get a cancel signal before it is fully
-	 initialized, so that the thread register might still point to the
-	 manager thread.  Double check that this is really the manager
-	 thread.  */
-      pthread_descr real_self = thread_self_stack();
-      if (real_self == &__pthread_manager_thread)
-	{
-	  __pthread_manager_sighandler(sig);
-	  return;
-	}
-      /* Oops, thread_self() isn't working yet..  */
-      self = real_self;
-# ifdef INIT_THREAD_SELF
-      INIT_THREAD_SELF(self, self->p_nr);
-# endif
-#else
-      __pthread_manager_sighandler(sig);
-      return;
-#endif
-    }
-  if (__builtin_expect (__pthread_exit_requested, 0)) {
-    /* Main thread should accumulate times for thread manager and its
-       children, so that timings for main thread account for all threads. */
-    if (self == __pthread_main_thread) {
-#if defined(USE_TLS) && USE_TLS
-      waitpid(__pthread_manager_thread->p_pid, NULL, __WCLONE);
-#else
-      waitpid(__pthread_manager_thread.p_pid, NULL, __WCLONE);
-#endif
-    }
-    _exit(__pthread_exit_code);
-  }
-  if (__builtin_expect (THREAD_GETMEM(self, p_canceled), 0)
-      && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE) {
-    if (THREAD_GETMEM(self, p_canceltype) == PTHREAD_CANCEL_ASYNCHRONOUS)
-      __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-    jmpbuf = THREAD_GETMEM(self, p_cancel_jmp);
-    if (jmpbuf != NULL) {
-      THREAD_SETMEM(self, p_cancel_jmp, NULL);
-      siglongjmp(*jmpbuf, 1);
-    }
-  }
-}
-
-/* Handler for the DEBUG signal.
-   The debugging strategy is as follows:
-   On reception of a REQ_DEBUG request (sent by new threads created to
-   the thread manager under debugging mode), the thread manager throws
-   __pthread_sig_debug to itself. The debugger (if active) intercepts
-   this signal, takes into account new threads and continue execution
-   of the thread manager by propagating the signal because it doesn't
-   know what it is specifically done for. In the current implementation,
-   the thread manager simply discards it. */
-
-static void pthread_handle_sigdebug(int sig attribute_unused)
-{
-  /* Nothing */
-}
-
-/* Reset the state of the thread machinery after a fork().
-   Close the pipe used for requests and set the main thread to the forked
-   thread.
-   Notice that we can't free the stack segments, as the forked thread
-   may hold pointers into them. */
-
-void __pthread_reset_main_thread(void)
-{
-  pthread_descr self = thread_self();
-
-  if (__pthread_manager_request != -1) {
-    /* Free the thread manager stack */
-    free(__pthread_manager_thread_bos);
-    __pthread_manager_thread_bos = __pthread_manager_thread_tos = NULL;
-    /* Close the two ends of the pipe */
-    close(__pthread_manager_request);
-    close(__pthread_manager_reader);
-    __pthread_manager_request = __pthread_manager_reader = -1;
-  }
-
-  /* Update the pid of the main thread */
-  THREAD_SETMEM(self, p_pid, getpid());
-  /* Make the forked thread the main thread */
-  __pthread_main_thread = self;
-  THREAD_SETMEM(self, p_nextlive, self);
-  THREAD_SETMEM(self, p_prevlive, self);
-  /* Now this thread modifies the global variables.  */
-  THREAD_SETMEM(self, p_errnop, &_errno);
-  THREAD_SETMEM(self, p_h_errnop, &_h_errno);
-}
-
-/* Process-wide exec() request */
-
-void __pthread_kill_other_threads_np(void)
-{
-  struct sigaction sa;
-  /* Terminate all other threads and thread manager */
-  pthread_onexit_process(0, NULL);
-  /* Make current thread the main thread in case the calling thread
-     changes its mind, does not exec(), and creates new threads instead. */
-  __pthread_reset_main_thread();
-  /* Reset the signal handlers behaviour for the signals the
-     implementation uses since this would be passed to the new
-     process.  */
-  memset(&sa, 0, sizeof(sa));
-  if (SIG_DFL) /* if it's constant zero, it's already done */
-    sa.sa_handler = SIG_DFL;
-  __libc_sigaction(__pthread_sig_restart, &sa, NULL);
-  __libc_sigaction(__pthread_sig_cancel, &sa, NULL);
-  if (__pthread_sig_debug > 0)
-    __libc_sigaction(__pthread_sig_debug, &sa, NULL);
-}
-weak_alias (__pthread_kill_other_threads_np, pthread_kill_other_threads_np)
-
-/* Concurrency symbol level.  */
-static int current_level;
-
-int __pthread_setconcurrency(int level)
-{
-  /* We don't do anything unless we have found a useful interpretation.  */
-  current_level = level;
-  return 0;
-}
-weak_alias (__pthread_setconcurrency, pthread_setconcurrency)
-
-int __pthread_getconcurrency(void)
-{
-  return current_level;
-}
-weak_alias (__pthread_getconcurrency, pthread_getconcurrency)
-
-
-/* Primitives for controlling thread execution */
-
-void __pthread_wait_for_restart_signal(pthread_descr self)
-{
-    sigset_t mask;
-
-    sigprocmask(SIG_SETMASK, NULL, &mask); /* Get current signal mask */
-    sigdelset(&mask, __pthread_sig_restart); /* Unblock the restart signal */
-    THREAD_SETMEM(self, p_signal, 0);
-    do {
-	sigsuspend(&mask);                   /* Wait for signal */
-    } while (THREAD_GETMEM(self, p_signal) !=__pthread_sig_restart);
-
-    READ_MEMORY_BARRIER(); /* See comment in __pthread_restart_new */
-}
-
-#ifndef __NR_rt_sigaction
-/* The _old variants are for 2.0 and early 2.1 kernels which don't have RT
-   signals.
-   On these kernels, we use SIGUSR1 and SIGUSR2 for restart and cancellation.
-   Since the restart signal does not queue, we use an atomic counter to create
-   queuing semantics. This is needed to resolve a rare race condition in
-   pthread_cond_timedwait_relative. */
-
-void __pthread_restart_old(pthread_descr th)
-{
-    if (atomic_increment(&th->p_resume_count) == -1)
-	kill(th->p_pid, __pthread_sig_restart);
-}
-
-void __pthread_suspend_old(pthread_descr self)
-{
-    if (atomic_decrement(&self->p_resume_count) <= 0)
-	__pthread_wait_for_restart_signal(self);
-}
-
-int
-__pthread_timedsuspend_old(pthread_descr self, const struct timespec *abstime)
-{
-  sigset_t unblock, initial_mask;
-  int was_signalled = 0;
-  sigjmp_buf jmpbuf;
-
-  if (atomic_decrement(&self->p_resume_count) == 0) {
-    /* Set up a longjmp handler for the restart signal, unblock
-       the signal and sleep. */
-
-    if (sigsetjmp(jmpbuf, 1) == 0) {
-      THREAD_SETMEM(self, p_signal_jmp, &jmpbuf);
-      THREAD_SETMEM(self, p_signal, 0);
-      /* Unblock the restart signal */
-      __sigemptyset(&unblock);
-      sigaddset(&unblock, __pthread_sig_restart);
-      sigprocmask(SIG_UNBLOCK, &unblock, &initial_mask);
-
-      while (1) {
-	struct timeval now;
-	struct timespec reltime;
-
-	/* Compute a time offset relative to now.  */
-	gettimeofday (&now, NULL);
-	reltime.tv_nsec = abstime->tv_nsec - now.tv_usec * 1000;
-	reltime.tv_sec = abstime->tv_sec - now.tv_sec;
-	if (reltime.tv_nsec < 0) {
-	  reltime.tv_nsec += 1000000000;
-	  reltime.tv_sec -= 1;
-	}
-
-	/* Sleep for the required duration. If woken by a signal,
-	   resume waiting as required by Single Unix Specification.  */
-	if (reltime.tv_sec < 0 || nanosleep(&reltime, NULL) == 0)
-	  break;
-      }
-
-      /* Block the restart signal again */
-      sigprocmask(SIG_SETMASK, &initial_mask, NULL);
-      was_signalled = 0;
-    } else {
-      was_signalled = 1;
-    }
-    THREAD_SETMEM(self, p_signal_jmp, NULL);
-  }
-
-  /* Now was_signalled is true if we exited the above code
-     due to the delivery of a restart signal.  In that case,
-     we know we have been dequeued and resumed and that the
-     resume count is balanced.  Otherwise, there are some
-     cases to consider. First, try to bump up the resume count
-     back to zero. If it goes to 1, it means restart() was
-     invoked on this thread. The signal must be consumed
-     and the count bumped down and everything is cool. We
-     can return a 1 to the caller.
-     Otherwise, no restart was delivered yet, so a potential
-     race exists; we return a 0 to the caller which must deal
-     with this race in an appropriate way; for example by
-     atomically removing the thread from consideration for a
-     wakeup---if such a thing fails, it means a restart is
-     being delivered. */
-
-  if (!was_signalled) {
-    if (atomic_increment(&self->p_resume_count) != -1) {
-      __pthread_wait_for_restart_signal(self);
-      atomic_decrement(&self->p_resume_count); /* should be zero now! */
-      /* woke spontaneously and consumed restart signal */
-      return 1;
-    }
-    /* woke spontaneously but did not consume restart---caller must resolve */
-    return 0;
-  }
-  /* woken due to restart signal */
-  return 1;
-}
-#endif /* __NR_rt_sigaction */
-
-
-#ifdef __NR_rt_sigaction
-void __pthread_restart_new(pthread_descr th)
-{
-    /* The barrier is proabably not needed, in which case it still documents
-       our assumptions. The intent is to commit previous writes to shared
-       memory so the woken thread will have a consistent view.  Complementary
-       read barriers are present to the suspend functions. */
-    WRITE_MEMORY_BARRIER();
-    kill(th->p_pid, __pthread_sig_restart);
-}
-
-int __pthread_timedsuspend_new(pthread_descr self, const struct timespec *abstime)
-{
-    sigset_t unblock, initial_mask;
-    int was_signalled = 0;
-    sigjmp_buf jmpbuf;
-
-    if (sigsetjmp(jmpbuf, 1) == 0) {
-	THREAD_SETMEM(self, p_signal_jmp, &jmpbuf);
-	THREAD_SETMEM(self, p_signal, 0);
-	/* Unblock the restart signal */
-	__sigemptyset(&unblock);
-	sigaddset(&unblock, __pthread_sig_restart);
-	sigprocmask(SIG_UNBLOCK, &unblock, &initial_mask);
-
-	while (1) {
-	    struct timeval now;
-	    struct timespec reltime;
-
-	    /* Compute a time offset relative to now.  */
-	    gettimeofday (&now, NULL);
-	    reltime.tv_nsec = abstime->tv_nsec - now.tv_usec * 1000;
-	    reltime.tv_sec = abstime->tv_sec - now.tv_sec;
-	    if (reltime.tv_nsec < 0) {
-		reltime.tv_nsec += 1000000000;
-		reltime.tv_sec -= 1;
-	    }
-
-	    /* Sleep for the required duration. If woken by a signal,
-	       resume waiting as required by Single Unix Specification.  */
-	    if (reltime.tv_sec < 0 || nanosleep(&reltime, NULL) == 0)
-		break;
-	}
-
-	/* Block the restart signal again */
-	sigprocmask(SIG_SETMASK, &initial_mask, NULL);
-	was_signalled = 0;
-    } else {
-	was_signalled = 1;
-    }
-    THREAD_SETMEM(self, p_signal_jmp, NULL);
-
-    /* Now was_signalled is true if we exited the above code
-       due to the delivery of a restart signal.  In that case,
-       everything is cool. We have been removed from whatever
-       we were waiting on by the other thread, and consumed its signal.
-
-       Otherwise we this thread woke up spontaneously, or due to a signal other
-       than restart. This is an ambiguous case  that must be resolved by
-       the caller; the thread is still eligible for a restart wakeup
-       so there is a race. */
-
-    READ_MEMORY_BARRIER(); /* See comment in __pthread_restart_new */
-    return was_signalled;
-}
-#endif
-
-/* Debugging aid */
-
-#ifdef DEBUG_PT
-#include <stdarg.h>
-
-void __pthread_message(char * fmt, ...)
-{
-  char buffer[1024];
-  va_list args;
-  sprintf(buffer, "%05d : ", getpid());
-  va_start(args, fmt);
-  vsnprintf(buffer + 8, sizeof(buffer) - 8, fmt, args);
-  va_end(args);
-  TEMP_FAILURE_RETRY(write(2, buffer, strlen(buffer)));
-}
-
-#endif
-
-
-#ifndef __PIC__
-/* We need a hook to force the cancellation wrappers to be linked in when
-   static libpthread is used.  */
-extern const char __pthread_provide_wrappers;
-static const char *const __pthread_require_wrappers =
-  &__pthread_provide_wrappers;
-#endif
diff --git a/libpthread/linuxthreads.old/queue.h b/libpthread/linuxthreads.old/queue.h
deleted file mode 100644
index 01d18d16e..000000000
--- a/libpthread/linuxthreads.old/queue.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Waiting queues */
-
-/* Waiting queues are represented by lists of thread descriptors
-   linked through their p_nextwaiting field.  The lists are kept
-   sorted by decreasing priority, and then decreasing waiting time. */
-
-static __inline__ void enqueue(pthread_descr * q, pthread_descr th)
-{
-  int prio = th->p_priority;
-  for (; *q != NULL; q = &((*q)->p_nextwaiting)) {
-    if (prio > (*q)->p_priority) {
-      th->p_nextwaiting = *q;
-      *q = th;
-      return;
-    }
-  }
-  *q = th;
-}
-
-static __inline__ pthread_descr dequeue(pthread_descr * q)
-{
-  pthread_descr th;
-  th = *q;
-  if (th != NULL) {
-    *q = th->p_nextwaiting;
-    th->p_nextwaiting = NULL;
-  }
-  return th;
-}
-
-static __inline__ int remove_from_queue(pthread_descr * q, pthread_descr th)
-{
-  for (; *q != NULL; q = &((*q)->p_nextwaiting)) {
-    if (*q == th) {
-      *q = th->p_nextwaiting;
-      th->p_nextwaiting = NULL;
-      return 1;
-    }
-  }
-  return 0;
-}
-
-static __inline__ int queue_is_empty(pthread_descr * q)
-{
-    return *q == NULL;
-}
diff --git a/libpthread/linuxthreads.old/restart.h b/libpthread/linuxthreads.old/restart.h
deleted file mode 100644
index 7d63a7022..000000000
--- a/libpthread/linuxthreads.old/restart.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-#include <signal.h>
-#include <sys/syscall.h>
-#define __ASSUME_REALTIME_SIGNALS defined(__NR_rt_sigaction)
-
-/* Primitives for controlling thread execution */
-
-static __inline__ void restart(pthread_descr th)
-{
-  /* See pthread.c */
-#if __ASSUME_REALTIME_SIGNALS
-  __pthread_restart_new(th);
-#else
-  __pthread_restart(th);
-#endif
-}
-
-static __inline__ void suspend(pthread_descr self)
-{
-  /* See pthread.c */
-#if __ASSUME_REALTIME_SIGNALS
-  __pthread_wait_for_restart_signal(self);
-#else
-  __pthread_suspend(self);
-#endif
-}
-
-static __inline__ int timedsuspend(pthread_descr self,
-		const struct timespec *abstime)
-{
-  /* See pthread.c */
-#if __ASSUME_REALTIME_SIGNALS
-  return __pthread_timedsuspend_new(self, abstime);
-#else
-  return __pthread_timedsuspend(self, abstime);
-#endif
-}
diff --git a/libpthread/linuxthreads.old/rwlock.c b/libpthread/linuxthreads.old/rwlock.c
deleted file mode 100644
index 3ab940261..000000000
--- a/libpthread/linuxthreads.old/rwlock.c
+++ /dev/null
@@ -1,485 +0,0 @@
-/* Read-write lock implementation.
-   Copyright (C) 1998 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Xavier Leroy <Xavier.Leroy@inria.fr>
-   and Ulrich Drepper <drepper@cygnus.com>, 1998.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include <stdlib.h>
-#include "internals.h"
-#include "queue.h"
-#include "spinlock.h"
-#include "restart.h"
-
-/*
- * Check whether the calling thread already owns one or more read locks on the
- * specified lock. If so, return a pointer to the read lock info structure
- * corresponding to that lock.
- */
-
-static pthread_readlock_info *
-rwlock_is_in_list(pthread_descr self, pthread_rwlock_t *rwlock)
-{
-  pthread_readlock_info *info;
-
-  for (info = self->p_readlock_list; info != NULL; info = info->pr_next)
-    {
-      if (info->pr_lock == rwlock)
-	return info;
-    }
-
-  return NULL;
-}
-
-/*
- * Add a new lock to the thread's list of locks for which it has a read lock.
- * A new info node must be allocated for this, which is taken from the thread's
- * free list, or by calling malloc. If malloc fails, a null pointer is
- * returned. Otherwise the lock info structure is initialized and pushed
- * onto the thread's list.
- */
-
-static pthread_readlock_info *
-rwlock_add_to_list(pthread_descr self, pthread_rwlock_t *rwlock)
-{
-  pthread_readlock_info *info = self->p_readlock_free;
-
-  if (info != NULL)
-    self->p_readlock_free = info->pr_next;
-  else
-    info = malloc(sizeof *info);
-
-  if (info == NULL)
-    return NULL;
-
-  info->pr_lock_count = 1;
-  info->pr_lock = rwlock;
-  info->pr_next = self->p_readlock_list;
-  self->p_readlock_list = info;
-
-  return info;
-}
-
-/*
- * If the thread owns a read lock over the given pthread_rwlock_t,
- * and this read lock is tracked in the thread's lock list,
- * this function returns a pointer to the info node in that list.
- * It also decrements the lock count within that node, and if
- * it reaches zero, it removes the node from the list.
- * If nothing is found, it returns a null pointer.
- */
-
-static pthread_readlock_info *
-rwlock_remove_from_list(pthread_descr self, pthread_rwlock_t *rwlock)
-{
-  pthread_readlock_info **pinfo;
-
-  for (pinfo = &self->p_readlock_list; *pinfo != NULL; pinfo = &(*pinfo)->pr_next)
-    {
-      if ((*pinfo)->pr_lock == rwlock)
-	{
-	  pthread_readlock_info *info = *pinfo;
-	  if (--info->pr_lock_count == 0)
-	    *pinfo = info->pr_next;
-	  return info;
-	}
-    }
-
-  return NULL;
-}
-
-/*
- * This function checks whether the conditions are right to place a read lock.
- * It returns 1 if so, otherwise zero. The rwlock's internal lock must be
- * locked upon entry.
- */
-
-static int
-rwlock_can_rdlock(pthread_rwlock_t *rwlock, int have_lock_already)
-{
-  /* Can't readlock; it is write locked. */
-  if (rwlock->__rw_writer != NULL)
-    return 0;
-
-  /* Lock prefers readers; get it. */
-  if (rwlock->__rw_kind == PTHREAD_RWLOCK_PREFER_READER_NP)
-    return 1;
-
-  /* Lock prefers writers, but none are waiting. */
-  if (queue_is_empty(&rwlock->__rw_write_waiting))
-    return 1;
-
-  /* Writers are waiting, but this thread already has a read lock */
-  if (have_lock_already)
-    return 1;
-
-  /* Writers are waiting, and this is a new lock */
-  return 0;
-}
-
-/*
- * This function helps support brain-damaged recursive read locking
- * semantics required by Unix 98, while maintaining write priority.
- * This basically determines whether this thread already holds a read lock
- * already. It returns 1 if so, otherwise it returns 0.
- *
- * If the thread has any ``untracked read locks'' then it just assumes
- * that this lock is among them, just to be safe, and returns 1.
- *
- * Also, if it finds the thread's lock in the list, it sets the pointer
- * referenced by pexisting to refer to the list entry.
- *
- * If the thread has no untracked locks, and the lock is not found
- * in its list, then it is added to the list. If this fails,
- * then *pout_of_mem is set to 1.
- */
-
-static int
-rwlock_have_already(pthread_descr *pself, pthread_rwlock_t *rwlock,
-    pthread_readlock_info **pexisting, int *pout_of_mem)
-{
-  pthread_readlock_info *existing = NULL;
-  int out_of_mem = 0, have_lock_already = 0;
-  pthread_descr self = *pself;
-
-  if (rwlock->__rw_kind == PTHREAD_RWLOCK_PREFER_WRITER_NP)
-    {
-      if (!self)
-	self = thread_self();
-
-      existing = rwlock_is_in_list(self, rwlock);
-
-      if (existing != NULL || self->p_untracked_readlock_count > 0)
-	have_lock_already = 1;
-      else
-	{
-	  existing = rwlock_add_to_list(self, rwlock);
-	  if (existing == NULL)
-	    out_of_mem = 1;
-	}
-    }
-
-  *pout_of_mem = out_of_mem;
-  *pexisting = existing;
-  *pself = self;
-
-  return have_lock_already;
-}
-
-int
-pthread_rwlock_init (pthread_rwlock_t *rwlock,
-		     const pthread_rwlockattr_t *attr)
-{
-  __pthread_init_lock(&rwlock->__rw_lock);
-  rwlock->__rw_readers = 0;
-  rwlock->__rw_writer = NULL;
-  rwlock->__rw_read_waiting = NULL;
-  rwlock->__rw_write_waiting = NULL;
-
-  if (attr == NULL)
-    {
-      rwlock->__rw_kind = PTHREAD_RWLOCK_DEFAULT_NP;
-      rwlock->__rw_pshared = PTHREAD_PROCESS_PRIVATE;
-    }
-  else
-    {
-      rwlock->__rw_kind = attr->__lockkind;
-      rwlock->__rw_pshared = attr->__pshared;
-    }
-
-  return 0;
-}
-
-
-int
-pthread_rwlock_destroy (pthread_rwlock_t *rwlock)
-{
-  int readers;
-  _pthread_descr writer;
-
-  __pthread_lock (&rwlock->__rw_lock, NULL);
-  readers = rwlock->__rw_readers;
-  writer = rwlock->__rw_writer;
-  __pthread_unlock (&rwlock->__rw_lock);
-
-  if (readers > 0 || writer != NULL)
-    return EBUSY;
-
-  return 0;
-}
-
-int
-pthread_rwlock_rdlock (pthread_rwlock_t *rwlock)
-{
-  pthread_descr self = NULL;
-  pthread_readlock_info *existing;
-  int out_of_mem, have_lock_already;
-
-  have_lock_already = rwlock_have_already(&self, rwlock,
-      &existing, &out_of_mem);
-
-  for (;;)
-    {
-      if (self == NULL)
-	self = thread_self ();
-
-      __pthread_lock (&rwlock->__rw_lock, self);
-
-      if (rwlock_can_rdlock(rwlock, have_lock_already))
-	break;
-
-      enqueue (&rwlock->__rw_read_waiting, self);
-      __pthread_unlock (&rwlock->__rw_lock);
-      suspend (self); /* This is not a cancellation point */
-    }
-
-  ++rwlock->__rw_readers;
-  __pthread_unlock (&rwlock->__rw_lock);
-
-  if (have_lock_already || out_of_mem)
-    {
-      if (existing != NULL)
-	existing->pr_lock_count++;
-      else
-	self->p_untracked_readlock_count++;
-    }
-
-  return 0;
-}
-
-int
-pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock)
-{
-  pthread_descr self = thread_self();
-  pthread_readlock_info *existing;
-  int out_of_mem, have_lock_already;
-  int retval = EBUSY;
-
-  have_lock_already = rwlock_have_already(&self, rwlock,
-      &existing, &out_of_mem);
-
-  __pthread_lock (&rwlock->__rw_lock, self);
-
-  /* 0 is passed to here instead of have_lock_already.
-     This is to meet Single Unix Spec requirements:
-     if writers are waiting, pthread_rwlock_tryrdlock
-     does not acquire a read lock, even if the caller has
-     one or more read locks already. */
-
-  if (rwlock_can_rdlock(rwlock, 0))
-    {
-      ++rwlock->__rw_readers;
-      retval = 0;
-    }
-
-  __pthread_unlock (&rwlock->__rw_lock);
-
-  if (retval == 0)
-    {
-      if (have_lock_already || out_of_mem)
-	{
-	  if (existing != NULL)
-	    existing->pr_lock_count++;
-	  else
-	    self->p_untracked_readlock_count++;
-	}
-    }
-
-  return retval;
-}
-
-
-int
-pthread_rwlock_wrlock (pthread_rwlock_t *rwlock)
-{
-  pthread_descr self = thread_self ();
-
-  while(1)
-    {
-      __pthread_lock (&rwlock->__rw_lock, self);
-      if (rwlock->__rw_readers == 0 && rwlock->__rw_writer == NULL)
-	{
-	  rwlock->__rw_writer = self;
-	  __pthread_unlock (&rwlock->__rw_lock);
-	  return 0;
-	}
-
-      /* Suspend ourselves, then try again */
-      enqueue (&rwlock->__rw_write_waiting, self);
-      __pthread_unlock (&rwlock->__rw_lock);
-      suspend (self); /* This is not a cancellation point */
-    }
-}
-
-
-int
-pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock)
-{
-  int result = EBUSY;
-
-  __pthread_lock (&rwlock->__rw_lock, NULL);
-  if (rwlock->__rw_readers == 0 && rwlock->__rw_writer == NULL)
-    {
-      rwlock->__rw_writer = thread_self ();
-      result = 0;
-    }
-  __pthread_unlock (&rwlock->__rw_lock);
-
-  return result;
-}
-
-
-int
-pthread_rwlock_unlock (pthread_rwlock_t *rwlock)
-{
-  pthread_descr torestart;
-  pthread_descr th;
-
-  __pthread_lock (&rwlock->__rw_lock, NULL);
-  if (rwlock->__rw_writer != NULL)
-    {
-      /* Unlocking a write lock.  */
-      if (rwlock->__rw_writer != thread_self ())
-	{
-	  __pthread_unlock (&rwlock->__rw_lock);
-	  return EPERM;
-	}
-      rwlock->__rw_writer = NULL;
-
-      if (rwlock->__rw_kind == PTHREAD_RWLOCK_PREFER_READER_NP
-	  || (th = dequeue (&rwlock->__rw_write_waiting)) == NULL)
-	{
-	  /* Restart all waiting readers.  */
-	  torestart = rwlock->__rw_read_waiting;
-	  rwlock->__rw_read_waiting = NULL;
-	  __pthread_unlock (&rwlock->__rw_lock);
-	  while ((th = dequeue (&torestart)) != NULL)
-	    restart (th);
-	}
-      else
-	{
-	  /* Restart one waiting writer.  */
-	  __pthread_unlock (&rwlock->__rw_lock);
-	  restart (th);
-	}
-    }
-  else
-    {
-      /* Unlocking a read lock.  */
-      if (rwlock->__rw_readers == 0)
-	{
-	  __pthread_unlock (&rwlock->__rw_lock);
-	  return EPERM;
-	}
-
-      --rwlock->__rw_readers;
-      if (rwlock->__rw_readers == 0)
-	/* Restart one waiting writer, if any.  */
-	th = dequeue (&rwlock->__rw_write_waiting);
-      else
-	th = NULL;
-
-      __pthread_unlock (&rwlock->__rw_lock);
-      if (th != NULL)
-	restart (th);
-
-      /* Recursive lock fixup */
-
-      if (rwlock->__rw_kind == PTHREAD_RWLOCK_PREFER_WRITER_NP)
-	{
-	  pthread_descr self = thread_self();
-	  pthread_readlock_info *victim = rwlock_remove_from_list(self, rwlock);
-
-	  if (victim != NULL)
-	    {
-	      if (victim->pr_lock_count == 0)
-		{
-		  victim->pr_next = self->p_readlock_free;
-		  self->p_readlock_free = victim;
-		}
-	    }
-	  else
-	    {
-	      if (self->p_untracked_readlock_count > 0)
-		self->p_untracked_readlock_count--;
-	    }
-	}
-    }
-
-  return 0;
-}
-
-
-
-int
-pthread_rwlockattr_init (pthread_rwlockattr_t *attr)
-{
-  attr->__lockkind = 0;
-  attr->__pshared = 0;
-
-  return 0;
-}
-
-
-int
-pthread_rwlockattr_destroy (pthread_rwlockattr_t *attr attribute_unused)
-{
-  return 0;
-}
-
-
-int
-pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr, int *pshared)
-{
-  *pshared = attr->__pshared;
-  return 0;
-}
-
-
-int
-pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int pshared)
-{
-  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
-    return EINVAL;
-
-  attr->__pshared = pshared;
-
-  return 0;
-}
-
-
-int
-pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *attr, int *pref)
-{
-  *pref = attr->__lockkind;
-  return 0;
-}
-
-
-int
-pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *attr, int pref)
-{
-  if (pref != PTHREAD_RWLOCK_PREFER_READER_NP
-      && pref != PTHREAD_RWLOCK_PREFER_WRITER_NP
-      && pref != PTHREAD_RWLOCK_DEFAULT_NP)
-    return EINVAL;
-
-  attr->__lockkind = pref;
-
-  return 0;
-}
diff --git a/libpthread/linuxthreads.old/semaphore.c b/libpthread/linuxthreads.old/semaphore.c
deleted file mode 100644
index 9025dfee6..000000000
--- a/libpthread/linuxthreads.old/semaphore.c
+++ /dev/null
@@ -1,299 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Semaphores a la POSIX 1003.1b */
-
-#include <features.h>
-#include <limits.h>
-#include <errno.h>
-#include "pthread.h"
-#include "semaphore.h"
-#include "internals.h"
-#include "spinlock.h"
-#include "restart.h"
-#include "queue.h"
-
-int sem_init(sem_t *sem, int pshared, unsigned int value)
-{
-  if (value > SEM_VALUE_MAX) {
-    errno = EINVAL;
-    return -1;
-  }
-  if (pshared) {
-    errno = ENOSYS;
-    return -1;
-  }
-  __pthread_init_lock(&sem->__sem_lock);
-  sem->__sem_value = value;
-  sem->__sem_waiting = NULL;
-  return 0;
-}
-
-/* Function called by pthread_cancel to remove the thread from
-   waiting inside sem_wait. */
-
-static int new_sem_extricate_func(void *obj, pthread_descr th)
-{
-  volatile pthread_descr self = thread_self();
-  sem_t *sem = obj;
-  int did_remove = 0;
-
-  __pthread_lock(&sem->__sem_lock, self);
-  did_remove = remove_from_queue(&sem->__sem_waiting, th);
-  __pthread_unlock(&sem->__sem_lock);
-
-  return did_remove;
-}
-
-int sem_wait(sem_t * sem)
-{
-  volatile pthread_descr self = thread_self();
-  pthread_extricate_if extr;
-  int already_canceled = 0;
-  int spurious_wakeup_count;
-
-  /* Set up extrication interface */
-  extr.pu_object = sem;
-  extr.pu_extricate_func = new_sem_extricate_func;
-
-  __pthread_lock(&sem->__sem_lock, self);
-  if (sem->__sem_value > 0) {
-    sem->__sem_value--;
-    __pthread_unlock(&sem->__sem_lock);
-    return 0;
-  }
-  /* Register extrication interface */
-  THREAD_SETMEM(self, p_sem_avail, 0);
-  __pthread_set_own_extricate_if(self, &extr);
-  /* Enqueue only if not already cancelled. */
-  if (!(THREAD_GETMEM(self, p_canceled)
-      && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE))
-    enqueue(&sem->__sem_waiting, self);
-  else
-    already_canceled = 1;
-  __pthread_unlock(&sem->__sem_lock);
-
-  if (already_canceled) {
-    __pthread_set_own_extricate_if(self, 0);
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-  }
-
-  /* Wait for sem_post or cancellation, or fall through if already canceled */
-  spurious_wakeup_count = 0;
-  while (1)
-    {
-      suspend(self);
-      if (THREAD_GETMEM(self, p_sem_avail) == 0
-	  && (THREAD_GETMEM(self, p_woken_by_cancel) == 0
-	      || THREAD_GETMEM(self, p_cancelstate) != PTHREAD_CANCEL_ENABLE))
-	{
-	  /* Count resumes that don't belong to us. */
-	  spurious_wakeup_count++;
-	  continue;
-	}
-      break;
-    }
-  __pthread_set_own_extricate_if(self, 0);
-
-  /* Terminate only if the wakeup came from cancellation. */
-  /* Otherwise ignore cancellation because we got the semaphore. */
-
-  if (THREAD_GETMEM(self, p_woken_by_cancel)
-      && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE) {
-    THREAD_SETMEM(self, p_woken_by_cancel, 0);
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-  }
-  /* We got the semaphore */
-  return 0;
-}
-
-int sem_trywait(sem_t * sem)
-{
-  int retval;
-
-  __pthread_lock(&sem->__sem_lock, NULL);
-  if (sem->__sem_value == 0) {
-    errno = EAGAIN;
-    retval = -1;
-  } else {
-    sem->__sem_value--;
-    retval = 0;
-  }
-  __pthread_unlock(&sem->__sem_lock);
-  return retval;
-}
-
-int sem_post(sem_t * sem)
-{
-  pthread_descr self = thread_self();
-  pthread_descr th;
-  struct pthread_request request;
-
-  if (THREAD_GETMEM(self, p_in_sighandler) == NULL) {
-    __pthread_lock(&sem->__sem_lock, self);
-    if (sem->__sem_waiting == NULL) {
-      if (sem->__sem_value >= SEM_VALUE_MAX) {
-        /* Overflow */
-        errno = ERANGE;
-        __pthread_unlock(&sem->__sem_lock);
-        return -1;
-      }
-      sem->__sem_value++;
-      __pthread_unlock(&sem->__sem_lock);
-    } else {
-      th = dequeue(&sem->__sem_waiting);
-      __pthread_unlock(&sem->__sem_lock);
-      th->p_sem_avail = 1;
-      WRITE_MEMORY_BARRIER();
-      restart(th);
-    }
-  } else {
-    /* If we're in signal handler, delegate post operation to
-       the thread manager. */
-    if (__pthread_manager_request < 0) {
-      if (__pthread_initialize_manager() < 0) {
-        errno = EAGAIN;
-        return -1;
-      }
-    }
-    request.req_kind = REQ_POST;
-    request.req_args.post = sem;
-    TEMP_FAILURE_RETRY(write(__pthread_manager_request,
-				    (char *) &request, sizeof(request)));
-  }
-  return 0;
-}
-
-int sem_getvalue(sem_t * sem, int * sval)
-{
-  *sval = sem->__sem_value;
-  return 0;
-}
-
-int sem_destroy(sem_t * sem)
-{
-  if (sem->__sem_waiting != NULL) {
-    __set_errno (EBUSY);
-    return -1;
-  }
-  return 0;
-}
-
-sem_t *sem_open(const char *name attribute_unused, int oflag attribute_unused, ...)
-{
-  __set_errno (ENOSYS);
-  return SEM_FAILED;
-}
-
-int sem_close(sem_t *sem attribute_unused)
-{
-  __set_errno (ENOSYS);
-  return -1;
-}
-
-int sem_unlink(const char *name attribute_unused)
-{
-  __set_errno (ENOSYS);
-  return -1;
-}
-
-int sem_timedwait(sem_t *sem, const struct timespec *abstime)
-{
-  pthread_descr self = thread_self();
-  pthread_extricate_if extr;
-  int already_canceled = 0;
-  int spurious_wakeup_count;
-
-  __pthread_lock(&sem->__sem_lock, self);
-  if (sem->__sem_value > 0) {
-    --sem->__sem_value;
-    __pthread_unlock(&sem->__sem_lock);
-    return 0;
-  }
-
-  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000) {
-    /* The standard requires that if the function would block and the
-       time value is illegal, the function returns with an error.  */
-    __pthread_unlock(&sem->__sem_lock);
-    __set_errno (EINVAL);
-    return -1;
-  }
-
-  /* Set up extrication interface */
-  extr.pu_object = sem;
-  extr.pu_extricate_func = new_sem_extricate_func;
-
-  /* Register extrication interface */
-  THREAD_SETMEM(self, p_sem_avail, 0);
-  __pthread_set_own_extricate_if(self, &extr);
-  /* Enqueue only if not already cancelled. */
-  if (!(THREAD_GETMEM(self, p_canceled)
-      && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE))
-    enqueue(&sem->__sem_waiting, self);
-  else
-    already_canceled = 1;
-  __pthread_unlock(&sem->__sem_lock);
-
-  if (already_canceled) {
-    __pthread_set_own_extricate_if(self, 0);
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-  }
-
-  spurious_wakeup_count = 0;
-  while (1)
-    {
-      if (timedsuspend(self, abstime) == 0) {
-	int was_on_queue;
-
-	/* __pthread_lock will queue back any spurious restarts that
-	   may happen to it. */
-
-	__pthread_lock(&sem->__sem_lock, self);
-	was_on_queue = remove_from_queue(&sem->__sem_waiting, self);
-	__pthread_unlock(&sem->__sem_lock);
-
-	if (was_on_queue) {
-	  __pthread_set_own_extricate_if(self, 0);
-	  __set_errno (ETIMEDOUT);
-	  return -1;
-	}
-
-	/* Eat the outstanding restart() from the signaller */
-	suspend(self);
-      }
-
-      if (THREAD_GETMEM(self, p_sem_avail) == 0
-	  && (THREAD_GETMEM(self, p_woken_by_cancel) == 0
-	      || THREAD_GETMEM(self, p_cancelstate) != PTHREAD_CANCEL_ENABLE))
-	{
-	  /* Count resumes that don't belong to us. */
-	  spurious_wakeup_count++;
-	  continue;
-	}
-      break;
-    }
-
- __pthread_set_own_extricate_if(self, 0);
-
-  /* Terminate only if the wakeup came from cancellation. */
-  /* Otherwise ignore cancellation because we got the semaphore. */
-
-  if (THREAD_GETMEM(self, p_woken_by_cancel)
-      && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE) {
-    THREAD_SETMEM(self, p_woken_by_cancel, 0);
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-  }
-  /* We got the semaphore */
-  return 0;
-}
diff --git a/libpthread/linuxthreads.old/semaphore.h b/libpthread/linuxthreads.old/semaphore.h
deleted file mode 100644
index 9a9b72c9e..000000000
--- a/libpthread/linuxthreads.old/semaphore.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-#ifndef _SEMAPHORE_H
-#define _SEMAPHORE_H	1
-
-#include <features.h>
-#include <sys/types.h>
-#include <limits.h>
-#ifdef __USE_XOPEN2K
-# define __need_timespec
-# include <time.h>
-#endif
-
-#ifndef _PTHREAD_DESCR_DEFINED
-/* Thread descriptors.  Needed for `sem_t' definition.  */
-typedef struct _pthread_descr_struct *_pthread_descr;
-# define _PTHREAD_DESCR_DEFINED
-#endif
-
-/* System specific semaphore definition.  */
-typedef struct
-{
-  struct _pthread_fastlock __sem_lock;
-  int __sem_value;
-  _pthread_descr __sem_waiting;
-} sem_t;
-
-
-
-/* Value returned if `sem_open' failed.  */
-#define SEM_FAILED	((sem_t *) 0)
-
-/* Maximum value the semaphore can have.  */
-#ifndef SEM_VALUE_MAX
-#define SEM_VALUE_MAX	((int) ((~0u) >> 1))
-#endif
-
-
-__BEGIN_DECLS
-
-/* Initialize semaphore object SEM to VALUE.  If PSHARED then share it
-   with other processes.  */
-extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value) __THROW;
-
-/* Free resources associated with semaphore object SEM.  */
-extern int sem_destroy (sem_t *__sem) __THROW;
-
-/* Open a named semaphore NAME with open flags OFLAG.  */
-extern sem_t *sem_open (const char *__name, int __oflag, ...) __THROW;
-
-/* Close descriptor for named semaphore SEM.  */
-extern int sem_close (sem_t *__sem) __THROW;
-
-/* Remove named semaphore NAME.  */
-extern int sem_unlink (const char *__name) __THROW;
-
-/* Wait for SEM being posted.
-
-   This function is a cancellation point and therefore not marked with
-   __THROW.  */
-extern int sem_wait (sem_t *__sem);
-
-#ifdef __USE_XOPEN2K
-/* Similar to `sem_wait' but wait only until ABSTIME.
-
-   This function is a cancellation point and therefore not marked with
-   __THROW.  */
-extern int sem_timedwait (sem_t *__restrict __sem,
-			  const struct timespec *__restrict __abstime);
-#endif
-
-/* Test whether SEM is posted.  */
-extern int sem_trywait (sem_t *__sem) __THROW;
-
-/* Post SEM.  */
-extern int sem_post (sem_t *__sem) __THROW;
-
-/* Get current value of SEM and store it in *SVAL.  */
-extern int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval)
-     __THROW;
-
-
-__END_DECLS
-
-#endif	/* semaphore.h */
diff --git a/libpthread/linuxthreads.old/signals.c b/libpthread/linuxthreads.old/signals.c
deleted file mode 100644
index d8dbc78bd..000000000
--- a/libpthread/linuxthreads.old/signals.c
+++ /dev/null
@@ -1,246 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Handling of signals */
-
-#include <errno.h>
-#include <signal.h>
-#include <stdio.h>
-#include "pthread.h"
-#include "internals.h"
-#include "spinlock.h"
-#include <bits/sigcontextinfo.h>
-
-int pthread_sigmask(int how, const sigset_t * newmask, sigset_t * oldmask)
-{
-  sigset_t mask;
-
-  if (newmask != NULL) {
-    mask = *newmask;
-    /* Don't allow __pthread_sig_restart to be unmasked.
-       Don't allow __pthread_sig_cancel to be masked. */
-    switch(how) {
-    case SIG_SETMASK:
-      sigaddset(&mask, __pthread_sig_restart);
-      sigdelset(&mask, __pthread_sig_cancel);
-      if (__pthread_sig_debug > 0)
-	sigdelset(&mask, __pthread_sig_debug);
-      break;
-    case SIG_BLOCK:
-      sigdelset(&mask, __pthread_sig_cancel);
-      if (__pthread_sig_debug > 0)
-	sigdelset(&mask, __pthread_sig_debug);
-      break;
-    case SIG_UNBLOCK:
-      sigdelset(&mask, __pthread_sig_restart);
-      break;
-    }
-    newmask = &mask;
-  }
-  if (sigprocmask(how, newmask, oldmask) == -1)
-    return errno;
-  else
-    return 0;
-}
-
-int pthread_kill(pthread_t thread, int signo)
-{
-  pthread_handle handle = thread_handle(thread);
-  int pid;
-
-  __pthread_lock(&handle->h_lock, NULL);
-  if (invalid_handle(handle, thread)) {
-    __pthread_unlock(&handle->h_lock);
-    return ESRCH;
-  }
-  pid = handle->h_descr->p_pid;
-  __pthread_unlock(&handle->h_lock);
-  if (kill(pid, signo) == -1)
-    return errno;
-  else
-    return 0;
-}
-
-/* User-provided signal handlers */
-typedef void (*arch_sighandler_t) __PMT ((int, SIGCONTEXT));
-static union
-{
-  arch_sighandler_t old;
-  void (*rt) (int, struct siginfo *, struct ucontext *);
-} sighandler[NSIG];
-
-/* The wrapper around user-provided signal handlers */
-static void pthread_sighandler(int signo, SIGCONTEXT ctx)
-{
-  pthread_descr self = thread_self();
-  char * in_sighandler;
-  /* If we're in a sigwait operation, just record the signal received
-     and return without calling the user's handler */
-  if (THREAD_GETMEM(self, p_sigwaiting)) {
-    THREAD_SETMEM(self, p_sigwaiting, 0);
-    THREAD_SETMEM(self, p_signal, signo);
-    return;
-  }
-  /* Record that we're in a signal handler and call the user's
-     handler function */
-  in_sighandler = THREAD_GETMEM(self, p_in_sighandler);
-  if (in_sighandler == NULL)
-    THREAD_SETMEM(self, p_in_sighandler, CURRENT_STACK_FRAME);
-  sighandler[signo].old(signo, SIGCONTEXT_EXTRA_ARGS ctx);
-  if (in_sighandler == NULL)
-    THREAD_SETMEM(self, p_in_sighandler, NULL);
-}
-
-/* The same, this time for real-time signals.  */
-static void pthread_sighandler_rt(int signo, struct siginfo *si,
-				  struct ucontext *uc)
-{
-  pthread_descr self = thread_self();
-  char * in_sighandler;
-  /* If we're in a sigwait operation, just record the signal received
-     and return without calling the user's handler */
-  if (THREAD_GETMEM(self, p_sigwaiting)) {
-    THREAD_SETMEM(self, p_sigwaiting, 0);
-    THREAD_SETMEM(self, p_signal, signo);
-    return;
-  }
-  /* Record that we're in a signal handler and call the user's
-     handler function */
-  in_sighandler = THREAD_GETMEM(self, p_in_sighandler);
-  if (in_sighandler == NULL)
-    THREAD_SETMEM(self, p_in_sighandler, CURRENT_STACK_FRAME);
-  sighandler[signo].rt(signo, si, uc);
-  if (in_sighandler == NULL)
-    THREAD_SETMEM(self, p_in_sighandler, NULL);
-}
-
-/* The wrapper around sigaction.  Install our own signal handler
-   around the signal. */
-libpthread_hidden_proto(sigaction)
-int sigaction(int sig, const struct sigaction * act,
-              struct sigaction * oact)
-{
-  struct sigaction newact;
-  struct sigaction *newactp;
-
-#ifdef DEBUG_PT
-printf(__FUNCTION__": pthreads wrapper!\n");
-#endif
-  if (sig == __pthread_sig_restart ||
-      sig == __pthread_sig_cancel ||
-      (sig == __pthread_sig_debug && __pthread_sig_debug > 0))
-    return EINVAL;
-  if (act)
-    {
-      newact = *act;
-      if (act->sa_handler != SIG_IGN && act->sa_handler != SIG_DFL
-	  && sig > 0 && sig < NSIG)
-	{
-	  if (act->sa_flags & SA_SIGINFO)
-	    newact.sa_handler = (__sighandler_t) pthread_sighandler_rt;
-	  else
-	    newact.sa_handler = (__sighandler_t) pthread_sighandler;
-	}
-      newactp = &newact;
-    }
-  else
-    newactp = NULL;
-  if (__libc_sigaction(sig, newactp, oact) == -1)
-    return -1;
-#ifdef DEBUG_PT
-printf(__FUNCTION__": sighandler installed, sigaction successful\n");
-#endif
-  if (sig > 0 && sig < NSIG)
-    {
-      if (oact != NULL)
-	oact->sa_handler = (__sighandler_t) sighandler[sig].old;
-      if (act)
-	/* For the assignment is does not matter whether it's a normal
-	   or real-time signal.  */
-	sighandler[sig].old = (arch_sighandler_t) act->sa_handler;
-    }
-  return 0;
-}
-libpthread_hidden_def(sigaction)
-
-/* A signal handler that does nothing */
-static void pthread_null_sighandler(int sig attribute_unused) { }
-
-/* sigwait -- synchronously wait for a signal */
-int sigwait(const sigset_t * set, int * sig)
-{
-  volatile pthread_descr self = thread_self();
-  sigset_t mask;
-  int s;
-  sigjmp_buf jmpbuf;
-  struct sigaction sa;
-
-  /* Get ready to block all signals except those in set
-     and the cancellation signal.
-     Also check that handlers are installed on all signals in set,
-     and if not, install our dummy handler.  This is conformant to
-     POSIX: "The effect of sigwait() on the signal actions for the
-     signals in set is unspecified." */
-  __sigfillset(&mask);
-  sigdelset(&mask, __pthread_sig_cancel);
-  for (s = 1; s <= NSIG; s++) {
-    if (sigismember(set, s) &&
-        s != __pthread_sig_restart &&
-        s != __pthread_sig_cancel &&
-        s != __pthread_sig_debug) {
-      sigdelset(&mask, s);
-      if (sighandler[s].old == NULL ||
-	  sighandler[s].old == (arch_sighandler_t) SIG_DFL ||
-	  sighandler[s].old == (arch_sighandler_t) SIG_IGN) {
-        memset(&sa, 0, sizeof(sa));
-        sa.sa_handler = pthread_null_sighandler;
-        sigaction(s, &sa, NULL);
-      }
-    }
-  }
-  /* Test for cancellation */
-  if (sigsetjmp(jmpbuf, 1) == 0) {
-    THREAD_SETMEM(self, p_cancel_jmp, &jmpbuf);
-    if (! (THREAD_GETMEM(self, p_canceled)
-	   && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE)) {
-      /* Reset the signal count */
-      THREAD_SETMEM(self, p_signal, 0);
-      /* Say we're in sigwait */
-      THREAD_SETMEM(self, p_sigwaiting, 1);
-      /* Unblock the signals and wait for them */
-      sigsuspend(&mask);
-    }
-  }
-  THREAD_SETMEM(self, p_cancel_jmp, NULL);
-  /* The signals are now reblocked.  Check for cancellation */
-  pthread_testcancel();
-  /* We should have self->p_signal != 0 and equal to the signal received */
-  *sig = THREAD_GETMEM(self, p_signal);
-  return 0;
-}
-
-/* Redefine raise() to send signal to calling thread only,
-   as per POSIX 1003.1c */
-libpthread_hidden_proto(raise)
-int raise (int sig)
-{
-  int retcode = pthread_kill(pthread_self(), sig);
-  if (retcode == 0)
-    return 0;
-  else {
-    errno = retcode;
-    return -1;
-  }
-}
-libpthread_hidden_def(raise)
diff --git a/libpthread/linuxthreads.old/specific.c b/libpthread/linuxthreads.old/specific.c
deleted file mode 100644
index c4bcfbf8c..000000000
--- a/libpthread/linuxthreads.old/specific.c
+++ /dev/null
@@ -1,198 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Thread-specific data */
-
-#include <features.h>
-#include <errno.h>
-#include <stddef.h>
-#include <stdlib.h>
-#include "pthread.h"
-#include "internals.h"
-#include "spinlock.h"
-#include "restart.h"
-
-/* Table of keys. */
-
-static struct pthread_key_struct pthread_keys[PTHREAD_KEYS_MAX] =
-  { { 0, NULL } };
-
-/* For debugging purposes put the maximum number of keys in a variable.  */
-const int __linuxthreads_pthread_keys_max = PTHREAD_KEYS_MAX;
-const int __linuxthreads_pthread_key_2ndlevel_size = PTHREAD_KEY_2NDLEVEL_SIZE;
-
-/* Mutex to protect access to pthread_keys */
-
-static pthread_mutex_t pthread_keys_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-/* Create a new key */
-
-int pthread_key_create(pthread_key_t * key, destr_function destr)
-{
-  int i;
-
-  __pthread_mutex_lock(&pthread_keys_mutex);
-  for (i = 0; i < PTHREAD_KEYS_MAX; i++) {
-    if (! pthread_keys[i].in_use) {
-      /* Mark key in use */
-      pthread_keys[i].in_use = 1;
-      pthread_keys[i].destr = destr;
-      __pthread_mutex_unlock(&pthread_keys_mutex);
-      *key = i;
-      return 0;
-    }
-  }
-  __pthread_mutex_unlock(&pthread_keys_mutex);
-  return EAGAIN;
-}
-
-/* Delete a key */
-int pthread_key_delete(pthread_key_t key)
-{
-    pthread_descr self = thread_self();
-
-    __pthread_mutex_lock(&pthread_keys_mutex);
-    if (key >= PTHREAD_KEYS_MAX || !pthread_keys[key].in_use) {
-	__pthread_mutex_unlock(&pthread_keys_mutex);
-	return EINVAL;
-    }
-    pthread_keys[key].in_use = 0;
-    pthread_keys[key].destr = NULL;
-
-    /* Set the value of the key to NULL in all running threads, so
-       that if the key is reallocated later by pthread_key_create, its
-       associated values will be NULL in all threads.
-       Do nothing if no threads have been created yet.  */
-    if (__pthread_manager_request != -1)
-    {
-	pthread_descr th;
-	unsigned int idx1st, idx2nd;
-
-	idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;
-	idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;
-	th = self;
-	do {
-	    /* If the thread already is terminated don't modify the memory.  */
-	    if (!th->p_terminated && th->p_specific[idx1st] != NULL)
-		th->p_specific[idx1st][idx2nd] = NULL;
-	    th = th->p_nextlive;
-	} while (th != self);
-    }
-
-    __pthread_mutex_unlock(&pthread_keys_mutex);
-    return 0;
-}
-
-/* Set the value of a key */
-
-int pthread_setspecific(pthread_key_t key, const void * pointer)
-{
-    pthread_descr self = thread_self();
-    unsigned int idx1st, idx2nd;
-
-    if (key >= PTHREAD_KEYS_MAX || !pthread_keys[key].in_use)
-	return EINVAL;
-    idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;
-    idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;
-    if (THREAD_GETMEM_NC(self, p_specific[idx1st]) == NULL) {
-	void *newp = calloc(PTHREAD_KEY_2NDLEVEL_SIZE, sizeof (void *));
-	if (newp == NULL)
-	    return ENOMEM;
-	THREAD_SETMEM_NC(self, p_specific[idx1st], newp);
-    }
-    THREAD_GETMEM_NC(self, p_specific[idx1st])[idx2nd] = (void *) pointer;
-    return 0;
-}
-
-/* Get the value of a key */
-
-void * pthread_getspecific(pthread_key_t key)
-{
-    pthread_descr self = thread_self();
-    unsigned int idx1st, idx2nd;
-
-    if (key >= PTHREAD_KEYS_MAX)
-	return NULL;
-    idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;
-    idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;
-    if (THREAD_GETMEM_NC(self, p_specific[idx1st]) == NULL
-	    || !pthread_keys[key].in_use)
-	return NULL;
-    return THREAD_GETMEM_NC(self, p_specific[idx1st])[idx2nd];
-}
-
-/* Call the destruction routines on all keys */
-
-void __pthread_destroy_specifics(void)
-{
-    pthread_descr self = thread_self();
-    int i, j, round, found_nonzero;
-    destr_function destr;
-    void * data;
-
-    for (round = 0, found_nonzero = 1;
-	    found_nonzero && round < PTHREAD_DESTRUCTOR_ITERATIONS;
-	    round++) {
-	found_nonzero = 0;
-	for (i = 0; i < PTHREAD_KEY_1STLEVEL_SIZE; i++)
-	    if (THREAD_GETMEM_NC(self, p_specific[i]) != NULL)
-		for (j = 0; j < PTHREAD_KEY_2NDLEVEL_SIZE; j++) {
-		    destr = pthread_keys[i * PTHREAD_KEY_2NDLEVEL_SIZE + j].destr;
-		    data = THREAD_GETMEM_NC(self, p_specific[i])[j];
-		    if (destr != NULL && data != NULL) {
-			THREAD_GETMEM_NC(self, p_specific[i])[j] = NULL;
-			destr(data);
-			found_nonzero = 1;
-		    }
-		}
-    }
-    __pthread_lock(THREAD_GETMEM(self, p_lock), self);
-    for (i = 0; i < PTHREAD_KEY_1STLEVEL_SIZE; i++) {
-	if (THREAD_GETMEM_NC(self, p_specific[i]) != NULL) {
-	    free(THREAD_GETMEM_NC(self, p_specific[i]));
-	    THREAD_SETMEM_NC(self, p_specific[i], NULL);
-	}
-    }
-    __pthread_unlock(THREAD_GETMEM(self, p_lock));
-}
-
-#if !defined __UCLIBC_HAS_TLS__ && defined __UCLIBC_HAS_RPC__
-
-/* Thread-specific data for libc. */
-
-int
-__pthread_internal_tsd_set (int key, const void * pointer)
-{
-  pthread_descr self = thread_self();
-
-  THREAD_SETMEM_NC(self, p_libc_specific[key], (void *) pointer);
-  return 0;
-}
-
-void *
-__pthread_internal_tsd_get (int key)
-{
-  pthread_descr self = thread_self();
-
-  return THREAD_GETMEM_NC(self, p_libc_specific[key]);
-}
-
-void ** __attribute__ ((__const__))
-__pthread_internal_tsd_address (int key)
-{
-  pthread_descr self = thread_self();
-  return &self->p_libc_specific[key];
-}
-
-#endif
diff --git a/libpthread/linuxthreads.old/spinlock.c b/libpthread/linuxthreads.old/spinlock.c
deleted file mode 100644
index 80aeda529..000000000
--- a/libpthread/linuxthreads.old/spinlock.c
+++ /dev/null
@@ -1,720 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1998 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Internal locks */
-
-#include <errno.h>
-#include <sched.h>
-#include <time.h>
-#include <stdlib.h>
-#include <limits.h>
-#include "pthread.h"
-#include "internals.h"
-#include "spinlock.h"
-#include "restart.h"
-
-libpthread_hidden_proto(nanosleep)
-
-static void __pthread_acquire(int * spinlock);
-
-static __inline__ void __pthread_release(int * spinlock)
-{
-  WRITE_MEMORY_BARRIER();
-  *spinlock = __LT_SPINLOCK_INIT;
-  __asm__ __volatile__ ("" : "=m" (*spinlock) : "m" (*spinlock));
-}
-
-
-/* The status field of a spinlock is a pointer whose least significant
-   bit is a locked flag.
-
-   Thus the field values have the following meanings:
-
-   status == 0:       spinlock is free
-   status == 1:       spinlock is taken; no thread is waiting on it
-
-   (status & 1) == 1: spinlock is taken and (status & ~1L) is a
-                      pointer to the first waiting thread; other
-		      waiting threads are linked via the p_nextlock
-		      field.
-   (status & 1) == 0: same as above, but spinlock is not taken.
-
-   The waiting list is not sorted by priority order.
-   Actually, we always insert at top of list (sole insertion mode
-   that can be performed without locking).
-   For __pthread_unlock, we perform a linear search in the list
-   to find the highest-priority, oldest waiting thread.
-   This is safe because there are no concurrent __pthread_unlock
-   operations -- only the thread that locked the mutex can unlock it. */
-
-
-void internal_function __pthread_lock(struct _pthread_fastlock * lock,
-				      pthread_descr self)
-{
-#if defined HAS_COMPARE_AND_SWAP
-  long oldstatus, newstatus;
-  int successful_seizure, spurious_wakeup_count;
-#endif
-
-#if defined TEST_FOR_COMPARE_AND_SWAP
-  if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-  {
-    __pthread_acquire(&lock->__spinlock);
-    return;
-  }
-#endif
-
-#if defined HAS_COMPARE_AND_SWAP
-  /* First try it without preparation.  Maybe it's a completely
-     uncontested lock.  */
-  if (lock->__status == 0 && __compare_and_swap (&lock->__status, 0, 1))
-    return;
-
-  spurious_wakeup_count = 0;
-
-  /* On SMP, try spinning to get the lock. */
-#if 0
-  if (__pthread_smp_kernel) {
-    int spin_count;
-    int max_count = lock->__spinlock * 2 + 10;
-
-    if (max_count > MAX_ADAPTIVE_SPIN_COUNT)
-      max_count = MAX_ADAPTIVE_SPIN_COUNT;
-
-    for (spin_count = 0; spin_count < max_count; spin_count++) {
-      if (((oldstatus = lock->__status) & 1) == 0) {
-	if(__compare_and_swap(&lock->__status, oldstatus, oldstatus | 1))
-	{
-	  if (spin_count)
-	    lock->__spinlock += (spin_count - lock->__spinlock) / 8;
-	  READ_MEMORY_BARRIER();
-	  return;
-	}
-      }
-#ifdef BUSY_WAIT_NOP
-      BUSY_WAIT_NOP;
-#endif
-      __asm__ __volatile__ ("" : "=m" (lock->__status) : "m" (lock->__status));
-    }
-
-    lock->__spinlock += (spin_count - lock->__spinlock) / 8;
-  }
-#endif
-
-again:
-
-  /* No luck, try once more or suspend. */
-
-  do {
-    oldstatus = lock->__status;
-    successful_seizure = 0;
-
-    if ((oldstatus & 1) == 0) {
-      newstatus = oldstatus | 1;
-      successful_seizure = 1;
-    } else {
-      if (self == NULL)
-	self = thread_self();
-      newstatus = (long) self | 1;
-    }
-
-    if (self != NULL) {
-      THREAD_SETMEM(self, p_nextlock, (pthread_descr) (oldstatus));
-      /* Make sure the store in p_nextlock completes before performing
-         the compare-and-swap */
-      MEMORY_BARRIER();
-    }
-  } while(! __compare_and_swap(&lock->__status, oldstatus, newstatus));
-
-  /* Suspend with guard against spurious wakeup.
-     This can happen in pthread_cond_timedwait_relative, when the thread
-     wakes up due to timeout and is still on the condvar queue, and then
-     locks the queue to remove itself. At that point it may still be on the
-     queue, and may be resumed by a condition signal. */
-
-  if (!successful_seizure) {
-    for (;;) {
-      suspend(self);
-      if (self->p_nextlock != NULL) {
-	/* Count resumes that don't belong to us. */
-	spurious_wakeup_count++;
-	continue;
-      }
-      break;
-    }
-    goto again;
-  }
-
-  /* Put back any resumes we caught that don't belong to us. */
-  while (spurious_wakeup_count--)
-    restart(self);
-
-  READ_MEMORY_BARRIER();
-#endif
-}
-
-int __pthread_unlock(struct _pthread_fastlock * lock)
-{
-#if defined HAS_COMPARE_AND_SWAP
-  long oldstatus;
-  pthread_descr thr, * ptr, * maxptr;
-  int maxprio;
-#endif
-
-#if defined TEST_FOR_COMPARE_AND_SWAP
-  if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-  {
-    __pthread_release(&lock->__spinlock);
-    return 0;
-  }
-#endif
-
-#if defined HAS_COMPARE_AND_SWAP
-  WRITE_MEMORY_BARRIER();
-
-again:
-  while ((oldstatus = lock->__status) == 1) {
-    if (__compare_and_swap_with_release_semantics(&lock->__status,
-	oldstatus, 0))
-      return 0;
-  }
-
-  /* Find thread in waiting queue with maximal priority */
-  ptr = (pthread_descr *) &lock->__status;
-  thr = (pthread_descr) (oldstatus & ~1L);
-  maxprio = 0;
-  maxptr = ptr;
-
-  /* Before we iterate over the wait queue, we need to execute
-     a read barrier, otherwise we may read stale contents of nodes that may
-     just have been inserted by other processors. One read barrier is enough to
-     ensure we have a stable list; we don't need one for each pointer chase
-     through the list, because we are the owner of the lock; other threads
-     can only add nodes at the front; if a front node is consistent,
-     the ones behind it must also be. */
-
-  READ_MEMORY_BARRIER();
-
-  while (thr != 0) {
-    if (thr->p_priority >= maxprio) {
-      maxptr = ptr;
-      maxprio = thr->p_priority;
-    }
-    ptr = &(thr->p_nextlock);
-    thr = (pthread_descr)((long)(thr->p_nextlock) & ~1L);
-  }
-
-  /* Remove max prio thread from waiting list. */
-  if (maxptr == (pthread_descr *) &lock->__status) {
-    /* If max prio thread is at head, remove it with compare-and-swap
-       to guard against concurrent lock operation. This removal
-       also has the side effect of marking the lock as released
-       because the new status comes from thr->p_nextlock whose
-       least significant bit is clear. */
-    thr = (pthread_descr) (oldstatus & ~1L);
-    if (! __compare_and_swap_with_release_semantics
-	    (&lock->__status, oldstatus, (long)(thr->p_nextlock) & ~1L))
-      goto again;
-  } else {
-    /* No risk of concurrent access, remove max prio thread normally.
-       But in this case we must also flip the least significant bit
-       of the status to mark the lock as released. */
-    thr = (pthread_descr)((long)*maxptr & ~1L);
-    *maxptr = thr->p_nextlock;
-
-    /* Ensure deletion from linked list completes before we
-       release the lock. */
-    WRITE_MEMORY_BARRIER();
-
-    do {
-      oldstatus = lock->__status;
-    } while (!__compare_and_swap_with_release_semantics(&lock->__status,
-	     oldstatus, oldstatus & ~1L));
-  }
-
-  /* Wake up the selected waiting thread. Woken thread can check
-     its own p_nextlock field for NULL to detect that it has been removed. No
-     barrier is needed here, since restart() and suspend() take
-     care of memory synchronization. */
-
-  thr->p_nextlock = NULL;
-  restart(thr);
-
-  return 0;
-#endif
-}
-
-/*
- * Alternate fastlocks do not queue threads directly. Instead, they queue
- * these wait queue node structures. When a timed wait wakes up due to
- * a timeout, it can leave its wait node in the queue (because there
- * is no safe way to remove from the quue). Some other thread will
- * deallocate the abandoned node.
- */
-
-
-struct wait_node {
-  struct wait_node *next;	/* Next node in null terminated linked list */
-  pthread_descr thr;		/* The thread waiting with this node */
-  int abandoned;		/* Atomic flag */
-};
-
-static long wait_node_free_list;
-static int wait_node_free_list_spinlock;
-
-/* Allocate a new node from the head of the free list using an atomic
-   operation, or else using malloc if that list is empty.  A fundamental
-   assumption here is that we can safely access wait_node_free_list->next.
-   That's because we never free nodes once we allocate them, so a pointer to a
-   node remains valid indefinitely. */
-
-static struct wait_node *wait_node_alloc(void)
-{
-    struct wait_node *new_node = 0;
-
-    __pthread_acquire(&wait_node_free_list_spinlock);
-    if (wait_node_free_list != 0) {
-      new_node = (struct wait_node *) wait_node_free_list;
-      wait_node_free_list = (long) new_node->next;
-    }
-    WRITE_MEMORY_BARRIER();
-    __pthread_release(&wait_node_free_list_spinlock);
-
-    if (new_node == 0)
-      return malloc(sizeof *wait_node_alloc());
-
-    return new_node;
-}
-
-/* Return a node to the head of the free list using an atomic
-   operation. */
-
-static void wait_node_free(struct wait_node *wn)
-{
-    __pthread_acquire(&wait_node_free_list_spinlock);
-    wn->next = (struct wait_node *) wait_node_free_list;
-    wait_node_free_list = (long) wn;
-    WRITE_MEMORY_BARRIER();
-    __pthread_release(&wait_node_free_list_spinlock);
-    return;
-}
-
-#if defined HAS_COMPARE_AND_SWAP
-
-/* Remove a wait node from the specified queue.  It is assumed
-   that the removal takes place concurrently with only atomic insertions at the
-   head of the queue. */
-
-static void wait_node_dequeue(struct wait_node **pp_head,
-			      struct wait_node **pp_node,
-			      struct wait_node *p_node)
-{
-  /* If the node is being deleted from the head of the
-     list, it must be deleted using atomic compare-and-swap.
-     Otherwise it can be deleted in the straightforward way. */
-
-  if (pp_node == pp_head) {
-    /* We don't need a read barrier between these next two loads,
-       because it is assumed that the caller has already ensured
-       the stability of *p_node with respect to p_node. */
-
-    long oldvalue = (long) p_node;
-    long newvalue = (long) p_node->next;
-
-    if (__compare_and_swap((long *) pp_node, oldvalue, newvalue))
-      return;
-
-    /* Oops! Compare and swap failed, which means the node is
-       no longer first. We delete it using the ordinary method.  But we don't
-       know the identity of the node which now holds the pointer to the node
-       being deleted, so we must search from the beginning. */
-
-    for (pp_node = pp_head; p_node != *pp_node; ) {
-      pp_node = &(*pp_node)->next;
-      READ_MEMORY_BARRIER(); /* Stabilize *pp_node for next iteration. */
-    }
-  }
-
-  *pp_node = p_node->next;
-  return;
-}
-
-#endif
-
-void __pthread_alt_lock(struct _pthread_fastlock * lock,
-		        pthread_descr self)
-{
-#if defined HAS_COMPARE_AND_SWAP
-  long oldstatus, newstatus;
-#endif
-  struct wait_node wait_node;
-
-#if defined TEST_FOR_COMPARE_AND_SWAP
-  if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-  {
-    int suspend_needed = 0;
-    __pthread_acquire(&lock->__spinlock);
-
-    if (lock->__status == 0)
-      lock->__status = 1;
-    else {
-      if (self == NULL)
-	self = thread_self();
-
-      wait_node.abandoned = 0;
-      wait_node.next = (struct wait_node *) lock->__status;
-      wait_node.thr = self;
-      lock->__status = (long) &wait_node;
-      suspend_needed = 1;
-    }
-
-    __pthread_release(&lock->__spinlock);
-
-    if (suspend_needed)
-      suspend (self);
-    return;
-  }
-#endif
-
-#if defined HAS_COMPARE_AND_SWAP
-  do {
-    oldstatus = lock->__status;
-    if (oldstatus == 0) {
-      newstatus = 1;
-    } else {
-      if (self == NULL)
-	self = thread_self();
-      wait_node.thr = self;
-      newstatus = (long) &wait_node;
-    }
-    wait_node.abandoned = 0;
-    wait_node.next = (struct wait_node *) oldstatus;
-    /* Make sure the store in wait_node.next completes before performing
-       the compare-and-swap */
-    MEMORY_BARRIER();
-  } while(! __compare_and_swap(&lock->__status, oldstatus, newstatus));
-
-  /* Suspend. Note that unlike in __pthread_lock, we don't worry
-     here about spurious wakeup. That's because this lock is not
-     used in situations where that can happen; the restart can
-     only come from the previous lock owner. */
-
-  if (oldstatus != 0)
-    suspend(self);
-
-  READ_MEMORY_BARRIER();
-#endif
-}
-
-/* Timed-out lock operation; returns 0 to indicate timeout. */
-
-int __pthread_alt_timedlock(struct _pthread_fastlock * lock,
-			    pthread_descr self, const struct timespec *abstime)
-{
-  long oldstatus = 0;
-#if defined HAS_COMPARE_AND_SWAP
-  long newstatus;
-#endif
-  struct wait_node *p_wait_node = wait_node_alloc();
-
-  /* Out of memory, just give up and do ordinary lock. */
-  if (p_wait_node == 0) {
-    __pthread_alt_lock(lock, self);
-    return 1;
-  }
-
-#if defined TEST_FOR_COMPARE_AND_SWAP
-  if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-  {
-    __pthread_acquire(&lock->__spinlock);
-
-    if (lock->__status == 0)
-      lock->__status = 1;
-    else {
-      if (self == NULL)
-	self = thread_self();
-
-      p_wait_node->abandoned = 0;
-      p_wait_node->next = (struct wait_node *) lock->__status;
-      p_wait_node->thr = self;
-      lock->__status = (long) p_wait_node;
-      oldstatus = 1; /* force suspend */
-    }
-
-    __pthread_release(&lock->__spinlock);
-    goto suspend;
-  }
-#endif
-
-#if defined HAS_COMPARE_AND_SWAP
-  do {
-    oldstatus = lock->__status;
-    if (oldstatus == 0) {
-      newstatus = 1;
-    } else {
-      if (self == NULL)
-	self = thread_self();
-      p_wait_node->thr = self;
-      newstatus = (long) p_wait_node;
-    }
-    p_wait_node->abandoned = 0;
-    p_wait_node->next = (struct wait_node *) oldstatus;
-    /* Make sure the store in wait_node.next completes before performing
-       the compare-and-swap */
-    MEMORY_BARRIER();
-  } while(! __compare_and_swap(&lock->__status, oldstatus, newstatus));
-#endif
-
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-  suspend:
-#endif
-
-  /* If we did not get the lock, do a timed suspend. If we wake up due
-     to a timeout, then there is a race; the old lock owner may try
-     to remove us from the queue. This race is resolved by us and the owner
-     doing an atomic testandset() to change the state of the wait node from 0
-     to 1. If we succeed, then it's a timeout and we abandon the node in the
-     queue. If we fail, it means the owner gave us the lock. */
-
-  if (oldstatus != 0) {
-    if (timedsuspend(self, abstime) == 0) {
-      if (!testandset(&p_wait_node->abandoned))
-	return 0; /* Timeout! */
-
-      /* Eat oustanding resume from owner, otherwise wait_node_free() below
-	 will race with owner's wait_node_dequeue(). */
-      suspend(self);
-    }
-  }
-
-  wait_node_free(p_wait_node);
-
-  READ_MEMORY_BARRIER();
-
-  return 1; /* Got the lock! */
-}
-
-void __pthread_alt_unlock(struct _pthread_fastlock *lock)
-{
-  struct wait_node *p_node, **pp_node, *p_max_prio, **pp_max_prio;
-  struct wait_node ** const pp_head = (struct wait_node **) &lock->__status;
-  int maxprio;
-
-  WRITE_MEMORY_BARRIER();
-
-#if defined TEST_FOR_COMPARE_AND_SWAP
-  if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-  {
-    __pthread_acquire(&lock->__spinlock);
-  }
-#endif
-
-  while (1) {
-
-  /* If no threads are waiting for this lock, try to just
-     atomically release it. */
-#if defined TEST_FOR_COMPARE_AND_SWAP
-    if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-    {
-      if (lock->__status == 0 || lock->__status == 1) {
-	lock->__status = 0;
-	break;
-      }
-    }
-#endif
-
-#if defined TEST_FOR_COMPARE_AND_SWAP
-    else
-#endif
-
-#if defined HAS_COMPARE_AND_SWAP
-    {
-      long oldstatus = lock->__status;
-      if (oldstatus == 0 || oldstatus == 1) {
-	if (__compare_and_swap_with_release_semantics (&lock->__status, oldstatus, 0))
-	  break;
-	else
-	  continue;
-      }
-    }
-#endif
-
-    /* Process the entire queue of wait nodes. Remove all abandoned
-       wait nodes and put them into the global free queue, and
-       remember the one unabandoned node which refers to the thread
-       having the highest priority. */
-
-    pp_max_prio = pp_node = pp_head;
-    p_max_prio = p_node = *pp_head;
-    maxprio = INT_MIN;
-
-    READ_MEMORY_BARRIER(); /* Prevent access to stale data through p_node */
-
-    while (p_node != (struct wait_node *) 1) {
-      int prio;
-
-      if (p_node->abandoned) {
-	/* Remove abandoned node. */
-#if defined TEST_FOR_COMPARE_AND_SWAP
-	if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-	  *pp_node = p_node->next;
-#endif
-#if defined TEST_FOR_COMPARE_AND_SWAP
-	else
-#endif
-#if defined HAS_COMPARE_AND_SWAP
-	  wait_node_dequeue(pp_head, pp_node, p_node);
-#endif
-	wait_node_free(p_node);
-	/* Note that the next assignment may take us to the beginning
-	   of the queue, to newly inserted nodes, if pp_node == pp_head.
-	   In that case we need a memory barrier to stabilize the first of
-	   these new nodes. */
-	p_node = *pp_node;
-	if (pp_node == pp_head)
-	  READ_MEMORY_BARRIER(); /* No stale reads through p_node */
-	continue;
-      } else if ((prio = p_node->thr->p_priority) >= maxprio) {
-	/* Otherwise remember it if its thread has a higher or equal priority
-	   compared to that of any node seen thus far. */
-	maxprio = prio;
-	pp_max_prio = pp_node;
-	p_max_prio = p_node;
-      }
-
-      /* This canno6 jump backward in the list, so no further read
-         barrier is needed. */
-      pp_node = &p_node->next;
-      p_node = *pp_node;
-    }
-
-    /* If all threads abandoned, go back to top */
-    if (maxprio == INT_MIN)
-      continue;
-
-    /* Now we want to to remove the max priority thread's wait node from
-       the list. Before we can do this, we must atomically try to change the
-       node's abandon state from zero to nonzero. If we succeed, that means we
-       have the node that we will wake up. If we failed, then it means the
-       thread timed out and abandoned the node in which case we repeat the
-       whole unlock operation. */
-
-    if (!testandset(&p_max_prio->abandoned)) {
-#if defined TEST_FOR_COMPARE_AND_SWAP
-      if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-	*pp_max_prio = p_max_prio->next;
-#endif
-#if defined TEST_FOR_COMPARE_AND_SWAP
-      else
-#endif
-#if defined HAS_COMPARE_AND_SWAP
-	wait_node_dequeue(pp_head, pp_max_prio, p_max_prio);
-#endif
-      restart(p_max_prio->thr);
-      break;
-    }
-  }
-
-#if defined TEST_FOR_COMPARE_AND_SWAP
-  if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-  {
-    __pthread_release(&lock->__spinlock);
-  }
-#endif
-}
-
-
-/* Compare-and-swap emulation with a spinlock */
-
-#ifdef TEST_FOR_COMPARE_AND_SWAP
-int __pthread_has_cas = 0;
-#endif
-
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-
-int __pthread_compare_and_swap(long * ptr, long oldval, long newval,
-                               int * spinlock)
-{
-  int res;
-
-  __pthread_acquire(spinlock);
-
-  if (*ptr == oldval) {
-    *ptr = newval; res = 1;
-  } else {
-    res = 0;
-  }
-
-  __pthread_release(spinlock);
-
-  return res;
-}
-
-#endif
-
-/* The retry strategy is as follows:
-   - We test and set the spinlock MAX_SPIN_COUNT times, calling
-     sched_yield() each time.  This gives ample opportunity for other
-     threads with priority >= our priority to make progress and
-     release the spinlock.
-   - If a thread with priority < our priority owns the spinlock,
-     calling sched_yield() repeatedly is useless, since we're preventing
-     the owning thread from making progress and releasing the spinlock.
-     So, after MAX_SPIN_LOCK attemps, we suspend the calling thread
-     using nanosleep().  This again should give time to the owning thread
-     for releasing the spinlock.
-     Notice that the nanosleep() interval must not be too small,
-     since the kernel does busy-waiting for short intervals in a realtime
-     process (!).  The smallest duration that guarantees thread
-     suspension is currently 2ms.
-   - When nanosleep() returns, we try again, doing MAX_SPIN_COUNT
-     sched_yield(), then sleeping again if needed. */
-
-static void __pthread_acquire(int * spinlock)
-{
-  int cnt = 0;
-  struct timespec tm;
-
-  READ_MEMORY_BARRIER();
-
-  while (testandset(spinlock)) {
-    if (cnt < MAX_SPIN_COUNT) {
-      sched_yield();
-      cnt++;
-    } else {
-      tm.tv_sec = 0;
-      tm.tv_nsec = SPIN_SLEEP_DURATION;
-      nanosleep(&tm, NULL);
-      cnt = 0;
-    }
-  }
-}
diff --git a/libpthread/linuxthreads.old/spinlock.h b/libpthread/linuxthreads.old/spinlock.h
deleted file mode 100644
index 7117898f7..000000000
--- a/libpthread/linuxthreads.old/spinlock.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1998 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-#include <bits/initspin.h>
-
-
-/* There are 2 compare and swap synchronization primitives with
-   different semantics:
-
-	1. compare_and_swap, which has acquire semantics (i.e. it
-	completes befor subsequent writes.)
-	2. compare_and_swap_with_release_semantics, which has release
-	semantics (it completes after previous writes.)
-
-   For those platforms on which they are the same. HAS_COMPARE_AND_SWAP
-   should be defined. For those platforms on which they are different,
-   HAS_COMPARE_AND_SWAP_WITH_RELEASE_SEMANTICS has to be defined.  */
-
-#ifndef HAS_COMPARE_AND_SWAP
-#ifdef HAS_COMPARE_AND_SWAP_WITH_RELEASE_SEMANTICS
-#define HAS_COMPARE_AND_SWAP
-#endif
-#endif
-
-#if defined(TEST_FOR_COMPARE_AND_SWAP)
-
-extern int __pthread_has_cas;
-extern int __pthread_compare_and_swap(long * ptr, long oldval, long newval,
-                                      int * spinlock);
-
-static __inline__ int compare_and_swap(long * ptr, long oldval, long newval,
-                                   int * spinlock)
-{
-  if (__builtin_expect (__pthread_has_cas, 1))
-    return __compare_and_swap(ptr, oldval, newval);
-  else
-    return __pthread_compare_and_swap(ptr, oldval, newval, spinlock);
-}
-
-#elif defined(HAS_COMPARE_AND_SWAP)
-
-#ifdef IMPLEMENT_TAS_WITH_CAS
-#define testandset(p) !__compare_and_swap((long int *) p, 0, 1)
-#endif
-
-#ifdef HAS_COMPARE_AND_SWAP_WITH_RELEASE_SEMANTICS
-
-static __inline__ int
-compare_and_swap_with_release_semantics (long * ptr, long oldval,
-					 long newval, int * spinlock)
-{
-  return __compare_and_swap_with_release_semantics (ptr, oldval,
-						    newval);
-}
-
-#endif
-
-static __inline__ int compare_and_swap(long * ptr, long oldval, long newval,
-                                   int * spinlock)
-{
-  return __compare_and_swap(ptr, oldval, newval);
-}
-
-#else
-
-extern int __pthread_compare_and_swap(long * ptr, long oldval, long newval,
-                                      int * spinlock);
-
-static __inline__ int compare_and_swap(long * ptr, long oldval, long newval,
-                                   int * spinlock)
-{
-  return __pthread_compare_and_swap(ptr, oldval, newval, spinlock);
-}
-
-#endif
-
-#ifndef HAS_COMPARE_AND_SWAP_WITH_RELEASE_SEMANTICS
-#define compare_and_swap_with_release_semantics compare_and_swap
-#define __compare_and_swap_with_release_semantics __compare_and_swap
-#endif
-
-/* Internal locks */
-
-extern void internal_function __pthread_lock(struct _pthread_fastlock * lock,
-					     pthread_descr self);
-extern int __pthread_unlock(struct _pthread_fastlock *lock);
-
-static __inline__ void __pthread_init_lock(struct _pthread_fastlock * lock)
-{
-  lock->__status = 0;
-  lock->__spinlock = __LT_SPINLOCK_INIT;
-}
-
-static __inline__ int __pthread_trylock (struct _pthread_fastlock * lock)
-{
-#if defined TEST_FOR_COMPARE_AND_SWAP
-  if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-  {
-    return (testandset(&lock->__spinlock) ? EBUSY : 0);
-  }
-#endif
-
-#if defined HAS_COMPARE_AND_SWAP
-  do {
-    if (lock->__status != 0) return EBUSY;
-  } while(! __compare_and_swap(&lock->__status, 0, 1));
-  return 0;
-#endif
-}
-
-/* Variation of internal lock used for pthread_mutex_t, supporting
-   timed-out waits.  Warning: do not mix these operations with the above ones
-   over the same lock object! */
-
-extern void __pthread_alt_lock(struct _pthread_fastlock * lock,
-			       pthread_descr self);
-
-extern int __pthread_alt_timedlock(struct _pthread_fastlock * lock,
-			       pthread_descr self, const struct timespec *abstime);
-
-extern void __pthread_alt_unlock(struct _pthread_fastlock *lock);
-
-static __inline__ void __pthread_alt_init_lock(struct _pthread_fastlock * lock)
-{
-  lock->__status = 0;
-  lock->__spinlock = __LT_SPINLOCK_INIT;
-}
-
-static __inline__ int __pthread_alt_trylock (struct _pthread_fastlock * lock)
-{
-#if defined TEST_FOR_COMPARE_AND_SWAP
-  if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-  {
-    int res = EBUSY;
-
-    if (testandset(&lock->__spinlock) == 0)
-      {
-	if (lock->__status == 0)
-	  {
-	    lock->__status = 1;
-	    WRITE_MEMORY_BARRIER();
-	    res = 0;
-	  }
-	lock->__spinlock = __LT_SPINLOCK_INIT;
-      }
-    return res;
-  }
-#endif
-
-#if defined HAS_COMPARE_AND_SWAP
-  do {
-    if (lock->__status != 0) return EBUSY;
-  } while(! compare_and_swap(&lock->__status, 0, 1, &lock->__spinlock));
-  return 0;
-#endif
-}
-
-/* Operations on pthread_atomic, which is defined in internals.h */
-
-static __inline__ long atomic_increment(struct pthread_atomic *pa)
-{
-    long oldval;
-
-    do {
-	oldval = pa->p_count;
-    } while (!compare_and_swap(&pa->p_count, oldval, oldval + 1, &pa->p_spinlock));
-
-    return oldval;
-}
-
-
-static __inline__ long atomic_decrement(struct pthread_atomic *pa)
-{
-    long oldval;
-
-    do {
-	oldval = pa->p_count;
-    } while (!compare_and_swap(&pa->p_count, oldval, oldval - 1, &pa->p_spinlock));
-
-    return oldval;
-}
-
-
-static __inline__ void
-__pthread_set_own_extricate_if (pthread_descr self, pthread_extricate_if *peif)
-{
-  /* Only store a non-null peif if the thread has cancellation enabled.
-     Otherwise pthread_cancel will unconditionally call the extricate handler,
-     and restart the thread giving rise to forbidden spurious wakeups. */
-  if (peif == NULL
-      || THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE)
-    {
-      /* If we are removing the extricate interface, we need to synchronize
-	 against pthread_cancel so that it does not continue with a pointer
-         to a deallocated pthread_extricate_if struct! The thread lock
-         is (ab)used for this synchronization purpose. */
-      if (peif == NULL)
-	__pthread_lock (THREAD_GETMEM(self, p_lock), self);
-      THREAD_SETMEM(self, p_extricate, peif);
-      if (peif == NULL)
-	__pthread_unlock (THREAD_GETMEM(self, p_lock));
-    }
-}
diff --git a/libpthread/linuxthreads.old/sysdeps/alpha/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/alpha/pt-machine.h
deleted file mode 100644
index b47343ba7..000000000
--- a/libpthread/linuxthreads.old/sysdeps/alpha/pt-machine.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   Alpha version.
-   Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003
-   Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Richard Henderson <rth@tamu.edu>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#include <features.h>
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-#ifdef __linux__
-# include <asm/pal.h>
-#else
-# include <machine/pal.h>
-#endif
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  stack_pointer
-register char *stack_pointer __asm__("$30");
-
-
-/* Memory barrier; default is to do nothing */
-#define MEMORY_BARRIER() __asm__ __volatile__("mb" : : : "memory")
-/* Write barrier.  */
-#define WRITE_MEMORY_BARRIER() __asm__ __volatile__("wmb" : : : "memory")
-
-
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
-{
-  long int ret, temp;
-
-  __asm__ __volatile__(
-	"/* Inline spinlock test & set */\n"
-	"1:\t"
-	"ldl_l %0,%3\n\t"
-	"bne %0,2f\n\t"
-	"or $31,1,%1\n\t"
-	"stl_c %1,%2\n\t"
-	"beq %1,1b\n"
-	"2:\tmb\n"
-	"/* End spinlock test & set */"
-	: "=&r"(ret), "=&r"(temp), "=m"(*spinlock)
-	: "m"(*spinlock)
-        : "memory");
-
-  return ret;
-}
-
-
-/* Begin allocating thread stacks at this address.  Default is to allocate
-   them just below the initial program stack.  */
-#define THREAD_STACK_START_ADDRESS  0x40000000000
-
-
-/* Return the thread descriptor for the current thread.  */
-#define THREAD_SELF \
-({									      \
-  register pthread_descr __self __asm__("$0");				      \
-  __asm__ ("call_pal %1" : "=r"(__self) : "i"(PAL_rduniq));		      \
-  __self;								      \
-})
-
-/* Initialize the thread-unique value.  */
-#define INIT_THREAD_SELF(descr, nr) \
-{									      \
-  register pthread_descr __self __asm__("$16") = (descr);		      \
-  __asm__ __volatile__ ("call_pal %1" : : "r"(__self), "i"(PAL_wruniq));      \
-}
-
-
-/* Compare-and-swap for semaphores. */
-
-#define HAS_COMPARE_AND_SWAP
-PT_EI int
-__compare_and_swap (long int *p, long int oldval, long int newval)
-{
-  long int ret;
-
-  __asm__ __volatile__ (
-	"/* Inline compare & swap */\n"
-	"1:\t"
-	"ldq_l %0,%4\n\t"
-	"cmpeq %0,%2,%0\n\t"
-	"beq %0,2f\n\t"
-	"mov %3,%0\n\t"
-	"stq_c %0,%1\n\t"
-	"beq %0,1b\n\t"
-	"2:\tmb\n"
-	"/* End compare & swap */"
-	: "=&r"(ret), "=m"(*p)
-	: "r"(oldval), "r"(newval), "m"(*p)
-        : "memory");
-
-  return ret;
-}
-
-/* We want the OS to assign stack addresses.  */
-#define FLOATING_STACKS 1
-
-/* Maximum size of the stack if the rlimit is unlimited.  */
-#define ARCH_STACK_MAX_SIZE     32*1024*1024
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/arm/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/arm/pt-machine.h
deleted file mode 100644
index 2b877f980..000000000
--- a/libpthread/linuxthreads.old/sysdeps/arm/pt-machine.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   ARM version.
-   Copyright (C) 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Philip Blundell <philb@gnu.org>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#include <sys/syscall.h>
-#include <unistd.h>
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-#if defined(__thumb__)
-#if defined(__USE_LDREXSTREX__)
-PT_EI long int ldrex(int *spinlock)
-{
-	long int ret;
-	__asm__ __volatile__(
-		"ldrex %0, [%1]\n"
-		: "=r"(ret)
-		: "r"(spinlock) : "memory");
-	return ret;
-}
-
-PT_EI long int strex(int val, int *spinlock)
-{
-	long int ret;
-	__asm__ __volatile__(
-		"strex %0, %1, [%2]\n"
-		: "=r"(ret)
-		: "r" (val), "r"(spinlock) : "memory");
-	return ret;
-}
-
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
-{
-  register unsigned int ret;
-
-  do {
-	  ret = ldrex(spinlock);
-  } while (strex(1, spinlock));
-
-  return ret;
-}
-
-#else /* __USE_LDREXSTREX__ */
-
-/* This will not work on ARM1 or ARM2 because SWP is lacking on those
-   machines.  Unfortunately we have no way to detect this at compile
-   time; let's hope nobody tries to use one.  */
-
-/* Spinlock implementation; required.  */
-PT_EI long int testandset (int *spinlock);
-PT_EI long int testandset (int *spinlock)
-{
-  register unsigned int ret;
-  void *pc;
-  __asm__ __volatile__(
-	".align 0\n"
-	"\tbx pc\n"
-	"\tnop\n"
-	"\t.arm\n"
-	"\tswp %0, %2, [%3]\n"
-	"\torr %1, pc, #1\n"
-	"\tbx %1\n"
-	"\t.force_thumb"
-	: "=r"(ret), "=r"(pc)
-	: "0"(1), "r"(spinlock));
-  return ret;
-}
-#endif
-#else /* __thumb__ */
-
-PT_EI long int testandset (int *spinlock);
-PT_EI long int testandset (int *spinlock)
-{
-  register unsigned int ret;
-  __asm__ __volatile__("swp %0, %1, [%2]"
-		       : "=r"(ret)
-		       : "0"(1), "r"(spinlock));
-  return ret;
-}
-#endif
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  stack_pointer
-register char * stack_pointer __asm__ ("sp");
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/avr32/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/avr32/pt-machine.h
deleted file mode 100644
index 5735d0ea2..000000000
--- a/libpthread/linuxthreads.old/sysdeps/avr32/pt-machine.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
- *
- * Copyright (C) 2005-2007 Atmel Corporation
- *
- * This file is subject to the terms and conditions of the GNU Lesser General
- * Public License.  See the file "COPYING.LIB" in the main directory of this
- * archive for more details.
- */
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#include <features.h>
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-static __inline__ int
-_test_and_set (int *p, int v)
-{
-	int result;
-
-	__asm__ __volatile__(
-		"/* Inline test and set */\n"
-		"	xchg	%[old], %[mem], %[new]"
-		: [old] "=&r"(result)
-		: [mem] "r"(p), [new] "r"(v)
-		: "memory");
-
-	return result;
-}
-
-extern long int testandset (int *spinlock);
-extern int __compare_and_swap (long int *p, long int oldval, long int newval);
-
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
-{
-	return _test_and_set(spinlock, 1);
-}
-
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  stack_pointer
-register char * stack_pointer __asm__ ("sp");
-
-/* Compare-and-swap for semaphores. */
-
-#define HAS_COMPARE_AND_SWAP
-PT_EI int
-__compare_and_swap(long int *p, long int oldval, long int newval)
-{
-	long int result;
-
-	__asm__ __volatile__(
-		"/* Inline compare and swap */\n"
-		"1:	ssrf	5\n"
-		"	ld.w	%[result], %[mem]\n"
-		"	eor	%[result], %[old]\n"
-		"	brne	2f\n"
-		"	stcond	%[mem], %[new]\n"
-		"	brne	1b\n"
-		"2:"
-		: [result] "=&r"(result), [mem] "=m"(*p)
-		: "m"(*p), [new] "r"(newval), [old] "r"(oldval)
-		: "cc", "memory");
-
-	return result == 0;
-}
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/cris/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/cris/pt-machine.h
deleted file mode 100644
index a89579ee0..000000000
--- a/libpthread/linuxthreads.old/sysdeps/cris/pt-machine.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   CRIS version.
-   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#include <features.h>
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-PT_EI long int
-testandset (int *spinlock)
-{
-  register unsigned long int ret;
-
-  /* Note the use of a dummy output of *spinlock to expose the write.  The
-     memory barrier is to stop *other* writes being moved past this code.  */
-
-#ifdef __arch_v32
-  __asm__ __volatile__("clearf p\n"
-		       "0:\n\t"
-		       "movu.b [%2],%0\n\t"
-		       "ax\n\t"
-		       "move.b %3,[%2]\n\t"
-		       "bcs 0b\n\t"
-		       "clearf p"
-		       : "=&r" (ret), "=m" (*spinlock)
-		       : "r" (spinlock), "r" ((int) 1), "m" (*spinlock)
-		       : "memory");
-#else  /* not __arch_v32 */
-  __asm__ __volatile__("clearf\n"
-		       "0:\n\t"
-		       "movu.b [%2],%0\n\t"
-		       "ax\n\t"
-		       "move.b %3,[%2]\n\t"
-		       "bwf 0b\n\t"
-		       "clearf"
-		       : "=&r" (ret), "=m" (*spinlock)
-		       : "r" (spinlock), "r" ((int) 1), "m" (*spinlock)
-		       : "memory");
-#endif /* __arch_v32 */
-  return ret;
-}
-
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.
-   I don't trust register variables, so let's do this the safe way.  */
-#define CURRENT_STACK_FRAME \
- ({ char *sp; __asm__ ("move.d $sp,%0" : "=rm" (sp)); sp; })
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/i386/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/i386/pt-machine.h
deleted file mode 100644
index 24c5e6c7c..000000000
--- a/libpthread/linuxthreads.old/sysdeps/i386/pt-machine.h
+++ /dev/null
@@ -1,146 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   i386 version.
-   Copyright (C) 1996-2001, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Richard Henderson <rth@tamu.edu>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H	1
-
-#include <features.h>
-
-#ifndef __ASSEMBLER__
-#ifndef PT_EI
-# define PT_EI __extern_always_inline __attribute__((visibility("hidden")))
-#endif
-
-extern long int testandset (int *spinlock);
-extern int __compare_and_swap (long int *p, long int oldval, long int newval);
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  __builtin_frame_address (0)
-
-
-/* See if we can optimize for newer cpus... */
-#if defined __GNUC__ && __GNUC__ >= 2 && \
-   (defined __i486__ || defined __pentium__ || defined __pentiumpro__ || defined __pentium4__ || \
-    defined __athlon__ || defined __k8__)
-
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
-{
-  long int ret;
-
-  __asm__ __volatile__ (
-	"xchgl %0, %1"
-	: "=r" (ret), "=m" (*spinlock)
-	: "0" (1), "m" (*spinlock)
-	: "memory");
-
-  return ret;
-}
-
-/* Compare-and-swap for semaphores.  It's always available on i686.  */
-#define HAS_COMPARE_AND_SWAP
-
-PT_EI int
-__compare_and_swap (long int *p, long int oldval, long int newval)
-{
-  char ret;
-  long int readval;
-
-  __asm__ __volatile__ ("lock; cmpxchgl %3, %1; sete %0"
-			: "=q" (ret), "=m" (*p), "=a" (readval)
-			: "r" (newval), "m" (*p), "a" (oldval)
-			: "memory");
-  return ret;
-}
-
-#if defined(__ASSUME_LDT_WORKS) && __ASSUME_LDT_WORKS > 0
-#include "useldt.h"
-#endif
-
-/* The P4 and above really want some help to prevent overheating.  */
-#define BUSY_WAIT_NOP	__asm__ ("rep; nop")
-
-
-#else /* Generic i386 implementation */
-
-extern int compare_and_swap_is_available (void);
-
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
-{
-  long int ret;
-
-  __asm__ __volatile__(
-       "xchgl %0, %1"
-       : "=r"(ret), "=m"(*spinlock)
-       : "0"(1), "m"(*spinlock)
-       : "memory");
-
-  return ret;
-}
-
-
-/* Compare-and-swap for semaphores.
-   Available on the 486 and above, but not on the 386.
-   We test dynamically whether it's available or not. */
-
-#define HAS_COMPARE_AND_SWAP
-#define TEST_FOR_COMPARE_AND_SWAP
-
-PT_EI int
-__compare_and_swap (long int *p, long int oldval, long int newval)
-{
-  char ret;
-  long int readval;
-
-  __asm__ __volatile__ ("lock; cmpxchgl %3, %1; sete %0"
-			: "=q" (ret), "=m" (*p), "=a" (readval)
-			: "r" (newval), "m" (*p), "a" (oldval)
-			: "memory");
-  return ret;
-}
-
-PT_EI int
-compare_and_swap_is_available (void)
-{
-  int changed;
-  int oldflags;
-  /* get EFLAGS */
-  __asm__ __volatile__ ("pushfl; popl %0" : "=r" (oldflags) : );
-  /* Flip AC bit in EFLAGS.  */
-  __asm__ __volatile__ ("pushl %0; popfl" : : "r" (oldflags ^ 0x40000) : "cc");
-  /* reread EFLAGS */
-  __asm__ __volatile__ ("pushfl; popl %0" : "=r" (changed) : );
-  /* See if bit changed.  */
-  changed = (changed ^ oldflags) & 0x40000;
-  /* Restore EFLAGS.  */
-  __asm__ __volatile__ ("pushl %0; popfl" : : "r" (oldflags) : "cc");
-  /* If the AC flag did not change, it's a 386 and it lacks cmpxchg.
-     Otherwise, it's a 486 or above and it has cmpxchg.  */
-  return changed != 0;
-}
-#endif /* Generic i386 implementation */
-
-#endif /* __ASSEMBLER__ */
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/i386/tls.h b/libpthread/linuxthreads.old/sysdeps/i386/tls.h
deleted file mode 100644
index 4469f0776..000000000
--- a/libpthread/linuxthreads.old/sysdeps/i386/tls.h
+++ /dev/null
@@ -1,184 +0,0 @@
-/* Definition for thread-local data handling.  linuxthreads/i386 version.
-   Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _TLS_H
-#define _TLS_H
-
-# include <pt-machine.h>
-
-#ifndef __ASSEMBLER__
-# include <stdbool.h>
-# include <stddef.h>
-# include <stdint.h>
-
-/* Type for the dtv.  */
-typedef union dtv
-{
-  size_t counter;
-  void *pointer;
-} dtv_t;
-
-
-typedef struct
-{
-  void *tcb;		/* Pointer to the TCB.  Not necessary the
-			   thread descriptor used by libpthread.  */
-  dtv_t *dtv;
-  void *self;		/* Pointer to the thread descriptor.  */
-} tcbhead_t;
-#endif
-
-
-/* We can support TLS only if the floating-stack support is available.  */
-#if defined FLOATING_STACKS && defined HAVE_TLS_SUPPORT
-
-/* Signal that TLS support is available.  */
-//# define USE_TLS	1
-
-# ifndef __ASSEMBLER__
-/* Get system call information.  */
-#  include <sysdep.h>
-
-
-/* Get the thread descriptor definition.  */
-#  include <linuxthreads/descr.h>
-
-/* This is the size of the initial TCB.  */
-#  define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
-
-/* Alignment requirements for the initial TCB.  */
-#  define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
-
-/* This is the size of the TCB.  */
-#  define TLS_TCB_SIZE sizeof (struct _pthread_descr_struct)
-
-/* Alignment requirements for the TCB.  */
-#  define TLS_TCB_ALIGN __alignof__ (struct _pthread_descr_struct)
-
-/* The TCB can have any size and the memory following the address the
-   thread pointer points to is unspecified.  Allocate the TCB there.  */
-#  define TLS_TCB_AT_TP	1
-
-
-/* Install the dtv pointer.  The pointer passed is to the element with
-   index -1 which contain the length.  */
-#  define INSTALL_DTV(descr, dtvp) \
-  ((tcbhead_t *) (descr))->dtv = (dtvp) + 1
-
-/* Install new dtv for current thread.  */
-#  define INSTALL_NEW_DTV(dtv) \
-  ({ struct _pthread_descr_struct *__descr;				      \
-     THREAD_SETMEM (__descr, p_header.data.dtvp, (dtv)); })
-
-/* Return dtv of given thread descriptor.  */
-#  define GET_DTV(descr) \
-  (((tcbhead_t *) (descr))->dtv)
-
-#  ifdef __PIC__
-#   define TLS_EBX_ARG "r"
-#   define TLS_LOAD_EBX "xchgl %3, %%ebx\n\t"
-#  else
-#   define TLS_EBX_ARG "b"
-#   define TLS_LOAD_EBX
-#  endif
-
-#  define TLS_DO_MODIFY_LDT(descr, nr)					      \
-({									      \
-  struct modify_ldt_ldt_s ldt_entry =					      \
-    { nr, (unsigned long int) (descr), 0xfffff /* 4GB in pages */,	      \
-      1, 0, 0, 1, 0, 1, 0 };						      \
-  int result;								      \
-  __asm__ __volatile__ (TLS_LOAD_EBX						      \
-		"int $0x80\n\t"						      \
-		TLS_LOAD_EBX						      \
-		: "=a" (result)						      \
-		: "0" (__NR_modify_ldt),				      \
-		/* The extra argument with the "m" constraint is necessary    \
-		   to let the compiler know that we are accessing LDT_ENTRY   \
-		   here.  */						      \
-		"m" (ldt_entry), TLS_EBX_ARG (1), "c" (&ldt_entry),	      \
-		"d" (sizeof (ldt_entry)));				      \
-  __builtin_expect (result, 0) != 0 ? -1 : nr * 8 + 7;			      \
-})
-
-#  define TLS_DO_SET_THREAD_AREA(descr, secondcall)			      \
-({									      \
-  struct modify_ldt_ldt_s ldt_entry =					      \
-    { -1, (unsigned long int) (descr), 0xfffff /* 4GB in pages */,	      \
-      1, 0, 0, 1, 0, 1, 0 };						      \
-  int result;								      \
-  if (secondcall)							      \
-    ldt_entry.entry_number = ({ int _gs;				      \
-				__asm__ ("movw %%gs, %w0" : "=q" (_gs));	      \
-				(_gs & 0xffff) >> 3; });		      \
-  __asm__ __volatile__ (TLS_LOAD_EBX						      \
-		"int $0x80\n\t"						      \
-		TLS_LOAD_EBX						      \
-		: "=a" (result), "=m" (ldt_entry.entry_number)		      \
-		: "0" (__NR_set_thread_area),				      \
-		/* The extra argument with the "m" constraint is necessary    \
-		   to let the compiler know that we are accessing LDT_ENTRY   \
-		   here.  */						      \
-		TLS_EBX_ARG (&ldt_entry), "m" (ldt_entry));		      \
-    __builtin_expect (result, 0) == 0 ? ldt_entry.entry_number * 8 + 3 : -1;  \
-})
-
-#  ifdef __ASSUME_SET_THREAD_AREA_SYSCALL
-#   define TLS_SETUP_GS_SEGMENT(descr, secondcall) \
-  TLS_DO_SET_THREAD_AREA (descr, firstcall)
-#  elif defined __NR_set_thread_area
-#   define TLS_SETUP_GS_SEGMENT(descr, secondcall) \
-  ({ int __seg = TLS_DO_SET_THREAD_AREA (descr, secondcall); \
-     __seg == -1 ? TLS_DO_MODIFY_LDT (descr, 0) : __seg; })
-#  else
-#   define TLS_SETUP_GS_SEGMENT(descr, secondcall) \
-  TLS_DO_MODIFY_LDT ((descr), 0)
-#  endif
-
-/* Code to initially initialize the thread pointer.  This might need
-   special attention since 'errno' is not yet available and if the
-   operation can cause a failure 'errno' must not be touched.  */
-#  define TLS_INIT_TP(descr, secondcall)				      \
-  ({									      \
-    void *_descr = (descr);						      \
-    tcbhead_t *head = _descr;						      \
-    int __gs;								      \
-									      \
-    head->tcb = _descr;							      \
-    /* For now the thread descriptor is at the same address.  */	      \
-    head->self = _descr;						      \
-									      \
-    __gs = TLS_SETUP_GS_SEGMENT (_descr, secondcall);			      \
-    if (__builtin_expect (__gs, 7) != -1)				      \
-      {									      \
-	__asm__ ("movw %w0, %%gs" : : "q" (__gs));				      \
-	__gs = 0;							      \
-      }									      \
-    __gs;								      \
-  })
-
-
-/* Return the address of the dtv for the current thread.  */
-#  define THREAD_DTV() \
-  ({ struct _pthread_descr_struct *__descr;				      \
-     THREAD_GETMEM (__descr, p_header.data.dtvp); })
-
-# endif	/* FLOATING_STACKS && HAVE_TLS_SUPPORT */
-#endif /* __ASSEMBLER__ */
-
-#endif	/* tls.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/i386/useldt.h b/libpthread/linuxthreads.old/sysdeps/i386/useldt.h
deleted file mode 100644
index 02326729a..000000000
--- a/libpthread/linuxthreads.old/sysdeps/i386/useldt.h
+++ /dev/null
@@ -1,306 +0,0 @@
-/* Special definitions for ix86 machine using segment register based
-   thread descriptor.
-   Copyright (C) 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-#ifndef __ASSEMBLER__
-#include <stddef.h>	/* For offsetof.  */
-#include <stdlib.h>	/* For abort().	 */
-
-
-/* We don't want to include the kernel header.	So duplicate the
-   information.	 */
-
-/* Structure passed on `modify_ldt' call.  */
-struct modify_ldt_ldt_s
-{
-  unsigned int entry_number;
-  unsigned long int base_addr;
-  unsigned int limit;
-  unsigned int seg_32bit:1;
-  unsigned int contents:2;
-  unsigned int read_exec_only:1;
-  unsigned int limit_in_pages:1;
-  unsigned int seg_not_present:1;
-  unsigned int useable:1;
-  unsigned int empty:25;
-};
-
-/* System call to set LDT entry.  */
-extern int __modify_ldt (int, struct modify_ldt_ldt_s *, size_t);
-
-
-/* Return the thread descriptor for the current thread.
-
-   The contained asm must *not* be marked volatile since otherwise
-   assignments like
-	pthread_descr self = thread_self();
-   do not get optimized away.  */
-#define THREAD_SELF \
-({									      \
-  register pthread_descr __self;					      \
-  __asm__ ("movl %%gs:%c1,%0" : "=r" (__self)				      \
-	   : "i" (offsetof (struct _pthread_descr_struct,		      \
-			    p_header.data.self)));			      \
-  __self;								      \
-})
-
-
-/* Initialize the thread-unique value.	Two possible ways to do it.  */
-
-#define DO_MODIFY_LDT(descr, nr)					      \
-({									      \
-  struct modify_ldt_ldt_s ldt_entry =					      \
-    { nr, (unsigned long int) (descr), 0xfffff /* 4GB in pages */,	      \
-      1, 0, 0, 1, 0, 1, 0 };						      \
-  if (__modify_ldt (1, &ldt_entry, sizeof (ldt_entry)) != 0)		      \
-    abort ();								      \
-  __asm__ ("movw %w0, %%gs" : : "q" (nr * 8 + 7));				      \
-})
-
-#ifdef __PIC__
-# define USETLS_EBX_ARG "r"
-# define USETLS_LOAD_EBX "xchgl %3, %%ebx\n\t"
-#else
-# define USETLS_EBX_ARG "b"
-# define USETLS_LOAD_EBX
-#endif
-
-/* When using the new set_thread_area call, we don't need to change %gs
-   because we inherited the value set up in the main thread by TLS setup.
-   We need to extract that value and set up the same segment in this
-   thread.  */
-#if USE_TLS
-# define DO_SET_THREAD_AREA_REUSE(nr)	1
-#else
-/* Without TLS, we do the initialization of the main thread, where NR == 0.  */
-# define DO_SET_THREAD_AREA_REUSE(nr)	(!__builtin_constant_p (nr) || (nr))
-#endif
-#define DO_SET_THREAD_AREA(descr, nr) \
-({									      \
-  int __gs;								      \
-  if (DO_SET_THREAD_AREA_REUSE (nr))					      \
-    {									      \
-      __asm__ ("movw %%gs, %w0" : "=q" (__gs));				      \
-      struct modify_ldt_ldt_s ldt_entry =				      \
-	{ (__gs & 0xffff) >> 3,						      \
-	  (unsigned long int) (descr), 0xfffff /* 4GB in pages */,	      \
-	  1, 0, 0, 1, 0, 1, 0 };					      \
-									      \
-      int __result;							      \
-      __asm__ (USETLS_LOAD_EBX						      \
-	     "movl %2, %%eax\n\t"					      \
-	     "int $0x80\n\t"						      \
-	     USETLS_LOAD_EBX						      \
-	     : "&a" (__result)						      \
-	     : USETLS_EBX_ARG (&ldt_entry), "i" (__NR_set_thread_area));      \
-      if (__result == 0)						      \
-	__asm__ ("movw %w0, %%gs" :: "q" (__gs));				      \
-      else								      \
-	__gs = -1;							      \
-    }									      \
-  else									      \
-    {									      \
-      struct modify_ldt_ldt_s ldt_entry =				      \
-	{ -1,								      \
-	  (unsigned long int) (descr), 0xfffff /* 4GB in pages */,	      \
-	  1, 0, 0, 1, 0, 1, 0 };					      \
-      int __result;							      \
-      __asm__ (USETLS_LOAD_EBX						      \
-	     "movl %2, %%eax\n\t"					      \
-	     "int $0x80\n\t"						      \
-	     USETLS_LOAD_EBX						      \
-	     : "&a" (__result)						      \
-	     : USETLS_EBX_ARG (&ldt_entry), "i" (__NR_set_thread_area));      \
-      if (__result == 0)						      \
-	{								      \
-	  __gs = (ldt_entry.entry_number << 3) + 3;			      \
-	  __asm__ ("movw %w0, %%gs" : : "q" (__gs));			      \
-	}								      \
-      else								      \
-	__gs = -1;							      \
-    }									      \
-  __gs;									      \
-})
-
-#if defined __ASSUME_SET_THREAD_AREA_SYSCALL
-# define INIT_THREAD_SELF(descr, nr)	DO_SET_THREAD_AREA (descr, nr)
-#elif defined __NR_set_thread_area
-# define INIT_THREAD_SELF(descr, nr)					      \
-({									      \
-  if (__builtin_expect (__have_no_set_thread_area, 0)			      \
-      || (DO_SET_THREAD_AREA (descr, DO_SET_THREAD_AREA_REUSE (nr)) == -1     \
-	  && (__have_no_set_thread_area = 1)))				      \
-    DO_MODIFY_LDT (descr, nr);						      \
-})
-/* Defined in pspinlock.c.  */
-extern int __have_no_set_thread_area;
-#else
-# define INIT_THREAD_SELF(descr, nr)	DO_MODIFY_LDT (descr, nr)
-#endif
-
-/* Free resources associated with thread descriptor.  */
-#ifdef __ASSUME_SET_THREAD_AREA_SYSCALL
-#define FREE_THREAD(descr, nr) do { } while (0)
-#elif defined __NR_set_thread_area
-#define FREE_THREAD(descr, nr) \
-{									      \
-  int __gs;								      \
-  __asm__ __volatile__ ("movw %%gs, %w0" : "=q" (__gs));		      \
-  if (__builtin_expect (__gs & 4, 0))					      \
-    {									      \
-      struct modify_ldt_ldt_s ldt_entry =				      \
-	{ nr, 0, 0, 0, 0, 1, 0, 1, 0, 0 };				      \
-      __modify_ldt (1, &ldt_entry, sizeof (ldt_entry));			      \
-    }									      \
-}
-#else
-#define FREE_THREAD(descr, nr) \
-{									      \
-  struct modify_ldt_ldt_s ldt_entry =					      \
-    { nr, 0, 0, 0, 0, 1, 0, 1, 0, 0 };					      \
-  __modify_ldt (1, &ldt_entry, sizeof (ldt_entry));			      \
-}
-#endif
-
-/* Read member of the thread descriptor directly.  */
-#define THREAD_GETMEM(descr, member) \
-({									      \
-  __typeof__ (descr->member) __value;					      \
-  if (sizeof (__value) == 1)						      \
-    __asm__ __volatile__ ("movb %%gs:%P2,%b0"				      \
-			  : "=q" (__value)				      \
-			  : "0" (0),					      \
-			    "i" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else if (sizeof (__value) == 4)					      \
-    __asm__ __volatile__ ("movl %%gs:%P1,%0"				      \
-			  : "=r" (__value)				      \
-			  : "i" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else									      \
-    {									      \
-      if (sizeof (__value) != 8)					      \
-	/* There should not be any value with a size other than 1, 4 or 8.  */\
-	abort ();							      \
-									      \
-      __asm__ __volatile__ ("movl %%gs:%P1,%%eax\n\t"			      \
-			    "movl %%gs:%P2,%%edx"			      \
-			    : "=A" (__value)				      \
-			    : "i" (offsetof (struct _pthread_descr_struct,    \
-					     member)),			      \
-			      "i" (offsetof (struct _pthread_descr_struct,    \
-					     member) + 4));		      \
-    }									      \
-  __value;								      \
-})
-
-/* Same as THREAD_GETMEM, but the member offset can be non-constant.  */
-#define THREAD_GETMEM_NC(descr, member) \
-({									      \
-  __typeof__ (descr->member) __value;					      \
-  if (sizeof (__value) == 1)						      \
-    __asm__ __volatile__ ("movb %%gs:(%2),%b0"				      \
-			  : "=q" (__value)				      \
-			  : "0" (0),					      \
-			    "r" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else if (sizeof (__value) == 4)					      \
-    __asm__ __volatile__ ("movl %%gs:(%1),%0"				      \
-			  : "=r" (__value)				      \
-			  : "r" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else									      \
-    {									      \
-      if (sizeof (__value) != 8)					      \
-	/* There should not be any value with a size other than 1, 4 or 8.  */\
-	abort ();							      \
-									      \
-      __asm__ __volatile__ ("movl %%gs:(%1),%%eax\n\t"			      \
-			    "movl %%gs:4(%1),%%edx"			      \
-			    : "=&A" (__value)				      \
-			    : "r" (offsetof (struct _pthread_descr_struct,    \
-					     member)));			      \
-    }									      \
-  __value;								      \
-})
-
-/* Same as THREAD_SETMEM, but the member offset can be non-constant.  */
-#define THREAD_SETMEM(descr, member, value) \
-({									      \
-  __typeof__ (descr->member) __value = (value);				      \
-  if (sizeof (__value) == 1)						      \
-    __asm__ __volatile__ ("movb %0,%%gs:%P1" :				      \
-			  : "q" (__value),				      \
-			    "i" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else if (sizeof (__value) == 4)					      \
-    __asm__ __volatile__ ("movl %0,%%gs:%P1" :				      \
-			  : "r" (__value),				      \
-			    "i" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else									      \
-    {									      \
-      if (sizeof (__value) != 8)					      \
-	/* There should not be any value with a size other than 1, 4 or 8.  */\
-	abort ();							      \
-									      \
-      __asm__ __volatile__ ("movl %%eax,%%gs:%P1\n\n"			      \
-			    "movl %%edx,%%gs:%P2" :			      \
-			    : "A" (__value),				      \
-			      "i" (offsetof (struct _pthread_descr_struct,    \
-					     member)),			      \
-			      "i" (offsetof (struct _pthread_descr_struct,    \
-					     member) + 4));		      \
-    }									      \
-})
-
-/* Set member of the thread descriptor directly.  */
-#define THREAD_SETMEM_NC(descr, member, value) \
-({									      \
-  __typeof__ (descr->member) __value = (value);				      \
-  if (sizeof (__value) == 1)						      \
-    __asm__ __volatile__ ("movb %0,%%gs:(%1)" :				      \
-			  : "q" (__value),				      \
-			    "r" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else if (sizeof (__value) == 4)					      \
-    __asm__ __volatile__ ("movl %0,%%gs:(%1)" :				      \
-			  : "r" (__value),				      \
-			    "r" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else									      \
-    {									      \
-      if (sizeof (__value) != 8)					      \
-	/* There should not be any value with a size other than 1, 4 or 8.  */\
-	abort ();							      \
-									      \
-      __asm__ __volatile__ ("movl %%eax,%%gs:(%1)\n\t"			      \
-			    "movl %%edx,%%gs:4(%1)" :			      \
-			    : "A" (__value),				      \
-			      "r" (offsetof (struct _pthread_descr_struct,    \
-					     member)));			      \
-    }									      \
-})
-#endif
-
-/* We want the OS to assign stack addresses.  */
-#define FLOATING_STACKS	1
-
-/* Maximum size of the stack if the rlimit is unlimited.  */
-#define ARCH_STACK_MAX_SIZE	8*1024*1024
diff --git a/libpthread/linuxthreads.old/sysdeps/ia64/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/ia64/pt-machine.h
deleted file mode 100644
index f4c6be989..000000000
--- a/libpthread/linuxthreads.old/sysdeps/ia64/pt-machine.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   IA-64 version.
-   Copyright (C) 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#include <features.h>
-#include <ia64intrin.h>
-
-#include <sys/types.h>
-extern int __clone2 (int (*__fn) (void *__arg), void *__child_stack_base,
-                     size_t __child_stack_size, int __flags, void *__arg, ...);
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-/* Make sure gcc doesn't try to be clever and move things around on
-   us. We need to use _exactly_ the address the user gave us, not some
-   alias that contains the same information.  */
-#define __atomic_fool_gcc(x) (*(volatile struct { int a[100]; } *)x)
-
-#ifndef ELF_MACHINE_NAME
-
-#define NEED_SEPARATE_REGISTER_STACK
-
-/* We want the OS to assign stack addresses.  */
-#define FLOATING_STACKS 1
-
-/* Maximum size of the stack if the rlimit is unlimited.  */
-#define ARCH_STACK_MAX_SIZE     32*1024*1024
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.
-   r12 (sp) is the stack pointer. */
-#define CURRENT_STACK_FRAME  stack_pointer
-register char *stack_pointer __asm__ ("sp");
-
-
-/* Register r13 (tp) is reserved by the ABI as "thread pointer". */
-struct _pthread_descr_struct;
-register struct _pthread_descr_struct *__thread_self __asm__("r13");
-
-/* Return the thread descriptor for the current thread.  */
-#define THREAD_SELF  __thread_self
-
-/* Initialize the thread-unique value.  */
-#define INIT_THREAD_SELF(descr, nr)  (__thread_self = (descr))
-
-
-/* Access to data in the thread descriptor is easy.  */
-#define THREAD_GETMEM(descr, member) \
-  ((void) sizeof (descr), THREAD_SELF->member)
-#define THREAD_GETMEM_NC(descr, member) \
-  ((void) sizeof (descr), THREAD_SELF->member)
-#define THREAD_SETMEM(descr, member, value) \
-  ((void) sizeof (descr), THREAD_SELF->member = (value))
-#define THREAD_SETMEM_NC(descr, member, value) \
-  ((void) sizeof (descr), THREAD_SELF->member = (value))
-
-
-/* Memory barrier */
-#define MEMORY_BARRIER() __sync_synchronize ()
-
-
-#define HAS_COMPARE_AND_SWAP_WITH_RELEASE_SEMANTICS
-
-PT_EI int
-__compare_and_swap (long int *p, long int oldval, long int newval)
-{
-  long int readval;
-
-  __asm__ __volatile__
-       ("mov ar.ccv=%4;;\n\t"
-	"cmpxchg8.acq %0=%1,%2,ar.ccv"
-	: "=r" (readval), "=m" (__atomic_fool_gcc (p))
-	: "r"(newval), "m" (__atomic_fool_gcc (p)), "r" (oldval)
-	: "memory");
-  return readval == oldval;
-}
-
-PT_EI int
-__compare_and_swap_with_release_semantics (long int *p,
-					   long int oldval,
-					   long int newval)
-{
-  long int readval;
-
-  __asm__ __volatile__
-       ("mov ar.ccv=%4;;\n\t"
-	"cmpxchg8.rel %0=%1,%2,ar.ccv"
-	: "=r" (readval), "=m" (__atomic_fool_gcc (p))
-	: "r"(newval), "m" (__atomic_fool_gcc (p)), "r" (oldval)
-	: "memory");
-  return readval == oldval;
-}
-
-#endif /* ELF_MACHINE_NAME */
-
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
-{
-  long int ret;
-
-  __asm__ __volatile__(
-       "xchg4 %0=%1,%2"
-       : "=r"(ret), "=m"(__atomic_fool_gcc (spinlock))
-       : "r"(1), "m"(__atomic_fool_gcc (spinlock))
-       : "memory");
-
-  return ret;
-}
-
-/* Indicate that we are looping.  */
-#define BUSY_WAIT_NOP	__asm__ ("hint @pause")
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/ia64/tls.h b/libpthread/linuxthreads.old/sysdeps/ia64/tls.h
deleted file mode 100644
index a78f0ec7a..000000000
--- a/libpthread/linuxthreads.old/sysdeps/ia64/tls.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/* Definitions for thread-local data handling.  linuxthreads/IA-64 version.
-   Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _TLS_H
-#define _TLS_H
-
-#ifndef __ASSEMBLER__
-
-# include <pt-machine.h>
-# include <stdbool.h>
-# include <stddef.h>
-
-/* Type for the dtv.  */
-typedef union dtv
-{
-  size_t counter;
-  struct
-  {
-    void *val;
-    bool is_static;
-  } pointer;
-} dtv_t;
-
-#else /* __ASSEMBLER__ */
-# include <tcb-offsets.h>
-#endif /* __ASSEMBLER__ */
-
-#ifdef HAVE_TLS_SUPPORT
-
-/* Signal that TLS support is available.  */
-# define USE_TLS        1
-
-# ifndef __ASSEMBLER__
-
-typedef struct
-{
-  dtv_t *dtv;
-  void *private;
-} tcbhead_t;
-
-/* This is the size of the initial TCB.  */
-#  define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
-
-/* Alignment requirements for the initial TCB.  */
-#  define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
-
-/* This is the size of the TCB.  */
-#  define TLS_TCB_SIZE sizeof (tcbhead_t)
-
-/* This is the size we need before TCB.  */
-#  define TLS_PRE_TCB_SIZE sizeof (struct _pthread_descr_struct)
-
-/* Alignment requirements for the TCB.  */
-#  define TLS_TCB_ALIGN __alignof__ (struct _pthread_descr_struct)
-
-/* The DTV is allocated at the TP; the TCB is placed elsewhere.  */
-#  define TLS_DTV_AT_TP 1
-
-/* Install the dtv pointer.  The pointer passed is to the element with
-   index -1 which contain the length.  */
-#  define INSTALL_DTV(tcbp, dtvp) \
-  ((tcbhead_t *) (tcbp))->dtv = (dtvp) + 1
-
-/* Install new dtv for current thread.  */
-#  define INSTALL_NEW_DTV(DTV) \
-  (((tcbhead_t *)__thread_self)->dtv = (DTV))
-
-/* Return dtv of given thread descriptor.  */
-#  define GET_DTV(tcbp) \
-  (((tcbhead_t *) (tcbp))->dtv)
-
-#if defined NEED_DL_SYSINFO
-# define INIT_SYSINFO \
-  (((tcbhead_t *) __thread_self)->private = (void *) GLRO(dl_sysinfo))
-#else
-# define INIT_SYSINFO 0
-#endif
-
-/* Code to initially initialize the thread pointer.  This might need
-   special attention since 'errno' is not yet available and if the
-   operation can cause a failure 'errno' must not be touched.  */
-#  define TLS_INIT_TP(tcbp, secondcall) \
-  (__thread_self = (__typeof (__thread_self)) (tcbp), INIT_SYSINFO, NULL)
-
-/* Return the address of the dtv for the current thread.  */
-#  define THREAD_DTV() \
-  (((tcbhead_t *)__thread_self)->dtv)
-
-/* Return the thread descriptor for the current thread.  */
-#  undef THREAD_SELF
-#  define THREAD_SELF (__thread_self - 1)
-
-#  undef INIT_THREAD_SELF
-#  define INIT_THREAD_SELF(descr, nr) \
-  (__thread_self = (struct _pthread_descr_struct *)(descr) + 1)
-
-# define TLS_MULTIPLE_THREADS_IN_TCB 1
-
-# endif
-
-#else
-
-# ifndef __ASSEMBLER__
-
-typedef struct
-{
-  void *tcb;
-  dtv_t *dtv;
-  void *self;
-  int multiple_threads;
-} tcbhead_t;
-
-#  define NONTLS_INIT_TP \
-  do { 									\
-    static const tcbhead_t nontls_init_tp = { .multiple_threads = 0 };	\
-    __thread_self = (__typeof (__thread_self)) &nontls_init_tp;		\
-  } while (0)
-
-#endif
-
-#endif /* USE_TLS */
-
-#endif	/* tls.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/m68k/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/m68k/pt-machine.h
deleted file mode 100644
index 3be216524..000000000
--- a/libpthread/linuxthreads.old/sysdeps/m68k/pt-machine.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   m68k version.
-   Copyright (C) 1996, 1998, 2000, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Richard Henderson <rth@tamu.edu>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#include <features.h>
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
-{
-  char ret;
-
-  __asm__ __volatile__(
-#if !defined(__mcoldfire__) && !defined(__mcf5200__) && !defined(__m68000)
-         "tas %1; sne %0"
-#else
-         "bset #7,%1; sne %0"
-#endif
-       : "=&dm"(ret), "=m"(*spinlock)
-       : "m"(*spinlock)
-       : "cc");
-
-  return ret;
-}
-
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  stack_pointer
-register char * stack_pointer __asm__ ("%sp");
-
-
-/* Compare-and-swap for semaphores. */
-
-#if !defined(__mcoldfire__) && !defined(__mcf5200__) && !defined(__mc68000)
-#define HAS_COMPARE_AND_SWAP
-PT_EI int
-__compare_and_swap (long int *p, long int oldval, long int newval)
-{
-  char ret;
-  long int readval;
-
-  __asm__ __volatile__ ("casl %2, %3, %1; seq %0"
-			: "=dm" (ret), "=m" (*p), "=d" (readval)
-			: "d" (newval), "m" (*p), "2" (oldval));
-
-  return ret;
-}
-#endif
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/mips/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/mips/pt-machine.h
deleted file mode 100644
index caaf9a7c0..000000000
--- a/libpthread/linuxthreads.old/sysdeps/mips/pt-machine.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-
-   Copyright (C) 1996, 1997, 1998, 2000, 2002, 2003, 2004
-   Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ralf Baechle <ralf@gnu.org>.
-   Based on the Alpha version by Richard Henderson <rth@tamu.edu>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#include <features.h>
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-/* Copyright (C) 2000, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Maciej W. Rozycki <macro@ds2.pg.gda.pl>, 2000.  */
-static __inline__ int
-__NTH (_test_and_set (int *p, int v))
-{
-  int r, t;
-
-  __asm__ __volatile__
-    ("/* Inline test and set */\n"
-     "1:\n\t"
-     ".set	push\n\t"
-     ".set	mips2\n\t"
-     "ll	%0,%3\n\t"
-     "move	%1,%4\n\t"
-     "beq	%0,%4,2f\n\t"
-     "sc	%1,%2\n\t"
-     ".set	pop\n\t"
-     "beqz	%1,1b\n"
-     "2:\n\t"
-     "/* End test and set */"
-     : "=&r" (r), "=&r" (t), "=m" (*p)
-     : "m" (*p), "r" (v)
-     : "memory");
-
-  return r;
-}
-
-
-/* Spinlock implementation; required.  */
-
-PT_EI long int
-testandset (int *spinlock)
-{
-  return _test_and_set (spinlock, 1);
-}
-
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  stack_pointer
-register char * stack_pointer __asm__ ("$29");
-
-
-/* Compare-and-swap for semaphores. */
-
-#define HAS_COMPARE_AND_SWAP
-PT_EI int
-__compare_and_swap (long int *p, long int oldval, long int newval)
-{
-  long int ret, temp;
-
-  __asm__ __volatile__
-    ("/* Inline compare & swap */\n"
-     "1:\n\t"
-     ".set	push\n\t"
-     ".set	mips2\n\t"
-     "ll	%1,%5\n\t"
-     "move	%0,$0\n\t"
-     "bne	%1,%3,2f\n\t"
-     "move	%0,%4\n\t"
-     "sc	%0,%2\n\t"
-     ".set	pop\n\t"
-     "beqz	%0,1b\n"
-     "2:\n\t"
-     "/* End compare & swap */"
-     : "=&r" (ret), "=&r" (temp), "=m" (*p)
-     : "r" (oldval), "r" (newval), "m" (*p)
-     : "memory");
-
-  return ret;
-}
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/powerpc/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/powerpc/pt-machine.h
deleted file mode 100644
index aa2d206b0..000000000
--- a/libpthread/linuxthreads.old/sysdeps/powerpc/pt-machine.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   powerpc version.
-   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-/* These routines are from Appendix G of the 'PowerPC 601 RISC Microprocessor
-   User's Manual', by IBM and Motorola.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#include <features.h>
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-/* For multiprocessor systems, we want to ensure all memory accesses
-   are completed before we reset a lock.  On other systems, we still
-   need to make sure that the compiler has flushed everything to memory.  */
-#define MEMORY_BARRIER() __asm__ __volatile__ ("sync" : : : "memory")
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  stack_pointer
-register char * stack_pointer __asm__ ("r1");
-
-/* Register r2 (tp) is reserved by the ABI as "thread pointer". */
-struct _pthread_descr_struct;
-register struct _pthread_descr_struct *__thread_self __asm__("r2");
-
-/* Return the thread descriptor for the current thread.  */
-#define THREAD_SELF  __thread_self
-
-/* Initialize the thread-unique value.  */
-#define INIT_THREAD_SELF(descr, nr)  (__thread_self = (descr))
-
-/* Compare-and-swap for semaphores. */
-/* note that test-and-set(x) is the same as !compare-and-swap(x, 0, 1) */
-
-#define HAS_COMPARE_AND_SWAP_WITH_RELEASE_SEMANTICS
-#define IMPLEMENT_TAS_WITH_CAS
-
-PT_EI int
-__compare_and_swap (long int *p, long int oldval, long int newval)
-{
-  int ret;
-
-  __asm__ __volatile__ (
-	   "0:    lwarx %0,0,%1 ;"
-	   "      xor. %0,%3,%0;"
-	   "      bne 1f;"
-	   "      stwcx. %2,0,%1;"
-	   "      bne- 0b;"
-	   "1:    "
-	: "=&r"(ret)
-	: "r"(p), "r"(newval), "r"(oldval)
-	: "cr0", "memory");
-  /* This version of __compare_and_swap is to be used when acquiring
-     a lock, so we don't need to worry about whether other memory
-     operations have completed, but we do need to be sure that any loads
-     after this point really occur after we have acquired the lock.  */
-  __asm__ __volatile__ ("isync" : : : "memory");
-  return ret == 0;
-}
-
-PT_EI int
-__compare_and_swap_with_release_semantics (long int *p,
-					   long int oldval, long int newval)
-{
-  int ret;
-
-  MEMORY_BARRIER ();
-  __asm__ __volatile__ (
-	   "0:    lwarx %0,0,%1 ;"
-	   "      xor. %0,%3,%0;"
-	   "      bne 1f;"
-	   "      stwcx. %2,0,%1;"
-	   "      bne- 0b;"
-	   "1:    "
-	: "=&r"(ret)
-	: "r"(p), "r"(newval), "r"(oldval)
-	: "cr0", "memory");
-  return ret == 0;
-}
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/pthread/bits/libc-lock.h b/libpthread/linuxthreads.old/sysdeps/pthread/bits/libc-lock.h
deleted file mode 100644
index 8833e343d..000000000
--- a/libpthread/linuxthreads.old/sysdeps/pthread/bits/libc-lock.h
+++ /dev/null
@@ -1,415 +0,0 @@
-/* libc-internal interface for mutex locks.  LinuxThreads version.
-   Copyright (C) 1996,1997,1998,1999,2000,2001,2002,2003
-   	Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _BITS_LIBC_LOCK_H
-#define _BITS_LIBC_LOCK_H 1
-
-#include <pthread.h>
-
-#if defined _LIBC && !defined NOT_IN_libc
-#include <linuxthreads.old/internals.h>
-#endif
-
-/* Mutex type.  */
-#if defined(_LIBC) || defined(_IO_MTSAFE_IO)
-typedef pthread_mutex_t __libc_lock_t;
-typedef pthread_mutex_t __libc_lock_recursive_t;
-# ifdef __USE_UNIX98
-typedef pthread_rwlock_t __libc_rwlock_t;
-# else
-typedef struct __libc_rwlock_opaque__ __libc_rwlock_t;
-# endif
-typedef __libc_lock_recursive_t __rtld_lock_recursive_t;
-#else
-typedef struct __libc_lock_opaque__ __libc_lock_t;
-typedef struct __libc_lock_recursive_opaque__ __libc_lock_recursive_t;
-typedef struct __libc_rwlock_opaque__ __libc_rwlock_t;
-#endif
-
-/* Type for key to thread-specific data.  */
-typedef pthread_key_t __libc_key_t;
-
-/* Define a lock variable NAME with storage class CLASS.  The lock must be
-   initialized with __libc_lock_init before it can be used (or define it
-   with __libc_lock_define_initialized, below).  Use `extern' for CLASS to
-   declare a lock defined in another module.  In public structure
-   definitions you must use a pointer to the lock structure (i.e., NAME
-   begins with a `*'), because its storage size will not be known outside
-   of libc.  */
-#define __libc_lock_define(CLASS,NAME) \
-  CLASS __libc_lock_t NAME;
-#define __libc_rwlock_define(CLASS,NAME) \
-  CLASS __libc_rwlock_t NAME;
-#define __libc_lock_define_recursive(CLASS,NAME) \
-  CLASS __libc_lock_recursive_t NAME;
-#define __rtld_lock_define_recursive(CLASS,NAME) \
-  CLASS __rtld_lock_recursive_t NAME;
-
-/* Define an initialized lock variable NAME with storage class CLASS.
-
-   For the C library we take a deeper look at the initializer.  For
-   this implementation all fields are initialized to zero.  Therefore
-   we don't initialize the variable which allows putting it into the
-   BSS section.  (Except on PA-RISC and other odd architectures, where
-   initialized locks must be set to one due to the lack of normal
-   atomic operations.) */
-
-#if __LT_SPINLOCK_INIT == 0
-#  define __libc_lock_define_initialized(CLASS,NAME) \
-  CLASS __libc_lock_t NAME;
-#else
-#  define __libc_lock_define_initialized(CLASS,NAME) \
-  CLASS __libc_lock_t NAME = PTHREAD_MUTEX_INITIALIZER;
-#endif
-
-#define __libc_rwlock_define_initialized(CLASS,NAME) \
-  CLASS __libc_rwlock_t NAME = PTHREAD_RWLOCK_INITIALIZER;
-
-/* Define an initialized recursive lock variable NAME with storage
-   class CLASS.  */
-#define __libc_lock_define_initialized_recursive(CLASS,NAME) \
-  CLASS __libc_lock_recursive_t NAME = _LIBC_LOCK_RECURSIVE_INITIALIZER;
-#define _LIBC_LOCK_RECURSIVE_INITIALIZER \
-  {PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP}
-
-#define __rtld_lock_define_initialized_recursive(CLASS,NAME) \
-  CLASS __rtld_lock_recursive_t NAME = _RTLD_LOCK_RECURSIVE_INITIALIZER;
-#define _RTLD_LOCK_RECURSIVE_INITIALIZER \
-  {PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP}
-
-#if defined _LIBC && defined IS_IN_libpthread
-# define __libc_maybe_call(FUNC, ARGS, ELSE) FUNC ARGS
-#else
-# if defined __PIC__ || (defined _LIBC && defined SHARED)
-#  define __libc_maybe_call(FUNC, ARGS, ELSE) \
-  (__extension__ ({ __typeof (FUNC) *_fn = (FUNC); \
-                    _fn != NULL ? (*_fn) ARGS : ELSE; }))
-# else
-#  define __libc_maybe_call(FUNC, ARGS, ELSE) \
-  (FUNC != NULL ? FUNC ARGS : ELSE)
-# endif
-#endif
-#if defined _LIBC && !defined NOT_IN_libc && defined SHARED
-# define __libc_maybe_call2(FUNC, ARGS, ELSE) \
-  ({__builtin_expect (__libc_pthread_functions.ptr_##FUNC != NULL, 0) \
-    ? __libc_pthread_functions.ptr_##FUNC ARGS : ELSE; })
-#else
-# define __libc_maybe_call2(FUNC, ARGS, ELSE) __libc_maybe_call (__##FUNC, ARGS, ELSE)
-#endif
-
-/* Initialize the named lock variable, leaving it in a consistent, unlocked
-   state.  */
-#if defined _LIBC && !defined NOT_IN_libc && defined SHARED
-#define __libc_lock_init(NAME) \
-  ({									      \
-    (NAME).__m_count = 0;						      \
-    (NAME).__m_owner = NULL;						      \
-    (NAME).__m_kind = PTHREAD_MUTEX_TIMED_NP;				      \
-    (NAME).__m_lock.__status = 0;					      \
-    (NAME).__m_lock.__spinlock = __LT_SPINLOCK_INIT;			      \
-    0; })
-#else
-#define __libc_lock_init(NAME) \
-  (__libc_maybe_call2 (pthread_mutex_init, (&(NAME), NULL), 0))
-#endif
-#define __libc_rwlock_init(NAME) \
-  (__libc_maybe_call (__pthread_rwlock_init, (&(NAME), NULL), 0));
-
-/* Same as last but this time we initialize an adaptive mutex.  */
-#if defined _LIBC && !defined NOT_IN_libc && defined SHARED
-#define __libc_lock_init_adaptive(NAME) \
-  ({									      \
-    (NAME).__m_count = 0;						      \
-    (NAME).__m_owner = NULL;						      \
-    (NAME).__m_kind = PTHREAD_MUTEX_ADAPTIVE_NP;			      \
-    (NAME).__m_lock.__status = 0;					      \
-    (NAME).__m_lock.__spinlock = __LT_SPINLOCK_INIT;			      \
-    0; })
-#else
-#define __libc_lock_init_adaptive(NAME) \
-  do {									      \
-    if (__pthread_mutex_init != NULL)					      \
-      {									      \
-	pthread_mutexattr_t __attr;					      \
-	__pthread_mutexattr_init (&__attr);				      \
-	__pthread_mutexattr_settype (&__attr, PTHREAD_MUTEX_ADAPTIVE_NP);     \
-	__pthread_mutex_init (&(NAME), &__attr);			      \
-	__pthread_mutexattr_destroy (&__attr);				      \
-      }									      \
-  } while (0);
-#endif
-
-/* Same as last but this time we initialize a recursive mutex.  */
-#if defined _LIBC && !defined NOT_IN_libc && defined SHARED
-#define __libc_lock_init_recursive(NAME) \
-  ({									      \
-    (NAME).__m_count = 0;						      \
-    (NAME).__m_owner = NULL;					      \
-    (NAME).__m_kind = PTHREAD_MUTEX_RECURSIVE_NP;			      \
-    (NAME).__m_lock.__status = 0;					      \
-    (NAME).__m_lock.__spinlock = __LT_SPINLOCK_INIT;		      \
-    0; })
-#else
-#define __libc_lock_init_recursive(NAME) \
-  do {									      \
-    if (__pthread_mutex_init != NULL)					      \
-      {									      \
-	pthread_mutexattr_t __attr;					      \
-	__pthread_mutexattr_init (&__attr);				      \
-	__pthread_mutexattr_settype (&__attr, PTHREAD_MUTEX_RECURSIVE_NP); \
-	__pthread_mutex_init (&(NAME), &__attr);			      \
-	__pthread_mutexattr_destroy (&__attr);				      \
-      }									      \
-  } while (0);
-#endif
-#define __rtld_lock_init_recursive(NAME) \
-  __libc_lock_init_recursive (NAME)
-
-/* Finalize the named lock variable, which must be locked.  It cannot be
-   used again until __libc_lock_init is called again on it.  This must be
-   called on a lock variable before the containing storage is reused.  */
-#define __libc_lock_fini(NAME) \
-  (__libc_maybe_call2 (pthread_mutex_destroy, (&(NAME)), 0));
-#define __libc_rwlock_fini(NAME) \
-  (__libc_maybe_call (__pthread_rwlock_destroy, (&(NAME)), 0));
-
-/* Finalize recursive named lock.  */
-#define __libc_lock_fini_recursive(NAME) __libc_lock_fini ((NAME).mutex)
-#define __rtld_lock_fini_recursive(NAME) __libc_lock_fini_recursive (NAME)
-
-/* Lock the named lock variable.  */
-#define __libc_lock_lock(NAME) \
-  (__libc_maybe_call2 (pthread_mutex_lock, (&(NAME)), 0));
-#define __libc_rwlock_rdlock(NAME) \
-  (__libc_maybe_call (__pthread_rwlock_rdlock, (&(NAME)), 0));
-#define __libc_rwlock_wrlock(NAME) \
-  (__libc_maybe_call (__pthread_rwlock_wrlock, (&(NAME)), 0));
-
-/* Lock the recursive named lock variable.  */
-#define __libc_lock_lock_recursive(NAME) __libc_lock_lock ((NAME).mutex)
-
-/* Try to lock the named lock variable.  */
-#define __libc_lock_trylock(NAME) \
-  (__libc_maybe_call2 (pthread_mutex_trylock, (&(NAME)), 0))
-#define __libc_rwlock_tryrdlock(NAME) \
-  (__libc_maybe_call (__pthread_rwlock_tryrdlock, (&(NAME)), 0))
-#define __libc_rwlock_trywrlock(NAME) \
-  (__libc_maybe_call (__pthread_rwlock_trywrlock, (&(NAME)), 0))
-
-/* Try to lock the recursive named lock variable.  */
-#define __libc_lock_trylock_recursive(NAME) __libc_lock_trylock ((NAME).mutex)
-#define __rtld_lock_trylock_recursive(NAME) \
-  __libc_lock_trylock_recursive (NAME)
-
-/* Unlock the named lock variable.  */
-#define __libc_lock_unlock(NAME) \
-  (__libc_maybe_call2 (pthread_mutex_unlock, (&(NAME)), 0));
-#define __libc_rwlock_unlock(NAME) \
-  (__libc_maybe_call (__pthread_rwlock_unlock, (&(NAME)), 0));
-
-/* Unlock the recursive named lock variable.  */
-#define __libc_lock_unlock_recursive(NAME) __libc_lock_unlock ((NAME).mutex)
-
-/* Define once control variable.  */
-#if PTHREAD_ONCE_INIT == 0
-/* Special case for static variables where we can avoid the initialization
-   if it is zero.  */
-# define __libc_once_define(CLASS, NAME) \
-  CLASS pthread_once_t NAME
-#else
-# define __libc_once_define(CLASS, NAME) \
-  CLASS pthread_once_t NAME = PTHREAD_ONCE_INIT
-#endif
-
-/* Call handler iff the first call.  */
-#define __libc_once(ONCE_CONTROL, INIT_FUNCTION) \
-  do {									      \
-    if (__pthread_once != NULL)						      \
-      __pthread_once (&(ONCE_CONTROL), (INIT_FUNCTION));		      \
-    else if ((ONCE_CONTROL) == PTHREAD_ONCE_INIT) {			      \
-      INIT_FUNCTION ();							      \
-      (ONCE_CONTROL) = !PTHREAD_ONCE_INIT;				      \
-    }									      \
-  } while (0)
-
-
-/* Start critical region with cleanup.  */
-#define __libc_cleanup_region_start(DOIT, FCT, ARG) \
-  { struct _pthread_cleanup_buffer _buffer;				      \
-    int _avail = (DOIT) && _pthread_cleanup_push_defer != NULL;		      \
-    if (_avail) {							      \
-      _pthread_cleanup_push_defer (&_buffer, (FCT), (ARG));		      \
-    }
-
-/* End critical region with cleanup.  */
-#define __libc_cleanup_region_end(DOIT) \
-    if (_avail) {							      \
-      _pthread_cleanup_pop_restore (&_buffer, (DOIT));			      \
-    }									      \
-  }
-
-/* Sometimes we have to exit the block in the middle.  */
-#define __libc_cleanup_end(DOIT) \
-    if (_avail) {							      \
-      _pthread_cleanup_pop_restore (&_buffer, (DOIT));			      \
-    }
-
-#if 0
-#define __libc_cleanup_push(fct, arg) \
-    { struct _pthread_cleanup_buffer _buffer; 				      \
-    __libc_maybe_call (_pthread_cleanup_push, (&_buffer, (fct), (arg)), 0)
-
-#define __libc_cleanup_pop(execute) \
-    __libc_maybe_call (_pthread_cleanup_pop, (&_buffer, execute), 0);	      \
-    }
-#endif
-
-/* Create thread-specific key.  */
-#define __libc_key_create(KEY, DESTRUCTOR) \
-  (__libc_maybe_call (__pthread_key_create, (KEY, DESTRUCTOR), 1))
-
-/* Get thread-specific data.  */
-#define __libc_getspecific(KEY) \
-  (__libc_maybe_call (__pthread_getspecific, (KEY), NULL))
-
-/* Set thread-specific data.  */
-#define __libc_setspecific(KEY, VALUE) \
-  (__libc_maybe_call (__pthread_setspecific, (KEY, VALUE), 0))
-
-
-/* Register handlers to execute before and after `fork'.  */
-#define __libc_atfork(PREPARE, PARENT, CHILD) \
-  (__libc_maybe_call (__pthread_atfork, (PREPARE, PARENT, CHILD), 0))
-
-/* Functions that are used by this file and are internal to the GNU C
-   library.  */
-
-extern int __pthread_mutex_init (pthread_mutex_t *__mutex,
-				 const pthread_mutexattr_t *__mutex_attr);
-
-extern int __pthread_mutex_destroy (pthread_mutex_t *__mutex);
-
-extern int __pthread_mutex_trylock (pthread_mutex_t *__mutex);
-
-extern int __pthread_mutex_lock (pthread_mutex_t *__mutex);
-
-extern int __pthread_mutex_unlock (pthread_mutex_t *__mutex);
-
-extern int __pthread_mutexattr_init (pthread_mutexattr_t *__attr);
-
-extern int __pthread_mutexattr_destroy (pthread_mutexattr_t *__attr);
-
-extern int __pthread_mutexattr_settype (pthread_mutexattr_t *__attr,
-					int __kind);
-
-#ifdef __USE_UNIX98
-extern int __pthread_rwlock_init (pthread_rwlock_t *__rwlock,
-				  const pthread_rwlockattr_t *__attr);
-
-extern int __pthread_rwlock_destroy (pthread_rwlock_t *__rwlock);
-
-extern int __pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock);
-
-extern int __pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock);
-
-extern int __pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock);
-
-extern int __pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock);
-
-extern int __pthread_rwlock_unlock (pthread_rwlock_t *__rwlock);
-#endif
-
-extern int __pthread_key_create (pthread_key_t *__key,
-				 void (*__destr_function) (void *));
-
-extern int __pthread_setspecific (pthread_key_t __key,
-				  const void *__pointer);
-
-extern void *__pthread_getspecific (pthread_key_t __key);
-
-extern int __pthread_once (pthread_once_t *__once_control,
-			   void (*__init_routine) (void));
-
-extern int __pthread_atfork (void (*__prepare) (void),
-			     void (*__parent) (void),
-			     void (*__child) (void));
-
-
-
-/* Make the pthread functions weak so that we can elide them from
-   single-threaded processes.  */
-#ifndef __NO_WEAK_PTHREAD_ALIASES
-# ifdef weak_extern
-#   define BP_SYM(sym) sym
-weak_extern (BP_SYM (__pthread_mutex_init))
-weak_extern (BP_SYM (__pthread_mutex_destroy))
-weak_extern (BP_SYM (__pthread_mutex_lock))
-weak_extern (BP_SYM (__pthread_mutex_trylock))
-weak_extern (BP_SYM (__pthread_mutex_unlock))
-weak_extern (BP_SYM (__pthread_mutexattr_init))
-weak_extern (BP_SYM (__pthread_mutexattr_destroy))
-weak_extern (BP_SYM (__pthread_mutexattr_settype))
-weak_extern (BP_SYM (__pthread_rwlock_init))
-weak_extern (BP_SYM (__pthread_rwlock_destroy))
-weak_extern (BP_SYM (__pthread_rwlock_rdlock))
-weak_extern (BP_SYM (__pthread_rwlock_tryrdlock))
-weak_extern (BP_SYM (__pthread_rwlock_wrlock))
-weak_extern (BP_SYM (__pthread_rwlock_trywrlock))
-weak_extern (BP_SYM (__pthread_rwlock_unlock))
-weak_extern (BP_SYM (__pthread_key_create))
-weak_extern (BP_SYM (__pthread_setspecific))
-weak_extern (BP_SYM (__pthread_getspecific))
-weak_extern (BP_SYM (__pthread_once))
-weak_extern (__pthread_atfork)
-weak_extern (BP_SYM (_pthread_cleanup_push))
-weak_extern (BP_SYM (_pthread_cleanup_pop))
-weak_extern (BP_SYM (_pthread_cleanup_push_defer))
-weak_extern (BP_SYM (_pthread_cleanup_pop_restore))
-# else
-#  pragma weak __pthread_mutex_init
-#  pragma weak __pthread_mutex_destroy
-#  pragma weak __pthread_mutex_lock
-#  pragma weak __pthread_mutex_trylock
-#  pragma weak __pthread_mutex_unlock
-#  pragma weak __pthread_mutexattr_init
-#  pragma weak __pthread_mutexattr_destroy
-#  pragma weak __pthread_mutexattr_settype
-#  pragma weak __pthread_rwlock_destroy
-#  pragma weak __pthread_rwlock_rdlock
-#  pragma weak __pthread_rwlock_tryrdlock
-#  pragma weak __pthread_rwlock_wrlock
-#  pragma weak __pthread_rwlock_trywrlock
-#  pragma weak __pthread_rwlock_unlock
-#  pragma weak __pthread_key_create
-#  pragma weak __pthread_setspecific
-#  pragma weak __pthread_getspecific
-#  pragma weak __pthread_once
-#  pragma weak __pthread_atfork
-#  pragma weak _pthread_cleanup_push_defer
-#  pragma weak _pthread_cleanup_pop_restore
-#  pragma weak _pthread_cleanup_push
-#  pragma weak _pthread_cleanup_pop
-# endif
-#endif
-
-/* We need portable names for some functions.  E.g., when they are
-   used as argument to __libc_cleanup_region_start.  */
-#define __libc_mutex_unlock __pthread_mutex_unlock
-
-#endif	/* bits/libc-lock.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/pthread/bits/libc-tsd.h b/libpthread/linuxthreads.old/sysdeps/pthread/bits/libc-tsd.h
deleted file mode 100644
index 97af75ebf..000000000
--- a/libpthread/linuxthreads.old/sysdeps/pthread/bits/libc-tsd.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* libc-internal interface for thread-specific data.  LinuxThreads version.
-   Copyright (C) 1997-2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _BITS_LIBC_TSD_H
-#define _BITS_LIBC_TSD_H 1
-
-/* Fast thread-specific data internal to libc.  */
-enum __libc_tsd_key_t { _LIBC_TSD_KEY_MALLOC = 0,
-			_LIBC_TSD_KEY_DL_ERROR,
-			_LIBC_TSD_KEY_RPC_VARS,
-			_LIBC_TSD_KEY_LOCALE,
-			_LIBC_TSD_KEY_CTYPE_B,
-			_LIBC_TSD_KEY_CTYPE_TOLOWER,
-			_LIBC_TSD_KEY_CTYPE_TOUPPER,
-			_LIBC_TSD_KEY_N };
-
-#include <features.h>
-#include <linuxthreads.old/internals.h>
-
-#ifdef __UCLIBC_HAS_TLS__
-#include <tls.h>
-
-/* When __thread works, the generic definition is what we want.  */
-# include <sysdeps/generic/bits/libc-tsd.h>
-
-#else
-
-# include <bits/libc-lock.h>
-
-# ifndef SHARED
-extern void ** __pthread_internal_tsd_address (int);
-extern void *__pthread_internal_tsd_get (int);
-extern int __pthread_internal_tsd_set (int, const void *);
-
-weak_extern (__pthread_internal_tsd_address)
-weak_extern (__pthread_internal_tsd_get)
-weak_extern (__pthread_internal_tsd_set)
-# endif
-
-#define __libc_tsd_define(CLASS, KEY)	CLASS void *__libc_tsd_##KEY##_data;
-#define __libc_tsd_address(KEY) \
-  __libc_maybe_call2 (pthread_internal_tsd_address,			\
-		      (_LIBC_TSD_KEY_##KEY), &__libc_tsd_##KEY##_data)
-#define __libc_tsd_get(KEY) \
-  __libc_maybe_call2 (pthread_internal_tsd_get,				\
-		      (_LIBC_TSD_KEY_##KEY), __libc_tsd_##KEY##_data)
-#define __libc_tsd_set(KEY, VALUE) \
-  __libc_maybe_call2 (pthread_internal_tsd_set,				\
-		      (_LIBC_TSD_KEY_##KEY, (VALUE)),			\
-		       (__libc_tsd_##KEY##_data = (VALUE), 0))
-
-#endif
-
-#endif	/* bits/libc-tsd.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/pthread/bits/pthreadtypes.h b/libpthread/linuxthreads.old/sysdeps/pthread/bits/pthreadtypes.h
deleted file mode 100644
index 3eb592919..000000000
--- a/libpthread/linuxthreads.old/sysdeps/pthread/bits/pthreadtypes.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-#if !defined _BITS_TYPES_H && !defined _PTHREAD_H
-# error "Never include <bits/pthreadtypes.h> directly; use <sys/types.h> instead."
-#endif
-
-#ifndef _BITS_PTHREADTYPES_H
-#define _BITS_PTHREADTYPES_H	1
-
-#define __need_size_t
-#include <stddef.h>
-
-#define __need_schedparam
-#include <bits/sched.h>
-
-/* Fast locks (not abstract because mutexes and conditions aren't abstract). */
-struct _pthread_fastlock
-{
-  long int __status;   /* "Free" or "taken" or head of waiting list */
-  int __spinlock;      /* Used by compare_and_swap emulation. Also,
-			  adaptive SMP lock stores spin count here. */
-};
-
-#ifndef _PTHREAD_DESCR_DEFINED
-/* Thread descriptors */
-typedef struct _pthread_descr_struct *_pthread_descr;
-# define _PTHREAD_DESCR_DEFINED
-#endif
-
-
-/* Attributes for threads.  */
-typedef struct __pthread_attr_s
-{
-  int __detachstate;
-  int __schedpolicy;
-  struct __sched_param __schedparam;
-  int __inheritsched;
-  int __scope;
-  size_t __guardsize;
-  int __stackaddr_set;
-  void *__stackaddr;
-  size_t __stacksize;
-} pthread_attr_t;
-
-
-/* Conditions (not abstract because of PTHREAD_COND_INITIALIZER */
-typedef struct
-{
-  struct _pthread_fastlock __c_lock; /* Protect against concurrent access */
-  _pthread_descr __c_waiting;        /* Threads waiting on this condition */
-} pthread_cond_t;
-
-
-/* Attribute for conditionally variables.  */
-typedef struct
-{
-  int __dummy;
-} pthread_condattr_t;
-
-/* Keys for thread-specific data */
-typedef unsigned int pthread_key_t;
-
-
-/* Mutexes (not abstract because of PTHREAD_MUTEX_INITIALIZER).  */
-/* (The layout is unnatural to maintain binary compatibility
-    with earlier releases of LinuxThreads.) */
-typedef struct
-{
-  int __m_reserved;               /* Reserved for future use */
-  int __m_count;                  /* Depth of recursive locking */
-  _pthread_descr __m_owner;       /* Owner thread (if recursive or errcheck) */
-  int __m_kind;                   /* Mutex kind: fast, recursive or errcheck */
-  struct _pthread_fastlock __m_lock; /* Underlying fast lock */
-} pthread_mutex_t;
-
-
-/* Attribute for mutex.  */
-typedef struct
-{
-  int __mutexkind;
-} pthread_mutexattr_t;
-
-
-/* Once-only execution */
-typedef int pthread_once_t;
-
-
-#if defined __USE_UNIX98 || defined __USE_XOPEN2K
-/* Read-write locks.  */
-typedef struct _pthread_rwlock_t
-{
-  struct _pthread_fastlock __rw_lock; /* Lock to guarantee mutual exclusion */
-  int __rw_readers;                   /* Number of readers */
-  _pthread_descr __rw_writer;         /* Identity of writer, or NULL if none */
-  _pthread_descr __rw_read_waiting;   /* Threads waiting for reading */
-  _pthread_descr __rw_write_waiting;  /* Threads waiting for writing */
-  int __rw_kind;                      /* Reader/Writer preference selection */
-  int __rw_pshared;                   /* Shared between processes or not */
-} pthread_rwlock_t;
-
-
-/* Attribute for read-write locks.  */
-typedef struct
-{
-  int __lockkind;
-  int __pshared;
-} pthread_rwlockattr_t;
-#endif
-
-#ifdef __USE_XOPEN2K
-/* POSIX spinlock data type.  */
-typedef volatile int pthread_spinlock_t;
-
-/* POSIX barrier. */
-typedef struct {
-  struct _pthread_fastlock __ba_lock; /* Lock to guarantee mutual exclusion */
-  int __ba_required;                  /* Threads needed for completion */
-  int __ba_present;                   /* Threads waiting */
-  _pthread_descr __ba_waiting;        /* Queue of waiting threads */
-} pthread_barrier_t;
-
-/* barrier attribute */
-typedef struct {
-  int __pshared;
-} pthread_barrierattr_t;
-
-#endif
-
-
-/* Thread identifiers */
-typedef unsigned long int pthread_t;
-
-#endif	/* bits/pthreadtypes.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/pthread/not-cancel.h b/libpthread/linuxthreads.old/sysdeps/pthread/not-cancel.h
deleted file mode 100644
index bbdb0739c..000000000
--- a/libpthread/linuxthreads.old/sysdeps/pthread/not-cancel.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/* Uncancelable versions of cancelable interfaces.  Linux version.
-   Copyright (C) 2003, 2006 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sys/types.h>
-#include <sysdep.h>
-
-/* Uncancelable open.  */
-#if defined __NR_openat && !defined __NR_open
-#define open_not_cancel(name, flags, mode) \
-	INLINE_SYSCALL (openat, 4, AT_FDCWD, (const char *) (name), \
-		(flags), (mode))
-#define open_not_cancel_2(name, flags) \
-	INLINE_SYSCALL (openat, 3, AT_FDCWD, (const char *) (name), \
-		(flags))
-#else
-#define open_not_cancel(name, flags, mode) \
-   INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
-#define open_not_cancel_2(name, flags) \
-   INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
-#endif
-
-/* Uncancelable openat.  */
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-extern int __openat_nocancel (int fd, const char *fname, int oflag,
-			      mode_t mode) attribute_hidden;
-extern int __openat64_nocancel (int fd, const char *fname, int oflag,
-				mode_t mode) attribute_hidden;
-#else
-# define __openat_nocancel(fd, fname, oflag, mode) \
-  openat (fd, fname, oflag, mode)
-# define __openat64_nocancel(fd, fname, oflag, mode) \
-  openat64 (fd, fname, oflag, mode)
-#endif
-
-#define openat_not_cancel(fd, fname, oflag, mode) \
-  __openat_nocancel (fd, fname, oflag, mode)
-#define openat_not_cancel_3(fd, fname, oflag) \
-  __openat_nocancel (fd, fname, oflag, 0)
-#define openat64_not_cancel(fd, fname, oflag, mode) \
-  __openat64_nocancel (fd, fname, oflag, mode)
-#define openat64_not_cancel_3(fd, fname, oflag) \
-  __openat64_nocancel (fd, fname, oflag, 0)
-
-/* Uncancelable close.  */
-#define close_not_cancel(fd) \
-  INLINE_SYSCALL (close, 1, fd)
-#define close_not_cancel_no_status(fd) \
-  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
-	    INTERNAL_SYSCALL (close, err, 1, (fd)); })
-
-/* Uncancelable read.  */
-#define read_not_cancel(fd, buf, n) \
-  INLINE_SYSCALL (read, 3, (fd), (buf), (n))
-
-/* Uncancelable write.  */
-#define write_not_cancel(fd, buf, n) \
-  INLINE_SYSCALL (write, 3, (fd), (buf), (n))
-
-/* Uncancelable writev.  */
-#define writev_not_cancel_no_status(fd, iov, n) \
-  (void) ({ INTERNAL_SYSCALL_DECL (err);				      \
-	    INTERNAL_SYSCALL (writev, err, 3, (fd), (iov), (n)); })
-
-/* Uncancelable fcntl.  */
-#define fcntl_not_cancel(fd, cmd, val) \
-  __fcntl_nocancel (fd, cmd, val)
-
-/* Uncancelable waitpid.  */
-#ifdef __NR_waitpid
-# define waitpid_not_cancel(pid, stat_loc, options) \
-  INLINE_SYSCALL (waitpid, 3, pid, stat_loc, options)
-#else
-# define waitpid_not_cancel(pid, stat_loc, options) \
-  INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL)
-#endif
-
-/* Uncancelable pause.  */
-#ifdef __NR_pause
-# define pause_not_cancel() \
-  INLINE_SYSCALL (pause, 0)
-#else
-# define pause_not_cancel() \
-  __pause_nocancel ()
-#endif
-
-/* Uncancelable nanosleep.  */
-#ifdef __NR_nanosleep
-# define nanosleep_not_cancel(requested_time, remaining) \
-  INLINE_SYSCALL (nanosleep, 2, requested_time, remaining)
-#else
-# define nanosleep_not_cancel(requested_time, remaining) \
-  __nanosleep_nocancel (requested_time, remaining)
-#endif
-
-/* Uncancelable sigsuspend.  */
-#define sigsuspend_not_cancel(set) \
-  __sigsuspend_nocancel (set)
diff --git a/libpthread/linuxthreads.old/sysdeps/pthread/pthread-functions.h b/libpthread/linuxthreads.old/sysdeps/pthread/pthread-functions.h
deleted file mode 100644
index 2afaa52e8..000000000
--- a/libpthread/linuxthreads.old/sysdeps/pthread/pthread-functions.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/* Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PTHREAD_FUNCTIONS_H
-#define _PTHREAD_FUNCTIONS_H	1
-
-#include <pthread.h>
-#if 0
-#include <setjmp.h>
-#include <linuxthreads.old/internals.h>
-
-struct fork_block;
-#endif
-
-/* Data type shared with libc.  The libc uses it to pass on calls to
-   the thread functions.  Wine pokes directly into this structure,
-   so if possible avoid breaking it and append new hooks to the end.  */
-struct pthread_functions
-{
-#if 0
-  pid_t (*ptr_pthread_fork) (struct fork_block *);
-#endif
-  int (*ptr_pthread_attr_destroy) (pthread_attr_t *);
-  int (*ptr_pthread_attr_init) (pthread_attr_t *);
-  int (*ptr_pthread_attr_getdetachstate) (const pthread_attr_t *, int *);
-  int (*ptr_pthread_attr_setdetachstate) (pthread_attr_t *, int);
-  int (*ptr_pthread_attr_getinheritsched) (const pthread_attr_t *, int *);
-  int (*ptr_pthread_attr_setinheritsched) (pthread_attr_t *, int);
-  int (*ptr_pthread_attr_getschedparam) (const pthread_attr_t *,
-					 struct sched_param *);
-  int (*ptr_pthread_attr_setschedparam) (pthread_attr_t *,
-					 const struct sched_param *);
-  int (*ptr_pthread_attr_getschedpolicy) (const pthread_attr_t *, int *);
-  int (*ptr_pthread_attr_setschedpolicy) (pthread_attr_t *, int);
-  int (*ptr_pthread_attr_getscope) (const pthread_attr_t *, int *);
-  int (*ptr_pthread_attr_setscope) (pthread_attr_t *, int);
-  int (*ptr_pthread_condattr_destroy) (pthread_condattr_t *);
-  int (*ptr_pthread_condattr_init) (pthread_condattr_t *);
-  int (*ptr_pthread_cond_broadcast) (pthread_cond_t *);
-  int (*ptr_pthread_cond_destroy) (pthread_cond_t *);
-  int (*ptr_pthread_cond_init) (pthread_cond_t *,
-				  const pthread_condattr_t *);
-  int (*ptr_pthread_cond_signal) (pthread_cond_t *);
-  int (*ptr_pthread_cond_wait) (pthread_cond_t *, pthread_mutex_t *);
-  int (*ptr_pthread_equal) (pthread_t, pthread_t);
-  void (*ptr___pthread_exit) (void *);
-  int (*ptr_pthread_getschedparam) (pthread_t, int *, struct sched_param *);
-  int (*ptr_pthread_setschedparam) (pthread_t, int,
-				    const struct sched_param *);
-  int (*ptr_pthread_mutex_destroy) (pthread_mutex_t *);
-  int (*ptr_pthread_mutex_init) (pthread_mutex_t *,
-				 const pthread_mutexattr_t *);
-  int (*ptr_pthread_mutex_lock) (pthread_mutex_t *);
-  int (*ptr_pthread_mutex_trylock) (pthread_mutex_t *);
-  int (*ptr_pthread_mutex_unlock) (pthread_mutex_t *);
-  pthread_t (*ptr_pthread_self) (void);
-  int (*ptr_pthread_setcancelstate) (int, int *);
-  int (*ptr_pthread_setcanceltype) (int, int *);
-#if 0
-  void (*ptr_pthread_do_exit) (void *retval, char *currentframe);
-  void (*ptr_pthread_cleanup_upto) (__jmp_buf target,
-				    char *targetframe);
-  pthread_descr (*ptr_pthread_thread_self) (void);
-#endif
-#if !defined __UCLIBC_HAS_TLS__ && defined __UCLIBC_HAS_RPC__
-  int (*ptr_pthread_internal_tsd_set) (int key, const void *pointer);
-  void * (*ptr_pthread_internal_tsd_get) (int key);
-  void ** __attribute__ ((__const__))
-    (*ptr_pthread_internal_tsd_address) (int key);
-#endif
-#if 0
-  int (*ptr_pthread_sigaction) (int sig, const struct sigaction * act,
-				struct sigaction *oact);
-  int (*ptr_pthread_sigwait) (const sigset_t *set, int *sig);
-  int (*ptr_pthread_raise) (int sig);
-#endif
-  int (*ptr_pthread_cond_timedwait) (pthread_cond_t *, pthread_mutex_t *,
-				       const struct timespec *);
-#if 0
-  void (*ptr__pthread_cleanup_push) (struct _pthread_cleanup_buffer * buffer,
-				     void (*routine)(void *), void * arg);
-#endif
-  void (*ptr__pthread_cleanup_push_defer) (struct _pthread_cleanup_buffer * buffer,
-					   void (*routine)(void *), void * arg);
-#if 0
-  void (*ptr__pthread_cleanup_pop) (struct _pthread_cleanup_buffer * buffer,
-				    int execute);
-#endif
-  void (*ptr__pthread_cleanup_pop_restore) (struct _pthread_cleanup_buffer * buffer,
-					    int execute);
-};
-
-/* Variable in libc.so.  */
-extern struct pthread_functions __libc_pthread_functions attribute_hidden;
-
-extern int * __libc_pthread_init (const struct pthread_functions *functions);
-
-#endif	/* pthread-functions.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/pthread/pthread.h b/libpthread/linuxthreads.old/sysdeps/pthread/pthread.h
deleted file mode 100644
index 46c1010c6..000000000
--- a/libpthread/linuxthreads.old/sysdeps/pthread/pthread.h
+++ /dev/null
@@ -1,710 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-#ifndef _PTHREAD_H
-#define _PTHREAD_H	1
-
-#include <features.h>
-
-#include <sched.h>
-#include <time.h>
-
-#define __need_sigset_t
-#include <signal.h>
-#include <bits/pthreadtypes.h>
-#include <bits/initspin.h>
-
-
-__BEGIN_DECLS
-
-/* Initializers.  */
-
-#define PTHREAD_MUTEX_INITIALIZER \
-  {0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __LOCK_INITIALIZER}
-#ifdef __USE_GNU
-# define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \
-  {0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, __LOCK_INITIALIZER}
-# define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP \
-  {0, 0, 0, PTHREAD_MUTEX_ERRORCHECK_NP, __LOCK_INITIALIZER}
-# define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP \
-  {0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __LOCK_INITIALIZER}
-#endif
-
-#define PTHREAD_COND_INITIALIZER {__LOCK_INITIALIZER, 0}
-
-#if defined __USE_UNIX98 || defined __USE_XOPEN2K
-# define PTHREAD_RWLOCK_INITIALIZER \
-  { __LOCK_INITIALIZER, 0, NULL, NULL, NULL,				      \
-    PTHREAD_RWLOCK_DEFAULT_NP, PTHREAD_PROCESS_PRIVATE }
-#endif
-#ifdef __USE_GNU
-# define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP \
-  { __LOCK_INITIALIZER, 0, NULL, NULL, NULL,				      \
-    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, PTHREAD_PROCESS_PRIVATE }
-#endif
-
-/* Values for attributes.  */
-
-enum
-{
-  PTHREAD_CREATE_JOINABLE,
-#define PTHREAD_CREATE_JOINABLE	PTHREAD_CREATE_JOINABLE
-  PTHREAD_CREATE_DETACHED
-#define PTHREAD_CREATE_DETACHED	PTHREAD_CREATE_DETACHED
-};
-
-enum
-{
-  PTHREAD_INHERIT_SCHED,
-#define PTHREAD_INHERIT_SCHED	PTHREAD_INHERIT_SCHED
-  PTHREAD_EXPLICIT_SCHED
-#define PTHREAD_EXPLICIT_SCHED	PTHREAD_EXPLICIT_SCHED
-};
-
-enum
-{
-  PTHREAD_SCOPE_SYSTEM,
-#define PTHREAD_SCOPE_SYSTEM	PTHREAD_SCOPE_SYSTEM
-  PTHREAD_SCOPE_PROCESS
-#define PTHREAD_SCOPE_PROCESS	PTHREAD_SCOPE_PROCESS
-};
-
-enum
-{
-  PTHREAD_MUTEX_ADAPTIVE_NP,
-  PTHREAD_MUTEX_RECURSIVE_NP,
-  PTHREAD_MUTEX_ERRORCHECK_NP,
-  PTHREAD_MUTEX_TIMED_NP
-#ifdef __USE_UNIX98
-  ,
-  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_ADAPTIVE_NP,
-  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
-  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
-  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
-#endif
-#ifdef __USE_GNU
-  /* For compatibility.  */
-  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_ADAPTIVE_NP
-#endif
-};
-
-enum
-{
-  PTHREAD_PROCESS_PRIVATE,
-#define PTHREAD_PROCESS_PRIVATE	PTHREAD_PROCESS_PRIVATE
-  PTHREAD_PROCESS_SHARED
-#define PTHREAD_PROCESS_SHARED	PTHREAD_PROCESS_SHARED
-};
-
-#if defined __USE_UNIX98 || defined __USE_XOPEN2K
-enum
-{
-  PTHREAD_RWLOCK_PREFER_READER_NP,
-  PTHREAD_RWLOCK_PREFER_WRITER_NP,
-  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
-  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_WRITER_NP
-};
-#endif	/* Unix98 */
-
-#define PTHREAD_ONCE_INIT 0
-
-/* Special constants */
-
-#ifdef __USE_XOPEN2K
-/* -1 is distinct from 0 and all errno constants */
-# define PTHREAD_BARRIER_SERIAL_THREAD -1
-#endif
-
-/* Cleanup buffers */
-
-struct _pthread_cleanup_buffer
-{
-  void (*__routine) (void *);		  /* Function to call.  */
-  void *__arg;				  /* Its argument.  */
-  int __canceltype;			  /* Saved cancellation type. */
-  struct _pthread_cleanup_buffer *__prev; /* Chaining of cleanup functions.  */
-};
-
-/* Cancellation */
-
-enum
-{
-  PTHREAD_CANCEL_ENABLE,
-#define PTHREAD_CANCEL_ENABLE	PTHREAD_CANCEL_ENABLE
-  PTHREAD_CANCEL_DISABLE
-#define PTHREAD_CANCEL_DISABLE	PTHREAD_CANCEL_DISABLE
-};
-enum
-{
-  PTHREAD_CANCEL_DEFERRED,
-#define PTHREAD_CANCEL_DEFERRED	PTHREAD_CANCEL_DEFERRED
-  PTHREAD_CANCEL_ASYNCHRONOUS
-#define PTHREAD_CANCEL_ASYNCHRONOUS	PTHREAD_CANCEL_ASYNCHRONOUS
-};
-#define PTHREAD_CANCELED ((void *) -1)
-
-
-/* Function for handling threads.  */
-
-/* Create a thread with given attributes ATTR (or default attributes
-   if ATTR is NULL), and call function START_ROUTINE with given
-   arguments ARG.  */
-extern int pthread_create (pthread_t *__restrict __threadp,
-			   const pthread_attr_t *__restrict __attr,
-			   void *(*__start_routine) (void *),
-			   void *__restrict __arg) __THROW;
-
-/* Obtain the identifier of the current thread.  */
-extern pthread_t pthread_self (void) __THROW;
-
-/* Compare two thread identifiers.  */
-extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) __THROW;
-
-/* Terminate calling thread.  */
-extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));
-
-/* Make calling thread wait for termination of the thread TH.  The
-   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN
-   is not NULL.  */
-extern int pthread_join (pthread_t __th, void **__thread_return);
-
-/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.
-   The resources of TH will therefore be freed immediately when it
-   terminates, instead of waiting for another thread to perform PTHREAD_JOIN
-   on it.  */
-extern int pthread_detach (pthread_t __th) __THROW;
-
-
-/* Functions for handling attributes.  */
-
-/* Initialize thread attribute *ATTR with default attributes
-   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,
-    no user-provided stack).  */
-extern int pthread_attr_init (pthread_attr_t *__attr) __THROW;
-
-/* Destroy thread attribute *ATTR.  */
-extern int pthread_attr_destroy (pthread_attr_t *__attr) __THROW;
-
-/* Set the `detachstate' attribute in *ATTR according to DETACHSTATE.  */
-extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
-					int __detachstate) __THROW;
-
-/* Return in *DETACHSTATE the `detachstate' attribute in *ATTR.  */
-extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
-					int *__detachstate) __THROW;
-
-/* Set scheduling parameters (priority, etc) in *ATTR according to PARAM.  */
-extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
-				       const struct sched_param *__restrict
-				       __param) __THROW;
-
-/* Return in *PARAM the scheduling parameters of *ATTR.  */
-extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict
-				       __attr,
-				       struct sched_param *__restrict __param)
-     __THROW;
-
-/* Set scheduling policy in *ATTR according to POLICY.  */
-extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
-     __THROW;
-
-/* Return in *POLICY the scheduling policy of *ATTR.  */
-extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
-					__attr, int *__restrict __policy)
-     __THROW;
-
-/* Set scheduling inheritance mode in *ATTR according to INHERIT.  */
-extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
-					 int __inherit) __THROW;
-
-/* Return in *INHERIT the scheduling inheritance mode of *ATTR.  */
-extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
-					 __attr, int *__restrict __inherit)
-     __THROW;
-
-/* Set scheduling contention scope in *ATTR according to SCOPE.  */
-extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
-     __THROW;
-
-/* Return in *SCOPE the scheduling contention scope of *ATTR.  */
-extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
-				  int *__restrict __scope) __THROW;
-
-#ifdef __USE_UNIX98
-/* Set the size of the guard area at the bottom of the thread.  */
-extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
-				      size_t __guardsize) __THROW;
-
-/* Get the size of the guard area at the bottom of the thread.  */
-extern int pthread_attr_getguardsize (const pthread_attr_t *__restrict
-				      __attr, size_t *__restrict __guardsize)
-     __THROW;
-#endif
-
-#if 0 /* uClibc: deprecated stuff disabled. def __UCLIBC_SUSV3_LEGACY__ */
-/* Set the starting address of the stack of the thread to be created.
-   Depending on whether the stack grows up or down the value must either
-   be higher or lower than all the address in the memory block.  The
-   minimal size of the block must be PTHREAD_STACK_SIZE.  */
-extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
-				      void *__stackaddr) __THROW;
-
-/* Return the previously set address for the stack.  */
-extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
-				      __attr, void **__restrict __stackaddr)
-     __THROW;
-#endif
-
-#ifdef __USE_XOPEN2K
-/* The following two interfaces are intended to replace the last two.  They
-   require setting the address as well as the size since only setting the
-   address will make the implementation on some architectures impossible.  */
-extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
-				  size_t __stacksize) __THROW;
-
-/* Return the previously set address for the stack.  */
-extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
-				  void **__restrict __stackaddr,
-				  size_t *__restrict __stacksize) __THROW;
-#endif
-
-/* Add information about the minimum stack size needed for the thread
-   to be started.  This size must never be less than PTHREAD_STACK_SIZE
-   and must also not exceed the system limits.  */
-extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
-				      size_t __stacksize) __THROW;
-
-/* Return the currently used minimal stack size.  */
-extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
-				      __attr, size_t *__restrict __stacksize)
-     __THROW;
-
-#if 0
-/* Not yet implemented in uClibc! */
-
-#ifdef __USE_GNU
-/* Initialize thread attribute *ATTR with attributes corresponding to the
-   already running thread TH.  It shall be called on uninitialized ATTR
-   and destroyed with pthread_attr_destroy when no longer needed.  */
-extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr) __THROW;
-#endif
-#endif
-
-/* Functions for scheduling control.  */
-
-/* Set the scheduling parameters for TARGET_THREAD according to POLICY
-   and *PARAM.  */
-extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
-				  const struct sched_param *__param)
-     __THROW;
-
-/* Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD.  */
-extern int pthread_getschedparam (pthread_t __target_thread,
-				  int *__restrict __policy,
-				  struct sched_param *__restrict __param)
-     __THROW;
-
-#ifdef __USE_UNIX98
-/* Determine level of concurrency.  */
-extern int pthread_getconcurrency (void) __THROW;
-
-/* Set new concurrency level to LEVEL.  */
-extern int pthread_setconcurrency (int __level) __THROW;
-#endif
-
-#ifdef __USE_GNU
-/* Same thing, different name */
-#define pthread_yield() sched_yield()
-#endif
-
-/* Functions for mutex handling.  */
-
-/* Initialize MUTEX using attributes in *MUTEX_ATTR, or use the
-   default values if later is NULL.  */
-extern int pthread_mutex_init (pthread_mutex_t *__restrict __mutex,
-			       const pthread_mutexattr_t *__restrict
-			       __mutex_attr) __THROW;
-
-/* Destroy MUTEX.  */
-extern int pthread_mutex_destroy (pthread_mutex_t *__mutex) __THROW;
-
-/* Try to lock MUTEX.  */
-extern int pthread_mutex_trylock (pthread_mutex_t *__mutex) __THROW;
-
-/* Wait until lock for MUTEX becomes available and lock it.  */
-extern int pthread_mutex_lock (pthread_mutex_t *__mutex) __THROW;
-
-#ifdef __USE_XOPEN2K
-/* Wait until lock becomes available, or specified time passes. */
-extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
-				    const struct timespec *__restrict
-				    __abstime) __THROW;
-#endif
-
-/* Unlock MUTEX.  */
-extern int pthread_mutex_unlock (pthread_mutex_t *__mutex) __THROW;
-
-
-/* Functions for handling mutex attributes.  */
-
-/* Initialize mutex attribute object ATTR with default attributes
-   (kind is PTHREAD_MUTEX_TIMED_NP).  */
-extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr) __THROW;
-
-/* Destroy mutex attribute object ATTR.  */
-extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr) __THROW;
-
-/* Get the process-shared flag of the mutex attribute ATTR.  */
-extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
-					 __restrict __attr,
-					 int *__restrict __pshared) __THROW;
-
-/* Set the process-shared flag of the mutex attribute ATTR.  */
-extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
-					 int __pshared) __THROW;
-
-#ifdef __USE_UNIX98
-/* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,
-   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or
-   PTHREAD_MUTEX_DEFAULT).  */
-extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
-     __THROW;
-
-/* Return in *KIND the mutex kind attribute in *ATTR.  */
-extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
-				      __attr, int *__restrict __kind) __THROW;
-#endif
-
-
-/* Functions for handling conditional variables.  */
-
-/* Initialize condition variable COND using attributes ATTR, or use
-   the default values if later is NULL.  */
-extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
-			      const pthread_condattr_t *__restrict
-			      __cond_attr) __THROW;
-libpthread_hidden_proto(pthread_cond_init)
-
-/* Destroy condition variable COND.  */
-extern int pthread_cond_destroy (pthread_cond_t *__cond) __THROW;
-libpthread_hidden_proto(pthread_cond_destroy)
-
-/* Wake up one thread waiting for condition variable COND.  */
-extern int pthread_cond_signal (pthread_cond_t *__cond) __THROW;
-libpthread_hidden_proto(pthread_cond_signal)
-
-/* Wake up all threads waiting for condition variables COND.  */
-extern int pthread_cond_broadcast (pthread_cond_t *__cond) __THROW;
-libpthread_hidden_proto(pthread_cond_broadcast)
-
-/* Wait for condition variable COND to be signaled or broadcast.
-   MUTEX is assumed to be locked before.  */
-extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
-			      pthread_mutex_t *__restrict __mutex);
-libpthread_hidden_proto(pthread_cond_wait)
-
-/* Wait for condition variable COND to be signaled or broadcast until
-   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an
-   absolute time specification; zero is the beginning of the epoch
-   (00:00:00 GMT, January 1, 1970).  */
-extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
-				   pthread_mutex_t *__restrict __mutex,
-				   const struct timespec *__restrict
-				   __abstime);
-libpthread_hidden_proto(pthread_cond_timedwait)
-
-/* Functions for handling condition variable attributes.  */
-
-/* Initialize condition variable attribute ATTR.  */
-extern int pthread_condattr_init (pthread_condattr_t *__attr) __THROW;
-libpthread_hidden_proto(pthread_condattr_init)
-
-/* Destroy condition variable attribute ATTR.  */
-extern int pthread_condattr_destroy (pthread_condattr_t *__attr) __THROW;
-libpthread_hidden_proto(pthread_condattr_destroy)
-
-/* Get the process-shared flag of the condition variable attribute ATTR.  */
-extern int pthread_condattr_getpshared (const pthread_condattr_t *
-					__restrict __attr,
-					int *__restrict __pshared) __THROW;
-
-/* Set the process-shared flag of the condition variable attribute ATTR.  */
-extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
-					int __pshared) __THROW;
-
-
-#if defined __USE_UNIX98 || defined __USE_XOPEN2K
-/* Functions for handling read-write locks.  */
-
-/* Initialize read-write lock RWLOCK using attributes ATTR, or use
-   the default values if later is NULL.  */
-extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
-				const pthread_rwlockattr_t *__restrict
-				__attr) __THROW;
-
-/* Destroy read-write lock RWLOCK.  */
-extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock) __THROW;
-
-/* Acquire read lock for RWLOCK.  */
-extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock) __THROW;
-
-/* Try to acquire read lock for RWLOCK.  */
-extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock) __THROW;
-
-# ifdef __USE_XOPEN2K
-/* Try to acquire read lock for RWLOCK or return after specfied time.  */
-extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
-				       const struct timespec *__restrict
-				       __abstime) __THROW;
-# endif
-
-/* Acquire write lock for RWLOCK.  */
-extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock) __THROW;
-
-/* Try to acquire write lock for RWLOCK.  */
-extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock) __THROW;
-
-# ifdef __USE_XOPEN2K
-/* Try to acquire write lock for RWLOCK or return after specfied time.  */
-extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
-				       const struct timespec *__restrict
-				       __abstime) __THROW;
-# endif
-
-/* Unlock RWLOCK.  */
-extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock) __THROW;
-
-
-/* Functions for handling read-write lock attributes.  */
-
-/* Initialize attribute object ATTR with default values.  */
-extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr) __THROW;
-
-/* Destroy attribute object ATTR.  */
-extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr) __THROW;
-
-/* Return current setting of process-shared attribute of ATTR in PSHARED.  */
-extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
-					  __restrict __attr,
-					  int *__restrict __pshared) __THROW;
-
-/* Set process-shared attribute of ATTR to PSHARED.  */
-extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
-					  int __pshared) __THROW;
-
-/* Return current setting of reader/writer preference.  */
-extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *__attr,
-					  int *__pref) __THROW;
-
-/* Set reader/write preference.  */
-extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
-					  int __pref) __THROW;
-#endif
-
-#if 0
-/* Not yet implemented in uClibc! */
-
-#ifdef __USE_XOPEN2K
-/* The IEEE Std. 1003.1j-2000 introduces functions to implement
-   spinlocks.  */
-
-/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can
-   be shared between different processes.  */
-extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
-     __THROW;
-
-/* Destroy the spinlock LOCK.  */
-extern int pthread_spin_destroy (pthread_spinlock_t *__lock) __THROW;
-
-/* Wait until spinlock LOCK is retrieved.  */
-extern int pthread_spin_lock (pthread_spinlock_t *__lock) __THROW;
-
-/* Try to lock spinlock LOCK.  */
-extern int pthread_spin_trylock (pthread_spinlock_t *__lock) __THROW;
-
-/* Release spinlock LOCK.  */
-extern int pthread_spin_unlock (pthread_spinlock_t *__lock) __THROW;
-
-
-/* Barriers are a also a new feature in 1003.1j-2000. */
-
-extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
-				 const pthread_barrierattr_t *__restrict
-				 __attr, unsigned int __count) __THROW;
-
-extern int pthread_barrier_destroy (pthread_barrier_t *__barrier) __THROW;
-
-extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr) __THROW;
-
-extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr) __THROW;
-
-extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
-					   __restrict __attr,
-					   int *__restrict __pshared) __THROW;
-
-extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
-					   int __pshared) __THROW;
-
-extern int pthread_barrier_wait (pthread_barrier_t *__barrier) __THROW;
-#endif
-#endif
-
-
-/* Functions for handling thread-specific data.  */
-
-/* Create a key value identifying a location in the thread-specific
-   data area.  Each thread maintains a distinct thread-specific data
-   area.  DESTR_FUNCTION, if non-NULL, is called with the value
-   associated to that key when the key is destroyed.
-   DESTR_FUNCTION is not called if the value associated is NULL when
-   the key is destroyed.  */
-extern int pthread_key_create (pthread_key_t *__key,
-			       void (*__destr_function) (void *)) __THROW;
-
-/* Destroy KEY.  */
-extern int pthread_key_delete (pthread_key_t __key) __THROW;
-
-/* Store POINTER in the thread-specific data slot identified by KEY. */
-extern int pthread_setspecific (pthread_key_t __key,
-				const void *__pointer) __THROW;
-
-/* Return current value of the thread-specific data slot identified by KEY.  */
-extern void *pthread_getspecific (pthread_key_t __key) __THROW;
-
-
-/* Functions for handling initialization.  */
-
-/* Guarantee that the initialization function INIT_ROUTINE will be called
-   only once, even if pthread_once is executed several times with the
-   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or
-   extern variable initialized to PTHREAD_ONCE_INIT.
-
-   The initialization functions might throw exception which is why
-   this function is not marked with __THROW.  */
-extern int pthread_once (pthread_once_t *__once_control,
-			 void (*__init_routine) (void));
-
-
-/* Functions for handling cancellation.  */
-
-/* Set cancelability state of current thread to STATE, returning old
-   state in *OLDSTATE if OLDSTATE is not NULL.  */
-extern int pthread_setcancelstate (int __state, int *__oldstate);
-
-/* Set cancellation state of current thread to TYPE, returning the old
-   type in *OLDTYPE if OLDTYPE is not NULL.  */
-extern int pthread_setcanceltype (int __type, int *__oldtype);
-
-/* Cancel THREAD immediately or at the next possibility.  */
-extern int pthread_cancel (pthread_t __cancelthread);
-
-/* Test for pending cancellation for the current thread and terminate
-   the thread as per pthread_exit(PTHREAD_CANCELED) if it has been
-   cancelled.  */
-extern void pthread_testcancel (void);
-
-
-/* Install a cleanup handler: ROUTINE will be called with arguments ARG
-   when the thread is cancelled or calls pthread_exit.  ROUTINE will also
-   be called with arguments ARG when the matching pthread_cleanup_pop
-   is executed with non-zero EXECUTE argument.
-   pthread_cleanup_push and pthread_cleanup_pop are macros and must always
-   be used in matching pairs at the same nesting level of braces. */
-
-#define pthread_cleanup_push(routine,arg) \
-  { struct _pthread_cleanup_buffer _buffer;				      \
-    _pthread_cleanup_push (&_buffer, (routine), (arg));
-
-extern void _pthread_cleanup_push (struct _pthread_cleanup_buffer *__buffer,
-				   void (*__routine) (void *),
-				   void *__arg) __THROW;
-
-/* Remove a cleanup handler installed by the matching pthread_cleanup_push.
-   If EXECUTE is non-zero, the handler function is called. */
-
-#define pthread_cleanup_pop(execute) \
-    _pthread_cleanup_pop (&_buffer, (execute)); }
-
-extern void _pthread_cleanup_pop (struct _pthread_cleanup_buffer *__buffer,
-				  int __execute) __THROW;
-
-/* Install a cleanup handler as pthread_cleanup_push does, but also
-   saves the current cancellation type and set it to deferred cancellation.  */
-
-#ifdef __USE_GNU
-# define pthread_cleanup_push_defer_np(routine,arg) \
-  { struct _pthread_cleanup_buffer _buffer;				      \
-    _pthread_cleanup_push_defer (&_buffer, (routine), (arg));
-
-extern void _pthread_cleanup_push_defer (struct _pthread_cleanup_buffer *__buffer,
-					 void (*__routine) (void *),
-					 void *__arg) __THROW;
-extern void __pthread_cleanup_push_defer (struct _pthread_cleanup_buffer *__buffer,
-					  void (*__routine) (void *),
-					  void *__arg) __THROW;
-
-/* Remove a cleanup handler as pthread_cleanup_pop does, but also
-   restores the cancellation type that was in effect when the matching
-   pthread_cleanup_push_defer was called.  */
-
-# define pthread_cleanup_pop_restore_np(execute) \
-  _pthread_cleanup_pop_restore (&_buffer, (execute)); }
-
-extern void _pthread_cleanup_pop_restore (struct _pthread_cleanup_buffer *__buffer,
-					  int __execute) __THROW;
-extern void __pthread_cleanup_pop_restore (struct _pthread_cleanup_buffer *__buffer,
-					   int __execute) __THROW;
-#endif
-
-
-#if 0
-/* Not yet implemented in uClibc! */
-
-#ifdef __USE_XOPEN2K
-/* Get ID of CPU-time clock for thread THREAD_ID.  */
-extern int pthread_getcpuclockid (pthread_t __thread_id,
-				  clockid_t *__clock_id) __THROW;
-#endif
-#endif
-
-
-/* Functions for handling signals.  */
-#include <bits/sigthread.h>
-
-
-/* Functions for handling process creation and process execution.  */
-
-/* Install handlers to be called when a new process is created with FORK.
-   The PREPARE handler is called in the parent process just before performing
-   FORK. The PARENT handler is called in the parent process just after FORK.
-   The CHILD handler is called in the child process.  Each of the three
-   handlers can be NULL, meaning that no handler needs to be called at that
-   point.
-   PTHREAD_ATFORK can be called several times, in which case the PREPARE
-   handlers are called in LIFO order (last added with PTHREAD_ATFORK,
-   first called before FORK), and the PARENT and CHILD handlers are called
-   in FIFO (first added, first called).  */
-
-extern int pthread_atfork (void (*__prepare) (void),
-			   void (*__parent) (void),
-			   void (*__child) (void)) __THROW;
-
-/* Terminate all threads in the program except the calling process.
-   Should be called just before invoking one of the exec*() functions.  */
-
-extern void pthread_kill_other_threads_np (void) __THROW;
-
-__END_DECLS
-
-#endif	/* pthread.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/sh/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/sh/pt-machine.h
deleted file mode 100644
index 7d1484e71..000000000
--- a/libpthread/linuxthreads.old/sysdeps/sh/pt-machine.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   SuperH version.
-   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Niibe Yutaka <gniibe@m17n.org>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#include <features.h>
-
-#ifndef __ASSEMBLER__
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-extern long int testandset (int *spinlock);
-
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
-{
-  int ret;
-
-  __asm__ __volatile__(
-       "tas.b	@%1\n\t"
-       "movt	%0"
-       : "=r" (ret)
-       : "r" (spinlock)
-       : "memory", "cc");
-
-  return (ret == 0);
-}
-
-/* We want the OS to assign stack addresses.  */
-#define FLOATING_STACKS 1
-
-/* Maximum size of the stack if the rlimit is unlimited.  */
-#define ARCH_STACK_MAX_SIZE     32*1024*1024
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  stack_pointer
-register char * stack_pointer __asm__ ("r15");
-
-/* Return the thread descriptor for the current thread.  */
-struct _pthread_descr_struct;
-#define THREAD_SELF \
-  ({ struct _pthread_descr_struct *self; \
-      __asm__("stc gbr,%0" : "=r" (self)); self;})
-
-/* Initialize the thread-unique value.  */
-#define INIT_THREAD_SELF(descr, nr) \
-  ({ __asm__ __volatile__("ldc %0,gbr" : : "r" (descr));})
-
-/* Access to data in the thread descriptor is easy.  */
-#define THREAD_GETMEM(descr, member) \
-  ((void) sizeof (descr), THREAD_SELF->member)
-#define THREAD_GETMEM_NC(descr, member) \
-  ((void) sizeof (descr), THREAD_SELF->member)
-#define THREAD_SETMEM(descr, member, value) \
-  ((void) sizeof (descr), THREAD_SELF->member = (value))
-#define THREAD_SETMEM_NC(descr, member, value) \
-  ((void) sizeof (descr), THREAD_SELF->member = (value))
-#endif /* __ASSEMBLER__ */
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/sh/tls.h b/libpthread/linuxthreads.old/sysdeps/sh/tls.h
deleted file mode 100644
index 25bef830f..000000000
--- a/libpthread/linuxthreads.old/sysdeps/sh/tls.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/* Definition for thread-local data handling.  linuxthreads/SH version.
-   Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _TLS_H
-#define _TLS_H
-
-# include <pt-machine.h>
-
-#ifndef __ASSEMBLER__
-# include <stdbool.h>
-# include <stddef.h>
-# include <stdint.h>
-
-/* Type for the dtv.  */
-typedef union dtv
-{
-  size_t counter;
-  void *pointer;
-} dtv_t;
-
-
-typedef struct
-{
-  void *tcb;		/* Pointer to the TCB.  Not necessary the
-			   thread descriptor used by libpthread.  */
-  dtv_t *dtv;
-  void *self;		/* Pointer to the thread descriptor.  */
-} tcbhead_t;
-
-
-/* We can support TLS only if the floating-stack support is available.  */
-#if defined FLOATING_STACKS && defined HAVE_TLS_SUPPORT
-
-/* Get system call information.  */
-# include <sysdep.h>
-
-/* Signal that TLS support is available.  */
-//# define USE_TLS	1
-
-
-/* Get the thread descriptor definition.  */
-# include <linuxthreads/descr.h>
-
-/* This is the size of the initial TCB.  */
-# define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
-
-/* Alignment requirements for the initial TCB.  */
-# define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
-
-/* This is the size of the TCB.  */
-# define TLS_TCB_SIZE sizeof (struct _pthread_descr_struct)
-
-/* Alignment requirements for the TCB.  */
-# define TLS_TCB_ALIGN __alignof__ (struct _pthread_descr_struct)
-
-/* The TLS blocks start right after the TCB.  */
-# define TLS_DTV_AT_TP	1
-
-
-/* Install the dtv pointer.  The pointer passed is to the element with
-   index -1 which contain the length.  */
-# define INSTALL_DTV(descr, dtvp) \
-  ((tcbhead_t *) (descr))->dtv = dtvp + 1
-
-/* Install new dtv for current thread.  */
-# define INSTALL_NEW_DTV(dtv) \
-  ({ struct _pthread_descr_struct *__descr;				      \
-     THREAD_SETMEM (__descr, p_header.data.dtvp, (dtv)); })
-
-/* Return dtv of given thread descriptor.  */
-# define GET_DTV(descr) \
-  (((tcbhead_t *) (descr))->dtv)
-
-/* Code to initially initialize the thread pointer.  This might need
-   special attention since 'errno' is not yet available and if the
-   operation can cause a failure 'errno' must not be touched.  */
-# define TLS_INIT_TP(descr, secondcall) \
-  ({									      \
-    void *_descr = (descr);						      \
-    int result;								      \
-    tcbhead_t *head = _descr;						      \
-									      \
-    head->tcb = _descr;							      \
-    /* For now the thread descriptor is at the same address.  */	      \
-    head->self = _descr;						      \
-									      \
-    __asm__ ("ldc %0,gbr" : : "r" (_descr));				      \
-									      \
-    0;									      \
-  })
-
-
-/* Return the address of the dtv for the current thread.  */
-# define THREAD_DTV() \
-  ({ struct _pthread_descr_struct *__descr;				      \
-     THREAD_GETMEM (__descr, p_header.data.dtvp); })
-
-#endif	/* FLOATING_STACKS && HAVE_TLS_SUPPORT */
-#endif /* __ASSEMBLER__ */
-
-#endif	/* tls.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/sparc/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/sparc/pt-machine.h
deleted file mode 100644
index d502c759a..000000000
--- a/libpthread/linuxthreads.old/sysdeps/sparc/pt-machine.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   sparc version.
-   Copyright (C) 1996-1998, 2000-2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Richard Henderson <rth@tamu.edu>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-extern long int testandset (int *spinlock);
-extern int __compare_and_swap (long int *p, long int oldval, long int newval);
-
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
-{
-  int ret;
-
-  __asm__ __volatile__("ldstub %1,%0"
-	: "=r"(ret), "=m"(*spinlock)
-	: "m"(*spinlock));
-
-  return ret;
-}
-
-
-/* Memory barrier; default is to do nothing */
-#define MEMORY_BARRIER() __asm__ __volatile__("stbar" : : : "memory")
-
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  (stack_pointer + (2 * 64))
-register char *stack_pointer __asm__("%sp");
-
-
-/* Registers %g6 and %g7 are reserved by the ABI for "system use".
-   %g7 is specified in the TLS ABI as thread pointer -- we do the same.  */
-struct _pthread_descr_struct;
-register struct _pthread_descr_struct *__thread_self __asm__("%g7");
-
-/* Return the thread descriptor for the current thread.  */
-#define THREAD_SELF  __thread_self
-
-/* Initialize the thread-unique value.  */
-#define INIT_THREAD_SELF(descr, nr)  (__thread_self = (descr))
-
-/* Access to data in the thread descriptor is easy.  */
-#define THREAD_GETMEM(descr, member) \
-  ((void) sizeof (descr), THREAD_SELF->member)
-#define THREAD_GETMEM_NC(descr, member) \
-  ((void) sizeof (descr), THREAD_SELF->member)
-#define THREAD_SETMEM(descr, member, value) \
-  ((void) sizeof (descr), THREAD_SELF->member = (value))
-#define THREAD_SETMEM_NC(descr, member, value) \
-  ((void) sizeof (descr), THREAD_SELF->member = (value))
-
-/* We want the OS to assign stack addresses.  */
-#define FLOATING_STACKS 1
-
-/* Maximum size of the stack if the rlimit is unlimited.  */
-#define ARCH_STACK_MAX_SIZE     8*1024*1024
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/x86_64/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/x86_64/pt-machine.h
deleted file mode 100644
index ed1fa30b1..000000000
--- a/libpthread/linuxthreads.old/sysdeps/x86_64/pt-machine.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   x86-64 version.
-   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#include <features.h>
-
-#ifndef __ASSEMBLER__
-# include <stddef.h>	/* For offsetof.  */
-# include <stdlib.h>	/* For abort().  */
-# include <asm/prctl.h>
-
-
-# ifndef PT_EI
-#  define PT_EI __extern_always_inline
-# endif
-
-extern long int testandset (int *);
-extern int __compare_and_swap (long int *, long int, long int);
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-# define CURRENT_STACK_FRAME  stack_pointer
-register char * stack_pointer __asm__ ("%rsp") __attribute_used__;
-
-
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *__spinlock)
-{
-  long int ret;
-
-  __asm__ __volatile__ (
-	"xchgl %k0, %1"
-	: "=r"(ret), "=m"(*__spinlock)
-	: "0"(1), "m"(*__spinlock)
-	: "memory");
-
-  return ret;
-}
-
-
-/* Compare-and-swap for semaphores.  */
-# define HAS_COMPARE_AND_SWAP
-
-PT_EI int
-__compare_and_swap (long int *__p, long int __oldval, long int __newval)
-{
-  char ret;
-  long int readval;
-
-  __asm__ __volatile__ ("lock; cmpxchgq %3, %1; sete %0"
-			: "=q" (ret), "=m" (*__p), "=a" (readval)
-			: "r" (__newval), "m" (*__p), "a" (__oldval)
-			: "memory");
-  return ret;
-}
-
-#endif /* !__ASSEMBLER__ */
-
-/* We want the OS to assign stack addresses.  */
-#define FLOATING_STACKS	1
-
-/* Maximum size of the stack if the rlimit is unlimited.  */
-#define ARCH_STACK_MAX_SIZE	32*1024*1024
-
-/* The ia32e really want some help to prevent overheating.  */
-#define BUSY_WAIT_NOP	__asm__ ("rep; nop")
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/x86_64/tls.h b/libpthread/linuxthreads.old/sysdeps/x86_64/tls.h
deleted file mode 100644
index 24ed3fca9..000000000
--- a/libpthread/linuxthreads.old/sysdeps/x86_64/tls.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/* Definitions for thread-local data handling.  linuxthreads/x86-64 version.
-   Copyright (C) 2002, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _TLS_H
-#define _TLS_H
-
-#ifndef __ASSEMBLER__
-
-# include <pt-machine.h>
-# include <stdbool.h>
-# include <stddef.h>
-
-/* Type for the dtv.  */
-typedef union dtv
-{
-  size_t counter;
-  struct
-  {
-    void *val;
-    bool is_static;
-  } pointer;
-} dtv_t;
-
-
-typedef struct
-{
-  void *tcb;		/* Pointer to the TCB.  Not necessary the
-			   thread descriptor used by libpthread.  */
-  dtv_t *dtv;
-  void *self;		/* Pointer to the thread descriptor.  */
-  int multiple_threads;
-} tcbhead_t;
-
-#else /* __ASSEMBLER__ */
-# include <tcb-offsets.h>
-#endif
-
-
-#ifdef HAVE_TLS_SUPPORT
-
-/* Signal that TLS support is available.  */
-# define USE_TLS	1
-
-# ifndef __ASSEMBLER__
-/* Get system call information.  */
-#  include <sysdep.h>
-
-/* Get the thread descriptor definition.  */
-#  include <linuxthreads/descr.h>
-
-/* This is the size of the initial TCB.  */
-#  define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
-
-/* Alignment requirements for the initial TCB.  */
-#  define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
-
-/* This is the size of the TCB.  */
-#  define TLS_TCB_SIZE sizeof (struct _pthread_descr_struct)
-
-/* Alignment requirements for the TCB.  */
-#  define TLS_TCB_ALIGN __alignof__ (struct _pthread_descr_struct)
-
-/* The TCB can have any size and the memory following the address the
-   thread pointer points to is unspecified.  Allocate the TCB there.  */
-#  define TLS_TCB_AT_TP	1
-
-
-/* Install the dtv pointer.  The pointer passed is to the element with
-   index -1 which contain the length.  */
-#  define INSTALL_DTV(descr, dtvp) \
-  ((tcbhead_t *) (descr))->dtv = (dtvp) + 1
-
-/* Install new dtv for current thread.  */
-#  define INSTALL_NEW_DTV(dtv) \
-  ({ struct _pthread_descr_struct *__descr;				      \
-     THREAD_SETMEM (__descr, p_header.data.dtvp, (dtv)); })
-
-/* Return dtv of given thread descriptor.  */
-#  define GET_DTV(descr) \
-  (((tcbhead_t *) (descr))->dtv)
-
-/* Code to initially initialize the thread pointer.  This might need
-   special attention since 'errno' is not yet available and if the
-   operation can cause a failure 'errno' must not be touched.  */
-# define TLS_INIT_TP(descr, secondcall)					      \
-  ({									      \
-    void *_descr = (descr);						      \
-    tcbhead_t *head = _descr;						      \
-    long int _result;							      \
-									      \
-    head->tcb = _descr;							      \
-    /* For now the thread descriptor is at the same address.  */	      \
-    head->self = _descr;						      \
-									      \
-    __asm__ __volatile__ ("syscall"						      \
-		  : "=a" (_result)					      \
-		  : "0" ((unsigned long int) __NR_arch_prctl),		      \
-		    "D" ((unsigned long int) ARCH_SET_FS),		      \
-		    "S" (_descr)					      \
-		  : "memory", "cc", "r11", "cx");			      \
-									      \
-    _result ? "cannot set %fs base address for thread-local storage" : 0;     \
-  })
-
-/* Indicate that dynamic linker shouldn't try to initialize TLS even
-   when no PT_TLS segments are found in the program and libraries
-   it is linked against.  */
-#  define TLS_INIT_TP_EXPENSIVE 1
-
-/* Return the address of the dtv for the current thread.  */
-#  define THREAD_DTV() \
-  ({ struct _pthread_descr_struct *__descr;				      \
-     THREAD_GETMEM (__descr, p_header.data.dtvp); })
-
-# endif	/* HAVE_TLS_SUPPORT */
-#endif /* __ASSEMBLER__ */
-
-#endif	/* tls.h */
diff --git a/libpthread/linuxthreads.old_db/Banner b/libpthread/linuxthreads.old_db/Banner
deleted file mode 100644
index 6f4f3f818..000000000
--- a/libpthread/linuxthreads.old_db/Banner
+++ /dev/null
@@ -1 +0,0 @@
-libthread_db work sponsored by Alpha Processor Inc
diff --git a/libpthread/linuxthreads.old_db/Makefile b/libpthread/linuxthreads.old_db/Makefile
deleted file mode 100644
index f9100219a..000000000
--- a/libpthread/linuxthreads.old_db/Makefile
+++ /dev/null
@@ -1,13 +0,0 @@
-# Makefile for uClibc
-#
-# Copyright (C) 2000-2005 Erik Andersen <andersen@uclibc.org>
-#
-# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
-#
-
-top_srcdir=../../
-top_builddir=../../
-include $(top_builddir)Rules.mak
-all: libs
-include Makefile.in
-include $(top_srcdir)Makerules
diff --git a/libpthread/linuxthreads.old_db/Makefile.in b/libpthread/linuxthreads.old_db/Makefile.in
deleted file mode 100644
index cf0ceb394..000000000
--- a/libpthread/linuxthreads.old_db/Makefile.in
+++ /dev/null
@@ -1,78 +0,0 @@
-# Makefile for uClibc
-#
-# Copyright (C) 2000-2008 Erik Andersen <andersen@uclibc.org>
-#
-# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
-#
-
-subdirs += libpthread/linuxthreads.old_db
-
-# Get the thread include dependencies and shared object name
-CFLAGS-libpthread/linuxthreads.old_db := -DNOT_IN_libc -DLIBPTHREAD_SO="\"libpthread.so.$(ABI_VERSION)\""
-
-LDFLAGS-libthread_db.so := $(LDFLAGS_NOSTRIP) $(if $(call check_ld,--warn-unresolved-symbols),-Wl$(comma)--warn-unresolved-symbols)
-ifeq ($(DOSTRIP),y)
-LDFLAGS-libthread_db.so += -Wl,-s
-endif
-
-LIBS-libthread_db.so := $(LIBS)
-
-libthread_db_FULL_NAME := libthread_db-$(VERSION).so
-
-libthread_db_DIR := $(top_srcdir)libpthread/linuxthreads.old_db
-libthread_db_OUT := $(top_builddir)libpthread/linuxthreads.old_db
-
-libthread_db_SRC := $(wildcard $(libthread_db_DIR)/*.c)
-
-libthread_db_OBJ := $(patsubst $(libthread_db_DIR)/%.c,$(libthread_db_OUT)/%.o,$(libthread_db_SRC))
-
-libthread_db-so-y := $(libthread_db_OBJ:.o=.os)
-ifeq ($(DOPIC),y)
-libthread_db-a-y  := $(libthread_db-so-y)
-else
-libthread_db-a-y  := $(libthread_db_OBJ)
-endif
-
-lib-a-$(PTHREADS_DEBUG_SUPPORT) += $(top_builddir)lib/libthread_db.a
-lib-so-$(PTHREADS_DEBUG_SUPPORT) += $(top_builddir)lib/libthread_db.so
-
-#ifeq ($(DOMULTI),n)
-ifeq ($(DOPIC),y)
-$(top_builddir)lib/libthread_db.so: $(top_builddir)lib/libthread_db.a $(libc.depend)
-else
-$(top_builddir)lib/libthread_db.so: $(libthread_db_OUT)/libthread_db_so.a $(libc.depend)
-endif
-	$(call link.so,$(libthread_db_FULL_NAME),1)
-#else
-#$(top_builddir)lib/libthread_db.so: $(libthread_db_OUT)/libthread_db.oS | $(libc.depend)
-#	$(call linkm.so,$(libthread_db_FULL_NAME),1)
-#endif
-
-$(libthread_db_OUT)/libthread_db_so.a: $(libthread_db-so-y)
-	$(Q)$(RM) $@
-	$(do_ar)
-
-$(libthread_db_OUT)/libthread_db.oS: $(libthread_db_SRC)
-	$(Q)$(RM) $@
-	$(compile-m)
-
-$(top_builddir)lib/libthread_db.a: $(libthread_db-a-y)
-	$(Q)$(INSTALL) -d $(dir $@)
-	$(Q)$(RM) $@
-	$(do_ar)
-
-$(top_builddir)include/thread_db.h:
-	$(do_ln) $(call rel_srcdir)$(PTDIR)_db/$(@F) $@
-
-linuxthreads_db_headers := $(top_builddir)include/thread_db.h
-$(linuxthreads_db_headers): $(wildcard $(addprefix $(top_builddir)include/config/linuxthreads/,old.h new.h))
-headers-$(PTHREADS_DEBUG_SUPPORT) += $(linuxthreads_db_headers)
-
-objclean-y += CLEAN_libpthread/linuxthreads.old_db
-headers_clean-y += HEADERCLEAN_libpthread/linuxthreads.old_db
-
-HEADERCLEAN_libpthread/linuxthreads.old_db:
-	$(do_rm) $(linuxthreads_db_headers)
-
-CLEAN_libpthread/linuxthreads.old_db:
-	$(do_rm) $(addprefix $(libthread_db_OUT)/*., o os oS a)
diff --git a/libpthread/linuxthreads.old_db/Versions b/libpthread/linuxthreads.old_db/Versions
deleted file mode 100644
index 063493c67..000000000
--- a/libpthread/linuxthreads.old_db/Versions
+++ /dev/null
@@ -1,24 +0,0 @@
-libthread_db {
-  GLIBC_2.1.3 {
-    # t*
-    td_init; td_log; td_ta_clear_event; td_ta_delete; td_ta_enable_stats;
-    td_ta_event_addr; td_ta_event_getmsg; td_ta_get_nthreads; td_ta_get_ph;
-    td_ta_get_stats; td_ta_map_id2thr; td_ta_map_lwp2thr; td_ta_new;
-    td_ta_reset_stats; td_ta_set_event; td_ta_setconcurrency;
-    td_ta_thr_iter; td_ta_tsd_iter; td_thr_clear_event; td_thr_dbresume;
-    td_thr_dbsuspend; td_thr_event_enable; td_thr_event_getmsg;
-    td_thr_get_info; td_thr_getfpregs; td_thr_getgregs; td_thr_getxregs;
-    td_thr_getxregsize; td_thr_set_event; td_thr_setfpregs; td_thr_setgregs;
-    td_thr_setprio; td_thr_setsigpending; td_thr_setxregs; td_thr_sigsetmask;
-    td_thr_tsd; td_thr_validate;
-  }
-  GLIBC_2.2.3 {
-    td_symbol_list;
-  }
-  GLIBC_2.3 {
-    td_thr_tls_get_addr;
-  }
-  GLIBC_2.3.3 {
-    td_thr_tlsbase;
-  }
-}
diff --git a/libpthread/linuxthreads.old_db/proc_service.h b/libpthread/linuxthreads.old_db/proc_service.h
deleted file mode 100644
index 6f33ccdda..000000000
--- a/libpthread/linuxthreads.old_db/proc_service.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* Copyright (C) 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-/* The definitions in this file must correspond to those in the debugger.  */
-#include <sys/procfs.h>
-
-typedef enum
-{
-  PS_OK,          /* generic "call succeeded" */
-  PS_ERR,         /* generic. */
-  PS_BADPID,      /* bad process handle */
-  PS_BADLID,      /* bad lwp identifier */
-  PS_BADADDR,     /* bad address */
-  PS_NOSYM,       /* p_lookup() could not find given symbol */
-        PS_NOFREGS
-  /*
-   * FPU register set not available for given
-   * lwp
-   */
-}       ps_err_e;
-
-
-struct ps_prochandle;		/* user defined. */
-
-
-extern ps_err_e ps_pdread(struct ps_prochandle *,
-                        psaddr_t, void *, size_t);
-extern ps_err_e ps_pdwrite(struct ps_prochandle *,
-                        psaddr_t, const void *, size_t);
-extern ps_err_e ps_ptread(struct ps_prochandle *,
-                        psaddr_t, void *, size_t);
-extern ps_err_e ps_ptwrite(struct ps_prochandle *,
-                        psaddr_t, const void *, size_t);
-
-extern ps_err_e ps_pglobal_lookup(struct ps_prochandle *,
-        const char *object_name, const char *sym_name, psaddr_t *sym_addr);
-
-
-extern ps_err_e ps_lgetregs(struct ps_prochandle *,
-                        lwpid_t, prgregset_t);
-extern ps_err_e ps_lsetregs(struct ps_prochandle *,
-                        lwpid_t, const prgregset_t);
-extern ps_err_e ps_lgetfpregs(struct ps_prochandle *,
-                        lwpid_t, prfpregset_t *);
-extern ps_err_e ps_lsetfpregs(struct ps_prochandle *,
-                        lwpid_t, const prfpregset_t *);
-
-extern pid_t ps_getpid (struct ps_prochandle *);
-
-
-extern ps_err_e ps_pstop (const struct ps_prochandle *);
-extern ps_err_e ps_pcontinue (const struct ps_prochandle *);
-
-extern ps_err_e ps_lstop (const struct ps_prochandle *, lwpid_t);
-extern ps_err_e ps_lcontinue (const struct ps_prochandle *, lwpid_t);
diff --git a/libpthread/linuxthreads.old_db/td_init.c b/libpthread/linuxthreads.old_db/td_init.c
deleted file mode 100644
index ecb0d3de2..000000000
--- a/libpthread/linuxthreads.old_db/td_init.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Initialization function of thread debugger support library.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-#ifndef NDEBUG
-int __td_debug;
-#endif
-
-td_err_e
-td_init (void)
-{
-  /* XXX We have to figure out what has to be done.  */
-  LOG ("td_init");
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_log.c b/libpthread/linuxthreads.old_db/td_log.c
deleted file mode 100644
index c82ffa54d..000000000
--- a/libpthread/linuxthreads.old_db/td_log.c
+++ /dev/null
@@ -1,31 +0,0 @@
-/* Noop, left for historical reasons.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_log (void)
-{
-  /* This interface is deprecated in the Sun interface.  We provide it
-     for compatibility but don't do anything ourself.  We might in
-     future do some logging if this seems reasonable.  */
-  LOG ("td_log");
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_symbol_list.c b/libpthread/linuxthreads.old_db/td_symbol_list.c
deleted file mode 100644
index f62cd692c..000000000
--- a/libpthread/linuxthreads.old_db/td_symbol_list.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/* Return list of symbols the library can request.
-   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 2001.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <assert.h>
-#include "thread_dbP.h"
-
-#ifdef HAVE_ASM_GLOBAL_DOT_NAME
-# define DOT "."		/* PPC64 requires . prefix on code symbols.  */
-#else
-# define DOT			/* No prefix.  */
-#endif
-
-static const char *symbol_list_arr[] =
-{
-  [PTHREAD_THREADS_EVENTS] = "__pthread_threads_events",
-  [PTHREAD_LAST_EVENT] = "__pthread_last_event",
-  [PTHREAD_HANDLES_NUM] = "__pthread_handles_num",
-  [PTHREAD_HANDLES] = "__pthread_handles",
-  [PTHREAD_KEYS] = "pthread_keys",
-  [LINUXTHREADS_PTHREAD_THREADS_MAX] = "__linuxthreads_pthread_threads_max",
-  [LINUXTHREADS_PTHREAD_KEYS_MAX] = "__linuxthreads_pthread_keys_max",
-  [LINUXTHREADS_PTHREAD_SIZEOF_DESCR] = "__linuxthreads_pthread_sizeof_descr",
-  [LINUXTHREADS_CREATE_EVENT] = DOT "__linuxthreads_create_event",
-  [LINUXTHREADS_DEATH_EVENT] = DOT "__linuxthreads_death_event",
-  [LINUXTHREADS_REAP_EVENT] = DOT "__linuxthreads_reap_event",
-  [LINUXTHREADS_INITIAL_REPORT_EVENTS] = "__linuxthreads_initial_report_events",
-  [LINUXTHREADS_VERSION] = "__linuxthreads_version",
-  [NUM_MESSAGES] = NULL
-};
-
-
-const char **
-td_symbol_list (void)
-{
-  return symbol_list_arr;
-}
-
-
-int
-td_lookup (struct ps_prochandle *ps, int idx, psaddr_t *sym_addr)
-{
-  assert (idx >= 0 && idx < NUM_MESSAGES);
-  return ps_pglobal_lookup (ps, LIBPTHREAD_SO, symbol_list_arr[idx], sym_addr);
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_clear_event.c b/libpthread/linuxthreads.old_db/td_ta_clear_event.c
deleted file mode 100644
index e827b46ae..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_clear_event.c
+++ /dev/null
@@ -1,50 +0,0 @@
-/* Globally disable events.
-   Copyright (C) 1999, 2001, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_clear_event(const td_thragent_t *ta,td_thr_events_t *event)
-{
-  td_thr_events_t old_event;
-  int i;
-
-  LOG ("td_ta_clear_event");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  /* Write the new value into the thread data structure.  */
-  if (ps_pdread (ta->ph, ta->pthread_threads_eventsp,
-		 &old_event, sizeof (td_thr_events_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Remove the set bits in.  */
-  for (i = 0; i < TD_EVENTSIZE; ++i)
-    old_event.event_bits[i] &= ~event->event_bits[i];
-
-  /* Write the new value into the thread data structure.  */
-  if (ps_pdwrite (ta->ph, ta->pthread_threads_eventsp,
-		  &old_event, sizeof (td_thr_events_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_delete.c b/libpthread/linuxthreads.old_db/td_ta_delete.c
deleted file mode 100644
index 9bc5c08ac..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_delete.c
+++ /dev/null
@@ -1,57 +0,0 @@
-/* Detach to target process.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <stdlib.h>
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_delete (td_thragent_t *ta)
-{
-  LOG ("td_ta_delete");
-
-  /* Safety check.  */
-  if (ta == NULL || __td_agent_list == NULL)
-    return TD_BADTA;
-
-  /* Remove the handle from the list.  */
-  if (ta == __td_agent_list->ta)
-    /* It's the first element of the list.  */
-    __td_agent_list = __td_agent_list->next;
-  else
-    {
-      /* We have to search for it.  */
-      struct agent_list *runp = __td_agent_list;
-
-      while (runp->next != NULL && runp->next->ta != ta)
-	runp = runp->next;
-
-      if (runp->next == NULL)
-	/* It's not a valid descriptor since it is not in the list.  */
-	return TD_BADTA;
-
-      runp->next = runp->next->next;
-    }
-
-  /* The handle was allocated in `td_ta_new'.  */
-  free (ta);
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_enable_stats.c b/libpthread/linuxthreads.old_db/td_ta_enable_stats.c
deleted file mode 100644
index 9d3408ece..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_enable_stats.c
+++ /dev/null
@@ -1,34 +0,0 @@
-/* Enable collection of statistics for process.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_enable_stats (const td_thragent_t *ta, int enable)
-{
-  /* XXX We have to figure out what has to be done.  */
-  LOG ("td_ta_enable_stats");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_event_addr.c b/libpthread/linuxthreads.old_db/td_ta_event_addr.c
deleted file mode 100644
index 72d426555..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_event_addr.c
+++ /dev/null
@@ -1,72 +0,0 @@
-/* Get event address.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_event_addr (const td_thragent_t *ta, td_event_e event, td_notify_t *addr)
-{
-  td_err_e res = TD_NOEVENT;
-  int idx = -1;
-
-  LOG ("td_ta_event_addr");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  switch (event)
-    {
-    case TD_CREATE:
-      idx = LINUXTHREADS_CREATE_EVENT;
-      break;
-
-    case TD_DEATH:
-      idx = LINUXTHREADS_DEATH_EVENT;
-      break;
-
-    case TD_REAP:
-      idx = LINUXTHREADS_REAP_EVENT;
-      break;
-
-    default:
-      /* Event cannot be handled.  */
-      break;
-    }
-
-  /* Now get the address.  */
-  if (idx != -1)
-    {
-      psaddr_t taddr;
-
-      if (td_lookup (ta->ph, idx, &taddr) == PS_OK)
-	{
-	  /* Success, we got the address.  */
-	  addr->type = NOTIFY_BPT;
-	  addr->u.bptaddr = taddr;
-
-	  res = TD_OK;
-	}
-      else
-	res = TD_ERR;
-    }
-
-  return res;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_event_getmsg.c b/libpthread/linuxthreads.old_db/td_ta_event_getmsg.c
deleted file mode 100644
index b7c2fcd72..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_event_getmsg.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/* Retrieve event.
-   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <stddef.h>
-#include <string.h>
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_event_getmsg (const td_thragent_t *ta, td_event_msg_t *msg)
-{
-  /* XXX I cannot think of another way but using a static variable.  */
-  static td_thrhandle_t th;
-  td_eventbuf_t event;
-  psaddr_t addr;
-
-  LOG ("td_ta_event_getmsg");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  /* Get the pointer to the thread descriptor with the last event.  */
-  if (ps_pdread (ta->ph, ta->pthread_last_event,
-		 &addr, sizeof (void *)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* If the pointer is NULL no event occurred.  */
-  if (addr == 0)
-    return TD_NOMSG;
-
-  /* Read the even structure from the target.  */
-  if (ps_pdread (ta->ph,
-		 ((char *) addr
-		  + offsetof (struct _pthread_descr_struct, p_eventbuf)),
-		 &event, sizeof (td_eventbuf_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Check whether an event occurred.  */
-  if (event.eventnum == TD_EVENT_NONE)
-    {
-      /* Oh well, this means the last event was already read.  So
-	 we have to look for any other event.  */
-      struct pthread_handle_struct handles[ta->pthread_threads_max];
-      int num;
-      int i;
-
-      /* Read the number of currently active threads.  */
-      if (ps_pdread (ta->ph, ta->pthread_handles_num, &num, sizeof (int))
-	  != PS_OK)
-	return TD_ERR;	/* XXX Other error value?  */
-
-      /* Now read the handles.  */
-      if (ps_pdread (ta->ph, ta->handles, handles,
-		     ta->pthread_threads_max * sizeof (handles[0])) != PS_OK)
-	return TD_ERR;	/* XXX Other error value?  */
-
-      for (i = 0; i < ta->pthread_threads_max && num > 0; ++i)
-	{
-	  if (handles[i].h_descr == NULL)
-	    /* No entry here.  */
-	    continue;
-
-	  /* First count this active thread.  */
-	  --num;
-
-	  if (handles[i].h_descr == addr)
-	    /* We already handled this.  */
-	    continue;
-
-	  /* Read the event data for this thread.  */
-	  if (ps_pdread (ta->ph,
-			 ((char *) handles[i].h_descr
-			  + offsetof (struct _pthread_descr_struct,
-				      p_eventbuf)),
-			 &event, sizeof (td_eventbuf_t)) != PS_OK)
-	    return TD_ERR;
-
-	  if (event.eventnum != TD_EVENT_NONE)
-	    {
-	      /* We found a thread with an unreported event.  */
-	      addr = handles[i].h_descr;
-	      break;
-	    }
-	}
-
-      /* If we haven't found any other event signal this to the user.  */
-      if (event.eventnum == TD_EVENT_NONE)
-	return TD_NOMSG;
-    }
-
-  /* Generate the thread descriptor.  */
-  th.th_ta_p = (td_thragent_t *) ta;
-  th.th_unique = addr;
-
-  /* Fill the user's data structure.  */
-  msg->event = event.eventnum;
-  msg->th_p = &th;
-  msg->msg.data = (uintptr_t) event.eventdata;
-
-  /* And clear the event message in the target.  */
-  memset (&event, '\0', sizeof (td_eventbuf_t));
-  if (ps_pdwrite (ta->ph,
-		  ((char *) addr
-		   + offsetof (struct _pthread_descr_struct, p_eventbuf)),
-		  &event, sizeof (td_eventbuf_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_get_nthreads.c b/libpthread/linuxthreads.old_db/td_ta_get_nthreads.c
deleted file mode 100644
index 144f4ffee..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_get_nthreads.c
+++ /dev/null
@@ -1,41 +0,0 @@
-/* Get the number of threads in the process.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-td_err_e
-td_ta_get_nthreads (const td_thragent_t *ta, int *np)
-{
-  psaddr_t addr;
-
-  LOG ("td_ta_get_nthreads");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  /* Access the variable `__pthread_handles_num'.  */
-  if (td_lookup (ta->ph, PTHREAD_HANDLES_NUM, &addr) != PS_OK)
-     return TD_ERR;	/* XXX Other error value?  */
-
-  if (ps_pdread (ta->ph, addr, np, sizeof (int)) != PS_OK)
-     return TD_ERR;	/* XXX Other error value?  */
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_get_ph.c b/libpthread/linuxthreads.old_db/td_ta_get_ph.c
deleted file mode 100644
index fdf44fbe1..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_get_ph.c
+++ /dev/null
@@ -1,35 +0,0 @@
-/* Get external process handle.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_get_ph (const td_thragent_t *ta, struct ps_prochandle **ph)
-{
-  LOG ("td_ta_get_ph");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  *ph = ta->ph;
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_get_stats.c b/libpthread/linuxthreads.old_db/td_ta_get_stats.c
deleted file mode 100644
index eca9ba5b4..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_get_stats.c
+++ /dev/null
@@ -1,34 +0,0 @@
-/* Retrieve statistics for process.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_get_stats (const td_thragent_t *ta, td_ta_stats_t *statsp)
-{
-  /* XXX We have to figure out what has to be done.  */
-  LOG ("td_ta_get_stats");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_map_id2thr.c b/libpthread/linuxthreads.old_db/td_ta_map_id2thr.c
deleted file mode 100644
index dc24533b8..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_map_id2thr.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/* Map thread ID to thread handle.
-   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_map_id2thr (const td_thragent_t *ta, pthread_t pt, td_thrhandle_t *th)
-{
-  struct pthread_handle_struct phc;
-  struct _pthread_descr_struct pds;
-  int pthread_threads_max;
-
-  LOG ("td_ta_map_id2thr");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  /* Make the following expression a bit smaller.  */
-  pthread_threads_max = ta->pthread_threads_max;
-
-  /* We can compute the entry in the handle array we want.  */
-  if (ps_pdread (ta->ph, ta->handles + pt % pthread_threads_max, &phc,
-		 sizeof (struct pthread_handle_struct)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Test whether this entry is in use.  */
-  if (phc.h_descr == NULL)
-    {
-      if (pt % pthread_threads_max == 0)
-	{
-	  /* The initial thread always exists but the thread library
-	     might not yet be initialized.  */
-	  th->th_ta_p = (td_thragent_t *) ta;
-	  th->th_unique = NULL;
-
-	  return TD_OK;
-	}
-
-      return TD_BADTH;
-    }
-
-  /* Next test: get the descriptor to see whether this is not an old
-     thread handle.  */
-  if (ps_pdread (ta->ph, phc.h_descr, &pds,
-		 sizeof (struct _pthread_descr_struct)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  if (pds.p_tid != pt)
-    return TD_BADTH;
-
-  if (pds.p_terminated != 0)
-    return TD_NOTHR;
-
-  /* Create the `td_thrhandle_t' object.  */
-  th->th_ta_p = (td_thragent_t *) ta;
-  th->th_unique = phc.h_descr;
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_map_lwp2thr.c b/libpthread/linuxthreads.old_db/td_ta_map_lwp2thr.c
deleted file mode 100644
index 00efc43d6..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_map_lwp2thr.c
+++ /dev/null
@@ -1,89 +0,0 @@
-/* Which thread is running on an lwp?
-   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_map_lwp2thr (const td_thragent_t *ta, lwpid_t lwpid, td_thrhandle_t *th)
-{
-  int pthread_threads_max = ta->pthread_threads_max;
-  size_t sizeof_descr = ta->sizeof_descr;
-  struct pthread_handle_struct phc[pthread_threads_max];
-  size_t cnt;
-#ifdef ALL_THREADS_STOPPED
-  int num;
-#else
-# define num 1
-#endif
-
-  LOG ("td_ta_map_lwp2thr");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  /* Read all the descriptors.  */
-  if (ps_pdread (ta->ph, ta->handles, phc,
-		 sizeof (struct pthread_handle_struct) * pthread_threads_max)
-      != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-#ifdef ALL_THREADS_STOPPED
-  /* Read the number of currently active threads.  */
-  if (ps_pdread (ta->ph, ta->pthread_handles_num, &num, sizeof (int)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-#endif
-
-  /* Get the entries one after the other and find out whether the ID
-     matches.  */
-  for (cnt = 0; cnt < pthread_threads_max && num > 0; ++cnt)
-    if (phc[cnt].h_descr != NULL)
-      {
-	struct _pthread_descr_struct pds;
-
-#ifdef ALL_THREADS_STOPPED
-	/* First count this active thread.  */
-	--num;
-#endif
-
-	if (ps_pdread (ta->ph, phc[cnt].h_descr, &pds, sizeof_descr) != PS_OK)
-	  return TD_ERR;	/* XXX Other error value?  */
-
-	if ((pds.p_pid ?: ps_getpid (ta->ph)) == lwpid)
-	  {
-	    /* Found it.  Now fill in the `td_thrhandle_t' object.  */
-	    th->th_ta_p = (td_thragent_t *) ta;
-	    th->th_unique = phc[cnt].h_descr;
-
-	    return TD_OK;
-	  }
-      }
-    else if (cnt == 0)
-      {
-	/* The initial thread always exists.  But it might not yet be
-	   initialized.  Construct a value.  */
-	th->th_ta_p = (td_thragent_t *) ta;
-	th->th_unique = NULL;
-
-	return TD_OK;
-      }
-
-  return TD_NOLWP;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_new.c b/libpthread/linuxthreads.old_db/td_ta_new.c
deleted file mode 100644
index 7cf0edc66..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_new.c
+++ /dev/null
@@ -1,148 +0,0 @@
-/* Attach to target process.
-   Copyright (C) 1999, 2001, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <stddef.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "thread_dbP.h"
-
-
-/* Datatype for the list of known thread agents.  Normally there will
-   be exactly one so we don't spend much though on making it fast.  */
-struct agent_list *__td_agent_list;
-
-
-td_err_e
-td_ta_new (struct ps_prochandle *ps, td_thragent_t **ta)
-{
-  psaddr_t addr;
-  psaddr_t versaddr;
-  char versbuf[sizeof (VERSION)];
-  struct agent_list *elemp;
-
-  LOG ("td_ta_new");
-
-  /* Get the global event mask.  This is one of the variables which
-     are new in the thread library to enable debugging.  If it is
-     not available we cannot debug.  */
-  if (td_lookup (ps, PTHREAD_THREADS_EVENTS, &addr) != PS_OK)
-    return TD_NOLIBTHREAD;
-
-  /* Check whether the versions match.  */
-  if (td_lookup (ps, LINUXTHREADS_VERSION, &versaddr) != PS_OK)
-    return TD_VERSION;
-  if (ps_pdread (ps, versaddr, versbuf, sizeof (versbuf)) != PS_OK)
-    return TD_ERR;
-
-  versbuf[sizeof (versbuf) - 1] = '\0';
-  if (strcmp (versbuf, VERSION) != 0)
-    /* Not the right version.  */
-    return TD_VERSION;
-
-  /* Fill in the appropriate information.  */
-  *ta = (td_thragent_t *) malloc (sizeof (td_thragent_t));
-  if (*ta == NULL)
-    return TD_MALLOC;
-
-  /* Store the proc handle which we will pass to the callback functions
-     back into the debugger.  */
-  (*ta)->ph = ps;
-
-  /* Remember the address.  */
-  (*ta)->pthread_threads_eventsp = (td_thr_events_t *) addr;
-
-  /* Get the pointer to the variable pointing to the thread descriptor
-     with the last event.  */
-  if (td_lookup (ps, PTHREAD_LAST_EVENT, &(*ta)->pthread_last_event) != PS_OK)
-    {
-    free_return:
-      free (*ta);
-      return TD_ERR;
-    }
-
-  /* Get the pointer to the variable containing the number of active
-     threads.  */
-  if (td_lookup (ps, PTHREAD_HANDLES_NUM, &(*ta)->pthread_handles_num)
-      != PS_OK)
-    goto free_return;
-
-  /* See whether the library contains the necessary symbols.  */
-  if (td_lookup (ps, PTHREAD_HANDLES, &addr) != PS_OK)
-    goto free_return;
-
-  (*ta)->handles = (struct pthread_handle_struct *) addr;
-
-
-  if (td_lookup (ps, PTHREAD_KEYS, &addr) != PS_OK)
-    goto free_return;
-
-  /* Cast to the right type.  */
-  (*ta)->keys = (struct pthread_key_struct *) addr;
-
-  /* Find out about the maximum number of threads.  Old implementations
-     don't provide this information.  In this case we assume that the
-     debug  library is compiled with the same values.  */
-  if (td_lookup (ps, LINUXTHREADS_PTHREAD_THREADS_MAX, &addr) != PS_OK)
-    (*ta)->pthread_threads_max = PTHREAD_THREADS_MAX;
-  else
-    {
-      if (ps_pdread (ps, addr, &(*ta)->pthread_threads_max, sizeof (int))
-	  != PS_OK)
-	goto free_return;
-    }
-
-  /* Similar for the maximum number of thread local data keys.  */
-  if (td_lookup (ps, LINUXTHREADS_PTHREAD_KEYS_MAX, &addr) != PS_OK)
-    (*ta)->pthread_keys_max = PTHREAD_KEYS_MAX;
-  else
-    {
-      if (ps_pdread (ps, addr, &(*ta)->pthread_keys_max, sizeof (int))
-	  != PS_OK)
-	goto free_return;
-    }
-
-  /* And for the size of the second level arrays for the keys.  */
-  if (td_lookup (ps, LINUXTHREADS_PTHREAD_SIZEOF_DESCR, &addr) != PS_OK)
-    (*ta)->sizeof_descr = sizeof (struct _pthread_descr_struct);
-  else
-    {
-      if (ps_pdread (ps, addr, &(*ta)->sizeof_descr, sizeof (int)) != PS_OK)
-	goto free_return;
-      /* Don't let bogons in the inferior make us mess ourselves.  */
-      if ((*ta)->sizeof_descr > sizeof (struct _pthread_descr_struct))
-	(*ta)->sizeof_descr = sizeof (struct _pthread_descr_struct);
-    }
-
-  /* Now add the new agent descriptor to the list.  */
-  elemp = (struct agent_list *) malloc (sizeof (struct agent_list));
-  if (elemp == NULL)
-    {
-      /* Argh, now that everything else worked...  */
-      free (*ta);
-      return TD_MALLOC;
-    }
-
-  /* We don't care for thread-safety here.  */
-  elemp->ta = *ta;
-  elemp->next = __td_agent_list;
-  __td_agent_list = elemp;
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_reset_stats.c b/libpthread/linuxthreads.old_db/td_ta_reset_stats.c
deleted file mode 100644
index ce41e1751..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_reset_stats.c
+++ /dev/null
@@ -1,34 +0,0 @@
-/* Reset statistics.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_reset_stats (const td_thragent_t *ta)
-{
-  /* XXX We have to figure out what has to be done.  */
-  LOG ("td_ta_reset_stats");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_set_event.c b/libpthread/linuxthreads.old_db/td_ta_set_event.c
deleted file mode 100644
index 3a75e7b7f..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_set_event.c
+++ /dev/null
@@ -1,50 +0,0 @@
-/* Globally enable events.
-   Copyright (C) 1999, 2001, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_set_event(const td_thragent_t *ta,td_thr_events_t *event)
-{
-  td_thr_events_t old_event;
-  int i;
-
-  LOG ("td_ta_set_event");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  /* Write the new value into the thread data structure.  */
-  if (ps_pdread (ta->ph, ta->pthread_threads_eventsp,
-		 &old_event, sizeof (td_thr_events_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Or the new bits in.  */
-  for (i = 0; i < TD_EVENTSIZE; ++i)
-    old_event.event_bits[i] |= event->event_bits[i];
-
-  /* Write the new value into the thread data structure.  */
-  if (ps_pdwrite (ta->ph, ta->pthread_threads_eventsp,
-		  &old_event, sizeof (td_thr_events_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_setconcurrency.c b/libpthread/linuxthreads.old_db/td_ta_setconcurrency.c
deleted file mode 100644
index 111dfd583..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_setconcurrency.c
+++ /dev/null
@@ -1,34 +0,0 @@
-/* Set suggested concurrency level for process.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_ta_setconcurrency (const td_thragent_t *ta, int level)
-{
-  /* This is something LinuxThreads does not support.  */
-  LOG ("td_ta_setconcurrency");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  return TD_NOCAPAB;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_thr_iter.c b/libpthread/linuxthreads.old_db/td_ta_thr_iter.c
deleted file mode 100644
index da230096f..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_thr_iter.c
+++ /dev/null
@@ -1,172 +0,0 @@
-/* Iterate over a process's threads.
-   Copyright (C) 1999,2000,2001,2002,2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-#include <alloca.h>
-
-static int
-handle_descr (const td_thragent_t *ta, td_thr_iter_f *callback,
-	      void *cbdata_p, td_thr_state_e state, int ti_pri,
-	      size_t cnt, pthread_descr descr)
-{
-  struct _pthread_descr_struct pds;
-  size_t sizeof_descr = ta->sizeof_descr;
-  td_thrhandle_t th;
-
-  if (descr == NULL)
-    {
-      /* No descriptor (yet).  */
-      if (cnt == 0)
-	{
-	  /* This is the main thread.  Create a fake descriptor.  */
-	  memset (&pds, '\0', sizeof (pds));
-
-	  /* Empty thread descriptor the thread library would create.  */
-	  pds.p_self = &pds;
-	  pds.p_nextlive = pds.p_prevlive = &pds;
-	  pds.p_tid = PTHREAD_THREADS_MAX;
-	  /* The init code also sets up p_lock, p_errnop, p_herrnop, and
-	     p_userstack but this should not be necessary here.  */
-
-	  th.th_ta_p = (td_thragent_t *) ta;
-	  th.th_unique = NULL;
-	  if (callback (&th, cbdata_p) != 0)
-	    return TD_DBERR;
-
-	  /* All done successfully.  */
-	  return TD_OK;
-	}
-      else if (cnt == 1)
-	/* The manager is not yet started.  No big deal.  */
-	return TD_OK;
-      else
-	/* For every other thread this should not happen.  */
-	return TD_ERR;
-    }
-
-  if (ps_pdread (ta->ph, descr, &pds, sizeof_descr) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* The manager thread must be handled special.  The descriptor
-     exists but the thread only gets created when the first
-     `pthread_create' call is issued.  A clear indication that this
-     happened is when the p_pid field is non-zero.  */
-  if (cnt == 1 && pds.p_pid == 0)
-    return TD_OK;
-
-  /* Now test whether this thread matches the specified
-     conditions.  */
-
-  /* Only if the priority level is as high or higher.  */
-  if (pds.p_priority < ti_pri)
-    return TD_OK;
-
-  /* Test the state.
-     XXX This is incomplete.  */
-  if (state != TD_THR_ANY_STATE)
-    return TD_OK;
-
-  /* XXX For now we ignore threads which are not running anymore.
-     The reason is that gdb tries to get the registers and fails.
-     In future we should have a special mode of the thread library
-     in which we keep the process around until the actual join
-     operation happened.  */
-  if (pds.p_exited != 0)
-    return TD_OK;
-
-  /* Yep, it matches.  Call the callback function.  */
-  th.th_ta_p = (td_thragent_t *) ta;
-  th.th_unique = descr;
-  if (callback (&th, cbdata_p) != 0)
-    return TD_DBERR;
-
-  /* All done successfully.  */
-  return TD_OK;
-}
-
-
-td_err_e
-td_ta_thr_iter (const td_thragent_t *ta, td_thr_iter_f *callback,
-		void *cbdata_p, td_thr_state_e state, int ti_pri,
-		sigset_t *ti_sigmask_p, unsigned int ti_user_flags)
-{
-  int pthread_threads_max;
-  struct pthread_handle_struct *phc;
-  td_err_e result = TD_OK;
-  int cnt;
-#ifdef ALL_THREADS_STOPPED
-  int num;
-#else
-# define num 1
-#endif
-
-  LOG ("td_ta_thr_iter");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  pthread_threads_max = ta->pthread_threads_max;
-  phc = (struct pthread_handle_struct *) alloca (sizeof (phc[0])
-						 * pthread_threads_max);
-
-  /* First read only the main thread and manager thread information.  */
-  if (ps_pdread (ta->ph, ta->handles, phc,
-		 sizeof (struct pthread_handle_struct) * 2) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Now handle these descriptors.  */
-  result = handle_descr (ta, callback, cbdata_p, state, ti_pri, 0,
-			 phc[0].h_descr);
-  if (result != TD_OK)
-    return result;
-  result = handle_descr (ta, callback, cbdata_p, state, ti_pri, 1,
-			 phc[1].h_descr);
-  if (result != TD_OK)
-    return result;
-
-  /* Read all the descriptors.  */
-  if (ps_pdread (ta->ph, ta->handles + 2, &phc[2],
-		 (sizeof (struct pthread_handle_struct)
-		  * (pthread_threads_max - 2))) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-#ifdef ALL_THREADS_STOPPED
-  /* Read the number of currently active threads.  */
-  if (ps_pdread (ta->ph, ta->pthread_handles_num, &num, sizeof (int)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-#endif
-
-  /* Now get all descriptors, one after the other.  */
-  for (cnt = 2; cnt < pthread_threads_max && num > 0; ++cnt)
-    if (phc[cnt].h_descr != NULL)
-      {
-#ifdef ALL_THREADS_STOPPED
-	/* First count this active thread.  */
-	--num;
-#endif
-
-	result = handle_descr (ta, callback, cbdata_p, state, ti_pri, cnt,
-			       phc[cnt].h_descr);
-	if (result != TD_OK)
-	  break;
-      }
-
-  return result;
-}
diff --git a/libpthread/linuxthreads.old_db/td_ta_tsd_iter.c b/libpthread/linuxthreads.old_db/td_ta_tsd_iter.c
deleted file mode 100644
index 758222cd7..000000000
--- a/libpthread/linuxthreads.old_db/td_ta_tsd_iter.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/* Iterate over a process's thread-specific data.
-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-#include <alloca.h>
-
-td_err_e
-td_ta_tsd_iter (const td_thragent_t *ta, td_key_iter_f *callback,
-		void *cbdata_p)
-{
-  struct pthread_key_struct *keys;
-  int pthread_keys_max;
-  int cnt;
-
-  LOG ("td_ta_tsd_iter");
-
-  /* Test whether the TA parameter is ok.  */
-  if (! ta_ok (ta))
-    return TD_BADTA;
-
-  pthread_keys_max = ta->pthread_keys_max;
-  keys = (struct pthread_key_struct *) alloca (sizeof (keys[0])
-					       * pthread_keys_max);
-
-  /* Read all the information about the keys.  */
-  if (ps_pdread (ta->ph, ta->keys, keys,
-		 sizeof (keys[0]) * pthread_keys_max) != PS_OK)
-	return TD_ERR;	/* XXX Other error value?  */
-
-  /* Now get all descriptors, one after the other.  */
-  for (cnt = 0; cnt < pthread_keys_max; ++cnt)
-    if (keys[cnt].in_use
-	/* Return with an error if the callback returns a nonzero value.  */
-	&& callback (cnt, keys[cnt].destr, cbdata_p) != 0)
-      return TD_DBERR;
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_clear_event.c b/libpthread/linuxthreads.old_db/td_thr_clear_event.c
deleted file mode 100644
index 67a592a10..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_clear_event.c
+++ /dev/null
@@ -1,59 +0,0 @@
-/* Disable specific event for thread.
-   Copyright (C) 1999, 2001, 2002, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <stddef.h>
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_clear_event(const td_thrhandle_t *th,td_thr_events_t *event)
-{
-  td_thr_events_t old_event;
-  int i;
-
-  LOG ("td_thr_clear_event");
-
-  /* If the thread descriptor has not yet been constructed do not do
-     anything.  */
-  if (th->th_unique == NULL)
-    return TD_OK;
-
-  /* Write the new value into the thread data structure.  */
-  if (ps_pdread (th->th_ta_p->ph,
-		 ((char *) th->th_unique
-		  + offsetof (struct _pthread_descr_struct,
-			      p_eventbuf.eventmask)),
-		 &old_event, sizeof (td_thr_events_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Remove the set bits in.  */
-  for (i = 0; i < TD_EVENTSIZE; ++i)
-    old_event.event_bits[i] &= ~event->event_bits[i];
-
-  /* Write the new value into the thread data structure.  */
-  if (ps_pdwrite (th->th_ta_p->ph,
-		  ((char *) th->th_unique
-		   + offsetof (struct _pthread_descr_struct,
-			       p_eventbuf.eventmask)),
-		  &old_event, sizeof (td_thr_events_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_dbresume.c b/libpthread/linuxthreads.old_db/td_thr_dbresume.c
deleted file mode 100644
index 3e63d8f41..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_dbresume.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/* Resume execution of given thread.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_dbresume (const td_thrhandle_t *th)
-{
-  /* XXX We have to figure out what has to be done.  */
-  LOG ("td_thr_dbresume");
-  return TD_NOCAPAB;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_dbsuspend.c b/libpthread/linuxthreads.old_db/td_thr_dbsuspend.c
deleted file mode 100644
index 557e88862..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_dbsuspend.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/* Suspend execution of given thread.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_dbsuspend (const td_thrhandle_t *th)
-{
-  /* XXX We have to figure out what has to be done.  */
-  LOG ("td_thr_dbsuspend");
-  return TD_NOCAPAB;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_event_enable.c b/libpthread/linuxthreads.old_db/td_thr_event_enable.c
deleted file mode 100644
index d55a2ce75..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_event_enable.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/* Enable event process-wide.
-   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <stddef.h>
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_event_enable(const td_thrhandle_t *th, int onoff)
-{
-  LOG ("td_thr_event_enable");
-
-  /* Write the new value into the thread data structure.  */
-  if (th->th_unique == NULL)
-    {
-      psaddr_t addr;
-
-      if (td_lookup (th->th_ta_p->ph, LINUXTHREADS_INITIAL_REPORT_EVENTS,
-		     &addr) != PS_OK)
-	/* Cannot read the symbol.  This should not happen.  */
-	return TD_ERR;
-
-      if (ps_pdwrite (th->th_ta_p->ph, addr, &onoff, sizeof (int)) != PS_OK)
-	return TD_ERR;
-
-      return TD_OK;
-    }
-
-  if (ps_pdwrite (th->th_ta_p->ph,
-		  ((char *) th->th_unique
-		   + offsetof (struct _pthread_descr_struct,
-			       p_report_events)),
-		  &onoff, sizeof (int)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_event_getmsg.c b/libpthread/linuxthreads.old_db/td_thr_event_getmsg.c
deleted file mode 100644
index d4db08b6f..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_event_getmsg.c
+++ /dev/null
@@ -1,64 +0,0 @@
-/* Retrieve event.
-   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <stddef.h>
-#include <string.h>
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_event_getmsg (const td_thrhandle_t *th, td_event_msg_t *msg)
-{
-  td_eventbuf_t event;
-
-  LOG ("td_thr_event_getmsg");
-
-  /* If the thread descriptor has not yet been created there cannot be
-     any event.  */
-  if (th->th_unique == NULL)
-    return TD_NOMSG;
-
-  /* Read the even structure from the target.  */
-  if (ps_pdread (th->th_ta_p->ph,
-		 ((char *) th->th_unique
-		  + offsetof (struct _pthread_descr_struct, p_eventbuf)),
-		 &event, sizeof (td_eventbuf_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Check whether an event occurred.  */
-  if (event.eventnum == TD_EVENT_NONE)
-    /* Nothing.  */
-    return TD_NOMSG;
-
-  /* Fill the user's data structure.  */
-  msg->event = event.eventnum;
-  msg->th_p = th;
-  msg->msg.data = (uintptr_t) event.eventdata;
-
-  /* And clear the event message in the target.  */
-  memset (&event, '\0', sizeof (td_eventbuf_t));
-  if (ps_pdwrite (th->th_ta_p->ph,
-		  ((char *) th->th_unique
-		   + offsetof (struct _pthread_descr_struct, p_eventbuf)),
-		  &event, sizeof (td_eventbuf_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_get_info.c b/libpthread/linuxthreads.old_db/td_thr_get_info.c
deleted file mode 100644
index c73f33020..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_get_info.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/* Get thread information.
-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <stddef.h>
-#include <string.h>
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_get_info (const td_thrhandle_t *th, td_thrinfo_t *infop)
-{
-  struct _pthread_descr_struct pds;
-
-  LOG ("td_thr_get_info");
-
-  /* Handle the case when the thread library is not yet initialized.  */
-  if (th->th_unique == NULL)
-    {
-      memset (&pds, '\0', sizeof (pds));
-      pds.p_tid = PTHREAD_THREADS_MAX;
-    }
-  else
-    /* Get the thread descriptor.  */
-    if (ps_pdread (th->th_ta_p->ph, th->th_unique, &pds,
-		   th->th_ta_p->sizeof_descr) != PS_OK)
-      return TD_ERR;	/* XXX Other error value?  */
-
-  /* Fill in information.  Clear first to provide reproducable
-     results for the fields we do not fill in.  */
-  memset (infop, '\0', sizeof (td_thrinfo_t));
-
-  /* We have to handle the manager thread special since the thread
-     descriptor in older versions is not fully initialized.  */
-  if (pds.p_nr == 1)
-    {
-      infop->ti_tid = th->th_ta_p->pthread_threads_max * 2 + 1;
-      infop->ti_type = TD_THR_SYSTEM;
-      infop->ti_state = TD_THR_ACTIVE;
-    }
-  else
-    {
-      infop->ti_tid = pds.p_tid;
-      infop->ti_tls = (char *) pds.p_specific;
-      infop->ti_pri = pds.p_priority;
-      infop->ti_type = TD_THR_USER;
-
-      if (! pds.p_terminated)
-	/* XXX For now there is no way to get more information.  */
-	infop->ti_state = TD_THR_ACTIVE;
-      else if (! pds.p_detached)
-	infop->ti_state = TD_THR_ZOMBIE;
-      else
-	infop->ti_state = TD_THR_UNKNOWN;
-    }
-
-  /* Initialization which are the same in both cases.  */
-  infop->ti_lid = pds.p_pid ?: ps_getpid (th->th_ta_p->ph);
-  infop->ti_ta_p = th->th_ta_p;
-  infop->ti_startfunc = pds.p_start_args.start_routine;
-  memcpy (&infop->ti_events, &pds.p_eventbuf.eventmask,
-	  sizeof (td_thr_events_t));
-  infop->ti_traceme = pds.p_report_events != 0;
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_getfpregs.c b/libpthread/linuxthreads.old_db/td_thr_getfpregs.c
deleted file mode 100644
index 0fc22097e..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_getfpregs.c
+++ /dev/null
@@ -1,57 +0,0 @@
-/* Get a thread's floating-point register set.
-   Copyright (C) 1999, 2001, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_getfpregs (const td_thrhandle_t *th, prfpregset_t *regset)
-{
-  struct _pthread_descr_struct pds;
-
-  LOG ("td_thr_getfpregs");
-
-  if (th->th_unique == NULL)
-    {
-      /* No data yet.  Use the main thread.  */
-      pid_t pid = ps_getpid (th->th_ta_p->ph);
-      if (ps_lgetfpregs (th->th_ta_p->ph, pid, regset) != PS_OK)
-	return TD_ERR;
-      return TD_OK;
-    }
-
-  /* We have to get the state and the PID for this thread.  */
-  if (ps_pdread (th->th_ta_p->ph, th->th_unique, &pds,
-		 sizeof (struct _pthread_descr_struct)) != PS_OK)
-    return TD_ERR;
-
-  /* If the thread already terminated we return all zeroes.  */
-  if (pds.p_terminated)
-    memset (regset, '\0', sizeof (*regset));
-  /* Otherwise get the register content through the callback.  */
-  else
-    {
-      pid_t pid = pds.p_pid ?: ps_getpid (th->th_ta_p->ph);
-
-      if (ps_lgetfpregs (th->th_ta_p->ph, pid, regset) != PS_OK)
-	return TD_ERR;
-    }
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_getgregs.c b/libpthread/linuxthreads.old_db/td_thr_getgregs.c
deleted file mode 100644
index a33789847..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_getgregs.c
+++ /dev/null
@@ -1,57 +0,0 @@
-/* Get a thread's general register set.
-   Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_getgregs (const td_thrhandle_t *th, prgregset_t gregs)
-{
-  struct _pthread_descr_struct pds;
-
-  LOG ("td_thr_getgregs");
-
-  if (th->th_unique == NULL)
-    {
-      /* No data yet.  Use the main thread.  */
-      pid_t pid = ps_getpid (th->th_ta_p->ph);
-      if (ps_lgetregs (th->th_ta_p->ph, pid, gregs) != PS_OK)
-	return TD_ERR;
-      return TD_OK;
-    }
-
-  /* We have to get the state and the PID for this thread.  */
-  if (ps_pdread (th->th_ta_p->ph, th->th_unique, &pds,
-		 sizeof (struct _pthread_descr_struct)) != PS_OK)
-    return TD_ERR;
-
-  /* If the thread already terminated we return all zeroes.  */
-  if (pds.p_terminated)
-    memset (gregs, '\0', sizeof (prgregset_t));
-  /* Otherwise get the register content through the callback.  */
-  else
-    {
-      pid_t pid = pds.p_pid ?: ps_getpid (th->th_ta_p->ph);
-
-      if (ps_lgetregs (th->th_ta_p->ph, pid, gregs) != PS_OK)
-	return TD_ERR;
-    }
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_getxregs.c b/libpthread/linuxthreads.old_db/td_thr_getxregs.c
deleted file mode 100644
index b98e19dd8..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_getxregs.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/* Get a thread's extra state register set.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_getxregs (const td_thrhandle_t *th, void *xregs)
-{
-  /* XXX This might be platform specific.  */
-  LOG ("td_thr_getxregs");
-  return TD_NOXREGS;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_getxregsize.c b/libpthread/linuxthreads.old_db/td_thr_getxregsize.c
deleted file mode 100644
index d7b4b13bb..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_getxregsize.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/* Get the size of the extra state register set for this architecture.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_getxregsize (const td_thrhandle_t *th, int *sizep)
-{
-  /* XXX This might be platform specific.  */
-  LOG ("td_thr_getxregsize");
-  return TD_NOXREGS;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_set_event.c b/libpthread/linuxthreads.old_db/td_thr_set_event.c
deleted file mode 100644
index 31a04f1e6..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_set_event.c
+++ /dev/null
@@ -1,59 +0,0 @@
-/* Enable specific event for thread.
-   Copyright (C) 1999, 2001, 2002, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <stddef.h>
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_set_event(const td_thrhandle_t *th, td_thr_events_t *event)
-{
-  td_thr_events_t old_event;
-  int i;
-
-  LOG ("td_thr_set_event");
-
-  /* What shall we do if no thread descriptor exists but the user
-     wants to set an event?  */
-  if (th->th_unique == NULL)
-    return TD_NOTALLOC;
-
-  /* Write the new value into the thread data structure.  */
-  if (ps_pdread (th->th_ta_p->ph,
-		 ((char *) th->th_unique
-		  + offsetof (struct _pthread_descr_struct,
-			      p_eventbuf.eventmask)),
-		 &old_event, sizeof (td_thr_events_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Or the new bits in.  */
-  for (i = 0; i < TD_EVENTSIZE; ++i)
-    old_event.event_bits[i] |= event->event_bits[i];
-
-  /* Write the new value into the thread data structure.  */
-  if (ps_pdwrite (th->th_ta_p->ph,
-		  ((char *) th->th_unique
-		   + offsetof (struct _pthread_descr_struct,
-			       p_eventbuf.eventmask)),
-		  &old_event, sizeof (td_thr_events_t)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_setfpregs.c b/libpthread/linuxthreads.old_db/td_thr_setfpregs.c
deleted file mode 100644
index 793d02ed3..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_setfpregs.c
+++ /dev/null
@@ -1,46 +0,0 @@
-/* Set a thread's floating-point register set.
-   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_setfpregs (const td_thrhandle_t *th, const prfpregset_t *fpregs)
-{
-  struct _pthread_descr_struct pds = { .p_terminated = 0, .p_pid = 0 };
-
-  LOG ("td_thr_setfpregs");
-
-  /* We have to get the state and the PID for this thread.  */
-  if (th->th_unique != NULL
-      && ps_pdread (th->th_ta_p->ph, th->th_unique, &pds,
-                 sizeof (struct _pthread_descr_struct)) != PS_OK)
-    return TD_ERR;
-
-  /* Only set the registers if the thread hasn't yet terminated.  */
-  if (pds.p_terminated == 0)
-    {
-      pid_t pid = pds.p_pid ?: ps_getpid (th->th_ta_p->ph);
-
-      if (ps_lsetfpregs (th->th_ta_p->ph, pid, fpregs) != PS_OK)
-	return TD_ERR;
-    }
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_setgregs.c b/libpthread/linuxthreads.old_db/td_thr_setgregs.c
deleted file mode 100644
index 32e394b63..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_setgregs.c
+++ /dev/null
@@ -1,46 +0,0 @@
-/* Set a thread's general register set.
-   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_setgregs (const td_thrhandle_t *th, prgregset_t gregs)
-{
-  struct _pthread_descr_struct pds = { .p_terminated = 0, .p_pid = 0 };
-
-  LOG ("td_thr_setgregs");
-
-  /* We have to get the state and the PID for this thread.  */
-  if (th->th_unique != NULL
-      && ps_pdread (th->th_ta_p->ph, th->th_unique, &pds,
-                 sizeof (struct _pthread_descr_struct)) != PS_OK)
-    return TD_ERR;
-
-  /* Only set the registers if the thread hasn't yet terminated.  */
-  if (pds.p_terminated == 0)
-    {
-      pid_t pid = pds.p_pid ?: ps_getpid (th->th_ta_p->ph);
-
-      if (ps_lsetregs (th->th_ta_p->ph, pid, gregs) != PS_OK)
-	return TD_ERR;
-    }
-
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_setprio.c b/libpthread/linuxthreads.old_db/td_thr_setprio.c
deleted file mode 100644
index 554e8ffc9..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_setprio.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/* Set a thread's priority.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_setprio (const td_thrhandle_t *th, int prio)
-{
-  /* XXX We have to figure out what has to be done.  */
-  LOG ("td_thr_setprio");
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_setsigpending.c b/libpthread/linuxthreads.old_db/td_thr_setsigpending.c
deleted file mode 100644
index c6729b4c0..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_setsigpending.c
+++ /dev/null
@@ -1,30 +0,0 @@
-/* Raise a signal for a thread.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_setsigpending (const td_thrhandle_t *th, unsigned char n,
-		      const sigset_t *ss)
-{
-  /* XXX We have to figure out what has to be done.  */
-  LOG ("td_thr_setsigpending");
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_setxregs.c b/libpthread/linuxthreads.old_db/td_thr_setxregs.c
deleted file mode 100644
index cb6b7e2fe..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_setxregs.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/* Set a thread's extra state register set.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_setxregs (const td_thrhandle_t *ta, const void *addr)
-{
-  /* XXX This might have to be platform specific.  */
-  LOG ("td_thr_setxregs");
-  return TD_NOXREGS;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_sigsetmask.c b/libpthread/linuxthreads.old_db/td_thr_sigsetmask.c
deleted file mode 100644
index e990101d3..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_sigsetmask.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/* Set a thread's signal mask.
-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_sigsetmask (const td_thrhandle_t *th, const sigset_t *ss)
-{
-  /* XXX We have to figure out what has to be done.  */
-  LOG ("td_thr_sigsetmask");
-  return TD_OK;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_tls_get_addr.c b/libpthread/linuxthreads.old_db/td_thr_tls_get_addr.c
deleted file mode 100644
index ac4d706c4..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_tls_get_addr.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/* Get address of thread local variable.
-   Copyright (C) 2002,2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <link.h>
-#include "thread_dbP.h"
-
-/* Value used for dtv entries for which the allocation is delayed.  */
-# define TLS_DTV_UNALLOCATED	((void *) -1l)
-
-
-td_err_e
-td_thr_tls_get_addr (const td_thrhandle_t *th __attribute__ ((unused)),
-		     void *map_address __attribute__ ((unused)),
-		     size_t offset __attribute__ ((unused)),
-		     void **address __attribute__ ((unused)))
-{
-#if defined(USE_TLS) && USE_TLS
-  size_t modid;
-  union dtv pdtv, *dtvp;
-
-  LOG ("td_thr_tls_get_addr");
-
-  /* Get the DTV pointer from the thread descriptor.  */
-  if (ps_pdread (th->th_ta_p->ph,
-		 &((struct _pthread_descr_struct *) th->th_unique)->p_header.data.dtvp,
-		 &dtvp, sizeof dtvp) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Read the module ID from the link_map.  */
-  if (ps_pdread (th->th_ta_p->ph,
-		 &((struct link_map *) map_address)->l_tls_modid,
-		 &modid, sizeof modid) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Get the corresponding entry in the DTV.  */
-  if (ps_pdread (th->th_ta_p->ph, dtvp + modid,
-		 &pdtv, sizeof (union dtv)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* It could be that the memory for this module is not allocated for
-     the given thread.  */
-  if (pdtv.pointer == TLS_DTV_UNALLOCATED)
-    /* There is not much we can do.  */
-    return TD_NOTALLOC;
-
-  *address = (char *) pdtv.pointer + offset;
-
-  return TD_OK;
-#else
-  return TD_ERR;
-#endif
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_tsd.c b/libpthread/linuxthreads.old_db/td_thr_tsd.c
deleted file mode 100644
index f18832f46..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_tsd.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/* Get a thread-specific data pointer for a thread.
-   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_tsd (const td_thrhandle_t *th, const thread_key_t tk, void **data)
-{
-  struct _pthread_descr_struct pds;
-  struct pthread_key_struct *keys = th->th_ta_p->keys;
-  struct pthread_key_struct key;
-  int pthread_keys_max = th->th_ta_p->pthread_keys_max;
-  int pthread_key_2ndlevel_size = th->th_ta_p->pthread_key_2ndlevel_size;
-  unsigned int idx1st;
-  unsigned int idx2nd;
-  void *p;
-
-  LOG ("td_thr_tsd");
-
-  /* If there is no thread descriptor there cannot be any thread
-     specific data.  */
-  if (th->th_unique == NULL)
-    return TD_BADKEY;
-
-  /* Get the thread descriptor.  */
-  if (ps_pdread (th->th_ta_p->ph, th->th_unique, &pds,
-		 sizeof (struct _pthread_descr_struct)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Check correct value of key.  */
-  if (tk >= pthread_keys_max)
-    return TD_BADKEY;
-
-  /* Get the key entry.  */
-  if (ps_pdread (th->th_ta_p->ph, &keys[tk], &key,
-		 sizeof (struct pthread_key_struct)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Fail if this key is not at all used.  */
-  if (! key.in_use)
-    return TD_BADKEY;
-
-  /* Compute the indeces.  */
-  idx1st = tk / pthread_key_2ndlevel_size;
-  idx2nd = tk % pthread_key_2ndlevel_size;
-
-  /* Check the pointer to the second level array.  */
-  if (pds.p_specific[idx1st] == NULL)
-    return TD_NOTSD;
-
-  /* Now get the real key.
-     XXX I don't know whether it's correct but there is currently no
-     easy way to determine whether a key was never set or the value
-     is NULL.  We return an error whenever the value is NULL.  */
-  if (ps_pdread (th->th_ta_p->ph, &pds.p_specific[idx1st][idx2nd], &p,
-		 sizeof (void *)) != PS_OK)
-    return TD_ERR;
-
-  if (p != NULL)
-    *data = p;
-
-  return p != NULL ? TD_OK : TD_NOTSD;
-}
diff --git a/libpthread/linuxthreads.old_db/td_thr_validate.c b/libpthread/linuxthreads.old_db/td_thr_validate.c
deleted file mode 100644
index ca82637b9..000000000
--- a/libpthread/linuxthreads.old_db/td_thr_validate.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/* Validate a thread handle.
-   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-
-td_err_e
-td_thr_validate (const td_thrhandle_t *th)
-{
-  struct pthread_handle_struct *handles = th->th_ta_p->handles;
-  int pthread_threads_max = th->th_ta_p->pthread_threads_max;
-  int cnt;
-  struct pthread_handle_struct phc;
-
-  LOG ("td_thr_validate");
-
-  /* A special case: if the program just starts up the handle is
-     NULL.  */
-  if (th->th_unique == NULL)
-    {
-      /* Read the first handle.  If the pointer to the thread
-	 descriptor is not NULL this is an error.  */
-      if (ps_pdread (th->th_ta_p->ph, handles, &phc,
-		     sizeof (struct pthread_handle_struct)) != PS_OK)
-	return TD_ERR;	/* XXX Other error value?  */
-
-      return phc.h_descr == NULL ? TD_OK : TD_NOTHR;
-    }
-
-  /* Now get all descriptors, one after the other.  */
-  for (cnt = 0; cnt < pthread_threads_max; ++cnt, ++handles)
-    {
-      if (ps_pdread (th->th_ta_p->ph, handles, &phc,
-		     sizeof (struct pthread_handle_struct)) != PS_OK)
-	return TD_ERR;	/* XXX Other error value?  */
-
-      if (phc.h_descr != NULL && phc.h_descr == th->th_unique)
-	{
-	  struct _pthread_descr_struct pds;
-
-	  if (ps_pdread (th->th_ta_p->ph, phc.h_descr, &pds,
-			 th->th_ta_p->sizeof_descr) != PS_OK)
-	    return TD_ERR;	/* XXX Other error value?  */
-
-	  /* XXX There should be another test using the TID but this is
-	     currently not available.  */
-	  return pds.p_terminated != 0 ? TD_NOTHR : TD_OK;
-	}
-    }
-
-  return TD_ERR;
-}
diff --git a/libpthread/linuxthreads.old_db/thread_db.h b/libpthread/linuxthreads.old_db/thread_db.h
deleted file mode 100644
index 13c30af5b..000000000
--- a/libpthread/linuxthreads.old_db/thread_db.h
+++ /dev/null
@@ -1,458 +0,0 @@
-/* thread_db.h -- interface to libthread_db.so library for debugging -lpthread
-   Copyright (C) 1999,2001,2002,2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _THREAD_DB_H
-#define _THREAD_DB_H	1
-
-/* This is the debugger interface for the LinuxThreads library.  It is
-   modelled closely after the interface with same names in Solaris with
-   the goal to share the same code in the debugger.  */
-#include <pthread.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <sys/procfs.h>
-
-
-/* Error codes of the library.  */
-typedef enum
-{
-  TD_OK,	  /* No error.  */
-  TD_ERR,	  /* No further specified error.  */
-  TD_NOTHR,	  /* No matching thread found.  */
-  TD_NOSV,	  /* No matching synchronization handle found.  */
-  TD_NOLWP,	  /* No matching light-weighted process found.  */
-  TD_BADPH,	  /* Invalid process handle.  */
-  TD_BADTH,	  /* Invalid thread handle.  */
-  TD_BADSH,	  /* Invalid synchronization handle.  */
-  TD_BADTA,	  /* Invalid thread agent.  */
-  TD_BADKEY,	  /* Invalid key.  */
-  TD_NOMSG,	  /* No event available.  */
-  TD_NOFPREGS,	  /* No floating-point register content available.  */
-  TD_NOLIBTHREAD, /* Application not linked with thread library.  */
-  TD_NOEVENT,	  /* Requested event is not supported.  */
-  TD_NOCAPAB,	  /* Capability not available.  */
-  TD_DBERR,	  /* Internal debug library error.  */
-  TD_NOAPLIC,	  /* Operation is not applicable.  */
-  TD_NOTSD,	  /* No thread-specific data available.  */
-  TD_MALLOC,	  /* Out of memory.  */
-  TD_PARTIALREG,  /* Not entire register set was read or written.  */
-  TD_NOXREGS,	  /* X register set not available for given thread.  */
-  TD_TLSDEFER,	  /* Thread has not yet allocated TLS for given module.  */
-  TD_NOTALLOC = TD_TLSDEFER,
-  TD_VERSION,	  /* Version if libpthread and libthread_db do not match.  */
-  TD_NOTLS	  /* There is TLS segment in the given module.  */
-} td_err_e;
-
-
-/* Possible thread states.  TD_THR_ANY_STATE is a pseudo-state used to
-   select threads regardless of state in td_ta_thr_iter().  */
-typedef enum
-{
-  TD_THR_ANY_STATE,
-  TD_THR_UNKNOWN,
-  TD_THR_STOPPED,
-  TD_THR_RUN,
-  TD_THR_ACTIVE,
-  TD_THR_ZOMBIE,
-  TD_THR_SLEEP,
-  TD_THR_STOPPED_ASLEEP
-} td_thr_state_e;
-
-/* Thread type: user or system.  TD_THR_ANY_TYPE is a pseudo-type used
-   to select threads regardless of type in td_ta_thr_iter().  */
-typedef enum
-{
-  TD_THR_ANY_TYPE,
-  TD_THR_USER,
-  TD_THR_SYSTEM
-} td_thr_type_e;
-
-
-/* Types of the debugging library.  */
-
-/* Handle for a process.  This type is opaque.  */
-typedef struct td_thragent td_thragent_t;
-
-/* The actual thread handle type.  This is also opaque.  */
-typedef struct td_thrhandle
-{
-  td_thragent_t *th_ta_p;
-  psaddr_t th_unique;
-} td_thrhandle_t;
-
-
-/* Forward declaration of a type defined by and for the dynamic linker.  */
-struct link_map;
-
-
-/* Flags for `td_ta_thr_iter'.  */
-#define TD_THR_ANY_USER_FLAGS	0xffffffff
-#define TD_THR_LOWEST_PRIORITY	-20
-#define TD_SIGNO_MASK		NULL
-
-
-#define TD_EVENTSIZE	2
-#define BT_UISHIFT	5 /* log base 2 of BT_NBIPUI, to extract word index */
-#define BT_NBIPUI	(1 << BT_UISHIFT)       /* n bits per uint */
-#define BT_UIMASK	(BT_NBIPUI - 1)         /* to extract bit index */
-
-/* Bitmask of enabled events. */
-typedef struct td_thr_events
-{
-  uint32_t event_bits[TD_EVENTSIZE];
-} td_thr_events_t;
-
-/* Event set manipulation macros. */
-#define __td_eventmask(n) \
-  (UINT32_C (1) << (((n) - 1) & BT_UIMASK))
-#define __td_eventword(n) \
-  ((UINT32_C ((n) - 1)) >> BT_UISHIFT)
-
-#define td_event_emptyset(setp) \
-  do {									      \
-    int __i;								      \
-    for (__i = TD_EVENTSIZE; __i > 0; --__i)				      \
-      (setp)->event_bits[__i - 1] = 0;					      \
-  } while (0)
-
-#define td_event_fillset(setp) \
-  do {									      \
-    int __i;								      \
-    for (__i = TD_EVENTSIZE; __i > 0; --__i)				      \
-      (setp)->event_bits[__i - 1] = UINT32_C (0xffffffff);		      \
-  } while (0)
-
-#define td_event_addset(setp, n) \
-  (((setp)->event_bits[__td_eventword (n)]) |= __td_eventmask (n))
-#define td_event_delset(setp, n) \
-  (((setp)->event_bits[__td_eventword (n)]) &= ~__td_eventmask (n))
-#define td_eventismember(setp, n) \
-  (__td_eventmask (n) & ((setp)->event_bits[__td_eventword (n)]))
-#if TD_EVENTSIZE == 2
-# define td_eventisempty(setp) \
-  (!((setp)->event_bits[0]) && !((setp)->event_bits[1]))
-#else
-# error "td_eventisempty must be changed to match TD_EVENTSIZE"
-#endif
-
-/* Events reportable by the thread implementation.  */
-typedef enum
-{
-  TD_ALL_EVENTS,		 /* Pseudo-event number.  */
-  TD_EVENT_NONE = TD_ALL_EVENTS, /* Depends on context.  */
-  TD_READY,			 /* Is executable now. */
-  TD_SLEEP,			 /* Blocked in a synchronization obj.  */
-  TD_SWITCHTO,			 /* Now assigned to a process.  */
-  TD_SWITCHFROM,		 /* Not anymore assigned to a process.  */
-  TD_LOCK_TRY,			 /* Trying to get an unavailable lock.  */
-  TD_CATCHSIG,			 /* Signal posted to the thread.  */
-  TD_IDLE,			 /* Process getting idle.  */
-  TD_CREATE,			 /* New thread created.  */
-  TD_DEATH,			 /* Thread terminated.  */
-  TD_PREEMPT,			 /* Preempted.  */
-  TD_PRI_INHERIT,		 /* Inherited elevated priority.  */
-  TD_REAP,			 /* Reaped.  */
-  TD_CONCURRENCY,		 /* Number of processes changing.  */
-  TD_TIMEOUT,			 /* Conditional variable wait timed out.  */
-  TD_MIN_EVENT_NUM = TD_READY,
-  TD_MAX_EVENT_NUM = TD_TIMEOUT,
-  TD_EVENTS_ENABLE = 31		/* Event reporting enabled.  */
-} td_event_e;
-
-/* Values representing the different ways events are reported.  */
-typedef enum
-{
-  NOTIFY_BPT,			/* User must insert breakpoint at u.bptaddr. */
-  NOTIFY_AUTOBPT,		/* Breakpoint at u.bptaddr is automatically
-				   inserted.  */
-  NOTIFY_SYSCALL		/* System call u.syscallno will be invoked.  */
-} td_notify_e;
-
-/* Description how event type is reported.  */
-typedef struct td_notify
-{
-  td_notify_e type;		/* Way the event is reported.  */
-  union
-  {
-    psaddr_t bptaddr;		/* Address of breakpoint.  */
-    int syscallno;		/* Number of system call used.  */
-  } u;
-} td_notify_t;
-
-/* Structure used to report event.  */
-typedef struct td_event_msg
-{
-  td_event_e event;		/* Event type being reported.  */
-  const td_thrhandle_t *th_p;	/* Thread reporting the event.  */
-  union
-  {
-# if 0
-    td_synchandle_t *sh;	/* Handle of synchronization object.  */
-#endif
-    uintptr_t data;		/* Event specific data.  */
-  } msg;
-} td_event_msg_t;
-
-/* Structure containing event data available in each thread structure.  */
-typedef struct
-{
-  td_thr_events_t eventmask;	/* Mask of enabled events.  */
-  td_event_e eventnum;		/* Number of last event.  */
-  void *eventdata;		/* Data associated with event.  */
-} td_eventbuf_t;
-
-
-/* Gathered statistics about the process.  */
-typedef struct td_ta_stats
-{
-  int nthreads;       		/* Total number of threads in use.  */
-  int r_concurrency;		/* Concurrency level requested by user.  */
-  int nrunnable_num;		/* Average runnable threads, numerator.  */
-  int nrunnable_den;		/* Average runnable threads, denominator.  */
-  int a_concurrency_num;	/* Achieved concurrency level, numerator.  */
-  int a_concurrency_den;	/* Achieved concurrency level, denominator.  */
-  int nlwps_num;		/* Average number of processes in use,
-				   numerator.  */
-  int nlwps_den;		/* Average number of processes in use,
-				   denominator.  */
-  int nidle_num;		/* Average number of idling processes,
-				   numerator.  */
-  int nidle_den;		/* Average number of idling processes,
-				   denominator.  */
-} td_ta_stats_t;
-
-
-/* Since Sun's library is based on Solaris threads we have to define a few
-   types to map them to POSIX threads.  */
-typedef pthread_t thread_t;
-typedef pthread_key_t thread_key_t;
-
-
-/* Callback for iteration over threads.  */
-typedef int td_thr_iter_f (const td_thrhandle_t *, void *);
-
-/* Callback for iteration over thread local data.  */
-typedef int td_key_iter_f (thread_key_t, void (*) (void *), void *);
-
-
-
-/* Forward declaration.  This has to be defined by the user.  */
-struct ps_prochandle;
-
-
-/* Information about the thread.  */
-typedef struct td_thrinfo
-{
-  td_thragent_t *ti_ta_p;		/* Process handle.  */
-  unsigned int ti_user_flags;		/* Unused.  */
-  thread_t ti_tid;			/* Thread ID returned by
-					   pthread_create().  */
-  char *ti_tls;				/* Pointer to thread-local data.  */
-  psaddr_t ti_startfunc;		/* Start function passed to
-					   pthread_create().  */
-  psaddr_t ti_stkbase;			/* Base of thread's stack.  */
-  long int ti_stksize;			/* Size of thread's stack.  */
-  psaddr_t ti_ro_area;			/* Unused.  */
-  int ti_ro_size;			/* Unused.  */
-  td_thr_state_e ti_state;		/* Thread state.  */
-  unsigned char ti_db_suspended;	/* Nonzero if suspended by debugger. */
-  td_thr_type_e ti_type;		/* Type of the thread (system vs
-					   user thread).  */
-  intptr_t ti_pc;			/* Unused.  */
-  intptr_t ti_sp;			/* Unused.  */
-  short int ti_flags;			/* Unused.  */
-  int ti_pri;				/* Thread priority.  */
-  lwpid_t ti_lid;			/* Unused.  */
-  sigset_t ti_sigmask;			/* Signal mask.  */
-  unsigned char ti_traceme;		/* Nonzero if event reporting
-					   enabled.  */
-  unsigned char ti_preemptflag;		/* Unused.  */
-  unsigned char ti_pirecflag;		/* Unused.  */
-  sigset_t ti_pending;			/* Set of pending signals.  */
-  td_thr_events_t ti_events;		/* Set of enabled events.  */
-} td_thrinfo_t;
-
-
-
-/* Prototypes for exported library functions.  */
-
-/* Initialize the thread debug support library.  */
-extern td_err_e td_init (void);
-
-/* Historical relict.  Should not be used anymore.  */
-extern td_err_e td_log (void);
-
-/* Return list of symbols the library can request.  */
-extern const char **td_symbol_list (void);
-
-/* Generate new thread debug library handle for process PS.  */
-extern td_err_e td_ta_new (struct ps_prochandle *__ps, td_thragent_t **__ta);
-
-/* Free resources allocated for TA.  */
-extern td_err_e td_ta_delete (td_thragent_t *__ta);
-
-/* Get number of currently running threads in process associated with TA.  */
-extern td_err_e td_ta_get_nthreads (const td_thragent_t *__ta, int *__np);
-
-/* Return process handle passed in `td_ta_new' for process associated with
-   TA.  */
-extern td_err_e td_ta_get_ph (const td_thragent_t *__ta,
-			      struct ps_prochandle **__ph);
-
-/* Map thread library handle PT to thread debug library handle for process
-   associated with TA and store result in *TH.  */
-extern td_err_e td_ta_map_id2thr (const td_thragent_t *__ta, pthread_t __pt,
-				  td_thrhandle_t *__th);
-
-/* Map process ID LWPID to thread debug library handle for process
-   associated with TA and store result in *TH.  */
-extern td_err_e td_ta_map_lwp2thr (const td_thragent_t *__ta, lwpid_t __lwpid,
-				   td_thrhandle_t *__th);
-
-
-/* Call for each thread in a process associated with TA the callback function
-   CALLBACK.  */
-extern td_err_e td_ta_thr_iter (const td_thragent_t *__ta,
-				td_thr_iter_f *__callback, void *__cbdata_p,
-				td_thr_state_e __state, int __ti_pri,
-				sigset_t *__ti_sigmask_p,
-				unsigned int __ti_user_flags);
-
-/* Call for each defined thread local data entry the callback function KI.  */
-extern td_err_e td_ta_tsd_iter (const td_thragent_t *__ta, td_key_iter_f *__ki,
-				void *__p);
-
-
-/* Get event address for EVENT.  */
-extern td_err_e td_ta_event_addr (const td_thragent_t *__ta,
-				  td_event_e __event, td_notify_t *__ptr);
-
-/* Enable EVENT in global mask.  */
-extern td_err_e td_ta_set_event (const td_thragent_t *__ta,
-				 td_thr_events_t *__event);
-
-/* Disable EVENT in global mask.  */
-extern td_err_e td_ta_clear_event (const td_thragent_t *__ta,
-				   td_thr_events_t *__event);
-
-/* Return information about last event.  */
-extern td_err_e td_ta_event_getmsg (const td_thragent_t *__ta,
-				    td_event_msg_t *__msg);
-
-
-/* Set suggested concurrency level for process associated with TA.  */
-extern td_err_e td_ta_setconcurrency (const td_thragent_t *__ta, int __level);
-
-
-/* Enable collecting statistics for process associated with TA.  */
-extern td_err_e td_ta_enable_stats (const td_thragent_t *__ta, int __enable);
-
-/* Reset statistics.  */
-extern td_err_e td_ta_reset_stats (const td_thragent_t *__ta);
-
-/* Retrieve statistics from process associated with TA.  */
-extern td_err_e td_ta_get_stats (const td_thragent_t *__ta,
-				 td_ta_stats_t *__statsp);
-
-
-/* Validate that TH is a thread handle.  */
-extern td_err_e td_thr_validate (const td_thrhandle_t *__th);
-
-/* Return information about thread TH.  */
-extern td_err_e td_thr_get_info (const td_thrhandle_t *__th,
-				 td_thrinfo_t *__infop);
-
-/* Retrieve floating-point register contents of process running thread TH.  */
-extern td_err_e td_thr_getfpregs (const td_thrhandle_t *__th,
-				  prfpregset_t *__regset);
-
-/* Retrieve general register contents of process running thread TH.  */
-extern td_err_e td_thr_getgregs (const td_thrhandle_t *__th,
-				 prgregset_t __gregs);
-
-/* Retrieve extended register contents of process running thread TH.  */
-extern td_err_e td_thr_getxregs (const td_thrhandle_t *__th, void *__xregs);
-
-/* Get size of extended register set of process running thread TH.  */
-extern td_err_e td_thr_getxregsize (const td_thrhandle_t *__th, int *__sizep);
-
-/* Set floating-point register contents of process running thread TH.  */
-extern td_err_e td_thr_setfpregs (const td_thrhandle_t *__th,
-				  const prfpregset_t *__fpregs);
-
-/* Set general register contents of process running thread TH.  */
-extern td_err_e td_thr_setgregs (const td_thrhandle_t *__th,
-				 prgregset_t __gregs);
-
-/* Set extended register contents of process running thread TH.  */
-extern td_err_e td_thr_setxregs (const td_thrhandle_t *__th,
-				 const void *__addr);
-
-
-/* Get address of the given module's TLS storage area for the given thread.  */
-extern td_err_e td_thr_tlsbase (const td_thrhandle_t *__th,
-				unsigned long int __modid,
-				psaddr_t *__base);
-
-/* Get address of thread local variable.  */
-extern td_err_e td_thr_tls_get_addr (const td_thrhandle_t *__th,
-				     void *__map_address, size_t __offset,
-				     void **__address);
-
-
-/* Enable reporting for EVENT for thread TH.  */
-extern td_err_e td_thr_event_enable (const td_thrhandle_t *__th, int __event);
-
-/* Enable EVENT for thread TH.  */
-extern td_err_e td_thr_set_event (const td_thrhandle_t *__th,
-				  td_thr_events_t *__event);
-
-/* Disable EVENT for thread TH.  */
-extern td_err_e td_thr_clear_event (const td_thrhandle_t *__th,
-				    td_thr_events_t *__event);
-
-/* Get event message for thread TH.  */
-extern td_err_e td_thr_event_getmsg (const td_thrhandle_t *__th,
-				     td_event_msg_t *__msg);
-
-
-/* Set priority of thread TH.  */
-extern td_err_e td_thr_setprio (const td_thrhandle_t *__th, int __prio);
-
-
-/* Set pending signals for thread TH.  */
-extern td_err_e td_thr_setsigpending (const td_thrhandle_t *__th,
-				      unsigned char __n, const sigset_t *__ss);
-
-/* Set signal mask for thread TH.  */
-extern td_err_e td_thr_sigsetmask (const td_thrhandle_t *__th,
-				   const sigset_t *__ss);
-
-
-/* Return thread local data associated with key TK in thread TH.  */
-extern td_err_e td_thr_tsd (const td_thrhandle_t *__th,
-			    const thread_key_t __tk, void **__data);
-
-
-/* Suspend execution of thread TH.  */
-extern td_err_e td_thr_dbsuspend (const td_thrhandle_t *__th);
-
-/* Resume execution of thread TH.  */
-extern td_err_e td_thr_dbresume (const td_thrhandle_t *__th);
-
-#endif	/* thread_db.h */
diff --git a/libpthread/linuxthreads.old_db/thread_dbP.h b/libpthread/linuxthreads.old_db/thread_dbP.h
deleted file mode 100644
index 64fd2e511..000000000
--- a/libpthread/linuxthreads.old_db/thread_dbP.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/* Private header for thread debug library.  */
-#ifndef _THREAD_DBP_H
-#define _THREAD_DBP_H	1
-
-#include <string.h>
-#include <unistd.h>
-#include "proc_service.h"
-#include "thread_db.h"
-#include "internals.h"
-
-
-/* Indices for the symbol names.  */
-enum
-  {
-    PTHREAD_THREADS_EVENTS = 0,
-    PTHREAD_LAST_EVENT,
-    PTHREAD_HANDLES_NUM,
-    PTHREAD_HANDLES,
-    PTHREAD_KEYS,
-    LINUXTHREADS_PTHREAD_THREADS_MAX,
-    LINUXTHREADS_PTHREAD_KEYS_MAX,
-    LINUXTHREADS_PTHREAD_SIZEOF_DESCR,
-    LINUXTHREADS_CREATE_EVENT,
-    LINUXTHREADS_DEATH_EVENT,
-    LINUXTHREADS_REAP_EVENT,
-    LINUXTHREADS_INITIAL_REPORT_EVENTS,
-    LINUXTHREADS_VERSION,
-    NUM_MESSAGES
-  };
-
-
-/* Comment out the following for less verbose output.  */
-#ifndef NDEBUG
-# define LOG(c) if (__td_debug) write (2, c "\n", strlen (c "\n"))
-extern int __td_debug attribute_hidden;
-#else
-# define LOG(c)
-#endif
-
-
-/* Handle for a process.  This type is opaque.  */
-struct td_thragent
-{
-  /* Delivered by the debugger and we have to pass it back in the
-     proc callbacks.  */
-  struct ps_prochandle *ph;
-
-  /* Some cached information.  */
-
-  /* Address of the `__pthread_handles' array.  */
-  struct pthread_handle_struct *handles;
-
-  /* Address of the `pthread_kyes' array.  */
-  struct pthread_key_struct *keys;
-
-  /* Maximum number of threads.  */
-  int pthread_threads_max;
-
-  /* Maximum number of thread-local data keys.  */
-  int pthread_keys_max;
-
-  /* Size of 2nd level array for thread-local data keys.  */
-  int pthread_key_2ndlevel_size;
-
-  /* Sizeof struct _pthread_descr_struct.  */
-  int sizeof_descr;
-
-  /* Pointer to the `__pthread_threads_events' variable in the target.  */
-  psaddr_t pthread_threads_eventsp;
-
-  /* Pointer to the `__pthread_last_event' variable in the target.  */
-  psaddr_t pthread_last_event;
-
-  /* Pointer to the `__pthread_handles_num' variable.  */
-  psaddr_t pthread_handles_num;
-};
-
-
-/* Type used internally to keep track of thread agent descriptors.  */
-struct agent_list
-{
-  td_thragent_t *ta;
-  struct agent_list *next;
-};
-
-/* List of all known descriptors.  */
-extern struct agent_list *__td_agent_list attribute_hidden;
-
-/* Function used to test for correct thread agent pointer.  */
-static __inline__ int
-ta_ok (const td_thragent_t *ta)
-{
-  struct agent_list *runp = __td_agent_list;
-
-  if (ta == NULL)
-    return 0;
-
-  while (runp != NULL && runp->ta != ta)
-    runp = runp->next;
-
-  return runp != NULL;
-}
-
-
-/* Internal wrapper around ps_pglobal_lookup.  */
-extern int td_lookup (struct ps_prochandle *ps, int idx, psaddr_t *sym_addr) attribute_hidden;
-
-#endif /* thread_dbP.h */
diff --git a/libpthread/linuxthreads/Makefile.in b/libpthread/linuxthreads/Makefile.in
index c1ec1c9c7..6be2099d2 100644
--- a/libpthread/linuxthreads/Makefile.in
+++ b/libpthread/linuxthreads/Makefile.in
@@ -6,23 +6,17 @@
 # Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
 #
 
-subdirs += libpthread/linuxthreads/sysdeps/$(TARGET_ARCH)
-subdirs += libpthread/linuxthreads/sysdeps/unix/sysv/linux
-subdirs += libpthread/linuxthreads/sysdeps/pthread
+subdirs += libpthread/linuxthreads.old
 
-CFLAGS-dir_linuxthreads := -DNOT_IN_libc -DIS_IN_libpthread
-CFLAGS-libpthread/linuxthreads := $(CFLAGS-dir_linuxthreads) $(SSP_ALL_CFLAGS)
-
-# This stuff will not compile without at least -O1
-# psm: can't handle this here, could maybe search for -O0 in CFLAGS
-# and append -O1 if found
-#CFLAGS:=$(CFLAGS:-O0=-O1)
+CFLAGS-dir_linuxthreads.old := -DNOT_IN_libc -DIS_IN_libpthread
+CFLAGS-libpthread/linuxthreads.old := $(CFLAGS-dir_linuxthreads.old) $(SSP_ALL_CFLAGS)
 
 ifeq ($(PTHREADS_DEBUG_SUPPORT),y)
 LDFLAGS-libpthread.so := $(LDFLAGS_NOSTRIP) -Wl,-z,defs
 else
 LDFLAGS-libpthread.so := $(LDFLAGS)
 endif
+LDFLAGS-$(UCLIBC_FORMAT_DSBT_ELF)-libpthread.so := -Wl,--dsbt-index=10
 
 LIBS-libpthread.so := $(LIBS) $(ldso)
 
@@ -31,51 +25,42 @@ END_FILE-libpthread.so := $(SHARED_END_FILES)
 
 libpthread_FULL_NAME := libpthread-$(VERSION).so
 
-libpthread_DIR := $(top_srcdir)libpthread/linuxthreads
-libpthread_OUT := $(top_builddir)libpthread/linuxthreads
+libpthread_DIR := $(top_srcdir)libpthread/linuxthreads.old
+libpthread_OUT := $(top_builddir)libpthread/linuxthreads.old
 
 -include $(libpthread_DIR)/sysdeps/$(TARGET_ARCH)/Makefile.arch
 
-pthread_arch_SRC   := pspinlock
-pthread_arch_SRC   := $(patsubst %,$(libpthread_DIR)/sysdeps/$(TARGET_ARCH)/%.c,$(pthread_arch_SRC))
-pthread_linux_SRC  := fork pt-sigsuspend register-atfork unregister-atfork
-pthread_linux_SRC  := $(patsubst %,$(libpthread_DIR)/sysdeps/unix/sysv/linux/%.c,$(pthread_linux_SRC))
-pthread_sysdep_SRC := errno-loc herrno-loc ptlongjmp
-pthread_sysdep_SRC := $(patsubst %,$(libpthread_DIR)/sysdeps/pthread/%.c,$(pthread_sysdep_SRC))
-pthread_SRC := \
-	attr barrier cancel condvar errno events join pthread \
-	lockfile manager mutex pt-machine ptcleanup \
-	ptclock_gettime ptclock_settime ptfork pthandles \
-	pthread_setegid pthread_seteuid pthread_setgid pthread_setregid \
-	pthread_setresgid pthread_setresuid pthread_setreuid pthread_setuid \
-	rwlock semaphore sighandler signals specific spinlock
-pthread_SRC := $(patsubst %,$(libpthread_DIR)/%.c,$(pthread_SRC))
-
-libpthread_static_SRC := pthread_atfork
-libpthread_SRC := $(pthread_arch_SRC) $(pthread_linux_SRC) $(pthread_sysdep_SRC) $(pthread_SRC)
+libpthread_SRC := \
+	attr.c cancel.c condvar.c errno.c events.c join.c lockfile.c manager.c \
+	mutex.c pt-machine.c ptfork.c pthread.c ptlongjmp.c \
+	rwlock.c semaphore.c signals.c specific.c spinlock.c wrapsyscall.c
+ifeq ($(UCLIBC_HAS_XLOCALE),y)
+libpthread_SRC += locale.c
+endif
+
+# remove generic sources, if arch specific version is present
+ifneq ($(strip $(libpthread_ARCH_SRC)),)
+libpthread_SRC := $(filter-out $(patsubst %.c,$(libpthread_DIR)/%.c,$(notdir $(libpthread_ARCH_SRC))),$(libpthread_SRC))
+endif
+
+libpthread_SRC := $(patsubst %,$(libpthread_DIR)/%,$(libpthread_SRC))
+
 libpthread_OBJ := $(patsubst $(libpthread_DIR)/%.c,$(libpthread_OUT)/%.o,$(libpthread_SRC))
 
 #
 # Stuff that goes into libc.so, not libpthread.so
 #
-#CFLAGS-OMIT-alloca_cutoff.c := $(CFLAGS-dir_linuxthreads)
-CFLAGS-OMIT-forward.c := $(CFLAGS-dir_linuxthreads)
-CFLAGS-OMIT-libc-cancellation.c := $(CFLAGS-dir_linuxthreads)
-CFLAGS-OMIT-libc_pthread_init.c := $(CFLAGS-dir_linuxthreads)
-libpthread_libc_CSRC := \
-	forward.c libc-cancellation.c libc_pthread_init.c # alloca_cutoff.c
+CFLAGS-OMIT-forward.c := $(CFLAGS-dir_linuxthreads.old)
+CFLAGS-OMIT-libc_pthread_init.c := $(CFLAGS-dir_linuxthreads.old)
+libpthread_libc_CSRC := forward.c libc_pthread_init.c
 libpthread_libc_OBJ  := $(patsubst %.c, $(libpthread_OUT)/%.o,$(libpthread_libc_CSRC))
-libc-static-y += $(libpthread_OUT)/libc_pthread_init.o $(libpthread_OUT)/libc-cancellation.o
+libc-static-y += $(libpthread_OUT)/libc_pthread_init.o
 libc-shared-y += $(libpthread_libc_OBJ:.o=.oS)
 
-libpthread-static-y += $(patsubst %,$(libpthread_OUT)/%.o,$(libpthread_static_SRC))
-
-libpthread-nonshared-y += $(patsubst %,$(libpthread_OUT)/%.oS,$(libpthread_static_SRC))
-
 ifeq ($(DOPIC),y)
-libpthread-a-y  += $(libpthread_OBJ:.o=.os) $(libpthread-static-y:.o=.os)
+libpthread-a-y  += $(libpthread_OBJ:.o=.os)
 else
-libpthread-a-y  += $(libpthread_OBJ) $(libpthread-static-y)
+libpthread-a-y  += $(libpthread_OBJ)
 endif
 libpthread-so-y += $(libpthread_OBJ:.o=.oS)
 
@@ -83,16 +68,12 @@ lib-a-$(UCLIBC_HAS_THREADS) += $(top_builddir)lib/libpthread.a
 lib-so-$(UCLIBC_HAS_THREADS) += $(top_builddir)lib/libpthread.so
 
 #ifeq ($(DOMULTI),n)
-$(top_builddir)lib/libpthread.so: $(libpthread_OUT)/libpthread_so.a $(libc.depend) $(top_builddir)lib/libpthread_nonshared.a
+$(top_builddir)lib/libpthread.so: $(libpthread_OUT)/libpthread_so.a $(libc.depend)
 	$(call link.so,$(libpthread_FULL_NAME),$(ABI_VERSION))
 #else
-#$(top_builddir)lib/libpthread.so: $(libpthread_OUT)/libpthread.oS | $(libc.depend) $(top_builddir)lib/libpthread_nonshared.a
+#$(top_builddir)lib/libpthread.so: $(libpthread_OUT)/libpthread.oS | $(libc.depend)
 #	$(call linkm.so,$(libpthread_FULL_NAME),$(ABI_VERSION))
 #endif
-	$(Q)$(RM) $@
-	$(Q)cat $(top_srcdir)extra/scripts/format.lds > $@.tmp
-	$(Q)echo "GROUP ( $(notdir $@).$(ABI_VERSION) libpthread_nonshared.a )" >> $@.tmp
-	$(Q)mv $@.tmp $@
 
 ifeq ($(PTHREADS_DEBUG_SUPPORT),y)
 $(libpthread_OUT)/libpthread_so.a: STRIP_FLAGS:=$(STRIP_FLAGS:-x=-X --strip-debug)
@@ -129,10 +110,10 @@ linuxthreads_headers := $(top_builddir)include/pthread.h \
 $(linuxthreads_headers): $(wildcard $(addprefix $(top_builddir)include/config/linuxthreads/,old.h new.h))
 headers-$(UCLIBC_HAS_THREADS) += $(linuxthreads_headers)
 
-objclean-y += CLEAN_libpthread/linuxthreads
-headers_clean-y += HEADERCLEAN_libpthread/linuxthreads
-HEADERCLEAN_libpthread/linuxthreads:
+objclean-y += CLEAN_libpthread/linuxthreads.old
+headers_clean-y += HEADERCLEAN_libpthread/linuxthreads.old
+HEADERCLEAN_libpthread/linuxthreads.old:
 	$(do_rm) $(linuxthreads_headers)
 
-CLEAN_libpthread/linuxthreads:
-	$(do_rm) $(addprefix $(libpthread_OUT)/,$(foreach e, o os oS a,$(foreach d, *. */*. */*/*. */*/*/*.,$(d)$(e))))
+CLEAN_libpthread/linuxthreads.old:
+	$(do_rm) $(addprefix $(libpthread_OUT)/*., o os oS a)
diff --git a/libpthread/linuxthreads/alloca_cutoff.c b/libpthread/linuxthreads/alloca_cutoff.c
deleted file mode 100644
index 9fe13a39d..000000000
--- a/libpthread/linuxthreads/alloca_cutoff.c
+++ /dev/null
@@ -1,35 +0,0 @@
-/* Determine whether block of given size can be allocated on the stack or not.
-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <alloca.h>
-#include <stdlib.h>
-#include <sys/param.h>
-#include "internals.h"
-#include <sysdep-cancel.h>
-
-int
-__libc_alloca_cutoff (size_t size)
-{
-  if (! SINGLE_THREAD_P)
-    {
-      pthread_descr self = thread_self ();
-      return size <= LIBC_THREAD_GETMEM (self, p_alloca_cutoff);
-    }
-
-  return size <= __MAX_ALLOCA_CUTOFF;
-}
diff --git a/libpthread/linuxthreads/attr.c b/libpthread/linuxthreads/attr.c
index a621c2dcc..8465c234c 100644
--- a/libpthread/linuxthreads/attr.c
+++ b/libpthread/linuxthreads/attr.c
@@ -12,49 +12,82 @@
 /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
 /* GNU Library General Public License for more details.                 */
 
+/* changed for uClibc */
+#define __sched_get_priority_min sched_get_priority_min
+#define __sched_get_priority_max sched_get_priority_max
+
 /* Handling of thread attributes */
 
 #include <errno.h>
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdio_ext.h>
-#include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <sys/param.h>
-#include <sys/resource.h>
 #include "pthread.h"
 #include "internals.h"
 
+libpthread_hidden_proto(pthread_attr_destroy)
+libpthread_hidden_proto(pthread_attr_init)
+libpthread_hidden_proto(pthread_attr_getdetachstate)
+libpthread_hidden_proto(pthread_attr_setdetachstate)
+libpthread_hidden_proto(pthread_attr_getinheritsched)
+libpthread_hidden_proto(pthread_attr_setinheritsched)
+libpthread_hidden_proto(pthread_attr_setschedparam)
+libpthread_hidden_proto(pthread_attr_getschedparam)
+libpthread_hidden_proto(pthread_attr_getschedpolicy)
+libpthread_hidden_proto(pthread_attr_setschedpolicy)
+libpthread_hidden_proto(pthread_attr_getscope)
+libpthread_hidden_proto(pthread_attr_setscope)
+
+/* NOTE: With uClibc I don't think we need this versioning stuff.
+ * Therefore, define the function pthread_attr_init() here using
+ * a strong symbol. */
 
-int __pthread_attr_init(pthread_attr_t *attr)
+/*int __pthread_attr_init_2_1(pthread_attr_t *attr)*/
+int pthread_attr_init(pthread_attr_t *attr)
 {
-  size_t ps = __getpagesize ();
+  size_t ps = getpagesize ();
 
   attr->__detachstate = PTHREAD_CREATE_JOINABLE;
   attr->__schedpolicy = SCHED_OTHER;
   attr->__schedparam.sched_priority = 0;
   attr->__inheritsched = PTHREAD_EXPLICIT_SCHED;
   attr->__scope = PTHREAD_SCOPE_SYSTEM;
-#ifdef NEED_SEPARATE_REGISTER_STACK
-  attr->__guardsize = ps + ps;
-#else
   attr->__guardsize = ps;
-#endif
   attr->__stackaddr = NULL;
   attr->__stackaddr_set = 0;
   attr->__stacksize = STACK_SIZE - ps;
   return 0;
 }
-strong_alias (__pthread_attr_init, pthread_attr_init)
+libpthread_hidden_def(pthread_attr_init)
+
+/* uClibc: leave out this for now. */
+#if defined DO_PTHREAD_VERSIONING_WITH_UCLIBC
+#if defined __PIC__ && defined DO_VERSIONING
+default_symbol_version (__pthread_attr_init_2_1, pthread_attr_init, GLIBC_2.1);
+
+int __pthread_attr_init_2_0(pthread_attr_t *attr)
+{
+  attr->__detachstate = PTHREAD_CREATE_JOINABLE;
+  attr->__schedpolicy = SCHED_OTHER;
+  attr->__schedparam.sched_priority = 0;
+  attr->__inheritsched = PTHREAD_EXPLICIT_SCHED;
+  attr->__scope = PTHREAD_SCOPE_SYSTEM;
+  return 0;
+}
+symbol_version (__pthread_attr_init_2_0, pthread_attr_init, GLIBC_2.0);
+#else
+strong_alias (__pthread_attr_init_2_1, pthread_attr_init)
+#endif
+#endif /* DO_PTHREAD_VERSIONING_WITH_UCLIBC */
 
-int __pthread_attr_destroy(pthread_attr_t *attr)
+int pthread_attr_destroy(pthread_attr_t *attr attribute_unused)
 {
   return 0;
 }
-strong_alias (__pthread_attr_destroy, pthread_attr_destroy)
+libpthread_hidden_def(pthread_attr_destroy)
+
 
-int __pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate)
+int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate)
 {
   if (detachstate < PTHREAD_CREATE_JOINABLE ||
       detachstate > PTHREAD_CREATE_DETACHED)
@@ -62,17 +95,17 @@ int __pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate)
   attr->__detachstate = detachstate;
   return 0;
 }
-strong_alias (__pthread_attr_setdetachstate, pthread_attr_setdetachstate)
+libpthread_hidden_def(pthread_attr_setdetachstate)
 
-int __pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate)
+int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate)
 {
   *detachstate = attr->__detachstate;
   return 0;
 }
-strong_alias (__pthread_attr_getdetachstate, pthread_attr_getdetachstate)
+libpthread_hidden_def(pthread_attr_getdetachstate)
 
-int __pthread_attr_setschedparam(pthread_attr_t *attr,
-                                 const struct sched_param *param)
+int pthread_attr_setschedparam(pthread_attr_t *attr,
+                               const struct sched_param *param)
 {
   int max_prio = __sched_get_priority_max(attr->__schedpolicy);
   int min_prio = __sched_get_priority_min(attr->__schedpolicy);
@@ -82,49 +115,49 @@ int __pthread_attr_setschedparam(pthread_attr_t *attr,
   memcpy (&attr->__schedparam, param, sizeof (struct sched_param));
   return 0;
 }
-strong_alias (__pthread_attr_setschedparam, pthread_attr_setschedparam)
+libpthread_hidden_def(pthread_attr_setschedparam)
 
-int __pthread_attr_getschedparam(const pthread_attr_t *attr,
-                                 struct sched_param *param)
+int pthread_attr_getschedparam(const pthread_attr_t *attr,
+                               struct sched_param *param)
 {
   memcpy (param, &attr->__schedparam, sizeof (struct sched_param));
   return 0;
 }
-strong_alias (__pthread_attr_getschedparam, pthread_attr_getschedparam)
+libpthread_hidden_def(pthread_attr_getschedparam)
 
-int __pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
+int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
 {
   if (policy != SCHED_OTHER && policy != SCHED_FIFO && policy != SCHED_RR)
     return EINVAL;
   attr->__schedpolicy = policy;
   return 0;
 }
-strong_alias (__pthread_attr_setschedpolicy, pthread_attr_setschedpolicy)
+libpthread_hidden_def(pthread_attr_setschedpolicy)
 
-int __pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
+int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
 {
   *policy = attr->__schedpolicy;
   return 0;
 }
-strong_alias (__pthread_attr_getschedpolicy, pthread_attr_getschedpolicy)
+libpthread_hidden_def(pthread_attr_getschedpolicy)
 
-int __pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit)
+int pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit)
 {
   if (inherit != PTHREAD_INHERIT_SCHED && inherit != PTHREAD_EXPLICIT_SCHED)
     return EINVAL;
   attr->__inheritsched = inherit;
   return 0;
 }
-strong_alias (__pthread_attr_setinheritsched, pthread_attr_setinheritsched)
+libpthread_hidden_def(pthread_attr_setinheritsched)
 
-int __pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit)
+int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit)
 {
   *inherit = attr->__inheritsched;
   return 0;
 }
-strong_alias (__pthread_attr_getinheritsched, pthread_attr_getinheritsched)
+libpthread_hidden_def(pthread_attr_getinheritsched)
 
-int __pthread_attr_setscope(pthread_attr_t *attr, int scope)
+int pthread_attr_setscope(pthread_attr_t *attr, int scope)
 {
   switch (scope) {
   case PTHREAD_SCOPE_SYSTEM:
@@ -136,17 +169,22 @@ int __pthread_attr_setscope(pthread_attr_t *attr, int scope)
     return EINVAL;
   }
 }
-strong_alias (__pthread_attr_setscope, pthread_attr_setscope)
+libpthread_hidden_def(pthread_attr_setscope)
 
-int __pthread_attr_getscope(const pthread_attr_t *attr, int *scope)
+int pthread_attr_getscope(const pthread_attr_t *attr, int *scope)
 {
   *scope = attr->__scope;
   return 0;
 }
-strong_alias (__pthread_attr_getscope, pthread_attr_getscope)
+libpthread_hidden_def(pthread_attr_getscope)
 
 int __pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize)
 {
+  size_t ps = getpagesize ();
+
+  /* First round up the guard size.  */
+  guardsize = roundup (guardsize, ps);
+
   /* The guard size must not be larger than the stack itself */
   if (guardsize >= attr->__stacksize) return EINVAL;
 
@@ -172,9 +210,6 @@ int __pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr)
 }
 weak_alias (__pthread_attr_setstackaddr, pthread_attr_setstackaddr)
 
-link_warning (pthread_attr_setstackaddr,
-	      "the use of `pthread_attr_setstackaddr' is deprecated, use `pthread_attr_setstack'")
-
 int __pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackaddr)
 {
   /* XXX This function has a stupid definition.  The standard specifies
@@ -184,29 +219,10 @@ int __pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackaddr)
   return 0;
 }
 weak_alias (__pthread_attr_getstackaddr, pthread_attr_getstackaddr)
-
-link_warning (pthread_attr_getstackaddr,
-	      "the use of `pthread_attr_getstackaddr' is deprecated, use `pthread_attr_getstack'")
 #endif
 
-
 int __pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize)
 {
-#ifdef FLOATING_STACKS
-  /* We have to check against the maximum allowed stack size.  This is no
-     problem if the manager is already started and we determined it.  If
-     this hasn't happened, we have to find the limit outself.  */
-  if (__pthread_max_stacksize == 0)
-    __pthread_init_max_stacksize ();
-
-  if (stacksize > __pthread_max_stacksize)
-    return EINVAL;
-#else
-  /* We have a fixed size limit.  */
-  if (stacksize > STACK_SIZE)
-    return EINVAL;
-#endif
-
   /* We don't accept value smaller than PTHREAD_STACK_MIN.  */
   if (stacksize < PTHREAD_STACK_MIN)
     return EINVAL;
@@ -214,44 +230,7 @@ int __pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize)
   attr->__stacksize = stacksize;
   return 0;
 }
-
-#if PTHREAD_STACK_MIN == 16384 || defined __UCLIBC__
 weak_alias (__pthread_attr_setstacksize, pthread_attr_setstacksize)
-#else
-versioned_symbol (libpthread, __pthread_attr_setstacksize,
-                  pthread_attr_setstacksize, GLIBC_2_3_3);
-
-# if SHLIB_COMPAT(libpthread, GLIBC_2_1, GLIBC_2_3_3)
-
-int __old_pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize)
-{
-#  ifdef FLOATING_STACKS
-  /* We have to check against the maximum allowed stack size.  This is no
-     problem if the manager is already started and we determined it.  If
-     this hasn't happened, we have to find the limit outself.  */
-  if (__pthread_max_stacksize == 0)
-    __pthread_init_max_stacksize ();
-
-  if (stacksize > __pthread_max_stacksize)
-    return EINVAL;
-#  else
-  /* We have a fixed size limit.  */
-  if (stacksize > STACK_SIZE)
-    return EINVAL;
-#  endif
-
-  /* We don't accept value smaller than old PTHREAD_STACK_MIN.  */
-  if (stacksize < 16384)
-    return EINVAL;
-
-  attr->__stacksize = stacksize;
-  return 0;
-}
-compat_symbol (libpthread, __old_pthread_attr_setstacksize,
-	       pthread_attr_setstacksize, GLIBC_2_1);
-# endif
-#endif
-
 
 int __pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize)
 {
@@ -259,211 +238,3 @@ int __pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize)
   return 0;
 }
 weak_alias (__pthread_attr_getstacksize, pthread_attr_getstacksize)
-
-int __pthread_attr_setstack (pthread_attr_t *attr, void *stackaddr,
-			     size_t stacksize)
-{
-  int err;
-
-  if ((((uintptr_t) stackaddr)
-       & (__alignof__ (struct _pthread_descr_struct) - 1)) != 0)
-    err = EINVAL;
-  else
-    err = __pthread_attr_setstacksize (attr, stacksize);
-  if (err == 0)
-    {
-#ifndef _STACK_GROWS_UP
-      attr->__stackaddr = (char *) stackaddr + stacksize;
-#else
-      attr->__stackaddr = stackaddr;
-#endif
-      attr->__stackaddr_set = 1;
-    }
-
-  return err;
-}
-
-#if PTHREAD_STACK_MIN == 16384 || defined __UCLIBC__
-weak_alias (__pthread_attr_setstack, pthread_attr_setstack)
-#else
-versioned_symbol (libpthread, __pthread_attr_setstack, pthread_attr_setstack,
-                  GLIBC_2_3_3);
-# if SHLIB_COMPAT(libpthread, GLIBC_2_2, GLIBC_2_3_3)
-int __old_pthread_attr_setstack (pthread_attr_t *attr, void *stackaddr,
-				 size_t stacksize)
-{
-  int err;
-
-  if ((((uintptr_t) stackaddr)
-       & (__alignof__ (struct _pthread_descr_struct) - 1)) != 0)
-    err = EINVAL;
-  else
-    err = __old_pthread_attr_setstacksize (attr, stacksize);
-  if (err == 0)
-    {
-#  ifndef _STACK_GROWS_UP
-      attr->__stackaddr = (char *) stackaddr + stacksize;
-#  else
-      attr->__stackaddr = stackaddr;
-#  endif
-      attr->__stackaddr_set = 1;
-    }
-
-  return err;
-}
-
-compat_symbol (libpthread, __old_pthread_attr_setstack, pthread_attr_setstack,
-               GLIBC_2_2);
-
-# endif
-#endif
-
-int __pthread_attr_getstack (const pthread_attr_t *attr, void **stackaddr,
-			     size_t *stacksize)
-{
-  /* XXX This function has a stupid definition.  The standard specifies
-     no error value but what is if no stack address was set?  We simply
-     return the value we have in the member.  */
-#ifndef _STACK_GROWS_UP
-  *stackaddr = (char *) attr->__stackaddr - attr->__stacksize;
-#else
-  *stackaddr = attr->__stackaddr;
-#endif
-  *stacksize = attr->__stacksize;
-  return 0;
-}
-weak_alias (__pthread_attr_getstack, pthread_attr_getstack)
-
-int pthread_getattr_np (pthread_t thread, pthread_attr_t *attr)
-{
-  pthread_handle handle = thread_handle (thread);
-  pthread_descr descr;
-  int ret = 0;
-
-  if (handle == NULL)
-    return ENOENT;
-
-  descr = handle->h_descr;
-
-  attr->__detachstate = (descr->p_detached
-			 ? PTHREAD_CREATE_DETACHED
-			 : PTHREAD_CREATE_JOINABLE);
-
-  attr->__schedpolicy = __sched_getscheduler (descr->p_pid);
-  if (attr->__schedpolicy == -1)
-    return errno;
-
-  if (__sched_getparam (descr->p_pid,
-			(struct sched_param *) &attr->__schedparam) != 0)
-    return errno;
-
-  attr->__inheritsched = descr->p_inheritsched;
-  attr->__scope = PTHREAD_SCOPE_SYSTEM;
-
-#ifdef _STACK_GROWS_DOWN
-# ifdef __UCLIBC_HAS_TLS__
-  attr->__stacksize = descr->p_stackaddr - (char *)descr->p_guardaddr
-		      - descr->p_guardsize;
-# else
-  attr->__stacksize = (char *)(descr + 1) - (char *)descr->p_guardaddr
-		      - descr->p_guardsize;
-# endif
-#else
-# ifdef __UCLIBC_HAS_TLS__
-  attr->__stacksize = (char *)descr->p_guardaddr - descr->p_stackaddr;
-# else
-  attr->__stacksize = (char *)descr->p_guardaddr - (char *)descr;
-# endif
-#endif
-  attr->__guardsize = descr->p_guardsize;
-  attr->__stackaddr_set = descr->p_userstack;
-#ifdef NEED_SEPARATE_REGISTER_STACK
-  if (descr->p_userstack == 0)
-    attr->__stacksize *= 2;
-  /* XXX This is awkward.  The guard pages are in the middle of the
-     two stacks.  We must count the guard size in the stack size since
-     otherwise the range of the stack area cannot be computed.  */
-  attr->__stacksize += attr->__guardsize;
-#endif
-#ifdef __UCLIBC_HAS_TLS__
-  attr->__stackaddr = descr->p_stackaddr;
-#else
-# ifndef _STACK_GROWS_UP
-  attr->__stackaddr = (char *)(descr + 1);
-# else
-  attr->__stackaddr = (char *)descr;
-# endif
-#endif
-
-#ifdef __UCLIBC_HAS_TLS__
-  if (attr->__stackaddr == NULL)
-#else
-  if (descr == &__pthread_initial_thread)
-#endif
-    {
-      /* Stack size limit.  */
-      struct rlimit rl;
-
-      /* The safest way to get the top of the stack is to read
-	 /proc/self/maps and locate the line into which
-	 __libc_stack_end falls.  */
-      FILE *fp = fopen ("/proc/self/maps", "rc");
-      if (fp == NULL)
-	ret = errno;
-      /* We need the limit of the stack in any case.  */
-      else if (getrlimit (RLIMIT_STACK, &rl) != 0)
-	ret = errno;
-      else
-	{
-	  /* We need no locking.  */
-	  __fsetlocking (fp, FSETLOCKING_BYCALLER);
-
-	  /* Until we found an entry (which should always be the case)
-	     mark the result as a failure.  */
-	  ret = ENOENT;
-
-	  char *line = NULL;
-	  size_t linelen = 0;
-	  uintptr_t last_to = 0;
-
-	  while (! feof_unlocked (fp))
-	    {
-	      if (getdelim (&line, &linelen, '\n', fp) <= 0)
-		break;
-
-	      uintptr_t from;
-	      uintptr_t to;
-	      if (sscanf (line, "%" SCNxPTR "-%" SCNxPTR, &from, &to) != 2)
-		continue;
-	      if (from <= (uintptr_t) __libc_stack_end
-		  && (uintptr_t) __libc_stack_end < to)
-		{
-		  /* Found the entry.  Now we have the info we need.  */
-		  attr->__stacksize = rl.rlim_cur;
-#ifdef _STACK_GROWS_UP
-		  /* Don't check to enforce a limit on the __stacksize */
-		  attr->__stackaddr = (void *) from;
-#else
-		  attr->__stackaddr = (void *) to;
-
-		  /* The limit might be too high.  */
-		  if ((size_t) attr->__stacksize
-		      > (size_t) attr->__stackaddr - last_to)
-		    attr->__stacksize = (size_t) attr->__stackaddr - last_to;
-#endif
-
-		  /* We succeed and no need to look further.  */
-		  ret = 0;
-		  break;
-		}
-	      last_to = to;
-	    }
-
-	  fclose (fp);
-	  free (line);
-	}
-    }
-
-  return 0;
-
-}
diff --git a/libpthread/linuxthreads/barrier.c b/libpthread/linuxthreads/barrier.c
deleted file mode 100644
index 2e2521b19..000000000
--- a/libpthread/linuxthreads/barrier.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/* POSIX barrier implementation for LinuxThreads.
-   Copyright (C) 2000, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Kaz Kylheku <kaz@ashi.footprints.net>, 2000.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include "pthread.h"
-#include "internals.h"
-#include "spinlock.h"
-#include "queue.h"
-#include "restart.h"
-
-int
-pthread_barrier_wait(pthread_barrier_t *barrier)
-{
-  pthread_descr self = thread_self();
-  pthread_descr temp_wake_queue, th;
-  int result = 0;
-
-  __pthread_lock(&barrier->__ba_lock, self);
-
-  /* If the required number of threads have achieved rendezvous... */
-  if (barrier->__ba_present >= barrier->__ba_required - 1)
-    {
-      /* ... then this last caller shall be the serial thread */
-      result = PTHREAD_BARRIER_SERIAL_THREAD;
-      /* Copy and clear wait queue and reset barrier. */
-      temp_wake_queue = barrier->__ba_waiting;
-      barrier->__ba_waiting = NULL;
-      barrier->__ba_present = 0;
-    }
-  else
-    {
-      result = 0;
-      barrier->__ba_present++;
-      enqueue(&barrier->__ba_waiting, self);
-    }
-
-  __pthread_unlock(&barrier->__ba_lock);
-
-  if (result == 0)
-    {
-      /* Non-serial threads have to suspend */
-      suspend(self);
-      /* We don't bother dealing with cancellation because the POSIX
-         spec for barriers doesn't mention that pthread_barrier_wait
-         is a cancellation point. */
-    }
-  else
-    {
-      /* Serial thread wakes up all others. */
-      while ((th = dequeue(&temp_wake_queue)) != NULL)
-	restart(th);
-    }
-
-  return result;
-}
-
-int
-pthread_barrier_init(pthread_barrier_t *barrier,
-				const pthread_barrierattr_t *attr,
-				unsigned int count)
-{
-  if (count == 0)
-     return EINVAL;
-
-  __pthread_init_lock(&barrier->__ba_lock);
-  barrier->__ba_required = count;
-  barrier->__ba_present = 0;
-  barrier->__ba_waiting = NULL;
-  return 0;
-}
-
-int
-pthread_barrier_destroy(pthread_barrier_t *barrier)
-{
-  if (barrier->__ba_waiting != NULL) return EBUSY;
-  return 0;
-}
-
-int
-pthread_barrierattr_init(pthread_barrierattr_t *attr)
-{
-  attr->__pshared = PTHREAD_PROCESS_PRIVATE;
-  return 0;
-}
-
-int
-pthread_barrierattr_destroy(pthread_barrierattr_t *attr)
-{
-  return 0;
-}
-
-int
-__pthread_barrierattr_getpshared(const pthread_barrierattr_t *attr,
-				 int *pshared)
-{
-  *pshared = PTHREAD_PROCESS_PRIVATE;
-  return 0;
-}
-
-int
-pthread_barrierattr_setpshared(pthread_barrierattr_t *attr, int pshared)
-{
-  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
-    return EINVAL;
-
-  /* For now it is not possible to shared a conditional variable.  */
-  if (pshared != PTHREAD_PROCESS_PRIVATE)
-    return ENOSYS;
-
-  return 0;
-}
diff --git a/libpthread/linuxthreads/cancel.c b/libpthread/linuxthreads/cancel.c
index 21b8d900c..392d1d586 100644
--- a/libpthread/linuxthreads/cancel.c
+++ b/libpthread/linuxthreads/cancel.c
@@ -19,6 +19,13 @@
 #include "internals.h"
 #include "spinlock.h"
 #include "restart.h"
+#ifdef __UCLIBC_HAS_RPC__
+#include <rpc/rpc.h>
+extern void __rpc_thread_destroy(void);
+#endif
+#include <bits/stackinfo.h>
+
+#include <stdio.h>
 
 #ifdef _STACK_GROWS_DOWN
 # define FRAME_LEFT(frame, other) ((char *) frame >= (char *) other)
@@ -28,8 +35,10 @@
 # error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
 #endif
 
+libpthread_hidden_proto(pthread_setcancelstate)
+libpthread_hidden_proto(pthread_setcanceltype)
 
-int __pthread_setcancelstate(int state, int * oldstate)
+int pthread_setcancelstate(int state, int * oldstate)
 {
   pthread_descr self = thread_self();
   if (state < PTHREAD_CANCEL_ENABLE || state > PTHREAD_CANCEL_DISABLE)
@@ -42,9 +51,9 @@ int __pthread_setcancelstate(int state, int * oldstate)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
   return 0;
 }
-strong_alias (__pthread_setcancelstate, pthread_setcancelstate)
+libpthread_hidden_def(pthread_setcancelstate)
 
-int __pthread_setcanceltype(int type, int * oldtype)
+int pthread_setcanceltype(int type, int * oldtype)
 {
   pthread_descr self = thread_self();
   if (type < PTHREAD_CANCEL_DEFERRED || type > PTHREAD_CANCEL_ASYNCHRONOUS)
@@ -57,33 +66,7 @@ int __pthread_setcanceltype(int type, int * oldtype)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
   return 0;
 }
-strong_alias (__pthread_setcanceltype, pthread_setcanceltype)
-
-
-/* The next two functions are similar to pthread_setcanceltype() but
-   more specialized for the use in the cancelable functions like write().
-   They do not need to check parameters etc.  */
-int
-attribute_hidden
-__pthread_enable_asynccancel (void)
-{
-  pthread_descr self = thread_self();
-  int oldtype = THREAD_GETMEM(self, p_canceltype);
-  THREAD_SETMEM(self, p_canceltype, PTHREAD_CANCEL_ASYNCHRONOUS);
-  if (__builtin_expect (THREAD_GETMEM(self, p_canceled), 0) &&
-      THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE)
-    __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
-  return oldtype;
-}
-
-void
-internal_function attribute_hidden
-__pthread_disable_asynccancel (int oldtype)
-{
-  pthread_descr self = thread_self();
-  THREAD_SETMEM(self, p_canceltype, oldtype);
-}
-
+libpthread_hidden_def(pthread_setcanceltype)
 
 int pthread_cancel(pthread_t thread)
 {
@@ -184,6 +167,7 @@ void _pthread_cleanup_push_defer(struct _pthread_cleanup_buffer * buffer,
   THREAD_SETMEM(self, p_canceltype, PTHREAD_CANCEL_DEFERRED);
   THREAD_SETMEM(self, p_cleanup, buffer);
 }
+strong_alias(_pthread_cleanup_push_defer,__pthread_cleanup_push_defer)
 
 void _pthread_cleanup_pop_restore(struct _pthread_cleanup_buffer * buffer,
 				  int execute)
@@ -197,36 +181,26 @@ void _pthread_cleanup_pop_restore(struct _pthread_cleanup_buffer * buffer,
       THREAD_GETMEM(self, p_canceltype) == PTHREAD_CANCEL_ASYNCHRONOUS)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
 }
+strong_alias(_pthread_cleanup_pop_restore,__pthread_cleanup_pop_restore)
+
 
-extern void __rpc_thread_destroy(void);
 void __pthread_perform_cleanup(char *currentframe)
 {
   pthread_descr self = thread_self();
-  struct _pthread_cleanup_buffer *c = THREAD_GETMEM(self, p_cleanup);
-  struct _pthread_cleanup_buffer *last;
-
-  if (c != NULL)
-    while (FRAME_LEFT (currentframe, c))
-      {
-	last = c;
-	c = c->__prev;
-
-	if (c == NULL || FRAME_LEFT (last, c))
-	  {
-	    c = NULL;
-	    break;
-	  }
-      }
-
-  while (c != NULL)
-    {
-      c->__routine(c->__arg);
+  struct _pthread_cleanup_buffer * c;
 
-      last = c;
-      c = c->__prev;
-
-      if (FRAME_LEFT (last, c))
+  for (c = THREAD_GETMEM(self, p_cleanup); c != NULL; c = c->__prev)
+    {
+#ifdef _STACK_GROWS_DOWN
+      if ((char *) c <= currentframe)
 	break;
+#elif defined _STACK_GROWS_UP
+      if ((char *) c >= currentframe)
+	break;
+#else
+# error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
+#endif
+      c->__routine(c->__arg);
     }
 
 #ifdef __UCLIBC_HAS_RPC__
@@ -235,3 +209,11 @@ void __pthread_perform_cleanup(char *currentframe)
       __rpc_thread_destroy ();
 #endif
 }
+
+#ifndef __PIC__
+/* We need a hook to force the cancellation wrappers to be linked in when
+   static libpthread is used.  */
+extern const char __pthread_provide_wrappers;
+static const char *const __pthread_require_wrappers =
+  &__pthread_provide_wrappers;
+#endif
diff --git a/libpthread/linuxthreads/condvar.c b/libpthread/linuxthreads/condvar.c
index d7b2e9886..35daacf15 100644
--- a/libpthread/linuxthreads/condvar.c
+++ b/libpthread/linuxthreads/condvar.c
@@ -25,28 +25,28 @@
 #include "queue.h"
 #include "restart.h"
 
-int __pthread_cond_init(pthread_cond_t *cond,
-                        const pthread_condattr_t *cond_attr)
+int pthread_cond_init(pthread_cond_t *cond,
+                      const pthread_condattr_t *cond_attr attribute_unused)
 {
   __pthread_init_lock(&cond->__c_lock);
   cond->__c_waiting = NULL;
   return 0;
 }
-strong_alias (__pthread_cond_init, pthread_cond_init)
+libpthread_hidden_def(pthread_cond_init)
 
-int __pthread_cond_destroy(pthread_cond_t *cond)
+int pthread_cond_destroy(pthread_cond_t *cond)
 {
   if (cond->__c_waiting != NULL) return EBUSY;
   return 0;
 }
-strong_alias (__pthread_cond_destroy, pthread_cond_destroy)
+libpthread_hidden_def(pthread_cond_destroy)
 
 /* Function called by pthread_cancel to remove the thread from
    waiting on a condition variable queue. */
 
 static int cond_extricate_func(void *obj, pthread_descr th)
 {
-  __volatile__ pthread_descr self = thread_self();
+  volatile pthread_descr self = thread_self();
   pthread_cond_t *cond = obj;
   int did_remove = 0;
 
@@ -57,9 +57,9 @@ static int cond_extricate_func(void *obj, pthread_descr th)
   return did_remove;
 }
 
-int __pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
+int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
 {
-  __volatile__ pthread_descr self = thread_self();
+  volatile pthread_descr self = thread_self();
   pthread_extricate_if extr;
   int already_canceled = 0;
   int spurious_wakeup_count;
@@ -98,7 +98,7 @@ int __pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
   }
 
-  pthread_mutex_unlock(mutex);
+  __pthread_mutex_unlock(mutex);
 
   spurious_wakeup_count = 0;
   while (1)
@@ -123,7 +123,7 @@ int __pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
   if (THREAD_GETMEM(self, p_woken_by_cancel)
       && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE) {
     THREAD_SETMEM(self, p_woken_by_cancel, 0);
-    pthread_mutex_lock(mutex);
+    __pthread_mutex_lock(mutex);
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
   }
 
@@ -131,17 +131,17 @@ int __pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
   while (spurious_wakeup_count--)
     restart(self);
 
-  pthread_mutex_lock(mutex);
+  __pthread_mutex_lock(mutex);
   return 0;
 }
-strong_alias (__pthread_cond_wait, pthread_cond_wait)
+libpthread_hidden_def(pthread_cond_wait)
 
 static int
 pthread_cond_timedwait_relative(pthread_cond_t *cond,
 				pthread_mutex_t *mutex,
 				const struct timespec * abstime)
 {
-  __volatile__ pthread_descr self = thread_self();
+  volatile pthread_descr self = thread_self();
   int already_canceled = 0;
   pthread_extricate_if extr;
   int spurious_wakeup_count;
@@ -174,7 +174,7 @@ pthread_cond_timedwait_relative(pthread_cond_t *cond,
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
   }
 
-  pthread_mutex_unlock(mutex);
+  __pthread_mutex_unlock(mutex);
 
   spurious_wakeup_count = 0;
   while (1)
@@ -191,7 +191,7 @@ pthread_cond_timedwait_relative(pthread_cond_t *cond,
 
 	if (was_on_queue) {
 	  __pthread_set_own_extricate_if(self, 0);
-	  pthread_mutex_lock(mutex);
+	  __pthread_mutex_lock(mutex);
 	  return ETIMEDOUT;
 	}
 
@@ -218,7 +218,7 @@ pthread_cond_timedwait_relative(pthread_cond_t *cond,
   if (THREAD_GETMEM(self, p_woken_by_cancel)
       && THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE) {
     THREAD_SETMEM(self, p_woken_by_cancel, 0);
-    pthread_mutex_lock(mutex);
+    __pthread_mutex_lock(mutex);
     __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
   }
 
@@ -226,19 +226,19 @@ pthread_cond_timedwait_relative(pthread_cond_t *cond,
   while (spurious_wakeup_count--)
     restart(self);
 
-  pthread_mutex_lock(mutex);
+  __pthread_mutex_lock(mutex);
   return 0;
 }
 
-int __pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
-			     const struct timespec * abstime)
+int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
+                           const struct timespec * abstime)
 {
   /* Indirect call through pointer! */
   return pthread_cond_timedwait_relative(cond, mutex, abstime);
 }
-strong_alias (__pthread_cond_timedwait, pthread_cond_timedwait)
+libpthread_hidden_def(pthread_cond_timedwait)
 
-int __pthread_cond_signal(pthread_cond_t *cond)
+int pthread_cond_signal(pthread_cond_t *cond)
 {
   pthread_descr th;
 
@@ -252,9 +252,9 @@ int __pthread_cond_signal(pthread_cond_t *cond)
   }
   return 0;
 }
-strong_alias (__pthread_cond_signal, pthread_cond_signal)
+libpthread_hidden_def(pthread_cond_signal)
 
-int __pthread_cond_broadcast(pthread_cond_t *cond)
+int pthread_cond_broadcast(pthread_cond_t *cond)
 {
   pthread_descr tosignal, th;
 
@@ -271,27 +271,27 @@ int __pthread_cond_broadcast(pthread_cond_t *cond)
   }
   return 0;
 }
-strong_alias (__pthread_cond_broadcast, pthread_cond_broadcast)
+libpthread_hidden_def(pthread_cond_broadcast)
 
-int __pthread_condattr_init(pthread_condattr_t *attr)
+int pthread_condattr_init(pthread_condattr_t *attr attribute_unused)
 {
   return 0;
 }
-strong_alias (__pthread_condattr_init, pthread_condattr_init)
+libpthread_hidden_def(pthread_condattr_init)
 
-int __pthread_condattr_destroy(pthread_condattr_t *attr)
+int pthread_condattr_destroy(pthread_condattr_t *attr attribute_unused)
 {
   return 0;
 }
-strong_alias (__pthread_condattr_destroy, pthread_condattr_destroy)
+libpthread_hidden_def(pthread_condattr_destroy)
 
-int pthread_condattr_getpshared (const pthread_condattr_t *attr, int *pshared)
+int pthread_condattr_getpshared (const pthread_condattr_t *attr attribute_unused, int *pshared)
 {
   *pshared = PTHREAD_PROCESS_PRIVATE;
   return 0;
 }
 
-int pthread_condattr_setpshared (pthread_condattr_t *attr, int pshared)
+int pthread_condattr_setpshared (pthread_condattr_t *attr attribute_unused, int pshared)
 {
   if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
     return EINVAL;
diff --git a/libpthread/linuxthreads.old/debug.h b/libpthread/linuxthreads/debug.h
similarity index 100%
rename from libpthread/linuxthreads.old/debug.h
rename to libpthread/linuxthreads/debug.h
diff --git a/libpthread/linuxthreads/descr.h b/libpthread/linuxthreads/descr.h
deleted file mode 100644
index 1c816b225..000000000
--- a/libpthread/linuxthreads/descr.h
+++ /dev/null
@@ -1,268 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-#ifndef _DESCR_H
-#define _DESCR_H	1
-
-#define __need_res_state
-#include <resolv.h>
-#include <sched.h>
-#include <setjmp.h>
-#include <signal.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include <hp-timing.h>
-#ifdef __UCLIBC_HAS_TLS__
-#include <tls.h>
-#endif
-#include "uClibc-glue.h"
-
-/* Fast thread-specific data internal to libc.  */
-enum __libc_tsd_key_t { _LIBC_TSD_KEY_MALLOC = 0,
-			_LIBC_TSD_KEY_DL_ERROR,
-			_LIBC_TSD_KEY_RPC_VARS,
-			_LIBC_TSD_KEY_LOCALE,
-			_LIBC_TSD_KEY_CTYPE_B,
-			_LIBC_TSD_KEY_CTYPE_TOLOWER,
-			_LIBC_TSD_KEY_CTYPE_TOUPPER,
-			_LIBC_TSD_KEY_N };
-
-/* The type of thread descriptors */
-typedef struct _pthread_descr_struct *pthread_descr;
-
-
-/* Some more includes.  */
-#include <pt-machine.h>
-#include <linuxthreads_db/thread_dbP.h>
-
-
-/* Arguments passed to thread creation routine */
-struct pthread_start_args {
-  void *(*start_routine)(void *); /* function to run */
-  void *arg;                      /* its argument */
-  sigset_t mask;                  /* initial signal mask for thread */
-  int schedpolicy;                /* initial scheduling policy (if any) */
-  struct sched_param schedparam;  /* initial scheduling parameters (if any) */
-};
-
-
-/* Callback interface for removing the thread from waiting on an
-   object if it is cancelled while waiting or about to wait.
-   This hold a pointer to the object, and a pointer to a function
-   which ``extricates'' the thread from its enqueued state.
-   The function takes two arguments: pointer to the wait object,
-   and a pointer to the thread. It returns 1 if an extrication
-   actually occured, and hence the thread must also be signalled.
-   It returns 0 if the thread had already been extricated. */
-typedef struct _pthread_extricate_struct {
-    void *pu_object;
-    int (*pu_extricate_func)(void *, pthread_descr);
-} pthread_extricate_if;
-
-
-/* Atomic counter made possible by compare_and_swap */
-struct pthread_atomic {
-  long p_count;
-  int p_spinlock;
-};
-
-
-/* Context info for read write locks. The pthread_rwlock_info structure
-   is information about a lock that has been read-locked by the thread
-   in whose list this structure appears. The pthread_rwlock_context
-   is embedded in the thread context and contains a pointer to the
-   head of the list of lock info structures, as well as a count of
-   read locks that are untracked, because no info structure could be
-   allocated for them. */
-struct _pthread_rwlock_t;
-typedef struct _pthread_rwlock_info {
-  struct _pthread_rwlock_info *pr_next;
-  struct _pthread_rwlock_t *pr_lock;
-  int pr_lock_count;
-} pthread_readlock_info;
-
-
-/* We keep thread specific data in a special data structure, a two-level
-   array.  The top-level array contains pointers to dynamically allocated
-   arrays of a certain number of data pointers.  So we can implement a
-   sparse array.  Each dynamic second-level array has
-	PTHREAD_KEY_2NDLEVEL_SIZE
-   entries.  This value shouldn't be too large.  */
-#define PTHREAD_KEY_2NDLEVEL_SIZE	32
-
-/* We need to address PTHREAD_KEYS_MAX key with PTHREAD_KEY_2NDLEVEL_SIZE
-   keys in each subarray.  */
-#define PTHREAD_KEY_1STLEVEL_SIZE \
-  ((PTHREAD_KEYS_MAX + PTHREAD_KEY_2NDLEVEL_SIZE - 1) \
-   / PTHREAD_KEY_2NDLEVEL_SIZE)
-
-
-union dtv;
-
-struct _pthread_descr_struct
-{
-#if !defined __UCLIBC_HAS_TLS__ || !TLS_DTV_AT_TP || INCLUDE_TLS_PADDING
-  /* This overlaps tcbhead_t (see tls.h), as used for TLS without threads.  */
-  union
-  {
-    struct
-    {
-      void *tcb;		/* Pointer to the TCB.  This is not always
-				   the address of this thread descriptor.  */
-      union dtv *dtvp;
-      pthread_descr self;	/* Pointer to this structure */
-      int multiple_threads;
-      uintptr_t sysinfo;
-    } data;
-    void *__padding[16];
-  } p_header;
-# define p_multiple_threads p_header.data.multiple_threads
-#elif defined TLS_MULTIPLE_THREADS_IN_TCB && TLS_MULTIPLE_THREADS_IN_TCB
-  int p_multiple_threads;
-#endif
-
-  pthread_descr p_nextlive, p_prevlive;
-                                /* Double chaining of active threads */
-  pthread_descr p_nextwaiting;  /* Next element in the queue holding the thr */
-  pthread_descr p_nextlock;	/* can be on a queue and waiting on a lock */
-  pthread_t p_tid;              /* Thread identifier */
-  int p_pid;                    /* PID of Unix process */
-  int p_priority;               /* Thread priority (== 0 if not realtime) */
-  struct _pthread_fastlock * p_lock; /* Spinlock for synchronized accesses */
-  int p_signal;                 /* last signal received */
-  sigjmp_buf * p_signal_jmp;    /* where to siglongjmp on a signal or NULL */
-  sigjmp_buf * p_cancel_jmp;    /* where to siglongjmp on a cancel or NULL */
-  char p_terminated;            /* true if terminated e.g. by pthread_exit */
-  char p_detached;              /* true if detached */
-  char p_exited;                /* true if the assoc. process terminated */
-  void * p_retval;              /* placeholder for return value */
-  int p_retcode;                /* placeholder for return code */
-  pthread_descr p_joining;      /* thread joining on that thread or NULL */
-  struct _pthread_cleanup_buffer * p_cleanup; /* cleanup functions */
-  char p_cancelstate;           /* cancellation state */
-  char p_canceltype;            /* cancellation type (deferred/async) */
-  char p_canceled;              /* cancellation request pending */
-  char * p_in_sighandler;       /* stack address of sighandler, or NULL */
-  char p_sigwaiting;            /* true if a sigwait() is in progress */
-  struct pthread_start_args p_start_args; /* arguments for thread creation */
-  void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE]; /* thread-specific data */
-#ifndef __UCLIBC_HAS_TLS__
-  void * p_libc_specific[_LIBC_TSD_KEY_N]; /* thread-specific data for libc */
-  int * p_errnop;               /* pointer to used errno variable */
-  int p_errno;                  /* error returned by last system call */
-  int * p_h_errnop;             /* pointer to used h_errno variable */
-  int p_h_errno;                /* error returned by last netdb function */
-  struct __res_state *p_resp;	/* Pointer to resolver state */
-#endif
-  struct __res_state p_res;	/* per-thread resolver state */
-  int p_userstack;		/* nonzero if the user provided the stack */
-  void *p_guardaddr;		/* address of guard area or NULL */
-  size_t p_guardsize;		/* size of guard area */
-  int p_nr;                     /* Index of descriptor in __pthread_handles */
-  int p_report_events;		/* Nonzero if events must be reported.  */
-  td_eventbuf_t p_eventbuf;     /* Data for event.  */
-  struct pthread_atomic p_resume_count; /* number of times restart() was
-					   called on thread */
-  char p_woken_by_cancel;       /* cancellation performed wakeup */
-  char p_condvar_avail;		/* flag if conditional variable became avail */
-  char p_sem_avail;             /* flag if semaphore became available */
-  pthread_extricate_if *p_extricate; /* See above */
-  pthread_readlock_info *p_readlock_list;  /* List of readlock info structs */
-  pthread_readlock_info *p_readlock_free;  /* Free list of structs */
-  int p_untracked_readlock_count;	/* Readlocks not tracked by list */
-  int p_inheritsched;           /* copied from the thread attribute */
-#if HP_TIMING_AVAIL
-  hp_timing_t p_cpuclock_offset; /* Initial CPU clock for thread.  */
-#endif
-#ifdef __UCLIBC_HAS_TLS__
-  char *p_stackaddr;		/* Stack address.  */
-#endif
-  size_t p_alloca_cutoff;	/* Maximum size which should be allocated
-				   using alloca() instead of malloc().  */
-  /* New elements must be added at the end.  */
-} __attribute__ ((aligned(32))); /* We need to align the structure so that
-				    doubles are aligned properly.  This is 8
-				    bytes on MIPS and 16 bytes on MIPS64.
-				    32 bytes might give better cache
-				    utilization.  */
-
-
-
-/* Limit between the stack of the initial thread (above) and the
-   stacks of other threads (below). Aligned on a STACK_SIZE boundary.
-   Initially 0, meaning that the current thread is (by definition)
-   the initial thread. */
-
-extern char *__pthread_initial_thread_bos;
-
-/* Descriptor of the initial thread */
-
-extern struct _pthread_descr_struct __pthread_initial_thread;
-
-/* Limits of the thread manager stack. */
-
-extern char *__pthread_manager_thread_bos;
-extern char *__pthread_manager_thread_tos;
-
-/* Descriptor of the manager thread */
-
-extern struct _pthread_descr_struct __pthread_manager_thread;
-extern pthread_descr __pthread_manager_threadp attribute_hidden;
-
-/* Indicate whether at least one thread has a user-defined stack (if 1),
-   or all threads have stacks supplied by LinuxThreads (if 0). */
-
-extern int __pthread_nonstandard_stacks;
-
-/* The max size of the thread stack segments.  If the default
-   THREAD_SELF implementation is used, this must be a power of two and
-   a multiple of PAGE_SIZE.  */
-#ifndef STACK_SIZE
-#define STACK_SIZE  (2 * 1024 * 1024)
-#endif
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#ifndef CURRENT_STACK_FRAME
-#define CURRENT_STACK_FRAME  ({ char __csf; &__csf; })
-#endif
-
-/* Recover thread descriptor for the current thread */
-
-extern pthread_descr __pthread_find_self (void) __attribute__ ((pure));
-
-static __inline__ pthread_descr thread_self (void) __attribute__ ((pure));
-static __inline__ pthread_descr thread_self (void)
-{
-#ifdef THREAD_SELF
-  return THREAD_SELF;
-#else
-  char *sp = CURRENT_STACK_FRAME;
-  if (sp >= __pthread_initial_thread_bos)
-    return &__pthread_initial_thread;
-  else if (sp >= __pthread_manager_thread_bos
-	   && sp < __pthread_manager_thread_tos)
-    return &__pthread_manager_thread;
-  else if (__pthread_nonstandard_stacks)
-    return __pthread_find_self();
-  else
-#ifdef _STACK_GROWS_DOWN
-    return (pthread_descr)(((unsigned long)sp | (STACK_SIZE-1))+1) - 1;
-#else
-    return (pthread_descr)((unsigned long)sp &~ (STACK_SIZE-1));
-#endif
-#endif
-}
-
-#endif	/* descr.h */
diff --git a/libpthread/linuxthreads/errno.c b/libpthread/linuxthreads/errno.c
index b8d9eb343..748c1d512 100644
--- a/libpthread/linuxthreads/errno.c
+++ b/libpthread/linuxthreads/errno.c
@@ -16,12 +16,10 @@
 
 #include <errno.h>
 #include <netdb.h>
-#include <resolv.h>
 #include "pthread.h"
 #include "internals.h"
+#include <stdio.h>
 
-#ifndef __UCLIBC_HAS_TLS__
-/* The definition in libc is sufficient if we use TLS.  */
 int *
 __errno_location (void)
 {
@@ -35,14 +33,3 @@ __h_errno_location (void)
   pthread_descr self = thread_self();
   return THREAD_GETMEM (self, p_h_errnop);
 }
-
-#if 0
-/* Return thread specific resolver state.  */
-struct __res_state *
-__res_state (void)
-{
-  pthread_descr self = thread_self();
-  return THREAD_GETMEM (self, p_resp);
-}
-#endif
-#endif
diff --git a/libpthread/linuxthreads/events.c b/libpthread/linuxthreads/events.c
index 62bf122fa..2a76f91d4 100644
--- a/libpthread/linuxthreads/events.c
+++ b/libpthread/linuxthreads/events.c
@@ -1,20 +1,20 @@
 /* Event functions used while debugging.
-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1999 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
    License, or (at your option) any later version.
 
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
+   Library General Public License for more details.
 
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   see <http://www.gnu.org/licenses/>.  */
 
 /* The functions contained here do nothing, they just return.  */
 
diff --git a/libpthread/linuxthreads/forward.c b/libpthread/linuxthreads/forward.c
index 486d254dc..5a1771b90 100644
--- a/libpthread/linuxthreads/forward.c
+++ b/libpthread/linuxthreads/forward.c
@@ -21,11 +21,36 @@
 #include <dlfcn.h>
 
 /* psm: keep this before internals.h */
+#if 0
+vda: here is why:
+headers contain libc_hidden_proto(foo).
+In libpthread/linuxthreads.old/sysdeps/pthread/bits/libc-lock.h
+adding libc_hidden_proto(foo) just before weak_extern (__pthread_initialize)
+will not warn:
+    /* libc_hidden_proto(foo) */
+    weak_extern (__pthread_initialize)
+    /* libc_hidden_proto(foo) */
+but adding after will! Which is extremely strange -
+weak_extern expands into just "#pragma weak __pthread_initialize".
+TODO: determine whether it is a gcc bug or what
+(see gcc.gnu.org/PR36282).
+For now, just include all headers before internals.h
+(they are again included in internals.h - maybe remove them there later)
+#endif
+
+#include <string.h>
+#include <limits.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/time.h>
 
 #include "internals.h"
 
 /* Pointers to the libc functions.  */
-struct pthread_functions __libc_pthread_functions;
+struct pthread_functions __libc_pthread_functions attribute_hidden;
 
 
 # define FORWARD2(name, rettype, decl, params, defaction) \
@@ -137,8 +162,12 @@ FORWARD (pthread_setcancelstate, (int state, int *oldstate), (state, oldstate),
 
 FORWARD (pthread_setcanceltype, (int type, int *oldtype), (type, oldtype), 0)
 
+#if 0
 FORWARD2 (_pthread_cleanup_push, void, (struct _pthread_cleanup_buffer * buffer, void (*routine)(void *), void * arg), (buffer, routine, arg), return)
+#endif
 FORWARD2 (_pthread_cleanup_push_defer, void, (struct _pthread_cleanup_buffer * buffer, void (*routine)(void *), void * arg), (buffer, routine, arg), return)
 
+#if 0
 FORWARD2 (_pthread_cleanup_pop, void, (struct _pthread_cleanup_buffer * buffer, int execute), (buffer, execute), return)
+#endif
 FORWARD2 (_pthread_cleanup_pop_restore, void, (struct _pthread_cleanup_buffer * buffer, int execute), (buffer, execute), return)
diff --git a/libpthread/linuxthreads/internals.h b/libpthread/linuxthreads/internals.h
index 68a8b6a75..ea274d824 100644
--- a/libpthread/linuxthreads/internals.h
+++ b/libpthread/linuxthreads/internals.h
@@ -13,30 +13,30 @@
 /* GNU Library General Public License for more details.                 */
 
 #ifndef _INTERNALS_H
-#define _INTERNALS_H	1
-
-#include "uClibc-glue.h"
+#define _INTERNALS_H   1
 
 /* Internal data structures */
 
 /* Includes */
 
+#include <bits/libc-tsd.h> /* for _LIBC_TSD_KEY_N */
 #include <limits.h>
+#include <setjmp.h>
 #include <signal.h>
-#include <stdbool.h>
 #include <unistd.h>
-#include <sys/ucontext.h>
 #include <bits/stackinfo.h>
-#include <bits/sigcontextinfo.h>
-#include <bits/pthreadtypes.h>
-
-#ifdef __UCLIBC_HAS_TLS__
-#include <tls.h>
-#endif
-#include "descr.h"
-
+#include <sys/types.h>
+#include <sys/wait.h>
+#include "pt-machine.h"
 #include "semaphore.h"
-#include <pthread-functions.h>
+#include "../linuxthreads.old_db/thread_dbP.h"
+#ifdef __UCLIBC_HAS_XLOCALE__
+#include <bits/uClibc_locale.h>
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+
+/* Use a funky version in a probably vein attempt at preventing gdb
+ * from dlopen()'ing glibc's libthread_db library... */
+#define VERSION __stringify(__UCLIBC_MAJOR__) "." __stringify(__UCLIBC_MINOR__) "." __stringify(__UCLIBC_SUBLEVEL__)
 
 #ifndef THREAD_GETMEM
 # define THREAD_GETMEM(descr, member) descr->member
@@ -51,14 +51,30 @@
 # define THREAD_SETMEM_NC(descr, member, value) descr->member = (value)
 #endif
 
-#if !defined NOT_IN_libc && defined FLOATING_STACKS
-# define LIBC_THREAD_GETMEM(descr, member) THREAD_GETMEM (descr, member)
-# define LIBC_THREAD_SETMEM(descr, member, value) \
-  THREAD_SETMEM (descr, member, value)
-#else
-# define LIBC_THREAD_GETMEM(descr, member) descr->member
-# define LIBC_THREAD_SETMEM(descr, member, value) descr->member = (value)
-#endif
+/* Arguments passed to thread creation routine */
+
+struct pthread_start_args {
+  void * (*start_routine)(void *); /* function to run */
+  void * arg;                   /* its argument */
+  sigset_t mask;                /* initial signal mask for thread */
+  int schedpolicy;              /* initial scheduling policy (if any) */
+  struct sched_param schedparam; /* initial scheduling parameters (if any) */
+};
+
+
+/* We keep thread specific data in a special data structure, a two-level
+   array.  The top-level array contains pointers to dynamically allocated
+   arrays of a certain number of data pointers.  So we can implement a
+   sparse array.  Each dynamic second-level array has
+	PTHREAD_KEY_2NDLEVEL_SIZE
+   entries.  This value shouldn't be too large.  */
+#define PTHREAD_KEY_2NDLEVEL_SIZE	32
+
+/* We need to address PTHREAD_KEYS_MAX key with PTHREAD_KEY_2NDLEVEL_SIZE
+   keys in each subarray.  */
+#define PTHREAD_KEY_1STLEVEL_SIZE \
+  ((PTHREAD_KEYS_MAX + PTHREAD_KEY_2NDLEVEL_SIZE - 1) \
+   / PTHREAD_KEY_2NDLEVEL_SIZE)
 
 typedef void (*destr_function)(void *);
 
@@ -68,9 +84,105 @@ struct pthread_key_struct {
 };
 
 
-#define PTHREAD_START_ARGS_INITIALIZER(fct) \
-  { (void *(*) (void *)) fct, NULL, {{0, }}, 0, { 0 } }
+#define PTHREAD_START_ARGS_INITIALIZER { NULL, NULL, {{0, }}, 0, { 0 } }
+
+/* The type of thread descriptors */
+
+typedef struct _pthread_descr_struct * pthread_descr;
+
+/* Callback interface for removing the thread from waiting on an
+   object if it is cancelled while waiting or about to wait.
+   This hold a pointer to the object, and a pointer to a function
+   which ``extricates'' the thread from its enqueued state.
+   The function takes two arguments: pointer to the wait object,
+   and a pointer to the thread. It returns 1 if an extrication
+   actually occured, and hence the thread must also be signalled.
+   It returns 0 if the thread had already been extricated. */
+
+typedef struct _pthread_extricate_struct {
+    void *pu_object;
+    int (*pu_extricate_func)(void *, pthread_descr);
+} pthread_extricate_if;
 
+/* Atomic counter made possible by compare_and_swap */
+
+struct pthread_atomic {
+  long p_count;
+  int p_spinlock;
+};
+
+/* Context info for read write locks. The pthread_rwlock_info structure
+   is information about a lock that has been read-locked by the thread
+   in whose list this structure appears. The pthread_rwlock_context
+   is embedded in the thread context and contains a pointer to the
+   head of the list of lock info structures, as well as a count of
+   read locks that are untracked, because no info structure could be
+   allocated for them. */
+
+struct _pthread_rwlock_t;
+
+typedef struct _pthread_rwlock_info {
+  struct _pthread_rwlock_info *pr_next;
+  struct _pthread_rwlock_t *pr_lock;
+  int pr_lock_count;
+} pthread_readlock_info;
+
+struct _pthread_descr_struct {
+  pthread_descr p_nextlive, p_prevlive;
+                                /* Double chaining of active threads */
+  pthread_descr p_nextwaiting;  /* Next element in the queue holding the thr */
+  pthread_descr p_nextlock;	/* can be on a queue and waiting on a lock */
+  pthread_t p_tid;              /* Thread identifier */
+  int p_pid;                    /* PID of Unix process */
+  int p_priority;               /* Thread priority (== 0 if not realtime) */
+  struct _pthread_fastlock * p_lock; /* Spinlock for synchronized accesses */
+  int p_signal;                 /* last signal received */
+  sigjmp_buf * p_signal_jmp;    /* where to siglongjmp on a signal or NULL */
+  sigjmp_buf * p_cancel_jmp;    /* where to siglongjmp on a cancel or NULL */
+  char p_terminated;            /* true if terminated e.g. by pthread_exit */
+  char p_detached;              /* true if detached */
+  char p_exited;                /* true if the assoc. process terminated */
+  void * p_retval;              /* placeholder for return value */
+  int p_retcode;                /* placeholder for return code */
+  pthread_descr p_joining;      /* thread joining on that thread or NULL */
+  struct _pthread_cleanup_buffer * p_cleanup; /* cleanup functions */
+  char p_cancelstate;           /* cancellation state */
+  char p_canceltype;            /* cancellation type (deferred/async) */
+  char p_canceled;              /* cancellation request pending */
+  int * p_errnop;               /* pointer to used errno variable */
+  int p_errno;                  /* error returned by last system call */
+  int * p_h_errnop;             /* pointer to used h_errno variable */
+  int p_h_errno;                /* error returned by last netdb function */
+  char * p_in_sighandler;       /* stack address of sighandler, or NULL */
+  char p_sigwaiting;            /* true if a sigwait() is in progress */
+  struct pthread_start_args p_start_args; /* arguments for thread creation */
+  void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE]; /* thread-specific data */
+  void * p_libc_specific[_LIBC_TSD_KEY_N]; /* thread-specific data for libc */
+  int p_userstack;		/* nonzero if the user provided the stack */
+  void *p_guardaddr;		/* address of guard area or NULL */
+  size_t p_guardsize;		/* size of guard area */
+  pthread_descr p_self;		/* Pointer to this structure */
+  int p_nr;                     /* Index of descriptor in __pthread_handles */
+  int p_report_events;         /* Nonzero if events must be reported.  */
+  td_eventbuf_t p_eventbuf;     /* Data for event.  */
+  struct pthread_atomic p_resume_count; /* number of times restart() was
+					   called on thread */
+  char p_woken_by_cancel;       /* cancellation performed wakeup */
+  char p_condvar_avail;         /* flag if conditional variable became avail */
+  char p_sem_avail;             /* flag if semaphore became available */
+  pthread_extricate_if *p_extricate; /* See above */
+  pthread_readlock_info *p_readlock_list;  /* List of readlock info structs */
+  pthread_readlock_info *p_readlock_free;  /* Free list of structs */
+  int p_untracked_readlock_count;	/* Readlocks not tracked by list */
+  /* New elements must be added at the end.  */
+#ifdef __UCLIBC_HAS_XLOCALE__
+  __locale_t locale; /* thread-specific locale from uselocale() only! */
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+} __attribute__ ((aligned(32))); /* We need to align the structure so that
+				    doubles are aligned properly.  This is 8
+				    bytes on MIPS and 16 bytes on MIPS64.
+				    32 bytes might give better cache
+				    utilization.  */
 
 /* The type of thread handles. */
 
@@ -88,7 +200,7 @@ struct pthread_request {
   pthread_descr req_thread;     /* Thread doing the request */
   enum {                        /* Request kind */
     REQ_CREATE, REQ_FREE, REQ_PROCESS_EXIT, REQ_MAIN_THREAD_EXIT,
-    REQ_POST, REQ_DEBUG, REQ_KICK, REQ_FOR_EACH_THREAD
+    REQ_POST, REQ_DEBUG, REQ_KICK
   } req_kind;
   union {                       /* Arguments for request */
     struct {                    /* For REQ_CREATE: */
@@ -104,24 +216,10 @@ struct pthread_request {
       int code;                 /*   exit status */
     } exit;
     void * post;                /* For REQ_POST: the semaphore */
-    struct {			/* For REQ_FOR_EACH_THREAD: callback */
-      void (*fn)(void *, pthread_descr);
-      void *arg;
-    } for_each;
   } req_args;
 };
 
 
-
-typedef void (*arch_sighandler_t) (int, SIGCONTEXT);
-union sighandler
-{
-  arch_sighandler_t old;
-  void (*rt) (int, struct siginfo *, struct ucontext *);
-};
-extern union sighandler __sighandler[NSIG];
-
-
 /* Signals used for suspend/restart and for cancellation notification.  */
 
 extern int __pthread_sig_restart;
@@ -137,10 +235,52 @@ extern int __pthread_sig_debug;
 
 extern struct pthread_handle_struct __pthread_handles[PTHREAD_THREADS_MAX];
 
+/* Descriptor of the initial thread */
+
+extern struct _pthread_descr_struct __pthread_initial_thread;
+
+/* Descriptor of the manager thread */
+
+extern struct _pthread_descr_struct __pthread_manager_thread;
+
 /* Descriptor of the main thread */
 
 extern pthread_descr __pthread_main_thread;
 
+/* Limit between the stack of the initial thread (above) and the
+   stacks of other threads (below). Aligned on a STACK_SIZE boundary.
+   Initially 0, meaning that the current thread is (by definition)
+   the initial thread. */
+
+extern char *__pthread_initial_thread_bos;
+#ifndef __ARCH_USE_MMU__
+/* For non-MMU systems, we have no idea the bounds of the initial thread
+ * stack, so we have to track it on the fly relative to other stacks.  Do
+ * so by scaling back our assumptions on the limits of the bos/tos relative
+ * to the known mid point.  See also the comments in pthread_initialize(). */
+extern char *__pthread_initial_thread_tos, *__pthread_initial_thread_mid;
+#define NOMMU_INITIAL_THREAD_BOUNDS(tos,bos) \
+	do { \
+		char *__tos = (tos); \
+		char *__bos = (bos); \
+		if (__tos >= __pthread_initial_thread_bos && \
+		    __bos < __pthread_initial_thread_tos) { \
+			if (__bos < __pthread_initial_thread_mid) \
+				__pthread_initial_thread_bos = __tos; \
+			else \
+				__pthread_initial_thread_tos = __bos; \
+		} \
+	} while (0)
+#else
+#define NOMMU_INITIAL_THREAD_BOUNDS(tos,bos) /* empty */
+#endif /* __ARCH_USE_MMU__ */
+
+
+/* Indicate whether at least one thread has a user-defined stack (if 1),
+   or all threads have stacks supplied by LinuxThreads (if 0). */
+
+extern int __pthread_nonstandard_stacks;
+
 /* File descriptor for sending requests to the thread manager.
    Initially -1, meaning that __pthread_initialize_manager must be called. */
 
@@ -150,10 +290,10 @@ extern int __pthread_manager_request;
 
 extern int __pthread_manager_reader;
 
-#ifdef FLOATING_STACKS
-/* Maximum stack size.  */
-extern size_t __pthread_max_stacksize;
-#endif
+/* Limits of the thread manager stack. */
+
+extern char *__pthread_manager_thread_bos;
+extern char *__pthread_manager_thread_tos;
 
 /* Pending request for a process-wide exit */
 
@@ -161,16 +301,13 @@ extern int __pthread_exit_requested, __pthread_exit_code;
 
 /* Set to 1 by gdb if we're debugging */
 
-extern __volatile__ int __pthread_threads_debug;
+extern volatile int __pthread_threads_debug;
 
 /* Globally enabled events.  */
-extern __volatile__ td_thr_events_t __pthread_threads_events;
+extern volatile td_thr_events_t __pthread_threads_events;
 
 /* Pointer to descriptor of thread with last event.  */
-extern __volatile__ pthread_descr __pthread_last_event;
-
-/* Flag which tells whether we are executing on SMP kernel. */
-extern int __pthread_smp_kernel;
+extern volatile pthread_descr __pthread_last_event;
 
 /* Return the handle corresponding to a thread id */
 
@@ -182,26 +319,27 @@ static __inline__ pthread_handle thread_handle(pthread_t id)
 /* Validate a thread handle. Must have acquired h->h_spinlock before. */
 
 static __inline__ int invalid_handle(pthread_handle h, pthread_t id)
-{
-  return h->h_descr == NULL || h->h_descr->p_tid != id || h->h_descr->p_terminated;
-}
-
-static __inline__ int nonexisting_handle(pthread_handle h, pthread_t id)
 {
   return h->h_descr == NULL || h->h_descr->p_tid != id;
 }
 
 /* Fill in defaults left unspecified by pt-machine.h.  */
 
-/* We round up a value with page size. */
-#ifndef page_roundup
-#define page_roundup(v,p) ((((size_t) (v)) + (p) - 1) & ~((p) - 1))
-#endif
-
 /* The page size we can get from the system.  This should likely not be
    changed by the machine file but, you never know.  */
 #define __PAGE_SIZE  (sysconf (_SC_PAGESIZE))
 
+/* The max size of the thread stack segments.  If the default
+   THREAD_SELF implementation is used, this must be a power of two and
+   a multiple of __PAGE_SIZE.  */
+#ifndef STACK_SIZE
+#ifdef __ARCH_USE_MMU__
+#define STACK_SIZE  (2 * 1024 * 1024)
+#else
+#define STACK_SIZE  (4 * __PAGE_SIZE)
+#endif
+#endif
+
 /* The initial size of the thread stack.  Must be a multiple of __PAGE_SIZE.  */
 #ifndef INITIAL_STACK_SIZE
 #define INITIAL_STACK_SIZE  (4 * __PAGE_SIZE)
@@ -220,12 +358,17 @@ static __inline__ int nonexisting_handle(pthread_handle h, pthread_t id)
 #define THREAD_STACK_START_ADDRESS  __pthread_initial_thread_bos
 #endif
 
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#ifndef CURRENT_STACK_FRAME
+#define CURRENT_STACK_FRAME  ({ char __csf; &__csf; })
+#endif
+
 /* If MEMORY_BARRIER isn't defined in pt-machine.h, assume the
    architecture doesn't need a memory barrier instruction (e.g. Intel
    x86).  Still we need the compiler to respect the barrier and emit
    all outstanding operations which modify memory.  Some architectures
    distinguish between full, read and write barriers.  */
-
 #ifndef MEMORY_BARRIER
 #define MEMORY_BARRIER() __asm__ ("" : : : "memory")
 #endif
@@ -236,6 +379,54 @@ static __inline__ int nonexisting_handle(pthread_handle h, pthread_t id)
 #define WRITE_MEMORY_BARRIER() MEMORY_BARRIER()
 #endif
 
+/* Recover thread descriptor for the current thread */
+
+extern pthread_descr __pthread_find_self (void) __attribute__ ((const)) attribute_hidden;
+
+static __inline__ pthread_descr thread_self (void) __attribute__ ((const));
+static __inline__ pthread_descr thread_self (void)
+{
+#ifdef THREAD_SELF
+  return THREAD_SELF;
+#else
+  char *sp = CURRENT_STACK_FRAME;
+#ifdef __ARCH_USE_MMU__
+  if (sp >= __pthread_initial_thread_bos)
+    return &__pthread_initial_thread;
+  else if (sp >= __pthread_manager_thread_bos
+	   && sp < __pthread_manager_thread_tos)
+    return &__pthread_manager_thread;
+  else if (__pthread_nonstandard_stacks)
+    return __pthread_find_self();
+  else
+    return (pthread_descr)(((unsigned long)sp | (STACK_SIZE-1))+1) - 1;
+#else
+  /* For non-MMU we need to be more careful about the initial thread stack.
+   * We refine the initial thread stack bounds dynamically as we allocate
+   * the other stack frame such that it doesn't overlap with them. Then
+   * we can be sure to pick the right thread according to the current SP */
+
+  /* Since we allow other stack frames to be above or below, we need to
+   * treat this case special. When pthread_initialize() wasn't called yet,
+   * only the initial thread is there. */
+  if (__pthread_initial_thread_bos == NULL) {
+      return &__pthread_initial_thread;
+  }
+  else if (sp >= __pthread_initial_thread_bos
+	   && sp < __pthread_initial_thread_tos) {
+      return &__pthread_initial_thread;
+  }
+  else if (sp >= __pthread_manager_thread_bos
+	   && sp < __pthread_manager_thread_tos) {
+      return &__pthread_manager_thread;
+  }
+  else {
+      return __pthread_find_self();
+  }
+#endif /* __ARCH_USE_MMU__ */
+#endif
+}
+
 /* Max number of times we must spin on a spinlock calling sched_yield().
    After MAX_SPIN_COUNT iterations, we put the calling thread to sleep. */
 
@@ -243,13 +434,6 @@ static __inline__ int nonexisting_handle(pthread_handle h, pthread_t id)
 #define MAX_SPIN_COUNT 50
 #endif
 
-/* Max number of times the spinlock in the adaptive mutex implementation
-   spins actively on SMP systems.  */
-
-#ifndef MAX_ADAPTIVE_SPIN_COUNT
-#define MAX_ADAPTIVE_SPIN_COUNT 100
-#endif
-
 /* Duration of sleep (in nanoseconds) when we can't acquire a spinlock
    after MAX_SPIN_COUNT iterations of sched_yield().
    With the 2.0 and 2.1 kernels, this MUST BE > 2ms.
@@ -264,286 +448,82 @@ static __inline__ int nonexisting_handle(pthread_handle h, pthread_t id)
 extern int __libc_multiple_threads attribute_hidden;
 extern int __librt_multiple_threads;
 
-/* Debugging */
-
-#ifdef DEBUG
-#include <assert.h>
-#define ASSERT assert
-#define MSG __pthread_message
-#else
-#define ASSERT(x)
-#define MSG(msg,arg...)
-#endif
-
 /* Internal global functions */
 
-extern void __pthread_do_exit (void *retval, char *currentframe)
-     __attribute__ ((__noreturn__));
-extern void __pthread_destroy_specifics (void);
-extern void __pthread_perform_cleanup (char *currentframe);
-extern void __pthread_init_max_stacksize (void);
-extern int __pthread_initialize_manager (void);
-extern void __pthread_message (const char * fmt, ...) attribute_hidden;
-extern int __pthread_manager (void *reqfd);
-extern int __pthread_manager_event (void *reqfd);
-extern void __pthread_manager_sighandler (int sig);
-extern void __pthread_reset_main_thread (void);
-extern void __pthread_once_fork_prepare (void);
-extern void __pthread_once_fork_parent (void);
-extern void __pthread_once_fork_child (void);
-extern void __flockfilelist (void);
-extern void __funlockfilelist (void);
-extern void __fresetlockfiles (void);
-extern void __pthread_manager_adjust_prio (int thread_prio);
-extern void __pthread_initialize_minimal (void);
-
-extern int __pthread_attr_setguardsize (pthread_attr_t *__attr,
-					size_t __guardsize);
-extern int __pthread_attr_getguardsize (const pthread_attr_t *__attr,
-					size_t *__guardsize);
-#if 0 /* uClibc: deprecated stuff disabled */
-extern int __pthread_attr_setstackaddr (pthread_attr_t *__attr,
-					void *__stackaddr);
-extern int __pthread_attr_getstackaddr (const pthread_attr_t *__attr,
-					void **__stackaddr);
-#endif
-extern int __pthread_attr_setstacksize (pthread_attr_t *__attr,
-					size_t __stacksize);
-extern int __pthread_attr_getstacksize (const pthread_attr_t *__attr,
-					size_t *__stacksize);
-extern int __pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
-				    size_t __stacksize);
-extern int __pthread_attr_getstack (const pthread_attr_t *__attr, void **__stackaddr,
-				    size_t *__stacksize);
-extern int __pthread_attr_destroy (pthread_attr_t *attr);
-extern int __pthread_attr_setdetachstate (pthread_attr_t *attr,
-					  int detachstate);
-extern int __pthread_attr_getdetachstate (const pthread_attr_t *attr,
-					  int *detachstate);
-extern int __pthread_attr_setschedparam (pthread_attr_t *attr,
-					 const struct sched_param *param);
-extern int __pthread_attr_getschedparam (const pthread_attr_t *attr,
-					 struct sched_param *param);
-extern int __pthread_attr_setschedpolicy (pthread_attr_t *attr, int policy);
-extern int __pthread_attr_getschedpolicy (const pthread_attr_t *attr,
-					  int *policy);
-extern int __pthread_attr_setinheritsched (pthread_attr_t *attr, int inherit);
-extern int __pthread_attr_getinheritsched (const pthread_attr_t *attr,
-					   int *inherit);
-extern int __pthread_attr_setscope (pthread_attr_t *attr, int scope);
-extern int __pthread_attr_getscope (const pthread_attr_t *attr, int *scope);
-
-extern int __pthread_getconcurrency (void);
-extern int __pthread_setconcurrency (int __level);
-extern int __pthread_mutex_timedlock (pthread_mutex_t *__mutex,
-				      const struct timespec *__abstime);
-extern int __pthread_mutexattr_getpshared (const pthread_mutexattr_t *__attr,
-					   int *__pshared);
-extern int __pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
-					   int __pshared);
-extern int __pthread_mutexattr_gettype (const pthread_mutexattr_t *__attr,
-					int *__kind);
-extern void __pthread_kill_other_threads_np (void);
-extern int __pthread_mutex_init (pthread_mutex_t *__mutex,
-				 const pthread_mutexattr_t *__mutex_attr);
-extern int __pthread_mutex_destroy (pthread_mutex_t *__mutex);
-extern int __pthread_mutex_lock (pthread_mutex_t *__mutex);
-extern int __pthread_mutex_trylock (pthread_mutex_t *__mutex);
-extern int __pthread_mutex_unlock (pthread_mutex_t *__mutex);
-
-extern int __pthread_cond_init (pthread_cond_t *cond,
-				const pthread_condattr_t *cond_attr);
-extern int __pthread_cond_destroy (pthread_cond_t *cond);
-extern int __pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex);
-extern int __pthread_cond_timedwait (pthread_cond_t *cond,
-				     pthread_mutex_t *mutex,
-				     const struct timespec *abstime);
-extern int __pthread_cond_signal (pthread_cond_t *cond);
-extern int __pthread_cond_broadcast (pthread_cond_t *cond);
-extern int __pthread_condattr_init (pthread_condattr_t *attr);
-extern int __pthread_condattr_destroy (pthread_condattr_t *attr);
-extern pthread_t __pthread_self (void);
-extern pthread_descr __pthread_thread_self (void);
-extern pthread_descr __pthread_self_stack (void) attribute_hidden;
-extern int __pthread_equal (pthread_t thread1, pthread_t thread2);
+void __pthread_do_exit (void *retval, char *currentframe)
+     __attribute__ ((__noreturn__)) attribute_hidden;
+void __pthread_destroy_specifics(void) attribute_hidden;
+void __pthread_perform_cleanup(char *currentframe) attribute_hidden;
+int __pthread_initialize_manager(void) attribute_hidden;
+void __pthread_message(char * fmt, ...)
+     __attribute__ ((__format__ (printf, 1, 2))) attribute_hidden;
+int __pthread_manager(void *reqfd) attribute_hidden;
+int __pthread_manager_event(void *reqfd) attribute_hidden;
+void __pthread_manager_sighandler(int sig) attribute_hidden;
+void __pthread_reset_main_thread(void) attribute_hidden;
+void __fresetlockfiles(void) attribute_hidden;
+void __pthread_manager_adjust_prio(int thread_prio) attribute_hidden;
+void __pthread_initialize_minimal (void);
+
 extern void __pthread_exit (void *retval)
 #if defined NOT_IN_libc && defined IS_IN_libpthread
 	attribute_noreturn
 #endif
 	;
-extern int __pthread_getschedparam (pthread_t thread, int *policy,
-				    struct sched_param *param);
-extern int __pthread_setschedparam (pthread_t thread, int policy,
-				    const struct sched_param *param);
-extern int __pthread_setcancelstate (int state, int * oldstate);
-extern int __pthread_setcanceltype (int type, int * oldtype);
-
-extern void __pthread_restart_old(pthread_descr th);
-extern void __pthread_suspend_old(pthread_descr self);
-extern int __pthread_timedsuspend_old(pthread_descr self, const struct timespec *abstime);
-
-extern void __pthread_restart_new(pthread_descr th);
-extern void __pthread_suspend_new(pthread_descr self);
-extern int __pthread_timedsuspend_new(pthread_descr self, const struct timespec *abstime);
-
-extern void __pthread_wait_for_restart_signal(pthread_descr self);
-
-extern void __pthread_sigsuspend (const sigset_t *mask) attribute_hidden;
-
-extern int __pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
-					 const struct timespec *__restrict
-					 __abstime);
-extern int __pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
-					 const struct timespec *__restrict
-					 __abstime);
-extern int __pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr);
-
-extern int __pthread_barrierattr_getpshared (const pthread_barrierattr_t *
-					     __restrict __attr,
-					     int *__restrict __pshared);
-
-extern int __pthread_spin_lock (pthread_spinlock_t *__lock);
-extern int __pthread_spin_trylock (pthread_spinlock_t *__lock);
-extern int __pthread_spin_unlock (pthread_spinlock_t *__lock);
-extern int __pthread_spin_init (pthread_spinlock_t *__lock, int __pshared);
-extern int __pthread_spin_destroy (pthread_spinlock_t *__lock);
 
-/* Global pointers to old or new suspend functions */
+extern int __pthread_attr_setguardsize(pthread_attr_t *__attr,
+				       size_t __guardsize) attribute_hidden;
+extern int __pthread_attr_getguardsize(const pthread_attr_t *__attr,
+				       size_t *__guardsize) attribute_hidden;
+extern int __pthread_attr_setstackaddr(pthread_attr_t *__attr,
+				       void *__stackaddr) attribute_hidden;
+extern int __pthread_attr_getstackaddr(const pthread_attr_t *__attr,
+				       void **__stackaddr) attribute_hidden;
+extern int __pthread_attr_setstacksize(pthread_attr_t *__attr,
+				       size_t __stacksize) attribute_hidden;
+extern int __pthread_attr_getstacksize(const pthread_attr_t *__attr,
+				       size_t *__stacksize) attribute_hidden;
+extern int __pthread_getconcurrency(void) attribute_hidden;
+extern int __pthread_setconcurrency(int __level) attribute_hidden;
+extern void __pthread_kill_other_threads_np(void) attribute_hidden;
+
+extern void __pthread_restart_old(pthread_descr th) attribute_hidden;
+extern void __pthread_suspend_old(pthread_descr self) attribute_hidden;
+extern int __pthread_timedsuspend_old(pthread_descr self, const struct timespec *abstime) attribute_hidden;
+
+extern void __pthread_restart_new(pthread_descr th) attribute_hidden;
+extern void __pthread_suspend_new(pthread_descr self) attribute_hidden;
+extern int __pthread_timedsuspend_new(pthread_descr self, const struct timespec *abstime) attribute_hidden;
+
+extern void __pthread_wait_for_restart_signal(pthread_descr self) attribute_hidden;
 
-extern void (*__pthread_restart)(pthread_descr);
-extern void (*__pthread_suspend)(pthread_descr);
-extern int (*__pthread_timedsuspend)(pthread_descr, const struct timespec *);
+/* Global pointers to old or new suspend functions */
 
-/* Prototypes for some of the new semaphore functions.  */
-extern int sem_post (sem_t * sem);
-extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value);
-extern int sem_wait (sem_t *__sem);
-extern int sem_trywait (sem_t *__sem);
-extern int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval);
-extern int sem_destroy (sem_t *__sem);
-
-/* Prototypes for compatibility functions.  */
-extern int __pthread_attr_init (pthread_attr_t *__attr);
-extern int __pthread_create (pthread_t *__restrict __threadp,
-				 const pthread_attr_t *__attr,
-				 void *(*__start_routine) (void *),
-				 void *__restrict __arg);
+extern void (*__pthread_restart)(pthread_descr) attribute_hidden;
+extern void (*__pthread_suspend)(pthread_descr) attribute_hidden;
 
-/* The functions called the signal events.  */
-extern void __linuxthreads_create_event (void);
-extern void __linuxthreads_death_event (void);
-extern void __linuxthreads_reap_event (void);
+#if defined NOT_IN_libc && defined IS_IN_libpthread
+extern __typeof(pthread_mutex_init) __pthread_mutex_init attribute_hidden;
+extern __typeof(pthread_mutex_destroy) __pthread_mutex_destroy attribute_hidden;
+extern __typeof(pthread_mutex_lock) __pthread_mutex_lock attribute_hidden;
+extern __typeof(pthread_mutex_trylock) __pthread_mutex_trylock attribute_hidden;
+extern __typeof(pthread_mutex_unlock) __pthread_mutex_unlock attribute_hidden;
+#endif
 
-/* This function is called to initialize the pthread library.  */
-extern void __pthread_initialize (void);
+/* Prototypes for some of the new semaphore functions.  */
+/*extern int __new_sem_post (sem_t * sem);*/
 
 /* TSD.  */
-#if !defined __UCLIBC_HAS_TLS__ && defined __UCLIBC_HAS_RPC__
 extern int __pthread_internal_tsd_set (int key, const void * pointer);
 extern void * __pthread_internal_tsd_get (int key);
 extern void ** __attribute__ ((__const__))
   __pthread_internal_tsd_address (int key);
-#endif
 
-/* Sighandler wrappers.  */
-extern void __pthread_sighandler(int signo, SIGCONTEXT ctx);
-extern void __pthread_sighandler_rt(int signo, struct siginfo *si,
-				    struct ucontext *uc);
-extern void __pthread_null_sighandler(int sig);
-extern int __pthread_sigaction (int sig, const struct sigaction *act,
-				struct sigaction *oact);
-extern int __pthread_sigwait (const sigset_t *set, int *sig);
-extern int __pthread_raise (int sig);
-
-/* Cancellation.  */
-extern int __pthread_enable_asynccancel (void) attribute_hidden;
-extern void __pthread_disable_asynccancel (int oldtype)
-  internal_function attribute_hidden;
-
-/* The two functions are in libc.so and not exported.  */
-extern int __libc_enable_asynccancel (void) attribute_hidden;
-extern void __libc_disable_asynccancel (int oldtype)
-  internal_function attribute_hidden;
-
-/* The two functions are in libc.so and are exported.  */
-extern int __librt_enable_asynccancel (void);
-extern void __librt_disable_asynccancel (int oldtype) internal_function;
-
-extern void __pthread_cleanup_upto (__jmp_buf target,
-				    char *targetframe) attribute_hidden;
-extern pid_t __pthread_fork (struct fork_block *b) attribute_hidden;
-
-#define asm_handle(name) _asm_handle(name)
-#define _asm_handle(name) #name
-#define ASM_GLOBAL asm_handle(ASM_GLOBAL_DIRECTIVE)
-#define ASM_CANCEL(name) asm_handle(C_SYMBOL_NAME(name))
-
-#if !defined NOT_IN_libc
-# define LIBC_CANCEL_ASYNC() \
-  __libc_enable_asynccancel ()
-# define LIBC_CANCEL_RESET(oldtype) \
-  __libc_disable_asynccancel (oldtype)
-# define LIBC_CANCEL_HANDLED() \
-  __asm__ (ASM_GLOBAL " " ASM_CANCEL(__libc_enable_asynccancel)); \
-  __asm__ (ASM_GLOBAL " " ASM_CANCEL(__libc_disable_asynccancel))
-#elif defined IS_IN_libpthread
-# define LIBC_CANCEL_ASYNC() \
-  __pthread_enable_asynccancel ()
-# define LIBC_CANCEL_RESET(oldtype) \
-  __pthread_disable_asynccancel (oldtype)
-# define LIBC_CANCEL_HANDLED() \
-  __asm__ (ASM_GLOBAL " " ASM_CANCEL(__pthread_enable_asynccancel)); \
-  __asm__ (ASM_GLOBAL " " ASM_CANCEL(__pthread_disable_asynccancel))
-#elif defined IS_IN_librt
-# define LIBC_CANCEL_ASYNC() \
-  __librt_enable_asynccancel ()
-# define LIBC_CANCEL_RESET(oldtype) \
-  __librt_disable_asynccancel (oldtype)
-# define LIBC_CANCEL_HANDLED() \
-  __asm__ (ASM_GLOBAL " " ASM_CANCEL(__librt_enable_asynccancel)); \
-  __asm__ (ASM_GLOBAL " " ASM_CANCEL(__librt_disable_asynccancel))
-#else
-# define LIBC_CANCEL_ASYNC()    0 /* Just a dummy value.  */
-# define LIBC_CANCEL_RESET(val) ((void)(val)) /* Nothing, but evaluate it.  */
-# define LIBC_CANCEL_HANDLED()	/* Nothing.  */
-#endif
-
-#if !defined NOT_IN_libc && !defined FLOATING_STACKS
-# ifdef SHARED
-#  define thread_self() \
-  (*__libc_pthread_functions.ptr_pthread_thread_self) ()
-# else
-weak_extern (__pthread_thread_self)
-#  define thread_self() __pthread_thread_self ()
-# endif
-#endif
-
-#ifndef __UCLIBC_HAS_TLS__
-# define __manager_thread (&__pthread_manager_thread)
-#else
-# define __manager_thread __pthread_manager_threadp
-#endif
+/* The functions called the signal events.  */
+extern void __linuxthreads_create_event (void) attribute_hidden;
+extern void __linuxthreads_death_event (void) attribute_hidden;
+extern void __linuxthreads_reap_event (void) attribute_hidden;
 
-static __always_inline pthread_descr
-check_thread_self (void);
-static __always_inline pthread_descr
-check_thread_self (void)
-{
-  pthread_descr self = thread_self ();
-#if defined THREAD_SELF && defined INIT_THREAD_SELF
-  if (self == __manager_thread)
-    {
-      /* A new thread might get a cancel signal before it is fully
-	 initialized, so that the thread register might still point to the
-	 manager thread.  Double check that this is really the manager
-	 thread.  */
-      self = __pthread_self_stack();
-      if (self != __manager_thread)
-	/* Oops, thread_self() isn't working yet..  */
-	INIT_THREAD_SELF(self, self->p_nr);
-    }
-#endif
-  return self;
-}
+#include <pthread-functions.h>
 
 #endif /* internals.h */
diff --git a/libpthread/linuxthreads/join.c b/libpthread/linuxthreads/join.c
index 57ea54e34..4a7c0d8ac 100644
--- a/libpthread/linuxthreads/join.c
+++ b/libpthread/linuxthreads/join.c
@@ -14,31 +14,38 @@
 
 /* Thread termination and joining */
 
+#include <features.h>
 #include <errno.h>
 #include <sched.h>
-#include <stdlib.h>
 #include <unistd.h>
+#include <stdlib.h>
 #include "pthread.h"
 #include "internals.h"
 #include "spinlock.h"
 #include "restart.h"
-#include <not-cancel.h>
+#include "debug.h" /* PDEBUG, added by StS */
 
-void __pthread_exit(void * retval)
+libpthread_hidden_proto(pthread_exit)
+void pthread_exit(void * retval)
 {
   __pthread_do_exit (retval, CURRENT_STACK_FRAME);
 }
-strong_alias (__pthread_exit, pthread_exit)
+libpthread_hidden_def (pthread_exit)
 
 void __pthread_do_exit(void *retval, char *currentframe)
 {
   pthread_descr self = thread_self();
   pthread_descr joining;
   struct pthread_request request;
+  PDEBUG("self=%p, pid=%d\n", self, self->p_pid);
+
+  /* obey POSIX behavior and prevent cancellation functions from
+   * being called more than once.
+   * http://sourceware.org/ml/libc-ports/2006-10/msg00043.html
+   */
+  THREAD_SETMEM(self, p_cancelstate, PTHREAD_CANCEL_DISABLE);
+  THREAD_SETMEM(self, p_canceltype, PTHREAD_CANCEL_DEFERRED);
 
-  /* Reset the cancellation flag to avoid looping if the cleanup handlers
-     contain cancellation points */
-  THREAD_SETMEM(self, p_canceled, 0);
   /* Call cleanup functions and destroy the thread-specific data */
   __pthread_perform_cleanup(currentframe);
   __pthread_destroy_specifics();
@@ -54,7 +61,7 @@ void __pthread_do_exit(void *retval, char *currentframe)
 
       if ((mask & (__pthread_threads_events.event_bits[idx]
 		   | THREAD_GETMEM_NC(self,
-				      p_eventbuf.eventmask.event_bits[idx])))
+				   p_eventbuf.eventmask).event_bits[idx]))
 	  != 0)
 	{
 	  /* Yep, we have to signal the death.  */
@@ -70,6 +77,7 @@ void __pthread_do_exit(void *retval, char *currentframe)
   THREAD_SETMEM(self, p_terminated, 1);
   /* See if someone is joining on us */
   joining = THREAD_GETMEM(self, p_joining);
+  PDEBUG("joining = %p, pid=%d\n", joining, joining ? joining->p_pid : 0);
   __pthread_unlock(THREAD_GETMEM(self, p_lock));
   /* Restart joining thread if any */
   if (joining != NULL) restart(joining);
@@ -79,25 +87,25 @@ void __pthread_do_exit(void *retval, char *currentframe)
   if (self == __pthread_main_thread && __pthread_manager_request >= 0) {
     request.req_thread = self;
     request.req_kind = REQ_MAIN_THREAD_EXIT;
-    TEMP_FAILURE_RETRY(write_not_cancel(__pthread_manager_request,
-					(char *)&request, sizeof(request)));
+    TEMP_FAILURE_RETRY(write(__pthread_manager_request,
+		(char *)&request, sizeof(request)));
     suspend(self);
     /* Main thread flushes stdio streams and runs atexit functions.
-       It also calls a handler within LinuxThreads which sends a process exit
-       request to the thread manager. */
+     * It also calls a handler within LinuxThreads which sends a process exit
+     * request to the thread manager. */
     exit(0);
   }
-  /* Threads other than the main one  terminate without flushing stdio streams
-     or running atexit functions. */
+  /* Exit the process (but don't flush stdio streams, and don't run
+     atexit functions). */
   _exit(0);
 }
 
 /* Function called by pthread_cancel to remove the thread from
    waiting on a condition variable queue. */
 
-static int join_extricate_func(void *obj, pthread_descr th)
+static int join_extricate_func(void *obj, pthread_descr th attribute_unused)
 {
-  __volatile__ pthread_descr self = thread_self();
+  volatile pthread_descr self = thread_self();
   pthread_handle handle = obj;
   pthread_descr jo;
   int did_remove = 0;
@@ -113,19 +121,20 @@ static int join_extricate_func(void *obj, pthread_descr th)
 
 int pthread_join(pthread_t thread_id, void ** thread_return)
 {
-  __volatile__ pthread_descr self = thread_self();
+  volatile pthread_descr self = thread_self();
   struct pthread_request request;
   pthread_handle handle = thread_handle(thread_id);
   pthread_descr th;
   pthread_extricate_if extr;
   int already_canceled = 0;
+  PDEBUG("\n");
 
   /* Set up extrication interface */
   extr.pu_object = handle;
   extr.pu_extricate_func = join_extricate_func;
 
   __pthread_lock(&handle->h_lock, self);
-  if (nonexisting_handle(handle, thread_id)) {
+  if (invalid_handle(handle, thread_id)) {
     __pthread_unlock(&handle->h_lock);
     return ESRCH;
   }
@@ -155,7 +164,9 @@ int pthread_join(pthread_t thread_id, void ** thread_return)
       __pthread_do_exit(PTHREAD_CANCELED, CURRENT_STACK_FRAME);
     }
 
+  PDEBUG("before suspend\n");
     suspend(self);
+  PDEBUG("after suspend\n");
     /* Deregister extrication interface */
     __pthread_set_own_extricate_if(self, 0);
 
@@ -175,8 +186,8 @@ int pthread_join(pthread_t thread_id, void ** thread_return)
     request.req_thread = self;
     request.req_kind = REQ_FREE;
     request.req_args.free.thread_id = thread_id;
-    TEMP_FAILURE_RETRY(write_not_cancel(__pthread_manager_request,
-					(char *) &request, sizeof(request)));
+    TEMP_FAILURE_RETRY(write(__pthread_manager_request,
+		(char *) &request, sizeof(request)));
   }
   return 0;
 }
@@ -189,7 +200,7 @@ int pthread_detach(pthread_t thread_id)
   pthread_descr th;
 
   __pthread_lock(&handle->h_lock, NULL);
-  if (nonexisting_handle(handle, thread_id)) {
+  if (invalid_handle(handle, thread_id)) {
     __pthread_unlock(&handle->h_lock);
     return ESRCH;
   }
@@ -213,8 +224,8 @@ int pthread_detach(pthread_t thread_id)
     request.req_thread = thread_self();
     request.req_kind = REQ_FREE;
     request.req_args.free.thread_id = thread_id;
-    TEMP_FAILURE_RETRY(write_not_cancel(__pthread_manager_request,
-					(char *) &request, sizeof(request)));
+    TEMP_FAILURE_RETRY(write(__pthread_manager_request,
+		(char *) &request, sizeof(request)));
   }
   return 0;
 }
diff --git a/libpthread/linuxthreads/libc-cancellation.c b/libpthread/linuxthreads/libc-cancellation.c
deleted file mode 100644
index e41e9c81a..000000000
--- a/libpthread/linuxthreads/libc-cancellation.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <rpc/rpc.h>
-#include "pthread.h"
-#include "internals.h"
-#include "spinlock.h"
-#include "restart.h"
-#include <bits/libc-lock.h>
-
-#if !defined NOT_IN_libc
-
-# ifndef SHARED
-weak_extern (__pthread_do_exit)
-# endif
-
-/* The next two functions are similar to pthread_setcanceltype() but
-   more specialized for the use in the cancelable functions like write().
-   They do not need to check parameters etc.  */
-int
-attribute_hidden
-__libc_enable_asynccancel (void)
-{
-  pthread_descr self = thread_self();
-  int oldtype = LIBC_THREAD_GETMEM(self, p_canceltype);
-  LIBC_THREAD_SETMEM(self, p_canceltype, PTHREAD_CANCEL_ASYNCHRONOUS);
-  if (__builtin_expect (LIBC_THREAD_GETMEM(self, p_canceled), 0) &&
-      LIBC_THREAD_GETMEM(self, p_cancelstate) == PTHREAD_CANCEL_ENABLE)
-    __libc_maybe_call2 (pthread_do_exit,
-			(PTHREAD_CANCELED, CURRENT_STACK_FRAME), 0);
-  return oldtype;
-}
-strong_alias (__libc_enable_asynccancel, __librt_enable_asynccancel)
-
-void
-internal_function attribute_hidden
-__libc_disable_asynccancel (int oldtype)
-{
-  pthread_descr self = thread_self();
-  LIBC_THREAD_SETMEM(self, p_canceltype, oldtype);
-}
-strong_alias (__libc_disable_asynccancel, __librt_disable_asynccancel)
-
-#endif
diff --git a/libpthread/linuxthreads/libc_pthread_init.c b/libpthread/linuxthreads/libc_pthread_init.c
index 384bf2f7f..dfdcbcccc 100644
--- a/libpthread/linuxthreads/libc_pthread_init.c
+++ b/libpthread/linuxthreads/libc_pthread_init.c
@@ -17,20 +17,13 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include <locale.h>
-#include <stdlib.h>
 #include <string.h>
-#ifdef __UCLIBC_HAS_TLS__
-#include <tls.h>
-#endif
-#include "internals.h"
+#include <linuxthreads.old/sysdeps/pthread/pthread-functions.h>
 
 
 int __libc_multiple_threads attribute_hidden __attribute__((nocommon));
-strong_alias (__libc_multiple_threads, __librt_multiple_threads)
-
 
-int *
-__libc_pthread_init(const struct pthread_functions *functions)
+int * __libc_pthread_init (const struct pthread_functions *functions)
 {
 #ifdef SHARED
   /* We copy the content of the variable pointed to by the FUNCTIONS
@@ -40,10 +33,10 @@ __libc_pthread_init(const struct pthread_functions *functions)
 	  sizeof (__libc_pthread_functions));
 #endif
 
-#ifndef __UCLIBC_HAS_TLS__
+#if !defined __UCLIBC_HAS_TLS__ && defined __UCLIBC_HAS_XLOCALE__
   /* Initialize thread-locale current locale to point to the global one.
      With __thread support, the variable's initializer takes care of this.  */
-  __uselocale (LC_GLOBAL_LOCALE);
+  uselocale (LC_GLOBAL_LOCALE);
 #endif
 
   return &__libc_multiple_threads;
diff --git a/libpthread/linuxthreads.old/linuxthreads.texi b/libpthread/linuxthreads/linuxthreads.texi
similarity index 100%
rename from libpthread/linuxthreads.old/linuxthreads.texi
rename to libpthread/linuxthreads/linuxthreads.texi
diff --git a/libpthread/linuxthreads.old/locale.c b/libpthread/linuxthreads/locale.c
similarity index 100%
rename from libpthread/linuxthreads.old/locale.c
rename to libpthread/linuxthreads/locale.c
diff --git a/libpthread/linuxthreads/lockfile.c b/libpthread/linuxthreads/lockfile.c
index 1f6584a88..de834c476 100644
--- a/libpthread/linuxthreads/lockfile.c
+++ b/libpthread/linuxthreads/lockfile.c
@@ -16,36 +16,27 @@
    License along with the GNU C Library; see the file COPYING.LIB.  If
    not, see <http://www.gnu.org/licenses/>.  */
 
-#include <bits/libc-lock.h>
 #include <stdio.h>
 #include <pthread.h>
-#include "internals.h"
+
+extern __typeof(pthread_mutexattr_init) __pthread_mutexattr_init attribute_hidden;
+extern __typeof(pthread_mutexattr_settype) __pthread_mutexattr_settype attribute_hidden;
+extern __typeof(pthread_mutexattr_destroy) __pthread_mutexattr_destroy attribute_hidden;
 
 /* Note: glibc puts flockfile, funlockfile, and ftrylockfile in both
  * libc and libpthread.  In uClibc, they are now in libc only.  */
 
-void
-__flockfilelist(void)
-{
-}
-
-void
-__funlockfilelist(void)
-{
-}
-
-void
-__fresetlockfiles (void)
+void __fresetlockfiles (void);
+void __fresetlockfiles (void)
 {
   FILE *fp;
-
   pthread_mutexattr_t attr;
 
-  __pthread_mutexattr_init (&attr);
-  __pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE_NP);
+  __pthread_mutexattr_init(&attr);
+  __pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE_NP);
 
   for (fp = _stdio_openlist; fp != NULL; fp = fp->__nextopen)
-    pthread_mutex_init (&fp->__lock, &attr);
+    __pthread_mutex_init(&fp->__lock, &attr);
 
-  pthread_mutexattr_destroy(&attr);
+  __pthread_mutexattr_destroy(&attr);
 }
diff --git a/libpthread/linuxthreads/manager.c b/libpthread/linuxthreads/manager.c
index 3c5bee876..e4022f8ea 100644
--- a/libpthread/linuxthreads/manager.c
+++ b/libpthread/linuxthreads/manager.c
@@ -14,7 +14,7 @@
 
 /* The "thread manager" thread: manages creation and termination of threads */
 
-#include <assert.h>
+#include <features.h>
 #include <errno.h>
 #include <sched.h>
 #include <stddef.h>
@@ -27,72 +27,77 @@
 #include <sys/param.h>
 #include <sys/time.h>
 #include <sys/wait.h>           /* for waitpid macros */
-#include <locale.h>		/* for __uselocale */
-#include <resolv.h>		/* for __resp */
 
 #include "pthread.h"
 #include "internals.h"
 #include "spinlock.h"
 #include "restart.h"
 #include "semaphore.h"
-#include <not-cancel.h>
+#include "debug.h" /* PDEBUG, added by StS */
+
+#ifndef THREAD_STACK_OFFSET
+#define THREAD_STACK_OFFSET 0
+#endif
+
+/* poll() is not supported in kernel <= 2.0, therefore is __NR_poll is
+ * not available, we assume an old Linux kernel is in use and we will
+ * use select() instead. */
+#include <sys/syscall.h>
+#ifndef __NR_poll
+# define USE_SELECT
+#endif
+
+libpthread_hidden_proto(waitpid)
+libpthread_hidden_proto(raise)
+
+/* Array of active threads. Entry 0 is reserved for the initial thread. */
+struct pthread_handle_struct __pthread_handles[PTHREAD_THREADS_MAX] =
+{ { __LOCK_INITIALIZER, &__pthread_initial_thread, 0},
+  { __LOCK_INITIALIZER, &__pthread_manager_thread, 0}, /* All NULLs */ };
 
 /* For debugging purposes put the maximum number of threads in a variable.  */
 const int __linuxthreads_pthread_threads_max = PTHREAD_THREADS_MAX;
 
-#ifndef THREAD_SELF
 /* Indicate whether at least one thread has a user-defined stack (if 1),
    or if all threads have stacks supplied by LinuxThreads (if 0). */
 int __pthread_nonstandard_stacks;
-#endif
 
 /* Number of active entries in __pthread_handles (used by gdb) */
-__volatile__ int __pthread_handles_num = 2;
+volatile int __pthread_handles_num = 2;
 
 /* Whether to use debugger additional actions for thread creation
    (set to 1 by gdb) */
-__volatile__ int __pthread_threads_debug;
+volatile int __pthread_threads_debug;
 
 /* Globally enabled events.  */
-__volatile__ td_thr_events_t __pthread_threads_events;
+volatile td_thr_events_t __pthread_threads_events;
 
 /* Pointer to thread descriptor with last event.  */
-__volatile__ pthread_descr __pthread_last_event;
-
-static pthread_descr manager_thread;
+volatile pthread_descr __pthread_last_event;
 
 /* Mapping from stack segment to thread descriptor. */
 /* Stack segment numbers are also indices into the __pthread_handles array. */
 /* Stack segment number 0 is reserved for the initial thread. */
 
-#if FLOATING_STACKS
-# define thread_segment(seq) NULL
-#else
 static __inline__ pthread_descr thread_segment(int seg)
 {
-# ifdef _STACK_GROWS_UP
-  return (pthread_descr)(THREAD_STACK_START_ADDRESS + (seg - 1) * STACK_SIZE)
-         + 1;
-# else
   return (pthread_descr)(THREAD_STACK_START_ADDRESS - (seg - 1) * STACK_SIZE)
          - 1;
-# endif
 }
-#endif
 
 /* Flag set in signal handler to record child termination */
 
-static __volatile__ int terminated_children;
+static volatile int terminated_children = 0;
 
 /* Flag set when the initial thread is blocked on pthread_exit waiting
    for all other threads to terminate */
 
-static int main_thread_exiting;
+static int main_thread_exiting = 0;
 
 /* Counter used to generate unique thread identifier.
    Thread identifier is pthread_threads_counter + segment. */
 
-static pthread_t pthread_threads_counter;
+static pthread_t pthread_threads_counter = 0;
 
 /* Forward declarations */
 
@@ -102,54 +107,67 @@ static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
 				 int report_events,
 				 td_thr_events_t *event_maskp);
 static void pthread_handle_free(pthread_t th_id);
-static void pthread_handle_exit(pthread_descr issuing_thread, int exitcode)
-     __attribute__ ((noreturn));
+static void pthread_handle_exit(pthread_descr issuing_thread, int exitcode) attribute_noreturn;
 static void pthread_reap_children(void);
 static void pthread_kill_all_threads(int sig, int main_thread_also);
-static void pthread_for_each_thread(void *arg,
-    void (*fn)(void *, pthread_descr));
 
 /* The server thread managing requests for thread creation and termination */
 
-int
-__attribute__ ((noreturn))
-__pthread_manager(void *arg)
+int attribute_noreturn __pthread_manager(void *arg)
 {
-  pthread_descr self = manager_thread = arg;
-  int reqfd = __pthread_manager_reader;
+  int reqfd = (int) (long int) arg;
+#ifdef USE_SELECT
+  struct timeval tv;
+  fd_set fd;
+#else
   struct pollfd ufd;
+#endif
   sigset_t manager_mask;
   int n;
   struct pthread_request request;
 
   /* If we have special thread_self processing, initialize it.  */
 #ifdef INIT_THREAD_SELF
-  INIT_THREAD_SELF(self, 1);
+  INIT_THREAD_SELF(&__pthread_manager_thread, 1);
 #endif
-#ifndef __UCLIBC_HAS_TLS__
   /* Set the error variable.  */
-  self->p_errnop = &self->p_errno;
-  self->p_h_errnop = &self->p_h_errno;
-#endif
+  __pthread_manager_thread.p_errnop = &__pthread_manager_thread.p_errno;
+  __pthread_manager_thread.p_h_errnop = &__pthread_manager_thread.p_h_errno;
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+  /* Initialize thread's locale to the global locale. */
+  __pthread_manager_thread.locale = __global_locale;
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+
   /* Block all signals except __pthread_sig_cancel and SIGTRAP */
   __sigfillset(&manager_mask);
   sigdelset(&manager_mask, __pthread_sig_cancel); /* for thread termination */
   sigdelset(&manager_mask, SIGTRAP);            /* for debugging purposes */
   if (__pthread_threads_debug && __pthread_sig_debug > 0)
-    sigdelset(&manager_mask, __pthread_sig_debug);
+      sigdelset(&manager_mask, __pthread_sig_debug);
   sigprocmask(SIG_SETMASK, &manager_mask, NULL);
   /* Raise our priority to match that of main thread */
   __pthread_manager_adjust_prio(__pthread_main_thread->p_priority);
   /* Synchronize debugging of the thread manager */
-  n = TEMP_FAILURE_RETRY(read_not_cancel(reqfd, (char *)&request,
-					 sizeof(request)));
-  ASSERT(n == sizeof(request) && request.req_kind == REQ_DEBUG);
+  n = TEMP_FAILURE_RETRY(read(reqfd, (char *)&request,
+				     sizeof(request)));
+#ifndef USE_SELECT
   ufd.fd = reqfd;
   ufd.events = POLLIN;
+#endif
   /* Enter server loop */
   while(1) {
-    n = __poll(&ufd, 1, 2000);
-
+#ifdef USE_SELECT
+    tv.tv_sec = 2;
+    tv.tv_usec = 0;
+    FD_ZERO (&fd);
+    FD_SET (reqfd, &fd);
+    n = select (reqfd + 1, &fd, NULL, NULL, &tv);
+#else
+    PDEBUG("before poll\n");
+    n = poll(&ufd, 1, 2000);
+    PDEBUG("after poll\n");
+#endif
     /* Check for termination of the main thread */
     if (getppid() == 1) {
       pthread_kill_all_threads(SIGKILL, 0);
@@ -161,20 +179,19 @@ __pthread_manager(void *arg)
       pthread_reap_children();
     }
     /* Read and execute request */
-    if (n == 1 && (ufd.revents & POLLIN)) {
-      n = TEMP_FAILURE_RETRY(read_not_cancel(reqfd, (char *)&request,
-					     sizeof(request)));
-#ifdef DEBUG
-      if (n < 0) {
-	char d[64];
-	write(STDERR_FILENO, d, snprintf(d, sizeof(d), "*** read err %m\n"));
-      } else if (n != sizeof(request)) {
-	write(STDERR_FILENO, "*** short read in manager\n", 26);
-      }
+#ifdef USE_SELECT
+    if (n == 1)
+#else
+    if (n == 1 && (ufd.revents & POLLIN))
 #endif
+    {
 
+      PDEBUG("before read\n");
+      n = read(reqfd, (char *)&request, sizeof(request));
+      PDEBUG("after read, n=%d\n", n);
       switch(request.req_kind) {
       case REQ_CREATE:
+        PDEBUG("got REQ_CREATE\n");
         request.req_thread->p_retcode =
           pthread_handle_create((pthread_t *) &request.req_thread->p_retval,
                                 request.req_args.create.attr,
@@ -182,19 +199,23 @@ __pthread_manager(void *arg)
                                 request.req_args.create.arg,
                                 &request.req_args.create.mask,
                                 request.req_thread->p_pid,
-				request.req_thread->p_report_events,
-				&request.req_thread->p_eventbuf.eventmask);
+                                request.req_thread->p_report_events,
+                                &request.req_thread->p_eventbuf.eventmask);
+        PDEBUG("restarting %p\n", request.req_thread);
         restart(request.req_thread);
         break;
       case REQ_FREE:
-	pthread_handle_free(request.req_args.free.thread_id);
+        PDEBUG("got REQ_FREE\n");
+        pthread_handle_free(request.req_args.free.thread_id);
         break;
       case REQ_PROCESS_EXIT:
+        PDEBUG("got REQ_PROCESS_EXIT from %p, exit code = %d\n",
+        request.req_thread, request.req_args.exit.code);
         pthread_handle_exit(request.req_thread,
                             request.req_args.exit.code);
-	/* NOTREACHED */
         break;
       case REQ_MAIN_THREAD_EXIT:
+        PDEBUG("got REQ_MAIN_THREAD_EXIT\n");
         main_thread_exiting = 1;
 	/* Reap children in case all other threads died and the signal handler
 	   went off before we set main_thread_exiting to 1, and therefore did
@@ -210,99 +231,81 @@ __pthread_manager(void *arg)
 	}
         break;
       case REQ_POST:
+        PDEBUG("got REQ_POST\n");
         sem_post(request.req_args.post);
         break;
       case REQ_DEBUG:
+        PDEBUG("got REQ_DEBUG\n");
 	/* Make gdb aware of new thread and gdb will restart the
 	   new thread when it is ready to handle the new thread. */
-	if (__pthread_threads_debug && __pthread_sig_debug > 0)
+	if (__pthread_threads_debug && __pthread_sig_debug > 0) {
+	  PDEBUG("about to call raise(__pthread_sig_debug)\n");
 	  raise(__pthread_sig_debug);
-        break;
+	}
       case REQ_KICK:
 	/* This is just a prod to get the manager to reap some
 	   threads right away, avoiding a potential delay at shutdown. */
 	break;
-      case REQ_FOR_EACH_THREAD:
-	pthread_for_each_thread(request.req_args.for_each.arg,
-	                        request.req_args.for_each.fn);
-	restart(request.req_thread);
-	break;
       }
     }
   }
 }
 
-int __pthread_manager_event(void *arg)
+int attribute_noreturn __pthread_manager_event(void *arg)
 {
-  pthread_descr self = arg;
   /* If we have special thread_self processing, initialize it.  */
 #ifdef INIT_THREAD_SELF
-  INIT_THREAD_SELF(self, 1);
+  INIT_THREAD_SELF(&__pthread_manager_thread, 1);
 #endif
 
   /* Get the lock the manager will free once all is correctly set up.  */
-  __pthread_lock (THREAD_GETMEM(self, p_lock), NULL);
+  __pthread_lock (THREAD_GETMEM((&__pthread_manager_thread), p_lock), NULL);
   /* Free it immediately.  */
-  __pthread_unlock (THREAD_GETMEM(self, p_lock));
+  __pthread_unlock (THREAD_GETMEM((&__pthread_manager_thread), p_lock));
 
-  return __pthread_manager(arg);
+  __pthread_manager(arg);
 }
 
 /* Process creation */
-
 static int
-__attribute__ ((noreturn))
+attribute_noreturn
 pthread_start_thread(void *arg)
 {
   pthread_descr self = (pthread_descr) arg;
   struct pthread_request request;
   void * outcome;
-#if HP_TIMING_AVAIL
-  hp_timing_t tmpclock;
-#endif
   /* Initialize special thread_self processing, if any.  */
 #ifdef INIT_THREAD_SELF
   INIT_THREAD_SELF(self, self->p_nr);
 #endif
-#if HP_TIMING_AVAIL
-  HP_TIMING_NOW (tmpclock);
-  THREAD_SETMEM (self, p_cpuclock_offset, tmpclock);
-#endif
+  PDEBUG("\n");
   /* Make sure our pid field is initialized, just in case we get there
      before our father has initialized it. */
-  THREAD_SETMEM(self, p_pid, __getpid());
+  THREAD_SETMEM(self, p_pid, getpid());
   /* Initial signal mask is that of the creating thread. (Otherwise,
      we'd just inherit the mask of the thread manager.) */
   sigprocmask(SIG_SETMASK, &self->p_start_args.mask, NULL);
   /* Set the scheduling policy and priority for the new thread, if needed */
   if (THREAD_GETMEM(self, p_start_args.schedpolicy) >= 0)
     /* Explicit scheduling attributes were provided: apply them */
-    __sched_setscheduler(THREAD_GETMEM(self, p_pid),
+    sched_setscheduler(THREAD_GETMEM(self, p_pid),
 			 THREAD_GETMEM(self, p_start_args.schedpolicy),
                          &self->p_start_args.schedparam);
-  else if (manager_thread->p_priority > 0)
+  else if (__pthread_manager_thread.p_priority > 0)
     /* Default scheduling required, but thread manager runs in realtime
        scheduling: switch new thread to SCHED_OTHER policy */
     {
       struct sched_param default_params;
       default_params.sched_priority = 0;
-      __sched_setscheduler(THREAD_GETMEM(self, p_pid),
+      sched_setscheduler(THREAD_GETMEM(self, p_pid),
                            SCHED_OTHER, &default_params);
     }
-#ifndef __UCLIBC_HAS_TLS__
-  /* Initialize thread-locale current locale to point to the global one.
-     With __thread support, the variable's initializer takes care of this.  */
-  __uselocale (LC_GLOBAL_LOCALE);
-#elif defined __UCLIBC_HAS_RESOLVER_SUPPORT__
-  /* Initialize __resp.  */
-  __resp = &self->p_res;
-#endif
   /* Make gdb aware of new thread */
   if (__pthread_threads_debug && __pthread_sig_debug > 0) {
     request.req_thread = self;
     request.req_kind = REQ_DEBUG;
-    TEMP_FAILURE_RETRY(write_not_cancel(__pthread_manager_request,
-					(char *) &request, sizeof(request)));
+    TEMP_FAILURE_RETRY(write(__pthread_manager_request,
+		(char *) &request, sizeof(request)));
     suspend(self);
   }
   /* Run the thread code */
@@ -313,7 +316,7 @@ pthread_start_thread(void *arg)
 }
 
 static int
-__attribute__ ((noreturn))
+attribute_noreturn
 pthread_start_thread_event(void *arg)
 {
   pthread_descr self = (pthread_descr) arg;
@@ -323,7 +326,7 @@ pthread_start_thread_event(void *arg)
 #endif
   /* Make sure our pid field is initialized, just in case we get there
      before our father has initialized it. */
-  THREAD_SETMEM(self, p_pid, __getpid());
+  THREAD_SETMEM(self, p_pid, getpid());
   /* Get the lock the manager will free once all is correctly set up.  */
   __pthread_lock (THREAD_GETMEM(self, p_lock), NULL);
   /* Free it immediately.  */
@@ -333,250 +336,136 @@ pthread_start_thread_event(void *arg)
   pthread_start_thread (arg);
 }
 
-#if defined __UCLIBC_HAS_TLS__ && !FLOATING_STACKS
-# error "TLS can only work with floating stacks"
-#endif
-
 static int pthread_allocate_stack(const pthread_attr_t *attr,
                                   pthread_descr default_new_thread,
                                   int pagesize,
-                                  char ** out_new_thread,
+                                  pthread_descr * out_new_thread,
                                   char ** out_new_thread_bottom,
                                   char ** out_guardaddr,
-                                  size_t * out_guardsize,
-                                  size_t * out_stacksize)
+                                  size_t * out_guardsize)
 {
   pthread_descr new_thread;
   char * new_thread_bottom;
   char * guardaddr;
   size_t stacksize, guardsize;
 
-#ifdef __UCLIBC_HAS_TLS__
-  /* TLS cannot work with fixed thread descriptor addresses.  */
-  assert (default_new_thread == NULL);
-#endif
-
   if (attr != NULL && attr->__stackaddr_set)
     {
-#ifdef _STACK_GROWS_UP
       /* The user provided a stack. */
-# ifdef __UCLIBC_HAS_TLS__
-      /* This value is not needed.  */
-      new_thread = (pthread_descr) attr->__stackaddr;
-      new_thread_bottom = (char *) new_thread;
-# else
-      new_thread = (pthread_descr) attr->__stackaddr;
-      new_thread_bottom = (char *) (new_thread + 1);
-# endif
-      guardaddr = attr->__stackaddr + attr->__stacksize;
-      guardsize = 0;
-#else
-      /* The user provided a stack.  For now we interpret the supplied
-	 address as 1 + the highest addr. in the stack segment.  If a
-	 separate register stack is needed, we place it at the low end
-	 of the segment, relying on the associated stacksize to
-	 determine the low end of the segment.  This differs from many
-	 (but not all) other pthreads implementations.  The intent is
-	 that on machines with a single stack growing toward higher
-	 addresses, stackaddr would be the lowest address in the stack
-	 segment, so that it is consistently close to the initial sp
-	 value. */
-# ifdef __UCLIBC_HAS_TLS__
-      new_thread = (pthread_descr) attr->__stackaddr;
-# else
-      new_thread =
-        (pthread_descr) ((long)(attr->__stackaddr) & -sizeof(void *)) - 1;
-# endif
+      new_thread = (pthread_descr) ((long)(attr->__stackaddr) & -sizeof(void *)) - 1;
       new_thread_bottom = (char *) attr->__stackaddr - attr->__stacksize;
-      guardaddr = new_thread_bottom;
+      guardaddr = NULL;
       guardsize = 0;
-#endif
-#ifndef THREAD_SELF
       __pthread_nonstandard_stacks = 1;
+#ifndef __ARCH_USE_MMU__
+      /* check the initial thread stack boundaries so they don't overlap */
+      NOMMU_INITIAL_THREAD_BOUNDS((char *) new_thread, (char *) new_thread_bottom);
+
+      PDEBUG("initial stack: bos=%p, tos=%p\n", __pthread_initial_thread_bos,
+            __pthread_initial_thread_tos);
 #endif
-#ifndef __UCLIBC_HAS_TLS__
-      /* Clear the thread data structure.  */
-      memset (new_thread, '\0', sizeof (*new_thread));
-#endif
-      stacksize = attr->__stacksize;
     }
   else
     {
-#ifdef NEED_SEPARATE_REGISTER_STACK
-      const size_t granularity = 2 * pagesize;
-      /* Try to make stacksize/2 a multiple of pagesize */
+#ifdef __ARCH_USE_MMU__
+      stacksize = STACK_SIZE - pagesize;
+      if (attr != NULL)
+        stacksize = MIN(stacksize, roundup(attr->__stacksize, pagesize));
+      /* Allocate space for stack and thread descriptor at default address */
+      new_thread = default_new_thread;
+      new_thread_bottom = (char *) (new_thread + 1) - stacksize;
+      if (mmap((caddr_t)((char *)(new_thread + 1) - INITIAL_STACK_SIZE),
+               INITIAL_STACK_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC,
+               MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED | MAP_GROWSDOWN,
+               -1, 0) == MAP_FAILED)
+        /* Bad luck, this segment is already mapped. */
+        return -1;
+      /* We manage to get a stack.  Now see whether we need a guard
+         and allocate it if necessary.  Notice that the default
+         attributes (stack_size = STACK_SIZE - pagesize) do not need
+	 a guard page, since the RLIMIT_STACK soft limit prevents stacks
+	 from running into one another. */
+      if (stacksize == (size_t) (STACK_SIZE - pagesize))
+        {
+          /* We don't need a guard page. */
+          guardaddr = NULL;
+          guardsize = 0;
+        }
+      else
+        {
+          /* Put a bad page at the bottom of the stack */
+          guardsize = attr->__guardsize;
+          guardaddr = (void *)new_thread_bottom - guardsize;
+          if (mmap((caddr_t) guardaddr, guardsize, 0, MAP_FIXED, -1, 0)
+              == MAP_FAILED)
+            {
+              /* We don't make this an error.  */
+              guardaddr = NULL;
+              guardsize = 0;
+            }
+        }
 #else
-      const size_t granularity = pagesize;
-#endif
-      void *map_addr;
+      /* We cannot mmap to this huge chunk of stack space when we don't have
+       * an MMU. Pretend we are using a user provided stack even if there was
+       * none provided by the user. Thus, we get around the mmap and reservation
+       * of a huge stack segment. -StS */
 
-      /* Allocate space for stack and thread descriptor at default address */
-#if FLOATING_STACKS
+      stacksize = INITIAL_STACK_SIZE;
+      /* The user may want to use a non-default stacksize */
       if (attr != NULL)
 	{
-	  guardsize = page_roundup (attr->__guardsize, granularity);
-	  stacksize = __pthread_max_stacksize - guardsize;
-	  stacksize = MIN (stacksize,
-			   page_roundup (attr->__stacksize, granularity));
+	  stacksize = attr->__stacksize;
 	}
-      else
+
+      /* malloc a stack - memory from the bottom up */
+      if ((new_thread_bottom = malloc(stacksize)) == NULL)
 	{
-	  guardsize = granularity;
-	  stacksize = __pthread_max_stacksize - guardsize;
+	  /* bad luck, we cannot malloc any more */
+	  return -1 ;
 	}
+      PDEBUG("malloced chunk: base=%p, size=0x%04x\n", new_thread_bottom, stacksize);
+
+      /* Set up the pointers. new_thread marks the TOP of the stack frame and
+       * the address of the pthread_descr struct at the same time. Therefore we
+       * must account for its size and fit it in the malloc()'ed block. The
+       * value of `new_thread' is then passed to clone() as the stack argument.
+       *
+       *               ^ +------------------------+
+       *               | |  pthread_descr struct  |
+       *               | +------------------------+  <- new_thread
+       * malloc block  | |                        |
+       *               | |  thread stack          |
+       *               | |                        |
+       *               v +------------------------+  <- new_thread_bottom
+       *
+       * Note: The calculated value of new_thread must be word aligned otherwise
+       * the kernel chokes on a non-aligned stack frame. Choose the lower
+       * available word boundary.
+       */
+      new_thread = ((pthread_descr) ((int)(new_thread_bottom + stacksize) & -sizeof(void*))) - 1;
+      guardaddr = NULL;
+      guardsize = 0;
 
-      map_addr = mmap(NULL, stacksize + guardsize,
-		      PROT_READ | PROT_WRITE | PROT_EXEC,
-		      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-      if (map_addr == MAP_FAILED)
-        /* No more memory available.  */
-        return -1;
+      PDEBUG("thread stack: bos=%p, tos=%p\n", new_thread_bottom, new_thread);
 
-# ifdef NEED_SEPARATE_REGISTER_STACK
-      guardaddr = map_addr + stacksize / 2;
-      if (guardsize > 0)
-	mprotect (guardaddr, guardsize, PROT_NONE);
-
-      new_thread_bottom = (char *) map_addr;
-#  ifdef __UCLIBC_HAS_TLS__
-      new_thread = ((pthread_descr) (new_thread_bottom + stacksize
-				     + guardsize));
-#  else
-      new_thread = ((pthread_descr) (new_thread_bottom + stacksize
-				     + guardsize)) - 1;
-#  endif
-# elif defined _STACK_GROWS_DOWN
-      guardaddr = map_addr;
-      if (guardsize > 0)
-	mprotect (guardaddr, guardsize, PROT_NONE);
-
-      new_thread_bottom = (char *) map_addr + guardsize;
-#  ifdef __UCLIBC_HAS_TLS__
-      new_thread = ((pthread_descr) (new_thread_bottom + stacksize));
-#  else
-      new_thread = ((pthread_descr) (new_thread_bottom + stacksize)) - 1;
-#  endif
-# elif defined _STACK_GROWS_UP
-      guardaddr = map_addr + stacksize;
-      if (guardsize > 0)
-	mprotect (guardaddr, guardsize, PROT_NONE);
-
-      new_thread = (pthread_descr) map_addr;
-#  ifdef __UCLIBC_HAS_TLS__
-      new_thread_bottom = (char *) new_thread;
-#  else
-      new_thread_bottom = (char *) (new_thread + 1);
-#  endif
-# else
-#  error You must define a stack direction
-# endif /* Stack direction */
-#else /* !FLOATING_STACKS */
-# if !defined NEED_SEPARATE_REGISTER_STACK && defined _STACK_GROWS_DOWN
-      void *res_addr;
-# endif
+      /* check the initial thread stack boundaries so they don't overlap */
+      NOMMU_INITIAL_THREAD_BOUNDS((char *) new_thread, (char *) new_thread_bottom);
 
-      if (attr != NULL)
-	{
-	  guardsize = page_roundup (attr->__guardsize, granularity);
-	  stacksize = STACK_SIZE - guardsize;
-	  stacksize = MIN (stacksize,
-			   page_roundup (attr->__stacksize, granularity));
-	}
-      else
-	{
-	  guardsize = granularity;
-	  stacksize = STACK_SIZE - granularity;
-	}
+      PDEBUG("initial stack: bos=%p, tos=%p\n", __pthread_initial_thread_bos,
+	     __pthread_initial_thread_tos);
 
-# ifdef NEED_SEPARATE_REGISTER_STACK
-      new_thread = default_new_thread;
-      new_thread_bottom = (char *) (new_thread + 1) - stacksize - guardsize;
-      /* Includes guard area, unlike the normal case.  Use the bottom
-       end of the segment as backing store for the register stack.
-       Needed on IA64.  In this case, we also map the entire stack at
-       once.  According to David Mosberger, that's cheaper.  It also
-       avoids the risk of intermittent failures due to other mappings
-       in the same region.  The cost is that we might be able to map
-       slightly fewer stacks.  */
-
-      /* First the main stack: */
-      map_addr = (caddr_t)((char *)(new_thread + 1) - stacksize / 2);
-      res_addr = mmap(map_addr, stacksize / 2,
-		      PROT_READ | PROT_WRITE | PROT_EXEC,
-		      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-      if (res_addr != map_addr)
-	{
-	  /* Bad luck, this segment is already mapped. */
-	  if (res_addr != MAP_FAILED)
-	    munmap(res_addr, stacksize / 2);
-	  return -1;
-	}
-      /* Then the register stack:	*/
-      map_addr = (caddr_t)new_thread_bottom;
-      res_addr = mmap(map_addr, stacksize/2,
-		      PROT_READ | PROT_WRITE | PROT_EXEC,
-		      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-      if (res_addr != map_addr)
-	{
-	  if (res_addr != MAP_FAILED)
-	    munmap(res_addr, stacksize / 2);
-	  munmap((caddr_t)((char *)(new_thread + 1) - stacksize/2),
-		 stacksize/2);
-	  return -1;
-	}
-
-      guardaddr = new_thread_bottom + stacksize/2;
-      /* We leave the guard area in the middle unmapped.	*/
-# else  /* !NEED_SEPARATE_REGISTER_STACK */
-#  ifdef _STACK_GROWS_DOWN
-      new_thread = default_new_thread;
-      new_thread_bottom = (char *) (new_thread + 1) - stacksize;
-      map_addr = new_thread_bottom - guardsize;
-      res_addr = mmap(map_addr, stacksize + guardsize,
-		      PROT_READ | PROT_WRITE | PROT_EXEC,
-		      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-      if (res_addr != map_addr)
-	{
-	  /* Bad luck, this segment is already mapped. */
-	  if (res_addr != MAP_FAILED)
-	    munmap (res_addr, stacksize + guardsize);
-	  return -1;
-	}
+      /* on non-MMU systems we always have non-standard stack frames */
+      __pthread_nonstandard_stacks = 1;
 
-      /* We manage to get a stack.  Protect the guard area pages if
-	 necessary.  */
-      guardaddr = map_addr;
-      if (guardsize > 0)
-	mprotect (guardaddr, guardsize, PROT_NONE);
-#  else
-      /* The thread description goes at the bottom of this area, and
-       * the stack starts directly above it.
-       */
-      new_thread = (pthread_descr)((unsigned long)default_new_thread &~ (STACK_SIZE - 1));
-      map_addr = mmap(new_thread, stacksize + guardsize,
-		      PROT_READ | PROT_WRITE | PROT_EXEC,
-		      MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-      if (map_addr == MAP_FAILED)
-	  return -1;
-
-      new_thread_bottom = map_addr + sizeof(*new_thread);
-      guardaddr = map_addr + stacksize;
-      if (guardsize > 0)
-	  mprotect (guardaddr, guardsize, PROT_NONE);
-
-#  endif /* stack direction */
-# endif  /* !NEED_SEPARATE_REGISTER_STACK */
-#endif   /* !FLOATING_STACKS */
+#endif /* __ARCH_USE_MMU__ */
     }
-  *out_new_thread = (char *) new_thread;
+
+  /* Clear the thread data structure.  */
+  memset (new_thread, '\0', sizeof (*new_thread));
+  *out_new_thread = new_thread;
   *out_new_thread_bottom = new_thread_bottom;
   *out_guardaddr = guardaddr;
   *out_guardsize = guardsize;
-#ifdef NEED_SEPARATE_REGISTER_STACK
-  *out_stacksize = stacksize / 2;
-#else
-  *out_stacksize = stacksize;
-#endif
   return 0;
 }
 
@@ -589,30 +478,17 @@ static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
   size_t sseg;
   int pid;
   pthread_descr new_thread;
-  char *stack_addr;
   char * new_thread_bottom;
+  char * new_thread_top;
   pthread_t new_thread_id;
   char *guardaddr = NULL;
-  size_t guardsize = 0, stksize = 0;
-  int pagesize = __getpagesize();
+  size_t guardsize = 0;
+  int pagesize = getpagesize();
   int saved_errno = 0;
 
-#ifdef __UCLIBC_HAS_TLS__
-  new_thread = _dl_allocate_tls (NULL);
-  if (new_thread == NULL)
-    return EAGAIN;
-# if defined(TLS_DTV_AT_TP)
-  /* pthread_descr is below TP.  */
-  new_thread = (pthread_descr) ((char *) new_thread - TLS_PRE_TCB_SIZE);
-# endif
-#else
-  /* Prevent warnings.  */
-  new_thread = NULL;
-#endif
-
   /* First check whether we have to change the policy and if yes, whether
      we can  do this.  Normally this should be done by examining the
-     return value of the __sched_setscheduler call in pthread_start_thread
+     return value of the sched_setscheduler call in pthread_start_thread
      but this is hard to implement.  FIXME  */
   if (attr != NULL && attr->__schedpolicy != SCHED_OTHER && geteuid () != 0)
     return EPERM;
@@ -620,36 +496,21 @@ static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
   for (sseg = 2; ; sseg++)
     {
       if (sseg >= PTHREAD_THREADS_MAX)
-	{
-#ifdef __UCLIBC_HAS_TLS__
-# if defined(TLS_DTV_AT_TP)
-	  new_thread = (pthread_descr) ((char *) new_thread + TLS_PRE_TCB_SIZE);
-# endif
-	  _dl_deallocate_tls (new_thread, true);
-#endif
-	  return EAGAIN;
-	}
+	return EAGAIN;
       if (__pthread_handles[sseg].h_descr != NULL)
 	continue;
-      if (pthread_allocate_stack(attr, thread_segment(sseg),
-				 pagesize, &stack_addr, &new_thread_bottom,
-                                 &guardaddr, &guardsize, &stksize) == 0)
-	{
-#ifdef __UCLIBC_HAS_TLS__
-	  new_thread->p_stackaddr = stack_addr;
-#else
-	  new_thread = (pthread_descr) stack_addr;
-#endif
-	  break;
+      if (pthread_allocate_stack(attr, thread_segment(sseg), pagesize,
+                                 &new_thread, &new_thread_bottom,
+                                 &guardaddr, &guardsize) == 0)
+        break;
 #ifndef __ARCH_USE_MMU__
-	} else {
-	  /* When there is MMU, mmap () is used to allocate the stack. If one
-	   * segment is already mapped, we should continue to see if we can
-	   * use the next one. However, when there is no MMU, malloc () is used.
-	   * It's waste of CPU cycles to continue to try if it fails.  */
-	  return EAGAIN;
+      else
+        /* When there is MMU, mmap () is used to allocate the stack. If one
+         * segment is already mapped, we should continue to see if we can
+         * use the next one. However, when there is no MMU, malloc () is used.
+         * It's waste of CPU cycles to continue to try if it fails.  */
+        return EAGAIN;
 #endif
-	}
     }
   __pthread_handles_num++;
   /* Allocate new thread identifier */
@@ -657,28 +518,20 @@ static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
   new_thread_id = sseg + pthread_threads_counter;
   /* Initialize the thread descriptor.  Elements which have to be
      initialized to zero already have this value.  */
-#if !defined __UCLIBC_HAS_TLS__ || !TLS_DTV_AT_TP
-  new_thread->p_header.data.tcb = new_thread;
-  new_thread->p_header.data.self = new_thread;
-#endif
-#if TLS_MULTIPLE_THREADS_IN_TCB || !defined __UCLIBC_HAS_TLS__ || !TLS_DTV_AT_TP
-  new_thread->p_multiple_threads = 1;
-#endif
   new_thread->p_tid = new_thread_id;
   new_thread->p_lock = &(__pthread_handles[sseg].h_lock);
   new_thread->p_cancelstate = PTHREAD_CANCEL_ENABLE;
   new_thread->p_canceltype = PTHREAD_CANCEL_DEFERRED;
-#ifndef __UCLIBC_HAS_TLS__
   new_thread->p_errnop = &new_thread->p_errno;
   new_thread->p_h_errnop = &new_thread->p_h_errno;
-  new_thread->p_resp = &new_thread->p_res;
-#endif
+#ifdef __UCLIBC_HAS_XLOCALE__
+  /* Initialize thread's locale to the global locale. */
+  new_thread->locale = __global_locale;
+#endif /* __UCLIBC_HAS_XLOCALE__ */
   new_thread->p_guardaddr = guardaddr;
   new_thread->p_guardsize = guardsize;
+  new_thread->p_self = new_thread;
   new_thread->p_nr = sseg;
-  new_thread->p_inheritsched = attr ? attr->__inheritsched : 0;
-  new_thread->p_alloca_cutoff = stksize / 4 > __MAX_ALLOCA_CUTOFF
-				 ? __MAX_ALLOCA_CUTOFF : stksize / 4;
   /* Initialize the thread handle */
   __pthread_init_lock(&__pthread_handles[sseg].h_lock);
   __pthread_handles[sseg].h_descr = new_thread;
@@ -696,8 +549,8 @@ static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
 	      sizeof (struct sched_param));
       break;
     case PTHREAD_INHERIT_SCHED:
-      new_thread->p_start_args.schedpolicy = __sched_getscheduler(father_pid);
-      __sched_getparam(father_pid, &new_thread->p_start_args.schedparam);
+      new_thread->p_start_args.schedpolicy = sched_getscheduler(father_pid);
+      sched_getparam(father_pid, &new_thread->p_start_args.schedparam);
       break;
     }
     new_thread->p_priority =
@@ -707,59 +560,55 @@ static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
   new_thread->p_start_args.start_routine = start_routine;
   new_thread->p_start_args.arg = arg;
   new_thread->p_start_args.mask = *mask;
-  /* Make the new thread ID available already now.  If any of the later
-     functions fail we return an error value and the caller must not use
-     the stored thread ID.  */
-  *thread = new_thread_id;
   /* Raise priority of thread manager if needed */
   __pthread_manager_adjust_prio(new_thread->p_priority);
   /* Do the cloning.  We have to use two different functions depending
      on whether we are debugging or not.  */
-  pid = 0;	/* Note that the thread never can have PID zero.  */
+  pid = 0;     /* Note that the thread never can have PID zero.  */
+  new_thread_top = ((char *)new_thread - THREAD_STACK_OFFSET);
+
+  /* ******************************************************** */
+  /*  This code was moved from below to cope with running threads
+   *  on uClinux systems.  See comment below...
+   * Insert new thread in doubly linked list of active threads */
+  new_thread->p_prevlive = __pthread_main_thread;
+  new_thread->p_nextlive = __pthread_main_thread->p_nextlive;
+  __pthread_main_thread->p_nextlive->p_prevlive = new_thread;
+  __pthread_main_thread->p_nextlive = new_thread;
+  /* ********************************************************* */
+
   if (report_events)
     {
       /* See whether the TD_CREATE event bit is set in any of the
          masks.  */
       int idx = __td_eventword (TD_CREATE);
-      uint32_t mask = __td_eventmask (TD_CREATE);
+      uint32_t m = __td_eventmask (TD_CREATE);
 
-      if ((mask & (__pthread_threads_events.event_bits[idx]
+      if ((m & (__pthread_threads_events.event_bits[idx]
 		   | event_maskp->event_bits[idx])) != 0)
 	{
 	  /* Lock the mutex the child will use now so that it will stop.  */
 	  __pthread_lock(new_thread->p_lock, NULL);
 
 	  /* We have to report this event.  */
-#ifdef NEED_SEPARATE_REGISTER_STACK
-	  /* Perhaps this version should be used on all platforms. But
-	   this requires that __clone2 be uniformly supported
-	   everywhere.
-
-	   And there is some argument for changing the __clone2
-	   interface to pass sp and bsp instead, making it more IA64
-	   specific, but allowing stacks to grow outward from each
-	   other, to get less paging and fewer mmaps.  */
-	  pid = __clone2(pthread_start_thread_event,
-  		 (void **)new_thread_bottom,
-			 (char *)stack_addr - new_thread_bottom,
-			 CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM |
-			 __pthread_sig_cancel, new_thread);
-#elif defined _STACK_GROWS_UP
-	  pid = __clone(pthread_start_thread_event, (void *) new_thread_bottom,
-			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM |
+#ifdef __ia64__
+	  pid = __clone2(pthread_start_thread_event, new_thread_top,
+			new_thread_top - new_thread_bottom,
+			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
 			__pthread_sig_cancel, new_thread);
 #else
-	  pid = __clone(pthread_start_thread_event, stack_addr,
-			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM |
+	  pid = clone(pthread_start_thread_event, new_thread_top,
+			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
 			__pthread_sig_cancel, new_thread);
 #endif
+
 	  saved_errno = errno;
 	  if (pid != -1)
 	    {
 	      /* Now fill in the information about the new thread in
-		 the newly created thread's data structure.  We cannot let
-		 the new thread do this since we don't know whether it was
-		 already scheduled when we send the event.  */
+	         the newly created thread's data structure.  We cannot let
+	         the new thread do this since we don't know whether it was
+	         already scheduled when we send the event.  */
 	      new_thread->p_eventbuf.eventdata = new_thread;
 	      new_thread->p_eventbuf.eventnum = TD_CREATE;
 	      __pthread_last_event = new_thread;
@@ -779,69 +628,71 @@ static int pthread_handle_create(pthread_t *thread, const pthread_attr_t *attr,
     }
   if (pid == 0)
     {
-#ifdef NEED_SEPARATE_REGISTER_STACK
-      pid = __clone2(pthread_start_thread,
-		     (void **)new_thread_bottom,
-                     (char *)stack_addr - new_thread_bottom,
-		     CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM |
-		     __pthread_sig_cancel, new_thread);
-#elif defined _STACK_GROWS_UP
-      pid = __clone(pthread_start_thread, (void *) new_thread_bottom,
-		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM |
+      PDEBUG("cloning new_thread = %p\n", new_thread);
+#ifdef __ia64__
+      pid = __clone2(pthread_start_thread, new_thread_top,
+		    new_thread_top - new_thread_bottom,
+		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
 		    __pthread_sig_cancel, new_thread);
 #else
-      pid = __clone(pthread_start_thread, stack_addr,
-		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM |
+      pid = clone(pthread_start_thread, new_thread_top,
+		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
 		    __pthread_sig_cancel, new_thread);
-#endif /* !NEED_SEPARATE_REGISTER_STACK */
+#endif
       saved_errno = errno;
     }
   /* Check if cloning succeeded */
   if (pid == -1) {
+    /********************************************************
+     * Code inserted to remove the thread from our list of active
+     * threads in case of failure (needed to cope with uClinux),
+     * See comment below. */
+    new_thread->p_nextlive->p_prevlive = new_thread->p_prevlive;
+    new_thread->p_prevlive->p_nextlive = new_thread->p_nextlive;
+    /********************************************************/
+
     /* Free the stack if we allocated it */
     if (attr == NULL || !attr->__stackaddr_set)
       {
-#ifdef NEED_SEPARATE_REGISTER_STACK
-	size_t stacksize = ((char *)(new_thread->p_guardaddr)
-			    - new_thread_bottom);
-	munmap((caddr_t)new_thread_bottom,
-	       2 * stacksize + new_thread->p_guardsize);
-#elif defined _STACK_GROWS_UP
-# ifdef __UCLIBC_HAS_TLS__
-	size_t stacksize = guardaddr - stack_addr;
-	munmap(stack_addr, stacksize + guardsize);
-# else
-	size_t stacksize = guardaddr - (char *)new_thread;
-	munmap(new_thread, stacksize + guardsize);
-# endif
+#ifdef __ARCH_USE_MMU__
+	if (new_thread->p_guardsize != 0)
+	  munmap(new_thread->p_guardaddr, new_thread->p_guardsize);
+	munmap((caddr_t)((char *)(new_thread+1) - INITIAL_STACK_SIZE),
+	       INITIAL_STACK_SIZE);
 #else
-# ifdef __UCLIBC_HAS_TLS__
-	size_t stacksize = stack_addr - new_thread_bottom;
-# else
-	size_t stacksize = (char *)(new_thread+1) - new_thread_bottom;
-# endif
-	munmap(new_thread_bottom - guardsize, guardsize + stacksize);
-#endif
+	free(new_thread_bottom);
+#endif /* __ARCH_USE_MMU__ */
       }
-#ifdef __UCLIBC_HAS_TLS__
-# if defined(TLS_DTV_AT_TP)
-    new_thread = (pthread_descr) ((char *) new_thread + TLS_PRE_TCB_SIZE);
-# endif
-    _dl_deallocate_tls (new_thread, true);
-#endif
     __pthread_handles[sseg].h_descr = NULL;
     __pthread_handles[sseg].h_bottom = NULL;
     __pthread_handles_num--;
     return saved_errno;
   }
+  PDEBUG("new thread pid = %d\n", pid);
+
+#if 0
+  /* ***********************************************************
+   This code has been moved before the call to clone().  In uClinux,
+   the use of wait on a semaphore is dependant upon that the child so
+   the child must be in the active threads list. This list is used in
+   pthread_find_self() to get the pthread_descr of self. So, if the
+   child calls sem_wait before this code is executed , it will hang
+   forever and initial_thread will instead be posted by a sem_post
+   call. */
+
   /* Insert new thread in doubly linked list of active threads */
   new_thread->p_prevlive = __pthread_main_thread;
   new_thread->p_nextlive = __pthread_main_thread->p_nextlive;
   __pthread_main_thread->p_nextlive->p_prevlive = new_thread;
   __pthread_main_thread->p_nextlive = new_thread;
+  /************************************************************/
+#endif
+
   /* Set pid field of the new thread, in case we get there before the
      child starts. */
   new_thread->p_pid = pid;
+  /* We're all set */
+  *thread = new_thread_id;
   return 0;
 }
 
@@ -853,16 +704,21 @@ static void pthread_free(pthread_descr th)
 {
   pthread_handle handle;
   pthread_readlock_info *iter, *next;
+#ifndef __ARCH_USE_MMU__
+  char *h_bottom_save;
+#endif
 
-  ASSERT(th->p_exited);
   /* Make the handle invalid */
   handle =  thread_handle(th->p_tid);
   __pthread_lock(&handle->h_lock, NULL);
+#ifndef __ARCH_USE_MMU__
+  h_bottom_save = handle->h_bottom;
+#endif
   handle->h_descr = NULL;
   handle->h_bottom = (char *)(-1L);
   __pthread_unlock(&handle->h_lock);
-#ifdef FREE_THREAD
-  FREE_THREAD(th, th->p_nr);
+#ifdef FREE_THREAD_SELF
+  FREE_THREAD_SELF(th, th->p_nr);
 #endif
   /* One fewer threads in __pthread_handles */
   __pthread_handles_num--;
@@ -884,44 +740,19 @@ static void pthread_free(pthread_descr th)
     }
 
   /* If initial thread, nothing to free */
+  if (th == &__pthread_initial_thread) return;
   if (!th->p_userstack)
     {
-      size_t guardsize = th->p_guardsize;
+#ifdef __ARCH_USE_MMU__
       /* Free the stack and thread descriptor area */
-      char *guardaddr = th->p_guardaddr;
-#ifdef _STACK_GROWS_UP
-# ifdef __UCLIBC_HAS_TLS__
-      size_t stacksize = guardaddr - th->p_stackaddr;
-      guardaddr = th->p_stackaddr;
-# else
-      size_t stacksize = guardaddr - (char *)th;
-      guardaddr = (char *)th;
-# endif
+      if (th->p_guardsize != 0)
+	munmap(th->p_guardaddr, th->p_guardsize);
+      munmap((caddr_t) ((char *)(th+1) - STACK_SIZE), STACK_SIZE);
 #else
-      /* Guardaddr is always set, even if guardsize is 0.  This allows
-	 us to compute everything else.  */
-# ifdef __UCLIBC_HAS_TLS__
-      size_t stacksize = th->p_stackaddr - guardaddr - guardsize;
-# else
-      size_t stacksize = (char *)(th+1) - guardaddr - guardsize;
-# endif
-# ifdef NEED_SEPARATE_REGISTER_STACK
-      /* Take account of the register stack, which is below guardaddr.  */
-      guardaddr -= stacksize;
-      stacksize *= 2;
-# endif
-#endif
-      /* Unmap the stack.  */
-      munmap(guardaddr, stacksize + guardsize);
-
+      /* For non-MMU systems we always malloc the stack, so free it here. -StS */
+      free(h_bottom_save);
+#endif /* __ARCH_USE_MMU__ */
     }
-
-#ifdef __UCLIBC_HAS_TLS__
-# if defined(TLS_DTV_AT_TP)
-  th = (pthread_descr) ((char *) th + TLS_PRE_TCB_SIZE);
-# endif
-  _dl_deallocate_tls (th, true);
-#endif
 }
 
 /* Handle threads that have exited */
@@ -980,8 +811,9 @@ static void pthread_reap_children(void)
 {
   pid_t pid;
   int status;
+  PDEBUG("\n");
 
-  while ((pid = waitpid_not_cancel(-1, &status, WNOHANG | __WCLONE)) > 0) {
+  while ((pid = waitpid(-1, &status, WNOHANG | __WCLONE)) > 0) {
     pthread_exited(pid);
     if (WIFSIGNALED(status)) {
       /* If a thread died due to a signal, send the same signal to
@@ -1001,7 +833,7 @@ static void pthread_handle_free(pthread_t th_id)
   pthread_descr th;
 
   __pthread_lock(&handle->h_lock, NULL);
-  if (nonexisting_handle(handle, th_id)) {
+  if (invalid_handle(handle, th_id)) {
     /* pthread_reap_children has deallocated the thread already,
        nothing needs to be done */
     __pthread_unlock(&handle->h_lock);
@@ -1035,20 +867,6 @@ static void pthread_kill_all_threads(int sig, int main_thread_also)
   }
 }
 
-static void pthread_for_each_thread(void *arg,
-    void (*fn)(void *, pthread_descr))
-{
-  pthread_descr th;
-
-  for (th = __pthread_main_thread->p_nextlive;
-       th != __pthread_main_thread;
-       th = th->p_nextlive) {
-    fn(arg, th);
-  }
-
-  fn(arg, __pthread_main_thread);
-}
-
 /* Process-wide exit() */
 
 static void pthread_handle_exit(pthread_descr issuing_thread, int exitcode)
@@ -1056,12 +874,6 @@ static void pthread_handle_exit(pthread_descr issuing_thread, int exitcode)
   pthread_descr th;
   __pthread_exit_requested = 1;
   __pthread_exit_code = exitcode;
-  /* A forced asynchronous cancellation follows.  Make sure we won't
-     get stuck later in the main thread with a system lock being held
-     by one of the cancelled threads.  Ideally one would use the same
-     code as in pthread_atfork(), but we can't distinguish system and
-     user handlers there.  */
-  __flockfilelist();
   /* Send the CANCEL signal to all running threads, including the main
      thread, but excluding the thread from which the exit request originated
      (that thread must complete the exit, e.g. calling atexit functions
@@ -1078,32 +890,31 @@ static void pthread_handle_exit(pthread_descr issuing_thread, int exitcode)
        th = th->p_nextlive) {
     waitpid(th->p_pid, NULL, __WCLONE);
   }
-  __fresetlockfiles();
   restart(issuing_thread);
   _exit(0);
 }
 
 /* Handler for __pthread_sig_cancel in thread manager thread */
 
-void __pthread_manager_sighandler(int sig)
+void __pthread_manager_sighandler(int sig attribute_unused)
 {
-  int kick_manager = terminated_children == 0 && main_thread_exiting;
-  terminated_children = 1;
-
-  /* If the main thread is terminating, kick the thread manager loop
-     each time some threads terminate. This eliminates a two second
-     shutdown delay caused by the thread manager sleeping in the
-     call to __poll(). Instead, the thread manager is kicked into
-     action, reaps the outstanding threads and resumes the main thread
-     so that it can complete the shutdown. */
-
-  if (kick_manager) {
-    struct pthread_request request;
-    request.req_thread = 0;
-    request.req_kind = REQ_KICK;
-    TEMP_FAILURE_RETRY(write_not_cancel(__pthread_manager_request,
-					(char *) &request, sizeof(request)));
-  }
+    int kick_manager = terminated_children == 0 && main_thread_exiting;
+    terminated_children = 1;
+
+    /* If the main thread is terminating, kick the thread manager loop
+       each time some threads terminate. This eliminates a two second
+       shutdown delay caused by the thread manager sleeping in the
+       call to __poll(). Instead, the thread manager is kicked into
+       action, reaps the outstanding threads and resumes the main thread
+       so that it can complete the shutdown. */
+
+    if (kick_manager) {
+	struct pthread_request request;
+	request.req_thread = 0;
+	request.req_kind = REQ_KICK;
+	TEMP_FAILURE_RETRY(write(__pthread_manager_request,
+		    (char *) &request, sizeof(request)));
+    }
 }
 
 /* Adjust priority of thread manager so that it always run at a priority
@@ -1113,10 +924,10 @@ void __pthread_manager_adjust_prio(int thread_prio)
 {
   struct sched_param param;
 
-  if (thread_prio <= manager_thread->p_priority) return;
+  if (thread_prio <= __pthread_manager_thread.p_priority) return;
   param.sched_priority =
-    thread_prio < __sched_get_priority_max(SCHED_FIFO)
+    thread_prio < sched_get_priority_max(SCHED_FIFO)
     ? thread_prio + 1 : thread_prio;
-  __sched_setscheduler(manager_thread->p_pid, SCHED_FIFO, &param);
-  manager_thread->p_priority = thread_prio;
+  sched_setscheduler(__pthread_manager_thread.p_pid, SCHED_FIFO, &param);
+  __pthread_manager_thread.p_priority = thread_prio;
 }
diff --git a/libpthread/linuxthreads/mutex.c b/libpthread/linuxthreads/mutex.c
index 3c97ea7d6..890841452 100644
--- a/libpthread/linuxthreads/mutex.c
+++ b/libpthread/linuxthreads/mutex.c
@@ -14,7 +14,6 @@
 
 /* Mutexes */
 
-#include <bits/libc-lock.h>
 #include <errno.h>
 #include <sched.h>
 #include <stddef.h>
@@ -25,7 +24,7 @@
 #include "queue.h"
 #include "restart.h"
 
-int __pthread_mutex_init(pthread_mutex_t * mutex,
+int attribute_hidden __pthread_mutex_init(pthread_mutex_t * mutex,
                        const pthread_mutexattr_t * mutex_attr)
 {
   __pthread_init_lock(&mutex->__m_lock);
@@ -37,7 +36,7 @@ int __pthread_mutex_init(pthread_mutex_t * mutex,
 }
 strong_alias (__pthread_mutex_init, pthread_mutex_init)
 
-int __pthread_mutex_destroy(pthread_mutex_t * mutex)
+int attribute_hidden __pthread_mutex_destroy(pthread_mutex_t * mutex)
 {
   switch (mutex->__m_kind) {
   case PTHREAD_MUTEX_ADAPTIVE_NP:
@@ -56,7 +55,7 @@ int __pthread_mutex_destroy(pthread_mutex_t * mutex)
 }
 strong_alias (__pthread_mutex_destroy, pthread_mutex_destroy)
 
-int __pthread_mutex_trylock(pthread_mutex_t * mutex)
+int attribute_hidden __pthread_mutex_trylock(pthread_mutex_t * mutex)
 {
   pthread_descr self;
   int retcode;
@@ -92,7 +91,7 @@ int __pthread_mutex_trylock(pthread_mutex_t * mutex)
 }
 strong_alias (__pthread_mutex_trylock, pthread_mutex_trylock)
 
-int __pthread_mutex_lock(pthread_mutex_t * mutex)
+int attribute_hidden __pthread_mutex_lock(pthread_mutex_t * mutex)
 {
   pthread_descr self;
 
@@ -125,7 +124,7 @@ int __pthread_mutex_lock(pthread_mutex_t * mutex)
 }
 strong_alias (__pthread_mutex_lock, pthread_mutex_lock)
 
-int __pthread_mutex_timedlock (pthread_mutex_t *mutex,
+int pthread_mutex_timedlock (pthread_mutex_t *mutex,
 			       const struct timespec *abstime)
 {
   pthread_descr self;
@@ -167,9 +166,8 @@ int __pthread_mutex_timedlock (pthread_mutex_t *mutex,
     return EINVAL;
   }
 }
-strong_alias (__pthread_mutex_timedlock, pthread_mutex_timedlock)
 
-int __pthread_mutex_unlock(pthread_mutex_t * mutex)
+int attribute_hidden __pthread_mutex_unlock(pthread_mutex_t * mutex)
 {
   switch (mutex->__m_kind) {
   case PTHREAD_MUTEX_ADAPTIVE_NP:
@@ -200,20 +198,20 @@ int __pthread_mutex_unlock(pthread_mutex_t * mutex)
 }
 strong_alias (__pthread_mutex_unlock, pthread_mutex_unlock)
 
-int __pthread_mutexattr_init(pthread_mutexattr_t *attr)
+int attribute_hidden __pthread_mutexattr_init(pthread_mutexattr_t *attr)
 {
   attr->__mutexkind = PTHREAD_MUTEX_TIMED_NP;
   return 0;
 }
-strong_alias (__pthread_mutexattr_init, pthread_mutexattr_init)
+strong_alias(__pthread_mutexattr_init,pthread_mutexattr_init)
 
-int __pthread_mutexattr_destroy(pthread_mutexattr_t *attr)
+int attribute_hidden __pthread_mutexattr_destroy(pthread_mutexattr_t *attr attribute_unused)
 {
   return 0;
 }
-strong_alias (__pthread_mutexattr_destroy, pthread_mutexattr_destroy)
+strong_alias(__pthread_mutexattr_destroy,pthread_mutexattr_destroy)
 
-int __pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind)
+int attribute_hidden __pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind)
 {
   if (kind != PTHREAD_MUTEX_ADAPTIVE_NP
       && kind != PTHREAD_MUTEX_RECURSIVE_NP
@@ -223,10 +221,11 @@ int __pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind)
   attr->__mutexkind = kind;
   return 0;
 }
-weak_alias (__pthread_mutexattr_settype, pthread_mutexattr_settype)
-strong_alias ( __pthread_mutexattr_settype, __pthread_mutexattr_setkind_np)
+strong_alias(__pthread_mutexattr_settype,pthread_mutexattr_settype)
+strong_alias (__pthread_mutexattr_settype, __pthread_mutexattr_setkind_np)
 weak_alias (__pthread_mutexattr_setkind_np, pthread_mutexattr_setkind_np)
 
+int __pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *kind) attribute_hidden;
 int __pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *kind)
 {
   *kind = attr->__mutexkind;
@@ -236,7 +235,9 @@ weak_alias (__pthread_mutexattr_gettype, pthread_mutexattr_gettype)
 strong_alias (__pthread_mutexattr_gettype, __pthread_mutexattr_getkind_np)
 weak_alias (__pthread_mutexattr_getkind_np, pthread_mutexattr_getkind_np)
 
-int __pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr,
+int __pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr attribute_unused,
+				   int *pshared) attribute_hidden;
+int __pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr attribute_unused,
 				   int *pshared)
 {
   *pshared = PTHREAD_PROCESS_PRIVATE;
@@ -244,7 +245,8 @@ int __pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr,
 }
 weak_alias (__pthread_mutexattr_getpshared, pthread_mutexattr_getpshared)
 
-int __pthread_mutexattr_setpshared (pthread_mutexattr_t *attr, int pshared)
+int __pthread_mutexattr_setpshared (pthread_mutexattr_t *attr attribute_unused, int pshared) attribute_hidden;
+int __pthread_mutexattr_setpshared (pthread_mutexattr_t *attr attribute_unused, int pshared)
 {
   if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
     return EINVAL;
@@ -273,9 +275,9 @@ static void pthread_once_cancelhandler(void *arg)
 {
     pthread_once_t *once_control = arg;
 
-    pthread_mutex_lock(&once_masterlock);
+    __pthread_mutex_lock(&once_masterlock);
     *once_control = NEVER;
-    pthread_mutex_unlock(&once_masterlock);
+    __pthread_mutex_unlock(&once_masterlock);
     pthread_cond_broadcast(&once_finished);
 }
 
@@ -293,7 +295,7 @@ int __pthread_once(pthread_once_t * once_control, void (*init_routine)(void))
 
   state_changed = 0;
 
-  pthread_mutex_lock(&once_masterlock);
+  __pthread_mutex_lock(&once_masterlock);
 
   /* If this object was left in an IN_PROGRESS state in a parent
      process (indicated by stale generation field), reset it to NEVER. */
@@ -308,16 +310,16 @@ int __pthread_once(pthread_once_t * once_control, void (*init_routine)(void))
   /* Here *once_control is stable and either NEVER or DONE. */
   if (*once_control == NEVER) {
     *once_control = IN_PROGRESS | fork_generation;
-    pthread_mutex_unlock(&once_masterlock);
+    __pthread_mutex_unlock(&once_masterlock);
     pthread_cleanup_push(pthread_once_cancelhandler, once_control);
     init_routine();
     pthread_cleanup_pop(0);
-    pthread_mutex_lock(&once_masterlock);
+    __pthread_mutex_lock(&once_masterlock);
     WRITE_MEMORY_BARRIER();
     *once_control = DONE;
     state_changed = 1;
   }
-  pthread_mutex_unlock(&once_masterlock);
+  __pthread_mutex_unlock(&once_masterlock);
 
   if (state_changed)
     pthread_cond_broadcast(&once_finished);
@@ -336,19 +338,22 @@ strong_alias (__pthread_once, pthread_once)
  * and reset them back to NEVER.
  */
 
+void __pthread_once_fork_prepare(void);
 void __pthread_once_fork_prepare(void)
 {
-  pthread_mutex_lock(&once_masterlock);
+  __pthread_mutex_lock(&once_masterlock);
 }
 
+void __pthread_once_fork_parent(void);
 void __pthread_once_fork_parent(void)
 {
-  pthread_mutex_unlock(&once_masterlock);
+  __pthread_mutex_unlock(&once_masterlock);
 }
 
+void __pthread_once_fork_child(void);
 void __pthread_once_fork_child(void)
 {
-  pthread_mutex_init(&once_masterlock, NULL);
+  __pthread_mutex_init(&once_masterlock, NULL);
   pthread_cond_init(&once_finished, NULL);
   if (fork_generation <= INT_MAX - 4)
     fork_generation += 4;	/* leave least significant two bits zero */
diff --git a/libpthread/linuxthreads/pt-machine.c b/libpthread/linuxthreads/pt-machine.c
index d932cf84b..6963dfcab 100644
--- a/libpthread/linuxthreads/pt-machine.c
+++ b/libpthread/linuxthreads/pt-machine.c
@@ -3,22 +3,19 @@
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
    License, or (at your option) any later version.
 
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
+   Library General Public License for more details.
 
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   see <http://www.gnu.org/licenses/>.  */
 
 #define PT_EI
 
-extern long int testandset (int *spinlock);
-extern int __compare_and_swap (long int *p, long int oldval, long int newval);
-
 #include <pt-machine.h>
diff --git a/libpthread/linuxthreads/ptcleanup.c b/libpthread/linuxthreads/ptcleanup.c
deleted file mode 100644
index 88b9453ff..000000000
--- a/libpthread/linuxthreads/ptcleanup.c
+++ /dev/null
@@ -1,74 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1998 Xavier Leroy (Xavier.Leroy@inria.fr)	        */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Redefine siglongjmp and longjmp so that they interact correctly
-   with cleanup handlers */
-
-#define NO_PTR_DEMANGLE
-
-#include <setjmp.h>
-#include "pthread.h"
-#include "internals.h"
-#include <jmpbuf-unwind.h>
-#ifndef NO_PTR_DEMANGLE
-#define __JMPBUF_UNWINDS(a,b,c) _JMPBUF_UNWINDS(a,b,c)
-#else
-#define __JMPBUF_UNWINDS(a,b,c) _JMPBUF_UNWINDS(a,b)
-#endif
-
-#ifndef NO_PTR_DEMANGLE
-static __inline__ uintptr_t
-demangle_ptr (uintptr_t x)
-{
-#ifdef PTR_DEMANGLE
-  PTR_DEMANGLE (x);
-#endif
-  return x;
-}
-#else
-#define demangle_ptr(x) x
-#endif
-
-void __pthread_cleanup_upto (__jmp_buf target, char *targetframe)
-{
-  pthread_descr self = thread_self();
-  struct _pthread_cleanup_buffer * c;
-
-  for (c = THREAD_GETMEM(self, p_cleanup);
-       c != NULL && __JMPBUF_UNWINDS(target, c, demangle_ptr);
-       c = c->__prev)
-    {
-#ifdef _STACK_GROWS_DOWN
-      if ((char *) c <= targetframe)
-	{
-	  c = NULL;
-	  break;
-	}
-#elif defined _STACK_GROWS_UP
-      if ((char *) c >= targetframe)
-	{
-	  c = NULL;
-	  break;
-	}
-#else
-# error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
-#endif
-      c->__routine(c->__arg);
-    }
-  THREAD_SETMEM(self, p_cleanup, c);
-  if (THREAD_GETMEM(self, p_in_sighandler)
-      && __JMPBUF_UNWINDS(target, THREAD_GETMEM(self, p_in_sighandler),
-			 demangle_ptr))
-    THREAD_SETMEM(self, p_in_sighandler, NULL);
-}
diff --git a/libpthread/linuxthreads/ptclock_gettime.c b/libpthread/linuxthreads/ptclock_gettime.c
deleted file mode 100644
index dc28d0c68..000000000
--- a/libpthread/linuxthreads/ptclock_gettime.c
+++ /dev/null
@@ -1,67 +0,0 @@
-/* Copyright (C) 2001, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <time.h>
-#include "internals.h"
-#include "spinlock.h"
-
-
-#if HP_TIMING_AVAIL
-int
-__pthread_clock_gettime (clockid_t clock_id, hp_timing_t freq,
-			 struct timespec *tp)
-{
-  hp_timing_t tsc, cpuclock_offset;
-  pthread_descr self = thread_self ();
-  pthread_t thread = ((unsigned int) clock_id) >> CLOCK_IDFIELD_SIZE;
-  const unsigned int mask = ~0U >> CLOCK_IDFIELD_SIZE;
-
-  if (thread == 0 || (THREAD_GETMEM (self, p_tid) & mask) == thread)
-    cpuclock_offset = THREAD_GETMEM (self, p_cpuclock_offset);
-  else
-    {
-      pthread_descr th;
-      pthread_handle handle = thread_handle (thread);
-      __pthread_lock (&handle->h_lock, NULL);
-      th = handle->h_descr;
-      if (th == NULL || (th->p_tid & mask) != thread || th->p_terminated)
-	{
-	  __pthread_unlock (&handle->h_lock);
-	  __set_errno (EINVAL);
-	  return -1;
-	}
-      cpuclock_offset = th->p_cpuclock_offset;
-      __pthread_unlock (&handle->h_lock);
-   }
-
-  /* Get the current counter.  */
-  HP_TIMING_NOW (tsc);
-
-  /* Compute the offset since the start time of the process.  */
-  tsc -= cpuclock_offset;
-
-  /* Compute the seconds.  */
-  tp->tv_sec = tsc / freq;
-
-  /* And the nanoseconds.  This computation should be stable until
-     we get machines with about 16GHz frequency.  */
-  tp->tv_nsec = ((tsc % freq) * 1000000000ull) / freq;
-
-  return 0;
-}
-#endif
diff --git a/libpthread/linuxthreads/ptclock_settime.c b/libpthread/linuxthreads/ptclock_settime.c
deleted file mode 100644
index bea015d2c..000000000
--- a/libpthread/linuxthreads/ptclock_settime.c
+++ /dev/null
@@ -1,53 +0,0 @@
-/* Copyright (C) 2001, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <time.h>
-#include "internals.h"
-#include "spinlock.h"
-
-
-#if HP_TIMING_AVAIL
-int
-__pthread_clock_settime (clockid_t clock_id, hp_timing_t offset)
-{
-  pthread_descr self = thread_self ();
-  pthread_t thread = ((unsigned int) clock_id) >> CLOCK_IDFIELD_SIZE;
-  const unsigned int mask = ~0U >> CLOCK_IDFIELD_SIZE;
-
-  if (thread == 0 || (THREAD_GETMEM (self, p_tid) & mask) == thread)
-    /* Our own clock.  */
-    THREAD_SETMEM (self, p_cpuclock_offset, offset);
-  else
-    {
-      pthread_descr th;
-      pthread_handle handle = thread_handle (thread);
-      __pthread_lock (&handle->h_lock, NULL);
-      th = handle->h_descr;
-      if (th == NULL || (th->p_tid & mask) != thread || th->p_terminated)
-	{
-	  __pthread_unlock (&handle->h_lock);
-	  __set_errno (EINVAL);
-	  return -1;
-	}
-      th->p_cpuclock_offset = offset;
-      __pthread_unlock (&handle->h_lock);
-   }
-
-  return 0;
-}
-#endif
diff --git a/libpthread/linuxthreads/ptfork.c b/libpthread/linuxthreads/ptfork.c
index 71404acf1..6f1e2d3c9 100644
--- a/libpthread/linuxthreads/ptfork.c
+++ b/libpthread/linuxthreads/ptfork.c
@@ -12,81 +12,156 @@
 /* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
 /* GNU Library General Public License for more details.                 */
 
+/* mods for uClibc: removed strong alias and defined funcs properly */
+
 /* The "atfork" stuff */
 
 #include <errno.h>
+
+#ifdef __ARCH_USE_MMU__
+
+#include <bits/uClibc_mutex.h>
 #include <stddef.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include "pthread.h"
 #include "internals.h"
-#include <bits/libc-lock.h>
-#include "fork.h"
 
-pid_t __pthread_fork (struct fork_block *b)
+struct handler_list {
+  void (*handler)(void);
+  struct handler_list * next;
+};
+
+static pthread_mutex_t pthread_atfork_lock = PTHREAD_MUTEX_INITIALIZER;
+static struct handler_list * pthread_atfork_prepare = NULL;
+static struct handler_list * pthread_atfork_parent = NULL;
+static struct handler_list * pthread_atfork_child = NULL;
+
+#ifdef __MALLOC__
+__UCLIBC_MUTEX_EXTERN(__malloc_heap_lock);
+__UCLIBC_MUTEX_EXTERN(__malloc_sbrk_lock);
+#ifdef __UCLIBC_UCLINUX_BROKEN_MUNMAP__
+__UCLIBC_MUTEX_EXTERN(__malloc_mmb_heap_lock);
+#endif
+#elif defined(__MALLOC_STANDARD__) || defined(__MALLOC_SIMPLE__)
+__UCLIBC_MUTEX_EXTERN(__malloc_lock);
+#endif
+
+static void pthread_insert_list(struct handler_list ** list,
+                                void (*handler)(void),
+                                struct handler_list * newlist,
+                                int at_end)
 {
-  pid_t pid;
-  list_t *runp;
+  if (handler == NULL) return;
+  if (at_end) {
+    while(*list != NULL) list = &((*list)->next);
+  }
+  newlist->handler = handler;
+  newlist->next = *list;
+  *list = newlist;
+}
 
-  __libc_lock_lock (b->lock);
+struct handler_list_block {
+  struct handler_list prepare, parent, child;
+};
 
-  /* Run all the registered preparation handlers.  In reverse order.  */
-  list_for_each_prev (runp, &b->prepare_list)
-    {
-      struct fork_handler *curp;
-      curp = list_entry (runp, struct fork_handler, list);
-      curp->handler ();
-    }
+int pthread_atfork(void (*prepare)(void),
+		     void (*parent)(void),
+		     void (*child)(void))
+{
+  struct handler_list_block * block =
+    (struct handler_list_block *) malloc(sizeof(struct handler_list_block));
+  if (block == NULL) return ENOMEM;
+  __pthread_mutex_lock(&pthread_atfork_lock);
+  /* "prepare" handlers are called in LIFO */
+  pthread_insert_list(&pthread_atfork_prepare, prepare, &block->prepare, 0);
+  /* "parent" handlers are called in FIFO */
+  pthread_insert_list(&pthread_atfork_parent, parent, &block->parent, 1);
+  /* "child" handlers are called in FIFO */
+  pthread_insert_list(&pthread_atfork_child, child, &block->child, 1);
+  __pthread_mutex_unlock(&pthread_atfork_lock);
+  return 0;
+}
+/*strong_alias (__pthread_atfork, pthread_atfork)*/
 
-  __pthread_once_fork_prepare();
-  __flockfilelist();
+static __inline__ void pthread_call_handlers(struct handler_list * list)
+{
+  for (/*nothing*/; list != NULL; list = list->next) (list->handler)();
+}
+
+void __pthread_once_fork_prepare(void);
+void __pthread_once_fork_child(void);
+void __pthread_once_fork_parent(void);
+
+static pid_t __fork(void)
+{
+  pid_t pid;
+  struct handler_list * prepare, * child, * parent;
 
-  pid = ARCH_FORK ();
+  __pthread_mutex_lock(&pthread_atfork_lock);
+  prepare = pthread_atfork_prepare;
+  child = pthread_atfork_child;
+  parent = pthread_atfork_parent;
+  pthread_call_handlers(prepare);
 
+  __pthread_once_fork_prepare();
+#ifdef __MALLOC__
+  __pthread_mutex_lock(&__malloc_sbrk_lock);
+  __pthread_mutex_lock(&__malloc_heap_lock);
+#ifdef __UCLIBC_UCLINUX_BROKEN_MUNMAP__
+  __pthread_mutex_lock(&__malloc_mmb_heap_lock);
+#endif
+#elif defined(__MALLOC_STANDARD__) || defined(__MALLOC_SIMPLE__)
+  __pthread_mutex_lock(&__malloc_lock);
+#endif
+
+  pid = __libc_fork();
   if (pid == 0) {
+#if defined(__MALLOC_STANDARD__) || defined(__MALLOC_SIMPLE__)
+    __libc_lock_init_recursive(__malloc_lock);
+#elif defined(__MALLOC__)
+#ifdef __UCLIBC_UCLINUX_BROKEN_MUNMAP__
+    __libc_lock_init_adaptive(__malloc_mmb_heap_lock);
+#endif
+    __libc_lock_init_adaptive(__malloc_heap_lock);
+    __libc_lock_init(__malloc_sbrk_lock);
+#endif
+    __libc_lock_init_adaptive(pthread_atfork_lock);
     __pthread_reset_main_thread();
-
     __fresetlockfiles();
     __pthread_once_fork_child();
-
-    /* Run the handlers registered for the child.  */
-    list_for_each (runp, &b->child_list)
-      {
-	struct fork_handler *curp;
-	curp = list_entry (runp, struct fork_handler, list);
-	curp->handler ();
-      }
-
-    __libc_lock_init (b->lock);
+    pthread_call_handlers(child);
   } else {
-    __funlockfilelist();
+#if defined(__MALLOC_STANDARD__) || defined(__MALLOC_SIMPLE__)
+    __pthread_mutex_unlock(&__malloc_lock);
+#elif defined(__MALLOC__)
+#ifdef __UCLIBC_UCLINUX_BROKEN_MUNMAP__
+    __pthread_mutex_unlock(&__malloc_mmb_heap_lock);
+#endif
+    __pthread_mutex_unlock(&__malloc_heap_lock);
+    __pthread_mutex_unlock(&__malloc_sbrk_lock);
+#endif
+    __pthread_mutex_unlock(&pthread_atfork_lock);
     __pthread_once_fork_parent();
-
-    /* Run the handlers registered for the parent.  */
-    list_for_each (runp, &b->parent_list)
-      {
-	struct fork_handler *curp;
-	curp = list_entry (runp, struct fork_handler, list);
-	curp->handler ();
-      }
-
-    __libc_lock_unlock (b->lock);
+    pthread_call_handlers(parent);
   }
-
   return pid;
 }
+strong_alias(__fork,fork)
+strong_alias(__fork,vfork)
 
-/* psm: have no idea why these are here, sjhill? */
-#if 0 /*def SHARED*/
-pid_t __fork (void)
-{
-  return __libc_fork ();
-}
-weak_alias (__fork, fork)
+#else
 
-pid_t __vfork(void)
+/* We can't support pthread_atfork without MMU, since we don't have
+   fork(), and we can't offer the correct semantics for vfork().  */
+int pthread_atfork(void (*prepare)(void),
+		   void (*parent)(void),
+		   void (*child)(void))
 {
-  return __libc_fork ();
+  /* ENOMEM is probably pushing it a little bit.
+     Take it as `no *virtual* memory' :-)  */
+  errno = ENOMEM;
+  return -1;
 }
-weak_alias (__vfork, vfork)
+
 #endif
diff --git a/libpthread/linuxthreads/pthandles.c b/libpthread/linuxthreads/pthandles.c
deleted file mode 100644
index acc47e28d..000000000
--- a/libpthread/linuxthreads/pthandles.c
+++ /dev/null
@@ -1,5 +0,0 @@
-#include "pthread.h"
-#include "internals.h"
-
-/* Array of active threads. Entry 0 is reserved for the initial thread. */
-struct pthread_handle_struct __pthread_handles[PTHREAD_THREADS_MAX];
diff --git a/libpthread/linuxthreads/pthread.c b/libpthread/linuxthreads/pthread.c
index 5dccd939f..00197b158 100644
--- a/libpthread/linuxthreads/pthread.c
+++ b/libpthread/linuxthreads/pthread.c
@@ -1,4 +1,3 @@
-
 /* Linuxthreads - a simple clone()-based implementation of Posix        */
 /* threads for Linux.                                                   */
 /* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
@@ -16,6 +15,7 @@
 /* Thread creation, initialization, and basic low-level routines */
 
 #include <errno.h>
+#include <netdb.h>	/* for h_errno */
 #include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -24,134 +24,176 @@
 #include <fcntl.h>
 #include <sys/wait.h>
 #include <sys/resource.h>
-#include <sys/time.h>
 #include "pthread.h"
 #include "internals.h"
 #include "spinlock.h"
 #include "restart.h"
-#include "smp.h"
-#include <not-cancel.h>
+#include "debug.h"      /* added to linuxthreads -StS */
 
-/* Sanity check.  */
-#if !defined __SIGRTMIN || (__SIGRTMAX - __SIGRTMIN) < 3
-# error "This must not happen"
-#endif
 
-#ifndef __UCLIBC_HAS_TLS__
+/* Mods for uClibc: Some includes */
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+
+libpthread_hidden_proto(waitpid)
+libpthread_hidden_proto(raise)
+
 /* These variables are used by the setup code.  */
 extern int _errno;
 extern int _h_errno;
 
-# if defined __UCLIBC_HAS_RESOLVER_SUPPORT__
-/* We need the global/static resolver state here.  */
-# include <resolv.h>
-# undef _res
-extern struct __res_state *__resp;
-# endif
-#endif
-
-#ifdef __UCLIBC_HAS_TLS__
-
-/* We need only a few variables.  */
-#define manager_thread __pthread_manager_threadp
-pthread_descr __pthread_manager_threadp attribute_hidden;
-
-#else
 
 /* Descriptor of the initial thread */
 
 struct _pthread_descr_struct __pthread_initial_thread = {
-  .p_header.data.self = &__pthread_initial_thread,
-  .p_nextlive = &__pthread_initial_thread,
-  .p_prevlive = &__pthread_initial_thread,
-  .p_tid = PTHREAD_THREADS_MAX,
-  .p_lock = &__pthread_handles[0].h_lock,
-  .p_start_args = PTHREAD_START_ARGS_INITIALIZER(NULL),
-#ifndef __UCLIBC_HAS_TLS__
-  .p_errnop = &_errno,
-  .p_h_errnop = &_h_errno,
-#endif
-  .p_userstack = 1,
-  .p_resume_count = __ATOMIC_INITIALIZER,
-  .p_alloca_cutoff = __MAX_ALLOCA_CUTOFF
+  &__pthread_initial_thread,  /* pthread_descr p_nextlive */
+  &__pthread_initial_thread,  /* pthread_descr p_prevlive */
+  NULL,                       /* pthread_descr p_nextwaiting */
+  NULL,			      /* pthread_descr p_nextlock */
+  PTHREAD_THREADS_MAX,        /* pthread_t p_tid */
+  0,                          /* int p_pid */
+  0,                          /* int p_priority */
+  &__pthread_handles[0].h_lock, /* struct _pthread_fastlock * p_lock */
+  0,                          /* int p_signal */
+  NULL,                       /* sigjmp_buf * p_signal_buf */
+  NULL,                       /* sigjmp_buf * p_cancel_buf */
+  0,                          /* char p_terminated */
+  0,                          /* char p_detached */
+  0,                          /* char p_exited */
+  NULL,                       /* void * p_retval */
+  0,                          /* int p_retval */
+  NULL,                       /* pthread_descr p_joining */
+  NULL,                       /* struct _pthread_cleanup_buffer * p_cleanup */
+  0,                          /* char p_cancelstate */
+  0,                          /* char p_canceltype */
+  0,                          /* char p_canceled */
+  &_errno,                       /* int *p_errnop */
+  0,                          /* int p_errno */
+  &_h_errno,                       /* int *p_h_errnop */
+  0,                          /* int p_h_errno */
+  NULL,                       /* char * p_in_sighandler */
+  0,                          /* char p_sigwaiting */
+  PTHREAD_START_ARGS_INITIALIZER, /* struct pthread_start_args p_start_args */
+  {NULL},                     /* void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE] */
+  {NULL},                     /* void * p_libc_specific[_LIBC_TSD_KEY_N] */
+  0,                          /* int p_userstack */
+  NULL,                       /* void * p_guardaddr */
+  0,                          /* size_t p_guardsize */
+  &__pthread_initial_thread,  /* pthread_descr p_self */
+  0,                          /* Always index 0 */
+  0,                          /* int p_report_events */
+  {{{0, }}, 0, NULL},         /* td_eventbuf_t p_eventbuf */
+  __ATOMIC_INITIALIZER,         /* struct pthread_atomic p_resume_count */
+  0,                          /* char p_woken_by_cancel */
+  0,                          /* char p_condvar_avail */
+  0,                          /* char p_sem_avail */
+  NULL,                       /* struct pthread_extricate_if *p_extricate */
+  NULL,	                      /* pthread_readlock_info *p_readlock_list; */
+  NULL,                       /* pthread_readlock_info *p_readlock_free; */
+  0                           /* int p_untracked_readlock_count; */
+#ifdef __UCLIBC_HAS_XLOCALE__
+  ,
+  &__global_locale_data,      /* __locale_t locale; */
+#endif /* __UCLIBC_HAS_XLOCALE__ */
 };
 
 /* Descriptor of the manager thread; none of this is used but the error
    variables, the p_pid and p_priority fields,
    and the address for identification.  */
-
 #define manager_thread (&__pthread_manager_thread)
 struct _pthread_descr_struct __pthread_manager_thread = {
-  .p_header.data.self = &__pthread_manager_thread,
-  .p_header.data.multiple_threads = 1,
-  .p_lock = &__pthread_handles[1].h_lock,
-  .p_start_args = PTHREAD_START_ARGS_INITIALIZER(__pthread_manager),
-#ifndef __UCLIBC_HAS_TLS__
-  .p_errnop = &__pthread_manager_thread.p_errno,
-#endif
-  .p_nr = 1,
-  .p_resume_count = __ATOMIC_INITIALIZER,
-  .p_alloca_cutoff = PTHREAD_STACK_MIN / 4
+  NULL,                       /* pthread_descr p_nextlive */
+  NULL,                       /* pthread_descr p_prevlive */
+  NULL,                       /* pthread_descr p_nextwaiting */
+  NULL,			      /* pthread_descr p_nextlock */
+  0,                          /* int p_tid */
+  0,                          /* int p_pid */
+  0,                          /* int p_priority */
+  &__pthread_handles[1].h_lock, /* struct _pthread_fastlock * p_lock */
+  0,                          /* int p_signal */
+  NULL,                       /* sigjmp_buf * p_signal_buf */
+  NULL,                       /* sigjmp_buf * p_cancel_buf */
+  0,                          /* char p_terminated */
+  0,                          /* char p_detached */
+  0,                          /* char p_exited */
+  NULL,                       /* void * p_retval */
+  0,                          /* int p_retval */
+  NULL,                       /* pthread_descr p_joining */
+  NULL,                       /* struct _pthread_cleanup_buffer * p_cleanup */
+  0,                          /* char p_cancelstate */
+  0,                          /* char p_canceltype */
+  0,                          /* char p_canceled */
+  &__pthread_manager_thread.p_errno, /* int *p_errnop */
+  0,                          /* int p_errno */
+  NULL,                       /* int *p_h_errnop */
+  0,                          /* int p_h_errno */
+  NULL,                       /* char * p_in_sighandler */
+  0,                          /* char p_sigwaiting */
+  PTHREAD_START_ARGS_INITIALIZER, /* struct pthread_start_args p_start_args */
+  {NULL},                     /* void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE] */
+  {NULL},                     /* void * p_libc_specific[_LIBC_TSD_KEY_N] */
+  0,                          /* int p_userstack */
+  NULL,                       /* void * p_guardaddr */
+  0,                          /* size_t p_guardsize */
+  &__pthread_manager_thread,  /* pthread_descr p_self */
+  1,                          /* Always index 1 */
+  0,                          /* int p_report_events */
+  {{{0, }}, 0, NULL},         /* td_eventbuf_t p_eventbuf */
+  __ATOMIC_INITIALIZER,         /* struct pthread_atomic p_resume_count */
+  0,                          /* char p_woken_by_cancel */
+  0,                          /* char p_condvar_avail */
+  0,                          /* char p_sem_avail */
+  NULL,                       /* struct pthread_extricate_if *p_extricate */
+  NULL,	                      /* pthread_readlock_info *p_readlock_list; */
+  NULL,                       /* pthread_readlock_info *p_readlock_free; */
+  0                           /* int p_untracked_readlock_count; */
+#ifdef __UCLIBC_HAS_XLOCALE__
+  ,
+  &__global_locale_data,      /* __locale_t locale; */
+#endif /* __UCLIBC_HAS_XLOCALE__ */
 };
-#endif
 
 /* Pointer to the main thread (the father of the thread manager thread) */
 /* Originally, this is the initial thread, but this changes after fork() */
 
-#ifdef __UCLIBC_HAS_TLS__
-pthread_descr __pthread_main_thread;
-#else
 pthread_descr __pthread_main_thread = &__pthread_initial_thread;
-#endif
 
 /* Limit between the stack of the initial thread (above) and the
    stacks of other threads (below). Aligned on a STACK_SIZE boundary. */
 
-char *__pthread_initial_thread_bos;
+char *__pthread_initial_thread_bos = NULL;
+
+#ifndef __ARCH_USE_MMU__
+/* See nommu notes in internals.h and pthread_initialize() below. */
+char *__pthread_initial_thread_tos = NULL;
+char *__pthread_initial_thread_mid = NULL;
+#endif /* __ARCH_USE_MMU__ */
 
 /* File descriptor for sending requests to the thread manager. */
 /* Initially -1, meaning that the thread manager is not running. */
 
 int __pthread_manager_request = -1;
 
-int __pthread_multiple_threads attribute_hidden;
-
 /* Other end of the pipe for sending requests to the thread manager. */
 
 int __pthread_manager_reader;
 
 /* Limits of the thread manager stack */
 
-char *__pthread_manager_thread_bos;
-char *__pthread_manager_thread_tos;
+char *__pthread_manager_thread_bos = NULL;
+char *__pthread_manager_thread_tos = NULL;
 
 /* For process-wide exit() */
 
-int __pthread_exit_requested;
-int __pthread_exit_code;
-
-/* Maximum stack size.  */
-size_t __pthread_max_stacksize;
-
-/* Nozero if the machine has more than one processor.  */
-int __pthread_smp_kernel;
-
-
-#if !__ASSUME_REALTIME_SIGNALS
-/* Pointers that select new or old suspend/resume functions
-   based on availability of rt signals. */
-
-void (*__pthread_restart)(pthread_descr) = __pthread_restart_old;
-void (*__pthread_suspend)(pthread_descr) = __pthread_suspend_old;
-int (*__pthread_timedsuspend)(pthread_descr, const struct timespec *) = __pthread_timedsuspend_old;
-#endif	/* __ASSUME_REALTIME_SIGNALS */
+int __pthread_exit_requested = 0;
+int __pthread_exit_code = 0;
 
 /* Communicate relevant LinuxThreads constants to gdb */
 
 const int __pthread_threads_max = PTHREAD_THREADS_MAX;
 const int __pthread_sizeof_handle = sizeof(struct pthread_handle_struct);
-const int __pthread_offsetof_descr = offsetof(struct pthread_handle_struct,
-                                              h_descr);
+const int __pthread_offsetof_descr = offsetof(struct pthread_handle_struct, h_descr);
 const int __pthread_offsetof_pid = offsetof(struct _pthread_descr_struct,
                                             p_pid);
 const int __linuxthreads_pthread_sizeof_descr
@@ -162,53 +204,72 @@ const int __linuxthreads_initial_report_events;
 const char __linuxthreads_version[] = VERSION;
 
 /* Forward declarations */
-
 static void pthread_onexit_process(int retcode, void *arg);
-#ifndef HAVE_Z_NODELETE
-static void pthread_atexit_process(void *arg, int retcode);
-static void pthread_atexit_retcode(void *arg, int retcode);
-#endif
 static void pthread_handle_sigcancel(int sig);
 static void pthread_handle_sigrestart(int sig);
 static void pthread_handle_sigdebug(int sig);
+int __pthread_timedsuspend_new(pthread_descr self, const struct timespec *abstime);
 
 /* Signal numbers used for the communication.
    In these variables we keep track of the used variables.  If the
    platform does not support any real-time signals we will define the
    values to some unreasonable value which will signal failing of all
    the functions below.  */
+#ifndef __NR_rt_sigaction
+static int current_rtmin = -1;
+static int current_rtmax = -1;
+int __pthread_sig_restart = SIGUSR1;
+int __pthread_sig_cancel = SIGUSR2;
+int __pthread_sig_debug;
+#else
+
+#if __SIGRTMAX - __SIGRTMIN >= 3
+static int current_rtmin = __SIGRTMIN + 3;
+static int current_rtmax = __SIGRTMAX;
 int __pthread_sig_restart = __SIGRTMIN;
 int __pthread_sig_cancel = __SIGRTMIN + 1;
 int __pthread_sig_debug = __SIGRTMIN + 2;
+void (*__pthread_restart)(pthread_descr) = __pthread_restart_new;
+void (*__pthread_suspend)(pthread_descr) = __pthread_wait_for_restart_signal;
+int (*__pthread_timedsuspend)(pthread_descr, const struct timespec *) = __pthread_timedsuspend_new;
+#else
+static int current_rtmin = __SIGRTMIN;
+static int current_rtmax = __SIGRTMAX;
+int __pthread_sig_restart = SIGUSR1;
+int __pthread_sig_cancel = SIGUSR2;
+int __pthread_sig_debug;
+void (*__pthread_restart)(pthread_descr) = __pthread_restart_old;
+void (*__pthread_suspend)(pthread_descr) = __pthread_suspend_old;
+int (*__pthread_timedsuspend)(pthread_descr, const struct timespec *) = __pthread_timedsuspend_old;
 
-extern int __libc_current_sigrtmin_private (void);
-
-#if !__ASSUME_REALTIME_SIGNALS
-static int rtsigs_initialized;
+#endif
 
-static void
-init_rtsigs (void)
+/* Return number of available real-time signal with highest priority.  */
+int __libc_current_sigrtmin (void)
 {
-  if (rtsigs_initialized)
-    return;
+    return current_rtmin;
+}
 
-  if (__libc_current_sigrtmin_private () == -1)
-    {
-      __pthread_sig_restart = SIGUSR1;
-      __pthread_sig_cancel = SIGUSR2;
-      __pthread_sig_debug = 0;
-    }
-  else
-    {
-      __pthread_restart = __pthread_restart_new;
-      __pthread_suspend = __pthread_wait_for_restart_signal;
-      __pthread_timedsuspend = __pthread_timedsuspend_new;
-    }
+/* Return number of available real-time signal with lowest priority.  */
+int __libc_current_sigrtmax (void)
+{
+    return current_rtmax;
+}
 
-  rtsigs_initialized = 1;
+#if 0
+/* Allocate real-time signal with highest/lowest available
+   priority.  Please note that we don't use a lock since we assume
+   this function to be called at program start.  */
+int __libc_allocate_rtsig (int high);
+int __libc_allocate_rtsig (int high)
+{
+    if (current_rtmin == -1 || current_rtmin > current_rtmax)
+	/* We don't have anymore signal available.  */
+	return -1;
+    return high ? current_rtmin++ : current_rtmax--;
 }
 #endif
-
+#endif
 
 /* Initialize the pthread library.
    Initialization is split in two functions:
@@ -219,14 +280,40 @@ init_rtsigs (void)
 
 static void pthread_initialize(void) __attribute__((constructor));
 
-#ifndef HAVE_Z_NODELETE
-extern void *__dso_handle __attribute__ ((weak));
-#endif
-
-
-#if defined __UCLIBC_HAS_TLS__ && !defined SHARED
-extern void __libc_setup_tls (size_t tcbsize, size_t tcbalign);
-#endif
+libpthread_hidden_proto(pthread_attr_destroy)
+libpthread_hidden_proto(pthread_attr_init)
+libpthread_hidden_proto(pthread_attr_getdetachstate)
+libpthread_hidden_proto(pthread_attr_setdetachstate)
+libpthread_hidden_proto(pthread_attr_getinheritsched)
+libpthread_hidden_proto(pthread_attr_setinheritsched)
+libpthread_hidden_proto(pthread_attr_setschedparam)
+libpthread_hidden_proto(pthread_attr_getschedparam)
+libpthread_hidden_proto(pthread_attr_getschedpolicy)
+libpthread_hidden_proto(pthread_attr_setschedpolicy)
+libpthread_hidden_proto(pthread_attr_getscope)
+libpthread_hidden_proto(pthread_attr_setscope)
+
+libpthread_hidden_proto(pthread_exit)
+
+libpthread_hidden_proto(pthread_equal)
+libpthread_hidden_proto(pthread_self)
+libpthread_hidden_proto(pthread_getschedparam)
+libpthread_hidden_proto(pthread_setschedparam)
+
+libpthread_hidden_proto(pthread_setcancelstate)
+libpthread_hidden_proto(pthread_setcanceltype)
+libpthread_hidden_proto(_pthread_cleanup_push_defer)
+libpthread_hidden_proto(_pthread_cleanup_pop_restore)
+
+libpthread_hidden_proto(pthread_cond_broadcast)
+libpthread_hidden_proto(pthread_cond_destroy)
+libpthread_hidden_proto(pthread_cond_init)
+libpthread_hidden_proto(pthread_cond_signal)
+libpthread_hidden_proto(pthread_cond_wait)
+libpthread_hidden_proto(pthread_cond_timedwait)
+
+libpthread_hidden_proto(pthread_condattr_destroy)
+libpthread_hidden_proto(pthread_condattr_init)
 
 struct pthread_functions __pthread_functions =
   {
@@ -235,49 +322,53 @@ struct pthread_functions __pthread_functions =
     .ptr_pthread_internal_tsd_get = __pthread_internal_tsd_get,
     .ptr_pthread_internal_tsd_address = __pthread_internal_tsd_address,
 #endif
+/*
     .ptr_pthread_fork = __pthread_fork,
-    .ptr_pthread_attr_destroy = __pthread_attr_destroy,
-    .ptr_pthread_attr_init = __pthread_attr_init,
-    .ptr_pthread_attr_getdetachstate = __pthread_attr_getdetachstate,
-    .ptr_pthread_attr_setdetachstate = __pthread_attr_setdetachstate,
-    .ptr_pthread_attr_getinheritsched = __pthread_attr_getinheritsched,
-    .ptr_pthread_attr_setinheritsched = __pthread_attr_setinheritsched,
-    .ptr_pthread_attr_getschedparam = __pthread_attr_getschedparam,
-    .ptr_pthread_attr_setschedparam = __pthread_attr_setschedparam,
-    .ptr_pthread_attr_getschedpolicy = __pthread_attr_getschedpolicy,
-    .ptr_pthread_attr_setschedpolicy = __pthread_attr_setschedpolicy,
-    .ptr_pthread_attr_getscope = __pthread_attr_getscope,
-    .ptr_pthread_attr_setscope = __pthread_attr_setscope,
-    .ptr_pthread_condattr_destroy = __pthread_condattr_destroy,
-    .ptr_pthread_condattr_init = __pthread_condattr_init,
-    .ptr_pthread_cond_broadcast = __pthread_cond_broadcast,
-    .ptr_pthread_cond_destroy = __pthread_cond_destroy,
-    .ptr_pthread_cond_init = __pthread_cond_init,
-    .ptr_pthread_cond_signal = __pthread_cond_signal,
-    .ptr_pthread_cond_wait = __pthread_cond_wait,
-    .ptr_pthread_cond_timedwait = __pthread_cond_timedwait,
-    .ptr_pthread_equal = __pthread_equal,
-    .ptr___pthread_exit = __pthread_exit,
-    .ptr_pthread_getschedparam = __pthread_getschedparam,
-    .ptr_pthread_setschedparam = __pthread_setschedparam,
+*/
+    .ptr_pthread_attr_destroy = pthread_attr_destroy,
+    .ptr_pthread_attr_init = pthread_attr_init,
+    .ptr_pthread_attr_getdetachstate = pthread_attr_getdetachstate,
+    .ptr_pthread_attr_setdetachstate = pthread_attr_setdetachstate,
+    .ptr_pthread_attr_getinheritsched = pthread_attr_getinheritsched,
+    .ptr_pthread_attr_setinheritsched = pthread_attr_setinheritsched,
+    .ptr_pthread_attr_getschedparam = pthread_attr_getschedparam,
+    .ptr_pthread_attr_setschedparam = pthread_attr_setschedparam,
+    .ptr_pthread_attr_getschedpolicy = pthread_attr_getschedpolicy,
+    .ptr_pthread_attr_setschedpolicy = pthread_attr_setschedpolicy,
+    .ptr_pthread_attr_getscope = pthread_attr_getscope,
+    .ptr_pthread_attr_setscope = pthread_attr_setscope,
+    .ptr_pthread_condattr_destroy = pthread_condattr_destroy,
+    .ptr_pthread_condattr_init = pthread_condattr_init,
+    .ptr_pthread_cond_broadcast = pthread_cond_broadcast,
+    .ptr_pthread_cond_destroy = pthread_cond_destroy,
+    .ptr_pthread_cond_init = pthread_cond_init,
+    .ptr_pthread_cond_signal = pthread_cond_signal,
+    .ptr_pthread_cond_wait = pthread_cond_wait,
+    .ptr_pthread_cond_timedwait = pthread_cond_timedwait,
+    .ptr_pthread_equal = pthread_equal,
+    .ptr___pthread_exit = pthread_exit,
+    .ptr_pthread_getschedparam = pthread_getschedparam,
+    .ptr_pthread_setschedparam = pthread_setschedparam,
     .ptr_pthread_mutex_destroy = __pthread_mutex_destroy,
     .ptr_pthread_mutex_init = __pthread_mutex_init,
     .ptr_pthread_mutex_lock = __pthread_mutex_lock,
     .ptr_pthread_mutex_trylock = __pthread_mutex_trylock,
     .ptr_pthread_mutex_unlock = __pthread_mutex_unlock,
-    .ptr_pthread_self = __pthread_self,
-    .ptr_pthread_setcancelstate = __pthread_setcancelstate,
-    .ptr_pthread_setcanceltype = __pthread_setcanceltype,
-    .ptr_pthread_do_exit = __pthread_do_exit,
-    .ptr_pthread_thread_self = __pthread_thread_self,
-    .ptr_pthread_cleanup_upto = __pthread_cleanup_upto,
-    .ptr_pthread_sigaction = __pthread_sigaction,
-    .ptr_pthread_sigwait = __pthread_sigwait,
-    .ptr_pthread_raise = __pthread_raise,
+    .ptr_pthread_self = pthread_self,
+    .ptr_pthread_setcancelstate = pthread_setcancelstate,
+    .ptr_pthread_setcanceltype = pthread_setcanceltype,
+/*
+    .ptr_pthread_do_exit = pthread_do_exit,
+    .ptr_pthread_thread_self = pthread_thread_self,
+    .ptr_pthread_cleanup_upto = pthread_cleanup_upto,
+    .ptr_pthread_sigaction = pthread_sigaction,
+    .ptr_pthread_sigwait = pthread_sigwait,
+    .ptr_pthread_raise = pthread_raise,
     .ptr__pthread_cleanup_push = _pthread_cleanup_push,
-    .ptr__pthread_cleanup_push_defer = _pthread_cleanup_push_defer,
     .ptr__pthread_cleanup_pop = _pthread_cleanup_pop,
-    .ptr__pthread_cleanup_pop_restore = _pthread_cleanup_pop_restore,
+*/
+    .ptr__pthread_cleanup_push_defer = __pthread_cleanup_push_defer,
+    .ptr__pthread_cleanup_pop_restore = __pthread_cleanup_pop_restore
   };
 #ifdef SHARED
 # define ptr_pthread_functions &__pthread_functions
@@ -287,224 +378,28 @@ struct pthread_functions __pthread_functions =
 
 static int *__libc_multiple_threads_ptr;
 
-/* Do some minimal initialization which has to be done during the
-   startup of the C library.  */
-void
-__pthread_initialize_minimal(void)
+ /* Do some minimal initialization which has to be done during the
+    startup of the C library.  */
+void __pthread_initialize_minimal(void)
 {
-#ifdef __UCLIBC_HAS_TLS__
-  pthread_descr self;
-
-  /* First of all init __pthread_handles[0] and [1] if needed.  */
-# if __LT_SPINLOCK_INIT != 0
-  __pthread_handles[0].h_lock = __LOCK_INITIALIZER;
-  __pthread_handles[1].h_lock = __LOCK_INITIALIZER;
-# endif
-# ifndef SHARED
-  /* Unlike in the dynamically linked case the dynamic linker has not
-     taken care of initializing the TLS data structures.  */
-  __libc_setup_tls (TLS_TCB_SIZE, TLS_TCB_ALIGN);
-# elif !defined __UCLIBC_HAS_TLS__
-  if (__builtin_expect (GL(dl_tls_dtv_slotinfo_list) == NULL, 0))
-    {
-      tcbhead_t *tcbp;
-
-      /* There is no actual TLS being used, so the thread register
-	 was not initialized in the dynamic linker.  */
-
-      /* We need to install special hooks so that the malloc and memalign
-	 calls in _dl_tls_setup and _dl_allocate_tls won't cause full
-	 malloc initialization that will try to set up its thread state.  */
-
-      extern void __libc_malloc_pthread_startup (bool first_time);
-      __libc_malloc_pthread_startup (true);
-
-      if (__builtin_expect (_dl_tls_setup (), 0)
-	  || __builtin_expect ((tcbp = _dl_allocate_tls (NULL)) == NULL, 0))
-	{
-	  static const char msg[] = "\
-cannot allocate TLS data structures for initial thread\n";
-	  TEMP_FAILURE_RETRY (write_not_cancel (STDERR_FILENO,
-						msg, sizeof msg - 1));
-	  abort ();
-	}
-      const char *lossage = TLS_INIT_TP (tcbp, 0);
-      if (__builtin_expect (lossage != NULL, 0))
-	{
-	  static const char msg[] = "cannot set up thread-local storage: ";
-	  const char nl = '\n';
-	  TEMP_FAILURE_RETRY (write_not_cancel (STDERR_FILENO,
-						msg, sizeof msg - 1));
-	  TEMP_FAILURE_RETRY (write_not_cancel (STDERR_FILENO,
-						lossage, strlen (lossage)));
-	  TEMP_FAILURE_RETRY (write_not_cancel (STDERR_FILENO, &nl, 1));
-	}
-
-      /* Though it was allocated with libc's malloc, that was done without
-	 the user's __malloc_hook installed.  A later realloc that uses
-	 the hooks might not work with that block from the plain malloc.
-	 So we record this block as unfreeable just as the dynamic linker
-	 does when it allocates the DTV before the libc malloc exists.  */
-      GL(dl_initial_dtv) = GET_DTV (tcbp);
-
-      __libc_malloc_pthread_startup (false);
-    }
-# endif
-
-  self = THREAD_SELF;
-
-  /* The memory for the thread descriptor was allocated elsewhere as
-     part of the TLS allocation.  We have to initialize the data
-     structure by hand.  This initialization must mirror the struct
-     definition above.  */
-  self->p_nextlive = self->p_prevlive = self;
-  self->p_tid = PTHREAD_THREADS_MAX;
-  self->p_lock = &__pthread_handles[0].h_lock;
-# ifndef __UCLIBC_HAS_TLS__
-  self->p_errnop = &_errno;
-  self->p_h_errnop = &_h_errno;
-# endif
-  /* self->p_start_args need not be initialized, it's all zero.  */
-  self->p_userstack = 1;
-# if __LT_SPINLOCK_INIT != 0
-  self->p_resume_count = (struct pthread_atomic) __ATOMIC_INITIALIZER;
-# endif
-  self->p_alloca_cutoff = __MAX_ALLOCA_CUTOFF;
-
-  /* Another variable which points to the thread descriptor.  */
-  __pthread_main_thread = self;
-
-  /* And fill in the pointer the the thread __pthread_handles array.  */
-  __pthread_handles[0].h_descr = self;
-
-#else  /* __UCLIBC_HAS_TLS__ */
-
-  /* First of all init __pthread_handles[0] and [1].  */
-# if __LT_SPINLOCK_INIT != 0
-  __pthread_handles[0].h_lock = __LOCK_INITIALIZER;
-  __pthread_handles[1].h_lock = __LOCK_INITIALIZER;
-# endif
-  __pthread_handles[0].h_descr = &__pthread_initial_thread;
-  __pthread_handles[1].h_descr = &__pthread_manager_thread;
-
-  /* If we have special thread_self processing, initialize that for the
-     main thread now.  */
-# ifdef INIT_THREAD_SELF
-  INIT_THREAD_SELF(&__pthread_initial_thread, 0);
-# endif
-#endif
-
-#if HP_TIMING_AVAIL
-# ifdef __UCLIBC_HAS_TLS__
-  self->p_cpuclock_offset = GL(dl_cpuclock_offset);
-# else
-  __pthread_initial_thread.p_cpuclock_offset = GL(dl_cpuclock_offset);
-# endif
+    /* If we have special thread_self processing, initialize
+     * that for the main thread now.  */
+#ifdef INIT_THREAD_SELF
+    INIT_THREAD_SELF(&__pthread_initial_thread, 0);
 #endif
 
-  __libc_multiple_threads_ptr = __libc_pthread_init (ptr_pthread_functions);
+    __libc_multiple_threads_ptr = __libc_pthread_init (ptr_pthread_functions);
 }
 
 
-void
-__pthread_init_max_stacksize(void)
-{
-  struct rlimit limit;
-  size_t max_stack;
-
-  getrlimit(RLIMIT_STACK, &limit);
-#ifdef FLOATING_STACKS
-  if (limit.rlim_cur == RLIM_INFINITY)
-    limit.rlim_cur = ARCH_STACK_MAX_SIZE;
-# ifdef NEED_SEPARATE_REGISTER_STACK
-  max_stack = limit.rlim_cur / 2;
-# else
-  max_stack = limit.rlim_cur;
-# endif
-#else
-  /* Play with the stack size limit to make sure that no stack ever grows
-     beyond STACK_SIZE minus one page (to act as a guard page). */
-# ifdef NEED_SEPARATE_REGISTER_STACK
-  /* STACK_SIZE bytes hold both the main stack and register backing
-     store. The rlimit value applies to each individually.  */
-  max_stack = STACK_SIZE/2 - __getpagesize ();
-# else
-  max_stack = STACK_SIZE - __getpagesize();
-# endif
-  if (limit.rlim_cur > max_stack) {
-    limit.rlim_cur = max_stack;
-    setrlimit(RLIMIT_STACK, &limit);
-  }
-#endif
-  __pthread_max_stacksize = max_stack;
-  if (max_stack / 4 < __MAX_ALLOCA_CUTOFF)
-    {
-#ifdef __UCLIBC_HAS_TLS__
-      pthread_descr self = THREAD_SELF;
-      self->p_alloca_cutoff = max_stack / 4;
-#else
-      __pthread_initial_thread.p_alloca_cutoff = max_stack / 4;
-#endif
-    }
-}
-
-#if defined SHARED && defined __UCLIBC_HAS_TLS__
-# ifdef __UCLIBC_HAS_TLS__
-/* When using __thread for this, we do it in libc so as not
-   to give libpthread its own TLS segment just for this.  */
-extern void **__libc_dl_error_tsd (void) __attribute__ ((const));
-# else
-static void ** __attribute__ ((const))
-__libc_dl_error_tsd (void)
-{
-  return &thread_self ()->p_libc_specific[_LIBC_TSD_KEY_DL_ERROR];
-}
-# endif
-#endif
-
-#ifdef __UCLIBC_HAS_TLS__
-static __inline__ void __attribute__((always_inline))
-init_one_static_tls (pthread_descr descr, struct link_map *map)
-{
-# if defined(TLS_TCB_AT_TP)
-  dtv_t *dtv = GET_DTV (descr);
-  void *dest = (char *) descr - map->l_tls_offset;
-# elif defined(TLS_DTV_AT_TP)
-  dtv_t *dtv = GET_DTV ((pthread_descr) ((char *) descr + TLS_PRE_TCB_SIZE));
-  void *dest = (char *) descr + map->l_tls_offset + TLS_PRE_TCB_SIZE;
-# else
-#  error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined"
-# endif
-
-  /* Fill in the DTV slot so that a later LD/GD access will find it.  */
-  dtv[map->l_tls_modid].pointer.val = dest;
-  dtv[map->l_tls_modid].pointer.is_static = true;
-
-  /* Initialize the memory.  */
-  memset (mempcpy (dest, map->l_tls_initimage, map->l_tls_initimage_size),
-	  '\0', map->l_tls_blocksize - map->l_tls_initimage_size);
-}
-
-static void
-__pthread_init_static_tls (struct link_map *map)
-{
-  size_t i;
-
-  for (i = 0; i < PTHREAD_THREADS_MAX; ++i)
-    if (__pthread_handles[i].h_descr != NULL && i != 1)
-      {
-        __pthread_lock (&__pthread_handles[i].h_lock, NULL);
-	if (__pthread_handles[i].h_descr != NULL)
-	  init_one_static_tls (__pthread_handles[i].h_descr, map);
-        __pthread_unlock (&__pthread_handles[i].h_lock);
-      }
-}
-#endif
-
 static void pthread_initialize(void)
 {
   struct sigaction sa;
   sigset_t mask;
+#ifdef __ARCH_USE_MMU__
+  struct rlimit limit;
+  rlim_t max_stack;
+#endif
 
   /* If already done (e.g. by a constructor called earlier!), bail out */
   if (__pthread_initial_thread_bos != NULL) return;
@@ -512,44 +407,70 @@ static void pthread_initialize(void)
   /* Test if compare-and-swap is available */
   __pthread_has_cas = compare_and_swap_is_available();
 #endif
-#ifdef FLOATING_STACKS
-  /* We don't need to know the bottom of the stack.  Give the pointer some
-     value to signal that initialization happened.  */
-  __pthread_initial_thread_bos = (void *) -1l;
-#else
-  /* Determine stack size limits .  */
-  __pthread_init_max_stacksize ();
-# ifdef _STACK_GROWS_UP
-  /* The initial thread already has all the stack it needs */
-  __pthread_initial_thread_bos = (char *)
-    ((long)CURRENT_STACK_FRAME &~ (STACK_SIZE - 1));
-# else
   /* For the initial stack, reserve at least STACK_SIZE bytes of stack
      below the current stack address, and align that on a
      STACK_SIZE boundary. */
   __pthread_initial_thread_bos =
     (char *)(((long)CURRENT_STACK_FRAME - 2 * STACK_SIZE) & ~(STACK_SIZE - 1));
-# endif
-#endif
-#ifdef __UCLIBC_HAS_TLS__
-  /* Update the descriptor for the initial thread. */
-  THREAD_SETMEM (((pthread_descr) NULL), p_pid, __getpid());
-# if defined __UCLIBC_HAS_RESOLVER_SUPPORT__
-  /* Likewise for the resolver state _res.  */
-  THREAD_SETMEM (((pthread_descr) NULL), p_resp, __resp);
-# endif
-#else
   /* Update the descriptor for the initial thread. */
-  __pthread_initial_thread.p_pid = __getpid();
-# if defined __UCLIBC_HAS_RESOLVER_SUPPORT__
-  /* Likewise for the resolver state _res.  */
-  __pthread_initial_thread.p_resp = __resp;
-# endif
-#endif
-#if !__ASSUME_REALTIME_SIGNALS
-  /* Initialize real-time signals. */
-  init_rtsigs ();
+  __pthread_initial_thread.p_pid = getpid();
+  /* If we have special thread_self processing, initialize that for the
+     main thread now.  */
+#ifdef INIT_THREAD_SELF
+  INIT_THREAD_SELF(&__pthread_initial_thread, 0);
 #endif
+  /* The errno/h_errno variable of the main thread are the global ones.  */
+  __pthread_initial_thread.p_errnop = &_errno;
+  __pthread_initial_thread.p_h_errnop = &_h_errno;
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+  /* The locale of the main thread is the current locale in use. */
+  __pthread_initial_thread.locale = __curlocale_var;
+#endif /* __UCLIBC_HAS_XLOCALE__ */
+
+ {			   /* uClibc-specific stdio initialization for threads. */
+	 FILE *fp;
+
+	 _stdio_user_locking = 0;	/* 2 if threading not initialized */
+	 for (fp = _stdio_openlist; fp != NULL; fp = fp->__nextopen) {
+		 if (fp->__user_locking != 1) {
+			 fp->__user_locking = 0;
+		 }
+	 }
+ }
+
+  /* Play with the stack size limit to make sure that no stack ever grows
+     beyond STACK_SIZE minus two pages (one page for the thread descriptor
+     immediately beyond, and one page to act as a guard page). */
+
+#ifdef __ARCH_USE_MMU__
+  /* We cannot allocate a huge chunk of memory to mmap all thread stacks later
+   * on a non-MMU system. Thus, we don't need the rlimit either. -StS */
+  getrlimit(RLIMIT_STACK, &limit);
+  max_stack = STACK_SIZE - 2 * getpagesize();
+  if (limit.rlim_cur > max_stack) {
+    limit.rlim_cur = max_stack;
+    setrlimit(RLIMIT_STACK, &limit);
+  }
+#else
+  /* For non-MMU, the initial thread stack can reside anywhere in memory.
+   * We don't have a way of knowing where the kernel started things -- top
+   * or bottom (well, that isn't exactly true, but the solution is fairly
+   * complex and error prone).  All we can determine here is an address
+   * that lies within that stack.  Save that address as a reference so that
+   * as other thread stacks are created, we can adjust the estimated bounds
+   * of the initial thread's stack appropriately.
+   *
+   * This checking is handled in NOMMU_INITIAL_THREAD_BOUNDS(), so see that
+   * for a few more details.
+   */
+  __pthread_initial_thread_mid = CURRENT_STACK_FRAME;
+  __pthread_initial_thread_tos = (char *) -1;
+  __pthread_initial_thread_bos = (char *) 1; /* set it non-zero so we know we have been here */
+  PDEBUG("initial thread stack bounds: bos=%p, tos=%p\n",
+	 __pthread_initial_thread_bos, __pthread_initial_thread_tos);
+#endif /* __ARCH_USE_MMU__ */
+
   /* Setup signal handlers for the initial thread.
      Since signal handlers are shared between threads, these settings
      will be inherited by all other threads. */
@@ -560,9 +481,9 @@ static void pthread_initialize(void)
   sigaddset(&sa.sa_mask, __pthread_sig_restart);
   __libc_sigaction(__pthread_sig_cancel, &sa, NULL);
   if (__pthread_sig_debug > 0) {
-    sa.sa_handler = pthread_handle_sigdebug;
-    __sigemptyset(&sa.sa_mask);
-    __libc_sigaction(__pthread_sig_debug, &sa, NULL);
+      sa.sa_handler = pthread_handle_sigdebug;
+      __sigemptyset(&sa.sa_mask);
+      __libc_sigaction(__pthread_sig_debug, &sa, NULL);
   }
   /* Initially, block __pthread_sig_restart. Will be unblocked on demand. */
   __sigemptyset(&mask);
@@ -574,48 +495,11 @@ static void pthread_initialize(void)
   sigprocmask(SIG_UNBLOCK, &mask, NULL);
   /* Register an exit function to kill all other threads. */
   /* Do it early so that user-registered atexit functions are called
-     before pthread_*exit_process. */
-#ifndef HAVE_Z_NODELETE
-  if (__builtin_expect (&__dso_handle != NULL, 1))
-    __cxa_atexit ((void (*) (void *)) pthread_atexit_process, NULL,
-		  __dso_handle);
-  else
-#endif
-    __on_exit (pthread_onexit_process, NULL);
-  /* How many processors.  */
-  __pthread_smp_kernel = is_smp_system ();
-
-#if defined SHARED && defined __UCLIBC_HAS_TLS__
-  /* Transfer the old value from the dynamic linker's internal location.  */
-  *__libc_dl_error_tsd () = *(*GL(dl_error_catch_tsd)) ();
-  GL(dl_error_catch_tsd) = &__libc_dl_error_tsd;
-
-  /* Make __rtld_lock_{,un}lock_recursive use pthread_mutex_{,un}lock,
-     keep the lock count from the ld.so implementation.  */
-  GL(dl_rtld_lock_recursive) = (void *) __pthread_mutex_lock;
-  GL(dl_rtld_unlock_recursive) = (void *) __pthread_mutex_unlock;
-  unsigned int rtld_lock_count = GL(dl_load_lock).mutex.__m_count;
-  GL(dl_load_lock).mutex.__m_count = 0;
-  while (rtld_lock_count-- > 0)
-    __pthread_mutex_lock (&GL(dl_load_lock).mutex);
-#endif
-
-#ifdef __UCLIBC_HAS_TLS__
-  GL(dl_init_static_tls) = &__pthread_init_static_tls;
-#endif
-
-  /* uClibc-specific stdio initialization for threads. */
-  {
-    FILE *fp;
-    _stdio_user_locking = 0;       /* 2 if threading not initialized */
-    for (fp = _stdio_openlist; fp != NULL; fp = fp->__nextopen) {
-      if (fp->__user_locking != 1) {
-        fp->__user_locking = 0;
-      }
-    }
-  }
+     before pthread_onexit_process. */
+  on_exit(pthread_onexit_process, NULL);
 }
 
+void __pthread_initialize(void);
 void __pthread_initialize(void)
 {
   pthread_initialize();
@@ -625,27 +509,11 @@ int __pthread_initialize_manager(void)
 {
   int manager_pipe[2];
   int pid;
-  struct pthread_request request;
   int report_events;
-  pthread_descr mgr;
-#ifdef __UCLIBC_HAS_TLS__
-  tcbhead_t *tcbp;
-#endif
+  struct pthread_request request;
 
-  __pthread_multiple_threads = 1;
-#if TLS_MULTIPLE_THREADS_IN_TCB || !defined __UCLIBC_HAS_TLS__ || !TLS_DTV_AT_TP
-  __pthread_main_thread->p_multiple_threads = 1;
-#endif
   *__libc_multiple_threads_ptr = 1;
 
-#ifndef HAVE_Z_NODELETE
-  if (__builtin_expect (&__dso_handle != NULL, 1))
-    __cxa_atexit ((void (*) (void *)) pthread_atexit_retcode, NULL,
-		  __dso_handle);
-#endif
-
-  if (__pthread_max_stacksize == 0)
-    __pthread_init_max_stacksize ();
   /* If basic initialization not done yet (e.g. we're called from a
      constructor run before our constructor), do it now */
   if (__pthread_initial_thread_bos == NULL) pthread_initialize();
@@ -654,59 +522,25 @@ int __pthread_initialize_manager(void)
   if (__pthread_manager_thread_bos == NULL) return -1;
   __pthread_manager_thread_tos =
     __pthread_manager_thread_bos + THREAD_MANAGER_STACK_SIZE;
+
+  /* On non-MMU systems we make sure that the initial thread bounds don't overlap
+   * with the manager stack frame */
+  NOMMU_INITIAL_THREAD_BOUNDS(__pthread_manager_thread_tos,__pthread_manager_thread_bos);
+  PDEBUG("manager stack: size=%ld, bos=%p, tos=%p\n", THREAD_MANAGER_STACK_SIZE,
+	 __pthread_manager_thread_bos, __pthread_manager_thread_tos);
+#if 0
+  PDEBUG("initial stack: estimate bos=%p, tos=%p\n",
+	 __pthread_initial_thread_bos, __pthread_initial_thread_tos);
+#endif
+
   /* Setup pipe to communicate with thread manager */
   if (pipe(manager_pipe) == -1) {
     free(__pthread_manager_thread_bos);
     return -1;
   }
-
-#ifdef __UCLIBC_HAS_TLS__
-  /* Allocate memory for the thread descriptor and the dtv.  */
-  tcbp = _dl_allocate_tls (NULL);
-  if (tcbp == NULL) {
-    free(__pthread_manager_thread_bos);
-    close_not_cancel(manager_pipe[0]);
-    close_not_cancel(manager_pipe[1]);
-    return -1;
-  }
-
-# if defined(TLS_TCB_AT_TP)
-  mgr = (pthread_descr) tcbp;
-# elif defined(TLS_DTV_AT_TP)
-  /* pthread_descr is located right below tcbhead_t which _dl_allocate_tls
-     returns.  */
-  mgr = (pthread_descr) ((char *) tcbp - TLS_PRE_TCB_SIZE);
-# endif
-  __pthread_handles[1].h_descr = manager_thread = mgr;
-
-  /* Initialize the descriptor.  */
-#if !defined __UCLIBC_HAS_TLS__ || !TLS_DTV_AT_TP
-  mgr->p_header.data.tcb = tcbp;
-  mgr->p_header.data.self = mgr;
-  mgr->p_header.data.multiple_threads = 1;
-#elif TLS_MULTIPLE_THREADS_IN_TCB
-  mgr->p_multiple_threads = 1;
-#endif
-  mgr->p_lock = &__pthread_handles[1].h_lock;
-# ifndef __UCLIBC_HAS_TLS__
-  mgr->p_errnop = &mgr->p_errno;
-# endif
-  mgr->p_start_args = (struct pthread_start_args) PTHREAD_START_ARGS_INITIALIZER(__pthread_manager);
-  mgr->p_nr = 1;
-# if __LT_SPINLOCK_INIT != 0
-  self->p_resume_count = (struct pthread_atomic) __ATOMIC_INITIALIZER;
-# endif
-  mgr->p_alloca_cutoff = PTHREAD_STACK_MIN / 4;
-#else
-  mgr = &__pthread_manager_thread;
-#endif
-
-  __pthread_manager_request = manager_pipe[1]; /* writing end */
-  __pthread_manager_reader = manager_pipe[0]; /* reading end */
-
   /* Start the thread manager */
   pid = 0;
-#ifdef __UCLIBC_HAS_TLS__
+#if defined(USE_TLS) && USE_TLS
   if (__linuxthreads_initial_report_events != 0)
     THREAD_SETMEM (((pthread_descr) NULL), p_report_events,
 		   __linuxthreads_initial_report_events);
@@ -723,36 +557,25 @@ int __pthread_initialize_manager(void)
 	 the manager thread.  */
       int idx = __td_eventword (TD_CREATE);
       uint32_t mask = __td_eventmask (TD_CREATE);
-      uint32_t event_bits;
 
-#ifdef __UCLIBC_HAS_TLS__
-      event_bits = THREAD_GETMEM_NC (((pthread_descr) NULL),
-				     p_eventbuf.eventmask.event_bits[idx]);
-#else
-      event_bits = __pthread_initial_thread.p_eventbuf.eventmask.event_bits[idx];
-#endif
-
-      if ((mask & (__pthread_threads_events.event_bits[idx] | event_bits))
+      if ((mask & (__pthread_threads_events.event_bits[idx]
+		   | __pthread_initial_thread.p_eventbuf.eventmask.event_bits[idx]))
 	  != 0)
 	{
-	  __pthread_lock(mgr->p_lock, NULL);
 
-#ifdef NEED_SEPARATE_REGISTER_STACK
+	 __pthread_lock(__pthread_manager_thread.p_lock, NULL);
+
+#ifdef __ia64__
 	  pid = __clone2(__pthread_manager_event,
-			 (void **) __pthread_manager_thread_bos,
-			 THREAD_MANAGER_STACK_SIZE,
-			 CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM,
-			 mgr);
-#elif defined _STACK_GROWS_UP
-	  pid = __clone(__pthread_manager_event,
-			(void **) __pthread_manager_thread_bos,
-			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM,
-			mgr);
+			(void **) __pthread_manager_thread_tos,
+			THREAD_MANAGER_STACK_SIZE,
+			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,
+			(void *)(long)manager_pipe[0]);
 #else
-	  pid = __clone(__pthread_manager_event,
+	  pid = clone(__pthread_manager_event,
 			(void **) __pthread_manager_thread_tos,
-			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM,
-			mgr);
+			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,
+			(void *)(long)manager_pipe[0]);
 #endif
 
 	  if (pid != -1)
@@ -761,48 +584,46 @@ int __pthread_initialize_manager(void)
 	         the newly created thread's data structure.  We cannot let
 	         the new thread do this since we don't know whether it was
 	         already scheduled when we send the event.  */
-	      mgr->p_eventbuf.eventdata = mgr;
-	      mgr->p_eventbuf.eventnum = TD_CREATE;
-	      __pthread_last_event = mgr;
-	      mgr->p_tid = 2* PTHREAD_THREADS_MAX + 1;
-	      mgr->p_pid = pid;
+	      __pthread_manager_thread.p_eventbuf.eventdata =
+		  &__pthread_manager_thread;
+	      __pthread_manager_thread.p_eventbuf.eventnum = TD_CREATE;
+	      __pthread_last_event = &__pthread_manager_thread;
+	      __pthread_manager_thread.p_tid = 2* PTHREAD_THREADS_MAX + 1;
+	      __pthread_manager_thread.p_pid = pid;
 
 	      /* Now call the function which signals the event.  */
 	      __linuxthreads_create_event ();
 	    }
-
 	  /* Now restart the thread.  */
-	  __pthread_unlock(mgr->p_lock);
+	  __pthread_unlock(__pthread_manager_thread.p_lock);
 	}
     }
 
-  if (__builtin_expect (pid, 0) == 0)
-    {
-#ifdef NEED_SEPARATE_REGISTER_STACK
-      pid = __clone2(__pthread_manager, (void **) __pthread_manager_thread_bos,
-		     THREAD_MANAGER_STACK_SIZE,
-		     CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM, mgr);
-#elif defined _STACK_GROWS_UP
-      pid = __clone(__pthread_manager, (void **) __pthread_manager_thread_bos,
-		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM, mgr);
+  if (pid == 0) {
+#ifdef __ia64__
+    pid = __clone2(__pthread_manager, (void **) __pthread_manager_thread_tos,
+		  THREAD_MANAGER_STACK_SIZE,
+		  CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,
+		  (void *)(long)manager_pipe[0]);
 #else
-      pid = __clone(__pthread_manager, (void **) __pthread_manager_thread_tos,
-		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_SYSVSEM, mgr);
-#endif
-    }
-  if (__builtin_expect (pid, 0) == -1) {
-#ifdef __UCLIBC_HAS_TLS__
-    _dl_deallocate_tls (tcbp, true);
+    pid = clone(__pthread_manager, (void **) __pthread_manager_thread_tos,
+		  CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,
+		  (void *)(long)manager_pipe[0]);
 #endif
+  }
+  if (pid == -1) {
     free(__pthread_manager_thread_bos);
-    close_not_cancel(manager_pipe[0]);
-    close_not_cancel(manager_pipe[1]);
+    close(manager_pipe[0]);
+    close(manager_pipe[1]);
     return -1;
   }
-  mgr->p_tid = 2* PTHREAD_THREADS_MAX + 1;
-  mgr->p_pid = pid;
+  __pthread_manager_request = manager_pipe[1]; /* writing end */
+  __pthread_manager_reader = manager_pipe[0]; /* reading end */
+  __pthread_manager_thread.p_tid = 2* PTHREAD_THREADS_MAX + 1;
+  __pthread_manager_thread.p_pid = pid;
+
   /* Make gdb aware of new thread manager */
-  if (__builtin_expect (__pthread_threads_debug, 0) && __pthread_sig_debug > 0)
+  if (__pthread_threads_debug && __pthread_sig_debug > 0)
     {
       raise(__pthread_sig_debug);
       /* We suspend ourself and gdb will wake us up when it is
@@ -810,21 +631,21 @@ int __pthread_initialize_manager(void)
       __pthread_wait_for_restart_signal(thread_self());
     }
   /* Synchronize debugging of the thread manager */
+  PDEBUG("send REQ_DEBUG to manager thread\n");
   request.req_kind = REQ_DEBUG;
-  TEMP_FAILURE_RETRY(write_not_cancel(__pthread_manager_request,
-				      (char *) &request, sizeof(request)));
+  TEMP_FAILURE_RETRY(write(__pthread_manager_request,
+	      (char *) &request, sizeof(request)));
   return 0;
 }
 
 /* Thread creation */
 
-int __pthread_create(pthread_t *thread, const pthread_attr_t *attr,
+int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
 			 void * (*start_routine)(void *), void *arg)
 {
   pthread_descr self = thread_self();
   struct pthread_request request;
-  int retval;
-  if (__builtin_expect (__pthread_manager_request, 0) < 0) {
+  if (__pthread_manager_request < 0) {
     if (__pthread_initialize_manager() < 0) return EAGAIN;
   }
   request.req_thread = self;
@@ -833,35 +654,31 @@ int __pthread_create(pthread_t *thread, const pthread_attr_t *attr,
   request.req_args.create.fn = start_routine;
   request.req_args.create.arg = arg;
   sigprocmask(SIG_SETMASK, NULL, &request.req_args.create.mask);
-  TEMP_FAILURE_RETRY(write_not_cancel(__pthread_manager_request,
-				      (char *) &request, sizeof(request)));
+  PDEBUG("write REQ_CREATE to manager thread\n");
+  TEMP_FAILURE_RETRY(write(__pthread_manager_request,
+	      (char *) &request, sizeof(request)));
+  PDEBUG("before suspend(self)\n");
   suspend(self);
-  retval = THREAD_GETMEM(self, p_retcode);
-  if (__builtin_expect (retval, 0) == 0)
+  PDEBUG("after suspend(self)\n");
+  if (THREAD_GETMEM(self, p_retcode) == 0)
     *thread = (pthread_t) THREAD_GETMEM(self, p_retval);
-  return retval;
+  return THREAD_GETMEM(self, p_retcode);
 }
-strong_alias (__pthread_create, pthread_create)
 
 /* Simple operations on thread identifiers */
 
-pthread_descr __pthread_thread_self(void)
-{
-  return thread_self();
-}
-
-pthread_t __pthread_self(void)
+pthread_t pthread_self(void)
 {
   pthread_descr self = thread_self();
   return THREAD_GETMEM(self, p_tid);
 }
-strong_alias (__pthread_self, pthread_self)
+libpthread_hidden_def (pthread_self)
 
-int __pthread_equal(pthread_t thread1, pthread_t thread2)
+int pthread_equal(pthread_t thread1, pthread_t thread2)
 {
   return thread1 == thread2;
 }
-strong_alias (__pthread_equal, pthread_equal)
+libpthread_hidden_def (pthread_equal)
 
 /* Helper function for thread_self in the case of user-provided stacks */
 
@@ -875,64 +692,55 @@ pthread_descr __pthread_find_self(void)
   /* __pthread_handles[0] is the initial thread, __pthread_handles[1] is
      the manager threads handled specially in thread_self(), so start at 2 */
   h = __pthread_handles + 2;
-# ifdef _STACK_GROWS_UP
-  while (! (sp >= (char *) h->h_descr && sp < (char *) h->h_descr->p_guardaddr)) h++;
-# else
   while (! (sp <= (char *) h->h_descr && sp >= h->h_bottom)) h++;
-# endif
+
+#ifdef DEBUG_PT
+  if (h->h_descr == NULL) {
+      printf("*** %s ERROR descriptor is NULL!!!!! ***\n\n", __FUNCTION__);
+      _exit(1);
+  }
+#endif
+
   return h->h_descr;
 }
-
 #else
 
-pthread_descr __pthread_self_stack(void)
+static pthread_descr thread_self_stack(void)
 {
-  char *sp = CURRENT_STACK_FRAME;
-  pthread_handle h;
-
-  if (sp >= __pthread_manager_thread_bos && sp < __pthread_manager_thread_tos)
-    return manager_thread;
-  h = __pthread_handles + 2;
-# ifdef __UCLIBC_HAS_TLS__
-#  ifdef _STACK_GROWS_UP
-  while (h->h_descr == NULL
-	 || ! (sp >= h->h_descr->p_stackaddr && sp < h->h_descr->p_guardaddr))
-    h++;
-#  else
-  while (h->h_descr == NULL
-	 || ! (sp <= (char *) h->h_descr->p_stackaddr && sp >= h->h_bottom))
-    h++;
-#  endif
+    char *sp = CURRENT_STACK_FRAME;
+    pthread_handle h;
+
+    if (sp >= __pthread_manager_thread_bos && sp < __pthread_manager_thread_tos)
+	return manager_thread;
+    h = __pthread_handles + 2;
+# if defined(USE_TLS) && USE_TLS
+    while (h->h_descr == NULL
+	    || ! (sp <= (char *) h->h_descr->p_stackaddr && sp >= h->h_bottom))
+	h++;
 # else
-#  ifdef _STACK_GROWS_UP
-  while (! (sp >= (char *) h->h_descr && sp < h->h_descr->p_guardaddr))
-    h++;
-#  else
-  while (! (sp <= (char *) h->h_descr && sp >= h->h_bottom))
-    h++;
-#  endif
+    while (! (sp <= (char *) h->h_descr && sp >= h->h_bottom))
+	h++;
 # endif
-  return h->h_descr;
+    return h->h_descr;
 }
 
 #endif
 
 /* Thread scheduling */
 
-int __pthread_setschedparam(pthread_t thread, int policy,
-                            const struct sched_param *param)
+int pthread_setschedparam(pthread_t thread, int policy,
+                          const struct sched_param *param)
 {
   pthread_handle handle = thread_handle(thread);
   pthread_descr th;
 
   __pthread_lock(&handle->h_lock, NULL);
-  if (__builtin_expect (invalid_handle(handle, thread), 0)) {
+  if (invalid_handle(handle, thread)) {
     __pthread_unlock(&handle->h_lock);
     return ESRCH;
   }
   th = handle->h_descr;
-  if (__builtin_expect (__sched_setscheduler(th->p_pid, policy, param) == -1,
-			0)) {
+  if (sched_setscheduler(th->p_pid, policy, param) == -1) {
     __pthread_unlock(&handle->h_lock);
     return errno;
   }
@@ -942,85 +750,53 @@ int __pthread_setschedparam(pthread_t thread, int policy,
     __pthread_manager_adjust_prio(th->p_priority);
   return 0;
 }
-strong_alias (__pthread_setschedparam, pthread_setschedparam)
+libpthread_hidden_def(pthread_setschedparam)
 
-int __pthread_getschedparam(pthread_t thread, int *policy,
-                            struct sched_param *param)
+int pthread_getschedparam(pthread_t thread, int *policy,
+                          struct sched_param *param)
 {
   pthread_handle handle = thread_handle(thread);
   int pid, pol;
 
   __pthread_lock(&handle->h_lock, NULL);
-  if (__builtin_expect (invalid_handle(handle, thread), 0)) {
+  if (invalid_handle(handle, thread)) {
     __pthread_unlock(&handle->h_lock);
     return ESRCH;
   }
   pid = handle->h_descr->p_pid;
   __pthread_unlock(&handle->h_lock);
-  pol = __sched_getscheduler(pid);
-  if (__builtin_expect (pol, 0) == -1) return errno;
-  if (__sched_getparam(pid, param) == -1) return errno;
+  pol = sched_getscheduler(pid);
+  if (pol == -1) return errno;
+  if (sched_getparam(pid, param) == -1) return errno;
   *policy = pol;
   return 0;
 }
-strong_alias (__pthread_getschedparam, pthread_getschedparam)
+libpthread_hidden_def(pthread_getschedparam)
 
 /* Process-wide exit() request */
 
-static void pthread_onexit_process(int retcode, void *arg)
+static void pthread_onexit_process(int retcode, void *arg attribute_unused)
 {
-  if (__builtin_expect (__pthread_manager_request, 0) >= 0) {
     struct pthread_request request;
     pthread_descr self = thread_self();
 
-    /* Make sure we come back here after suspend(), in case we entered
-       from a signal handler.  */
-    THREAD_SETMEM(self, p_signal_jmp, NULL);
-
-    request.req_thread = self;
-    request.req_kind = REQ_PROCESS_EXIT;
-    request.req_args.exit.code = retcode;
-    TEMP_FAILURE_RETRY(write_not_cancel(__pthread_manager_request,
-					(char *) &request, sizeof(request)));
-    suspend(self);
-    /* Main thread should accumulate times for thread manager and its
-       children, so that timings for main thread account for all threads. */
-    if (self == __pthread_main_thread)
-      {
-#ifdef __UCLIBC_HAS_TLS__
-	waitpid(manager_thread->p_pid, NULL, __WCLONE);
-#else
-	waitpid(__pthread_manager_thread.p_pid, NULL, __WCLONE);
-#endif
-	/* Since all threads have been asynchronously terminated
-           (possibly holding locks), free cannot be used any more.
-           For mtrace, we'd like to print something though.  */
-	/* #ifdef __UCLIBC_HAS_TLS__
-	   tcbhead_t *tcbp = (tcbhead_t *) manager_thread;
-	   # if defined(TLS_DTV_AT_TP)
-	   tcbp = (tcbhead_t) ((char *) tcbp + TLS_PRE_TCB_SIZE);
-	   # endif
-	   _dl_deallocate_tls (tcbp, true);
-	   #endif
-	   free (__pthread_manager_thread_bos); */
-	__pthread_manager_thread_bos = __pthread_manager_thread_tos = NULL;
-      }
-  }
-}
-
-#ifndef HAVE_Z_NODELETE
-static int __pthread_atexit_retcode;
-
-static void pthread_atexit_process(void *arg, int retcode)
-{
-  pthread_onexit_process (retcode ?: __pthread_atexit_retcode, arg);
-}
-
-static void pthread_atexit_retcode(void *arg, int retcode)
-{
-  __pthread_atexit_retcode = retcode;
+    if (__pthread_manager_request >= 0) {
+	request.req_thread = self;
+	request.req_kind = REQ_PROCESS_EXIT;
+	request.req_args.exit.code = retcode;
+	TEMP_FAILURE_RETRY(write(__pthread_manager_request,
+		    (char *) &request, sizeof(request)));
+	suspend(self);
+	/* Main thread should accumulate times for thread manager and its
+	   children, so that timings for main thread account for all threads. */
+	if (self == __pthread_main_thread) {
+	    waitpid(__pthread_manager_thread.p_pid, NULL, __WCLONE);
+	    /* Since all threads have been asynchronously terminated
+	     * (possibly holding locks), free cannot be used any more.  */
+	    __pthread_manager_thread_bos = __pthread_manager_thread_tos = NULL;
+	}
+    }
 }
-#endif
 
 /* The handler for the RESTART signal just records the signal received
    in the thread descriptor, and optionally performs a siglongjmp
@@ -1028,10 +804,10 @@ static void pthread_atexit_retcode(void *arg, int retcode)
 
 static void pthread_handle_sigrestart(int sig)
 {
-  pthread_descr self = check_thread_self();
-  THREAD_SETMEM(self, p_signal, sig);
-  if (THREAD_GETMEM(self, p_signal_jmp) != NULL)
-    siglongjmp(*THREAD_GETMEM(self, p_signal_jmp), 1);
+    pthread_descr self = thread_self();
+    THREAD_SETMEM(self, p_signal, sig);
+    if (THREAD_GETMEM(self, p_signal_jmp) != NULL)
+	siglongjmp(*THREAD_GETMEM(self, p_signal_jmp), 1);
 }
 
 /* The handler for the CANCEL signal checks for cancellation
@@ -1041,20 +817,39 @@ static void pthread_handle_sigrestart(int sig)
 
 static void pthread_handle_sigcancel(int sig)
 {
-  pthread_descr self = check_thread_self();
+  pthread_descr self = thread_self();
   sigjmp_buf * jmpbuf;
 
-  if (self == manager_thread)
+
+  if (self == &__pthread_manager_thread)
     {
+#ifdef THREAD_SELF
+      /* A new thread might get a cancel signal before it is fully
+	 initialized, so that the thread register might still point to the
+	 manager thread.  Double check that this is really the manager
+	 thread.  */
+      pthread_descr real_self = thread_self_stack();
+      if (real_self == &__pthread_manager_thread)
+	{
+	  __pthread_manager_sighandler(sig);
+	  return;
+	}
+      /* Oops, thread_self() isn't working yet..  */
+      self = real_self;
+# ifdef INIT_THREAD_SELF
+      INIT_THREAD_SELF(self, self->p_nr);
+# endif
+#else
       __pthread_manager_sighandler(sig);
       return;
+#endif
     }
   if (__builtin_expect (__pthread_exit_requested, 0)) {
     /* Main thread should accumulate times for thread manager and its
        children, so that timings for main thread account for all threads. */
     if (self == __pthread_main_thread) {
-#ifdef __UCLIBC_HAS_TLS__
-      waitpid(manager_thread->p_pid, NULL, __WCLONE);
+#if defined(USE_TLS) && USE_TLS
+      waitpid(__pthread_manager_thread->p_pid, NULL, __WCLONE);
 #else
       waitpid(__pthread_manager_thread.p_pid, NULL, __WCLONE);
 #endif
@@ -1083,7 +878,7 @@ static void pthread_handle_sigcancel(int sig)
    know what it is specifically done for. In the current implementation,
    the thread manager simply discards it. */
 
-static void pthread_handle_sigdebug(int sig)
+static void pthread_handle_sigdebug(int sig attribute_unused)
 {
   /* Nothing */
 }
@@ -1103,39 +898,20 @@ void __pthread_reset_main_thread(void)
     free(__pthread_manager_thread_bos);
     __pthread_manager_thread_bos = __pthread_manager_thread_tos = NULL;
     /* Close the two ends of the pipe */
-    close_not_cancel(__pthread_manager_request);
-    close_not_cancel(__pthread_manager_reader);
+    close(__pthread_manager_request);
+    close(__pthread_manager_reader);
     __pthread_manager_request = __pthread_manager_reader = -1;
   }
 
   /* Update the pid of the main thread */
-  THREAD_SETMEM(self, p_pid, __getpid());
+  THREAD_SETMEM(self, p_pid, getpid());
   /* Make the forked thread the main thread */
   __pthread_main_thread = self;
   THREAD_SETMEM(self, p_nextlive, self);
   THREAD_SETMEM(self, p_prevlive, self);
-#ifndef __UCLIBC_HAS_TLS__
   /* Now this thread modifies the global variables.  */
   THREAD_SETMEM(self, p_errnop, &_errno);
   THREAD_SETMEM(self, p_h_errnop, &_h_errno);
-# if defined __UCLIBC_HAS_RESOLVER_SUPPORT__
-  THREAD_SETMEM(self, p_resp, __resp);
-# endif
-#endif
-
-#ifndef FLOATING_STACKS
-  /* This is to undo the setrlimit call in __pthread_init_max_stacksize.
-     XXX This can be wrong if the user set the limit during the run.  */
- {
-   struct rlimit limit;
-   if (getrlimit (RLIMIT_STACK, &limit) == 0
-       && limit.rlim_cur != limit.rlim_max)
-     {
-       limit.rlim_cur = limit.rlim_max;
-       setrlimit(RLIMIT_STACK, &limit);
-     }
- }
-#endif
 }
 
 /* Process-wide exec() request */
@@ -1148,7 +924,6 @@ void __pthread_kill_other_threads_np(void)
   /* Make current thread the main thread in case the calling thread
      changes its mind, does not exec(), and creates new threads instead. */
   __pthread_reset_main_thread();
-
   /* Reset the signal handlers behaviour for the signals the
      implementation uses since this would be passed to the new
      process.  */
@@ -1179,24 +954,24 @@ int __pthread_getconcurrency(void)
 }
 weak_alias (__pthread_getconcurrency, pthread_getconcurrency)
 
+
 /* Primitives for controlling thread execution */
 
 void __pthread_wait_for_restart_signal(pthread_descr self)
 {
-  sigset_t mask;
+    sigset_t mask;
 
-  sigprocmask(SIG_SETMASK, NULL, &mask); /* Get current signal mask */
-  sigdelset(&mask, __pthread_sig_restart); /* Unblock the restart signal */
-  THREAD_SETMEM(self, p_signal, 0);
-  do {
-    __pthread_sigsuspend(&mask);	/* Wait for signal.  Must not be a
-					   cancellation point. */
-  } while (THREAD_GETMEM(self, p_signal) !=__pthread_sig_restart);
+    sigprocmask(SIG_SETMASK, NULL, &mask); /* Get current signal mask */
+    sigdelset(&mask, __pthread_sig_restart); /* Unblock the restart signal */
+    THREAD_SETMEM(self, p_signal, 0);
+    do {
+	sigsuspend(&mask);                   /* Wait for signal */
+    } while (THREAD_GETMEM(self, p_signal) !=__pthread_sig_restart);
 
-  READ_MEMORY_BARRIER(); /* See comment in __pthread_restart_new */
+    READ_MEMORY_BARRIER(); /* See comment in __pthread_restart_new */
 }
 
-#if !__ASSUME_REALTIME_SIGNALS
+#ifndef __NR_rt_sigaction
 /* The _old variants are for 2.0 and early 2.1 kernels which don't have RT
    signals.
    On these kernels, we use SIGUSR1 and SIGUSR2 for restart and cancellation.
@@ -1206,14 +981,14 @@ void __pthread_wait_for_restart_signal(pthread_descr self)
 
 void __pthread_restart_old(pthread_descr th)
 {
-  if (pthread_atomic_increment(&th->p_resume_count) == -1)
-    kill(th->p_pid, __pthread_sig_restart);
+    if (atomic_increment(&th->p_resume_count) == -1)
+	kill(th->p_pid, __pthread_sig_restart);
 }
 
 void __pthread_suspend_old(pthread_descr self)
 {
-  if (pthread_atomic_decrement(&self->p_resume_count) <= 0)
-    __pthread_wait_for_restart_signal(self);
+    if (atomic_decrement(&self->p_resume_count) <= 0)
+	__pthread_wait_for_restart_signal(self);
 }
 
 int
@@ -1223,7 +998,7 @@ __pthread_timedsuspend_old(pthread_descr self, const struct timespec *abstime)
   int was_signalled = 0;
   sigjmp_buf jmpbuf;
 
-  if (pthread_atomic_decrement(&self->p_resume_count) == 0) {
+  if (atomic_decrement(&self->p_resume_count) == 0) {
     /* Set up a longjmp handler for the restart signal, unblock
        the signal and sleep. */
 
@@ -1240,7 +1015,7 @@ __pthread_timedsuspend_old(pthread_descr self, const struct timespec *abstime)
 	struct timespec reltime;
 
 	/* Compute a time offset relative to now.  */
-	__gettimeofday (&now, NULL);
+	gettimeofday (&now, NULL);
 	reltime.tv_nsec = abstime->tv_nsec - now.tv_usec * 1000;
 	reltime.tv_sec = abstime->tv_sec - now.tv_sec;
 	if (reltime.tv_nsec < 0) {
@@ -1280,9 +1055,9 @@ __pthread_timedsuspend_old(pthread_descr self, const struct timespec *abstime)
      being delivered. */
 
   if (!was_signalled) {
-    if (pthread_atomic_increment(&self->p_resume_count) != -1) {
+    if (atomic_increment(&self->p_resume_count) != -1) {
       __pthread_wait_for_restart_signal(self);
-      pthread_atomic_decrement(&self->p_resume_count); /* should be zero now! */
+      atomic_decrement(&self->p_resume_count); /* should be zero now! */
       /* woke spontaneously and consumed restart signal */
       return 1;
     }
@@ -1292,92 +1067,99 @@ __pthread_timedsuspend_old(pthread_descr self, const struct timespec *abstime)
   /* woken due to restart signal */
   return 1;
 }
-#endif /* __ASSUME_REALTIME_SIGNALS */
+#endif /* __NR_rt_sigaction */
 
+
+#ifdef __NR_rt_sigaction
 void __pthread_restart_new(pthread_descr th)
 {
-  /* The barrier is proabably not needed, in which case it still documents
-     our assumptions. The intent is to commit previous writes to shared
-     memory so the woken thread will have a consistent view.  Complementary
-     read barriers are present to the suspend functions. */
-  WRITE_MEMORY_BARRIER();
-  kill(th->p_pid, __pthread_sig_restart);
+    /* The barrier is proabably not needed, in which case it still documents
+       our assumptions. The intent is to commit previous writes to shared
+       memory so the woken thread will have a consistent view.  Complementary
+       read barriers are present to the suspend functions. */
+    WRITE_MEMORY_BARRIER();
+    kill(th->p_pid, __pthread_sig_restart);
 }
 
-/* There is no __pthread_suspend_new because it would just
-   be a wasteful wrapper for __pthread_wait_for_restart_signal */
-
-int
-__pthread_timedsuspend_new(pthread_descr self, const struct timespec *abstime)
+int __pthread_timedsuspend_new(pthread_descr self, const struct timespec *abstime)
 {
-  sigset_t unblock, initial_mask;
-  int was_signalled = 0;
-  sigjmp_buf jmpbuf;
+    sigset_t unblock, initial_mask;
+    int was_signalled = 0;
+    sigjmp_buf jmpbuf;
 
-  if (sigsetjmp(jmpbuf, 1) == 0) {
-    THREAD_SETMEM(self, p_signal_jmp, &jmpbuf);
-    THREAD_SETMEM(self, p_signal, 0);
-    /* Unblock the restart signal */
-    __sigemptyset(&unblock);
-    sigaddset(&unblock, __pthread_sig_restart);
-    sigprocmask(SIG_UNBLOCK, &unblock, &initial_mask);
-
-    while (1) {
-      struct timeval now;
-      struct timespec reltime;
-
-      /* Compute a time offset relative to now.  */
-      __gettimeofday (&now, NULL);
-      reltime.tv_nsec = abstime->tv_nsec - now.tv_usec * 1000;
-      reltime.tv_sec = abstime->tv_sec - now.tv_sec;
-      if (reltime.tv_nsec < 0) {
-	reltime.tv_nsec += 1000000000;
-	reltime.tv_sec -= 1;
-      }
+    if (sigsetjmp(jmpbuf, 1) == 0) {
+	THREAD_SETMEM(self, p_signal_jmp, &jmpbuf);
+	THREAD_SETMEM(self, p_signal, 0);
+	/* Unblock the restart signal */
+	__sigemptyset(&unblock);
+	sigaddset(&unblock, __pthread_sig_restart);
+	sigprocmask(SIG_UNBLOCK, &unblock, &initial_mask);
+
+	while (1) {
+	    struct timeval now;
+	    struct timespec reltime;
+
+	    /* Compute a time offset relative to now.  */
+	    gettimeofday (&now, NULL);
+	    reltime.tv_nsec = abstime->tv_nsec - now.tv_usec * 1000;
+	    reltime.tv_sec = abstime->tv_sec - now.tv_sec;
+	    if (reltime.tv_nsec < 0) {
+		reltime.tv_nsec += 1000000000;
+		reltime.tv_sec -= 1;
+	    }
 
-      /* Sleep for the required duration. If woken by a signal,
-	 resume waiting as required by Single Unix Specification.  */
-      if (reltime.tv_sec < 0 || nanosleep(&reltime, NULL) == 0)
-	break;
-    }
+	    /* Sleep for the required duration. If woken by a signal,
+	       resume waiting as required by Single Unix Specification.  */
+	    if (reltime.tv_sec < 0 || nanosleep(&reltime, NULL) == 0)
+		break;
+	}
 
-    /* Block the restart signal again */
-    sigprocmask(SIG_SETMASK, &initial_mask, NULL);
-    was_signalled = 0;
-  } else {
-    was_signalled = 1;
-  }
-  THREAD_SETMEM(self, p_signal_jmp, NULL);
+	/* Block the restart signal again */
+	sigprocmask(SIG_SETMASK, &initial_mask, NULL);
+	was_signalled = 0;
+    } else {
+	was_signalled = 1;
+    }
+    THREAD_SETMEM(self, p_signal_jmp, NULL);
 
-  /* Now was_signalled is true if we exited the above code
-     due to the delivery of a restart signal.  In that case,
-     everything is cool. We have been removed from whatever
-     we were waiting on by the other thread, and consumed its signal.
+    /* Now was_signalled is true if we exited the above code
+       due to the delivery of a restart signal.  In that case,
+       everything is cool. We have been removed from whatever
+       we were waiting on by the other thread, and consumed its signal.
 
-     Otherwise we this thread woke up spontaneously, or due to a signal other
-     than restart. This is an ambiguous case  that must be resolved by
-     the caller; the thread is still eligible for a restart wakeup
-     so there is a race. */
+       Otherwise we this thread woke up spontaneously, or due to a signal other
+       than restart. This is an ambiguous case  that must be resolved by
+       the caller; the thread is still eligible for a restart wakeup
+       so there is a race. */
 
-  READ_MEMORY_BARRIER(); /* See comment in __pthread_restart_new */
-  return was_signalled;
+    READ_MEMORY_BARRIER(); /* See comment in __pthread_restart_new */
+    return was_signalled;
 }
-
+#endif
 
 /* Debugging aid */
 
-#ifdef DEBUG
+#ifdef DEBUG_PT
 #include <stdarg.h>
 
-void __pthread_message(const char * fmt, ...)
+void __pthread_message(char * fmt, ...)
 {
   char buffer[1024];
   va_list args;
-  sprintf(buffer, "%05d : ", __getpid());
+  sprintf(buffer, "%05d : ", getpid());
   va_start(args, fmt);
   vsnprintf(buffer + 8, sizeof(buffer) - 8, fmt, args);
   va_end(args);
-  TEMP_FAILURE_RETRY(write_not_cancel(2, buffer, strlen(buffer)));
+  TEMP_FAILURE_RETRY(write(2, buffer, strlen(buffer)));
 }
 
 #endif
+
+
+#ifndef __PIC__
+/* We need a hook to force the cancellation wrappers to be linked in when
+   static libpthread is used.  */
+extern const char __pthread_provide_wrappers;
+static const char *const __pthread_require_wrappers =
+  &__pthread_provide_wrappers;
+#endif
diff --git a/libpthread/linuxthreads/pthread_atfork.c b/libpthread/linuxthreads/pthread_atfork.c
deleted file mode 100644
index 436c3b400..000000000
--- a/libpthread/linuxthreads/pthread_atfork.c
+++ /dev/null
@@ -1,62 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   In addition to the permissions in the GNU Lesser General Public
-   License, the Free Software Foundation gives you unlimited
-   permission to link the compiled version of this file with other
-   programs, and to distribute those programs without any restriction
-   coming from the use of this file. (The GNU Lesser General Public
-   License restrictions do apply in other respects; for example, they
-   cover modification of the file, and distribution when not linked
-   into another program.)
-
-   Note that people who make modified versions of this file are not
-   obligated to grant this special exception for their modified
-   versions; it is their choice whether to do so. The GNU Lesser
-   General Public License gives permission to release a modified
-   version without this exception; this exception also makes it
-   possible to release a modified version which carries forward this
-   exception.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "internals.h"
-#include <fork.h>
-
-/* This is defined by newer gcc version unique for each module.  */
-extern void *__dso_handle __attribute__ ((__weak__));
-
-
-/* Hide the symbol so that no definition but the one locally in the
-   executable or DSO is used.  */
-int
-#ifndef __pthread_atfork
-/* Don't mark the compatibility function as hidden.  */
-attribute_hidden
-#endif
-__pthread_atfork (prepare, parent, child)
-     void (*prepare) (void);
-     void (*parent) (void);
-     void (*child) (void);
-{
-  return __register_atfork (prepare, parent, child,
-			    &__dso_handle == NULL ? NULL : __dso_handle);
-}
-#ifndef __pthread_atfork
-extern int pthread_atfork (void (*prepare) (void), void (*parent) (void),
-			   void (*child) (void)) attribute_hidden;
-strong_alias (__pthread_atfork, pthread_atfork)
-#endif
diff --git a/libpthread/linuxthreads/pthread_setegid.c b/libpthread/linuxthreads/pthread_setegid.c
deleted file mode 100644
index ff0f250a5..000000000
--- a/libpthread/linuxthreads/pthread_setegid.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/* Copyright (C) 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <pthread.h>
-#include <unistd.h>
-
-
-int pthread_setegid_np (gid_t gid);
-int
-pthread_setegid_np (gid_t gid)
-{
-  return setegid (gid);
-}
diff --git a/libpthread/linuxthreads/pthread_seteuid.c b/libpthread/linuxthreads/pthread_seteuid.c
deleted file mode 100644
index a5423a9f3..000000000
--- a/libpthread/linuxthreads/pthread_seteuid.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/* Copyright (C) 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <pthread.h>
-#include <unistd.h>
-
-
-int pthread_seteuid_np (uid_t uid);
-int
-pthread_seteuid_np (uid_t uid)
-{
-  return seteuid (uid);
-}
diff --git a/libpthread/linuxthreads/pthread_setgid.c b/libpthread/linuxthreads/pthread_setgid.c
deleted file mode 100644
index 3e49b19bf..000000000
--- a/libpthread/linuxthreads/pthread_setgid.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/* Copyright (C) 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <pthread.h>
-#include <unistd.h>
-
-
-int pthread_setgid_np (gid_t gid);
-int
-pthread_setgid_np (gid_t gid)
-{
-  return setgid (gid);
-}
diff --git a/libpthread/linuxthreads/pthread_setregid.c b/libpthread/linuxthreads/pthread_setregid.c
deleted file mode 100644
index 21cabab61..000000000
--- a/libpthread/linuxthreads/pthread_setregid.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/* Copyright (C) 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <pthread.h>
-#include <unistd.h>
-
-
-int pthread_setregid_np (gid_t rgid, gid_t egid);
-int
-pthread_setregid_np (gid_t rgid, gid_t egid)
-{
-  return setregid (rgid, egid);
-}
diff --git a/libpthread/linuxthreads/pthread_setresgid.c b/libpthread/linuxthreads/pthread_setresgid.c
deleted file mode 100644
index 1cbf1b5f7..000000000
--- a/libpthread/linuxthreads/pthread_setresgid.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/* Copyright (C) 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <pthread.h>
-#include <unistd.h>
-
-
-int pthread_setresgid_np (gid_t rgid, gid_t egid, gid_t sgid);
-int
-pthread_setresgid_np (gid_t rgid, gid_t egid, gid_t sgid)
-{
-  return setresgid (rgid, egid, sgid);
-}
diff --git a/libpthread/linuxthreads/pthread_setresuid.c b/libpthread/linuxthreads/pthread_setresuid.c
deleted file mode 100644
index 0e35ba8ca..000000000
--- a/libpthread/linuxthreads/pthread_setresuid.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/* Copyright (C) 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <pthread.h>
-#include <unistd.h>
-
-
-int pthread_setresuid_np (uid_t ruid, uid_t euid, uid_t suid);
-int
-pthread_setresuid_np (uid_t ruid, uid_t euid, uid_t suid)
-{
-  return setresuid (ruid, euid, suid);
-}
diff --git a/libpthread/linuxthreads/pthread_setreuid.c b/libpthread/linuxthreads/pthread_setreuid.c
deleted file mode 100644
index 680eb5394..000000000
--- a/libpthread/linuxthreads/pthread_setreuid.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/* Copyright (C) 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <pthread.h>
-#include <unistd.h>
-
-
-int pthread_setreuid_np (uid_t ruid, uid_t euid);
-int
-pthread_setreuid_np (uid_t ruid, uid_t euid)
-{
-  return setreuid (ruid, euid);
-}
diff --git a/libpthread/linuxthreads/pthread_setuid.c b/libpthread/linuxthreads/pthread_setuid.c
deleted file mode 100644
index e1af5a196..000000000
--- a/libpthread/linuxthreads/pthread_setuid.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/* Copyright (C) 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <pthread.h>
-#include <unistd.h>
-
-
-int pthread_setuid_np (uid_t uid);
-int
-pthread_setuid_np (uid_t uid)
-{
-  return setuid (uid);
-}
diff --git a/libpthread/linuxthreads.old/ptlongjmp.c b/libpthread/linuxthreads/ptlongjmp.c
similarity index 100%
rename from libpthread/linuxthreads.old/ptlongjmp.c
rename to libpthread/linuxthreads/ptlongjmp.c
diff --git a/libpthread/linuxthreads/queue.h b/libpthread/linuxthreads/queue.h
index e50517f77..01d18d16e 100644
--- a/libpthread/linuxthreads/queue.h
+++ b/libpthread/linuxthreads/queue.h
@@ -21,7 +21,6 @@
 static __inline__ void enqueue(pthread_descr * q, pthread_descr th)
 {
   int prio = th->p_priority;
-  ASSERT(th->p_nextwaiting == NULL);
   for (; *q != NULL; q = &((*q)->p_nextwaiting)) {
     if (prio > (*q)->p_priority) {
       th->p_nextwaiting = *q;
diff --git a/libpthread/linuxthreads/restart.h b/libpthread/linuxthreads/restart.h
index 694ec48cf..7d63a7022 100644
--- a/libpthread/linuxthreads/restart.h
+++ b/libpthread/linuxthreads/restart.h
@@ -13,7 +13,8 @@
 /* GNU Library General Public License for more details.                 */
 
 #include <signal.h>
-#include <bits/kernel-features.h>
+#include <sys/syscall.h>
+#define __ASSUME_REALTIME_SIGNALS defined(__NR_rt_sigaction)
 
 /* Primitives for controlling thread execution */
 
diff --git a/libpthread/linuxthreads/rwlock.c b/libpthread/linuxthreads/rwlock.c
index af72876f5..3ab940261 100644
--- a/libpthread/linuxthreads/rwlock.c
+++ b/libpthread/linuxthreads/rwlock.c
@@ -1,24 +1,23 @@
 /* Read-write lock implementation.
-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+   Copyright (C) 1998 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Xavier Leroy <Xavier.Leroy@inria.fr>
    and Ulrich Drepper <drepper@cygnus.com>, 1998.
 
    The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
    License, or (at your option) any later version.
 
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
+   Library General Public License for more details.
 
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   see <http://www.gnu.org/licenses/>.  */
 
-#include <bits/libc-lock.h>
 #include <errno.h>
 #include <pthread.h>
 #include <stdlib.h>
@@ -27,33 +26,6 @@
 #include "spinlock.h"
 #include "restart.h"
 
-/* Function called by pthread_cancel to remove the thread from
-   waiting inside pthread_rwlock_timedrdlock or pthread_rwlock_timedwrlock. */
-
-static int rwlock_rd_extricate_func(void *obj, pthread_descr th)
-{
-  pthread_rwlock_t *rwlock = obj;
-  int did_remove = 0;
-
-  __pthread_lock(&rwlock->__rw_lock, NULL);
-  did_remove = remove_from_queue(&rwlock->__rw_read_waiting, th);
-  __pthread_unlock(&rwlock->__rw_lock);
-
-  return did_remove;
-}
-
-static int rwlock_wr_extricate_func(void *obj, pthread_descr th)
-{
-  pthread_rwlock_t *rwlock = obj;
-  int did_remove = 0;
-
-  __pthread_lock(&rwlock->__rw_lock, NULL);
-  did_remove = remove_from_queue(&rwlock->__rw_write_waiting, th);
-  __pthread_unlock(&rwlock->__rw_lock);
-
-  return did_remove;
-}
-
 /*
  * Check whether the calling thread already owns one or more read locks on the
  * specified lock. If so, return a pointer to the read lock info structure
@@ -65,8 +37,7 @@ rwlock_is_in_list(pthread_descr self, pthread_rwlock_t *rwlock)
 {
   pthread_readlock_info *info;
 
-  for (info = THREAD_GETMEM (self, p_readlock_list); info != NULL;
-       info = info->pr_next)
+  for (info = self->p_readlock_list; info != NULL; info = info->pr_next)
     {
       if (info->pr_lock == rwlock)
 	return info;
@@ -86,10 +57,10 @@ rwlock_is_in_list(pthread_descr self, pthread_rwlock_t *rwlock)
 static pthread_readlock_info *
 rwlock_add_to_list(pthread_descr self, pthread_rwlock_t *rwlock)
 {
-  pthread_readlock_info *info = THREAD_GETMEM (self, p_readlock_free);
+  pthread_readlock_info *info = self->p_readlock_free;
 
   if (info != NULL)
-    THREAD_SETMEM (self, p_readlock_free, info->pr_next);
+    self->p_readlock_free = info->pr_next;
   else
     info = malloc(sizeof *info);
 
@@ -98,8 +69,8 @@ rwlock_add_to_list(pthread_descr self, pthread_rwlock_t *rwlock)
 
   info->pr_lock_count = 1;
   info->pr_lock = rwlock;
-  info->pr_next = THREAD_GETMEM (self, p_readlock_list);
-  THREAD_SETMEM (self, p_readlock_list, info);
+  info->pr_next = self->p_readlock_list;
+  self->p_readlock_list = info;
 
   return info;
 }
@@ -189,12 +160,11 @@ rwlock_have_already(pthread_descr *pself, pthread_rwlock_t *rwlock,
   if (rwlock->__rw_kind == PTHREAD_RWLOCK_PREFER_WRITER_NP)
     {
       if (!self)
-	*pself = self = thread_self();
+	self = thread_self();
 
       existing = rwlock_is_in_list(self, rwlock);
 
-      if (existing != NULL
-	  || THREAD_GETMEM (self, p_untracked_readlock_count) > 0)
+      if (existing != NULL || self->p_untracked_readlock_count > 0)
 	have_lock_already = 1;
       else
 	{
@@ -206,13 +176,14 @@ rwlock_have_already(pthread_descr *pself, pthread_rwlock_t *rwlock,
 
   *pout_of_mem = out_of_mem;
   *pexisting = existing;
+  *pself = self;
 
   return have_lock_already;
 }
 
 int
-__pthread_rwlock_init (pthread_rwlock_t *rwlock,
-		       const pthread_rwlockattr_t *attr)
+pthread_rwlock_init (pthread_rwlock_t *rwlock,
+		     const pthread_rwlockattr_t *attr)
 {
   __pthread_init_lock(&rwlock->__rw_lock);
   rwlock->__rw_readers = 0;
@@ -233,11 +204,10 @@ __pthread_rwlock_init (pthread_rwlock_t *rwlock,
 
   return 0;
 }
-strong_alias (__pthread_rwlock_init, pthread_rwlock_init)
 
 
 int
-__pthread_rwlock_destroy (pthread_rwlock_t *rwlock)
+pthread_rwlock_destroy (pthread_rwlock_t *rwlock)
 {
   int readers;
   _pthread_descr writer;
@@ -252,75 +222,22 @@ __pthread_rwlock_destroy (pthread_rwlock_t *rwlock)
 
   return 0;
 }
-strong_alias (__pthread_rwlock_destroy, pthread_rwlock_destroy)
 
 int
-__pthread_rwlock_rdlock (pthread_rwlock_t *rwlock)
+pthread_rwlock_rdlock (pthread_rwlock_t *rwlock)
 {
   pthread_descr self = NULL;
   pthread_readlock_info *existing;
   int out_of_mem, have_lock_already;
 
   have_lock_already = rwlock_have_already(&self, rwlock,
-					  &existing, &out_of_mem);
-
-  if (self == NULL)
-    self = thread_self ();
+      &existing, &out_of_mem);
 
   for (;;)
     {
-      __pthread_lock (&rwlock->__rw_lock, self);
-
-      if (rwlock_can_rdlock(rwlock, have_lock_already))
-	break;
-
-      enqueue (&rwlock->__rw_read_waiting, self);
-      __pthread_unlock (&rwlock->__rw_lock);
-      suspend (self); /* This is not a cancellation point */
-    }
-
-  ++rwlock->__rw_readers;
-  __pthread_unlock (&rwlock->__rw_lock);
-
-  if (have_lock_already || out_of_mem)
-    {
-      if (existing != NULL)
-	++existing->pr_lock_count;
-      else
-	++self->p_untracked_readlock_count;
-    }
-
-  return 0;
-}
-strong_alias (__pthread_rwlock_rdlock, pthread_rwlock_rdlock)
-
-int
-__pthread_rwlock_timedrdlock (pthread_rwlock_t *rwlock,
-			      const struct timespec *abstime)
-{
-  pthread_descr self = NULL;
-  pthread_readlock_info *existing;
-  int out_of_mem, have_lock_already;
-  pthread_extricate_if extr;
-
-  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)
-    return EINVAL;
-
-  have_lock_already = rwlock_have_already(&self, rwlock,
-					  &existing, &out_of_mem);
-
-  if (self == NULL)
-    self = thread_self ();
-
-  /* Set up extrication interface */
-  extr.pu_object = rwlock;
-  extr.pu_extricate_func = rwlock_rd_extricate_func;
-
-  /* Register extrication interface */
-  __pthread_set_own_extricate_if (self, &extr);
+      if (self == NULL)
+	self = thread_self ();
 
-  for (;;)
-    {
       __pthread_lock (&rwlock->__rw_lock, self);
 
       if (rwlock_can_rdlock(rwlock, have_lock_already))
@@ -328,45 +245,25 @@ __pthread_rwlock_timedrdlock (pthread_rwlock_t *rwlock,
 
       enqueue (&rwlock->__rw_read_waiting, self);
       __pthread_unlock (&rwlock->__rw_lock);
-      /* This is not a cancellation point */
-      if (timedsuspend (self, abstime) == 0)
-	{
-	  int was_on_queue;
-
-	  __pthread_lock (&rwlock->__rw_lock, self);
-	  was_on_queue = remove_from_queue (&rwlock->__rw_read_waiting, self);
-	  __pthread_unlock (&rwlock->__rw_lock);
-
-	  if (was_on_queue)
-	    {
-	      __pthread_set_own_extricate_if (self, 0);
-	      return ETIMEDOUT;
-	    }
-
-	  /* Eat the outstanding restart() from the signaller */
-	  suspend (self);
-	}
+      suspend (self); /* This is not a cancellation point */
     }
 
-  __pthread_set_own_extricate_if (self, 0);
-
   ++rwlock->__rw_readers;
   __pthread_unlock (&rwlock->__rw_lock);
 
   if (have_lock_already || out_of_mem)
     {
       if (existing != NULL)
-	++existing->pr_lock_count;
+	existing->pr_lock_count++;
       else
-	++self->p_untracked_readlock_count;
+	self->p_untracked_readlock_count++;
     }
 
   return 0;
 }
-strong_alias (__pthread_rwlock_timedrdlock, pthread_rwlock_timedrdlock)
 
 int
-__pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock)
+pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock)
 {
   pthread_descr self = thread_self();
   pthread_readlock_info *existing;
@@ -397,19 +294,18 @@ __pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock)
       if (have_lock_already || out_of_mem)
 	{
 	  if (existing != NULL)
-	    ++existing->pr_lock_count;
+	    existing->pr_lock_count++;
 	  else
-	    ++self->p_untracked_readlock_count;
+	    self->p_untracked_readlock_count++;
 	}
     }
 
   return retval;
 }
-strong_alias (__pthread_rwlock_tryrdlock, pthread_rwlock_tryrdlock)
 
 
 int
-__pthread_rwlock_wrlock (pthread_rwlock_t *rwlock)
+pthread_rwlock_wrlock (pthread_rwlock_t *rwlock)
 {
   pthread_descr self = thread_self ();
 
@@ -429,68 +325,10 @@ __pthread_rwlock_wrlock (pthread_rwlock_t *rwlock)
       suspend (self); /* This is not a cancellation point */
     }
 }
-strong_alias (__pthread_rwlock_wrlock, pthread_rwlock_wrlock)
 
 
 int
-__pthread_rwlock_timedwrlock (pthread_rwlock_t *rwlock,
-			      const struct timespec *abstime)
-{
-  pthread_descr self;
-  pthread_extricate_if extr;
-
-  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)
-    return EINVAL;
-
-  self = thread_self ();
-
-  /* Set up extrication interface */
-  extr.pu_object = rwlock;
-  extr.pu_extricate_func =  rwlock_wr_extricate_func;
-
-  /* Register extrication interface */
-  __pthread_set_own_extricate_if (self, &extr);
-
-  while(1)
-    {
-      __pthread_lock (&rwlock->__rw_lock, self);
-
-      if (rwlock->__rw_readers == 0 && rwlock->__rw_writer == NULL)
-	{
-	  rwlock->__rw_writer = self;
-	  __pthread_set_own_extricate_if (self, 0);
-	  __pthread_unlock (&rwlock->__rw_lock);
-	  return 0;
-	}
-
-      /* Suspend ourselves, then try again */
-      enqueue (&rwlock->__rw_write_waiting, self);
-      __pthread_unlock (&rwlock->__rw_lock);
-      /* This is not a cancellation point */
-      if (timedsuspend (self, abstime) == 0)
-	{
-	  int was_on_queue;
-
-	  __pthread_lock (&rwlock->__rw_lock, self);
-	  was_on_queue = remove_from_queue (&rwlock->__rw_write_waiting, self);
-	  __pthread_unlock (&rwlock->__rw_lock);
-
-	  if (was_on_queue)
-	    {
-	      __pthread_set_own_extricate_if (self, 0);
-	      return ETIMEDOUT;
-	    }
-
-	  /* Eat the outstanding restart() from the signaller */
-	  suspend (self);
-	}
-    }
-}
-strong_alias (__pthread_rwlock_timedwrlock, pthread_rwlock_timedwrlock)
-
-
-int
-__pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock)
+pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock)
 {
   int result = EBUSY;
 
@@ -504,11 +342,10 @@ __pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock)
 
   return result;
 }
-strong_alias (__pthread_rwlock_trywrlock, pthread_rwlock_trywrlock)
 
 
 int
-__pthread_rwlock_unlock (pthread_rwlock_t *rwlock)
+pthread_rwlock_unlock (pthread_rwlock_t *rwlock)
 {
   pthread_descr torestart;
   pthread_descr th;
@@ -524,9 +361,8 @@ __pthread_rwlock_unlock (pthread_rwlock_t *rwlock)
 	}
       rwlock->__rw_writer = NULL;
 
-      if ((rwlock->__rw_kind == PTHREAD_RWLOCK_PREFER_READER_NP
-	   && !queue_is_empty(&rwlock->__rw_read_waiting))
-	  || (th = dequeue(&rwlock->__rw_write_waiting)) == NULL)
+      if (rwlock->__rw_kind == PTHREAD_RWLOCK_PREFER_READER_NP
+	  || (th = dequeue (&rwlock->__rw_write_waiting)) == NULL)
 	{
 	  /* Restart all waiting readers.  */
 	  torestart = rwlock->__rw_read_waiting;
@@ -573,22 +409,20 @@ __pthread_rwlock_unlock (pthread_rwlock_t *rwlock)
 	    {
 	      if (victim->pr_lock_count == 0)
 		{
-		  victim->pr_next = THREAD_GETMEM (self, p_readlock_free);
-		  THREAD_SETMEM (self, p_readlock_free, victim);
+		  victim->pr_next = self->p_readlock_free;
+		  self->p_readlock_free = victim;
 		}
 	    }
 	  else
 	    {
-	      int val = THREAD_GETMEM (self, p_untracked_readlock_count);
-	      if (val > 0)
-		THREAD_SETMEM (self, p_untracked_readlock_count, val - 1);
+	      if (self->p_untracked_readlock_count > 0)
+		self->p_untracked_readlock_count--;
 	    }
 	}
     }
 
   return 0;
 }
-strong_alias (__pthread_rwlock_unlock, pthread_rwlock_unlock)
 
 
 
@@ -596,18 +430,17 @@ int
 pthread_rwlockattr_init (pthread_rwlockattr_t *attr)
 {
   attr->__lockkind = 0;
-  attr->__pshared = PTHREAD_PROCESS_PRIVATE;
+  attr->__pshared = 0;
 
   return 0;
 }
 
 
 int
-__pthread_rwlockattr_destroy (pthread_rwlockattr_t *attr)
+pthread_rwlockattr_destroy (pthread_rwlockattr_t *attr attribute_unused)
 {
   return 0;
 }
-strong_alias (__pthread_rwlockattr_destroy, pthread_rwlockattr_destroy)
 
 
 int
@@ -624,10 +457,6 @@ pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int pshared)
   if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)
     return EINVAL;
 
-  /* For now it is not possible to shared a conditional variable.  */
-  if (pshared != PTHREAD_PROCESS_PRIVATE)
-    return ENOSYS;
-
   attr->__pshared = pshared;
 
   return 0;
@@ -647,7 +476,6 @@ pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *attr, int pref)
 {
   if (pref != PTHREAD_RWLOCK_PREFER_READER_NP
       && pref != PTHREAD_RWLOCK_PREFER_WRITER_NP
-      && pref != PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
       && pref != PTHREAD_RWLOCK_DEFAULT_NP)
     return EINVAL;
 
diff --git a/libpthread/linuxthreads/semaphore.c b/libpthread/linuxthreads/semaphore.c
index b66735bed..9025dfee6 100644
--- a/libpthread/linuxthreads/semaphore.c
+++ b/libpthread/linuxthreads/semaphore.c
@@ -14,15 +14,15 @@
 
 /* Semaphores a la POSIX 1003.1b */
 
-#include <errno.h>
+#include <features.h>
 #include <limits.h>
+#include <errno.h>
 #include "pthread.h"
 #include "semaphore.h"
 #include "internals.h"
 #include "spinlock.h"
 #include "restart.h"
 #include "queue.h"
-#include <not-cancel.h>
 
 int sem_init(sem_t *sem, int pshared, unsigned int value)
 {
@@ -45,7 +45,7 @@ int sem_init(sem_t *sem, int pshared, unsigned int value)
 
 static int new_sem_extricate_func(void *obj, pthread_descr th)
 {
-  __volatile__ pthread_descr self = thread_self();
+  volatile pthread_descr self = thread_self();
   sem_t *sem = obj;
   int did_remove = 0;
 
@@ -58,7 +58,7 @@ static int new_sem_extricate_func(void *obj, pthread_descr th)
 
 int sem_wait(sem_t * sem)
 {
-  __volatile__ pthread_descr self = thread_self();
+  volatile pthread_descr self = thread_self();
   pthread_extricate_if extr;
   int already_canceled = 0;
   int spurious_wakeup_count;
@@ -169,8 +169,8 @@ int sem_post(sem_t * sem)
     }
     request.req_kind = REQ_POST;
     request.req_args.post = sem;
-    TEMP_FAILURE_RETRY(write_not_cancel(__pthread_manager_request,
-					(char *) &request, sizeof(request)));
+    TEMP_FAILURE_RETRY(write(__pthread_manager_request,
+				    (char *) &request, sizeof(request)));
   }
   return 0;
 }
@@ -190,19 +190,19 @@ int sem_destroy(sem_t * sem)
   return 0;
 }
 
-sem_t *sem_open(const char *name, int oflag, ...)
+sem_t *sem_open(const char *name attribute_unused, int oflag attribute_unused, ...)
 {
   __set_errno (ENOSYS);
   return SEM_FAILED;
 }
 
-int sem_close(sem_t *sem)
+int sem_close(sem_t *sem attribute_unused)
 {
   __set_errno (ENOSYS);
   return -1;
 }
 
-int sem_unlink(const char *name)
+int sem_unlink(const char *name attribute_unused)
 {
   __set_errno (ENOSYS);
   return -1;
diff --git a/libpthread/linuxthreads/semaphore.h b/libpthread/linuxthreads/semaphore.h
index 7f3dbadfb..9a9b72c9e 100644
--- a/libpthread/linuxthreads/semaphore.h
+++ b/libpthread/linuxthreads/semaphore.h
@@ -44,7 +44,7 @@ typedef struct
 
 /* Maximum value the semaphore can have.  */
 #ifndef SEM_VALUE_MAX
-#define SEM_VALUE_MAX	(2147483647)
+#define SEM_VALUE_MAX	((int) ((~0u) >> 1))
 #endif
 
 
diff --git a/libpthread/linuxthreads/sighandler.c b/libpthread/linuxthreads/sighandler.c
deleted file mode 100644
index 9dd3e228f..000000000
--- a/libpthread/linuxthreads/sighandler.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Signal handlers */
-
-#include "internals.h"
-
-
-/* The wrapper around user-provided signal handlers */
-void __pthread_sighandler(int signo, SIGCONTEXT ctx)
-{
-  pthread_descr self;
-  char * in_sighandler;
-  self = check_thread_self();
-
-  /* If we're in a sigwait operation, just record the signal received
-     and return without calling the user's handler */
-  if (THREAD_GETMEM(self, p_sigwaiting)) {
-    THREAD_SETMEM(self, p_sigwaiting, 0);
-    THREAD_SETMEM(self, p_signal, signo);
-    return;
-  }
-  /* Record that we're in a signal handler and call the user's
-     handler function */
-  in_sighandler = THREAD_GETMEM(self, p_in_sighandler);
-  if (in_sighandler == NULL)
-    THREAD_SETMEM(self, p_in_sighandler, CURRENT_STACK_FRAME);
-  CALL_SIGHANDLER(__sighandler[signo].old, signo, ctx);
-  if (in_sighandler == NULL)
-    THREAD_SETMEM(self, p_in_sighandler, NULL);
-}
-
-/* The same, this time for real-time signals.  */
-void __pthread_sighandler_rt(int signo, struct siginfo *si,
-			     struct ucontext *uc)
-{
-  pthread_descr self;
-  char * in_sighandler;
-  self = check_thread_self();
-
-  /* If we're in a sigwait operation, just record the signal received
-     and return without calling the user's handler */
-  if (THREAD_GETMEM(self, p_sigwaiting)) {
-    THREAD_SETMEM(self, p_sigwaiting, 0);
-    THREAD_SETMEM(self, p_signal, signo);
-    return;
-  }
-  /* Record that we're in a signal handler and call the user's
-     handler function */
-  in_sighandler = THREAD_GETMEM(self, p_in_sighandler);
-  if (in_sighandler == NULL)
-    THREAD_SETMEM(self, p_in_sighandler, CURRENT_STACK_FRAME);
-  __sighandler[signo].rt(signo, si, uc);
-  if (in_sighandler == NULL)
-    THREAD_SETMEM(self, p_in_sighandler, NULL);
-}
-
-
-/* A signal handler that does nothing */
-void __pthread_null_sighandler(int sig) { }
diff --git a/libpthread/linuxthreads/signals.c b/libpthread/linuxthreads/signals.c
index 672b8e4d9..d8dbc78bd 100644
--- a/libpthread/linuxthreads/signals.c
+++ b/libpthread/linuxthreads/signals.c
@@ -16,9 +16,11 @@
 
 #include <errno.h>
 #include <signal.h>
+#include <stdio.h>
 #include "pthread.h"
 #include "internals.h"
 #include "spinlock.h"
+#include <bits/sigcontextinfo.h>
 
 int pthread_sigmask(int how, const sigset_t * newmask, sigset_t * oldmask)
 {
@@ -70,27 +72,75 @@ int pthread_kill(pthread_t thread, int signo)
     return 0;
 }
 
-union sighandler __sighandler[NSIG] =
-  { [1 ... NSIG - 1] = { (arch_sighandler_t) SIG_ERR } };
+/* User-provided signal handlers */
+typedef void (*arch_sighandler_t) __PMT ((int, SIGCONTEXT));
+static union
+{
+  arch_sighandler_t old;
+  void (*rt) (int, struct siginfo *, struct ucontext *);
+} sighandler[NSIG];
+
+/* The wrapper around user-provided signal handlers */
+static void pthread_sighandler(int signo, SIGCONTEXT ctx)
+{
+  pthread_descr self = thread_self();
+  char * in_sighandler;
+  /* If we're in a sigwait operation, just record the signal received
+     and return without calling the user's handler */
+  if (THREAD_GETMEM(self, p_sigwaiting)) {
+    THREAD_SETMEM(self, p_sigwaiting, 0);
+    THREAD_SETMEM(self, p_signal, signo);
+    return;
+  }
+  /* Record that we're in a signal handler and call the user's
+     handler function */
+  in_sighandler = THREAD_GETMEM(self, p_in_sighandler);
+  if (in_sighandler == NULL)
+    THREAD_SETMEM(self, p_in_sighandler, CURRENT_STACK_FRAME);
+  sighandler[signo].old(signo, SIGCONTEXT_EXTRA_ARGS ctx);
+  if (in_sighandler == NULL)
+    THREAD_SETMEM(self, p_in_sighandler, NULL);
+}
+
+/* The same, this time for real-time signals.  */
+static void pthread_sighandler_rt(int signo, struct siginfo *si,
+				  struct ucontext *uc)
+{
+  pthread_descr self = thread_self();
+  char * in_sighandler;
+  /* If we're in a sigwait operation, just record the signal received
+     and return without calling the user's handler */
+  if (THREAD_GETMEM(self, p_sigwaiting)) {
+    THREAD_SETMEM(self, p_sigwaiting, 0);
+    THREAD_SETMEM(self, p_signal, signo);
+    return;
+  }
+  /* Record that we're in a signal handler and call the user's
+     handler function */
+  in_sighandler = THREAD_GETMEM(self, p_in_sighandler);
+  if (in_sighandler == NULL)
+    THREAD_SETMEM(self, p_in_sighandler, CURRENT_STACK_FRAME);
+  sighandler[signo].rt(signo, si, uc);
+  if (in_sighandler == NULL)
+    THREAD_SETMEM(self, p_in_sighandler, NULL);
+}
 
 /* The wrapper around sigaction.  Install our own signal handler
    around the signal. */
-int __pthread_sigaction(int sig, const struct sigaction * act,
-			struct sigaction * oact)
+libpthread_hidden_proto(sigaction)
+int sigaction(int sig, const struct sigaction * act,
+              struct sigaction * oact)
 {
   struct sigaction newact;
   struct sigaction *newactp;
-  __sighandler_t old = SIG_DFL;
 
+#ifdef DEBUG_PT
+printf(__FUNCTION__": pthreads wrapper!\n");
+#endif
   if (sig == __pthread_sig_restart ||
       sig == __pthread_sig_cancel ||
       (sig == __pthread_sig_debug && __pthread_sig_debug > 0))
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-  if (sig > 0 && sig < NSIG)
-    old = (__sighandler_t) __sighandler[sig].old;
+    return EINVAL;
   if (act)
     {
       newact = *act;
@@ -98,46 +148,39 @@ int __pthread_sigaction(int sig, const struct sigaction * act,
 	  && sig > 0 && sig < NSIG)
 	{
 	  if (act->sa_flags & SA_SIGINFO)
-	    newact.sa_handler = (__sighandler_t) __pthread_sighandler_rt;
+	    newact.sa_handler = (__sighandler_t) pthread_sighandler_rt;
 	  else
-	    newact.sa_handler = (__sighandler_t) __pthread_sighandler;
-	  if (old == SIG_IGN || old == SIG_DFL || old == SIG_ERR)
-	    __sighandler[sig].old = (arch_sighandler_t) act->sa_handler;
+	    newact.sa_handler = (__sighandler_t) pthread_sighandler;
 	}
       newactp = &newact;
     }
   else
     newactp = NULL;
   if (__libc_sigaction(sig, newactp, oact) == -1)
-    {
-      if (act && (sig > 0 && sig < NSIG))
-	__sighandler[sig].old = (arch_sighandler_t) old;
-      return -1;
-    }
+    return -1;
+#ifdef DEBUG_PT
+printf(__FUNCTION__": sighandler installed, sigaction successful\n");
+#endif
   if (sig > 0 && sig < NSIG)
     {
-      if (oact != NULL
-	  /* We may have inherited SIG_IGN from the parent, so return the
-	     kernel's idea of the signal handler the first time
-	     through.  */
-	  && old != SIG_ERR)
-	oact->sa_handler = old;
+      if (oact != NULL)
+	oact->sa_handler = (__sighandler_t) sighandler[sig].old;
       if (act)
-	/* For the assignment it does not matter whether it's a normal
+	/* For the assignment is does not matter whether it's a normal
 	   or real-time signal.  */
-	__sighandler[sig].old = (arch_sighandler_t) act->sa_handler;
+	sighandler[sig].old = (arch_sighandler_t) act->sa_handler;
     }
   return 0;
 }
-#ifdef SHARED
-strong_alias(__pthread_sigaction, __sigaction)
-strong_alias(__pthread_sigaction, sigaction)
-#endif
+libpthread_hidden_def(sigaction)
+
+/* A signal handler that does nothing */
+static void pthread_null_sighandler(int sig attribute_unused) { }
 
 /* sigwait -- synchronously wait for a signal */
-int __pthread_sigwait(const sigset_t * set, int * sig)
+int sigwait(const sigset_t * set, int * sig)
 {
-  __volatile__ pthread_descr self = thread_self();
+  volatile pthread_descr self = thread_self();
   sigset_t mask;
   int s;
   sigjmp_buf jmpbuf;
@@ -151,18 +194,17 @@ int __pthread_sigwait(const sigset_t * set, int * sig)
      signals in set is unspecified." */
   __sigfillset(&mask);
   sigdelset(&mask, __pthread_sig_cancel);
-  for (s = 1; s < NSIG; s++) {
+  for (s = 1; s <= NSIG; s++) {
     if (sigismember(set, s) &&
         s != __pthread_sig_restart &&
         s != __pthread_sig_cancel &&
         s != __pthread_sig_debug) {
       sigdelset(&mask, s);
-      if (__sighandler[s].old == (arch_sighandler_t) SIG_ERR ||
-          __sighandler[s].old == (arch_sighandler_t) SIG_DFL ||
-          __sighandler[s].old == (arch_sighandler_t) SIG_IGN) {
-        sa.sa_handler = __pthread_null_sighandler;
-        __sigfillset(&sa.sa_mask);
-        sa.sa_flags = 0;
+      if (sighandler[s].old == NULL ||
+	  sighandler[s].old == (arch_sighandler_t) SIG_DFL ||
+	  sighandler[s].old == (arch_sighandler_t) SIG_IGN) {
+        memset(&sa, 0, sizeof(sa));
+        sa.sa_handler = pthread_null_sighandler;
         sigaction(s, &sa, NULL);
       }
     }
@@ -187,13 +229,11 @@ int __pthread_sigwait(const sigset_t * set, int * sig)
   *sig = THREAD_GETMEM(self, p_signal);
   return 0;
 }
-#ifdef SHARED
-strong_alias (__pthread_sigwait, sigwait)
-#endif
 
 /* Redefine raise() to send signal to calling thread only,
    as per POSIX 1003.1c */
-int __pthread_raise (int sig)
+libpthread_hidden_proto(raise)
+int raise (int sig)
 {
   int retcode = pthread_kill(pthread_self(), sig);
   if (retcode == 0)
@@ -203,9 +243,4 @@ int __pthread_raise (int sig)
     return -1;
   }
 }
-#ifdef SHARED
-strong_alias (__pthread_raise, raise)
-#endif
-
-/* This files handles cancellation internally.  */
-LIBC_CANCEL_HANDLED ();
+libpthread_hidden_def(raise)
diff --git a/libpthread/linuxthreads/specific.c b/libpthread/linuxthreads/specific.c
index 0daad83f5..c4bcfbf8c 100644
--- a/libpthread/linuxthreads/specific.c
+++ b/libpthread/linuxthreads/specific.c
@@ -14,6 +14,7 @@
 
 /* Thread-specific data */
 
+#include <features.h>
 #include <errno.h>
 #include <stddef.h>
 #include <stdlib.h>
@@ -21,8 +22,6 @@
 #include "internals.h"
 #include "spinlock.h"
 #include "restart.h"
-#include <bits/libc-lock.h>
-#include <not-cancel.h>
 
 /* Table of keys. */
 
@@ -39,177 +38,133 @@ static pthread_mutex_t pthread_keys_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 /* Create a new key */
 
-int __pthread_key_create(pthread_key_t * key, destr_function destr)
+int pthread_key_create(pthread_key_t * key, destr_function destr)
 {
   int i;
 
-  pthread_mutex_lock(&pthread_keys_mutex);
+  __pthread_mutex_lock(&pthread_keys_mutex);
   for (i = 0; i < PTHREAD_KEYS_MAX; i++) {
     if (! pthread_keys[i].in_use) {
       /* Mark key in use */
       pthread_keys[i].in_use = 1;
       pthread_keys[i].destr = destr;
-      pthread_mutex_unlock(&pthread_keys_mutex);
+      __pthread_mutex_unlock(&pthread_keys_mutex);
       *key = i;
       return 0;
     }
   }
-  pthread_mutex_unlock(&pthread_keys_mutex);
+  __pthread_mutex_unlock(&pthread_keys_mutex);
   return EAGAIN;
 }
-strong_alias (__pthread_key_create, pthread_key_create)
-
-/* Reset deleted key's value to NULL in each live thread.
- * NOTE: this executes in the context of the thread manager! */
-
-struct pthread_key_delete_helper_args {
-  /* Damn, we need lexical closures in C! ;) */
-  unsigned int idx1st, idx2nd;
-  pthread_descr self;
-};
-
-static void pthread_key_delete_helper(void *arg, pthread_descr th)
-{
-  struct pthread_key_delete_helper_args *args = arg;
-  unsigned int idx1st = args->idx1st;
-  unsigned int idx2nd = args->idx2nd;
-  pthread_descr self = args->self;
-
-  if (self == 0)
-    self = args->self = thread_self();
-
-  if (!th->p_terminated) {
-    /* pthread_exit() may try to free th->p_specific[idx1st] concurrently. */
-    __pthread_lock(th->p_lock, self);
-    if (th->p_specific[idx1st] != NULL)
-      th->p_specific[idx1st][idx2nd] = NULL;
-    __pthread_unlock(th->p_lock);
-  }
-}
 
 /* Delete a key */
 int pthread_key_delete(pthread_key_t key)
 {
-  pthread_descr self = thread_self();
-
-  pthread_mutex_lock(&pthread_keys_mutex);
-  if (key >= PTHREAD_KEYS_MAX || !pthread_keys[key].in_use) {
-    pthread_mutex_unlock(&pthread_keys_mutex);
-    return EINVAL;
-  }
-  pthread_keys[key].in_use = 0;
-  pthread_keys[key].destr = NULL;
-
-  /* Set the value of the key to NULL in all running threads, so
-     that if the key is reallocated later by pthread_key_create, its
-     associated values will be NULL in all threads.
-
-     If no threads have been created yet, or if we are exiting, clear
-     it just in the current thread.  */
-
-  struct pthread_key_delete_helper_args args;
-  args.idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;
-  args.idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;
-  if (__pthread_manager_request != -1
-      && !(__builtin_expect (__pthread_exit_requested, 0)))
-    {
-      struct pthread_request request;
+    pthread_descr self = thread_self();
 
-      args.self = 0;
-
-      request.req_thread = self;
-      request.req_kind = REQ_FOR_EACH_THREAD;
-      request.req_args.for_each.arg = &args;
-      request.req_args.for_each.fn = pthread_key_delete_helper;
-
-      TEMP_FAILURE_RETRY(write_not_cancel(__pthread_manager_request,
-					  (char *) &request, sizeof(request)));
-      suspend(self);
+    __pthread_mutex_lock(&pthread_keys_mutex);
+    if (key >= PTHREAD_KEYS_MAX || !pthread_keys[key].in_use) {
+	__pthread_mutex_unlock(&pthread_keys_mutex);
+	return EINVAL;
     }
-  else
+    pthread_keys[key].in_use = 0;
+    pthread_keys[key].destr = NULL;
+
+    /* Set the value of the key to NULL in all running threads, so
+       that if the key is reallocated later by pthread_key_create, its
+       associated values will be NULL in all threads.
+       Do nothing if no threads have been created yet.  */
+    if (__pthread_manager_request != -1)
     {
-      if (self->p_specific[args.idx1st] != NULL)
-	self->p_specific[args.idx1st][args.idx2nd] = NULL;
+	pthread_descr th;
+	unsigned int idx1st, idx2nd;
+
+	idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;
+	idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;
+	th = self;
+	do {
+	    /* If the thread already is terminated don't modify the memory.  */
+	    if (!th->p_terminated && th->p_specific[idx1st] != NULL)
+		th->p_specific[idx1st][idx2nd] = NULL;
+	    th = th->p_nextlive;
+	} while (th != self);
     }
 
-  pthread_mutex_unlock(&pthread_keys_mutex);
-  return 0;
+    __pthread_mutex_unlock(&pthread_keys_mutex);
+    return 0;
 }
 
 /* Set the value of a key */
 
-int __pthread_setspecific(pthread_key_t key, const void * pointer)
+int pthread_setspecific(pthread_key_t key, const void * pointer)
 {
-  pthread_descr self = thread_self();
-  unsigned int idx1st, idx2nd;
-
-  if (key >= PTHREAD_KEYS_MAX || !pthread_keys[key].in_use)
-    return EINVAL;
-  idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;
-  idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;
-  if (THREAD_GETMEM_NC(self, p_specific[idx1st]) == NULL) {
-    void *newp = calloc(PTHREAD_KEY_2NDLEVEL_SIZE, sizeof (void *));
-    if (newp == NULL)
-      return ENOMEM;
-    THREAD_SETMEM_NC(self, p_specific[idx1st], newp);
-  }
-  THREAD_GETMEM_NC(self, p_specific[idx1st])[idx2nd] = (void *) pointer;
-  return 0;
+    pthread_descr self = thread_self();
+    unsigned int idx1st, idx2nd;
+
+    if (key >= PTHREAD_KEYS_MAX || !pthread_keys[key].in_use)
+	return EINVAL;
+    idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;
+    idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;
+    if (THREAD_GETMEM_NC(self, p_specific[idx1st]) == NULL) {
+	void *newp = calloc(PTHREAD_KEY_2NDLEVEL_SIZE, sizeof (void *));
+	if (newp == NULL)
+	    return ENOMEM;
+	THREAD_SETMEM_NC(self, p_specific[idx1st], newp);
+    }
+    THREAD_GETMEM_NC(self, p_specific[idx1st])[idx2nd] = (void *) pointer;
+    return 0;
 }
-strong_alias (__pthread_setspecific, pthread_setspecific)
 
 /* Get the value of a key */
 
-void * __pthread_getspecific(pthread_key_t key)
+void * pthread_getspecific(pthread_key_t key)
 {
-  pthread_descr self = thread_self();
-  unsigned int idx1st, idx2nd;
-
-  if (key >= PTHREAD_KEYS_MAX)
-    return NULL;
-  idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;
-  idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;
-  if (THREAD_GETMEM_NC(self, p_specific[idx1st]) == NULL
-      || !pthread_keys[key].in_use)
-    return NULL;
-  return THREAD_GETMEM_NC(self, p_specific[idx1st])[idx2nd];
+    pthread_descr self = thread_self();
+    unsigned int idx1st, idx2nd;
+
+    if (key >= PTHREAD_KEYS_MAX)
+	return NULL;
+    idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;
+    idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;
+    if (THREAD_GETMEM_NC(self, p_specific[idx1st]) == NULL
+	    || !pthread_keys[key].in_use)
+	return NULL;
+    return THREAD_GETMEM_NC(self, p_specific[idx1st])[idx2nd];
 }
-strong_alias (__pthread_getspecific, pthread_getspecific)
 
 /* Call the destruction routines on all keys */
 
-void __pthread_destroy_specifics()
+void __pthread_destroy_specifics(void)
 {
-  pthread_descr self = thread_self();
-  int i, j, round, found_nonzero;
-  destr_function destr;
-  void * data;
-
-  for (round = 0, found_nonzero = 1;
-       found_nonzero && round < PTHREAD_DESTRUCTOR_ITERATIONS;
-       round++) {
-    found_nonzero = 0;
-    for (i = 0; i < PTHREAD_KEY_1STLEVEL_SIZE; i++)
-      if (THREAD_GETMEM_NC(self, p_specific[i]) != NULL)
-        for (j = 0; j < PTHREAD_KEY_2NDLEVEL_SIZE; j++) {
-          destr = pthread_keys[i * PTHREAD_KEY_2NDLEVEL_SIZE + j].destr;
-          data = THREAD_GETMEM_NC(self, p_specific[i])[j];
-          if (destr != NULL && data != NULL) {
-            THREAD_GETMEM_NC(self, p_specific[i])[j] = NULL;
-            destr(data);
-            found_nonzero = 1;
-          }
-        }
-  }
-  __pthread_lock(THREAD_GETMEM(self, p_lock), self);
-  for (i = 0; i < PTHREAD_KEY_1STLEVEL_SIZE; i++) {
-    if (THREAD_GETMEM_NC(self, p_specific[i]) != NULL) {
-      void *p = THREAD_GETMEM_NC(self, p_specific[i]);
-      THREAD_SETMEM_NC(self, p_specific[i], NULL);
-      free(p);
+    pthread_descr self = thread_self();
+    int i, j, round, found_nonzero;
+    destr_function destr;
+    void * data;
+
+    for (round = 0, found_nonzero = 1;
+	    found_nonzero && round < PTHREAD_DESTRUCTOR_ITERATIONS;
+	    round++) {
+	found_nonzero = 0;
+	for (i = 0; i < PTHREAD_KEY_1STLEVEL_SIZE; i++)
+	    if (THREAD_GETMEM_NC(self, p_specific[i]) != NULL)
+		for (j = 0; j < PTHREAD_KEY_2NDLEVEL_SIZE; j++) {
+		    destr = pthread_keys[i * PTHREAD_KEY_2NDLEVEL_SIZE + j].destr;
+		    data = THREAD_GETMEM_NC(self, p_specific[i])[j];
+		    if (destr != NULL && data != NULL) {
+			THREAD_GETMEM_NC(self, p_specific[i])[j] = NULL;
+			destr(data);
+			found_nonzero = 1;
+		    }
+		}
     }
-  }
-  __pthread_unlock(THREAD_GETMEM(self, p_lock));
+    __pthread_lock(THREAD_GETMEM(self, p_lock), self);
+    for (i = 0; i < PTHREAD_KEY_1STLEVEL_SIZE; i++) {
+	if (THREAD_GETMEM_NC(self, p_specific[i]) != NULL) {
+	    free(THREAD_GETMEM_NC(self, p_specific[i]));
+	    THREAD_SETMEM_NC(self, p_specific[i], NULL);
+	}
+    }
+    __pthread_unlock(THREAD_GETMEM(self, p_lock));
 }
 
 #if !defined __UCLIBC_HAS_TLS__ && defined __UCLIBC_HAS_RPC__
diff --git a/libpthread/linuxthreads/spinlock.c b/libpthread/linuxthreads/spinlock.c
index f0cf19c54..80aeda529 100644
--- a/libpthread/linuxthreads/spinlock.c
+++ b/libpthread/linuxthreads/spinlock.c
@@ -24,6 +24,8 @@
 #include "spinlock.h"
 #include "restart.h"
 
+libpthread_hidden_proto(nanosleep)
+
 static void __pthread_acquire(int * spinlock);
 
 static __inline__ void __pthread_release(int * spinlock)
@@ -63,7 +65,6 @@ void internal_function __pthread_lock(struct _pthread_fastlock * lock,
 #if defined HAS_COMPARE_AND_SWAP
   long oldstatus, newstatus;
   int successful_seizure, spurious_wakeup_count;
-  int spin_count;
 #endif
 
 #if defined TEST_FOR_COMPARE_AND_SWAP
@@ -83,11 +84,11 @@ void internal_function __pthread_lock(struct _pthread_fastlock * lock,
     return;
 
   spurious_wakeup_count = 0;
-  spin_count = 0;
 
   /* On SMP, try spinning to get the lock. */
-
+#if 0
   if (__pthread_smp_kernel) {
+    int spin_count;
     int max_count = lock->__spinlock * 2 + 10;
 
     if (max_count > MAX_ADAPTIVE_SPIN_COUNT)
@@ -111,6 +112,7 @@ void internal_function __pthread_lock(struct _pthread_fastlock * lock,
 
     lock->__spinlock += (spin_count - lock->__spinlock) / 8;
   }
+#endif
 
 again:
 
@@ -615,8 +617,6 @@ void __pthread_alt_unlock(struct _pthread_fastlock *lock)
     if (maxprio == INT_MIN)
       continue;
 
-    ASSERT (p_max_prio != (struct wait_node *) 1);
-
     /* Now we want to to remove the max priority thread's wait node from
        the list. Before we can do this, we must atomically try to change the
        node's abandon state from zero to nonzero. If we succeed, that means we
@@ -637,20 +637,8 @@ void __pthread_alt_unlock(struct _pthread_fastlock *lock)
 #if defined HAS_COMPARE_AND_SWAP
 	wait_node_dequeue(pp_head, pp_max_prio, p_max_prio);
 #endif
-
-      /* Release the spinlock *before* restarting.  */
-#if defined TEST_FOR_COMPARE_AND_SWAP
-      if (!__pthread_has_cas)
-#endif
-#if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
-	{
-	  __pthread_release(&lock->__spinlock);
-	}
-#endif
-
       restart(p_max_prio->thr);
-
-      return;
+      break;
     }
   }
 
diff --git a/libpthread/linuxthreads/spinlock.h b/libpthread/linuxthreads/spinlock.h
index 2a3c2277f..7117898f7 100644
--- a/libpthread/linuxthreads/spinlock.h
+++ b/libpthread/linuxthreads/spinlock.h
@@ -172,8 +172,7 @@ static __inline__ int __pthread_alt_trylock (struct _pthread_fastlock * lock)
 
 /* Operations on pthread_atomic, which is defined in internals.h */
 
-static __inline__ long
-pthread_atomic_increment (struct pthread_atomic *pa)
+static __inline__ long atomic_increment(struct pthread_atomic *pa)
 {
     long oldval;
 
@@ -185,8 +184,7 @@ pthread_atomic_increment (struct pthread_atomic *pa)
 }
 
 
-static __inline__ long
-pthread_atomic_decrement (struct pthread_atomic *pa)
+static __inline__ long atomic_decrement(struct pthread_atomic *pa)
 {
     long oldval;
 
@@ -198,7 +196,7 @@ pthread_atomic_decrement (struct pthread_atomic *pa)
 }
 
 
-static __inline__ __attribute__((always_inline)) void
+static __inline__ void
 __pthread_set_own_extricate_if (pthread_descr self, pthread_extricate_if *peif)
 {
   /* Only store a non-null peif if the thread has cancellation enabled.
diff --git a/libpthread/linuxthreads/sysdeps/alpha/elf/pt-initfini.c b/libpthread/linuxthreads/sysdeps/alpha/elf/pt-initfini.c
deleted file mode 100644
index 6cdc69d58..000000000
--- a/libpthread/linuxthreads/sysdeps/alpha/elf/pt-initfini.c
+++ /dev/null
@@ -1,89 +0,0 @@
-/* Special .init and .fini section support for Alpha.  Linuxthreads version.
-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-/* This file is compiled into assembly code which is then munged by a sed
-   script into two files: crti.s and crtn.s.
-
-   * crti.s puts a function prologue at the beginning of the .init and .fini
-   sections and defines global symbols for those addresses, so they can be
-   called as functions.
-
-   * crtn.s puts the corresponding function epilogues in the .init and .fini
-   sections.
-
-   This differs from what would be generated by the generic code in that
-   we save and restore the GP within the function.  In order for linker
-   relaxation to work, the value in the GP register on exit from a function
-   must be valid for the function entry point.  Normally, a function is
-   contained within one object file and this is not an issue, provided
-   that the function reloads the gp after making any function calls.
-   However, _init and _fini are constructed from pieces of many object
-   files, all of which may have different GP values.  So we must reload
-   the GP value from crti.o in crtn.o.  */
-
-__asm__ ("						\n\
-#include \"defs.h\"					\n\
-							\n\
-/*@HEADER_ENDS*/					\n\
-							\n\
-/*@_init_PROLOG_BEGINS*/				\n\
-	.section .init, \"ax\", @progbits		\n\
-	.globl	_init					\n\
-	.type	_init,@function				\n\
-	.usepv	_init,std				\n\
-_init:							\n\
-	ldgp	$29, 0($27)				\n\
-	subq	$30, 16, $30				\n\
-	stq	$26, 0($30)				\n\
-	stq	$29, 8($30)				\n\
-	jsr	$26, __pthread_initialize_minimal	\n\
-	ldq	$29, 8($30)				\n\
-	.align 3					\n\
-/*@_init_PROLOG_ENDS*/					\n\
-							\n\
-/*@_init_EPILOG_BEGINS*/				\n\
-	.section .init, \"ax\", @progbits		\n\
-	ldq	$26, 0($30)				\n\
-	ldq	$29, 8($30)				\n\
-	addq	$30, 16, $30				\n\
-	ret						\n\
-/*@_init_EPILOG_ENDS*/					\n\
-							\n\
-/*@_fini_PROLOG_BEGINS*/				\n\
-	.section .fini, \"ax\", @progbits		\n\
-	.globl	_fini					\n\
-	.type	_fini,@function				\n\
-	.usepv	_fini,std				\n\
-_fini:							\n\
-	ldgp	$29, 0($27)				\n\
-	subq	$30, 16, $30				\n\
-	stq	$26, 0($30)				\n\
-	stq	$29, 8($30)				\n\
-	.align 3					\n\
-/*@_fini_PROLOG_ENDS*/					\n\
-							\n\
-/*@_fini_EPILOG_BEGINS*/				\n\
-	.section .fini, \"ax\", @progbits		\n\
-	ldq	$26, 0($30)				\n\
-	ldq	$29, 8($30)				\n\
-	addq	$30, 16, $30				\n\
-	ret						\n\
-/*@_fini_EPILOG_ENDS*/					\n\
-							\n\
-/*@TRAILER_BEGINS*/					\n\
-");
diff --git a/libpthread/linuxthreads/sysdeps/alpha/pspinlock.c b/libpthread/linuxthreads/sysdeps/alpha/pspinlock.c
deleted file mode 100644
index cdf4be99c..000000000
--- a/libpthread/linuxthreads/sysdeps/alpha/pspinlock.c
+++ /dev/null
@@ -1,109 +0,0 @@
-/* POSIX spinlock implementation.  Alpha version.
-   Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-
-
-/* This implementation is similar to the one used in the Linux kernel.
-   But the kernel is byte instructions for the memory access.  This is
-   faster but unusable here.  The problem is that only 128
-   threads/processes could use the spinlock at the same time.  If (by
-   a design error in the program) a thread/process would hold the
-   spinlock for a time long enough to accumulate 128 waiting
-   processes, the next one will find a positive value in the spinlock
-   and assume it is unlocked.  We cannot accept that.  */
-
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  unsigned int tmp;
-  __asm__ __volatile__
-    ("1:	ldl_l	%0,%1\n"
-     "		blbs	%0,2f\n"
-     "		or	%0,1,%0\n"
-     "		stl_c	%0,%1\n"
-     "		beq	%0,2f\n"
-     "		mb\n"
-     ".subsection 2\n"
-     "2:	ldl	%0,%1\n"
-     "		blbs	%0,2b\n"
-     "		br	1b\n"
-     ".previous"
-     : "=r" (tmp), "=m" (lock)
-     : "m" (lock));
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  unsigned long int oldval;
-  unsigned long int temp;
-
-  __asm__ __volatile__
-    ("1:	ldl_l	%0,%1\n"
-     "		and	%0,%3,%2\n"
-     "		bne	%2,2f\n"
-     "		xor	%0,%3,%0\n"
-     "		stl_c	%0,%1\n"
-     "		beq	%0,3f\n"
-     "		mb\n"
-     "2:\n"
-     ".subsection 2\n"
-     "3:	br	1b\n"
-     ".previous"
-     : "=&r" (temp), "=m" (*lock), "=&r" (oldval)
-     : "Ir" (1UL), "m" (*lock));
-
-  return oldval == 0 ? 0 : EBUSY;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  __asm__ __volatile__ ("mb");
-  return *lock = 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  *lock = 0;
-  return 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/alpha/tls.h b/libpthread/linuxthreads/sysdeps/alpha/tls.h
deleted file mode 100644
index 51c7fea8b..000000000
--- a/libpthread/linuxthreads/sysdeps/alpha/tls.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/* Definitions for thread-local data handling.  linuxthreads/Alpha version.
-   Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _TLS_H
-#define _TLS_H
-
-#ifndef __ASSEMBLER__
-
-# include <pt-machine.h>
-# include <stdbool.h>
-# include <stddef.h>
-
-/* Type for the dtv.  */
-typedef union dtv
-{
-  size_t counter;
-  struct
-  {
-    void *val;
-    bool is_static;
-  } pointer;
-} dtv_t;
-
-
-typedef struct
-{
-  dtv_t *dtv;
-
-  /* Reserved for the thread implementation.  Unused in LinuxThreads.  */
-  void *private;
-} tcbhead_t;
-#endif
-
-
-#ifdef HAVE_TLS_SUPPORT
-
-/* Signal that TLS support is available.  */
-# define USE_TLS	1
-
-# ifndef __ASSEMBLER__
-/* Get system call information.  */
-#  include <sysdep.h>
-
-/* This is the size of the initial TCB.  */
-#  define TLS_INIT_TCB_SIZE	sizeof (tcbhead_t)
-
-/* Alignment requirements for the initial TCB.  */
-#  define TLS_INIT_TCB_ALIGN	__alignof__ (tcbhead_t)
-
-/* This is the size of the TCB.  */
-#  define TLS_TCB_SIZE		sizeof (tcbhead_t)
-
-/* Alignment requirements for the TCB.  */
-#  define TLS_TCB_ALIGN		__alignof__ (tcbhead_t)
-
-/* This is the size we need before TCB.  */
-#  define TLS_PRE_TCB_SIZE	sizeof (struct _pthread_descr_struct)
-
-/* The DTV is allocated at the TP; the TCB is placed elsewhere.  */
-#  define TLS_DTV_AT_TP 1
-
-/* Install the dtv pointer.  The pointer passed is to the element with
-   index -1 which contain the length.  */
-#  define INSTALL_DTV(TCBP, DTVP) \
-  (((tcbhead_t *) (TCBP))->dtv = (DTVP) + 1)
-
-/* Install new dtv for current thread.  */
-#  define INSTALL_NEW_DTV(DTV) \
-  (((tcbhead_t *)__builtin_thread_pointer ())->dtv = (DTV))
-
-/* Return dtv of given thread descriptor.  */
-#  define GET_DTV(TCBP) \
-  (((tcbhead_t *) (TCBP))->dtv)
-
-/* Code to initially initialize the thread pointer.  This might need
-   special attention since 'errno' is not yet available and if the
-   operation can cause a failure 'errno' must not be touched.  */
-# define TLS_INIT_TP(TCBP, SECONDCALL) \
-  (__builtin_set_thread_pointer (TCBP), 0)
-
-/* Return the address of the dtv for the current thread.  */
-#  define THREAD_DTV() \
-  (((tcbhead_t *)__builtin_thread_pointer ())->dtv)
-
-/* Return the thread descriptor for the current thread.  */
-#  undef THREAD_SELF
-#  define THREAD_SELF \
-  ((pthread_descr)__builtin_thread_pointer () - 1)
-
-#  undef INIT_THREAD_SELF
-#  define INIT_THREAD_SELF(DESCR, NR) \
-  __builtin_set_thread_pointer ((struct _pthread_descr_struct *)(DESCR) + 1)
-
-/* Get the thread descriptor definition.  */
-#  include <linuxthreads/descr.h>
-
-/* ??? Generic bits of LinuxThreads may call these macros with
-   DESCR set to NULL.  We are expected to be able to reference
-   the "current" value.
-
-   In our case, we'd really prefer to use DESCR, since lots of
-   PAL_code calls would be expensive.  We can only trust that
-   the compiler does its job and unifies the multiple
-   __builtin_thread_pointer instances.  */
-
-#define THREAD_GETMEM(descr, member) \
-  ((void) sizeof (descr), THREAD_SELF->member)
-#define THREAD_GETMEM_NC(descr, member) \
-  ((void) sizeof (descr), THREAD_SELF->member)
-#define THREAD_SETMEM(descr, member, value) \
-  ((void) sizeof (descr), THREAD_SELF->member = (value))
-#define THREAD_SETMEM_NC(descr, member, value) \
-  ((void) sizeof (descr), THREAD_SELF->member = (value))
-
-# endif	/* HAVE_TLS_SUPPORT */
-#endif /* __ASSEMBLER__ */
-
-#endif	/* tls.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/arc/pt-machine.h b/libpthread/linuxthreads/sysdeps/arc/pt-machine.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/arc/pt-machine.h
rename to libpthread/linuxthreads/sysdeps/arc/pt-machine.h
diff --git a/libpthread/linuxthreads/sysdeps/arm/pspinlock.c b/libpthread/linuxthreads/sysdeps/arm/pspinlock.c
deleted file mode 100644
index 691085270..000000000
--- a/libpthread/linuxthreads/sysdeps/arm/pspinlock.c
+++ /dev/null
@@ -1,81 +0,0 @@
-/* POSIX spinlock implementation.  Arm version.
-   Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-
-
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  unsigned int val;
-
-  do
-    __asm__ __volatile__ ("swp %0, %1, [%2]"
-		  : "=r" (val)
-		  : "0" (1), "r" (lock)
-		  : "memory");
-  while (val != 0);
-
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  unsigned int val;
-
-  __asm__ __volatile__ ("swp %0, %1, [%2]"
-		: "=r" (val)
-		: "0" (1), "r" (lock)
-		: "memory");
-
-  return val ? EBUSY : 0;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  return *lock = 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  return *lock = 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/arm/pt-machine.h b/libpthread/linuxthreads/sysdeps/arm/pt-machine.h
index 0a455b97d..2b877f980 100644
--- a/libpthread/linuxthreads/sysdeps/arm/pt-machine.h
+++ b/libpthread/linuxthreads/sysdeps/arm/pt-machine.h
@@ -1,6 +1,6 @@
 /* Machine-dependent pthreads configuration and inline functions.
    ARM version.
-   Copyright (C) 1997, 1998, 2000, 2002, 2003 Free Software Foundation, Inc.
+   Copyright (C) 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Philip Blundell <philb@gnu.org>.
 
@@ -21,29 +21,86 @@
 #ifndef _PT_MACHINE_H
 #define _PT_MACHINE_H   1
 
-#include <features.h>
+#include <sys/syscall.h>
+#include <unistd.h>
 
 #ifndef PT_EI
 # define PT_EI __extern_always_inline
 #endif
 
+#if defined(__thumb__)
+#if defined(__USE_LDREXSTREX__)
+PT_EI long int ldrex(int *spinlock)
+{
+	long int ret;
+	__asm__ __volatile__(
+		"ldrex %0, [%1]\n"
+		: "=r"(ret)
+		: "r"(spinlock) : "memory");
+	return ret;
+}
+
+PT_EI long int strex(int val, int *spinlock)
+{
+	long int ret;
+	__asm__ __volatile__(
+		"strex %0, %1, [%2]\n"
+		: "=r"(ret)
+		: "r" (val), "r"(spinlock) : "memory");
+	return ret;
+}
+
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+  register unsigned int ret;
+
+  do {
+	  ret = ldrex(spinlock);
+  } while (strex(1, spinlock));
+
+  return ret;
+}
+
+#else /* __USE_LDREXSTREX__ */
+
 /* This will not work on ARM1 or ARM2 because SWP is lacking on those
    machines.  Unfortunately we have no way to detect this at compile
    time; let's hope nobody tries to use one.  */
 
 /* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
+PT_EI long int testandset (int *spinlock);
+PT_EI long int testandset (int *spinlock)
 {
   register unsigned int ret;
+  void *pc;
+  __asm__ __volatile__(
+	".align 0\n"
+	"\tbx pc\n"
+	"\tnop\n"
+	"\t.arm\n"
+	"\tswp %0, %2, [%3]\n"
+	"\torr %1, pc, #1\n"
+	"\tbx %1\n"
+	"\t.force_thumb"
+	: "=r"(ret), "=r"(pc)
+	: "0"(1), "r"(spinlock));
+  return ret;
+}
+#endif
+#else /* __thumb__ */
 
+PT_EI long int testandset (int *spinlock);
+PT_EI long int testandset (int *spinlock)
+{
+  register unsigned int ret;
   __asm__ __volatile__("swp %0, %1, [%2]"
 		       : "=r"(ret)
 		       : "0"(1), "r"(spinlock));
-
   return ret;
 }
-
+#endif
 
 /* Get some notion of the current stack.  Need not be exactly the top
    of the stack, just something somewhere in the current frame.  */
diff --git a/libpthread/linuxthreads/sysdeps/arm/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/arm/sysdep-cancel.h
deleted file mode 100644
index ba6a1e04b..000000000
--- a/libpthread/linuxthreads/sysdeps/arm/sysdep-cancel.h
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <sysdep.h>
-
-/* No multi-thread handling enabled.  */
-#define SINGLE_THREAD_P (1)
-#define RTLD_SINGLE_THREAD_P (1)
-#define LIBC_CANCEL_ASYNC()	0 /* Just a dummy value.  */
-#define LIBC_CANCEL_RESET(val)	((void)(val)) /* Nothing, but evaluate it.  */
-#define LIBC_CANCEL_HANDLED()	/* Nothing.  */
diff --git a/libpthread/linuxthreads/sysdeps/arm/tls.h b/libpthread/linuxthreads/sysdeps/arm/tls.h
deleted file mode 100644
index df8d97009..000000000
--- a/libpthread/linuxthreads/sysdeps/arm/tls.h
+++ /dev/null
@@ -1,171 +0,0 @@
-/* Definitions for thread-local data handling.  linuxthreads/ARM version.
-   Copyright (C) 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _TLS_H
-#define _TLS_H
-
-#ifndef __ASSEMBLER__
-
-# include <stdbool.h>
-# include <pt-machine.h>
-# include <stddef.h>
-
-/* Type for the dtv.  */
-typedef union dtv
-{
-  size_t counter;
-  struct
-  {
-    void *val;
-    bool is_static;
-  } pointer;
-} dtv_t;
-
-typedef struct
-{
-  dtv_t *dtv;
-
-  /* Reserved for the thread implementation.  Unused in LinuxThreads.  */
-  void *private;
-} tcbhead_t;
-#endif
-
-
-/* We can support TLS only if the floating-stack support is available.
-   However, we want to compile in the support and test at runtime whether
-   the running kernel can support it or not.  To avoid bothering with the
-   TLS support code at all, use configure --without-tls.
-
-   We need USE_TLS to be consistently defined, for ldsodefs.h conditionals.
-   But some of the code below can cause problems in building libpthread
-   (e.g. useldt.h will defined FLOATING_STACKS when it shouldn't).  */
-
-/* LinuxThreads can only support TLS if both floating stacks and support
-   from the tools are available.
-
-   We have to define USE_TLS consistently, or ldsodefs.h will lay out types
-   differently between an NPTL build and a LinuxThreads build.  It can be set
-   for libc.so and not libpthread.so, but only if we provide appropriate padding
-   in the _pthread_descr_struct.
-
-   Currently nothing defines FLOATING_STACKS.  We could assume this based on
-   kernel version once the TLS patches are available in kernel.org.
-
-   To avoid bothering with the TLS support code at all, use configure
-   --without-tls.  */
-
-#if defined HAVE_TLS_SUPPORT \
-    && (defined FLOATING_STACKS || !defined IS_IN_libpthread)
-
-/* Signal that TLS support is available.  */
-# define USE_TLS	1
-
-/* Include padding in _pthread_descr_struct so that libc can find p_errno,
-   if libpthread will only include the padding because of the !IS_IN_libpthread
-   check.  */
-#ifndef FLOATING_STACKS
-# define INCLUDE_TLS_PADDING	1
-#endif
-
-# ifndef __ASSEMBLER__
-/* Get system call information.  */
-#  include <sysdep.h>
-
-/* This is the size of the initial TCB.  */
-#  define TLS_INIT_TCB_SIZE	sizeof (tcbhead_t)
-
-/* Alignment requirements for the initial TCB.  */
-#  define TLS_INIT_TCB_ALIGN	__alignof__ (tcbhead_t)
-
-/* This is the size of the TCB.  */
-#  define TLS_TCB_SIZE		sizeof (tcbhead_t)
-
-/* Alignment requirements for the TCB.  */
-#  define TLS_TCB_ALIGN		__alignof__ (tcbhead_t)
-
-/* This is the size we need before TCB.  */
-#  define TLS_PRE_TCB_SIZE	sizeof (struct _pthread_descr_struct)
-
-/* The DTV is allocated at the TP; the TCB is placed elsewhere.  */
-#  define TLS_DTV_AT_TP 1
-
-/* Install the dtv pointer.  The pointer passed is to the element with
-   index -1 which contain the length.  */
-#  define INSTALL_DTV(TCBP, DTVP) \
-  (((tcbhead_t *) (TCBP))->dtv = (DTVP) + 1)
-
-/* Install new dtv for current thread.  */
-#  define INSTALL_NEW_DTV(DTV) \
-  (((tcbhead_t *)__builtin_thread_pointer ())->dtv = (DTV))
-
-/* Return dtv of given thread descriptor.  */
-#  define GET_DTV(TCBP) \
-  (((tcbhead_t *) (TCBP))->dtv)
-
-/* Code to initially initialize the thread pointer.  This might need
-   special attention since 'errno' is not yet available and if the
-   operation can cause a failure 'errno' must not be touched.  */
-# define TLS_INIT_TP(TCBP, SECONDCALL) \
-  ({ INTERNAL_SYSCALL_DECL (err);					\
-     long result_var;							\
-     result_var = INTERNAL_SYSCALL_ARM (set_tls, err, 1, (TCBP));	\
-     INTERNAL_SYSCALL_ERROR_P (result_var, err)				\
-       ? "unknown error" : NULL; })
-
-/* Return the address of the dtv for the current thread.  */
-#  define THREAD_DTV() \
-  (((tcbhead_t *)__builtin_thread_pointer ())->dtv)
-
-/* Return the thread descriptor for the current thread.  */
-#  undef THREAD_SELF
-#  define THREAD_SELF \
-  ((pthread_descr)__builtin_thread_pointer () - 1)
-
-#  undef INIT_THREAD_SELF
-#  define INIT_THREAD_SELF(DESCR, NR) \
-  TLS_INIT_TP ((struct _pthread_descr_struct *)(DESCR) + 1, 0)
-
-/* Get the thread descriptor definition.  */
-#  include <linuxthreads/descr.h>
-
-/* ??? Generic bits of LinuxThreads may call these macros with
-   DESCR set to NULL.  We are expected to be able to reference
-   the "current" value.
-
-   In our case, we'd really prefer to use DESCR, since lots of
-   PAL_code calls would be expensive.  We can only trust that
-   the compiler does its job and unifies the multiple
-   __builtin_thread_pointer instances.  */
-
-#define THREAD_GETMEM(descr, member) \
-  ((void) sizeof (descr), THREAD_SELF->member)
-#define THREAD_GETMEM_NC(descr, member) \
-  ((void) sizeof (descr), THREAD_SELF->member)
-#define THREAD_SETMEM(descr, member, value) \
-  ((void) sizeof (descr), THREAD_SELF->member = (value))
-#define THREAD_SETMEM_NC(descr, member, value) \
-  ((void) sizeof (descr), THREAD_SELF->member = (value))
-
-/* Initializing the thread pointer will generate a SIGILL if the syscall
-   is not available.  */
-#define TLS_INIT_TP_EXPENSIVE 1
-
-# endif	/* HAVE_TLS_SUPPORT */
-#endif /* __ASSEMBLER__ */
-
-#endif	/* tls.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/bfin/pt-machine.h b/libpthread/linuxthreads/sysdeps/bfin/pt-machine.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/bfin/pt-machine.h
rename to libpthread/linuxthreads/sysdeps/bfin/pt-machine.h
diff --git a/libpthread/linuxthreads.old/sysdeps/c6x/pt-machine.h b/libpthread/linuxthreads/sysdeps/c6x/pt-machine.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/c6x/pt-machine.h
rename to libpthread/linuxthreads/sysdeps/c6x/pt-machine.h
diff --git a/libpthread/linuxthreads/sysdeps/cris/pspinlock.c b/libpthread/linuxthreads/sysdeps/cris/pspinlock.c
deleted file mode 100644
index 7e3e62959..000000000
--- a/libpthread/linuxthreads/sysdeps/cris/pspinlock.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/* POSIX spinlock implementation.  CRIS version.
-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-
-/* FIXME: These are just dummies.  I don't know why or if they're needed;
-   configury should default to these definitions.  We just follow the
-   crowd here.  */
-
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  while (testandset (lock) != 0)
-    ;
-
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  return testandset (lock) != 0 ? EBUSY : 0;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  return *lock = 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  return *lock = 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/cris/pt-machine.h b/libpthread/linuxthreads/sysdeps/cris/pt-machine.h
index 9b2acb761..a89579ee0 100644
--- a/libpthread/linuxthreads/sysdeps/cris/pt-machine.h
+++ b/libpthread/linuxthreads/sysdeps/cris/pt-machine.h
@@ -14,9 +14,8 @@
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   see <http://www.gnu.org/licenses/>.  */
 #ifndef _PT_MACHINE_H
 #define _PT_MACHINE_H   1
 
@@ -33,6 +32,19 @@ testandset (int *spinlock)
 
   /* Note the use of a dummy output of *spinlock to expose the write.  The
      memory barrier is to stop *other* writes being moved past this code.  */
+
+#ifdef __arch_v32
+  __asm__ __volatile__("clearf p\n"
+		       "0:\n\t"
+		       "movu.b [%2],%0\n\t"
+		       "ax\n\t"
+		       "move.b %3,[%2]\n\t"
+		       "bcs 0b\n\t"
+		       "clearf p"
+		       : "=&r" (ret), "=m" (*spinlock)
+		       : "r" (spinlock), "r" ((int) 1), "m" (*spinlock)
+		       : "memory");
+#else  /* not __arch_v32 */
   __asm__ __volatile__("clearf\n"
 		       "0:\n\t"
 		       "movu.b [%2],%0\n\t"
@@ -41,8 +53,9 @@ testandset (int *spinlock)
 		       "bwf 0b\n\t"
 		       "clearf"
 		       : "=&r" (ret), "=m" (*spinlock)
-		       : "r" (spinlock), "r" ((int) 1)
+		       : "r" (spinlock), "r" ((int) 1), "m" (*spinlock)
 		       : "memory");
+#endif /* __arch_v32 */
   return ret;
 }
 
diff --git a/libpthread/linuxthreads.old/sysdeps/frv/pt-machine.h b/libpthread/linuxthreads/sysdeps/frv/pt-machine.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/frv/pt-machine.h
rename to libpthread/linuxthreads/sysdeps/frv/pt-machine.h
diff --git a/libpthread/linuxthreads.old/sysdeps/h8300/pt-machine.h b/libpthread/linuxthreads/sysdeps/h8300/pt-machine.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/h8300/pt-machine.h
rename to libpthread/linuxthreads/sysdeps/h8300/pt-machine.h
diff --git a/libpthread/linuxthreads/sysdeps/hppa/pspinlock.c b/libpthread/linuxthreads/sysdeps/hppa/pspinlock.c
deleted file mode 100644
index 1a6aa64a9..000000000
--- a/libpthread/linuxthreads/sysdeps/hppa/pspinlock.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/* POSIX spinlock implementation.  hppa version.
-   Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  unsigned int val;
-
-  do
-    __asm__ __volatile__ ("ldcw %1,%0"
-		  : "=r" (val), "=m" (*lock)
-		  : "m" (*lock));
-  while (!val);
-
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  unsigned int val;
-
-  __asm__ __volatile__ ("ldcw %1,%0"
-		: "=r" (val), "=m" (*lock)
-		: "m" (*lock));
-
-  return val ? 0 : EBUSY;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  *lock = 1;
-  return 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  *lock = 1;
-  return 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/hppa/pt-machine.h b/libpthread/linuxthreads/sysdeps/hppa/pt-machine.h
deleted file mode 100644
index 85c453c77..000000000
--- a/libpthread/linuxthreads/sysdeps/hppa/pt-machine.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   hppa version.
-   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Richard Henderson <rth@tamu.edu>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#include <features.h>
-#include <bits/initspin.h>
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  stack_pointer
-register char * stack_pointer __asm__ ("%r30");
-
-
-/* The hppa only has one atomic read and modify memory operation,
-   load and clear, so hppa spinlocks must use zero to signify that
-   someone is holding the lock.  */
-
-#define xstr(s) str(s)
-#define str(s) #s
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
-{
-  int ret;
-
-  __asm__ __volatile__(
-       "ldcw 0(%2),%0"
-       : "=r"(ret), "=m"(*spinlock)
-       : "r"(spinlock));
-
-  return ret == 0;
-}
-#undef str
-#undef xstr
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads/sysdeps/i386/i686/pt-machine.h b/libpthread/linuxthreads/sysdeps/i386/i686/pt-machine.h
deleted file mode 100644
index 2e52abe2e..000000000
--- a/libpthread/linuxthreads/sysdeps/i386/i686/pt-machine.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   i686 version.
-   Copyright (C) 1996-2001, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Richard Henderson <rth@tamu.edu>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H	1
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-#include <bits/kernel-features.h>
-
-#ifndef __ASSEMBLER__
-extern long int testandset (int *spinlock);
-extern int __compare_and_swap (long int *p, long int oldval, long int newval);
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  __builtin_frame_address (0)
-
-
-/* Spinlock implementation; required.  */
-PT_EI long int
-testandset (int *spinlock)
-{
-  long int ret;
-
-  __asm__ __volatile__ (
-	"xchgl %0, %1"
-	: "=r" (ret), "=m" (*spinlock)
-	: "0" (1), "m" (*spinlock)
-	: "memory");
-
-  return ret;
-}
-
-
-/* Compare-and-swap for semaphores.  It's always available on i686.  */
-#define HAS_COMPARE_AND_SWAP
-
-PT_EI int
-__compare_and_swap (long int *p, long int oldval, long int newval)
-{
-  char ret;
-  long int readval;
-
-  __asm__ __volatile__ ("lock; cmpxchgl %3, %1; sete %0"
-			: "=q" (ret), "=m" (*p), "=a" (readval)
-			: "r" (newval), "m" (*p), "a" (oldval)
-			: "memory");
-  return ret;
-}
-#endif
-
-#if __ASSUME_LDT_WORKS > 0
-#include "../useldt.h"
-#endif
-
-/* The P4 and above really want some help to prevent overheating.  */
-#define BUSY_WAIT_NOP	__asm__ ("rep; nop")
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads/sysdeps/i386/pspinlock.c b/libpthread/linuxthreads/sysdeps/i386/pspinlock.c
deleted file mode 100644
index 7936735f9..000000000
--- a/libpthread/linuxthreads/sysdeps/i386/pspinlock.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/* POSIX spinlock implementation.  x86 version.
-   Copyright (C) 2000, 2002, 2006 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-#include <bits/kernel-features.h>
-
-
-/* This implementation is similar to the one used in the Linux kernel.
-   But the kernel is byte instructions for the memory access.  This is
-   faster but unusable here.  The problem is that only 128
-   threads/processes could use the spinlock at the same time.  If (by
-   a design error in the program) a thread/process would hold the
-   spinlock for a time long enough to accumulate 128 waiting
-   processes, the next one will find a positive value in the spinlock
-   and assume it is unlocked.  We cannot accept that.  */
-
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  __asm__ __volatile__
-    ("\n"
-     "1:\n\t"
-     "lock; decl %0\n\t"
-     "js 2f\n\t"
-     ".section .text.spinlock,\"ax\"\n"
-     "2:\n\t"
-     "cmpl $0,%0\n\t"
-     "rep; nop\n\t"
-     "jle 2b\n\t"
-     "jmp 1b\n\t"
-     ".previous"
-     : "=m" (*lock));
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  int oldval;
-
-  __asm__ __volatile__
-    ("xchgl %0,%1"
-     : "=r" (oldval), "=m" (*lock)
-     : "0" (0));
-  return oldval > 0 ? 0 : EBUSY;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  __asm__ __volatile__
-    ("movl $1,%0"
-     : "=m" (*lock));
-  return 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  *lock = 1;
-  return 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
-
-#ifndef __ASSUME_SET_THREAD_AREA_SYSCALL
-int __have_no_set_thread_area;
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/i386/pt-machine.h b/libpthread/linuxthreads/sysdeps/i386/pt-machine.h
index 82a5cf077..24c5e6c7c 100644
--- a/libpthread/linuxthreads/sysdeps/i386/pt-machine.h
+++ b/libpthread/linuxthreads/sysdeps/i386/pt-machine.h
@@ -18,17 +18,14 @@
    License along with the GNU C Library; see the file COPYING.LIB.  If
    not, see <http://www.gnu.org/licenses/>.  */
 
-#if defined __pentiumpro__ || defined __pentium4__ || defined __athlon__ || \
-	defined __k8__
-# include "i686/pt-machine.h"
-#else
-
 #ifndef _PT_MACHINE_H
 #define _PT_MACHINE_H	1
 
+#include <features.h>
+
 #ifndef __ASSEMBLER__
 #ifndef PT_EI
-# define PT_EI __extern_always_inline
+# define PT_EI __extern_always_inline __attribute__((visibility("hidden")))
 #endif
 
 extern long int testandset (int *spinlock);
@@ -39,6 +36,54 @@ extern int __compare_and_swap (long int *p, long int oldval, long int newval);
 #define CURRENT_STACK_FRAME  __builtin_frame_address (0)
 
 
+/* See if we can optimize for newer cpus... */
+#if defined __GNUC__ && __GNUC__ >= 2 && \
+   (defined __i486__ || defined __pentium__ || defined __pentiumpro__ || defined __pentium4__ || \
+    defined __athlon__ || defined __k8__)
+
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+  long int ret;
+
+  __asm__ __volatile__ (
+	"xchgl %0, %1"
+	: "=r" (ret), "=m" (*spinlock)
+	: "0" (1), "m" (*spinlock)
+	: "memory");
+
+  return ret;
+}
+
+/* Compare-and-swap for semaphores.  It's always available on i686.  */
+#define HAS_COMPARE_AND_SWAP
+
+PT_EI int
+__compare_and_swap (long int *p, long int oldval, long int newval)
+{
+  char ret;
+  long int readval;
+
+  __asm__ __volatile__ ("lock; cmpxchgl %3, %1; sete %0"
+			: "=q" (ret), "=m" (*p), "=a" (readval)
+			: "r" (newval), "m" (*p), "a" (oldval)
+			: "memory");
+  return ret;
+}
+
+#if defined(__ASSUME_LDT_WORKS) && __ASSUME_LDT_WORKS > 0
+#include "useldt.h"
+#endif
+
+/* The P4 and above really want some help to prevent overheating.  */
+#define BUSY_WAIT_NOP	__asm__ ("rep; nop")
+
+
+#else /* Generic i386 implementation */
+
+extern int compare_and_swap_is_available (void);
+
 /* Spinlock implementation; required.  */
 PT_EI long int
 testandset (int *spinlock)
@@ -75,43 +120,27 @@ __compare_and_swap (long int *p, long int oldval, long int newval)
   return ret;
 }
 
-
-PT_EI int get_eflags (void);
-PT_EI int
-get_eflags (void)
-{
-  int res;
-  __asm__ __volatile__ ("pushfl; popl %0" : "=r" (res) : );
-  return res;
-}
-
-
-PT_EI void set_eflags (int newflags);
-PT_EI void
-set_eflags (int newflags)
-{
-  __asm__ __volatile__ ("pushl %0; popfl" : : "r" (newflags) : "cc");
-}
-
-
-PT_EI int compare_and_swap_is_available (void);
 PT_EI int
 compare_and_swap_is_available (void)
 {
-  int oldflags = get_eflags ();
   int changed;
+  int oldflags;
+  /* get EFLAGS */
+  __asm__ __volatile__ ("pushfl; popl %0" : "=r" (oldflags) : );
   /* Flip AC bit in EFLAGS.  */
-  set_eflags (oldflags ^ 0x40000);
+  __asm__ __volatile__ ("pushl %0; popfl" : : "r" (oldflags ^ 0x40000) : "cc");
+  /* reread EFLAGS */
+  __asm__ __volatile__ ("pushfl; popl %0" : "=r" (changed) : );
   /* See if bit changed.  */
-  changed = (get_eflags () ^ oldflags) & 0x40000;
+  changed = (changed ^ oldflags) & 0x40000;
   /* Restore EFLAGS.  */
-  set_eflags (oldflags);
+  __asm__ __volatile__ ("pushl %0; popfl" : : "r" (oldflags) : "cc");
   /* If the AC flag did not change, it's a 386 and it lacks cmpxchg.
      Otherwise, it's a 486 or above and it has cmpxchg.  */
   return changed != 0;
 }
+#endif /* Generic i386 implementation */
+
 #endif /* __ASSEMBLER__ */
 
 #endif /* pt-machine.h */
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/i386/tcb-offsets.sym b/libpthread/linuxthreads/sysdeps/i386/tcb-offsets.sym
deleted file mode 100644
index 69a5018d8..000000000
--- a/libpthread/linuxthreads/sysdeps/i386/tcb-offsets.sym
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <sysdep.h>
-#include <tls.h>
-
-MULTIPLE_THREADS_OFFSET		offsetof (tcbhead_t, multiple_threads)
-#ifdef NEED_DL_SYSINFO
-SYSINFO_OFFSET			offsetof (tcbhead_t, sysinfo)
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/i386/tls.h b/libpthread/linuxthreads/sysdeps/i386/tls.h
index d79bf0779..4469f0776 100644
--- a/libpthread/linuxthreads/sysdeps/i386/tls.h
+++ b/libpthread/linuxthreads/sysdeps/i386/tls.h
@@ -30,11 +30,7 @@
 typedef union dtv
 {
   size_t counter;
-  struct
-  {
-    void *val;
-    bool is_static;
-  } pointer;
+  void *pointer;
 } dtv_t;
 
 
@@ -44,28 +40,15 @@ typedef struct
 			   thread descriptor used by libpthread.  */
   dtv_t *dtv;
   void *self;		/* Pointer to the thread descriptor.  */
-  int multiple_threads;
-  uintptr_t sysinfo;
 } tcbhead_t;
-
-#else /* __ASSEMBLER__ */
-# include <tcb-offsets.h>
 #endif
 
-/* We can support TLS only if the floating-stack support is available.
-   However, we want to compile in the support and test at runtime whether
-   the running kernel can support it or not.  To avoid bothering with the
-   TLS support code at all, use configure --without-tls.
-
-   We need USE_TLS to be consistently defined, for ldsodefs.h conditionals.
-   But some of the code below can cause problems in building libpthread
-   (e.g. useldt.h will defined FLOATING_STACKS when it shouldn't).  */
 
-#if defined HAVE_TLS_SUPPORT \
-    && (defined FLOATING_STACKS || !defined IS_IN_libpthread)
+/* We can support TLS only if the floating-stack support is available.  */
+#if defined FLOATING_STACKS && defined HAVE_TLS_SUPPORT
 
 /* Signal that TLS support is available.  */
-# define USE_TLS	1
+//# define USE_TLS	1
 
 # ifndef __ASSEMBLER__
 /* Get system call information.  */
@@ -114,20 +97,7 @@ typedef struct
 #   define TLS_LOAD_EBX
 #  endif
 
-#  if !defined IS_IN_libpthread && !defined DO_MODIFY_LDT
-#   include "useldt.h"		/* For the structure.  */
-#  endif
-#  if __ASSUME_LDT_WORKS > 0
-#   define TLS_DO_MODIFY_LDT_KERNEL_CHECK(doit) (doit) /* Nothing to check.  */
-#  else
-#   define TLS_DO_MODIFY_LDT_KERNEL_CHECK(doit)				      \
-  (__builtin_expect (GLRO(dl_osversion) < 131939, 0)			      \
-   ? "kernel too old for thread-local storage support\n"			      \
-   : (doit))
-#  endif
-
 #  define TLS_DO_MODIFY_LDT(descr, nr)					      \
-TLS_DO_MODIFY_LDT_KERNEL_CHECK(						      \
 ({									      \
   struct modify_ldt_ldt_s ldt_entry =					      \
     { nr, (unsigned long int) (descr), 0xfffff /* 4GB in pages */,	      \
@@ -143,10 +113,8 @@ TLS_DO_MODIFY_LDT_KERNEL_CHECK(						      \
 		   here.  */						      \
 		"m" (ldt_entry), TLS_EBX_ARG (1), "c" (&ldt_entry),	      \
 		"d" (sizeof (ldt_entry)));				      \
-  __builtin_expect (result, 0) == 0					      \
-  ? ({ __asm__ ("movw %w0, %%gs" : : "q" ((nr) * 8 + 7)); NULL; })		      \
-  : "cannot set up LDT for thread-local storage\n";			      \
-}))
+  __builtin_expect (result, 0) != 0 ? -1 : nr * 8 + 7;			      \
+})
 
 #  define TLS_DO_SET_THREAD_AREA(descr, secondcall)			      \
 ({									      \
@@ -167,60 +135,50 @@ TLS_DO_MODIFY_LDT_KERNEL_CHECK(						      \
 		   to let the compiler know that we are accessing LDT_ENTRY   \
 		   here.  */						      \
 		TLS_EBX_ARG (&ldt_entry), "m" (ldt_entry));		      \
-  if (__builtin_expect (result, 0) == 0)				      \
-    __asm__ ("movw %w0, %%gs" : : "q" (ldt_entry.entry_number * 8 + 3));	      \
-  result;								      \
+    __builtin_expect (result, 0) == 0 ? ldt_entry.entry_number * 8 + 3 : -1;  \
 })
 
 #  ifdef __ASSUME_SET_THREAD_AREA_SYSCALL
-#   define TLS_SETUP_GS_SEGMENT(descr, secondcall)			      \
-  (TLS_DO_SET_THREAD_AREA (descr, secondcall)				      \
-   ? "set_thread_area failed when setting up thread-local storage\n" : NULL)
+#   define TLS_SETUP_GS_SEGMENT(descr, secondcall) \
+  TLS_DO_SET_THREAD_AREA (descr, firstcall)
 #  elif defined __NR_set_thread_area
 #   define TLS_SETUP_GS_SEGMENT(descr, secondcall) \
-  (TLS_DO_SET_THREAD_AREA (descr, secondcall)				      \
-   ? TLS_DO_MODIFY_LDT (descr, 0) : NULL)
+  ({ int __seg = TLS_DO_SET_THREAD_AREA (descr, secondcall); \
+     __seg == -1 ? TLS_DO_MODIFY_LDT (descr, 0) : __seg; })
 #  else
 #   define TLS_SETUP_GS_SEGMENT(descr, secondcall) \
   TLS_DO_MODIFY_LDT ((descr), 0)
 #  endif
 
-#if defined NEED_DL_SYSINFO
-# define INIT_SYSINFO \
-  head->sysinfo = GLRO(dl_sysinfo)
-#else
-# define INIT_SYSINFO
-#endif
-
 /* Code to initially initialize the thread pointer.  This might need
    special attention since 'errno' is not yet available and if the
-   operation can cause a failure 'errno' must not be touched.
-
-   The value of this macro is null if successful, or an error string.  */
+   operation can cause a failure 'errno' must not be touched.  */
 #  define TLS_INIT_TP(descr, secondcall)				      \
   ({									      \
     void *_descr = (descr);						      \
     tcbhead_t *head = _descr;						      \
+    int __gs;								      \
 									      \
     head->tcb = _descr;							      \
     /* For now the thread descriptor is at the same address.  */	      \
     head->self = _descr;						      \
 									      \
-    INIT_SYSINFO;							      \
-    TLS_SETUP_GS_SEGMENT (_descr, secondcall);				      \
+    __gs = TLS_SETUP_GS_SEGMENT (_descr, secondcall);			      \
+    if (__builtin_expect (__gs, 7) != -1)				      \
+      {									      \
+	__asm__ ("movw %w0, %%gs" : : "q" (__gs));				      \
+	__gs = 0;							      \
+      }									      \
+    __gs;								      \
   })
 
-/* Indicate that dynamic linker shouldn't try to initialize TLS even
-   when no PT_TLS segments are found in the program and libraries
-   it is linked against.  */
-#  define TLS_INIT_TP_EXPENSIVE 1
 
 /* Return the address of the dtv for the current thread.  */
 #  define THREAD_DTV() \
   ({ struct _pthread_descr_struct *__descr;				      \
      THREAD_GETMEM (__descr, p_header.data.dtvp); })
 
-# endif	/* HAVE_TLS_SUPPORT && (FLOATING_STACKS || !IS_IN_libpthread) */
+# endif	/* FLOATING_STACKS && HAVE_TLS_SUPPORT */
 #endif /* __ASSEMBLER__ */
 
 #endif	/* tls.h */
diff --git a/libpthread/linuxthreads/sysdeps/i386/useldt.h b/libpthread/linuxthreads/sysdeps/i386/useldt.h
index 067e5e242..02326729a 100644
--- a/libpthread/linuxthreads/sysdeps/i386/useldt.h
+++ b/libpthread/linuxthreads/sysdeps/i386/useldt.h
@@ -21,7 +21,6 @@
 #ifndef __ASSEMBLER__
 #include <stddef.h>	/* For offsetof.  */
 #include <stdlib.h>	/* For abort().	 */
-#include <sysdep.h>
 
 
 /* We don't want to include the kernel header.	So duplicate the
@@ -76,7 +75,7 @@ extern int __modify_ldt (int, struct modify_ldt_ldt_s *, size_t);
 
 #ifdef __PIC__
 # define USETLS_EBX_ARG "r"
-# define USETLS_LOAD_EBX "xchgl %1, %%ebx\n\t"
+# define USETLS_LOAD_EBX "xchgl %3, %%ebx\n\t"
 #else
 # define USETLS_EBX_ARG "b"
 # define USETLS_LOAD_EBX
@@ -86,7 +85,7 @@ extern int __modify_ldt (int, struct modify_ldt_ldt_s *, size_t);
    because we inherited the value set up in the main thread by TLS setup.
    We need to extract that value and set up the same segment in this
    thread.  */
-#ifdef __UCLIBC_HAS_TLS__
+#if USE_TLS
 # define DO_SET_THREAD_AREA_REUSE(nr)	1
 #else
 /* Without TLS, we do the initialization of the main thread, where NR == 0.  */
@@ -108,10 +107,8 @@ extern int __modify_ldt (int, struct modify_ldt_ldt_s *, size_t);
 	     "movl %2, %%eax\n\t"					      \
 	     "int $0x80\n\t"						      \
 	     USETLS_LOAD_EBX						      \
-	     : "=&a" (__result)						      \
-	     : USETLS_EBX_ARG (&ldt_entry), "i" (__NR_set_thread_area),	      \
-	       "m" (ldt_entry)						      \
-	     : "memory");						      \
+	     : "&a" (__result)						      \
+	     : USETLS_EBX_ARG (&ldt_entry), "i" (__NR_set_thread_area));      \
       if (__result == 0)						      \
 	__asm__ ("movw %w0, %%gs" :: "q" (__gs));				      \
       else								      \
@@ -128,10 +125,8 @@ extern int __modify_ldt (int, struct modify_ldt_ldt_s *, size_t);
 	     "movl %2, %%eax\n\t"					      \
 	     "int $0x80\n\t"						      \
 	     USETLS_LOAD_EBX						      \
-	     : "=&a" (__result)						      \
-	     : USETLS_EBX_ARG (&ldt_entry), "i" (__NR_set_thread_area),	      \
-	       "m" (ldt_entry)						      \
-	     : "memory");						      \
+	     : "&a" (__result)						      \
+	     : USETLS_EBX_ARG (&ldt_entry), "i" (__NR_set_thread_area));      \
       if (__result == 0)						      \
 	{								      \
 	  __gs = (ldt_entry.entry_number << 3) + 3;			      \
@@ -304,10 +299,8 @@ extern int __have_no_set_thread_area;
 })
 #endif
 
-#if __ASSUME_LDT_WORKS > 0
 /* We want the OS to assign stack addresses.  */
 #define FLOATING_STACKS	1
 
 /* Maximum size of the stack if the rlimit is unlimited.  */
 #define ARCH_STACK_MAX_SIZE	8*1024*1024
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/ia64/pspinlock.c b/libpthread/linuxthreads/sysdeps/ia64/pspinlock.c
deleted file mode 100644
index d5e52ff6b..000000000
--- a/libpthread/linuxthreads/sysdeps/ia64/pspinlock.c
+++ /dev/null
@@ -1,78 +0,0 @@
-/* POSIX spinlock implementation.  ia64 version.
-   Copyright (C) 2000, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jes Sorensen <jes@linuxcare.com>
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-#include <ia64intrin.h>
-
-/* This implementation is inspired by the implementation used in the
-   Linux kernel. */
-
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  int *p = (int *) lock;
-
-  while (__builtin_expect (__sync_val_compare_and_swap (p, 0, 1), 0))
-    {
-      /* Spin without using the atomic instruction.  */
-      do
-        __asm__ __volatile__ ("" : : : "memory");
-      while (*p);
-    }
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  return __sync_val_compare_and_swap ((int *) lock, 0, 1) == 0 ? 0 : EBUSY;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  return *lock = 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  return *lock = 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/ia64/pt-machine.h b/libpthread/linuxthreads/sysdeps/ia64/pt-machine.h
index 55bdd5df5..f4c6be989 100644
--- a/libpthread/linuxthreads/sysdeps/ia64/pt-machine.h
+++ b/libpthread/linuxthreads/sysdeps/ia64/pt-machine.h
@@ -23,6 +23,10 @@
 #include <features.h>
 #include <ia64intrin.h>
 
+#include <sys/types.h>
+extern int __clone2 (int (*__fn) (void *__arg), void *__child_stack_base,
+                     size_t __child_stack_size, int __flags, void *__arg, ...);
+
 #ifndef PT_EI
 # define PT_EI __extern_always_inline
 #endif
@@ -30,7 +34,7 @@
 /* Make sure gcc doesn't try to be clever and move things around on
    us. We need to use _exactly_ the address the user gave us, not some
    alias that contains the same information.  */
-#define __atomic_fool_gcc(x) (*(__volatile__ struct { int a[100]; } *)x)
+#define __atomic_fool_gcc(x) (*(volatile struct { int a[100]; } *)x)
 
 #ifndef ELF_MACHINE_NAME
 
diff --git a/libpthread/linuxthreads/sysdeps/ia64/tcb-offsets.sym b/libpthread/linuxthreads/sysdeps/ia64/tcb-offsets.sym
deleted file mode 100644
index 1000ad0a9..000000000
--- a/libpthread/linuxthreads/sysdeps/ia64/tcb-offsets.sym
+++ /dev/null
@@ -1,9 +0,0 @@
-#include <sysdep.h>
-#include <tls.h>
-
---
-#ifdef __UCLIBC_HAS_TLS__
-MULTIPLE_THREADS_OFFSET offsetof (struct _pthread_descr_struct, p_multiple_threads) - sizeof (struct _pthread_descr_struct)
-#else
-MULTIPLE_THREADS_OFFSET offsetof (tcbhead_t, multiple_threads)
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/ia64/tls.h b/libpthread/linuxthreads/sysdeps/ia64/tls.h
index c86073f26..a78f0ec7a 100644
--- a/libpthread/linuxthreads/sysdeps/ia64/tls.h
+++ b/libpthread/linuxthreads/sysdeps/ia64/tls.h
@@ -111,9 +111,6 @@ typedef struct
 
 # define TLS_MULTIPLE_THREADS_IN_TCB 1
 
-/* Get the thread descriptor definition.  */
-#  include <linuxthreads/descr.h>
-
 # endif
 
 #else
@@ -128,9 +125,6 @@ typedef struct
   int multiple_threads;
 } tcbhead_t;
 
-/* Get the thread descriptor definition.  */
-#  include <linuxthreads/descr.h>
-
 #  define NONTLS_INIT_TP \
   do { 									\
     static const tcbhead_t nontls_init_tp = { .multiple_threads = 0 };	\
diff --git a/libpthread/linuxthreads/sysdeps/m68k/pspinlock.c b/libpthread/linuxthreads/sysdeps/m68k/pspinlock.c
deleted file mode 100644
index af77c2a9d..000000000
--- a/libpthread/linuxthreads/sysdeps/m68k/pspinlock.c
+++ /dev/null
@@ -1,91 +0,0 @@
-/* POSIX spinlock implementation.  M68k version.
-   Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-
-
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  unsigned int val;
-
-  do
-    __asm__ __volatile__ (
-#if !defined(__mcoldfire__) && !defined(__mcf5200__) && !defined(__m68000)
-		"tas %1; sne %0"
-#else
-		"bset #7,%1; sne %0"
-#endif
-		: "=dm" (val), "=m" (*lock)
-		: "m" (*lock)
-		: "cc");
-  while (val);
-
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  unsigned int val;
-
-  __asm__ __volatile__ (
-#if !defined(__mcoldfire__) && !defined(__mcf5200__) && !defined(__m68000)
-		"tas %1; sne %0"
-#else
-		"bset #7,%1; sne %0"
-#endif
-		: "=dm" (val), "=m" (*lock)
-		: "m" (*lock)
-		: "cc");
-
-  return val ? EBUSY : 0;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  return *lock = 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  return *lock = 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/m68k/pt-machine.h b/libpthread/linuxthreads/sysdeps/m68k/pt-machine.h
index 1eb9fd57b..3be216524 100644
--- a/libpthread/linuxthreads/sysdeps/m68k/pt-machine.h
+++ b/libpthread/linuxthreads/sysdeps/m68k/pt-machine.h
@@ -28,7 +28,6 @@
 #endif
 
 /* Spinlock implementation; required.  */
-PT_EI long int testandset (int *spinlock);
 PT_EI long int
 testandset (int *spinlock)
 {
@@ -36,11 +35,11 @@ testandset (int *spinlock)
 
   __asm__ __volatile__(
 #if !defined(__mcoldfire__) && !defined(__mcf5200__) && !defined(__m68000)
-	"tas %1; sne %0"
+         "tas %1; sne %0"
 #else
-	"bset #7,%1; sne %0"
+         "bset #7,%1; sne %0"
 #endif
-       : "=dm"(ret), "=m"(*spinlock)
+       : "=&dm"(ret), "=m"(*spinlock)
        : "m"(*spinlock)
        : "cc");
 
@@ -71,4 +70,5 @@ __compare_and_swap (long int *p, long int oldval, long int newval)
   return ret;
 }
 #endif
+
 #endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/microblaze/pt-machine.h b/libpthread/linuxthreads/sysdeps/microblaze/pt-machine.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/microblaze/pt-machine.h
rename to libpthread/linuxthreads/sysdeps/microblaze/pt-machine.h
diff --git a/libpthread/linuxthreads.old/sysdeps/microblaze/sigcontextinfo.h b/libpthread/linuxthreads/sysdeps/microblaze/sigcontextinfo.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/microblaze/sigcontextinfo.h
rename to libpthread/linuxthreads/sysdeps/microblaze/sigcontextinfo.h
diff --git a/libpthread/linuxthreads/sysdeps/mips/pspinlock.c b/libpthread/linuxthreads/sysdeps/mips/pspinlock.c
deleted file mode 100644
index 7b9205ef0..000000000
--- a/libpthread/linuxthreads/sysdeps/mips/pspinlock.c
+++ /dev/null
@@ -1,95 +0,0 @@
-/* POSIX spinlock implementation.  MIPS version.
-   Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include <sgidefs.h>
-#include <sys/tas.h>
-#include "internals.h"
-
-/* This implementation is similar to the one used in the Linux kernel.  */
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  unsigned int tmp1, tmp2;
-
-  __asm__ __volatile__
-    ("\t\t\t# spin_lock\n"
-     "1:\n\t"
-     ".set	push\n\t"
-#if _MIPS_SIM == _ABIO32
-     ".set	mips2\n\t"
-#endif
-     "ll	%1,%3\n\t"
-     "li	%2,1\n\t"
-     "bnez	%1,1b\n\t"
-     "sc	%2,%0\n\t"
-     ".set	pop\n\t"
-     "beqz	%2,1b"
-     : "=m" (*lock), "=&r" (tmp1), "=&r" (tmp2)
-     : "m" (*lock)
-     : "memory");
-
-  return 0;
-}
-
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  /* To be done.  */
-  return 0;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  __asm__ __volatile__
-    ("\t\t\t# spin_unlock\n\t"
-     "sw	$0,%0"
-     : "=m" (*lock)
-     :
-     : "memory");
-  return 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  *lock = 0;
-  return 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/mips/pt-machine.h b/libpthread/linuxthreads/sysdeps/mips/pt-machine.h
index 74e8807eb..caaf9a7c0 100644
--- a/libpthread/linuxthreads/sysdeps/mips/pt-machine.h
+++ b/libpthread/linuxthreads/sysdeps/mips/pt-machine.h
@@ -24,13 +24,40 @@
 #define _PT_MACHINE_H   1
 
 #include <features.h>
-#include <sgidefs.h>
-#include <sys/tas.h>
 
 #ifndef PT_EI
 # define PT_EI __extern_always_inline
 #endif
 
+/* Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@ds2.pg.gda.pl>, 2000.  */
+static __inline__ int
+__NTH (_test_and_set (int *p, int v))
+{
+  int r, t;
+
+  __asm__ __volatile__
+    ("/* Inline test and set */\n"
+     "1:\n\t"
+     ".set	push\n\t"
+     ".set	mips2\n\t"
+     "ll	%0,%3\n\t"
+     "move	%1,%4\n\t"
+     "beq	%0,%4,2f\n\t"
+     "sc	%1,%2\n\t"
+     ".set	pop\n\t"
+     "beqz	%1,1b\n"
+     "2:\n\t"
+     "/* End test and set */"
+     : "=&r" (r), "=&r" (t), "=m" (*p)
+     : "m" (*p), "r" (v)
+     : "memory");
+
+  return r;
+}
+
+
 /* Spinlock implementation; required.  */
 
 PT_EI long int
@@ -58,22 +85,12 @@ __compare_and_swap (long int *p, long int oldval, long int newval)
     ("/* Inline compare & swap */\n"
      "1:\n\t"
      ".set	push\n\t"
-#if _MIPS_SIM == _ABIO32
      ".set	mips2\n\t"
-#endif
-#if _MIPS_SIM == _ABI64
-     "lld	%1,%5\n\t"
-#else
      "ll	%1,%5\n\t"
-#endif
      "move	%0,$0\n\t"
      "bne	%1,%3,2f\n\t"
      "move	%0,%4\n\t"
-#if _MIPS_SIM == _ABI64
-     "scd	%0,%2\n\t"
-#else
      "sc	%0,%2\n\t"
-#endif
      ".set	pop\n\t"
      "beqz	%0,1b\n"
      "2:\n\t"
diff --git a/libpthread/linuxthreads/sysdeps/mips/tls.h b/libpthread/linuxthreads/sysdeps/mips/tls.h
deleted file mode 100644
index 4e7887a74..000000000
--- a/libpthread/linuxthreads/sysdeps/mips/tls.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/* Definitions for thread-local data handling.  linuxthreads/MIPS version.
-   Copyright (C) 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _TLS_H
-#define _TLS_H
-
-#ifndef __ASSEMBLER__
-
-# include <stdbool.h>
-# include <pt-machine.h>
-# include <stddef.h>
-
-/* Type for the dtv.  */
-typedef union dtv
-{
-  size_t counter;
-  struct
-  {
-    void *val;
-    bool is_static;
-  } pointer;
-} dtv_t;
-
-# define READ_THREAD_POINTER() \
-    ({ void *__result;							      \
-       __asm__ __volatile__ (".set\tpush\n\t.set\tmips32r2\n\t"			      \
-		     "rdhwr\t%0, $29\n\t.set\tpop" : "=v" (__result));	      \
-       __result; })
-
-#else /* __ASSEMBLER__ */
-# include <tcb-offsets.h>
-
-/* Note: rd must be $v1 to be ABI-conformant.  */
-# define READ_THREAD_POINTER(rd) \
-	.set	push;							      \
-	.set	mips32r2;						      \
-	rdhwr	rd, $29;						      \
-	.set	pop
-#endif /* __ASSEMBLER__ */
-
-/* LinuxThreads can only use TLS if both floating stacks (in the MIPS case,
-   that means support for "rdhwr") and support from the tools are available.
-
-   We have to define USE_TLS consistently, or ldsodefs.h will lay out types
-   differently between an NPTL build and a LinuxThreads build.  It can be set
-   for libc.so and not libpthread.so, but only if we provide appropriate padding
-   in the _pthread_descr_struct.
-
-   Currently nothing defines FLOATING_STACKS.  We could assume this based on
-   kernel version once the TLS patches are available in kernel.org, but
-   it hardly seems worth it.  Use NPTL if you can.
-
-   To avoid bothering with the TLS support code at all, use configure
-   --without-tls.  */
-
-#if defined HAVE_TLS_SUPPORT \
-    && (defined FLOATING_STACKS || !defined IS_IN_libpthread)
-
-/* Signal that TLS support is available.  */
-# define USE_TLS	1
-
-/* Include padding in _pthread_descr_struct so that libc can find p_errno,
-   if libpthread will only include the padding because of the !IS_IN_libpthread
-   check.  */
-#ifndef FLOATING_STACKS
-# define INCLUDE_TLS_PADDING	1
-#endif
-
-# ifndef __ASSEMBLER__
-
-/* This layout is actually wholly private and not affected by the ABI.
-   Nor does it overlap the pthread data structure, so we need nothing
-   extra here at all.  */
-typedef struct
-{
-  dtv_t *dtv;
-  void *private;
-} tcbhead_t;
-
-/* This is the size of the initial TCB.  */
-#  define TLS_INIT_TCB_SIZE	0
-
-/* Alignment requirements for the initial TCB.  */
-#  define TLS_INIT_TCB_ALIGN	__alignof__ (struct _pthread_descr_struct)
-
-/* This is the size of the TCB.  */
-#  define TLS_TCB_SIZE		0
-
-/* Alignment requirements for the TCB.  */
-#  define TLS_TCB_ALIGN		__alignof__ (struct _pthread_descr_struct)
-
-/* This is the size we need before TCB.  */
-#  define TLS_PRE_TCB_SIZE \
-  (sizeof (struct _pthread_descr_struct)				      \
-   + ((sizeof (tcbhead_t) + TLS_TCB_ALIGN - 1) & ~(TLS_TCB_ALIGN - 1)))
-
-/* The thread pointer (in hardware register $29) points to the end of
-   the TCB + 0x7000, as for PowerPC.  The pthread_descr structure is
-   immediately in front of the TCB.  */
-#define TLS_TCB_OFFSET		0x7000
-
-/* The DTV is allocated at the TP; the TCB is placed elsewhere.  */
-/* This is not really true for powerpc64.  We are following alpha
-   where the DTV pointer is first doubleword in the TCB.  */
-#  define TLS_DTV_AT_TP 1
-
-/* Install the dtv pointer.  The pointer passed is to the element with
-   index -1 which contain the length.  */
-#  define INSTALL_DTV(TCBP, DTVP) \
-  (((tcbhead_t *) (TCBP))[-1].dtv = (DTVP) + 1)
-
-/* Install new dtv for current thread.  */
-#  define INSTALL_NEW_DTV(DTV) (THREAD_DTV() = (DTV))
-
-/* Return dtv of given thread descriptor.  */
-#  define GET_DTV(TCBP)	(((tcbhead_t *) (TCBP))[-1].dtv)
-
-/* Code to initially initialize the thread pointer.  This might need
-   special attention since 'errno' is not yet available and if the
-   operation can cause a failure 'errno' must not be touched.  */
-# define TLS_INIT_TP(tcbp, secondcall) \
-  ({ INTERNAL_SYSCALL_DECL (err);					\
-     long result_var;							\
-     result_var = INTERNAL_SYSCALL (set_thread_area, err, 1,		\
-				    (char *) (tcbp) + TLS_TCB_OFFSET);	\
-     INTERNAL_SYSCALL_ERROR_P (result_var, err)				\
-       ? "unknown error" : NULL; })
-
-/* Return the address of the dtv for the current thread.  */
-# define THREAD_DTV() \
-  (((tcbhead_t *) (READ_THREAD_POINTER () - TLS_TCB_OFFSET))[-1].dtv)
-
-/* Return the thread descriptor for the current thread.  */
-#  undef THREAD_SELF
-#  define THREAD_SELF \
-    ((pthread_descr) (READ_THREAD_POINTER () \
-		      - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE))
-
-/* Get the thread descriptor definition.  */
-#  include <linuxthreads/descr.h>
-
-/* l_tls_offset == 0 is perfectly valid on MIPS, so we have to use some
-   different value to mean unset l_tls_offset.  */
-#  define NO_TLS_OFFSET	-1
-
-/* Initializing the thread pointer requires a syscall which may not be
-   available, so don't do it if we don't need to.  */
-#  define TLS_INIT_TP_EXPENSIVE 1
-
-# endif /* __ASSEMBLER__ */
-
-#endif /* HAVE_TLS_SUPPORT */
-
-#endif	/* tls.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/nios/pt-machine.h b/libpthread/linuxthreads/sysdeps/nios/pt-machine.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/nios/pt-machine.h
rename to libpthread/linuxthreads/sysdeps/nios/pt-machine.h
diff --git a/libpthread/linuxthreads.old/sysdeps/nios2/pt-machine.h b/libpthread/linuxthreads/sysdeps/nios2/pt-machine.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/nios2/pt-machine.h
rename to libpthread/linuxthreads/sysdeps/nios2/pt-machine.h
diff --git a/libpthread/linuxthreads/sysdeps/powerpc/powerpc32/pspinlock.c b/libpthread/linuxthreads/sysdeps/powerpc/powerpc32/pspinlock.c
deleted file mode 100644
index 875aa3876..000000000
--- a/libpthread/linuxthreads/sysdeps/powerpc/powerpc32/pspinlock.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/* POSIX spinlock implementation.  PowerPC version.
-   Copyright (C) 2000, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  while (! __compare_and_swap ((long int *)lock, 0, 1))
-    ;
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  return __compare_and_swap ((long int *)lock, 0, 1) ? 0 : EBUSY;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  MEMORY_BARRIER ();
-  *lock = 0;
-  return 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  *lock = 0;
-  return 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/powerpc/powerpc32/pt-machine.h b/libpthread/linuxthreads/sysdeps/powerpc/powerpc32/pt-machine.h
deleted file mode 100644
index a2b8b61e6..000000000
--- a/libpthread/linuxthreads/sysdeps/powerpc/powerpc32/pt-machine.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   powerpc version.
-   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002, 2003
-   Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-/* These routines are from Appendix G of the 'PowerPC 601 RISC Microprocessor
-   User's Manual', by IBM and Motorola.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-extern long int testandset (int *spinlock);
-extern int __compare_and_swap (long int *p, long int oldval, long int newval);
-
-/* For multiprocessor systems, we want to ensure all memory accesses
-   are completed before we reset a lock.  On other systems, we still
-   need to make sure that the compiler has flushed everything to memory.  */
-#define MEMORY_BARRIER() __asm__ __volatile__ ("sync" : : : "memory")
-
-/* We want the OS to assign stack addresses.  */
-#define FLOATING_STACKS 1
-
-/* Maximum size of the stack if the rlimit is unlimited.  */
-#define ARCH_STACK_MAX_SIZE     8*1024*1024
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  stack_pointer
-register char * stack_pointer __asm__ ("r1");
-
-/* Register r2 (tp) is reserved by the ABI as "thread pointer". */
-struct _pthread_descr_struct;
-register struct _pthread_descr_struct *__thread_self __asm__("r2");
-
-/* Return the thread descriptor for the current thread.  */
-#define THREAD_SELF  __thread_self
-
-/* Initialize the thread-unique value.  */
-#define INIT_THREAD_SELF(descr, nr)  (__thread_self = (descr))
-
-/* Access to data in the thread descriptor is easy.  */
-#define THREAD_GETMEM(descr, member) \
-  ((void) (descr), THREAD_SELF->member)
-#define THREAD_GETMEM_NC(descr, member) \
-  ((void) (descr), THREAD_SELF->member)
-#define THREAD_SETMEM(descr, member, value) \
-  ((void) (descr), THREAD_SELF->member = (value))
-#define THREAD_SETMEM_NC(descr, member, value) \
-  ((void) (descr), THREAD_SELF->member = (value))
-
-/* Compare-and-swap for semaphores. */
-/* note that test-and-set(x) is the same as !compare-and-swap(x, 0, 1) */
-
-#define HAS_COMPARE_AND_SWAP_WITH_RELEASE_SEMANTICS
-#define IMPLEMENT_TAS_WITH_CAS
-
-PT_EI int
-__compare_and_swap (long int *p, long int oldval, long int newval)
-{
-  int ret;
-
-  __asm__ __volatile__ (
-	   "0:    lwarx %0,0,%1 ;"
-	   "      xor. %0,%3,%0;"
-	   "      bne 1f;"
-	   "      stwcx. %2,0,%1;"
-	   "      bne- 0b;"
-	   "1:    "
-	: "=&r"(ret)
-	: "r"(p), "r"(newval), "r"(oldval)
-	: "cr0", "memory");
-  /* This version of __compare_and_swap is to be used when acquiring
-     a lock, so we don't need to worry about whether other memory
-     operations have completed, but we do need to be sure that any loads
-     after this point really occur after we have acquired the lock.  */
-  __asm__ __volatile__ ("isync" : : : "memory");
-  return ret == 0;
-}
-
-PT_EI int
-__compare_and_swap_with_release_semantics (long int *p,
-					   long int oldval, long int newval)
-{
-  int ret;
-
-  MEMORY_BARRIER ();
-  __asm__ __volatile__ (
-	   "0:    lwarx %0,0,%1 ;"
-	   "      xor. %0,%3,%0;"
-	   "      bne 1f;"
-	   "      stwcx. %2,0,%1;"
-	   "      bne- 0b;"
-	   "1:    "
-	: "=&r"(ret)
-	: "r"(p), "r"(newval), "r"(oldval)
-	: "cr0", "memory");
-  return ret == 0;
-}
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads/sysdeps/powerpc/powerpc64/pspinlock.c b/libpthread/linuxthreads/sysdeps/powerpc/powerpc64/pspinlock.c
deleted file mode 100644
index f588c62c7..000000000
--- a/libpthread/linuxthreads/sysdeps/powerpc/powerpc64/pspinlock.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/* POSIX spinlock implementation.  PowerPC version.
-   Copyright (C) 2000, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  while (! __compare_and_swap32 ((int *)lock, 0, 1))
-    ;
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  return __compare_and_swap32 ((int *)lock, 0, 1) ? 0 : EBUSY;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  MEMORY_BARRIER ();
-  *lock = 0;
-  return 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  *lock = 0;
-  return 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/powerpc/powerpc64/pt-machine.h b/libpthread/linuxthreads/sysdeps/powerpc/powerpc64/pt-machine.h
deleted file mode 100644
index b9193a871..000000000
--- a/libpthread/linuxthreads/sysdeps/powerpc/powerpc64/pt-machine.h
+++ /dev/null
@@ -1,184 +0,0 @@
-/* Machine-dependent pthreads configuration and inline functions.
-   powerpc version.
-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-/* These routines are from Appendix G of the 'PowerPC 601 RISC Microprocessor
-   User's Manual', by IBM and Motorola.  */
-
-#ifndef _PT_MACHINE_H
-#define _PT_MACHINE_H   1
-
-#ifndef PT_EI
-# define PT_EI __extern_always_inline
-#endif
-
-extern long int testandset (int *spinlock);
-extern int __compare_and_swap (long int *p, long int oldval, long int newval);
-extern int __compare_and_swap32 (int *p, int oldval, int newval);
-
-/* For multiprocessor systems, we want to ensure all memory accesses
-   are completed before we reset a lock.  On other systems, we still
-   need to make sure that the compiler has flushed everything to memory.  */
-#define MEMORY_BARRIER() __asm__ __volatile__ ("lwsync" : : : "memory")
-#define READ_MEMORY_BARRIER() __asm__ __volatile__ ("lwsync" : : : "memory")
-#define WRITE_MEMORY_BARRIER() __asm__ __volatile__ ("eieio" : : : "memory")
-
-/* We want the OS to assign stack addresses.  */
-#define FLOATING_STACKS 1
-
-/* Maximum size of the stack if the rlimit is unlimited.  */
-#define ARCH_STACK_MAX_SIZE     16*1024*1024
-
-/* Get some notion of the current stack.  Need not be exactly the top
-   of the stack, just something somewhere in the current frame.  */
-#define CURRENT_STACK_FRAME  stack_pointer
-register char * stack_pointer __asm__ ("r1");
-
-/* Register r13 (tp) is reserved by the ABI as "thread pointer". */
-struct _pthread_descr_struct;
-register struct _pthread_descr_struct *__thread_self __asm__("r13");
-
-/* Return the thread descriptor for the current thread.  */
-#define THREAD_SELF  __thread_self
-
-/* Initialize the thread-unique value.  */
-#define INIT_THREAD_SELF(descr, nr)  (__thread_self = (descr))
-
-/* Access to data in the thread descriptor is easy.  */
-#define THREAD_GETMEM(descr, member) \
-  ((void) (descr), THREAD_SELF->member)
-#define THREAD_GETMEM_NC(descr, member) \
-  ((void) (descr), THREAD_SELF->member)
-#define THREAD_SETMEM(descr, member, value) \
-  ((void) (descr), THREAD_SELF->member = (value))
-#define THREAD_SETMEM_NC(descr, member, value) \
-  ((void) (descr), THREAD_SELF->member = (value))
-
-/* Compare-and-swap for semaphores. */
-/* note that test-and-set(x) is the same as !compare-and-swap(x, 0, 1) */
-
-#define HAS_COMPARE_AND_SWAP
-#define HAS_COMPARE_AND_SWAP_WITH_RELEASE_SEMANTICS
-
-PT_EI int
-__compare_and_swap (long int *p, long int oldval, long int newval)
-{
-  long int ret;
-
-  __asm__ __volatile__ (
-	   "0:    ldarx %0,0,%1 ;"
-	   "      xor. %0,%3,%0;"
-	   "      bne 1f;"
-	   "      stdcx. %2,0,%1;"
-	   "      bne- 0b;"
-	   "1:    "
-	: "=&r"(ret)
-	: "r"(p), "r"(newval), "r"(oldval)
-	: "cr0", "memory");
-  /* This version of __compare_and_swap is to be used when acquiring
-     a lock, so we don't need to worry about whether other memory
-     operations have completed, but we do need to be sure that any loads
-     after this point really occur after we have acquired the lock.  */
-  __asm__ __volatile__ ("isync" : : : "memory");
-  return (int)(ret == 0);
-}
-
-PT_EI int
-__compare_and_swap_with_release_semantics (long int *p,
-					   long int oldval, long int newval)
-{
-  long int ret;
-
-  MEMORY_BARRIER ();
-  __asm__ __volatile__ (
-	   "0:    ldarx %0,0,%1 ;"
-	   "      xor. %0,%3,%0;"
-	   "      bne 1f;"
-	   "      stdcx. %2,0,%1;"
-	   "      bne- 0b;"
-	   "1:    "
-	: "=&r"(ret)
-	: "r"(p), "r"(newval), "r"(oldval)
-	: "cr0", "memory");
-  return (int)(ret == 0);
-}
-
-PT_EI int
-__compare_and_swap32 (int *p, int oldval, int newval)
-{
-  int ret;
-
-  __asm__ __volatile__ (
-	   "0:    lwarx %0,0,%1 ;"
-	   "      xor. %0,%3,%0;"
-	   "      bne 1f;"
-	   "      stwcx. %2,0,%1;"
-	   "      bne- 0b;"
-	   "1:    "
-	: "=&r"(ret)
-	: "r"(p), "r"(newval), "r"(oldval)
-	: "cr0", "memory");
-  /* This version of __compare_and_swap is to be used when acquiring
-     a lock, so we don't need to worry about whether other memory
-     operations have completed, but we do need to be sure that any loads
-     after this point really occur after we have acquired the lock.  */
-  __asm__ __volatile__ ("isync" : : : "memory");
-  return (int)(ret == 0);
-}
-
-PT_EI int
-__compare_and_swap32_with_release_semantics (long int *p,
-					   long int oldval, long int newval)
-{
-  long int ret;
-
-  MEMORY_BARRIER ();
-  __asm__ __volatile__ (
-	   "0:    lwarx %0,0,%1 ;"
-	   "      xor. %0,%3,%0;"
-	   "      bne 1f;"
-	   "      stwcx. %2,0,%1;"
-	   "      bne- 0b;"
-	   "1:    "
-	: "=&r"(ret)
-	: "r"(p), "r"(newval), "r"(oldval)
-	: "cr0", "memory");
-  return (int)(ret == 0);
-}
-
-PT_EI long int
-testandset (int *p)
-{
-  long int ret, val = 1;
-
-  MEMORY_BARRIER ();
-  __asm__ __volatile__ (
-	   "0:    lwarx %0,0,%1 ;"
-	   "      cmpwi  0,%0,0;"
-	   "      bne 1f;"
-	   "      stwcx. %2,0,%1;"
-	   "      bne- 0b;"
-	   "1:    "
-	: "=&r"(ret)
-	: "r"(p), "r" (val)
-	: "cr0", "memory");
-  MEMORY_BARRIER ();
-  return ret != 0;
-}
-
-#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads/sysdeps/powerpc/pspinlock.c b/libpthread/linuxthreads/sysdeps/powerpc/pspinlock.c
deleted file mode 100644
index bb88a0690..000000000
--- a/libpthread/linuxthreads/sysdeps/powerpc/pspinlock.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <features.h>
-#include <bits/wordsize.h>
-
-#if __WORDSIZE == 32
-# include "powerpc32/pspinlock.c"
-#else
-# include "powerpc64/pspinlock.c"
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/powerpc/pt-machine.h b/libpthread/linuxthreads/sysdeps/powerpc/pt-machine.h
index 55e922efd..aa2d206b0 100644
--- a/libpthread/linuxthreads/sysdeps/powerpc/pt-machine.h
+++ b/libpthread/linuxthreads/sysdeps/powerpc/pt-machine.h
@@ -1,8 +1,101 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   powerpc version.
+   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+/* These routines are from Appendix G of the 'PowerPC 601 RISC Microprocessor
+   User's Manual', by IBM and Motorola.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
 #include <features.h>
-#include <bits/wordsize.h>
 
-#if __WORDSIZE == 32
-# include "powerpc32/pt-machine.h"
-#else
-# include "powerpc64/pt-machine.h"
+#ifndef PT_EI
+# define PT_EI __extern_always_inline
 #endif
+
+/* For multiprocessor systems, we want to ensure all memory accesses
+   are completed before we reset a lock.  On other systems, we still
+   need to make sure that the compiler has flushed everything to memory.  */
+#define MEMORY_BARRIER() __asm__ __volatile__ ("sync" : : : "memory")
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("r1");
+
+/* Register r2 (tp) is reserved by the ABI as "thread pointer". */
+struct _pthread_descr_struct;
+register struct _pthread_descr_struct *__thread_self __asm__("r2");
+
+/* Return the thread descriptor for the current thread.  */
+#define THREAD_SELF  __thread_self
+
+/* Initialize the thread-unique value.  */
+#define INIT_THREAD_SELF(descr, nr)  (__thread_self = (descr))
+
+/* Compare-and-swap for semaphores. */
+/* note that test-and-set(x) is the same as !compare-and-swap(x, 0, 1) */
+
+#define HAS_COMPARE_AND_SWAP_WITH_RELEASE_SEMANTICS
+#define IMPLEMENT_TAS_WITH_CAS
+
+PT_EI int
+__compare_and_swap (long int *p, long int oldval, long int newval)
+{
+  int ret;
+
+  __asm__ __volatile__ (
+	   "0:    lwarx %0,0,%1 ;"
+	   "      xor. %0,%3,%0;"
+	   "      bne 1f;"
+	   "      stwcx. %2,0,%1;"
+	   "      bne- 0b;"
+	   "1:    "
+	: "=&r"(ret)
+	: "r"(p), "r"(newval), "r"(oldval)
+	: "cr0", "memory");
+  /* This version of __compare_and_swap is to be used when acquiring
+     a lock, so we don't need to worry about whether other memory
+     operations have completed, but we do need to be sure that any loads
+     after this point really occur after we have acquired the lock.  */
+  __asm__ __volatile__ ("isync" : : : "memory");
+  return ret == 0;
+}
+
+PT_EI int
+__compare_and_swap_with_release_semantics (long int *p,
+					   long int oldval, long int newval)
+{
+  int ret;
+
+  MEMORY_BARRIER ();
+  __asm__ __volatile__ (
+	   "0:    lwarx %0,0,%1 ;"
+	   "      xor. %0,%3,%0;"
+	   "      bne 1f;"
+	   "      stwcx. %2,0,%1;"
+	   "      bne- 0b;"
+	   "1:    "
+	: "=&r"(ret)
+	: "r"(p), "r"(newval), "r"(oldval)
+	: "cr0", "memory");
+  return ret == 0;
+}
+
+#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads/sysdeps/powerpc/tcb-offsets.sym b/libpthread/linuxthreads/sysdeps/powerpc/tcb-offsets.sym
deleted file mode 100644
index 7940cf620..000000000
--- a/libpthread/linuxthreads/sysdeps/powerpc/tcb-offsets.sym
+++ /dev/null
@@ -1,19 +0,0 @@
-#include <sysdep.h>
-#include <tls.h>
-
--- This line separates the #include lines from conditionals.
-
-# ifdef __UCLIBC_HAS_TLS__
-
--- Abuse tls.h macros to derive offsets relative to the thread register.
-#  undef __thread_register
-#  define __thread_register	((void *) 0)
-#  define thread_offsetof(mem)	((ptrdiff_t) THREAD_SELF + offsetof (struct _pthread_descr_struct, p_##mem))
-
-# else
-
-#  define thread_offsetof(mem)	offsetof (tcbhead_t, mem)
-
-# endif
-
-MULTIPLE_THREADS_OFFSET		thread_offsetof (multiple_threads)
diff --git a/libpthread/linuxthreads/sysdeps/powerpc/tls.h b/libpthread/linuxthreads/sysdeps/powerpc/tls.h
deleted file mode 100644
index 8555b239d..000000000
--- a/libpthread/linuxthreads/sysdeps/powerpc/tls.h
+++ /dev/null
@@ -1,164 +0,0 @@
-/* Definitions for thread-local data handling.  linuxthreads/PPC version.
-   Copyright (C) 2003, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _TLS_H
-#define _TLS_H
-
-#ifndef __ASSEMBLER__
-
-# include <pt-machine.h>
-# include <stdbool.h>
-# include <stddef.h>
-
-/* Type for the dtv.  */
-typedef union dtv
-{
-  size_t counter;
-  struct
-  {
-    void *val;
-    bool is_static;
-  } pointer;
-} dtv_t;
-
-#else /* __ASSEMBLER__ */
-# include <tcb-offsets.h>
-#endif /* __ASSEMBLER__ */
-
-#ifdef HAVE_TLS_SUPPORT
-
-/* Signal that TLS support is available.  */
-# define USE_TLS	1
-
-# ifndef __ASSEMBLER__
-
-/* This layout is actually wholly private and not affected by the ABI.
-   Nor does it overlap the pthread data structure, so we need nothing
-   extra here at all.  */
-typedef struct
-{
-  dtv_t *dtv;
-} tcbhead_t;
-
-/* This is the size of the initial TCB.  */
-#  define TLS_INIT_TCB_SIZE	0
-
-/* Alignment requirements for the initial TCB.  */
-#  define TLS_INIT_TCB_ALIGN	__alignof__ (struct _pthread_descr_struct)
-
-/* This is the size of the TCB.  */
-#  define TLS_TCB_SIZE		0
-
-/* Alignment requirements for the TCB.  */
-#  define TLS_TCB_ALIGN		__alignof__ (struct _pthread_descr_struct)
-
-/* This is the size we need before TCB.  */
-#  define TLS_PRE_TCB_SIZE \
-  (sizeof (struct _pthread_descr_struct)				      \
-   + ((sizeof (tcbhead_t) + TLS_TCB_ALIGN - 1) & ~(TLS_TCB_ALIGN - 1)))
-
-/* The following assumes that TP (R2 or R13) is points to the end of the
-   TCB + 0x7000 (per the ABI).  This implies that TCB address is
-   TP - 0x7000.  As we define TLS_DTV_AT_TP we can
-   assume that the pthread_descr is allocated immediately ahead of the
-   TCB.  This implies that the pthread_descr address is
-   TP - (TLS_PRE_TCB_SIZE + 0x7000).  */
-#define TLS_TCB_OFFSET		0x7000
-
-/* The DTV is allocated at the TP; the TCB is placed elsewhere.  */
-/* This is not really true for powerpc64.  We are following alpha
-   where the DTV pointer is first doubleword in the TCB.  */
-#  define TLS_DTV_AT_TP 1
-
-/* Install the dtv pointer.  The pointer passed is to the element with
-   index -1 which contain the length.  */
-#  define INSTALL_DTV(TCBP, DTVP) \
-  (((tcbhead_t *) (TCBP))[-1].dtv = (DTVP) + 1)
-
-/* Install new dtv for current thread.  */
-#  define INSTALL_NEW_DTV(DTV) (THREAD_DTV() = (DTV))
-
-/* Return dtv of given thread descriptor.  */
-#  define GET_DTV(TCBP)	(((tcbhead_t *) (TCBP))[-1].dtv)
-
-/* We still need this define so that tcb-offsets.sym can override it and
-   use THREAD_SELF to generate MULTIPLE_THREADS_OFFSET.  */
-#  define __thread_register ((void *) __thread_self)
-
-/* Code to initially initialize the thread pointer.  This might need
-   special attention since 'errno' is not yet available and if the
-   operation can cause a failure 'errno' must not be touched.
-
-   The global register variable is declared in pt-machine.h with the
-   wrong type, so we need some extra casts to get the desired result.
-   This avoids a lvalue cast that gcc-3.4 does not like.  */
-# define TLS_INIT_TP(TCBP, SECONDCALL) \
-    (__thread_self = (struct _pthread_descr_struct *) \
-	((void *) (TCBP) + TLS_TCB_OFFSET), NULL)
-
-/* Return the address of the dtv for the current thread.  */
-#  define THREAD_DTV() \
-     (((tcbhead_t *) ((void *) __thread_self - TLS_TCB_OFFSET))[-1].dtv)
-
-/* Return the thread descriptor for the current thread.  */
-#  undef THREAD_SELF
-#  define THREAD_SELF \
-    ((pthread_descr) (__thread_register \
-		      - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE))
-
-#  undef INIT_THREAD_SELF
-#  define INIT_THREAD_SELF(DESCR, NR) \
-     (__thread_self = (struct _pthread_descr_struct *)((void *) (DESCR) \
-		           + TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE))
-
-/* Make sure we have the p_multiple_threads member in the thread structure.
-   See below.  */
-#  define TLS_MULTIPLE_THREADS_IN_TCB 1
-
-/* Get the thread descriptor definition.  */
-#  include <linuxthreads/descr.h>
-
-/* l_tls_offset == 0 is perfectly valid on PPC, so we have to use some
-   different value to mean unset l_tls_offset.  */
-#  define NO_TLS_OFFSET	-1
-
-# endif /* __ASSEMBLER__ */
-
-#elif !defined __ASSEMBLER__
-
-/* This overlaps the start of the pthread_descr.  System calls
-   and such use this to find the multiple_threads flag and need
-   to use the same offset relative to the thread register in both
-   single-threaded and multi-threaded code.  */
-typedef struct
-{
-  void *tcb;			/* Never used.  */
-  dtv_t *dtv;			/* Never used.  */
-  void *self;			/* Used only if multithreaded, and rarely.  */
-  int multiple_threads;		/* Only this member is really used.  */
-} tcbhead_t;
-
-#define NONTLS_INIT_TP							\
-  do {									\
-    static const tcbhead_t nontls_init_tp = { .multiple_threads = 0 };	\
-    __thread_self = (__typeof (__thread_self)) &nontls_init_tp;		\
-  } while (0)
-
-#endif /* HAVE_TLS_SUPPORT */
-
-#endif	/* tls.h */
diff --git a/libpthread/linuxthreads/sysdeps/pthread/bits/initspin.h b/libpthread/linuxthreads/sysdeps/pthread/bits/initspin.h
deleted file mode 100644
index b9e4acf30..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/bits/initspin.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/* Generic definitions for spinlock initializers.
-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-/* Initial value of a spinlock.  Most platforms should use zero,
-   unless they only implement a "test and clear" operation instead of
-   the usual "test and set". */
-#define __LT_SPINLOCK_INIT 0
-
-/* Macros for lock initializers, using the above definition. */
-#define __LOCK_INITIALIZER { 0, __LT_SPINLOCK_INIT }
-#define __ALT_LOCK_INITIALIZER { 0, __LT_SPINLOCK_INIT }
-#define __ATOMIC_INITIALIZER { 0, __LT_SPINLOCK_INIT }
diff --git a/libpthread/linuxthreads/sysdeps/pthread/bits/libc-lock.h b/libpthread/linuxthreads/sysdeps/pthread/bits/libc-lock.h
index 855efff12..8833e343d 100644
--- a/libpthread/linuxthreads/sysdeps/pthread/bits/libc-lock.h
+++ b/libpthread/linuxthreads/sysdeps/pthread/bits/libc-lock.h
@@ -1,5 +1,5 @@
 /* libc-internal interface for mutex locks.  LinuxThreads version.
-   Copyright (C) 1996,1997,1998,1999,2000,2001,2002,2003,2006
+   Copyright (C) 1996,1997,1998,1999,2000,2001,2002,2003
    	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -23,13 +23,13 @@
 #include <pthread.h>
 
 #if defined _LIBC && !defined NOT_IN_libc
-#include <linuxthreads/internals.h>
+#include <linuxthreads.old/internals.h>
 #endif
 
 /* Mutex type.  */
 #if defined(_LIBC) || defined(_IO_MTSAFE_IO)
 typedef pthread_mutex_t __libc_lock_t;
-typedef struct { pthread_mutex_t mutex; } __libc_lock_recursive_t;
+typedef pthread_mutex_t __libc_lock_recursive_t;
 # ifdef __USE_UNIX98
 typedef pthread_rwlock_t __libc_rwlock_t;
 # else
@@ -131,15 +131,39 @@ typedef pthread_key_t __libc_key_t;
 #define __libc_rwlock_init(NAME) \
   (__libc_maybe_call (__pthread_rwlock_init, (&(NAME), NULL), 0));
 
+/* Same as last but this time we initialize an adaptive mutex.  */
+#if defined _LIBC && !defined NOT_IN_libc && defined SHARED
+#define __libc_lock_init_adaptive(NAME) \
+  ({									      \
+    (NAME).__m_count = 0;						      \
+    (NAME).__m_owner = NULL;						      \
+    (NAME).__m_kind = PTHREAD_MUTEX_ADAPTIVE_NP;			      \
+    (NAME).__m_lock.__status = 0;					      \
+    (NAME).__m_lock.__spinlock = __LT_SPINLOCK_INIT;			      \
+    0; })
+#else
+#define __libc_lock_init_adaptive(NAME) \
+  do {									      \
+    if (__pthread_mutex_init != NULL)					      \
+      {									      \
+	pthread_mutexattr_t __attr;					      \
+	__pthread_mutexattr_init (&__attr);				      \
+	__pthread_mutexattr_settype (&__attr, PTHREAD_MUTEX_ADAPTIVE_NP);     \
+	__pthread_mutex_init (&(NAME), &__attr);			      \
+	__pthread_mutexattr_destroy (&__attr);				      \
+      }									      \
+  } while (0);
+#endif
+
 /* Same as last but this time we initialize a recursive mutex.  */
 #if defined _LIBC && !defined NOT_IN_libc && defined SHARED
 #define __libc_lock_init_recursive(NAME) \
   ({									      \
-    (NAME).mutex.__m_count = 0;						      \
-    (NAME).mutex.__m_owner = NULL;					      \
-    (NAME).mutex.__m_kind = PTHREAD_MUTEX_RECURSIVE_NP;			      \
-    (NAME).mutex.__m_lock.__status = 0;					      \
-    (NAME).mutex.__m_lock.__spinlock = __LT_SPINLOCK_INIT;		      \
+    (NAME).__m_count = 0;						      \
+    (NAME).__m_owner = NULL;					      \
+    (NAME).__m_kind = PTHREAD_MUTEX_RECURSIVE_NP;			      \
+    (NAME).__m_lock.__status = 0;					      \
+    (NAME).__m_lock.__spinlock = __LT_SPINLOCK_INIT;		      \
     0; })
 #else
 #define __libc_lock_init_recursive(NAME) \
@@ -149,7 +173,7 @@ typedef pthread_key_t __libc_key_t;
 	pthread_mutexattr_t __attr;					      \
 	__pthread_mutexattr_init (&__attr);				      \
 	__pthread_mutexattr_settype (&__attr, PTHREAD_MUTEX_RECURSIVE_NP); \
-	__pthread_mutex_init (&(NAME).mutex, &__attr);			      \
+	__pthread_mutex_init (&(NAME), &__attr);			      \
 	__pthread_mutexattr_destroy (&__attr);				      \
       }									      \
   } while (0);
@@ -202,23 +226,6 @@ typedef pthread_key_t __libc_key_t;
 /* Unlock the recursive named lock variable.  */
 #define __libc_lock_unlock_recursive(NAME) __libc_lock_unlock ((NAME).mutex)
 
-#if defined _LIBC && defined SHARED
-# define __rtld_lock_default_lock_recursive(lock) \
-  ++((pthread_mutex_t *)(lock))->__m_count;
-
-# define __rtld_lock_default_unlock_recursive(lock) \
-  --((pthread_mutex_t *)(lock))->__m_count;
-
-# define __rtld_lock_lock_recursive(NAME) \
-  GL(dl_rtld_lock_recursive) (&(NAME).mutex)
-
-# define __rtld_lock_unlock_recursive(NAME) \
-  GL(dl_rtld_unlock_recursive) (&(NAME).mutex)
-#else
-#define __rtld_lock_lock_recursive(NAME) __libc_lock_lock_recursive (NAME)
-#define __rtld_lock_unlock_recursive(NAME) __libc_lock_unlock_recursive (NAME)
-#endif
-
 /* Define once control variable.  */
 #if PTHREAD_ONCE_INIT == 0
 /* Special case for static variables where we can avoid the initialization
@@ -237,7 +244,7 @@ typedef pthread_key_t __libc_key_t;
       __pthread_once (&(ONCE_CONTROL), (INIT_FUNCTION));		      \
     else if ((ONCE_CONTROL) == PTHREAD_ONCE_INIT) {			      \
       INIT_FUNCTION ();							      \
-      (ONCE_CONTROL) = 2;						      \
+      (ONCE_CONTROL) = !PTHREAD_ONCE_INIT;				      \
     }									      \
   } while (0)
 
@@ -263,6 +270,7 @@ typedef pthread_key_t __libc_key_t;
       _pthread_cleanup_pop_restore (&_buffer, (DOIT));			      \
     }
 
+#if 0
 #define __libc_cleanup_push(fct, arg) \
     { struct _pthread_cleanup_buffer _buffer; 				      \
     __libc_maybe_call (_pthread_cleanup_push, (&_buffer, (fct), (arg)), 0)
@@ -270,6 +278,7 @@ typedef pthread_key_t __libc_key_t;
 #define __libc_cleanup_pop(execute) \
     __libc_maybe_call (_pthread_cleanup_pop, (&_buffer, execute), 0);	      \
     }
+#endif
 
 /* Create thread-specific key.  */
 #define __libc_key_create(KEY, DESTRUCTOR) \
@@ -367,7 +376,6 @@ weak_extern (BP_SYM (__pthread_key_create))
 weak_extern (BP_SYM (__pthread_setspecific))
 weak_extern (BP_SYM (__pthread_getspecific))
 weak_extern (BP_SYM (__pthread_once))
-weak_extern (__pthread_initialize)
 weak_extern (__pthread_atfork)
 weak_extern (BP_SYM (_pthread_cleanup_push))
 weak_extern (BP_SYM (_pthread_cleanup_pop))
@@ -392,7 +400,6 @@ weak_extern (BP_SYM (_pthread_cleanup_pop_restore))
 #  pragma weak __pthread_setspecific
 #  pragma weak __pthread_getspecific
 #  pragma weak __pthread_once
-#  pragma weak __pthread_initialize
 #  pragma weak __pthread_atfork
 #  pragma weak _pthread_cleanup_push_defer
 #  pragma weak _pthread_cleanup_pop_restore
diff --git a/libpthread/linuxthreads/sysdeps/pthread/bits/libc-tsd.h b/libpthread/linuxthreads/sysdeps/pthread/bits/libc-tsd.h
index 7cc5f9cf6..97af75ebf 100644
--- a/libpthread/linuxthreads/sysdeps/pthread/bits/libc-tsd.h
+++ b/libpthread/linuxthreads/sysdeps/pthread/bits/libc-tsd.h
@@ -19,7 +19,19 @@
 #ifndef _BITS_LIBC_TSD_H
 #define _BITS_LIBC_TSD_H 1
 
-#include <linuxthreads/descr.h>
+/* Fast thread-specific data internal to libc.  */
+enum __libc_tsd_key_t { _LIBC_TSD_KEY_MALLOC = 0,
+			_LIBC_TSD_KEY_DL_ERROR,
+			_LIBC_TSD_KEY_RPC_VARS,
+			_LIBC_TSD_KEY_LOCALE,
+			_LIBC_TSD_KEY_CTYPE_B,
+			_LIBC_TSD_KEY_CTYPE_TOLOWER,
+			_LIBC_TSD_KEY_CTYPE_TOUPPER,
+			_LIBC_TSD_KEY_N };
+
+#include <features.h>
+#include <linuxthreads.old/internals.h>
+
 #ifdef __UCLIBC_HAS_TLS__
 #include <tls.h>
 
diff --git a/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h b/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h
index 8d01c8908..3eb592919 100644
--- a/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h
+++ b/libpthread/linuxthreads/sysdeps/pthread/bits/pthreadtypes.h
@@ -56,20 +56,10 @@ typedef struct __pthread_attr_s
 
 
 /* Conditions (not abstract because of PTHREAD_COND_INITIALIZER */
-
-#ifdef __GLIBC_HAVE_LONG_LONG
-__extension__ typedef long long __pthread_cond_align_t;
-#else
-typedef long __pthread_cond_align_t;
-#endif
-
 typedef struct
 {
   struct _pthread_fastlock __c_lock; /* Protect against concurrent access */
   _pthread_descr __c_waiting;        /* Threads waiting on this condition */
-  char __padding[48 - sizeof (struct _pthread_fastlock)
-		 - sizeof (_pthread_descr) - sizeof (__pthread_cond_align_t)];
-  __pthread_cond_align_t __align;
 } pthread_cond_t;
 
 
@@ -131,7 +121,7 @@ typedef struct
 
 #ifdef __USE_XOPEN2K
 /* POSIX spinlock data type.  */
-typedef __volatile__ int pthread_spinlock_t;
+typedef volatile int pthread_spinlock_t;
 
 /* POSIX barrier. */
 typedef struct {
diff --git a/libpthread/linuxthreads/sysdeps/pthread/bits/typesizes.h b/libpthread/linuxthreads/sysdeps/pthread/bits/typesizes.h
deleted file mode 100644
index 0e900d2d5..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/bits/typesizes.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* bits/typesizes.h -- underlying types for *_t.  Generic version.
-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _BITS_TYPES_H
-# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
-#endif
-
-#ifndef	_BITS_TYPESIZES_H
-#define	_BITS_TYPESIZES_H	1
-
-/* See <bits/types.h> for the meaning of these macros.  This file exists so
-   that <bits/types.h> need not vary across different GNU platforms.  */
-
-#define __DEV_T_TYPE		__UQUAD_TYPE
-#define __UID_T_TYPE		__U32_TYPE
-#define __GID_T_TYPE		__U32_TYPE
-#define __INO_T_TYPE		__ULONGWORD_TYPE
-#define __INO64_T_TYPE		__UQUAD_TYPE
-#define __MODE_T_TYPE		__U32_TYPE
-#define __NLINK_T_TYPE		__UWORD_TYPE
-#define __OFF_T_TYPE		__SLONGWORD_TYPE
-#define __OFF64_T_TYPE		__SQUAD_TYPE
-#define __PID_T_TYPE		__S32_TYPE
-#define __RLIM_T_TYPE		__ULONGWORD_TYPE
-#define __RLIM64_T_TYPE		__UQUAD_TYPE
-#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
-#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
-#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
-#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
-#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
-#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
-#define	__ID_T_TYPE		__U32_TYPE
-#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
-#define __TIME_T_TYPE		__SLONGWORD_TYPE
-#define __USECONDS_T_TYPE	__U32_TYPE
-#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
-#define __DADDR_T_TYPE		__S32_TYPE
-#define __SWBLK_T_TYPE		__SLONGWORD_TYPE
-#define __KEY_T_TYPE		__S32_TYPE
-#define __CLOCKID_T_TYPE	__S32_TYPE
-#define __TIMER_T_TYPE		__S32_TYPE
-#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
-#define __FSID_T_TYPE		struct { int __val[2]; }
-#define __SSIZE_T_TYPE		__SWORD_TYPE
-
-/* Number of descriptors that can fit in an `fd_set'.  */
-#define	__FD_SETSIZE		1024
-
-
-#endif /* bits/typesizes.h */
diff --git a/libpthread/linuxthreads/sysdeps/pthread/errno-loc.c b/libpthread/linuxthreads/sysdeps/pthread/errno-loc.c
deleted file mode 100644
index 8bdfff485..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/errno-loc.c
+++ /dev/null
@@ -1,44 +0,0 @@
-/* MT support function to get address of `errno' variable, linuxthreads
-   version.
-   Copyright (C) 1996, 1998, 2002, 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <linuxthreads/internals.h>
-#include <sysdep-cancel.h>
-
-#if !defined __UCLIBC_HAS_TLS__ && !RTLD_PRIVATE_ERRNO
-#undef errno
-extern int errno;
-#endif
-
-int *
-#ifndef __UCLIBC_HAS_TLS__
-weak_const_function
-#endif
-__errno_location (void)
-{
-#if !defined __UCLIBC_HAS_TLS__ && !defined NOT_IN_libc
-  if (! SINGLE_THREAD_P)
-    {
-      pthread_descr self = thread_self();
-      return LIBC_THREAD_GETMEM (self, p_errnop);
-    }
-#endif
-  return &errno;
-}
-libc_hidden_def (__errno_location)
diff --git a/libpthread/linuxthreads/sysdeps/pthread/flockfile.c b/libpthread/linuxthreads/sysdeps/pthread/flockfile.c
deleted file mode 100644
index 538e368a0..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/flockfile.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <pthread.h>
-#include <stdio.h>
-#include <libio.h>
-#include <bits/stdio-lock.h>
-
-
-void
-__flockfile (stream)
-     FILE *stream;
-{
-  _IO_lock_lock (*stream->_lock);
-}
-strong_alias (__flockfile, _IO_flockfile)
-weak_alias (__flockfile, flockfile)
diff --git a/libpthread/linuxthreads/sysdeps/pthread/ftrylockfile.c b/libpthread/linuxthreads/sysdeps/pthread/ftrylockfile.c
deleted file mode 100644
index d814258d8..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/ftrylockfile.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include <stdio.h>
-#include <bits/stdio-lock.h>
-
-
-int
-__ftrylockfile (stream)
-     FILE *stream;
-{
-  return _IO_lock_trylock (*stream->_lock);
-}
-strong_alias (__ftrylockfile, _IO_ftrylockfile)
-weak_alias (__ftrylockfile, ftrylockfile)
diff --git a/libpthread/linuxthreads/sysdeps/pthread/funlockfile.c b/libpthread/linuxthreads/sysdeps/pthread/funlockfile.c
deleted file mode 100644
index f45479936..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/funlockfile.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <pthread.h>
-#include <stdio.h>
-#include <libio.h>
-#include <bits/stdio-lock.h>
-
-
-void
-__funlockfile (stream)
-     FILE *stream;
-{
-  _IO_lock_unlock (*stream->_lock);
-}
-strong_alias (__funlockfile, _IO_funlockfile)
-weak_alias (__funlockfile, funlockfile)
diff --git a/libpthread/linuxthreads/sysdeps/pthread/getcpuclockid.c b/libpthread/linuxthreads/sysdeps/pthread/getcpuclockid.c
deleted file mode 100644
index 6acb179c5..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/getcpuclockid.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/* pthread_getcpuclockid -- Get POSIX clockid_t for a pthread_t.  Linux version
-   Copyright (C) 2000, 2001, 2004, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include <sys/time.h>
-#include <time.h>
-#include <internals.h>
-#include <spinlock.h>
-#include <bits/kernel-features.h>
-#include <kernel-posix-cpu-timers.h>
-
-
-#if !(__ASSUME_POSIX_CPU_TIMERS > 0)
-int __libc_missing_posix_cpu_timers attribute_hidden;
-#endif
-#if !(__ASSUME_POSIX_TIMERS > 0)
-int __libc_missing_posix_timers attribute_hidden;
-#endif
-
-int
-pthread_getcpuclockid (pthread_t thread_id, clockid_t *clock_id)
-{
-#ifdef __NR_clock_getres
-  pthread_handle handle = thread_handle(thread_id);
-  int pid;
-
-  __pthread_lock (&handle->h_lock, NULL);
-  if (nonexisting_handle (handle, thread_id))
-    {
-      __pthread_unlock (&handle->h_lock);
-      return ESRCH;
-    }
-  pid = handle->h_descr->p_pid;
-  __pthread_unlock (&handle->h_lock);
-
-  /* The clockid_t value is a simple computation from the PID.
-     But we do a clock_getres call to validate it if we aren't
-     yet sure we have the kernel support.  */
-
-  const clockid_t pidclock = MAKE_PROCESS_CPUCLOCK (pid, CPUCLOCK_SCHED);
-
-# if !(__ASSUME_POSIX_CPU_TIMERS > 0)
-#  if !(__ASSUME_POSIX_TIMERS > 0)
-  if (__libc_missing_posix_timers && !__libc_missing_posix_cpu_timers)
-    __libc_missing_posix_cpu_timers = 1;
-#  endif
-  if (!__libc_missing_posix_cpu_timers)
-    {
-      INTERNAL_SYSCALL_DECL (err);
-      int r = INTERNAL_SYSCALL (clock_getres, err, 2, pidclock, NULL);
-      if (!INTERNAL_SYSCALL_ERROR_P (r, err))
-# endif
-	{
-	  *clock_id = pidclock;
-	  return 0;
-	}
-
-# if !(__ASSUME_POSIX_CPU_TIMERS > 0)
-#  if !(__ASSUME_POSIX_TIMERS > 0)
-      if (INTERNAL_SYSCALL_ERRNO (r, err) == ENOSYS)
-	{
-	  /* The kernel doesn't support these calls at all.  */
-	  __libc_missing_posix_timers = 1;
-	  __libc_missing_posix_cpu_timers = 1;
-	}
-      else
-#  endif
-	if (INTERNAL_SYSCALL_ERRNO (r, err) == EINVAL)
-	  {
-	    /* The kernel doesn't support these clocks at all.  */
-	    __libc_missing_posix_cpu_timers = 1;
-	  }
-      else
-	return INTERNAL_SYSCALL_ERRNO (r, err);
-    }
-# endif
-#endif
-
-#ifdef CLOCK_THREAD_CPUTIME_ID
-  /* We need to store the thread ID in the CLOCKID variable together
-     with a number identifying the clock.  We reserve the low 3 bits
-     for the clock ID and the rest for the thread ID.  This is
-     problematic if the thread ID is too large.  But 29 bits should be
-     fine.
-
-     If some day more clock IDs are needed the ID part can be
-     enlarged.  The IDs are entirely internal.  */
-  if (2 * PTHREAD_THREADS_MAX
-      >= 1 << (8 * sizeof (*clock_id) - CLOCK_IDFIELD_SIZE))
-    return ERANGE;
-
-  /* Store the number.  */
-  *clock_id = CLOCK_THREAD_CPUTIME_ID | (thread_id << CLOCK_IDFIELD_SIZE);
-
-  return 0;
-#else
-  /* We don't have a timer for that.  */
-  return ENOENT;
-#endif
-}
diff --git a/libpthread/linuxthreads/sysdeps/pthread/herrno-loc.c b/libpthread/linuxthreads/sysdeps/pthread/herrno-loc.c
deleted file mode 100644
index 634c75245..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/herrno-loc.c
+++ /dev/null
@@ -1,44 +0,0 @@
-/* Copyright (C) 1996, 97, 98, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <netdb.h>
-#ifdef __UCLIBC_HAS_TLS__
-#include <tls.h>
-#endif
-#include <linuxthreads/internals.h>
-#include <sysdep-cancel.h>
-
-#ifndef __UCLIBC_HAS_TLS__
-# undef h_errno
-extern int h_errno;
-#endif
-
-/* When threaded, h_errno may be a per-thread variable.  */
-int *
-weak_const_function
-__h_errno_location (void)
-{
-#ifndef __UCLIBC_HAS_TLS__
-  if (! SINGLE_THREAD_P)
-    {
-      pthread_descr self = thread_self();
-      return LIBC_THREAD_GETMEM (self, p_h_errnop);
-    }
-#endif
-  return &h_errno;
-}
-libc_hidden_def (__h_errno_location)
diff --git a/libpthread/linuxthreads/sysdeps/pthread/list.h b/libpthread/linuxthreads/sysdeps/pthread/list.h
deleted file mode 100644
index 232988fd6..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/list.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _LIST_H
-#define _LIST_H	1
-
-/* The definitions of this file are adopted from those which can be
-   found in the Linux kernel headers to enable people familiar with
-   the latter find their way in these sources as well.  */
-
-
-/* Basic type for the double-link list.  */
-typedef struct list_head
-{
-  struct list_head *next;
-  struct list_head *prev;
-} list_t;
-
-
-/* Define a variable with the head and tail of the list.  */
-#define LIST_HEAD(name) \
-  list_t name = { &(name), &(name) }
-
-/* Initialize a new list head.  */
-#define INIT_LIST_HEAD(ptr) \
-  (ptr)->next = (ptr)->prev = (ptr)
-
-
-/* Add new element at the head of the list.  */
-static __inline__ void
-list_add (list_t *newp, list_t *head)
-{
-  head->next->prev = newp;
-  newp->next = head->next;
-  newp->prev = head;
-  head->next = newp;
-}
-
-
-/* Add new element at the tail of the list.  */
-static __inline__ void
-list_add_tail (list_t *newp, list_t *head)
-{
-  head->prev->next = newp;
-  newp->next = head;
-  newp->prev = head->prev;
-  head->prev = newp;
-}
-
-
-/* Remove element from list.  */
-static __inline__ void
-list_del (list_t *elem)
-{
-  elem->next->prev = elem->prev;
-  elem->prev->next = elem->next;
-}
-
-
-/* Join two lists.  */
-static __inline__ void
-list_splice (list_t *add, list_t *head)
-{
-  /* Do nothing if the list which gets added is empty.  */
-  if (add != add->next)
-    {
-      add->next->prev = head;
-      add->prev->next = head->next;
-      head->next->prev = add->prev;
-      head->next = add->next;
-    }
-}
-
-
-/* Get typed element from list at a given position.  */
-#define list_entry(ptr, type, member) \
-  ((type *) ((char *) (ptr) - (unsigned long) (&((type *) 0)->member)))
-
-
-
-/* Iterate forward over the elements of the list.  */
-#define list_for_each(pos, head) \
-  for (pos = (head)->next; pos != (head); pos = pos->next)
-
-
-/* Iterate forward over the elements of the list.  */
-#define list_for_each_prev(pos, head) \
-  for (pos = (head)->prev; pos != (head); pos = pos->prev)
-
-
-/* Iterate backwards over the elements list.  The list elements can be
-   removed from the list while doing this.  */
-#define list_for_each_prev_safe(pos, p, head) \
-  for (pos = (head)->prev, p = pos->prev; \
-       pos != (head); \
-       pos = p, p = pos->prev)
-
-#endif	/* list.h */
diff --git a/libpthread/linuxthreads/sysdeps/pthread/malloc-machine.h b/libpthread/linuxthreads/sysdeps/pthread/malloc-machine.h
deleted file mode 100644
index f70729fd7..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/malloc-machine.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/* Basic platform-independent macro definitions for mutexes,
-   thread-specific data and parameters for malloc.
-   Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _MALLOC_MACHINE_H
-#define _MALLOC_MACHINE_H
-
-#undef thread_atfork_static
-
-#include <atomic.h>
-#include <bits/libc-lock.h>
-
-__libc_lock_define (typedef, mutex_t)
-
-#define mutex_init(m)		\
-  __libc_maybe_call2 (pthread_mutex_init, (m, NULL), (*(int *)(m) = 0))
-#define mutex_lock(m)		\
-  __libc_maybe_call2 (pthread_mutex_lock, (m), ((*(int *)(m) = 1), 0))
-#define mutex_trylock(m)	\
-  __libc_maybe_call2 (pthread_mutex_trylock, (m), \
-		      (*(int *)(m) ? 1 : ((*(int *)(m) = 1), 0)))
-#define mutex_unlock(m)		\
-  __libc_maybe_call2 (pthread_mutex_unlock, (m), (*(int *)(m) = 0))
-
-/* This is defined by newer gcc version unique for each module.  */
-extern void *__dso_handle __attribute__ ((__weak__));
-
-#include <fork.h>
-
-#ifdef SHARED
-# define thread_atfork(prepare, parent, child) \
-   __register_atfork (prepare, parent, child, __dso_handle)
-#else
-# define thread_atfork(prepare, parent, child) \
-   __register_atfork (prepare, parent, child,				      \
-		      &__dso_handle == NULL ? NULL : __dso_handle)
-#endif
-
-/* thread specific data for glibc */
-
-#include <bits/libc-tsd.h>
-
-typedef int tsd_key_t[1];	/* no key data structure, libc magic does it */
-__libc_tsd_define (static, MALLOC)	/* declaration/common definition */
-#define tsd_key_create(key, destr)	((void) (key))
-#define tsd_setspecific(key, data)	__libc_tsd_set (MALLOC, (data))
-#define tsd_getspecific(key, vptr)	((vptr) = __libc_tsd_get (MALLOC))
-
-#include <sysdeps/generic/malloc-machine.h>
-
-#endif /* !defined(_MALLOC_MACHINE_H) */
diff --git a/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h b/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h
index b46d2ab49..bbdb0739c 100644
--- a/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h
+++ b/libpthread/linuxthreads/sysdeps/pthread/not-cancel.h
@@ -23,10 +23,10 @@
 /* Uncancelable open.  */
 #if defined __NR_openat && !defined __NR_open
 #define open_not_cancel(name, flags, mode) \
-	INLINE_SYSCALL (openat, 4, (int) (AT_FDCWD), (const char *) (name), \
+	INLINE_SYSCALL (openat, 4, AT_FDCWD, (const char *) (name), \
 		(flags), (mode))
 #define open_not_cancel_2(name, flags) \
-	INLINE_SYSCALL (openat, 3, (int) (AT_FDCWD), (const char *) (name), \
+	INLINE_SYSCALL (openat, 3, AT_FDCWD, (const char *) (name), \
 		(flags))
 #else
 #define open_not_cancel(name, flags, mode) \
diff --git a/libpthread/linuxthreads/sysdeps/pthread/posix-timer.h b/libpthread/linuxthreads/sysdeps/pthread/posix-timer.h
deleted file mode 100644
index 4ac64d9ac..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/posix-timer.h
+++ /dev/null
@@ -1,203 +0,0 @@
-/* Definitions for POSIX timer implementation on top of LinuxThreads.
-   Copyright (C) 2000, 2002, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <limits.h>
-#include <signal.h>
-
-/* Double linked list.  */
-struct list_links
-{
-  struct list_links *next;
-  struct list_links *prev;
-};
-
-
-/* Forward declaration.  */
-struct timer_node;
-
-
-/* Definitions for an internal thread of the POSIX timer implementation.  */
-struct thread_node
-{
-  struct list_links links;
-  pthread_attr_t attr;
-  pthread_t id;
-  unsigned int exists;
-  struct list_links timer_queue;
-  pthread_cond_t cond;
-  struct timer_node *current_timer;
-  pthread_t captured;
-  clockid_t clock_id;
-};
-
-
-/* Internal representation of a timer.  */
-struct timer_node
-{
-  struct list_links links;
-  struct sigevent event;
-  clockid_t clock;
-  struct itimerspec value;
-  struct timespec expirytime;
-  pthread_attr_t attr;
-  unsigned int abstime;
-  unsigned int armed;
-  enum {
-    TIMER_FREE, TIMER_INUSE, TIMER_DELETED
-  } inuse;
-  struct thread_node *thread;
-  pid_t creator_pid;
-  int refcount;
-  int overrun_count;
-};
-
-
-/* Static array with the structures for all the timers.  */
-extern struct timer_node __timer_array[TIMER_MAX];
-
-/* Global lock to protect operation on the lists.  */
-extern pthread_mutex_t __timer_mutex;
-
-/* Variable to protext initialization.  */
-extern pthread_once_t __timer_init_once_control;
-
-/* Nonzero if initialization of timer implementation failed.  */
-extern int __timer_init_failed;
-
-/* Nodes for the threads used to deliver signals.  */
-/* A distinct thread is used for each clock type.  */
-
-extern struct thread_node __timer_signal_thread_rclk;
-
-
-/* Return pointer to timer structure corresponding to ID.  */
-static __inline__ struct timer_node *
-timer_id2ptr (timer_t timerid)
-{
-  if (timerid >= 0 && timerid < TIMER_MAX)
-    return &__timer_array[timerid];
-
-  return NULL;
-}
-
-/* Return ID of TIMER.  */
-static __inline__ int
-timer_ptr2id (struct timer_node *timer)
-{
-  return timer - __timer_array;
-}
-
-/* Check whether timer is valid; global mutex must be held. */
-static __inline__ int
-timer_valid (struct timer_node *timer)
-{
-  return timer && timer->inuse == TIMER_INUSE;
-}
-
-/* Timer refcount functions; need global mutex. */
-extern void __timer_dealloc (struct timer_node *timer);
-
-static __inline__ void
-timer_addref (struct timer_node *timer)
-{
-  timer->refcount++;
-}
-
-static __inline__ void
-timer_delref (struct timer_node *timer)
-{
-  if (--timer->refcount == 0)
-    __timer_dealloc (timer);
-}
-
-/* Timespec helper routines.  */
-static __inline__ int
-timespec_compare (const struct timespec *left, const struct timespec *right)
-{
-  if (left->tv_sec < right->tv_sec)
-    return -1;
-  if (left->tv_sec > right->tv_sec)
-    return 1;
-
-  if (left->tv_nsec < right->tv_nsec)
-    return -1;
-  if (left->tv_nsec > right->tv_nsec)
-    return 1;
-
-  return 0;
-}
-
-static __inline__ void
-timespec_add (struct timespec *sum, const struct timespec *left,
-	      const struct timespec *right)
-{
-  sum->tv_sec = left->tv_sec + right->tv_sec;
-  sum->tv_nsec = left->tv_nsec + right->tv_nsec;
-
-  if (sum->tv_nsec >= 1000000000)
-    {
-      ++sum->tv_sec;
-      sum->tv_nsec -= 1000000000;
-    }
-}
-
-static __inline__ void
-timespec_sub (struct timespec *diff, const struct timespec *left,
-	      const struct timespec *right)
-{
-  diff->tv_sec = left->tv_sec - right->tv_sec;
-  diff->tv_nsec = left->tv_nsec - right->tv_nsec;
-
-  if (diff->tv_nsec < 0)
-    {
-      --diff->tv_sec;
-      diff->tv_nsec += 1000000000;
-    }
-}
-
-
-/* We need one of the list functions in the other modules.  */
-static __inline__ void
-list_unlink_ip (struct list_links *list)
-{
-  struct list_links *lnext = list->next, *lprev = list->prev;
-
-  lnext->prev = lprev;
-  lprev->next = lnext;
-
-  /* The suffix ip means idempotent; list_unlink_ip can be called
-   * two or more times on the same node.
-   */
-
-  list->next = list;
-  list->prev = list;
-}
-
-
-/* Functions in the helper file.  */
-extern void __timer_mutex_cancel_handler (void *arg);
-extern void __timer_init_once (void);
-extern struct timer_node *__timer_alloc (void);
-extern int __timer_thread_start (struct thread_node *thread);
-extern struct thread_node *__timer_thread_find_matching (const pthread_attr_t *desired_attr, clockid_t);
-extern struct thread_node *__timer_thread_alloc (const pthread_attr_t *desired_attr, clockid_t);
-extern void __timer_thread_dealloc (struct thread_node *thread);
-extern int __timer_thread_queue_timer (struct thread_node *thread,
-				       struct timer_node *insert);
-extern void __timer_thread_wakeup (struct thread_node *thread);
diff --git a/libpthread/linuxthreads/sysdeps/pthread/pt-initfini.c b/libpthread/linuxthreads/sysdeps/pthread/pt-initfini.c
deleted file mode 100644
index 86d4c84e9..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/pt-initfini.c
+++ /dev/null
@@ -1,123 +0,0 @@
-/* Special .init and .fini section support.  Linuxthread version.
-   Copyright (C) 1995, 1996, 1997, 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   In addition to the permissions in the GNU Lesser General Public
-   License, the Free Software Foundation gives you unlimited
-   permission to link the compiled version of this file with other
-   programs, and to distribute those programs without any restriction
-   coming from the use of this file.  (The Lesser General Public
-   License restrictions do apply in other respects; for example, they
-   cover modification of the file, and distribution when not linked
-   into another program.)
-
-   The GNU C Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-/* This file is compiled into assembly code which is then munged by a sed
-   script into two files: crti.s and crtn.s.
-
-   * crti.s puts a function prologue at the beginning of the
-   .init and .fini sections and defines global symbols for
-   those addresses, so they can be called as functions.
-
-   * crtn.s puts the corresponding function epilogues
-   in the .init and .fini sections. */
-
-#include <stdlib.h>
-
-/* We use embedded asm for .section unconditionally, as this makes it
-   easier to insert the necessary directives into crtn.S. */
-#define SECTION(x) __asm__ (".section " x )
-
-/* Embed an #include to pull in the alignment and .end directives. */
-__asm__ ("\n#include \"defs.h\"");
-
-/* The initial common code ends here. */
-__asm__ ("\n/*@HEADER_ENDS*/");
-
-/* To determine whether we need .end and .align: */
-__asm__ ("\n/*@TESTS_BEGIN*/");
-extern void dummy (void (*foo) (void));
-void
-dummy (void (*foo) (void))
-{
-  if (foo)
-    (*foo) ();
-}
-__asm__ ("\n/*@TESTS_END*/");
-
-/* The beginning of _init:  */
-__asm__ ("\n/*@_init_PROLOG_BEGINS*/");
-
-static void
-call_initialize_minimal (void)
-{
-  extern void __pthread_initialize_minimal (void);
-
-  __pthread_initialize_minimal ();
-}
-
-SECTION (".init");
-extern void _init (void);
-void
-_init (void)
-{
-  /* The very first thing we must do is to set up the registers.  */
-  call_initialize_minimal ();
-
-  __asm__ ("ALIGN");
-  __asm__("END_INIT");
-  /* Now the epilog. */
-  __asm__ ("\n/*@_init_PROLOG_ENDS*/");
-  __asm__ ("\n/*@_init_EPILOG_BEGINS*/");
-  SECTION(".init");
-}
-__asm__ ("END_INIT");
-
-/* End of the _init epilog, beginning of the _fini prolog. */
-__asm__ ("\n/*@_init_EPILOG_ENDS*/");
-__asm__ ("\n/*@_fini_PROLOG_BEGINS*/");
-
-SECTION (".fini");
-extern void _fini (void);
-void
-_fini (void)
-{
-
-  /* End of the _fini prolog. */
-  __asm__ ("ALIGN");
-  __asm__ ("END_FINI");
-  __asm__ ("\n/*@_fini_PROLOG_ENDS*/");
-
-  {
-    /* Let GCC know that _fini is not a leaf function by having a dummy
-       function call here.  We arrange for this call to be omitted from
-       either crt file.  */
-    extern void i_am_not_a_leaf (void);
-    i_am_not_a_leaf ();
-  }
-
-  /* Beginning of the _fini epilog. */
-  __asm__ ("\n/*@_fini_EPILOG_BEGINS*/");
-  SECTION (".fini");
-}
-__asm__ ("END_FINI");
-
-/* End of the _fini epilog.  Any further generated assembly (e.g. .ident)
-   is shared between both crt files. */
-__asm__ ("\n/*@_fini_EPILOG_ENDS*/");
-__asm__ ("\n/*@TRAILER_BEGINS*/");
-
-/* End of file. */
diff --git a/libpthread/linuxthreads/sysdeps/pthread/pthread-functions.h b/libpthread/linuxthreads/sysdeps/pthread/pthread-functions.h
index 6d8663dcb..2afaa52e8 100644
--- a/libpthread/linuxthreads/sysdeps/pthread/pthread-functions.h
+++ b/libpthread/linuxthreads/sysdeps/pthread/pthread-functions.h
@@ -20,17 +20,21 @@
 #define _PTHREAD_FUNCTIONS_H	1
 
 #include <pthread.h>
+#if 0
 #include <setjmp.h>
-#include <linuxthreads/descr.h>
+#include <linuxthreads.old/internals.h>
 
 struct fork_block;
+#endif
 
 /* Data type shared with libc.  The libc uses it to pass on calls to
    the thread functions.  Wine pokes directly into this structure,
    so if possible avoid breaking it and append new hooks to the end.  */
 struct pthread_functions
 {
+#if 0
   pid_t (*ptr_pthread_fork) (struct fork_block *);
+#endif
   int (*ptr_pthread_attr_destroy) (pthread_attr_t *);
   int (*ptr_pthread_attr_init) (pthread_attr_t *);
   int (*ptr_pthread_attr_getdetachstate) (const pthread_attr_t *, int *);
@@ -67,28 +71,36 @@ struct pthread_functions
   pthread_t (*ptr_pthread_self) (void);
   int (*ptr_pthread_setcancelstate) (int, int *);
   int (*ptr_pthread_setcanceltype) (int, int *);
+#if 0
   void (*ptr_pthread_do_exit) (void *retval, char *currentframe);
   void (*ptr_pthread_cleanup_upto) (__jmp_buf target,
 				    char *targetframe);
   pthread_descr (*ptr_pthread_thread_self) (void);
+#endif
 #if !defined __UCLIBC_HAS_TLS__ && defined __UCLIBC_HAS_RPC__
   int (*ptr_pthread_internal_tsd_set) (int key, const void *pointer);
   void * (*ptr_pthread_internal_tsd_get) (int key);
   void ** __attribute__ ((__const__))
     (*ptr_pthread_internal_tsd_address) (int key);
 #endif
+#if 0
   int (*ptr_pthread_sigaction) (int sig, const struct sigaction * act,
 				struct sigaction *oact);
   int (*ptr_pthread_sigwait) (const sigset_t *set, int *sig);
   int (*ptr_pthread_raise) (int sig);
+#endif
   int (*ptr_pthread_cond_timedwait) (pthread_cond_t *, pthread_mutex_t *,
 				       const struct timespec *);
+#if 0
   void (*ptr__pthread_cleanup_push) (struct _pthread_cleanup_buffer * buffer,
 				     void (*routine)(void *), void * arg);
+#endif
   void (*ptr__pthread_cleanup_push_defer) (struct _pthread_cleanup_buffer * buffer,
 					   void (*routine)(void *), void * arg);
+#if 0
   void (*ptr__pthread_cleanup_pop) (struct _pthread_cleanup_buffer * buffer,
 				    int execute);
+#endif
   void (*ptr__pthread_cleanup_pop_restore) (struct _pthread_cleanup_buffer * buffer,
 					    int execute);
 };
diff --git a/libpthread/linuxthreads/sysdeps/pthread/pthread.h b/libpthread/linuxthreads/sysdeps/pthread/pthread.h
index 94ed95c99..46c1010c6 100644
--- a/libpthread/linuxthreads/sysdeps/pthread/pthread.h
+++ b/libpthread/linuxthreads/sysdeps/pthread/pthread.h
@@ -31,7 +31,7 @@ __BEGIN_DECLS
 /* Initializers.  */
 
 #define PTHREAD_MUTEX_INITIALIZER \
-  {0, 0, 0, PTHREAD_MUTEX_TIMED_NP, __LOCK_INITIALIZER}
+  {0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __LOCK_INITIALIZER}
 #ifdef __USE_GNU
 # define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \
   {0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, __LOCK_INITIALIZER}
@@ -41,7 +41,7 @@ __BEGIN_DECLS
   {0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __LOCK_INITIALIZER}
 #endif
 
-#define PTHREAD_COND_INITIALIZER {__LOCK_INITIALIZER, 0, "", 0}
+#define PTHREAD_COND_INITIALIZER {__LOCK_INITIALIZER, 0}
 
 #if defined __USE_UNIX98 || defined __USE_XOPEN2K
 # define PTHREAD_RWLOCK_INITIALIZER \
@@ -82,13 +82,13 @@ enum
 
 enum
 {
-  PTHREAD_MUTEX_TIMED_NP,
+  PTHREAD_MUTEX_ADAPTIVE_NP,
   PTHREAD_MUTEX_RECURSIVE_NP,
   PTHREAD_MUTEX_ERRORCHECK_NP,
-  PTHREAD_MUTEX_ADAPTIVE_NP
+  PTHREAD_MUTEX_TIMED_NP
 #ifdef __USE_UNIX98
   ,
-  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
+  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_ADAPTIVE_NP,
   PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
   PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
   PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
@@ -256,7 +256,7 @@ extern int pthread_attr_getguardsize (const pthread_attr_t *__restrict
 /* Set the starting address of the stack of the thread to be created.
    Depending on whether the stack grows up or down the value must either
    be higher or lower than all the address in the memory block.  The
-   minimal size of the block must be PTHREAD_STACK_MIN.  */
+   minimal size of the block must be PTHREAD_STACK_SIZE.  */
 extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
 				      void *__stackaddr) __THROW;
 
@@ -280,7 +280,7 @@ extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
 #endif
 
 /* Add information about the minimum stack size needed for the thread
-   to be started.  This size must never be less than PTHREAD_STACK_MIN
+   to be started.  This size must never be less than PTHREAD_STACK_SIZE
    and must also not exceed the system limits.  */
 extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
 				      size_t __stacksize) __THROW;
@@ -290,12 +290,16 @@ extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
 				      __attr, size_t *__restrict __stacksize)
      __THROW;
 
+#if 0
+/* Not yet implemented in uClibc! */
+
 #ifdef __USE_GNU
 /* Initialize thread attribute *ATTR with attributes corresponding to the
    already running thread TH.  It shall be called on uninitialized ATTR
    and destroyed with pthread_attr_destroy when no longer needed.  */
 extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr) __THROW;
 #endif
+#endif
 
 /* Functions for scheduling control.  */
 
@@ -319,6 +323,11 @@ extern int pthread_getconcurrency (void) __THROW;
 extern int pthread_setconcurrency (int __level) __THROW;
 #endif
 
+#ifdef __USE_GNU
+/* Same thing, different name */
+#define pthread_yield() sched_yield()
+#endif
+
 /* Functions for mutex handling.  */
 
 /* Initialize MUTEX using attributes in *MUTEX_ATTR, or use the
@@ -385,20 +394,25 @@ extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
 extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
 			      const pthread_condattr_t *__restrict
 			      __cond_attr) __THROW;
+libpthread_hidden_proto(pthread_cond_init)
 
 /* Destroy condition variable COND.  */
 extern int pthread_cond_destroy (pthread_cond_t *__cond) __THROW;
+libpthread_hidden_proto(pthread_cond_destroy)
 
 /* Wake up one thread waiting for condition variable COND.  */
 extern int pthread_cond_signal (pthread_cond_t *__cond) __THROW;
+libpthread_hidden_proto(pthread_cond_signal)
 
 /* Wake up all threads waiting for condition variables COND.  */
 extern int pthread_cond_broadcast (pthread_cond_t *__cond) __THROW;
+libpthread_hidden_proto(pthread_cond_broadcast)
 
 /* Wait for condition variable COND to be signaled or broadcast.
    MUTEX is assumed to be locked before.  */
 extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
 			      pthread_mutex_t *__restrict __mutex);
+libpthread_hidden_proto(pthread_cond_wait)
 
 /* Wait for condition variable COND to be signaled or broadcast until
    ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an
@@ -408,14 +422,17 @@ extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
 				   pthread_mutex_t *__restrict __mutex,
 				   const struct timespec *__restrict
 				   __abstime);
+libpthread_hidden_proto(pthread_cond_timedwait)
 
 /* Functions for handling condition variable attributes.  */
 
 /* Initialize condition variable attribute ATTR.  */
 extern int pthread_condattr_init (pthread_condattr_t *__attr) __THROW;
+libpthread_hidden_proto(pthread_condattr_init)
 
 /* Destroy condition variable attribute ATTR.  */
 extern int pthread_condattr_destroy (pthread_condattr_t *__attr) __THROW;
+libpthread_hidden_proto(pthread_condattr_destroy)
 
 /* Get the process-shared flag of the condition variable attribute ATTR.  */
 extern int pthread_condattr_getpshared (const pthread_condattr_t *
@@ -495,6 +512,9 @@ extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
 					  int __pref) __THROW;
 #endif
 
+#if 0
+/* Not yet implemented in uClibc! */
+
 #ifdef __USE_XOPEN2K
 /* The IEEE Std. 1003.1j-2000 introduces functions to implement
    spinlocks.  */
@@ -538,6 +558,7 @@ extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
 
 extern int pthread_barrier_wait (pthread_barrier_t *__barrier) __THROW;
 #endif
+#endif
 
 
 /* Functions for handling thread-specific data.  */
@@ -629,6 +650,9 @@ extern void _pthread_cleanup_pop (struct _pthread_cleanup_buffer *__buffer,
 extern void _pthread_cleanup_push_defer (struct _pthread_cleanup_buffer *__buffer,
 					 void (*__routine) (void *),
 					 void *__arg) __THROW;
+extern void __pthread_cleanup_push_defer (struct _pthread_cleanup_buffer *__buffer,
+					  void (*__routine) (void *),
+					  void *__arg) __THROW;
 
 /* Remove a cleanup handler as pthread_cleanup_pop does, but also
    restores the cancellation type that was in effect when the matching
@@ -639,13 +663,19 @@ extern void _pthread_cleanup_push_defer (struct _pthread_cleanup_buffer *__buffe
 
 extern void _pthread_cleanup_pop_restore (struct _pthread_cleanup_buffer *__buffer,
 					  int __execute) __THROW;
+extern void __pthread_cleanup_pop_restore (struct _pthread_cleanup_buffer *__buffer,
+					   int __execute) __THROW;
 #endif
 
 
+#if 0
+/* Not yet implemented in uClibc! */
+
 #ifdef __USE_XOPEN2K
 /* Get ID of CPU-time clock for thread THREAD_ID.  */
 extern int pthread_getcpuclockid (pthread_t __thread_id,
-				  __clockid_t *__clock_id) __THROW;
+				  clockid_t *__clock_id) __THROW;
+#endif
 #endif
 
 
diff --git a/libpthread/linuxthreads/sysdeps/pthread/ptlongjmp.c b/libpthread/linuxthreads/sysdeps/pthread/ptlongjmp.c
deleted file mode 100644
index ee5522036..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/ptlongjmp.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1998 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Redefine siglongjmp and longjmp so that they interact correctly
-   with cleanup handlers */
-
-#include <setjmp.h>
-#include "pthread.h"
-#include "internals.h"
-
-#ifdef SHARED
-void siglongjmp (sigjmp_buf env, int val)
-{
-  __libc_siglongjmp (env, val);
-}
-
-void longjmp (jmp_buf env, int val)
-{
-  __libc_longjmp (env, val);
-}
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/pthread/res-state.c b/libpthread/linuxthreads/sysdeps/pthread/res-state.c
deleted file mode 100644
index 6b4354972..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/res-state.c
+++ /dev/null
@@ -1,46 +0,0 @@
-/* Copyright (C) 1996, 97, 98, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <resolv.h>
-#include <tls.h>
-#include <linuxthreads/internals.h>
-#include <sysdep-cancel.h>
-
-#ifndef __UCLIBC_HAS_TLS__
-# undef _res
-extern struct __res_state _res;
-#endif
-
-/* When threaded, _res may be a per-thread variable.  */
-struct __res_state *
-#ifndef __UCLIBC_HAS_TLS__
-weak_const_function
-#endif
-__res_state (void)
-{
-#ifndef __UCLIBC_HAS_TLS__
-  if (! SINGLE_THREAD_P)
-    {
-      pthread_descr self = thread_self();
-      return LIBC_THREAD_GETMEM (self, p_resp);
-    }
-  return &_res;
-#else
-  return __resp;
-#endif
-}
-libc_hidden_def (__res_state)
diff --git a/libpthread/linuxthreads/sysdeps/pthread/semaphore.h b/libpthread/linuxthreads/sysdeps/pthread/semaphore.h
deleted file mode 100644
index 8793768a8..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/semaphore.h
+++ /dev/null
@@ -1 +0,0 @@
-#include <linuxthreads/semaphore.h>
diff --git a/libpthread/linuxthreads/sysdeps/pthread/sigaction.c b/libpthread/linuxthreads/sysdeps/pthread/sigaction.c
deleted file mode 100644
index eecb8c395..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/sigaction.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/* Copyright (C) 2003, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-/* Somebody please explain what's going on here.  --vda */
-
-/* This is tricky.  GCC doesn't like #include_next in the primary
-   source file and even if it did, the first #include_next is this
-   exact file anyway.  */
-#ifndef LIBC_SIGACTION
-
-# include <bits/libc-lock.h>
-
-# define LIBC_SIGACTION	1
-
-# include "sigaction.c"
-
-# ifndef NOT_IN_libc
-#  ifndef SHARED
-weak_extern (__pthread_sigaction)
-#  endif
-
-int
-__sigaction (sig, act, oact)
-     int sig;
-     const struct sigaction *act;
-     struct sigaction *oact;
-{
-  return __libc_maybe_call2 (pthread_sigaction, (sig, act, oact),
-			     __libc_sigaction (sig, act, oact));
-}
-# else
-weak_alias (__libc_sigaction, __sigaction)
-# endif
-libc_hidden_weak (__sigaction)
-weak_alias (__sigaction, sigaction)
-
-#else
-
-# include_next <sigaction.c>
-
-#endif /* LIBC_SIGACTION */
diff --git a/libpthread/linuxthreads/sysdeps/pthread/tcb-offsets.h b/libpthread/linuxthreads/sysdeps/pthread/tcb-offsets.h
deleted file mode 100644
index 3fe13702e..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/tcb-offsets.h
+++ /dev/null
@@ -1 +0,0 @@
-/* This is overridden by generated tcb-offsets.h on arches which need it.  */
diff --git a/libpthread/linuxthreads/sysdeps/pthread/timer_create.c b/libpthread/linuxthreads/sysdeps/pthread/timer_create.c
deleted file mode 100644
index 36fce3567..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/timer_create.c
+++ /dev/null
@@ -1,169 +0,0 @@
-/* Copyright (C) 2000, 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <signal.h>
-#include <pthread.h>
-#include <time.h>
-#include <unistd.h>
-
-#include "posix-timer.h"
-
-
-/* Create new per-process timer using CLOCK.  */
-int
-timer_create (clock_id, evp, timerid)
-     clockid_t clock_id;
-     struct sigevent *evp;
-     timer_t *timerid;
-{
-  int retval = -1;
-  struct timer_node *newtimer = NULL;
-  struct thread_node *thread = NULL;
-
-  if (0
-#ifdef _POSIX_CPUTIME
-      || clock_id == CLOCK_PROCESS_CPUTIME_ID
-#endif
-#ifdef _POSIX_THREAD_CPUTIME
-      || clock_id == CLOCK_THREAD_CPUTIME_ID
-#endif
-      )
-    {
-      /* We don't allow timers for CPU clocks.  At least not in the
-	 moment.  */
-      __set_errno (ENOTSUP);
-      return -1;
-    }
-
-  if (clock_id != CLOCK_REALTIME)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  pthread_once (&__timer_init_once_control, __timer_init_once);
-
-  if (__timer_init_failed)
-    {
-      __set_errno (ENOMEM);
-      return -1;
-    }
-
-  pthread_mutex_lock (&__timer_mutex);
-
-  newtimer = __timer_alloc ();
-  if (__builtin_expect (newtimer == NULL, 0))
-    {
-      __set_errno (EAGAIN);
-      goto unlock_bail;
-    }
-
-  if (evp != NULL)
-    newtimer->event = *evp;
-  else
-    {
-      newtimer->event.sigev_notify = SIGEV_SIGNAL;
-      newtimer->event.sigev_signo = SIGALRM;
-      newtimer->event.sigev_value.sival_int = timer_ptr2id (newtimer);
-      newtimer->event.sigev_notify_function = 0;
-    }
-
-  newtimer->event.sigev_notify_attributes = &newtimer->attr;
-  newtimer->creator_pid = getpid ();
-
-  switch (__builtin_expect (newtimer->event.sigev_notify, SIGEV_SIGNAL))
-    {
-    case SIGEV_NONE:
-    case SIGEV_SIGNAL:
-      /* We have a global thread for delivering timed signals.
-	 If it is not running, try to start it up.  */
-      thread = &__timer_signal_thread_rclk;
-      if (! thread->exists)
-	{
-	  if (__builtin_expect (__timer_thread_start (thread),
-				1) < 0)
-	    {
-	      __set_errno (EAGAIN);
-	      goto unlock_bail;
-            }
-        }
-      break;
-
-    case SIGEV_THREAD:
-      /* Copy over thread attributes or set up default ones.  */
-      if (evp->sigev_notify_attributes)
-	newtimer->attr = *(pthread_attr_t *) evp->sigev_notify_attributes;
-      else
-	pthread_attr_init (&newtimer->attr);
-
-      /* Ensure thread attributes call for deatched thread.  */
-      pthread_attr_setdetachstate (&newtimer->attr, PTHREAD_CREATE_DETACHED);
-
-      /* Try to find existing thread having the right attributes.  */
-      thread = __timer_thread_find_matching (&newtimer->attr, clock_id);
-
-      /* If no existing thread has these attributes, try to allocate one.  */
-      if (thread == NULL)
-	thread = __timer_thread_alloc (&newtimer->attr, clock_id);
-
-      /* Out of luck; no threads are available.  */
-      if (__builtin_expect (thread == NULL, 0))
-	{
-	  __set_errno (EAGAIN);
-	  goto unlock_bail;
-	}
-
-      /* If the thread is not running already, try to start it.  */
-      if (! thread->exists
-	  && __builtin_expect (! __timer_thread_start (thread), 0))
-	{
-	  __set_errno (EAGAIN);
-	  goto unlock_bail;
-	}
-      break;
-
-    default:
-      __set_errno (EINVAL);
-      goto unlock_bail;
-    }
-
-  newtimer->clock = clock_id;
-  newtimer->abstime = 0;
-  newtimer->armed = 0;
-  newtimer->thread = thread;
-
-  *timerid = timer_ptr2id (newtimer);
-  retval = 0;
-
-  if (__builtin_expect (retval, 0) == -1)
-    {
-    unlock_bail:
-      if (thread != NULL)
-	__timer_thread_dealloc (thread);
-      if (newtimer != NULL)
-	{
-	  timer_delref (newtimer);
-	  __timer_dealloc (newtimer);
-	}
-    }
-
-  pthread_mutex_unlock (&__timer_mutex);
-
-  return retval;
-}
diff --git a/libpthread/linuxthreads/sysdeps/pthread/timer_delete.c b/libpthread/linuxthreads/sysdeps/pthread/timer_delete.c
deleted file mode 100644
index a529d7392..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/timer_delete.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <assert.h>
-#include <errno.h>
-#include <pthread.h>
-#include <time.h>
-
-#include "posix-timer.h"
-
-
-/* Delete timer TIMERID.  */
-int
-timer_delete (timerid)
-     timer_t timerid;
-{
-  struct timer_node *timer;
-  int retval = -1;
-
-  pthread_mutex_lock (&__timer_mutex);
-
-  timer = timer_id2ptr (timerid);
-  if (! timer_valid (timer))
-    /* Invalid timer ID or the timer is not in use.  */
-    __set_errno (EINVAL);
-  else
-    {
-      if (timer->armed && timer->thread != NULL)
-	{
-	  struct thread_node *thread = timer->thread;
-	  assert (thread != NULL);
-
-	  /* If thread is cancelled while waiting for handler to terminate,
-	     the mutex is unlocked and timer_delete is aborted.  */
-	  pthread_cleanup_push (__timer_mutex_cancel_handler, &__timer_mutex);
-
-	  /* If timer is currently being serviced, wait for it to finish.  */
-	  while (thread->current_timer == timer)
-	    pthread_cond_wait (&thread->cond, &__timer_mutex);
-
-	  pthread_cleanup_pop (0);
-        }
-
-      /* Remove timer from whatever queue it may be on and deallocate it.  */
-      timer->inuse = TIMER_DELETED;
-      list_unlink_ip (&timer->links);
-      timer_delref (timer);
-      retval = 0;
-    }
-
-  pthread_mutex_unlock (&__timer_mutex);
-
-  return retval;
-}
diff --git a/libpthread/linuxthreads/sysdeps/pthread/timer_getoverr.c b/libpthread/linuxthreads/sysdeps/pthread/timer_getoverr.c
deleted file mode 100644
index 6d753e30d..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/timer_getoverr.c
+++ /dev/null
@@ -1,44 +0,0 @@
-/* Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include <time.h>
-
-#include "posix-timer.h"
-
-
-/* Get expiration overrun for timer TIMERID.  */
-int
-timer_getoverrun (timerid)
-     timer_t timerid;
-{
-  struct timer_node *timer;
-  int retval = -1;
-
-  pthread_mutex_lock (&__timer_mutex);
-
-  if (! timer_valid (timer = timer_id2ptr (timerid)))
-    __set_errno (EINVAL);
-  else
-    retval = timer->overrun_count;
-
-  pthread_mutex_unlock (&__timer_mutex);
-
-  return retval;
-}
diff --git a/libpthread/linuxthreads/sysdeps/pthread/timer_gettime.c b/libpthread/linuxthreads/sysdeps/pthread/timer_gettime.c
deleted file mode 100644
index 6bd2b84e2..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/timer_gettime.c
+++ /dev/null
@@ -1,76 +0,0 @@
-/* Copyright (C) 2000, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include <time.h>
-
-#include "posix-timer.h"
-
-
-/* Get current value of timer TIMERID and store it in VLAUE.  */
-int
-timer_gettime (timerid, value)
-     timer_t timerid;
-     struct itimerspec *value;
-{
-  struct timer_node *timer;
-  struct timespec now, expiry;
-  int retval = -1, armed = 0, valid;
-  clock_t clock = 0;
-
-  pthread_mutex_lock (&__timer_mutex);
-
-  timer = timer_id2ptr (timerid);
-  valid = timer_valid (timer);
-
-  if (valid) {
-    armed = timer->armed;
-    expiry = timer->expirytime;
-    clock = timer->clock;
-    value->it_interval = timer->value.it_interval;
-  }
-
-  pthread_mutex_unlock (&__timer_mutex);
-
-  if (valid)
-    {
-      if (armed)
-	{
-	  clock_gettime (clock, &now);
-	  if (timespec_compare (&now, &expiry) < 0)
-	    timespec_sub (&value->it_value, &expiry, &now);
-	  else
-	    {
-	      value->it_value.tv_sec = 0;
-	      value->it_value.tv_nsec = 0;
-	    }
-	}
-      else
-	{
-	  value->it_value.tv_sec = 0;
-	  value->it_value.tv_nsec = 0;
-	}
-
-      retval = 0;
-    }
-  else
-    __set_errno (EINVAL);
-
-  return retval;
-}
diff --git a/libpthread/linuxthreads/sysdeps/pthread/timer_routines.c b/libpthread/linuxthreads/sysdeps/pthread/timer_routines.c
deleted file mode 100644
index 9f6096ba5..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/timer_routines.c
+++ /dev/null
@@ -1,572 +0,0 @@
-/* Helper code for POSIX timer implementation on LinuxThreads.
-   Copyright (C) 2000, 2001, 2002, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <assert.h>
-#include <errno.h>
-#include <pthread.h>
-#include <stddef.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sysdep.h>
-#include <time.h>
-#include <unistd.h>
-#include <sys/syscall.h>
-
-#include "posix-timer.h"
-
-
-/* Number of threads used.  */
-#define THREAD_MAXNODES	16
-
-/* Array containing the descriptors for the used threads.  */
-static struct thread_node thread_array[THREAD_MAXNODES];
-
-/* Static array with the structures for all the timers.  */
-struct timer_node __timer_array[TIMER_MAX];
-
-/* Global lock to protect operation on the lists.  */
-pthread_mutex_t __timer_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-/* Variable to protext initialization.  */
-pthread_once_t __timer_init_once_control = PTHREAD_ONCE_INIT;
-
-/* Nonzero if initialization of timer implementation failed.  */
-int __timer_init_failed;
-
-/* Node for the thread used to deliver signals.  */
-struct thread_node __timer_signal_thread_rclk;
-
-/* Lists to keep free and used timers and threads.  */
-struct list_links timer_free_list;
-struct list_links thread_free_list;
-struct list_links thread_active_list;
-
-
-#ifdef __NR_rt_sigqueueinfo
-extern int __syscall_rt_sigqueueinfo (int, int, siginfo_t *);
-#endif
-
-
-/* List handling functions.  */
-static __inline__ void
-list_init (struct list_links *list)
-{
-  list->next = list->prev = list;
-}
-
-static __inline__ void
-list_append (struct list_links *list, struct list_links *newp)
-{
-  newp->prev = list->prev;
-  newp->next = list;
-  list->prev->next = newp;
-  list->prev = newp;
-}
-
-static __inline__ void
-list_insbefore (struct list_links *list, struct list_links *newp)
-{
-  list_append (list, newp);
-}
-
-/*
- * Like list_unlink_ip, except that calling it on a node that
- * is already unlinked is disastrous rather than a noop.
- */
-
-static __inline__ void
-list_unlink (struct list_links *list)
-{
-  struct list_links *lnext = list->next, *lprev = list->prev;
-
-  lnext->prev = lprev;
-  lprev->next = lnext;
-}
-
-static __inline__ struct list_links *
-list_first (struct list_links *list)
-{
-  return list->next;
-}
-
-static __inline__ struct list_links *
-list_null (struct list_links *list)
-{
-  return list;
-}
-
-static __inline__ struct list_links *
-list_next (struct list_links *list)
-{
-  return list->next;
-}
-
-static __inline__ int
-list_isempty (struct list_links *list)
-{
-  return list->next == list;
-}
-
-
-/* Functions build on top of the list functions.  */
-static __inline__ struct thread_node *
-thread_links2ptr (struct list_links *list)
-{
-  return (struct thread_node *) ((char *) list
-				 - offsetof (struct thread_node, links));
-}
-
-static __inline__ struct timer_node *
-timer_links2ptr (struct list_links *list)
-{
-  return (struct timer_node *) ((char *) list
-				- offsetof (struct timer_node, links));
-}
-
-
-/* Initialize a newly allocated thread structure.  */
-static void
-thread_init (struct thread_node *thread, const pthread_attr_t *attr, clockid_t clock_id)
-{
-  if (attr != NULL)
-    thread->attr = *attr;
-  else
-    {
-      pthread_attr_init (&thread->attr);
-      pthread_attr_setdetachstate (&thread->attr, PTHREAD_CREATE_DETACHED);
-    }
-
-  thread->exists = 0;
-  list_init (&thread->timer_queue);
-  pthread_cond_init (&thread->cond, 0);
-  thread->current_timer = 0;
-  thread->captured = pthread_self ();
-  thread->clock_id = clock_id;
-}
-
-
-/* Initialize the global lists, and acquire global resources.  Error
-   reporting is done by storing a non-zero value to the global variable
-   timer_init_failed.  */
-static void
-init_module (void)
-{
-  int i;
-
-  list_init (&timer_free_list);
-  list_init (&thread_free_list);
-  list_init (&thread_active_list);
-
-  for (i = 0; i < TIMER_MAX; ++i)
-    {
-      list_append (&timer_free_list, &__timer_array[i].links);
-      __timer_array[i].inuse = TIMER_FREE;
-    }
-
-  for (i = 0; i < THREAD_MAXNODES; ++i)
-    list_append (&thread_free_list, &thread_array[i].links);
-
-  thread_init (&__timer_signal_thread_rclk, 0, CLOCK_REALTIME);
-}
-
-
-/* This is a handler executed in a child process after a fork()
-   occurs.  It reinitializes the module, resetting all of the data
-   structures to their initial state.  The mutex is initialized in
-   case it was locked in the parent process.  */
-static void
-reinit_after_fork (void)
-{
-  init_module ();
-  pthread_mutex_init (&__timer_mutex, 0);
-}
-
-
-/* Called once form pthread_once in timer_init. This initializes the
-   module and ensures that reinit_after_fork will be executed in any
-   child process.  */
-void
-__timer_init_once (void)
-{
-  init_module ();
-  pthread_atfork (0, 0, reinit_after_fork);
-}
-
-
-/* Deinitialize a thread that is about to be deallocated.  */
-static void
-thread_deinit (struct thread_node *thread)
-{
-  assert (list_isempty (&thread->timer_queue));
-  pthread_cond_destroy (&thread->cond);
-}
-
-
-/* Allocate a thread structure from the global free list.  Global
-   mutex lock must be held by caller.  The thread is moved to
-   the active list. */
-struct thread_node *
-__timer_thread_alloc (const pthread_attr_t *desired_attr, clockid_t clock_id)
-{
-  struct list_links *node = list_first (&thread_free_list);
-
-  if (node != list_null (&thread_free_list))
-    {
-      struct thread_node *thread = thread_links2ptr (node);
-      list_unlink (node);
-      thread_init (thread, desired_attr, clock_id);
-      list_append (&thread_active_list, node);
-      return thread;
-    }
-
-  return 0;
-}
-
-
-/* Return a thread structure to the global free list.  Global lock
-   must be held by caller.  */
-void
-__timer_thread_dealloc (struct thread_node *thread)
-{
-  thread_deinit (thread);
-  list_unlink (&thread->links);
-  list_append (&thread_free_list, &thread->links);
-}
-
-
-/* Each of our threads which terminates executes this cleanup
-   handler. We never terminate threads ourselves; if a thread gets here
-   it means that the evil application has killed it.  If the thread has
-   timers, these require servicing and so we must hire a replacement
-   thread right away.  We must also unblock another thread that may
-   have been waiting for this thread to finish servicing a timer (see
-   timer_delete()).  */
-
-static void
-thread_cleanup (void *val)
-{
-  if (val != NULL)
-    {
-      struct thread_node *thread = val;
-
-      /* How did the signal thread get killed?  */
-      assert (thread != &__timer_signal_thread_rclk);
-
-      pthread_mutex_lock (&__timer_mutex);
-
-      thread->exists = 0;
-
-      /* We are no longer processing a timer event.  */
-      thread->current_timer = 0;
-
-      if (list_isempty (&thread->timer_queue))
-	  __timer_thread_dealloc (thread);
-      else
-	(void) __timer_thread_start (thread);
-
-      pthread_mutex_unlock (&__timer_mutex);
-
-      /* Unblock potentially blocked timer_delete().  */
-      pthread_cond_broadcast (&thread->cond);
-    }
-}
-
-
-/* Handle a timer which is supposed to go off now.  */
-static void
-thread_expire_timer (struct thread_node *self, struct timer_node *timer)
-{
-  self->current_timer = timer; /* Lets timer_delete know timer is running. */
-
-  pthread_mutex_unlock (&__timer_mutex);
-
-  switch (__builtin_expect (timer->event.sigev_notify, SIGEV_SIGNAL))
-    {
-    case SIGEV_NONE:
-      break;
-
-    case SIGEV_SIGNAL:
-#ifdef __NR_rt_sigqueueinfo
-      {
-	siginfo_t info;
-
-	/* First, clear the siginfo_t structure, so that we don't pass our
-	   stack content to other tasks.  */
-	memset (&info, 0, sizeof (siginfo_t));
-	/* We must pass the information about the data in a siginfo_t
-           value.  */
-	info.si_signo = timer->event.sigev_signo;
-	info.si_code = SI_TIMER;
-	info.si_pid = timer->creator_pid;
-	info.si_uid = getuid ();
-	info.si_value = timer->event.sigev_value;
-
-	INLINE_SYSCALL (rt_sigqueueinfo, 3, info.si_pid, info.si_signo, &info);
-      }
-#else
-      if (pthread_kill (self->captured, timer->event.sigev_signo) != 0)
-	{
-	  if (pthread_kill (self->id, timer->event.sigev_signo) != 0)
-	    abort ();
-        }
-#endif
-      break;
-
-    case SIGEV_THREAD:
-      timer->event.sigev_notify_function (timer->event.sigev_value);
-      break;
-
-    default:
-      assert (! "unknown event");
-      break;
-    }
-
-  pthread_mutex_lock (&__timer_mutex);
-
-  self->current_timer = 0;
-
-  pthread_cond_broadcast (&self->cond);
-}
-
-
-/* Thread function; executed by each timer thread. The job of this
-   function is to wait on the thread's timer queue and expire the
-   timers in chronological order as close to their scheduled time as
-   possible.  */
-static void
-__attribute__ ((noreturn))
-thread_func (void *arg)
-{
-  struct thread_node *self = arg;
-
-  /* Register cleanup handler, in case rogue application terminates
-     this thread.  (This cannot happen to __timer_signal_thread, which
-     doesn't invoke application callbacks). */
-
-  pthread_cleanup_push (thread_cleanup, self);
-
-  pthread_mutex_lock (&__timer_mutex);
-
-  while (1)
-    {
-      struct list_links *first;
-      struct timer_node *timer = NULL;
-
-      /* While the timer queue is not empty, inspect the first node.  */
-      first = list_first (&self->timer_queue);
-      if (first != list_null (&self->timer_queue))
-	{
-	  struct timespec now;
-
-	  timer = timer_links2ptr (first);
-
-	  /* This assumes that the elements of the list of one thread
-	     are all for the same clock.  */
-	  clock_gettime (timer->clock, &now);
-
-	  while (1)
-	    {
-	      /* If the timer is due or overdue, remove it from the queue.
-		 If it's a periodic timer, re-compute its new time and
-		 requeue it.  Either way, perform the timer expiry. */
-	      if (timespec_compare (&now, &timer->expirytime) < 0)
-		break;
-
-	      list_unlink_ip (first);
-
-	      if (__builtin_expect (timer->value.it_interval.tv_sec, 0) != 0
-		  || timer->value.it_interval.tv_nsec != 0)
-		{
-		  timer->overrun_count = 0;
-		  timespec_add (&timer->expirytime, &timer->expirytime,
-				&timer->value.it_interval);
-		  while (timespec_compare (&timer->expirytime, &now) < 0)
-		    {
-		      timespec_add (&timer->expirytime, &timer->expirytime,
-				    &timer->value.it_interval);
-		      if (timer->overrun_count < DELAYTIMER_MAX)
-			++timer->overrun_count;
-		    }
-		  __timer_thread_queue_timer (self, timer);
-		}
-
-	      thread_expire_timer (self, timer);
-
-	      first = list_first (&self->timer_queue);
-	      if (first == list_null (&self->timer_queue))
-		break;
-
-	      timer = timer_links2ptr (first);
-	    }
-	}
-
-      /* If the queue is not empty, wait until the expiry time of the
-	 first node.  Otherwise wait indefinitely.  Insertions at the
-	 head of the queue must wake up the thread by broadcasting
-	 this condition variable.  */
-      if (timer != NULL)
-	pthread_cond_timedwait (&self->cond, &__timer_mutex,
-				&timer->expirytime);
-      else
-	pthread_cond_wait (&self->cond, &__timer_mutex);
-    }
-  /* This macro will never be executed since the while loop loops
-     forever - but we have to add it for proper nesting.  */
-  pthread_cleanup_pop (1);
-}
-
-
-/* Enqueue a timer in wakeup order in the thread's timer queue.
-   Returns 1 if the timer was inserted at the head of the queue,
-   causing the queue's next wakeup time to change. */
-
-int
-__timer_thread_queue_timer (struct thread_node *thread,
-			    struct timer_node *insert)
-{
-  struct list_links *iter;
-  int athead = 1;
-
-  for (iter = list_first (&thread->timer_queue);
-       iter != list_null (&thread->timer_queue);
-        iter = list_next (iter))
-    {
-      struct timer_node *timer = timer_links2ptr (iter);
-
-      if (timespec_compare (&insert->expirytime, &timer->expirytime) < 0)
-	  break;
-      athead = 0;
-    }
-
-  list_insbefore (iter, &insert->links);
-  return athead;
-}
-
-
-/* Start a thread and associate it with the given thread node.  Global
-   lock must be held by caller.  */
-int
-__timer_thread_start (struct thread_node *thread)
-{
-  int retval = 1;
-
-  assert (!thread->exists);
-  thread->exists = 1;
-
-  if (pthread_create (&thread->id, &thread->attr,
-		      (void *(*) (void *)) thread_func, thread) != 0)
-    {
-      thread->exists = 0;
-      retval = -1;
-    }
-
-  return retval;
-}
-
-
-void
-__timer_thread_wakeup (struct thread_node *thread)
-{
-  pthread_cond_broadcast (&thread->cond);
-}
-
-
-/* Compare two pthread_attr_t thread attributes for exact equality.
-   Returns 1 if they are equal, otherwise zero if they are not equal or
-   contain illegal values.  This version is LinuxThreads-specific for
-   performance reason.  One could use the access functions to get the
-   values of all the fields of the attribute structure.  */
-static int
-thread_attr_compare (const pthread_attr_t *left, const pthread_attr_t *right)
-{
-  return (left->__detachstate == right->__detachstate
-	  && left->__schedpolicy == right->__schedpolicy
-	  && left->__guardsize == right->__guardsize
-	  && (left->__schedparam.sched_priority
-	      == right->__schedparam.sched_priority)
-	  && left->__inheritsched == right->__inheritsched
-	  && left->__scope == right->__scope
-	  && left->__stacksize == right->__stacksize
-	  && left->__stackaddr_set == right->__stackaddr_set
-	  && (left->__stackaddr_set
-	      || left->__stackaddr == right->__stackaddr));
-}
-
-
-/* Search the list of active threads and find one which has matching
-   attributes.  Global mutex lock must be held by caller.  */
-struct thread_node *
-__timer_thread_find_matching (const pthread_attr_t *desired_attr,
-			      clockid_t desired_clock_id)
-{
-  struct list_links *iter = list_first (&thread_active_list);
-
-  while (iter != list_null (&thread_active_list))
-    {
-      struct thread_node *candidate = thread_links2ptr (iter);
-
-      if (thread_attr_compare (desired_attr, &candidate->attr)
-	  && desired_clock_id == candidate->clock_id)
-	return candidate;
-
-      iter = list_next (iter);
-    }
-
-  return NULL;
-}
-
-
-/* Grab a free timer structure from the global free list.  The global
-   lock must be held by the caller.  */
-struct timer_node *
-__timer_alloc (void)
-{
-  struct list_links *node = list_first (&timer_free_list);
-
-  if (node != list_null (&timer_free_list))
-    {
-      struct timer_node *timer = timer_links2ptr (node);
-      list_unlink_ip (node);
-      timer->inuse = TIMER_INUSE;
-      timer->refcount = 1;
-      return timer;
-    }
-
-  return NULL;
-}
-
-
-/* Return a timer structure to the global free list.  The global lock
-   must be held by the caller.  */
-void
-__timer_dealloc (struct timer_node *timer)
-{
-  assert (timer->refcount == 0);
-  timer->thread = NULL;	/* Break association between timer and thread.  */
-  timer->inuse = TIMER_FREE;
-  list_append (&timer_free_list, &timer->links);
-}
-
-
-/* Thread cancellation handler which unlocks a mutex.  */
-void
-__timer_mutex_cancel_handler (void *arg)
-{
-  pthread_mutex_unlock (arg);
-}
diff --git a/libpthread/linuxthreads/sysdeps/pthread/timer_settime.c b/libpthread/linuxthreads/sysdeps/pthread/timer_settime.c
deleted file mode 100644
index da0908b0b..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/timer_settime.c
+++ /dev/null
@@ -1,136 +0,0 @@
-/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include <time.h>
-
-#include "posix-timer.h"
-
-
-/* Set timer TIMERID to VALUE, returning old value in OVLAUE.  */
-int
-timer_settime (timerid, flags, value, ovalue)
-     timer_t timerid;
-     int flags;
-     const struct itimerspec *value;
-     struct itimerspec *ovalue;
-{
-  struct timer_node *timer;
-  struct thread_node *thread = NULL;
-  struct timespec now;
-  int have_now = 0, need_wakeup = 0;
-  int retval = -1;
-
-  timer = timer_id2ptr (timerid);
-  if (timer == NULL)
-    {
-      __set_errno (EINVAL);
-      goto bail;
-    }
-
-  if (value->it_interval.tv_nsec < 0
-      || value->it_interval.tv_nsec >= 1000000000
-      || value->it_value.tv_nsec < 0
-      || value->it_value.tv_nsec >= 1000000000)
-    {
-      __set_errno (EINVAL);
-      goto bail;
-    }
-
-  /* Will need to know current time since this is a relative timer;
-     might as well make the system call outside of the lock now! */
-
-  if ((flags & TIMER_ABSTIME) == 0)
-    {
-      clock_gettime (timer->clock, &now);
-      have_now = 1;
-    }
-
-  pthread_mutex_lock (&__timer_mutex);
-  timer_addref (timer);
-
-  /* One final check of timer validity; this one is possible only
-     until we have the mutex, because it accesses the inuse flag. */
-
-  if (! timer_valid(timer))
-    {
-      __set_errno (EINVAL);
-      goto unlock_bail;
-    }
-
-  if (ovalue != NULL)
-    {
-      ovalue->it_interval = timer->value.it_interval;
-
-      if (timer->armed)
-	{
-	  if (! have_now)
-	    {
-	      pthread_mutex_unlock (&__timer_mutex);
-	      clock_gettime (timer->clock, &now);
-	      have_now = 1;
-	      pthread_mutex_lock (&__timer_mutex);
-	      timer_addref (timer);
-	    }
-
-	  timespec_sub (&ovalue->it_value, &timer->expirytime, &now);
-	}
-      else
-	{
-	  ovalue->it_value.tv_sec = 0;
-	  ovalue->it_value.tv_nsec = 0;
-	}
-    }
-
-  timer->value = *value;
-
-  list_unlink_ip (&timer->links);
-  timer->armed = 0;
-
-  thread = timer->thread;
-
-  /* A value of { 0, 0 } causes the timer to be stopped. */
-  if (value->it_value.tv_sec != 0
-      || __builtin_expect (value->it_value.tv_nsec != 0, 1))
-    {
-      if ((flags & TIMER_ABSTIME) != 0)
-	/* The user specified the expiration time.  */
-	timer->expirytime = value->it_value;
-      else
-	timespec_add (&timer->expirytime, &now, &value->it_value);
-
-      /* Only need to wake up the thread if timer is inserted
-	 at the head of the queue. */
-      if (thread != NULL)
-	need_wakeup = __timer_thread_queue_timer (thread, timer);
-      timer->armed = 1;
-    }
-
-  retval = 0;
-
-unlock_bail:
-  timer_delref (timer);
-  pthread_mutex_unlock (&__timer_mutex);
-
-bail:
-  if (thread != NULL && need_wakeup)
-    __timer_thread_wakeup (thread);
-
-  return retval;
-}
diff --git a/libpthread/linuxthreads.old/sysdeps/pthread/tls.h b/libpthread/linuxthreads/sysdeps/pthread/tls.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/pthread/tls.h
rename to libpthread/linuxthreads/sysdeps/pthread/tls.h
diff --git a/libpthread/linuxthreads/sysdeps/pthread/tst-timer.c b/libpthread/linuxthreads/sysdeps/pthread/tst-timer.c
deleted file mode 100644
index 0a679d9c6..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/tst-timer.c
+++ /dev/null
@@ -1,113 +0,0 @@
-/* Tests for POSIX timer implementation.
-   Copyright (C) 2000, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Kaz Kylheku <kaz@ashi.footprints.net>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <signal.h>
-#include <stdio.h>
-#include <time.h>
-#include <unistd.h>
-
-
-static void
-notify_func (union sigval sigval)
-{
-  puts ("notify_func");
-}
-
-
-static void
-signal_func (int sig)
-{
-  static const char text[] = "signal_func\n";
-  signal (sig, signal_func);
-  write (STDOUT_FILENO, text, sizeof text - 1);
-}
-
-static void
-intr_sleep (int sec)
-{
-  struct timespec ts;
-
-  ts.tv_sec = sec;
-  ts.tv_nsec = 0;
-
-  while (nanosleep (&ts, &ts) == -1 && errno == EINTR)
-    ;
-}
-
-#define ZSIGALRM 14
-
-
-int
-main (void)
-{
-  struct timespec ts;
-  timer_t timer_sig, timer_thr1, timer_thr2;
-  int retval;
-  struct sigevent sigev1 =
-  {
-    .sigev_notify = SIGEV_SIGNAL,
-    .sigev_signo = ZSIGALRM
-  };
-  struct sigevent sigev2;
-  struct itimerspec itimer1 = { { 0, 200000000 }, { 0, 200000000 } };
-  struct itimerspec itimer2 = { { 0, 100000000 }, { 0, 500000000 } };
-  struct itimerspec itimer3 = { { 0, 150000000 }, { 0, 300000000 } };
-  struct itimerspec old;
-
-  retval = clock_gettime (CLOCK_REALTIME, &ts);
-
-  sigev2.sigev_notify = SIGEV_THREAD;
-  sigev2.sigev_notify_function = notify_func;
-  sigev2.sigev_notify_attributes = NULL;
-
-  setvbuf (stdout, 0, _IOLBF, 0);
-
-  printf ("clock_gettime returned %d, timespec = { %ld, %ld }\n",
-	  retval, ts.tv_sec, ts.tv_nsec);
-
-  retval = clock_getres (CLOCK_REALTIME, &ts);
-
-  printf ("clock_getres returned %d, timespec = { %ld, %ld }\n",
-	  retval, ts.tv_sec, ts.tv_nsec);
-
-  timer_create (CLOCK_REALTIME, &sigev1, &timer_sig);
-  timer_create (CLOCK_REALTIME, &sigev2, &timer_thr1);
-  timer_create (CLOCK_REALTIME, &sigev2, &timer_thr2);
-
-  timer_settime (timer_thr1, 0, &itimer2, &old);
-  timer_settime (timer_thr2, 0, &itimer3, &old);
-
-  signal (ZSIGALRM, signal_func);
-
-  timer_settime (timer_sig, 0, &itimer1, &old);
-
-  timer_delete (-1);
-
-  intr_sleep (3);
-
-  timer_delete (timer_sig);
-  timer_delete (timer_thr1);
-
-  intr_sleep (3);
-
-  timer_delete (timer_thr2);
-
-  return 0;
-}
diff --git a/libpthread/linuxthreads/sysdeps/pthread/uClibc-glue.h b/libpthread/linuxthreads/sysdeps/pthread/uClibc-glue.h
deleted file mode 100644
index b957dedc9..000000000
--- a/libpthread/linuxthreads/sysdeps/pthread/uClibc-glue.h
+++ /dev/null
@@ -1,47 +0,0 @@
-#ifndef _UCLIBC_GLUE_H
-#define _UCLIBC_GLUE_H 1
-
-#include <features.h>
-#include <sys/cdefs.h>
-#include <bits/uClibc_page.h>
-
-#ifdef IS_IN_libpthread
-#include <bits/kernel-features.h>
-
-#ifndef __GLIBC_HAVE_LONG_LONG
-# define __GLIBC_HAVE_LONG_LONG
-#endif
-
-#define __getpagesize getpagesize
-#define __sched_get_priority_max sched_get_priority_max
-#define __sched_get_priority_min sched_get_priority_min
-#define __sched_getscheduler sched_getscheduler
-#define __sched_setscheduler sched_setscheduler
-#define __sched_getparam sched_getparam
-#define __getpid getpid
-#define __gettimeofday gettimeofday
-#define __poll poll
-#define __sysctl sysctl
-#define __open open
-#define __read read
-#define __close close
-#define __on_exit on_exit
-#define __libc_current_sigrtmin_private __libc_current_sigrtmin
-#define __clone clone
-
-extern void *__libc_stack_end;
-extern int __cxa_atexit (void (*func) (void *), void *arg, void *d);
-
-#endif /* IS_IN_libpthread */
-
-#ifdef __UCLIBC_HAS_XLOCALE__
-# define __uselocale(x) uselocale(x)
-#else
-# define __uselocale(x) ((void)0)
-#endif
-
-/* Use a funky version in a probably vein attempt at preventing gdb
- * from dlopen()'ing glibc's libthread_db library... */
-#define VERSION __stringify(__UCLIBC_MAJOR__) "." __stringify(__UCLIBC_MINOR__) "." __stringify(__UCLIBC_SUBLEVEL__)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/sh/pspinlock.c b/libpthread/linuxthreads/sysdeps/sh/pspinlock.c
deleted file mode 100644
index 2f039de53..000000000
--- a/libpthread/linuxthreads/sysdeps/sh/pspinlock.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/* POSIX spinlock implementation.  SH version.
-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  unsigned int val;
-
-  do
-    __asm__ __volatile__ ("tas.b @%1; movt %0"
-		  : "=r" (val)
-		  : "r" (lock)
-		  : "memory");
-  while (val == 0);
-
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  unsigned int val;
-
-  __asm__ __volatile__ ("tas.b @%1; movt %0"
-		: "=r" (val)
-		: "r" (lock)
-		: "memory");
-  return val ? 0 : EBUSY;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  return *lock = 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  return *lock = 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/sh/tcb-offsets.sym b/libpthread/linuxthreads/sysdeps/sh/tcb-offsets.sym
deleted file mode 100644
index 6324a016c..000000000
--- a/libpthread/linuxthreads/sysdeps/sh/tcb-offsets.sym
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <sysdep.h>
-#include <tls.h>
-
---
-#ifdef __UCLIBC_HAS_TLS__
-MULTIPLE_THREADS_OFFSET offsetof (struct _pthread_descr_struct, p_multiple_threads)
-TLS_PRE_TCB_SIZE	sizeof (struct _pthread_descr_struct)
-#else
-MULTIPLE_THREADS_OFFSET offsetof (tcbhead_t, multiple_threads)
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/sh/tls.h b/libpthread/linuxthreads/sysdeps/sh/tls.h
index 512e3181e..25bef830f 100644
--- a/libpthread/linuxthreads/sysdeps/sh/tls.h
+++ b/libpthread/linuxthreads/sysdeps/sh/tls.h
@@ -30,129 +30,87 @@
 typedef union dtv
 {
   size_t counter;
-  struct
-  {
-    void *val;
-    bool is_static;
-  } pointer;
+  void *pointer;
 } dtv_t;
 
-#else /* __ASSEMBLER__ */
-# include <tcb-offsets.h>
-#endif /* __ASSEMBLER__ */
+
+typedef struct
+{
+  void *tcb;		/* Pointer to the TCB.  Not necessary the
+			   thread descriptor used by libpthread.  */
+  dtv_t *dtv;
+  void *self;		/* Pointer to the thread descriptor.  */
+} tcbhead_t;
 
 
 /* We can support TLS only if the floating-stack support is available.  */
-#if defined HAVE_TLS_SUPPORT \
-    && (defined FLOATING_STACKS || !defined IS_IN_libpthread)
+#if defined FLOATING_STACKS && defined HAVE_TLS_SUPPORT
 
-/* Signal that TLS support is available.  */
-# define USE_TLS	1
+/* Get system call information.  */
+# include <sysdep.h>
 
-/* Include padding in _pthread_descr_struct so that libc can find p_errno,
-   if libpthread will only include the padding because of the !IS_IN_libpthread
-   check.  */
-#ifndef FLOATING_STACKS
-# define INCLUDE_TLS_PADDING	1
-#endif
+/* Signal that TLS support is available.  */
+//# define USE_TLS	1
 
-# ifndef __ASSEMBLER__
 
-typedef struct
-{
-  dtv_t *dtv;
-  void *private;
-} tcbhead_t;
+/* Get the thread descriptor definition.  */
+# include <linuxthreads/descr.h>
 
 /* This is the size of the initial TCB.  */
-#  define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
+# define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
 
 /* Alignment requirements for the initial TCB.  */
-#  define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
+# define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
 
 /* This is the size of the TCB.  */
-#  define TLS_TCB_SIZE sizeof (tcbhead_t)
-
-/* This is the size we need before TCB.  */
-#  define TLS_PRE_TCB_SIZE sizeof (struct _pthread_descr_struct)
+# define TLS_TCB_SIZE sizeof (struct _pthread_descr_struct)
 
 /* Alignment requirements for the TCB.  */
-#  define TLS_TCB_ALIGN __alignof__ (struct _pthread_descr_struct)
+# define TLS_TCB_ALIGN __alignof__ (struct _pthread_descr_struct)
 
 /* The TLS blocks start right after the TCB.  */
-#  define TLS_DTV_AT_TP	1
+# define TLS_DTV_AT_TP	1
+
 
 /* Install the dtv pointer.  The pointer passed is to the element with
    index -1 which contain the length.  */
-#  define INSTALL_DTV(tcbp, dtvp) \
-  ((tcbhead_t *) (tcbp))->dtv = dtvp + 1
+# define INSTALL_DTV(descr, dtvp) \
+  ((tcbhead_t *) (descr))->dtv = dtvp + 1
 
 /* Install new dtv for current thread.  */
-#  define INSTALL_NEW_DTV(dtv) \
-  ({ tcbhead_t *__tcbp;							      \
-     __asm__ __volatile__ ("stc gbr,%0" : "=r" (__tcbp));			      \
-     __tcbp->dtv = (dtv);})
+# define INSTALL_NEW_DTV(dtv) \
+  ({ struct _pthread_descr_struct *__descr;				      \
+     THREAD_SETMEM (__descr, p_header.data.dtvp, (dtv)); })
 
 /* Return dtv of given thread descriptor.  */
-#  define GET_DTV(tcbp) \
-  (((tcbhead_t *) (tcbp))->dtv)
+# define GET_DTV(descr) \
+  (((tcbhead_t *) (descr))->dtv)
 
 /* Code to initially initialize the thread pointer.  This might need
    special attention since 'errno' is not yet available and if the
    operation can cause a failure 'errno' must not be touched.  */
-#  define TLS_INIT_TP(tcbp, secondcall) \
-  ({ __asm__ __volatile__ ("ldc %0,gbr" : : "r" (tcbp)); 0; })
-
-/* Return the address of the dtv for the current thread.  */
-#  define THREAD_DTV() \
-  ({ tcbhead_t *__tcbp;							      \
-     __asm__ __volatile__ ("stc gbr,%0" : "=r" (__tcbp));			      \
-     __tcbp->dtv;})
+# define TLS_INIT_TP(descr, secondcall) \
+  ({									      \
+    void *_descr = (descr);						      \
+    int result;								      \
+    tcbhead_t *head = _descr;						      \
+									      \
+    head->tcb = _descr;							      \
+    /* For now the thread descriptor is at the same address.  */	      \
+    head->self = _descr;						      \
+									      \
+    __asm__ ("ldc %0,gbr" : : "r" (_descr));				      \
+									      \
+    0;									      \
+  })
 
-/* Return the thread descriptor for the current thread.  */
-#  undef THREAD_SELF
-#  define THREAD_SELF \
-  ({ struct _pthread_descr_struct *__self;				      \
-     __asm__ ("stc gbr,%0" : "=r" (__self));				      \
-     __self - 1;})
 
-#  undef INIT_THREAD_SELF
-#  define INIT_THREAD_SELF(descr, nr) \
-  ({ struct _pthread_descr_struct *__self = (void *) descr;		      \
-     __asm__ __volatile__ ("ldc %0,gbr" : : "r" (__self + 1));		      \
-     0; })
-
-# define TLS_MULTIPLE_THREADS_IN_TCB 1
-
-/* Get the thread descriptor definition.  This must be after the
-   the definition of THREAD_SELF for TLS.  */
-#  include <linuxthreads/descr.h>
-
-# endif /* __ASSEMBLER__ */
-
-#else
-
-# ifndef __ASSEMBLER__
-
-typedef struct
-{
-  void *tcb;
-  dtv_t *dtv;
-  void *self;
-  int multiple_threads;
-} tcbhead_t;
-
-/* Get the thread descriptor definition.  */
-#  include <linuxthreads/descr.h>
-
-#  define NONTLS_INIT_TP \
-  do { 									\
-    static const tcbhead_t nontls_init_tp = { .multiple_threads = 0 };	\
-    __asm__ __volatile__ ("ldc %0,gbr" : : "r" (&nontls_init_tp));	        \
-  } while (0)
-
-# endif /* __ASSEMBLER__ */
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  ({ struct _pthread_descr_struct *__descr;				      \
+     THREAD_GETMEM (__descr, p_header.data.dtvp); })
 
-#endif	/* HAVE_TLS_SUPPORT && (FLOATING_STACKS || !IS_IN_libpthread) */
+#endif	/* FLOATING_STACKS && HAVE_TLS_SUPPORT */
+#endif /* __ASSEMBLER__ */
 
 #endif	/* tls.h */
diff --git a/libpthread/linuxthreads.old/sysdeps/sh64/Makefile.arch b/libpthread/linuxthreads/sysdeps/sh64/Makefile.arch
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/sh64/Makefile.arch
rename to libpthread/linuxthreads/sysdeps/sh64/Makefile.arch
diff --git a/libpthread/linuxthreads.old/sysdeps/sh64/pt-machine.c b/libpthread/linuxthreads/sysdeps/sh64/pt-machine.c
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/sh64/pt-machine.c
rename to libpthread/linuxthreads/sysdeps/sh64/pt-machine.c
diff --git a/libpthread/linuxthreads.old/sysdeps/sh64/pt-machine.h b/libpthread/linuxthreads/sysdeps/sh64/pt-machine.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/sh64/pt-machine.h
rename to libpthread/linuxthreads/sysdeps/sh64/pt-machine.h
diff --git a/libpthread/linuxthreads/sysdeps/sparc/pspinlock.c b/libpthread/linuxthreads/sysdeps/sparc/pspinlock.c
deleted file mode 100644
index 4de152be3..000000000
--- a/libpthread/linuxthreads/sysdeps/sparc/pspinlock.c
+++ /dev/null
@@ -1,87 +0,0 @@
-/* POSIX spinlock implementation.  SPARC32 version.
-   Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-
-/* This implementation is similar to the one used in the Linux kernel.  */
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  __asm__ __volatile__
-    ("1: ldstub [%0], %%g2\n"
-     "   orcc   %%g2, 0x0, %%g0\n"
-     "   bne,a  2f\n"
-     "   ldub   [%0], %%g2\n"
-     ".subsection 2\n"
-     "2: orcc   %%g2, 0x0, %%g0\n"
-     "   bne,a  2b\n"
-     "   ldub   [%0], %%g2\n"
-     "   b,a    1b\n"
-     ".previous"
-     : /* no outputs */
-     : "r" (lock)
-     : "g2", "memory", "cc");
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  int result;
-  __asm__ __volatile__
-    ("ldstub [%1], %0"
-     : "=r" (result)
-     : "r" (lock)
-     : "memory");
-  return result == 0 ? 0 : EBUSY;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  *lock = 0;
-  return 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  *lock = 0;
-  return 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads.old/sysdeps/sparc/tcb-offsets.h b/libpthread/linuxthreads/sysdeps/sparc/tcb-offsets.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/sparc/tcb-offsets.h
rename to libpthread/linuxthreads/sysdeps/sparc/tcb-offsets.h
diff --git a/libpthread/linuxthreads/sysdeps/sparc/tcb-offsets.sym b/libpthread/linuxthreads/sysdeps/sparc/tcb-offsets.sym
deleted file mode 100644
index aee6be257..000000000
--- a/libpthread/linuxthreads/sysdeps/sparc/tcb-offsets.sym
+++ /dev/null
@@ -1,4 +0,0 @@
-#include <sysdep.h>
-#include <tls.h>
-
-MULTIPLE_THREADS_OFFSET		offsetof (tcbhead_t, multiple_threads)
diff --git a/libpthread/linuxthreads/sysdeps/sparc/tls.h b/libpthread/linuxthreads/sysdeps/sparc/tls.h
deleted file mode 100644
index 1e31c2e63..000000000
--- a/libpthread/linuxthreads/sysdeps/sparc/tls.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/* Definitions for thread-local data handling.  linuxthreads/sparc version.
-   Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _TLS_H
-#define _TLS_H
-
-#ifndef __ASSEMBLER__
-
-# include <pt-machine.h>
-# include <stdbool.h>
-# include <stddef.h>
-
-/* Type for the dtv.  */
-typedef union dtv
-{
-  size_t counter;
-  struct
-  {
-    void *val;
-    bool is_static;
-  } pointer;
-} dtv_t;
-
-typedef struct
-{
-  void *tcb;		/* Pointer to the TCB.  Not necessary the
-			   thread descriptor used by libpthread.  */
-  dtv_t *dtv;
-  void *self;		/* Pointer to the thread descriptor.  */
-  int multiple_threads;
-} tcbhead_t;
-
-#else /* __ASSEMBLER__ */
-# include <tcb-offsets.h>
-#endif /* __ASSEMBLER__ */
-
-#ifdef HAVE_TLS_SUPPORT
-
-/* Signal that TLS support is available.  */
-# define USE_TLS	1
-
-# ifndef __ASSEMBLER__
-/* Get system call information.  */
-#  include <sysdep.h>
-
-/* Get the thread descriptor definition.  */
-#  include <linuxthreads/descr.h>
-
-/* This is the size of the initial TCB.  */
-#  define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
-
-/* Alignment requirements for the initial TCB.  */
-#  define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
-
-/* This is the size of the TCB.  */
-#  define TLS_TCB_SIZE sizeof (struct _pthread_descr_struct)
-
-/* Alignment requirements for the TCB.  */
-#  define TLS_TCB_ALIGN __alignof__ (struct _pthread_descr_struct)
-
-/* The TCB can have any size and the memory following the address the
-   thread pointer points to is unspecified.  Allocate the TCB there.  */
-#  define TLS_TCB_AT_TP	1
-
-/* Install the dtv pointer.  The pointer passed is to the element with
-   index -1 which contain the length.  */
-#  define INSTALL_DTV(descr, dtvp) \
-  ((tcbhead_t *) (descr))->dtv = (dtvp) + 1
-
-/* Install new dtv for current thread.  */
-#  define INSTALL_NEW_DTV(DTV) \
-  (((tcbhead_t *) __thread_self)->dtv = (DTV))
-
-/* Return dtv of given thread descriptor.  */
-#  define GET_DTV(descr) \
-  (((tcbhead_t *) (descr))->dtv)
-
-/* Code to initially initialize the thread pointer.  */
-# define TLS_INIT_TP(descr, secondcall) \
-  (__thread_self = (__typeof (__thread_self)) (descr), NULL)
-
-/* Return the address of the dtv for the current thread.  */
-#  define THREAD_DTV() \
-  (((tcbhead_t *) __thread_self)->dtv)
-
-# endif
-
-#else
-
-# define NONTLS_INIT_TP \
-  do {									      \
-    static const tcbhead_t nontls_init_tp				      \
-      = { .multiple_threads = 0 };					      \
-    __thread_self = (__typeof (__thread_self)) &nontls_init_tp;		      \
-  } while (0)
-
-#endif /* USE_TLS */
-
-#endif	/* tls.h */
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/allocalim.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/allocalim.h
deleted file mode 100644
index 3d3d2219f..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/allocalim.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/* Determine whether block of given size can be allocated on the stack or not.
-   Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-#include <limits.h>
-
-__extern_always_inline int __libc_use_alloca (size_t size)
-{
-  return (__builtin_expect (size <= PTHREAD_STACK_MIN / 4, 1)
-	  || __libc_alloca_cutoff (size));
-}
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/allocrtsig.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/allocrtsig.c
deleted file mode 100644
index 69bc0d79a..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/allocrtsig.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/* Handle real-time signal allocation.
-   Copyright (C) 1997,98,99,2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <signal.h>
-
-/* Sanity check.  */
-#if !defined __SIGRTMIN || (__SIGRTMAX - __SIGRTMIN) < 3
-# error "This must not happen"
-#endif
-
-static int current_rtmin;
-static int current_rtmax;
-
-static int initialized;
-
-#include <testrtsig.h>
-
-static void
-init (void)
-{
-  if (!kernel_has_rtsig ())
-    {
-      current_rtmin = -1;
-      current_rtmax = -1;
-    }
-  else
-    {
-      current_rtmin = __SIGRTMIN + 3;
-      current_rtmax = __SIGRTMAX;
-    }
-  initialized = 1;
-}
-
-/* Return number of available real-time signal with highest priority.  */
-int
-__libc_current_sigrtmin (void)
-{
-  if (!initialized)
-    init ();
-  return current_rtmin;
-}
-strong_alias (__libc_current_sigrtmin, __libc_current_sigrtmin_private)
-libc_hidden_def (__libc_current_sigrtmin)
-
-/* Return number of available real-time signal with lowest priority.  */
-int
-__libc_current_sigrtmax (void)
-{
-  if (!initialized)
-    init ();
-  return current_rtmax;
-}
-strong_alias (__libc_current_sigrtmax, __libc_current_sigrtmax_private)
-libc_hidden_def (__libc_current_sigrtmax)
-
-#if 0
-/* Allocate real-time signal with highest/lowest available
-   priority.  Please note that we don't use a lock since we assume
-   this function to be called at program start.  */
-int
-__libc_allocate_rtsig (int high)
-{
-  if (!initialized)
-    init ();
-  if (current_rtmin == -1 || current_rtmin > current_rtmax)
-    /* We don't have anymore signal available.  */
-    return -1;
-
-  return high ? current_rtmin++ : current_rtmax--;
-}
-strong_alias (__libc_allocate_rtsig, __libc_allocate_rtsig_private)
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/aio_cancel.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/aio_cancel.c
deleted file mode 100644
index 0d6da8291..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/aio_cancel.c
+++ /dev/null
@@ -1,33 +0,0 @@
-#include <shlib-compat.h>
-
-#define aio_cancel64 XXX
-#include <aio.h>
-#undef aio_cancel64
-#include <errno.h>
-
-extern __typeof (aio_cancel) __new_aio_cancel;
-extern __typeof (aio_cancel) __old_aio_cancel;
-
-#define aio_cancel	__new_aio_cancel
-
-#include <sysdeps/pthread/aio_cancel.c>
-
-#undef aio_cancel
-strong_alias (__new_aio_cancel, __new_aio_cancel64);
-versioned_symbol (librt, __new_aio_cancel, aio_cancel, GLIBC_2_3);
-versioned_symbol (librt, __new_aio_cancel64, aio_cancel64, GLIBC_2_3);
-
-#if SHLIB_COMPAT (librt, GLIBC_2_1, GLIBC_2_3)
-
-#undef ECANCELED
-#define aio_cancel	__old_aio_cancel
-#define ECANCELED	125
-
-#include <sysdeps/pthread/aio_cancel.c>
-
-#undef aio_cancel
-strong_alias (__old_aio_cancel, __old_aio_cancel64);
-compat_symbol (librt, __old_aio_cancel, aio_cancel, GLIBC_2_1);
-compat_symbol (librt, __old_aio_cancel64, aio_cancel64, GLIBC_2_1);
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/bits/local_lim.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/bits/local_lim.h
deleted file mode 100644
index 001403a19..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/bits/local_lim.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* Minimum guaranteed maximum values for system limits.  Linux/Alpha version.
-   Copyright (C) 1993-1998,2000,2002,2003,2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-/* The kernel header pollutes the namespace with the NR_OPEN symbol
-   and defines LINK_MAX although filesystems have different maxima.  A
-   similar thing is true for OPEN_MAX: the limit can be changed at
-   runtime and therefore the macro must not be defined.  Remove this
-   after including the header if necessary.  */
-#ifndef NR_OPEN
-# define __undef_NR_OPEN
-#endif
-#ifndef LINK_MAX
-# define __undef_LINK_MAX
-#endif
-#ifndef OPEN_MAX
-# define __undef_OPEN_MAX
-#endif
-
-/* The kernel sources contain a file with all the needed information.  */
-#include <linux/limits.h>
-
-/* Have to remove NR_OPEN?  */
-#ifdef __undef_NR_OPEN
-# undef NR_OPEN
-# undef __undef_NR_OPEN
-#endif
-/* Have to remove LINK_MAX?  */
-#ifdef __undef_LINK_MAX
-# undef LINK_MAX
-# undef __undef_LINK_MAX
-#endif
-/* Have to remove OPEN_MAX?  */
-#ifdef __undef_OPEN_MAX
-# undef OPEN_MAX
-# undef __undef_OPEN_MAX
-#endif
-
-/* The number of data keys per process.  */
-#define _POSIX_THREAD_KEYS_MAX	128
-/* This is the value this implementation supports.  */
-#define PTHREAD_KEYS_MAX	1024
-
-/* Controlling the iterations of destructors for thread-specific data.  */
-#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
-/* Number of iterations this implementation does.  */
-#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
-
-/* The number of threads per process.  */
-#define _POSIX_THREAD_THREADS_MAX	64
-/* This is the value this implementation supports.  */
-#define PTHREAD_THREADS_MAX	16384
-
-/* Maximum amount by which a process can descrease its asynchronous I/O
-   priority level.  */
-#define AIO_PRIO_DELTA_MAX	20
-
-/* Minimum size for a thread.  We are free to choose a reasonable value.  */
-#define PTHREAD_STACK_MIN	24576
-
-/* Maximum number of POSIX timers available.  */
-#define TIMER_MAX	256
-
-/* Maximum number of timer expiration overruns.  */
-#define DELAYTIMER_MAX	2147483647
-
-/* Maximum tty name length.  */
-#define TTY_NAME_MAX		32
-
-/* Maximum login name length.  This is arbitrary.  */
-#define LOGIN_NAME_MAX		256
-
-/* Maximum host name length.  */
-#define HOST_NAME_MAX		64
-
-/* Maximum message queue priority level.  */
-#define MQ_PRIO_MAX		32768
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/bits/typesizes.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/bits/typesizes.h
deleted file mode 100644
index 6d917e7f5..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/bits/typesizes.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* bits/typesizes.h -- underlying types for *_t.  Linux/Alpha version.
-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _BITS_TYPES_H
-# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
-#endif
-
-#ifndef	_BITS_TYPESIZES_H
-#define	_BITS_TYPESIZES_H	1
-
-/* See <bits/types.h> for the meaning of these macros.  This file exists so
-   that <bits/types.h> need not vary across different GNU platforms.  */
-
-#define __DEV_T_TYPE		__U64_TYPE
-#define __UID_T_TYPE		__U32_TYPE
-#define __GID_T_TYPE		__U32_TYPE
-#define __INO_T_TYPE		__U32_TYPE
-#define __INO64_T_TYPE		__U64_TYPE
-#define __MODE_T_TYPE		__U32_TYPE
-#define __NLINK_T_TYPE		__U32_TYPE
-#define __OFF_T_TYPE		__SLONGWORD_TYPE
-#define __OFF64_T_TYPE		__S64_TYPE
-#define __PID_T_TYPE		__S32_TYPE
-#define __RLIM_T_TYPE		__ULONGWORD_TYPE
-#define __RLIM64_T_TYPE		__U64_TYPE
-#define	__BLKCNT_T_TYPE		__U32_TYPE
-#define	__BLKCNT64_T_TYPE	__U64_TYPE
-#define	__FSBLKCNT_T_TYPE	__S32_TYPE
-#define	__FSBLKCNT64_T_TYPE	__S64_TYPE
-#define	__FSFILCNT_T_TYPE	__U32_TYPE
-#define	__FSFILCNT64_T_TYPE	__U64_TYPE
-#define	__ID_T_TYPE		__U32_TYPE
-#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
-#define __TIME_T_TYPE		__SLONGWORD_TYPE
-#define __USECONDS_T_TYPE	__U32_TYPE
-#define __SUSECONDS_T_TYPE	__S64_TYPE
-#define __DADDR_T_TYPE		__S32_TYPE
-#define __SWBLK_T_TYPE		__SLONGWORD_TYPE
-#define __KEY_T_TYPE		__S32_TYPE
-#define __CLOCKID_T_TYPE	__S32_TYPE
-#define __TIMER_T_TYPE		__S32_TYPE
-#define __BLKSIZE_T_TYPE	__U32_TYPE
-#define __FSID_T_TYPE		struct { int __val[2]; }
-#define __SSIZE_T_TYPE		__SWORD_TYPE
-
-/* Number of descriptors that can fit in an `fd_set'.  */
-#define	__FD_SETSIZE		1024
-
-
-#endif /* bits/typesizes.h */
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/pt-sigsuspend.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/pt-sigsuspend.S
deleted file mode 100644
index 754fc5b1c..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/pt-sigsuspend.S
+++ /dev/null
@@ -1,27 +0,0 @@
-/* Internal sigsuspend system call for LinuxThreads.  Alpha version.
-   Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-
-#undef PSEUDO_PREPARE_ARGS
-#define PSEUDO_PREPARE_ARGS	ldq	a0, 0(a0);
-
-	.hidden __pthread_sigsuspend
-PSEUDO_NOERRNO(__pthread_sigsuspend, sigsuspend, 1)
-	ret
-PSEUDO_END_NOERRNO(__pthread_sigsuspend)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/sysdep-cancel.h
deleted file mode 100644
index 8ce43153d..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/sysdep-cancel.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/* Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread
-
-# ifdef PROF
-#  define PSEUDO_PROF				\
-	.set noat;				\
-	lda	AT, _mcount;			\
-	jsr	AT, (AT), _mcount;		\
-	.set at
-# else
-#  define PSEUDO_PROF
-# endif
-
-/* ??? Assumes that nothing comes between PSEUDO and PSEUDO_END
-   besides "ret".  */
-
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)			\
-	.globl name;						\
-	.align 4;						\
-	.type name, @function;					\
-	.usepv name, std;					\
-	cfi_startproc;						\
-__LABEL(name)							\
-	ldgp	gp, 0(pv);					\
-	PSEUDO_PROF;						\
-	PSEUDO_PREPARE_ARGS					\
-	SINGLE_THREAD_P(t0);					\
-	bne	t0, $pseudo_cancel;				\
-	lda	v0, SYS_ify(syscall_name);			\
-	call_pal PAL_callsys;					\
-	bne	a3, SYSCALL_ERROR_LABEL;			\
-__LABEL($pseudo_ret)						\
-	.subsection 2;						\
-__LABEL($pseudo_cancel)						\
-	subq	sp, 64, sp;					\
-	cfi_def_cfa_offset(64);					\
-	stq	ra, 0(sp);					\
-	cfi_offset(ra, -64);					\
-	SAVE_ARGS_##args;					\
-	CENABLE;						\
-	LOAD_ARGS_##args;					\
-	lda	v0, SYS_ify(syscall_name);			\
-	call_pal PAL_callsys;					\
-	stq	v0, 8(sp);					\
-	bne	a3, $multi_error;				\
-	CDISABLE;						\
-	ldq	ra, 0(sp);					\
-	ldq	v0, 8(sp);					\
-	addq	sp, 64, sp;					\
-	cfi_remember_state;					\
-	cfi_restore(ra);					\
-	cfi_def_cfa_offset(0);					\
-	ret;							\
-	cfi_restore_state;					\
-__LABEL($multi_error)						\
-	CDISABLE;						\
-	ldq	ra, 0(sp);					\
-	ldq	v0, 8(sp);					\
-	addq	sp, 64, sp;					\
-	cfi_restore(ra);					\
-	cfi_def_cfa_offset(0);					\
-__LABEL($syscall_error)						\
-	SYSCALL_ERROR_HANDLER;					\
-	.previous
-
-# undef PSEUDO_END
-# define PSEUDO_END(sym)					\
-	.subsection 2;						\
-	cfi_endproc;						\
-	.size sym, .-sym
-
-# define SAVE_ARGS_0	/* Nothing.  */
-# define SAVE_ARGS_1	SAVE_ARGS_0; stq a0, 8(sp)
-# define SAVE_ARGS_2	SAVE_ARGS_1; stq a1, 16(sp)
-# define SAVE_ARGS_3	SAVE_ARGS_2; stq a2, 24(sp)
-# define SAVE_ARGS_4	SAVE_ARGS_3; stq a3, 32(sp)
-# define SAVE_ARGS_5	SAVE_ARGS_4; stq a4, 40(sp)
-# define SAVE_ARGS_6	SAVE_ARGS_5; stq a5, 48(sp)
-
-# define LOAD_ARGS_0	/* Nothing.  */
-# define LOAD_ARGS_1	LOAD_ARGS_0; ldq a0, 8(sp)
-# define LOAD_ARGS_2	LOAD_ARGS_1; ldq a1, 16(sp)
-# define LOAD_ARGS_3	LOAD_ARGS_2; ldq a2, 24(sp)
-# define LOAD_ARGS_4	LOAD_ARGS_3; ldq a3, 32(sp)
-# define LOAD_ARGS_5	LOAD_ARGS_4; ldq a4, 40(sp)
-# define LOAD_ARGS_6	LOAD_ARGS_5; ldq a5, 48(sp)
-
-# ifdef IS_IN_libpthread
-#  define __local_enable_asynccancel	__pthread_enable_asynccancel
-#  define __local_disable_asynccancel	__pthread_disable_asynccancel
-#  define __local_multiple_threads	__pthread_multiple_threads
-# else
-#  define __local_enable_asynccancel	__libc_enable_asynccancel
-#  define __local_disable_asynccancel	__libc_disable_asynccancel
-#  define __local_multiple_threads	__libc_multiple_threads
-# endif
-
-# ifdef __PIC__
-#  define CENABLE	bsr ra, __local_enable_asynccancel !samegp
-#  define CDISABLE	bsr ra, __local_disable_asynccancel !samegp
-# else
-#  define CENABLE	jsr ra, __local_enable_asynccancel; ldgp ra, 0(gp)
-#  define CDISABLE	jsr ra, __local_disable_asynccancel; ldgp ra, 0(gp)
-# endif
-
-# ifndef __ASSEMBLER__
-extern int __local_multiple_threads attribute_hidden;
-#   define SINGLE_THREAD_P \
-  __builtin_expect (__local_multiple_threads == 0, 1)
-# elif defined(__PIC__)
-#  define SINGLE_THREAD_P(reg)  ldl reg, __local_multiple_threads(gp) !gprel
-# else
-#  define SINGLE_THREAD_P(reg)					\
-	ldah	reg, __local_multiple_threads(gp) !gprelhigh;	\
-	ldl	reg, __local_multiple_threads(reg) !gprellow
-# endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/vfork.S
deleted file mode 100644
index 80fdcc6fb..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/alpha/vfork.S
+++ /dev/null
@@ -1,69 +0,0 @@
-/* Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-
-#include <sysdep-cancel.h>
-
-        .align 4
-	.globl	__vfork
-	.type	__vfork, @function
-	.usepv	__vfork, std
-	cfi_startproc
-__vfork:
-	ldgp	gp, 0(pv)
-	PSEUDO_PROF
-
-#ifdef SHARED
-	ldq	t0, __libc_pthread_functions(gp) !gprel
-	bne	t0, HIDDEN_JUMPTARGET (fork) !samegp
-#else
-	.weak	pthread_create
-	ldq	t0, pthread_create(gp) !literal
-	bne	t0, $do_fork
-#endif
-
-	lda	v0, SYS_ify(vfork)
-	call_pal PAL_callsys
-	bne	a3, SYSCALL_ERROR_LABEL
-	ret
-
-#ifndef SHARED
-	/* Can't tail-call due to possible mismatch between GP in
-	   fork and vfork object files.  */
-$do_fork:
-	subq	sp, 16, sp
-	cfi_adjust_cfa_offset(16)
-	stq	ra, 0(sp)
-	cfi_offset(ra, -16)
-	jsr	ra, HIDDEN_JUMPTARGET (fork)
-	ldgp	gp, 0(ra)
-	ldq	ra, 0(sp)
-	addq	sp, 16, sp
-	cfi_restore(ra)
-	cfi_adjust_cfa_offset(-16)
-	ret
-
-$syscall_error:
-	SYSCALL_ERROR_HANDLER
-#endif
-
-	cfi_endproc
-	.size __vfork, .-__vfork
-
-libc_hidden_def (__vfork)
-
-weak_alias (__vfork, vfork)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/arm/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/arm/sysdep-cancel.h
deleted file mode 100644
index 2c1eba65f..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/arm/sysdep-cancel.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/* Copyright (C) 2003, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Phil Blundell <pb@nexus.co.uk>, 2003.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <tls.h>
-#include <pt-machine.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread
-
-/* We push lr onto the stack, so we have to use ldmib instead of ldmia
-   to find the saved arguments.  */
-# ifdef __PIC__
-#  undef DOARGS_5
-#  undef DOARGS_6
-#  undef DOARGS_7
-#  define DOARGS_5 str r4, [sp, $-4]!; ldr r4, [sp, $8];
-#  define DOARGS_6 mov ip, sp; stmfd sp!, {r4, r5}; ldmib ip, {r4, r5};
-#  define DOARGS_7 mov ip, sp; stmfd sp!, {r4, r5, r6}; ldmib ip, {r4, r5, r6};
-# endif
-
-# undef PSEUDO_RET
-# define PSEUDO_RET						        \
-    ldrcc pc, [sp], $4;						        \
-    ldr	lr, [sp], $4;							\
-    b PLTJMP(SYSCALL_ERROR)
-
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				\
-  .section ".text";							\
-    PSEUDO_PROLOGUE;							\
-  ENTRY (name);								\
-    SINGLE_THREAD_P;							\
-    bne .Lpseudo_cancel;						\
-    DO_CALL (syscall_name, args);					\
-    cmn r0, $4096;							\
-    RETINSTR(cc, lr);							\
-    b PLTJMP(SYSCALL_ERROR);						\
-  .Lpseudo_cancel:							\
-    str lr, [sp, $-4]!;							\
-    DOCARGS_##args;	/* save syscall args around CENABLE.  */	\
-    CENABLE;								\
-    mov ip, r0;		/* put mask in safe place.  */			\
-    UNDOCARGS_##args;	/* restore syscall args.  */			\
-    swi SYS_ify (syscall_name);	/* do the call.  */			\
-    str r0, [sp, $-4]!; /* save syscall return value.  */		\
-    mov r0, ip;		/* get mask back.  */				\
-    CDISABLE;								\
-    ldr r0, [sp], $4;	/* retrieve return value.  */			\
-    UNDOC2ARGS_##args;	/* fix register damage.  */			\
-    cmn r0, $4096;
-
-# define DOCARGS_0
-# define UNDOCARGS_0
-# define UNDOC2ARGS_0
-
-# define DOCARGS_1	str r0, [sp, #-4]!;
-# define UNDOCARGS_1	ldr r0, [sp], #4;
-# define UNDOC2ARGS_1
-
-# define DOCARGS_2	str r1, [sp, #-4]!; str r0, [sp, #-4]!;
-# define UNDOCARGS_2	ldr r0, [sp], #4; ldr r1, [sp], #4;
-# define UNDOC2ARGS_2
-
-# define DOCARGS_3	str r2, [sp, #-4]!; str r1, [sp, #-4]!; str r0, [sp, #-4]!;
-# define UNDOCARGS_3	ldr r0, [sp], #4; ldr r1, [sp], #4; ldr r2, [sp], #4
-# define UNDOC2ARGS_3
-
-# define DOCARGS_4	stmfd sp!, {r0-r3}
-# define UNDOCARGS_4	ldmfd sp!, {r0-r3}
-# define UNDOC2ARGS_4
-
-# define DOCARGS_5	stmfd sp!, {r0-r3}
-# define UNDOCARGS_5	ldmfd sp, {r0-r3}; str r4, [sp, #-4]!; ldr r4, [sp, #24]
-# define UNDOC2ARGS_5   ldr r4, [sp], #20
-
-# ifdef IS_IN_libpthread
-#  define CENABLE	bl PLTJMP(__pthread_enable_asynccancel)
-#  define CDISABLE	bl PLTJMP(__pthread_disable_asynccancel)
-#  define __local_multiple_threads __pthread_multiple_threads
-# else
-#  define CENABLE	bl PLTJMP(__libc_enable_asynccancel)
-#  define CDISABLE	bl PLTJMP(__libc_disable_asynccancel)
-#  define __local_multiple_threads __libc_multiple_threads
-# endif
-
-# ifndef __ASSEMBLER__
-extern int __local_multiple_threads attribute_hidden;
-#  define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
-# else
-#  if !defined __PIC__
-#   define SINGLE_THREAD_P						\
-  ldr ip, =__local_multiple_threads;					\
-  ldr ip, [ip];								\
-  teq ip, #0;
-#   define PSEUDO_PROLOGUE
-#  else
-#   define SINGLE_THREAD_P						\
-  ldr ip, 1b;								\
-2:									\
-  ldr ip, [pc, ip];							\
-  teq ip, #0;
-#   define PSEUDO_PROLOGUE						\
-  1:  .word __local_multiple_threads - 2f - 8;
-#  endif
-# endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/arm/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/arm/vfork.S
deleted file mode 100644
index 3d9e49a0f..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/arm/vfork.S
+++ /dev/null
@@ -1,77 +0,0 @@
-/* Copyright (C) 1999, 2002, 2003, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Philip Blundell <philb@gnu.org>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep-cancel.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-#include <kernel-features.h>
-
-/* Clone the calling process, but without copying the whole address space.
-   The calling process is suspended until the new process exits or is
-   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
-   and the process ID of the new process to the old process.  */
-
-ENTRY (__vfork)
-
-#ifdef __NR_vfork
-
-#ifdef SHARED
-	ldr	ip, 1f
-	ldr	r0, 2f
-3:	add	ip, pc, ip
-	ldr	r0, [ip, r0]
-#else
-	ldr	r0, 1f
-#endif
-	movs	r0, r0
-	bne	HIDDEN_JUMPTARGET (fork)
-
-	DO_CALL (vfork, 0)
-	cmn	a1, #4096
-	RETINSTR(cc, lr)
-
-#ifndef __ASSUME_VFORK_SYSCALL
-	/* Check if vfork syscall is known at all.  */
-	cmn	a1, #ENOSYS
-	bne	PLTJMP(C_SYMBOL_NAME(__syscall_error))
-#endif
-
-#endif
-
-#ifndef __ASSUME_VFORK_SYSCALL
-	/* If we don't have vfork, fork is close enough.  */
-	DO_CALL (fork, 0)
-	cmn	a1, #4096
-	RETINSTR(cc, lr)
-#elif !defined __NR_vfork
-# error "__NR_vfork not available and __ASSUME_VFORK_SYSCALL defined"
-#endif
-    	b	PLTJMP(C_SYMBOL_NAME(__syscall_error))
-
-#ifdef SHARED
-1:	.word	_GLOBAL_OFFSET_TABLE_ - 3b - 8
-2:	.word	__libc_pthread_functions(GOTOFF)
-#else
-	.weak	pthread_create
-1:	.word	pthread_create
-#endif
-
-PSEUDO_END (__vfork)
-libc_hidden_def (__vfork)
-
-weak_alias (__vfork, vfork)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/execve.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/execve.c
deleted file mode 100644
index cae12182f..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/execve.c
+++ /dev/null
@@ -1,39 +0,0 @@
-/* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <unistd.h>
-
-#include <sysdep.h>
-#include <alloca.h>
-#include <sys/syscall.h>
-
-extern int __syscall_execve(const char *file,
-			char *const *argv,
-			char *const *envp);
-extern void __pthread_kill_other_threads_np(void);
-weak_extern(__pthread_kill_other_threads_np)
-
-int
-__execve(const char *file, char *const argv[], char *const envp[])
-{
-	/* If this is a threaded application kill all other threads.  */
-	if (__pthread_kill_other_threads_np)
-		__pthread_kill_other_threads_np();
-	return INLINE_SYSCALL(execve, 3, file, argv, envp);
-}
-weak_alias(__execve, execve)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/fork.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/fork.c
deleted file mode 100644
index 8f954d8d9..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/fork.c
+++ /dev/null
@@ -1,29 +0,0 @@
-/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <fork.h>
-#include <bits/libc-lock.h>
-
-struct fork_block __fork_block =
-{
-  .lock = PTHREAD_MUTEX_INITIALIZER,
-  .prepare_list = { &__fork_block.prepare_list, &__fork_block.prepare_list },
-  .parent_list = { &__fork_block.parent_list, &__fork_block.parent_list },
-  .child_list = { &__fork_block.child_list, &__fork_block.child_list }
-};
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/fork.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/fork.h
deleted file mode 100644
index 8245d9ef0..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/fork.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <list.h>
-#include <bits/libc-lock.h>
-
-struct fork_block
-{
-  /* Lock to protect handling of fork handlers.  */
-  __libc_lock_define (, lock);
-
-  /* Lists of registered fork handlers.  */
-  list_t prepare_list;
-  list_t parent_list;
-  list_t child_list;
-};
-
-extern struct fork_block __fork_block attribute_hidden;
-
-/* Elements of the fork handler lists.  */
-struct fork_handler
-{
-  list_t list;
-  void (*handler) (void);
-  void *dso_handle;
-};
-
-
-/* Function to call to unregister fork handlers.  */
-extern void __unregister_atfork (void *dso_handle) attribute_hidden;
-#define UNREGISTER_ATFORK(dso_handle) __unregister_atfork (dso_handle)
-
-
-/* C library side function to register new fork handlers.  */
-extern int __register_atfork (void (*__prepare) (void),
-			      void (*__parent) (void),
-			      void (*__child) (void),
-			      void *dso_handle);
-
-#ifndef ARCH_FORK
-# define ARCH_FORK() __libc_fork()
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/aio_cancel.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/aio_cancel.c
deleted file mode 100644
index 0d6da8291..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/aio_cancel.c
+++ /dev/null
@@ -1,33 +0,0 @@
-#include <shlib-compat.h>
-
-#define aio_cancel64 XXX
-#include <aio.h>
-#undef aio_cancel64
-#include <errno.h>
-
-extern __typeof (aio_cancel) __new_aio_cancel;
-extern __typeof (aio_cancel) __old_aio_cancel;
-
-#define aio_cancel	__new_aio_cancel
-
-#include <sysdeps/pthread/aio_cancel.c>
-
-#undef aio_cancel
-strong_alias (__new_aio_cancel, __new_aio_cancel64);
-versioned_symbol (librt, __new_aio_cancel, aio_cancel, GLIBC_2_3);
-versioned_symbol (librt, __new_aio_cancel64, aio_cancel64, GLIBC_2_3);
-
-#if SHLIB_COMPAT (librt, GLIBC_2_1, GLIBC_2_3)
-
-#undef ECANCELED
-#define aio_cancel	__old_aio_cancel
-#define ECANCELED	125
-
-#include <sysdeps/pthread/aio_cancel.c>
-
-#undef aio_cancel
-strong_alias (__old_aio_cancel, __old_aio_cancel64);
-compat_symbol (librt, __old_aio_cancel, aio_cancel, GLIBC_2_1);
-compat_symbol (librt, __old_aio_cancel64, aio_cancel64, GLIBC_2_1);
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/bits/initspin.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/bits/initspin.h
deleted file mode 100644
index e367fb9d8..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/bits/initspin.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/* PA-RISC specific definitions for spinlock initializers.
-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-/* Initial value of a spinlock.  PA-RISC only implements atomic load
-   and clear so this must be non-zero. */
-#define __LT_SPINLOCK_INIT 1
-
-/* Macros for lock initializers, using the above definition. */
-#define __LOCK_INITIALIZER { 0, __LT_SPINLOCK_INIT }
-#define __ALT_LOCK_INITIALIZER { 0, __LT_SPINLOCK_INIT }
-#define __ATOMIC_INITIALIZER { 0, __LT_SPINLOCK_INIT }
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/malloc-machine.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/malloc-machine.h
deleted file mode 100644
index e6b71f441..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/malloc-machine.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/* HP-PARISC macro definitions for mutexes, thread-specific data
-   and parameters for malloc.
-   Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Carlos O'Donell <carlos@baldric.uwo.ca>, 2003.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _MALLOC_MACHINE_H
-#define _MALLOC_MACHINE_H
-
-#undef thread_atfork_static
-
-#include <atomic.h>
-#include <bits/libc-lock.h>
-
-__libc_lock_define (typedef, mutex_t)
-
-/* Since our lock structure does not tolerate being initialized to zero, we must
-   modify the standard function calls made by malloc */
-#  define mutex_init(m)		\
-	__libc_maybe_call (__pthread_mutex_init, (m, NULL), \
-		(((m)->__m_lock.__spinlock = __LT_SPINLOCK_INIT),(*(int *)(m))) )
-#  define mutex_lock(m)		\
-	__libc_maybe_call (__pthread_mutex_lock, (m), \
-			(__load_and_clear(&((m)->__m_lock.__spinlock)), 0))
-#  define mutex_trylock(m)	\
-	__libc_maybe_call (__pthread_mutex_trylock, (m), \
-			(*(int *)(m) ? 1 : (__load_and_clear(&((m)->__m_lock.__spinlock)), 0)))
-#  define mutex_unlock(m)	\
-	__libc_maybe_call (__pthread_mutex_unlock, (m), \
-			(((m)->__m_lock.__spinlock = __LT_SPINLOCK_INIT), (*(int *)(m))) )
-
-/* This is defined by newer gcc version unique for each module.  */
-extern void *__dso_handle __attribute__ ((__weak__));
-
-#include <fork.h>
-
-#ifdef SHARED
-# define thread_atfork(prepare, parent, child) \
-   __register_atfork (prepare, parent, child, __dso_handle)
-#else
-# define thread_atfork(prepare, parent, child) \
-   __register_atfork (prepare, parent, child,				      \
-		      &__dso_handle == NULL ? NULL : __dso_handle)
-#endif
-
-/* thread specific data for glibc */
-
-#include <bits/libc-tsd.h>
-
-typedef int tsd_key_t[1];	/* no key data structure, libc magic does it */
-__libc_tsd_define (static, MALLOC)	/* declaration/common definition */
-#define tsd_key_create(key, destr)	((void) (key))
-#define tsd_setspecific(key, data)	__libc_tsd_set (MALLOC, (data))
-#define tsd_getspecific(key, vptr)	((vptr) = __libc_tsd_get (MALLOC))
-
-#include <sysdeps/generic/malloc-machine.h>
-
-#endif /* !defined(_MALLOC_MACHINE_H) */
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/pt-initfini.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/pt-initfini.c
deleted file mode 100644
index 60607ad4f..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/pt-initfini.c
+++ /dev/null
@@ -1,108 +0,0 @@
-/* Special .init and .fini section support for HPPA.  Linuxthreads version.
-   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   In addition to the permissions in the GNU Lesser General Public
-   License, the Free Software Foundation gives you unlimited
-   permission to link the compiled version of this file with other
-   programs, and to distribute those programs without any restriction
-   coming from the use of this file.  (The Lesser General Public
-   License restrictions do apply in other respects; for example, they
-   cover modification of the file, and distribution when not linked
-   into another program.)
-
-   The GNU C Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-/* This file is compiled into assembly code which is then munged by a sed
-   script into two files: crti.s and crtn.s.
-
-   * crti.s puts a function prologue at the beginning of the
-   .init and .fini sections and defines global symbols for
-   those addresses, so they can be called as functions.
-
-   * crtn.s puts the corresponding function epilogues
-   in the .init and .fini sections. */
-
-/* If we use the standard C version, the linkage table pointer won't
-   be properly preserved due to the splitting up of function prologues
-   and epilogues.  Therefore we write these in assembly to make sure
-   they do the right thing.  */
-
-__asm__ (
-"#include \"defs.h\"\n"
-"\n"
-"/*@HEADER_ENDS*/\n"
-"\n"
-"/*@_init_PROLOG_BEGINS*/\n"
-"	.section .init\n"
-"	.align 4\n"
-"	.globl _init\n"
-"	.type _init,@function\n"
-"_init:\n"
-"	stw	%rp,-20(%sp)\n"
-"	stwm	%r4,64(%sp)\n"
-"	stw	%r19,-32(%sp)\n"
-"	bl	__pthread_initialize_minimal,%rp\n"
-"	copy	%r19,%r4	/* delay slot */\n"
-"	copy	%r4,%r19\n"
-"/*@_init_PROLOG_ENDS*/\n"
-"\n"
-"/*@_init_EPILOG_BEGINS*/\n"
-"/* Here is the tail end of _init.  */\n"
-"	.section .init\n"
-"	ldw	-84(%sp),%rp\n"
-"	copy	%r4,%r19\n"
-"	bv	%r0(%rp)\n"
-"_end_init:\n"
-"	ldwm	-64(%sp),%r4\n"
-"\n"
-"/* Our very own unwind info, because the assembler can't handle\n"
-"   functions split into two or more pieces.  */\n"
-"	.section .PARISC.unwind,\"a\",@progbits\n"
-"	.extern _init\n"
-"	.word	_init, _end_init\n"
-"	.byte	0x08, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08\n"
-"\n"
-"/*@_init_EPILOG_ENDS*/\n"
-"\n"
-"/*@_fini_PROLOG_BEGINS*/\n"
-"	.section .fini\n"
-"	.align 4\n"
-"	.globl _fini\n"
-"	.type _fini,@function\n"
-"_fini:\n"
-"	stw	%rp,-20(%sp)\n"
-"	stwm	%r4,64(%sp)\n"
-"	stw	%r19,-32(%sp)\n"
-"	copy	%r19,%r4\n"
-"/*@_fini_PROLOG_ENDS*/\n"
-"\n"
-"/*@_fini_EPILOG_BEGINS*/\n"
-"	.section .fini\n"
-"	ldw	-84(%sp),%rp\n"
-"	copy	%r4,%r19\n"
-"	bv	%r0(%rp)\n"
-"_end_fini:\n"
-"	ldwm	-64(%sp),%r4\n"
-"\n"
-"	.section .PARISC.unwind,\"a\",@progbits\n"
-"	.extern _fini\n"
-"	.word	_fini, _end_fini\n"
-"	.byte	0x08, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08\n"
-"\n"
-"/*@_fini_EPILOG_ENDS*/\n"
-"\n"
-"/*@TRAILER_BEGINS*/\n"
-);
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/sysdep-cancel.h
deleted file mode 100644
index 8a7bd9705..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/hppa/sysdep-cancel.h
+++ /dev/null
@@ -1,188 +0,0 @@
-/* cancellable system calls for Linux/HPPA.
-   Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Carlos O'Donell <carlos@baldric.uwo.ca>, 2003.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-
-# ifndef NO_ERROR
-#  define NO_ERROR -0x1000
-# endif
-
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				\
-  ENTRY (name)								\
-    SINGLE_THREAD_P					ASM_LINE_SEP	\
-    cmpib,<> 0,%ret0,Lpseudo_cancel			ASM_LINE_SEP	\
-    nop							ASM_LINE_SEP	\
-    DO_CALL(syscall_name, args)				ASM_LINE_SEP	\
-    /* DONE! */						ASM_LINE_SEP	\
-    bv 0(2)						ASM_LINE_SEP	\
-    nop							ASM_LINE_SEP	\
-  Lpseudo_cancel:					ASM_LINE_SEP	\
-    /* store return ptr */				ASM_LINE_SEP	\
-    stw %rp, -20(%sr0,%sp)				ASM_LINE_SEP	\
-    /* save syscall args */				ASM_LINE_SEP	\
-    PUSHARGS_##args /* MACRO */				ASM_LINE_SEP	\
-    STW_PIC						ASM_LINE_SEP	\
-    CENABLE /* FUNC CALL */				ASM_LINE_SEP	\
-    ldo 64(%sp), %sp					ASM_LINE_SEP	\
-    ldo -64(%sp), %sp					ASM_LINE_SEP	\
-    LDW_PIC						ASM_LINE_SEP	\
-    /* restore syscall args */				ASM_LINE_SEP	\
-    POPARGS_##args					ASM_LINE_SEP	\
-    /* save r4 in arg0 stack slot */			ASM_LINE_SEP	\
-    stw %r4, -36(%sr0,%sp)				ASM_LINE_SEP	\
-    /* save mask from cenable */			ASM_LINE_SEP	\
-    copy %ret0, %r4					ASM_LINE_SEP	\
-    ble 0x100(%sr2,%r0)					ASM_LINE_SEP    \
-    ldi SYS_ify (syscall_name), %r20			ASM_LINE_SEP	\
-    LDW_PIC						ASM_LINE_SEP	\
-    /* pass mask as arg0 to cdisable */			ASM_LINE_SEP	\
-    copy %r4, %r26					ASM_LINE_SEP	\
-    copy %ret0, %r4					ASM_LINE_SEP	\
-    CDISABLE						ASM_LINE_SEP	\
-    ldo 64(%sp), %sp					ASM_LINE_SEP	\
-    ldo -64(%sp), %sp					ASM_LINE_SEP	\
-    LDW_PIC						ASM_LINE_SEP	\
-    /* compare error */					ASM_LINE_SEP	\
-    ldi NO_ERROR,%r1					ASM_LINE_SEP	\
-    /* branch if no error */				ASM_LINE_SEP	\
-    cmpb,>>=,n %r1,%r4,Lpre_end				ASM_LINE_SEP	\
-    nop							ASM_LINE_SEP	\
-    SYSCALL_ERROR_HANDLER				ASM_LINE_SEP	\
-    ldo 64(%sp), %sp					ASM_LINE_SEP	\
-    ldo -64(%sp), %sp					ASM_LINE_SEP	\
-    /* No need to LDW_PIC */				ASM_LINE_SEP	\
-    /* make syscall res value positive */		ASM_LINE_SEP	\
-    sub %r0, %r4, %r4					ASM_LINE_SEP	\
-    /* store into errno location */			ASM_LINE_SEP	\
-    stw %r4, 0(%sr0,%ret0)				ASM_LINE_SEP	\
-    /* return -1 */					ASM_LINE_SEP	\
-    ldo -1(%r0), %ret0					ASM_LINE_SEP	\
-  Lpre_end:						ASM_LINE_SEP	\
-    ldw -20(%sr0,%sp), %rp             			ASM_LINE_SEP	\
-    /* No need to LDW_PIC */				ASM_LINE_SEP	\
-    ldw -36(%sr0,%sp), %r4				ASM_LINE_SEP
-
-/* Save arguments into our frame */
-# define PUSHARGS_0	/* nothing to do */
-# define PUSHARGS_1	PUSHARGS_0 stw %r26, -36(%sr0,%sp)	ASM_LINE_SEP
-# define PUSHARGS_2	PUSHARGS_1 stw %r25, -40(%sr0,%sp)	ASM_LINE_SEP
-# define PUSHARGS_3	PUSHARGS_2 stw %r24, -44(%sr0,%sp)	ASM_LINE_SEP
-# define PUSHARGS_4	PUSHARGS_3 stw %r23, -48(%sr0,%sp)	ASM_LINE_SEP
-# define PUSHARGS_5	PUSHARGS_4 /* Args are on the stack... */
-# define PUSHARGS_6	PUSHARGS_5
-
-/* Bring them back from the stack */
-# define POPARGS_0	/* nothing to do */
-# define POPARGS_1	POPARGS_0 ldw -36(%sr0,%sp), %r26	ASM_LINE_SEP
-# define POPARGS_2	POPARGS_1 ldw -40(%sr0,%sp), %r25	ASM_LINE_SEP
-# define POPARGS_3	POPARGS_2 ldw -44(%sr0,%sp), %r24	ASM_LINE_SEP
-# define POPARGS_4	POPARGS_3 ldw -48(%sr0,%sp), %r23	ASM_LINE_SEP
-# define POPARGS_5	POPARGS_4 ldw -52(%sr0,%sp), %r22	ASM_LINE_SEP
-# define POPARGS_6	POPARGS_5 ldw -54(%sr0,%sp), %r21	ASM_LINE_SEP
-
-# ifdef IS_IN_libpthread
-#  ifdef __PIC__
-#   define CENABLE .import __pthread_enable_asynccancel,code ASM_LINE_SEP \
-			bl __pthread_enable_asynccancel,%r2 ASM_LINE_SEP
-#   define CDISABLE .import __pthread_disable_asynccancel,code ASM_LINE_SEP \
-			bl __pthread_disable_asynccancel,%r2 ASM_LINE_SEP
-#  else
-#   define CENABLE .import __pthread_enable_asynccancel,code ASM_LINE_SEP \
-			bl __pthread_enable_asynccancel,%r2 ASM_LINE_SEP
-#   define CDISABLE .import __pthread_disable_asynccancel,code ASM_LINE_SEP \
-			bl __pthread_disable_asynccancel,%r2 ASM_LINE_SEP
-#  endif
-# elif !defined NOT_IN_libc
-#  ifdef __PIC__
-#   define CENABLE .import __libc_enable_asynccancel,code ASM_LINE_SEP \
-			bl __libc_enable_asynccancel,%r2 ASM_LINE_SEP
-#   define CDISABLE	.import __libc_disable_asynccancel,code ASM_LINE_SEP \
-			bl __libc_disable_asynccancel,%r2 ASM_LINE_SEP
-#  else
-#   define CENABLE .import __libc_enable_asynccancel,code ASM_LINE_SEP \
-			bl __libc_enable_asynccancel,%r2 ASM_LINE_SEP
-#   define CDISABLE	.import __libc_disable_asynccancel,code ASM_LINE_SEP \
-			bl __libc_disable_asynccancel,%r2 ASM_LINE_SEP
-#  endif
-# else
-#  ifdef __PIC__
-#   define CENABLE .import __librt_enable_asynccancel,code ASM_LINE_SEP \
-			bl __librt_enable_asynccancel,%r2 ASM_LINE_SEP
-#   define CDISABLE .import __librt_disable_asynccancel,code ASM_LINE_SEP \
-			bl __librt_disable_asynccancel,%r2 ASM_LINE_SEP
-#  else
-#   define CENABLE .import __librt_enable_asynccancel,code ASM_LINE_SEP \
-			bl __librt_enable_asynccancel,%r2 ASM_LINE_SEP
-#   define CDISABLE .import __librt_disable_asynccancel,code ASM_LINE_SEP \
-			bl __librt_disable_asynccancel,%r2 ASM_LINE_SEP
-#  endif
-# endif
-
-/* p_header.multiple_threads is +12 from the pthread_descr struct start,
-   We could have called __get_cr27() but we really want less overhead */
-# define MULTIPLE_THREADS_OFFSET 0xC
-
-/* cr27 has been initialized to 0x0 by kernel */
-# define NO_THREAD_CR27 0x0
-
-# ifdef IS_IN_libpthread
-#  define __local_multiple_threads __pthread_multiple_threads
-# elif !defined NOT_IN_libc
-#  define __local_multiple_threads __libc_multiple_threads
-# else
-#  define __local_multiple_threads __librt_multiple_threads
-# endif
-
-# ifndef __ASSEMBLER__
- extern int __local_multiple_threads attribute_hidden;
-#  define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
-# else
-/* This ALT version requires newer kernel support */
-#  define SINGLE_THREAD_P_MFCTL						\
-	mfctl %cr27, %ret0					ASM_LINE_SEP	\
-	cmpib,= NO_THREAD_CR27,%ret0,Lstp			ASM_LINE_SEP	\
-	nop							ASM_LINE_SEP	\
-	ldw MULTIPLE_THREADS_OFFSET(%sr0,%ret0),%ret0		ASM_LINE_SEP	\
- Lstp:								ASM_LINE_SEP
-#  ifdef __PIC__
-/* Slower version uses GOT to get value of __local_multiple_threads */
-#   define SINGLE_THREAD_P							\
-	addil LT%__local_multiple_threads, %r19			ASM_LINE_SEP	\
-	ldw RT%__local_multiple_threads(%sr0,%r1), %ret0	ASM_LINE_SEP	\
-	ldw 0(%sr0,%ret0), %ret0 				ASM_LINE_SEP
-#  else
-  /* Slow non-pic version using DP */
-#   define SINGLE_THREAD_P								\
-	addil LR%__local_multiple_threads-$global$,%r27  		ASM_LINE_SEP	\
-	ldw RR%__local_multiple_threads-$global$(%sr0,%r1),%ret0	ASM_LINE_SEP
-#  endif
-# endif
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
-/* !defined NOT_IN_libc || defined IS_IN_libpthread */
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/i386/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/i386/sysdep-cancel.h
deleted file mode 100644
index d330e664e..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/i386/sysdep-cancel.h
+++ /dev/null
@@ -1,186 +0,0 @@
-/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <tls.h>
-#include <pt-machine.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				      \
-  .text;								      \
-  ENTRY (name)								      \
-    SINGLE_THREAD_P;							      \
-    jne L(pseudo_cancel);						      \
-    DO_CALL (syscall_name, args);					      \
-    cmpl $-4095, %eax;							      \
-    jae SYSCALL_ERROR_LABEL;						      \
-    ret;								      \
-  L(pseudo_cancel):							      \
-    CENABLE								      \
-    SAVE_OLDTYPE_##args							      \
-    PUSHCARGS_##args							      \
-    DOCARGS_##args							      \
-    movl $SYS_ify (syscall_name), %eax;					      \
-    int $0x80								      \
-    POPCARGS_##args;							      \
-    POPSTATE_##args							      \
-    cmpl $-4095, %eax;							      \
-    jae SYSCALL_ERROR_LABEL;						      \
-  L(pseudo_end):
-
-# define SAVE_OLDTYPE_0	movl %eax, %ecx;
-# define SAVE_OLDTYPE_1	SAVE_OLDTYPE_0
-# define SAVE_OLDTYPE_2	pushl %eax; cfi_adjust_cfa_offset (4);
-# define SAVE_OLDTYPE_3	SAVE_OLDTYPE_2
-# define SAVE_OLDTYPE_4	SAVE_OLDTYPE_2
-# define SAVE_OLDTYPE_5	SAVE_OLDTYPE_2
-
-# define PUSHCARGS_0	/* No arguments to push.  */
-# define DOCARGS_0	/* No arguments to frob.  */
-# define POPCARGS_0	/* No arguments to pop.  */
-# define _PUSHCARGS_0	/* No arguments to push.  */
-# define _POPCARGS_0	/* No arguments to pop.  */
-
-# define PUSHCARGS_1	movl %ebx, %edx; cfi_register (ebx, edx); PUSHCARGS_0
-# define DOCARGS_1	_DOARGS_1 (4)
-# define POPCARGS_1	POPCARGS_0; movl %edx, %ebx; cfi_restore (ebx);
-# define _PUSHCARGS_1	pushl %ebx; cfi_adjust_cfa_offset (4); \
-			cfi_rel_offset (ebx, 0); _PUSHCARGS_0
-# define _POPCARGS_1	_POPCARGS_0; popl %ebx; \
-			cfi_adjust_cfa_offset (-4); cfi_restore (ebx);
-
-# define PUSHCARGS_2	PUSHCARGS_1
-# define DOCARGS_2	_DOARGS_2 (12)
-# define POPCARGS_2	POPCARGS_1
-# define _PUSHCARGS_2	_PUSHCARGS_1
-# define _POPCARGS_2	_POPCARGS_1
-
-# define PUSHCARGS_3	_PUSHCARGS_2
-# define DOCARGS_3	_DOARGS_3 (20)
-# define POPCARGS_3	_POPCARGS_3
-# define _PUSHCARGS_3	_PUSHCARGS_2
-# define _POPCARGS_3	_POPCARGS_2
-
-# define PUSHCARGS_4	_PUSHCARGS_4
-# define DOCARGS_4	_DOARGS_4 (28)
-# define POPCARGS_4	_POPCARGS_4
-# define _PUSHCARGS_4	pushl %esi; cfi_adjust_cfa_offset (4); \
-			cfi_rel_offset (esi, 0); _PUSHCARGS_3
-# define _POPCARGS_4	_POPCARGS_3; popl %esi; \
-			cfi_adjust_cfa_offset (-4); cfi_restore (esi);
-
-# define PUSHCARGS_5	_PUSHCARGS_5
-# define DOCARGS_5	_DOARGS_5 (36)
-# define POPCARGS_5	_POPCARGS_5
-# define _PUSHCARGS_5	pushl %edi; cfi_adjust_cfa_offset (4); \
-			cfi_rel_offset (edi, 0); _PUSHCARGS_4
-# define _POPCARGS_5	_POPCARGS_4; popl %edi; \
-			cfi_adjust_cfa_offset (-4); cfi_restore (edi);
-
-# ifdef IS_IN_libpthread
-#  define CENABLE	call __pthread_enable_asynccancel;
-#  define CDISABLE	call __pthread_disable_asynccancel
-# elif defined IS_IN_librt
-#  ifdef __PIC__
-#   define CENABLE	pushl %ebx; \
-			call __i686.get_pc_thunk.bx; \
-			addl     $_GLOBAL_OFFSET_TABLE_, %ebx; \
-			call __librt_enable_asynccancel@PLT; \
-			popl %ebx;
-#   define CDISABLE	pushl %ebx; \
-			call __i686.get_pc_thunk.bx; \
-			addl     $_GLOBAL_OFFSET_TABLE_, %ebx; \
-			call __librt_disable_asynccancel@PLT; \
-			popl %ebx;
-#  else
-#   define CENABLE	call __librt_enable_asynccancel;
-#   define CDISABLE	call __librt_disable_asynccancel
-#  endif
-# else
-#  define CENABLE	call __libc_enable_asynccancel;
-#  define CDISABLE	call __libc_disable_asynccancel
-# endif
-# define POPSTATE_0 \
- pushl %eax; cfi_adjust_cfa_offset (4); movl %ecx, %eax; \
- CDISABLE; popl %eax; cfi_adjust_cfa_offset (-4);
-# define POPSTATE_1	POPSTATE_0
-# define POPSTATE_2	xchgl (%esp), %eax; CDISABLE; popl %eax; \
-			cfi_adjust_cfa_offset (-4);
-# define POPSTATE_3	POPSTATE_2
-# define POPSTATE_4	POPSTATE_3
-# define POPSTATE_5	POPSTATE_4
-
-#if !defined NOT_IN_libc
-# define __local_multiple_threads __libc_multiple_threads
-#elif defined IS_IN_libpthread
-# define __local_multiple_threads __pthread_multiple_threads
-#else
-# define __local_multiple_threads __librt_multiple_threads
-#endif
-
-# ifndef __ASSEMBLER__
-#  if defined FLOATING_STACKS && defined __UCLIBC_HAS_TLS__ && defined __PIC__
-#   define SINGLE_THREAD_P \
-  __builtin_expect (THREAD_GETMEM (THREAD_SELF,				      \
-				   p_header.data.multiple_threads) == 0, 1)
-#  else
-extern int __local_multiple_threads
-#   if !defined NOT_IN_libc || defined IS_IN_libpthread
-  attribute_hidden;
-#   else
-  ;
-#   endif
-#   define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
-#  endif
-# else
-#  if !defined __PIC__
-#   define SINGLE_THREAD_P cmpl $0, __local_multiple_threads
-#  elif defined FLOATING_STACKS && defined __UCLIBC_HAS_TLS__
-#   define SINGLE_THREAD_P cmpl $0, %gs:MULTIPLE_THREADS_OFFSET
-#  else
-#   if !defined NOT_IN_libc || defined IS_IN_libpthread
-#    define __SINGLE_THREAD_CMP cmpl $0, __local_multiple_threads@GOTOFF(%ecx)
-#   else
-#    define __SINGLE_THREAD_CMP \
-  movl __local_multiple_threads@GOT(%ecx), %ecx;\
-  cmpl $0, (%ecx)
-#   endif
-#   if !defined HAVE_HIDDEN || !defined __UCLIBC_HAS_TLS__
-#    define SINGLE_THREAD_P \
-  SETUP_PIC_REG (cx);				\
-  addl $_GLOBAL_OFFSET_TABLE_, %ecx;		\
-  __SINGLE_THREAD_CMP
-#   else
-#    define SINGLE_THREAD_P \
-  call __i686.get_pc_thunk.cx;			\
-  addl $_GLOBAL_OFFSET_TABLE_, %ecx;		\
-  __SINGLE_THREAD_CMP
-#   endif
-#  endif
-# endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/i386/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/i386/vfork.S
deleted file mode 100644
index 83ad9f3b5..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/i386/vfork.S
+++ /dev/null
@@ -1,94 +0,0 @@
-/* Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Andreas Schwab <schwab@gnu.org>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep-cancel.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-#include <bits/kernel-features.h>
-
-/* Clone the calling process, but without copying the whole address space.
-   The calling process is suspended until the new process exits or is
-   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
-   and the process ID of the new process to the old process.  */
-
-ENTRY (__vfork)
-
-#ifdef __NR_vfork
-
-# ifdef SHARED
-#  if !defined HAVE_HIDDEN || !defined __UCLIBC_HAS_TLS__
-	SETUP_PIC_REG (cx)
-#  else
-	call	__i686.get_pc_thunk.cx
-#  endif
-	addl	$_GLOBAL_OFFSET_TABLE_, %ecx
-	cmpl	$0, __libc_pthread_functions@GOTOFF(%ecx)
-# else
-	.weak	pthread_create
-	movl	$pthread_create, %eax
-	testl	%eax, %eax
-# endif
-	jne	HIDDEN_JUMPTARGET (fork)
-
-	/* Pop the return PC value into ECX.  */
-	popl	%ecx
-
-	/* Stuff the syscall number in EAX and enter into the kernel.  */
-	movl	$SYS_ify (vfork), %eax
-	int	$0x80
-
-	/* Jump to the return PC.  Don't jump directly since this
-	   disturbs the branch target cache.  Instead push the return
-	   address back on the stack.  */
-	pushl	%ecx
-
-	cmpl	$-4095, %eax
-	/* Branch forward if it failed.  */
-# ifdef __ASSUME_VFORK_SYSCALL
-	jae	SYSCALL_ERROR_LABEL
-.Lpseudo_end:
-# else
-	jae	.Lerror
-# endif
-
-	ret
-
-# ifndef __ASSUME_VFORK_SYSCALL
-.Lerror:
-	/* Check if vfork syscall is known at all.  */
-	cmpl	$-ENOSYS, %eax
-	jne	SYSCALL_ERROR_LABEL
-# endif
-#endif
-
-#ifndef __ASSUME_VFORK_SYSCALL
-	/* If we don't have vfork, fork is close enough.  */
-
-	movl	$SYS_ify (fork), %eax
-	int	$0x80
-	cmpl	$-4095, %eax
-	jae	SYSCALL_ERROR_LABEL
-.Lpseudo_end:
-	ret
-#elif !defined __NR_vfork
-# error "__NR_vfork not available and __ASSUME_VFORK_SYSCALL defined"
-#endif
-PSEUDO_END (__vfork)
-libc_hidden_def (__vfork)
-
-weak_alias (__vfork, vfork)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/bits/local_lim.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/bits/local_lim.h
deleted file mode 100644
index ad12181ff..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/bits/local_lim.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* Minimum guaranteed maximum values for system limits.  Linux/Alpha version.
-   Copyright (C) 1993-1998,2000,2002,2003,2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-/* The kernel header pollutes the namespace with the NR_OPEN symbol
-   and defines LINK_MAX although filesystems have different maxima.  A
-   similar thing is true for OPEN_MAX: the limit can be changed at
-   runtime and therefore the macro must not be defined.  Remove this
-   after including the header if necessary.  */
-#ifndef NR_OPEN
-# define __undef_NR_OPEN
-#endif
-#ifndef LINK_MAX
-# define __undef_LINK_MAX
-#endif
-#ifndef OPEN_MAX
-# define __undef_OPEN_MAX
-#endif
-
-/* The kernel sources contain a file with all the needed information.  */
-#include <linux/limits.h>
-
-/* Have to remove NR_OPEN?  */
-#ifdef __undef_NR_OPEN
-# undef NR_OPEN
-# undef __undef_NR_OPEN
-#endif
-/* Have to remove LINK_MAX?  */
-#ifdef __undef_LINK_MAX
-# undef LINK_MAX
-# undef __undef_LINK_MAX
-#endif
-/* Have to remove OPEN_MAX?  */
-#ifdef __undef_OPEN_MAX
-# undef OPEN_MAX
-# undef __undef_OPEN_MAX
-#endif
-
-/* The number of data keys per process.  */
-#define _POSIX_THREAD_KEYS_MAX	128
-/* This is the value this implementation supports.  */
-#define PTHREAD_KEYS_MAX	1024
-
-/* Controlling the iterations of destructors for thread-specific data.  */
-#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
-/* Number of iterations this implementation does.  */
-#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
-
-/* The number of threads per process.  */
-#define _POSIX_THREAD_THREADS_MAX	64
-/* This is the value this implementation supports.  */
-#define PTHREAD_THREADS_MAX	16384
-
-/* Maximum amount by which a process can descrease its asynchronous I/O
-   priority level.  */
-#define AIO_PRIO_DELTA_MAX	20
-
-/* Minimum size for a thread.  We are free to choose a reasonable value.  */
-#define PTHREAD_STACK_MIN	196608
-
-/* Maximum number of POSIX timers available.  */
-#define TIMER_MAX	256
-
-/* Maximum number of timer expiration overruns.  */
-#define DELAYTIMER_MAX	2147483647
-
-/* Maximum tty name length.  */
-#define TTY_NAME_MAX		32
-
-/* Maximum login name length.  This is arbitrary.  */
-#define LOGIN_NAME_MAX		256
-
-/* Maximum host name length.  */
-#define HOST_NAME_MAX		64
-
-/* Maximum message queue priority level.  */
-#define MQ_PRIO_MAX		32768
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/fork.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/fork.h
deleted file mode 100644
index 88f286145..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/fork.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <signal.h>
-#include <sysdep.h>
-
-#define ARCH_FORK() INLINE_SYSCALL (clone, 2, SIGCHLD, 0)
-
-#include_next <fork.h>
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/pt-initfini.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/pt-initfini.c
deleted file mode 100644
index 025566587..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/pt-initfini.c
+++ /dev/null
@@ -1,141 +0,0 @@
-/* Special .init and .fini section support for ia64. LinuxThreads version.
-   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   In addition to the permissions in the GNU Lesser General Public
-   License, the Free Software Foundation gives you unlimited
-   permission to link the compiled version of this file with other
-   programs, and to distribute those programs without any restriction
-   coming from the use of this file.  (The Lesser General Public
-   License restrictions do apply in other respects; for example, they
-   cover modification of the file, and distribution when not linked
-   into another program.)
-
-   The GNU C Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-/* This file is compiled into assembly code which is then munged by a sed
-   script into two files: crti.s and crtn.s.
-
-   * crti.s puts a function prologue at the beginning of the
-   .init and .fini sections and defines global symbols for
-   those addresses, so they can be called as functions.
-
-   * crtn.s puts the corresponding function epilogues
-   in the .init and .fini sections. */
-
-#include <stddef.h>
-
-#ifdef HAVE_INITFINI_ARRAY
-
-# define INIT_NEW_WAY \
-    ".xdata8 \".init_array\", @fptr(__pthread_initialize_minimal)\n"
-# define INIT_OLD_WAY ""
-#else
-# define INIT_NEW_WAY ""
-# define INIT_OLD_WAY \
-	"\n\
-	st8 [r12] = gp, -16\n\
-	br.call.sptk.many b0 = __pthread_initialize_minimal# ;;\n\
-	;;\n\
-	adds r12 = 16, r12\n\
-	;;\n\
-	ld8 gp = [r12]\n\
-	;;\n"
-#endif
-
-__asm__ ("\n\
-\n\
-#include \"defs.h\"\n\
-\n\
-/*@HEADER_ENDS*/\n\
-\n\
-/*@_init_PROLOG_BEGINS*/\n"
-	INIT_NEW_WAY
-	".section .init\n\
-	.align 16\n\
-	.global _init#\n\
-	.proc _init#\n\
-_init:\n\
-	.prologue\n\
-	.save ar.pfs, r34\n\
-	alloc r34 = ar.pfs, 0, 3, 0, 0\n\
-	.vframe r32\n\
-	mov r32 = r12\n\
-	.save rp, r33\n\
-	mov r33 = b0\n\
-	.body\n\
-	adds r12 = -16, r12\n\
-	;;\n"
-	INIT_OLD_WAY
-	".endp _init#\n\
-\n\
-/*@_init_PROLOG_ENDS*/\n\
-\n\
-/*@_init_EPILOG_BEGINS*/\n\
-	.section .init\n\
-	.proc _init#\n\
-_init:\n\
-	.prologue\n\
-	.save ar.pfs, r34\n\
-	.vframe r32\n\
-	.save rp, r33\n\
-	.body\n\
-	mov r12 = r32\n\
-	mov ar.pfs = r34\n\
-	mov b0 = r33\n\
-	br.ret.sptk.many b0\n\
-	.endp _init#\n\
-/*@_init_EPILOG_ENDS*/\n\
-\n\
-/*@_fini_PROLOG_BEGINS*/\n\
-	.section .fini\n\
-	.align 16\n\
-	.global _fini#\n\
-	.proc _fini#\n\
-_fini:\n\
-	.prologue\n\
-	.save ar.pfs, r34\n\
-	alloc r34 = ar.pfs, 0, 3, 0, 0\n\
-	.vframe r32\n\
-	mov r32 = r12\n\
-	.save rp, r33\n\
-	mov r33 = b0\n\
-	.body\n\
-	adds r12 = -16, r12\n\
-	;;\n\
-	.endp _fini#\n\
-\n\
-/*@_fini_PROLOG_ENDS*/\n\
-\n\
-/*@_fini_EPILOG_BEGINS*/\n\
-	.section .fini\n\
-	.proc _fini#\n\
-_fini:\n\
-	.prologue\n\
-	.save ar.pfs, r34\n\
-	.vframe r32\n\
-	.save rp, r33\n\
-	.body\n\
-	mov r12 = r32\n\
-	mov ar.pfs = r34\n\
-	mov b0 = r33\n\
-	br.ret.sptk.many b0\n\
-	.endp _fini#\n\
-\n\
-/*@_fini_EPILOG_ENDS*/\n\
-\n\
-/*@TRAILER_BEGINS*/\n\
-	.weak	__gmon_start__#\n\
-");
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/pt-sigsuspend.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/pt-sigsuspend.c
deleted file mode 100644
index edb08439a..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/pt-sigsuspend.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Internal sigsuspend system call for LinuxThreads.  IA64 version.
-   Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <signal.h>
-#include <unistd.h>
-
-#include <sysdep.h>
-#include <sys/syscall.h>
-#include <linuxthreads/internals.h>
-
-void
-__pthread_sigsuspend (const sigset_t *set)
-{
-  INTERNAL_SYSCALL_DECL (err);
-  INTERNAL_SYSCALL (rt_sigsuspend, err, 2, set, _NSIG / 8);
-}
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/sysdep-cancel.h
deleted file mode 100644
index 595644044..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/sysdep-cancel.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <tls.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-
-# ifdef IS_IN_librt
-#  define PSEUDO_NLOCAL		6
-#  define PSEUDO_SAVE_GP	mov loc5 = gp
-#  define PSEUDO_RESTORE_GP	mov gp = loc5
-#  define PSEUDO_SAVE_GP_1
-#  define PSEUDO_RESTORE_GP_1	mov gp = loc5
-# else
-#  define PSEUDO_NLOCAL		5
-#  define PSEUDO_SAVE_GP
-#  define PSEUDO_RESTORE_GP
-#  define PSEUDO_SAVE_GP_1	mov loc4 = gp;;
-#  define PSEUDO_RESTORE_GP_1	mov gp = loc4
-# endif
-
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				      \
-.text;									      \
-ENTRY (name)								      \
-     adds r14 = MULTIPLE_THREADS_OFFSET, r13;;				      \
-     ld4 r14 = [r14];							      \
-     mov r15 = SYS_ify(syscall_name);;					      \
-     cmp4.ne p6, p7 = 0, r14;						      \
-(p6) br.cond.spnt .Lpseudo_cancel;;					      \
-     break __BREAK_SYSCALL;;						      \
-     cmp.eq p6,p0=-1,r10;						      \
-(p6) br.cond.spnt.few __syscall_error;					      \
-     ret;;								      \
-     .endp name;							      \
-     .proc __GC_##name;							      \
-     .globl __GC_##name;						      \
-     .hidden __GC_##name;						      \
-__GC_##name:								      \
-.Lpseudo_cancel:							      \
-     .prologue;								      \
-     .regstk args, PSEUDO_NLOCAL, args, 0;				      \
-     .save ar.pfs, loc0;						      \
-     alloc loc0 = ar.pfs, args, PSEUDO_NLOCAL, args, 0;			      \
-     .save rp, loc1;							      \
-     mov loc1 = rp;							      \
-     PSEUDO_SAVE_GP;;							      \
-     .body;								      \
-     CENABLE;;								      \
-     PSEUDO_RESTORE_GP;							      \
-     mov loc2 = r8;							      \
-     COPY_ARGS_##args							      \
-     mov r15 = SYS_ify(syscall_name);					      \
-     break __BREAK_SYSCALL;;						      \
-     mov loc3 = r8;							      \
-     mov loc4 = r10;							      \
-     mov out0 = loc2;							      \
-     CDISABLE;;								      \
-     PSEUDO_RESTORE_GP;							      \
-     cmp.eq p6,p0=-1,loc4;						      \
-(p6) br.cond.spnt.few __syscall_error_##args;				      \
-     mov r8 = loc3;							      \
-     mov rp = loc1;							      \
-     mov ar.pfs = loc0;							      \
-.Lpseudo_end:								      \
-     ret;								      \
-     .endp __GC_##name;							      \
-.section .gnu.linkonce.t.__syscall_error_##args, "ax";			      \
-     .align 32;								      \
-     .proc __syscall_error_##args;					      \
-     .global __syscall_error_##args;					      \
-     .hidden __syscall_error_##args;					      \
-     .size __syscall_error_##args, 64;					      \
-__syscall_error_##args:							      \
-     .prologue;								      \
-     .regstk args, PSEUDO_NLOCAL, args, 0;				      \
-     .save ar.pfs, loc0;						      \
-     .save rp, loc1;							      \
-     .body;								      \
-     PSEUDO_SAVE_GP_1;							      \
-     br.call.sptk.many b0 = __errno_location;;				      \
-     st4 [r8] = loc3;							      \
-     PSEUDO_RESTORE_GP_1;						      \
-     mov rp = loc1;							      \
-     mov r8 = -1;							      \
-     mov ar.pfs = loc0
-
-#undef PSEUDO_END
-#define PSEUDO_END(name) .endp
-
-# ifdef IS_IN_libpthread
-#  define CENABLE	br.call.sptk.many b0 = __pthread_enable_asynccancel
-#  define CDISABLE	br.call.sptk.many b0 = __pthread_disable_asynccancel
-# elif !defined NOT_IN_libc
-#  define CENABLE	br.call.sptk.many b0 = __libc_enable_asynccancel
-#  define CDISABLE	br.call.sptk.many b0 = __libc_disable_asynccancel
-# else
-#  define CENABLE	br.call.sptk.many b0 = __librt_enable_asynccancel
-#  define CDISABLE	br.call.sptk.many b0 = __librt_disable_asynccancel
-# endif
-
-#define COPY_ARGS_0	/* Nothing */
-#define COPY_ARGS_1	COPY_ARGS_0 mov out0 = in0;
-#define COPY_ARGS_2	COPY_ARGS_1 mov out1 = in1;
-#define COPY_ARGS_3	COPY_ARGS_2 mov out2 = in2;
-#define COPY_ARGS_4	COPY_ARGS_3 mov out3 = in3;
-#define COPY_ARGS_5	COPY_ARGS_4 mov out4 = in4;
-#define COPY_ARGS_6	COPY_ARGS_5 mov out5 = in5;
-#define COPY_ARGS_7	COPY_ARGS_6 mov out6 = in6;
-
-# ifndef __ASSEMBLER__
-#  define SINGLE_THREAD_P \
-  __builtin_expect (THREAD_GETMEM (THREAD_SELF, p_multiple_threads) == 0, 1)
-# else
-#  define SINGLE_THREAD_P \
-  adds r14 = MULTIPLE_THREADS_OFFSET, r13 ;; ld4 r14 = [r14] ;; cmp4.ne p6, p7 = 0, r14
-# endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/vfork.S
deleted file mode 100644
index 9b5fa767f..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/ia64/vfork.S
+++ /dev/null
@@ -1,53 +0,0 @@
-/* Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-
-#include <sysdep-cancel.h>
-#define _SIGNAL_H
-#include <bits/signum.h>
-
-/* The following are defined in linux/sched.h, which unfortunately	*/
-/* is not safe for inclusion in an assembly file.			*/
-#define CLONE_VM        0x00000100      /* set if VM shared between processes */
-#define CLONE_VFORK     0x00004000      /* set if the parent wants the child to wake it up on mm_release */
-
-/* pid_t vfork(void); */
-/* Implemented as __clone_syscall(CLONE_VFORK | CLONE_VM | SIGCHLD, 0)	*/
-
-ENTRY(__vfork)
-#ifdef SHARED
-	addl r14 = @gprel(__libc_pthread_functions#), gp;;
-#else
-	.weak	pthread_create
-	addl r14 = @ltoff(@fptr(pthread_create#)), gp;;
-#endif
-	ld8 r14 = [r14];;
-	cmp.ne p6, p7 = 0, r14
-(p6)	br.cond.spnt.few HIDDEN_JUMPTARGET (fork);;
-	alloc r2=ar.pfs,0,0,2,0
-	mov out0=CLONE_VM+CLONE_VFORK+SIGCHLD
-	mov out1=0		/* Standard sp value.			*/
-	;;
-	DO_CALL (SYS_ify (clone))
-	cmp.eq p6,p0=-1,r10
-	;;
-(p6)	br.cond.spnt.few __syscall_error
-	ret
-PSEUDO_END(__vfork)
-libc_hidden_def (__vfork)
-
-weak_alias (__vfork, vfork)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/jmp-unwind.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/jmp-unwind.c
deleted file mode 100644
index 3e04f515f..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/jmp-unwind.c
+++ /dev/null
@@ -1,34 +0,0 @@
-/* _longjmp_unwind -- Clean up stack frames unwound by longjmp.
-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <setjmp.h>
-#include <stddef.h>
-#include <bits/libc-lock.h>
-
-#ifndef SHARED
-weak_extern (__pthread_cleanup_upto);
-#endif
-
-void
-_longjmp_unwind (jmp_buf env, int val)
-{
-  __libc_maybe_call2 (pthread_cleanup_upto,
-		      (env->__jmpbuf, __builtin_frame_address (0)),
-		      (void) 0);
-}
-libc_hidden_def(_longjmp_unwind)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/m68k/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/m68k/sysdep-cancel.h
deleted file mode 100644
index 54b99d688..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/m68k/sysdep-cancel.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Andreas Schwab <schwab@suse.de>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				      \
-  .text;								      \
-  ENTRY (name)								      \
-    SINGLE_THREAD_P;							      \
-    jne .Lpseudo_cancel;						      \
-    DO_CALL (syscall_name, args);					      \
-    cmp.l &-4095, %d0;							      \
-    jcc SYSCALL_ERROR_LABEL;						      \
-    rts;								      \
-  .Lpseudo_cancel:							      \
-    CENABLE;								      \
-    DOCARGS_##args							      \
-    move.l %d0, -(%sp);							      \
-    move.l &SYS_ify (syscall_name), %d0;				      \
-    trap &0;								      \
-    move.l %d0, %d2;							      \
-    CDISABLE;								      \
-    addq.l &4, %sp;							      \
-    move.l %d2, %d0;							      \
-    UNDOCARGS_##args							      \
-    cmp.l &-4095, %d0;							      \
-    jcc SYSCALL_ERROR_LABEL
-
-# define DOCARGS_0	move.l %d2, -(%sp);
-# define _DOCARGS_0(n)
-# define UNDOCARGS_0	move.l (%sp)+, %d2;
-
-# define DOCARGS_1	_DOCARGS_1 (4); DOCARGS_0
-# define _DOCARGS_1(n)	move.l n(%sp), %d1; _DOARGS_0 (n)
-# define UNDOCARGS_1	UNDOCARGS_0
-
-# define DOCARGS_2	_DOCARGS_2 (8)
-# define _DOCARGS_2(n)	move.l %d2, -(%sp); move.l n+4(%sp), %d2;	\
-			_DOCARGS_1 (n)
-# define UNDOCARGS_2	UNDOCARGS_1
-
-# define DOCARGS_3	_DOCARGS_3 (12)
-# define _DOCARGS_3(n)	move.l %d3, -(%sp); move.l n+4(%sp), %d3;	\
-  	 		_DOCARGS_2 (n)
-# define UNDOCARGS_3	UNDOCARGS_2; move.l (%sp)+, %d3;
-
-# define DOCARGS_4	_DOCARGS_4 (16)
-# define _DOCARGS_4(n)	move.l %d4, -(%sp); move.l n+4(%sp), %d4;	\
-			_DOCARGS_3 (n)
-# define UNDOCARGS_4	UNDOCARGS_3; move.l (%sp)+, %d4;
-
-# define DOCARGS_5	_DOCARGS_5 (20)
-# define _DOCARGS_5(n)	move.l %d5, -(%sp); move.l n+4(%sp), %d5;	\
-			_DOCARGS_4 (n)
-# define UNDOCARGS_5	UNDOCARGS_4; move.l (%sp)+, %d5;
-
-# ifdef IS_IN_libpthread
-#  ifdef __PIC__
-#   define CENABLE	jbsr __pthread_enable_asynccancel@PLTPC
-#   define CDISABLE	jbsr __pthread_disable_asynccancel@PLTPC
-#  else
-#   define CENABLE	jbsr __pthread_enable_asynccancel
-#   define CDISABLE	jbsr __pthread_disable_asynccancel
-#  endif
-# elif !defined NOT_IN_libc
-#  ifdef __PIC__
-#   define CENABLE	jbsr __libc_enable_asynccancel@PLTPC
-#   define CDISABLE	jbsr __libc_disable_asynccancel@PLTPC
-#  else
-#   define CENABLE	jbsr __libc_enable_asynccancel
-#   define CDISABLE	jbsr __libc_disable_asynccancel
-#  endif
-# else
-#  ifdef __PIC__
-#   define CENABLE	jbsr __librt_enable_asynccancel@PLTPC
-#   define CDISABLE	jbsr __librt_disable_asynccancel@PLTPC
-#  else
-#   define CENABLE	jbsr __librt_enable_asynccancel
-#   define CDISABLE	jbsr __librt_disable_asynccancel
-#  endif
-# endif
-
-# if !defined NOT_IN_libc
-#  define __local_multiple_threads __libc_multiple_threads
-# elif defined IS_IN_libpthread
-#  define __local_multiple_threads __pthread_multiple_threads
-# else
-#  define __local_multiple_threads __librt_multiple_threads
-# endif
-
-# ifndef __ASSEMBLER__
-extern int __local_multiple_threads attribute_hidden;
-#  define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
-# else
-#  if !defined __PIC__
-#   define SINGLE_THREAD_P tst.l __local_multiple_threads
-#  else
-#   define SINGLE_THREAD_P tst.l (__local_multiple_threads, %pc)
-#  endif
-# endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/m68k/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/m68k/vfork.S
deleted file mode 100644
index 2a4d3862c..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/m68k/vfork.S
+++ /dev/null
@@ -1,83 +0,0 @@
-/* Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Andreas Schwab <schwab@gnu.org>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep-cancel.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-#include <bits/kernel-features.h>
-
-/* Clone the calling process, but without copying the whole address space.
-   The calling process is suspended until the new process exits or is
-   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
-   and the process ID of the new process to the old process.  */
-
-ENTRY (__vfork)
-
-#ifdef SHARED
-	tstl	(__libc_pthread_functions@GOTPC, %pc)
-#else
-	.weak	pthread_create
-	movel	#pthread_create, %d0
-#endif
-	jbne	HIDDEN_JUMPTARGET (fork)
-
-#ifdef __NR_vfork
-
-	/* Pop the return PC value into A0.  */
-	movel	%sp@+, %a0
-
-	/* Stuff the syscall number in D0 and trap into the kernel.  */
-	movel	#SYS_ify (vfork), %d0
-	trap	#0
-	tstl	%d0
-	jmi	.Lerror		/* Branch forward if it failed.  */
-
-	/* Jump to the return PC.  */
-	jmp	%a0@
-
-.Lerror:
-	/* Push back the return PC.  */
-	movel	%a0,%sp@-
-
-# ifdef __ASSUME_VFORK_SYSCALL
-#  ifndef __PIC__
-	jbra	SYSCALL_ERROR_LABEL
-#  endif
-# else
-	/* Check if vfork syscall is known at all.  */
-	movel	#-ENOSYS,%d1
-	cmpl	%d0,%d1
-	jne	SYSCALL_ERROR_LABEL
-
-# endif
-#endif
-
-#ifndef __ASSUME_VFORK_SYSCALL
-	/* If we don't have vfork, fork is close enough.  */
-
-	movel	#SYS_ify (fork), %d0
-	trap	#0
-	tstl	%d0
-	jmi	SYSCALL_ERROR_LABEL
-	rts
-#endif
-
-PSEUDO_END (__vfork)
-libc_hidden_def (__vfork)
-
-weak_alias (__vfork, vfork)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mips/mips64/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mips/mips64/sysdep-cancel.h
deleted file mode 100644
index 10c82a61c..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mips/mips64/sysdep-cancel.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/* system call stubs with cancellation handling.  Linux/MIPS version.
-   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Chris Demetriou of Broadcom Corporation,
-   based on work by Guido Guenther <agx@sigxcpu.org>.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-#include <sys/asm.h>
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-
-#ifdef __PIC__
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				      \
-  .align 2;								      \
-  99: move a0, v0; 							      \
-  PTR_LA t9,__syscall_error;					 	      \
-  /* manual cpreturn.  */						      \
-  REG_L gp, STKOFF_GP(sp);						      \
-  RESTORESTK ;								      \
-  jr t9;								      \
-  ENTRY (name)								      \
-    SAVESTK ;								      \
-    .cpsetup t9, STKOFF_GP, name ;					      \
-    .set reorder;							      \
-    SINGLE_THREAD_P(t0);						      \
-    bne zero, t0, L(pseudo_cancel);					      \
-    .set noreorder;							      \
-    li v0, SYS_ify(syscall_name);					      \
-    syscall;								      \
-    .set reorder;							      \
-    bne a3, zero, SYSCALL_ERROR_LABEL;			       		      \
-    /* manual cpreturn.  */						      \
-    REG_L gp, STKOFF_GP(sp);						      \
-    RESTORESTK ;							      \
-    ret;								      \
-  L(pseudo_cancel):							      \
-    REG_S ra, STKOFF_RA(sp);						      \
-    PUSHARGS_##args;			/* save syscall args */	      	      \
-    CENABLE;								      \
-    REG_S v0, STKOFF_SVMSK(sp);		/* save mask */			      \
-    POPARGS_##args;			/* restore syscall args */	      \
-    .set noreorder;							      \
-    li v0, SYS_ify (syscall_name);				      	      \
-    syscall;								      \
-    .set reorder;							      \
-    REG_S v0, STKOFF_SC_V0(sp);		/* save syscall result */             \
-    REG_S a3, STKOFF_SC_ERR(sp);	/* save syscall error flag */	      \
-    REG_L a0, STKOFF_SVMSK(sp);		/* pass mask as arg1 */		      \
-    CDISABLE;								      \
-    REG_L a3, STKOFF_SC_ERR(sp);	/* restore syscall error flag */      \
-    REG_L ra, STKOFF_RA(sp);		/* restore return address */	      \
-    REG_L v0, STKOFF_SC_V0(sp);		/* restore syscall result */          \
-    bne a3, zero, SYSCALL_ERROR_LABEL;					      \
-    /* manual cpreturn.  */						      \
-    REG_L gp, STKOFF_GP(sp);						      \
-    RESTORESTK ;							      \
-  L(pseudo_end):
-#endif
-
-# define PUSHARGS_0	/* nothing to do */
-# define PUSHARGS_1	PUSHARGS_0 REG_S a0, STKOFF_A0(sp);
-# define PUSHARGS_2	PUSHARGS_1 REG_S a1, STKOFF_A1(sp);
-# define PUSHARGS_3	PUSHARGS_2 REG_S a2, STKOFF_A2(sp);
-# define PUSHARGS_4	PUSHARGS_3 REG_S a3, STKOFF_A3(sp);
-# define PUSHARGS_5	PUSHARGS_4 REG_S a4, STKOFF_A4(sp);
-# define PUSHARGS_6	PUSHARGS_5 REG_S a5, STKOFF_A5(sp);
-
-# define POPARGS_0	/* nothing to do */
-# define POPARGS_1	POPARGS_0 REG_L a0, STKOFF_A0(sp);
-# define POPARGS_2	POPARGS_1 REG_L a1, STKOFF_A1(sp);
-# define POPARGS_3	POPARGS_2 REG_L a2, STKOFF_A2(sp);
-# define POPARGS_4	POPARGS_3 REG_L a3, STKOFF_A3(sp);
-# define POPARGS_5	POPARGS_4 REG_L a4, STKOFF_A4(sp);
-# define POPARGS_6	POPARGS_5 REG_L a5, STKOFF_A5(sp);
-
-/* Save an even number of slots.  Should be 0 if an even number of slots
-   are used below, or SZREG if an odd number are used.  */
-# define STK_PAD	SZREG
-
-/* Place values that we are more likely to use later in this sequence, i.e.
-   closer to the SP at function entry.  If you do that, the are more
-   likely to already be in your d-cache.  */
-# define STKOFF_A5	(STK_PAD)
-# define STKOFF_A4	(STKOFF_A5 + SZREG)
-# define STKOFF_A3	(STKOFF_A4 + SZREG)
-# define STKOFF_A2	(STKOFF_A3 + SZREG)	/* MT and more args.  */
-# define STKOFF_A1	(STKOFF_A2 + SZREG)	/* MT and 2 args.  */
-# define STKOFF_A0	(STKOFF_A1 + SZREG)	/* MT and 1 arg.  */
-# define STKOFF_RA	(STKOFF_A0 + SZREG)	/* Used if MT.  */
-# define STKOFF_SC_V0	(STKOFF_RA + SZREG)	/* Used if MT.  */
-# define STKOFF_SC_ERR	(STKOFF_SC_V0 + SZREG)	/* Used if MT.  */
-# define STKOFF_SVMSK	(STKOFF_SC_ERR + SZREG)	/* Used if MT.  */
-# define STKOFF_GP	(STKOFF_SVMSK + SZREG)	/* Always used.  */
-
-# define STKSPACE	(STKOFF_GP + SZREG)
-# define SAVESTK 	PTR_SUBU sp, STKSPACE
-# define RESTORESTK 	PTR_ADDU sp, STKSPACE
-
-# ifdef IS_IN_libpthread
-#  define CENABLE	PTR_LA t9, __pthread_enable_asynccancel; jalr t9;
-#  define CDISABLE	PTR_LA t9, __pthread_disable_asynccancel; jalr t9;
-#  define __local_multiple_threads __pthread_multiple_threads
-# elif defined IS_IN_librt
-#  define CENABLE	PTR_LA t9, __librt_enable_asynccancel; jalr t9;
-#  define CDISABLE	PTR_LA t9, __librt_disable_asynccancel; jalr t9;
-#  define __local_multiple_threads __librt_multiple_threads
-# else
-#  define CENABLE	PTR_LA t9, __libc_enable_asynccancel; jalr t9;
-#  define CDISABLE	PTR_LA t9, __libc_disable_asynccancel; jalr t9;
-#  define __local_multiple_threads __libc_multiple_threads
-# endif
-
-# ifndef __ASSEMBLER__
-extern int __local_multiple_threads attribute_hidden;
-#  define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
-# else
-#  define SINGLE_THREAD_P(reg) lw reg, __local_multiple_threads
-#endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mips/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mips/sysdep-cancel.h
deleted file mode 100644
index 4e6dec775..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mips/sysdep-cancel.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Guido Guenther <agx@sigxcpu.org>, 2003.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-
-#ifdef __PIC__
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				      \
-  .align 2;								      \
-  99: move a0, v0; 							      \
-  la t9,__syscall_error;						      \
-  jr t9;								      \
-  ENTRY (name)								      \
-    .set noreorder;							      \
-    .cpload t9;								      \
-    .set reorder;							      \
-    SINGLE_THREAD_P(t0);						      \
-    bne zero, t0, L(pseudo_cancel);					      \
-    .set noreorder;							      \
-    li v0, SYS_ify(syscall_name);					      \
-    syscall;								      \
-    .set reorder;							      \
-    bne a3, zero, SYSCALL_ERROR_LABEL;			       		      \
-    ret;								      \
-  L(pseudo_cancel):							      \
-    SAVESTK_##args;						              \
-    sw ra, 28(sp);							      \
-    sw gp, 32(sp);							      \
-    PUSHARGS_##args;			/* save syscall args */	      	      \
-    CENABLE;								      \
-    lw gp, 32(sp);							      \
-    sw v0, 44(sp);			/* save mask */			      \
-    POPARGS_##args;			/* restore syscall args */	      \
-    .set noreorder;							      \
-    li v0, SYS_ify (syscall_name);				      	      \
-    syscall;								      \
-    .set reorder;							      \
-    sw v0, 36(sp);			/* save syscall result */             \
-    sw a3, 40(sp);			/* save syscall error flag */	      \
-    lw a0, 44(sp);			/* pass mask as arg1 */		      \
-    CDISABLE;								      \
-    lw gp, 32(sp);							      \
-    lw v0, 36(sp);			/* restore syscall result */          \
-    lw a3, 40(sp);			/* restore syscall error flag */      \
-    lw ra, 28(sp);			/* restore return address */	      \
-    RESTORESTK;							              \
-    bne a3, zero, SYSCALL_ERROR_LABEL;					      \
-  L(pseudo_end):
-#endif
-
-# define PUSHARGS_0	/* nothing to do */
-# define PUSHARGS_1	PUSHARGS_0 sw a0, 0(sp);
-# define PUSHARGS_2	PUSHARGS_1 sw a1, 4(sp);
-# define PUSHARGS_3	PUSHARGS_2 sw a2, 8(sp);
-# define PUSHARGS_4	PUSHARGS_3 sw a3, 12(sp);
-# define PUSHARGS_5	PUSHARGS_4 /* handeld by SAVESTK_## */
-# define PUSHARGS_6	PUSHARGS_5
-# define PUSHARGS_7	PUSHARGS_6
-
-# define POPARGS_0	/* nothing to do */
-# define POPARGS_1	POPARGS_0 lw a0, 0(sp);
-# define POPARGS_2	POPARGS_1 lw a1, 4(sp);
-# define POPARGS_3	POPARGS_2 lw a2, 8(sp);
-# define POPARGS_4	POPARGS_3 lw a3, 12(sp);
-# define POPARGS_5	POPARGS_4 /* args already in new stackframe */
-# define POPARGS_6	POPARGS_5
-# define POPARGS_7	POPARGS_6
-
-
-# define STKSPACE	48
-# define SAVESTK_0 	subu sp, STKSPACE
-# define SAVESTK_1      SAVESTK_0
-# define SAVESTK_2      SAVESTK_1
-# define SAVESTK_3      SAVESTK_2
-# define SAVESTK_4      SAVESTK_3
-# define SAVESTK_5      lw t0, 16(sp);		\
-			subu sp, STKSPACE;	\
-			sw t0, 16(sp)
-
-# define SAVESTK_6      lw t0, 16(sp);		\
-			lw t1, 20(sp);		\
-			subu sp, STKSPACE;	\
-			sw t0, 16(sp);		\
-			sw t1, 20(sp)
-
-# define SAVESTK_7      lw t0, 16(sp);		\
-			lw t1, 20(sp);		\
-			lw t2, 24(sp);		\
-			subu sp, STKSPACE;	\
-			sw t0, 16(sp);		\
-			sw t1, 20(sp);		\
-			sw t2, 24(sp)
-
-# define RESTORESTK 	addu sp, STKSPACE
-
-
-# ifdef IS_IN_libpthread
-#  define CENABLE	la t9, __pthread_enable_asynccancel; jalr t9;
-#  define CDISABLE	la t9, __pthread_disable_asynccancel; jalr t9;
-#  define __local_multiple_threads __pthread_multiple_threads
-# elif defined IS_IN_librt
-#  define CENABLE	la t9, __librt_enable_asynccancel; jalr t9;
-#  define CDISABLE	la t9, __librt_disable_asynccancel; jalr t9;
-#  define __local_multiple_threads __librt_multiple_threads
-# else
-#  define CENABLE	la t9, __libc_enable_asynccancel; jalr t9;
-#  define CDISABLE	la t9, __libc_disable_asynccancel; jalr t9;
-#  define __local_multiple_threads __libc_multiple_threads
-# endif
-
-# ifndef __ASSEMBLER__
-extern int __local_multiple_threads attribute_hidden;
-#  define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
-# else
-#  define SINGLE_THREAD_P(reg) lw reg, __local_multiple_threads
-#endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mips/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mips/vfork.S
deleted file mode 100644
index 09dcfa683..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mips/vfork.S
+++ /dev/null
@@ -1,104 +0,0 @@
-/* Copyright (C) 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-/* vfork() is just a special case of clone().  */
-
-#include <sys/asm.h>
-#include <sysdep.h>
-#include <asm/unistd.h>
-
-/* int vfork() */
-
-	.text
-LOCALSZ= 1
-FRAMESZ= (((NARGSAVE+LOCALSZ)*SZREG)+ALSZ)&ALMASK
-GPOFF= FRAMESZ-(1*SZREG)
-NESTED(__vfork,FRAMESZ,sp)
-#ifdef __PIC__
-	SETUP_GP
-#endif
-	PTR_SUBU sp, FRAMESZ
-	SETUP_GP64 (a5, __vfork)
-#ifdef __PIC__
-	SAVE_GP (GPOFF)
-#endif
-#ifdef PROF
-# if (_MIPS_SIM != _ABIO32)
-	PTR_S		a5, GPOFF(sp)
-# endif
-	.set		noat
-	move		$1, ra
-# if (_MIPS_SIM == _ABIO32)
-	subu		sp,sp,8
-# endif
-	jal		_mcount
-	.set		at
-# if (_MIPS_SIM != _ABIO32)
-	PTR_L		a5, GPOFF(sp)
-# endif
-#endif
-
-	/* If libpthread is loaded, we need to call fork instead.  */
-#ifdef SHARED
-	PTR_L		a0, __libc_pthread_functions
-#else
-	.weak		pthread_create
-	PTR_LA		a0, pthread_create
-#endif
-
-	PTR_ADDU	sp, FRAMESZ
-
-	bnez		a0, L(call_fork)
-
-	li		a0, 0x4112	/* CLONE_VM | CLONE_VFORK | SIGCHLD */
-	move		a1, sp
-
-	/* Do the system call */
-	li		v0,__NR_clone
-	syscall
-
-	bnez		a3,L(error)
-
-	/* Successful return from the parent or child.  */
-	RESTORE_GP64
-	ret
-
-	/* Something bad happened -- no child created.  */
-L(error):
-	move		a0, v0
-#ifdef __PIC__
-	PTR_LA		t9, __syscall_error
-	RESTORE_GP64
-	jr		t9
-#else
-	RESTORE_GP64
-	j		__syscall_error
-#endif
-
-L(call_fork):
-#ifdef __PIC__
-	PTR_LA		t9, fork
-	RESTORE_GP64
-	jr		t9
-#else
-	RESTORE_GP64
-	j		fork
-#endif
-	END(__vfork)
-
-libc_hidden_def(__vfork)
-weak_alias (__vfork, vfork)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mq_notify.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mq_notify.c
deleted file mode 100644
index 13daefee6..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/mq_notify.c
+++ /dev/null
@@ -1,284 +0,0 @@
-/* Copyright (C) 2004, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contribute by Ulrich Drepper <drepper@redhat.com>, 2004.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <assert.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <mqueue.h>
-#include <pthread.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sysdep.h>
-#include <unistd.h>
-#include <sys/socket.h>
-#include <not-cancel.h>
-
-
-#ifdef __NR_mq_notify
-
-/* Defined in the kernel headers: */
-#define NOTIFY_COOKIE_LEN	32	/* Length of the cookie used.  */
-#define NOTIFY_WOKENUP		1	/* Code for notifcation.  */
-#define NOTIFY_REMOVED		2	/* Code for closed message queue
-					   of de-notifcation.  */
-
-
-/* Data structure for the queued notification requests.  */
-union notify_data
-{
-  struct
-  {
-    void (*fct) (union sigval);	/* The function to run.  */
-    union sigval param;		/* The parameter to pass.  */
-    pthread_attr_t *attr;	/* Attributes to create the thread with.  */
-    /* NB: on 64-bit machines the struct as a size of 24 bytes.  Which means
-       byte 31 can still be used for returning the status.  */
-  };
-  char raw[NOTIFY_COOKIE_LEN];
-};
-
-
-/* Keep track of the initialization.  */
-static pthread_once_t once = PTHREAD_ONCE_INIT;
-
-
-/* The netlink socket.  */
-static int netlink_socket = -1;
-
-
-/* Barrier used to make sure data passed to the new thread is not
-   resused by the parent.  */
-static pthread_barrier_t notify_barrier;
-
-
-/* Modify the signal mask.  We move this into a separate function so
-   that the stack space needed for sigset_t is not deducted from what
-   the thread can use.  */
-static int
-__attribute__ ((noinline))
-change_sigmask (int how, sigset_t *oss)
-{
-  sigset_t ss;
-  __sigfillset (&ss);
-  return pthread_sigmask (how, &ss, oss);
-}
-
-
-/* The function used for the notification.  */
-static void *
-notification_function (void *arg)
-{
-  /* Copy the function and parameter so that the parent thread can go
-     on with its life.  */
-  __volatile__ union notify_data *data = (__volatile__ union notify_data *) arg;
-  void (*fct) (union sigval) = data->fct;
-  union sigval param = data->param;
-
-  /* Let the parent go.  */
-  (void) pthread_barrier_wait (&notify_barrier);
-
-  /* Make the thread detached.  */
-  (void) pthread_detach (pthread_self ());
-
-  /* The parent thread has all signals blocked.  This is probably a
-     bit surprising for this thread.  So we unblock all of them.  */
-  (void) change_sigmask (SIG_UNBLOCK, NULL);
-
-  /* Now run the user code.  */
-  fct (param);
-
-  /* And we are done.  */
-  return NULL;
-}
-
-
-/* Helper thread.  */
-static void *
-helper_thread (void *arg)
-{
-  while (1)
-    {
-      union notify_data data;
-
-      ssize_t n = recv (netlink_socket, &data, sizeof (data),
-			MSG_NOSIGNAL | MSG_WAITALL);
-      if (n < NOTIFY_COOKIE_LEN)
-	continue;
-
-      if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_WOKENUP)
-	{
-	  /* Just create the thread as instructed.  There is no way to
-	     report a problem with creating a thread.  */
-	  pthread_t th;
-	  if (__builtin_expect (pthread_create (&th, data.attr,
-						notification_function, &data)
-				== 0, 0))
-	    /* Since we passed a pointer to DATA to the new thread we have
-	       to wait until it is done with it.  */
-	    (void) pthread_barrier_wait (&notify_barrier);
-	}
-      else if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_REMOVED)
-	/* The only state we keep is the copy of the thread attributes.  */
-	free (data.attr);
-    }
-  return NULL;
-}
-
-
-static void
-reset_once (void)
-{
-  once = PTHREAD_ONCE_INIT;
-}
-
-
-static void
-init_mq_netlink (void)
-{
-  /* This code might be called a second time after fork().  The file
-     descriptor is inherited from the parent.  */
-  if (netlink_socket == -1)
-    {
-      /* Just a normal netlink socket, not bound.  */
-      netlink_socket = socket (AF_NETLINK, SOCK_RAW, 0);
-      /* No need to do more if we have no socket.  */
-      if (netlink_socket == -1)
-	return;
-
-      /* Make sure the descriptor is closed on exec.  */
-      fcntl (netlink_socket, F_SETFD, FD_CLOEXEC);
-    }
-
-  int err = 1;
-
-  /* Initialize the barrier.  */
-  if (__builtin_expect (pthread_barrier_init (&notify_barrier, NULL, 2) == 0,
-			0))
-    {
-      /* Create the helper thread.  */
-      pthread_attr_t attr;
-      (void) pthread_attr_init (&attr);
-      (void) pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
-      /* We do not need much stack space, the bare minimum will be enough.  */
-      (void) pthread_attr_setstacksize (&attr, PTHREAD_STACK_MIN);
-
-      /* Temporarily block all signals so that the newly created
-	 thread inherits the mask.  */
-      sigset_t oss;
-      int have_no_oss = change_sigmask (SIG_BLOCK, &oss);
-
-      pthread_t th;
-      err = pthread_create (&th, &attr, helper_thread, NULL);
-
-      /* Reset the signal mask.  */
-      if (!have_no_oss)
-	pthread_sigmask (SIG_SETMASK, &oss, NULL);
-
-      (void) pthread_attr_destroy (&attr);
-
-      if (err == 0)
-	{
-	  static smallint added_atfork;
-
-	  if (added_atfork == 0
-	      && pthread_atfork (NULL, NULL, reset_once) != 0)
-	    {
-	      /* The child thread will call recv() which is a
-		 cancellation point.  */
-	      (void) pthread_cancel (th);
-	      err = 1;
-	    }
-	  else
-	    added_atfork = 1;
-	}
-    }
-
-  if (err != 0)
-    {
-      close_not_cancel_no_status (netlink_socket);
-      netlink_socket = -1;
-    }
-}
-
-
-/* Register notification upon message arrival to an empty message queue
-   MQDES.  */
-int
-mq_notify (mqd_t mqdes, const struct sigevent *notification)
-{
-  /* Make sure the type is correctly defined.  */
-  assert (sizeof (union notify_data) == NOTIFY_COOKIE_LEN);
-
-  /* Special treatment needed for SIGEV_THREAD.  */
-  if (notification == NULL || notification->sigev_notify != SIGEV_THREAD)
-    return INLINE_SYSCALL (mq_notify, 2, mqdes, notification);
-
-  /* The kernel cannot directly start threads.  This will have to be
-     done at userlevel.  Since we cannot start threads from signal
-     handlers we have to create a dedicated thread which waits for
-     notifications for arriving messages and creates threads in
-     response.  */
-
-  /* Initialize only once.  */
-  pthread_once (&once, init_mq_netlink);
-
-  /* If we cannot create the netlink socket we cannot provide
-     SIGEV_THREAD support.  */
-  if (__builtin_expect (netlink_socket == -1, 0))
-    {
-      __set_errno (ENOSYS);
-      return -1;
-    }
-
-  /* Create the cookie.  It will hold almost all the state.  */
-  union notify_data data;
-  memset (&data, '\0', sizeof (data));
-  data.fct = notification->sigev_notify_function;
-  data.param = notification->sigev_value;
-
-  if (notification->sigev_notify_attributes != NULL)
-    {
-      /* The thread attribute has to be allocated separately.  */
-      data.attr = (pthread_attr_t *) malloc (sizeof (pthread_attr_t));
-      if (data.attr == NULL)
-	return -1;
-
-      memcpy (data.attr, notification->sigev_notify_attributes,
-	      sizeof (pthread_attr_t));
-    }
-
-  /* Construct the new request.  */
-  struct sigevent se;
-  se.sigev_notify = SIGEV_THREAD;
-  se.sigev_signo = netlink_socket;
-  se.sigev_value.sival_ptr = &data;
-
-  /* Tell the kernel.  */
-  int retval = INLINE_SYSCALL (mq_notify, 2, mqdes, &se);
-
-  /* If it failed, free the allocated memory.  */
-  if (__builtin_expect (retval != 0, 0))
-    free (data.attr);
-
-  return retval;
-}
-
-#else
-# include <rt/mq_notify.c>
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc32/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc32/sysdep-cancel.h
deleted file mode 100644
index 6c3dc12a0..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc32/sysdep-cancel.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/* Copyright (C) 2003, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Franz Sirl <Franz.Sirl-kernel@lauterbach.com>, 2003.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <tls.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				\
-  .section ".text";							\
-  ENTRY (name)								\
-    SINGLE_THREAD_P;							\
-    bne- .Lpseudo_cancel;						\
-    DO_CALL (SYS_ify (syscall_name));					\
-    PSEUDO_RET;								\
-  .Lpseudo_cancel:							\
-    stwu 1,-48(1);							\
-    mflr 9;								\
-    stw 9,52(1);							\
-    CGOTSETUP;								\
-    DOCARGS_##args;	/* save syscall args around CENABLE.  */	\
-    CENABLE;								\
-    stw 3,16(1);	/* store CENABLE return value (MASK).  */	\
-    UNDOCARGS_##args;	/* restore syscall args.  */			\
-    DO_CALL (SYS_ify (syscall_name));					\
-    mfcr 0;		/* save CR/R3 around CDISABLE.  */		\
-    stw 3,8(1);								\
-    stw 0,12(1);							\
-    lwz 3,16(1);	/* pass MASK to CDISABLE.  */			\
-    CDISABLE;								\
-    lwz 4,52(1);							\
-    lwz 0,12(1);	/* restore CR/R3. */				\
-    lwz 3,8(1);								\
-    CGOTRESTORE;							\
-    mtlr 4;								\
-    mtcr 0;								\
-    addi 1,1,48;
-
-# define DOCARGS_0
-# define UNDOCARGS_0
-
-# define DOCARGS_1	stw 3,20(1); DOCARGS_0
-# define UNDOCARGS_1	lwz 3,20(1); UNDOCARGS_0
-
-# define DOCARGS_2	stw 4,24(1); DOCARGS_1
-# define UNDOCARGS_2	lwz 4,24(1); UNDOCARGS_1
-
-# define DOCARGS_3	stw 5,28(1); DOCARGS_2
-# define UNDOCARGS_3	lwz 5,28(1); UNDOCARGS_2
-
-# define DOCARGS_4	stw 6,32(1); DOCARGS_3
-# define UNDOCARGS_4	lwz 6,32(1); UNDOCARGS_3
-
-# define DOCARGS_5	stw 7,36(1); DOCARGS_4
-# define UNDOCARGS_5	lwz 7,36(1); UNDOCARGS_4
-
-# define DOCARGS_6	stw 8,40(1); DOCARGS_5
-# define UNDOCARGS_6	lwz 8,40(1); UNDOCARGS_5
-
-# define CGOTSETUP
-# define CGOTRESTORE
-
-# ifdef IS_IN_libpthread
-#  define CENABLE	bl __pthread_enable_asynccancel@local
-#  define CDISABLE	bl __pthread_disable_asynccancel@local
-# elif !defined NOT_IN_libc
-#  define CENABLE	bl __libc_enable_asynccancel@local
-#  define CDISABLE	bl __libc_disable_asynccancel@local
-# else
-#  define CENABLE	bl JUMPTARGET(__librt_enable_asynccancel)
-#  define CDISABLE	bl JUMPTARGET(__librt_disable_asynccancel)
-#  if defined HAVE_AS_REL16 && defined __PIC__
-#   undef CGOTSETUP
-#   define CGOTSETUP							\
-    bcl 20,31,1f;							\
- 1: stw 30,44(1);							\
-    mflr 30;								\
-    addis 30,30,_GLOBAL_OFFSET_TABLE-1b@ha;				\
-    addi 30,30,_GLOBAL_OFFSET_TABLE-1b@l
-#   undef CGOTRESTORE
-#   define CGOTRESTORE							\
-    lwz 30,44(1)
-#  endif
-# endif
-
-# ifdef HAVE_TLS_SUPPORT
-#  ifndef __ASSEMBLER__
-#   define SINGLE_THREAD_P						\
-  __builtin_expect (THREAD_GETMEM (THREAD_SELF, p_multiple_threads) == 0, 1)
-#  else
-#   define SINGLE_THREAD_P						\
-  lwz 10,MULTIPLE_THREADS_OFFSET(2);					\
-  cmpwi 10,0
-#  endif
-# else
-#  if !defined NOT_IN_libc
-#   define __local_multiple_threads __libc_multiple_threads
-#  else
-#   define __local_multiple_threads __librt_multiple_threads
-#  endif
-#  ifndef __ASSEMBLER__
-extern int __local_multiple_threads attribute_hidden;
-#   define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
-#  else
-#   if !defined __PIC__
-#    define SINGLE_THREAD_P						\
-  lis 10,__local_multiple_threads@ha;					\
-  lwz 10,__local_multiple_threads@l(10);				\
-  cmpwi 10,0
-#   else
-#    ifdef HAVE_ASM_PPC_REL16
-#     define SINGLE_THREAD_P						\
-  mflr 9;								\
-  bcl 20,31,1f;								\
-1:mflr 10;								\
-  addis 10,10,__local_multiple_threads-1b@ha;				\
-  lwz 10,__local_multiple_threads-1b@l(10);				\
-  mtlr 9;								\
-  cmpwi 10,0
-#    else
-#     define SINGLE_THREAD_P						\
-  mflr 9;								\
-  bl _GLOBAL_OFFSET_TABLE_@local-4;					\
-  mflr 10;								\
-  mtlr 9;								\
-  lwz 10,__local_multiple_threads@got(10);				\
-  lwz 10,0(10);								\
-  cmpwi 10,0
-#    endif
-#   endif
-#  endif
-# endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc32/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc32/vfork.S
deleted file mode 100644
index 4b16829be..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc32/vfork.S
+++ /dev/null
@@ -1,85 +0,0 @@
-/* Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep-cancel.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-#include <bits/kernel-features.h>
-
-/* Clone the calling process, but without copying the whole address space.
-   The calling process is suspended until the new process exits or is
-   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
-   and the process ID of the new process to the old process.  */
-
-ENTRY (__vfork)
-
-#ifdef __NR_vfork
-# ifdef SHARED
-	mflr	9
-#  ifdef HAVE_ASM_PPC_REL16
-	bcl	20,31,1f
-1:	mflr	10
-	addis	10,10,__libc_pthread_functions-1b@ha
-	lwz	10,__libc_pthread_functions-1b@l(10)
-	mtlr	9
-#  else
-	bl	_GLOBAL_OFFSET_TABLE_@local-4
-	mflr	10
-	mtlr	9
-	lwz	10,__libc_pthread_functions@got(10)
-	lwz	10,0(10)
-#  endif
-# else
-	.weak	pthread_create
-	lis	10,pthread_create@ha
-	la	10,pthread_create@l(10)
-# endif
-
-	cmpwi	10,0
-	bne-	.Lhidden_fork
-
-	DO_CALL (SYS_ify (vfork));
-
-# ifdef __ASSUME_VFORK_SYSCALL
-	PSEUDO_RET
-# else
-	bnslr+
-	/* Check if vfork syscall is known at all.  */
-	cmpwi	r3,ENOSYS
-	bne-	.Lsyscall_error
-
-# endif
-
-.Lhidden_fork:
-	b	HIDDEN_JUMPTARGET(fork)
-
-#endif
-
-#ifndef __ASSUME_VFORK_SYSCALL
-	/* If we don't have vfork, fork is close enough.  */
-
-	DO_CALL (SYS_ify (fork));
-	bnslr+
-
-.Lsyscall_error:
-	b	__syscall_error@local
-#endif
-
-PSEUDO_END (__vfork)
-libc_hidden_def (__vfork)
-
-weak_alias (__vfork, vfork)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc64/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc64/sysdep-cancel.h
deleted file mode 100644
index 901982ec8..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc64/sysdep-cancel.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/* Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Franz Sirl <Franz.Sirl-kernel@lauterbach.com>, 2003.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <tls.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				\
-  .section ".text";							\
-  ENTRY (name)								\
-    SINGLE_THREAD_P;							\
-    bne- .Lpseudo_cancel;						\
-    DO_CALL (SYS_ify (syscall_name));					\
-    PSEUDO_RET;								\
-  .Lpseudo_cancel:							\
-    stdu 1,-128(1);							\
-    mflr 9;								\
-    std  9,128+16(1);							\
-    DOCARGS_##args;	/* save syscall args around CENABLE.  */	\
-    CENABLE;								\
-    std  3,72(1);	/* store CENABLE return value (MASK).  */	\
-    UNDOCARGS_##args;	/* restore syscall args.  */			\
-    DO_CALL (SYS_ify (syscall_name));					\
-    mfcr 0;		/* save CR/R3 around CDISABLE.  */		\
-    std  3,64(1);								\
-    std  0,8(1);							\
-    ld   3,72(1);	/* pass MASK to CDISABLE.  */			\
-    CDISABLE;								\
-    ld   9,128+16(1);							\
-    ld   0,8(1);	/* restore CR/R3. */				\
-    ld   3,64(1);								\
-    mtlr 9;								\
-    mtcr 0;								\
-    addi 1,1,128;
-
-# define DOCARGS_0
-# define UNDOCARGS_0
-
-# define DOCARGS_1	std 3,80(1); DOCARGS_0
-# define UNDOCARGS_1	ld 3,80(1); UNDOCARGS_0
-
-# define DOCARGS_2	std 4,88(1); DOCARGS_1
-# define UNDOCARGS_2	ld 4,88(1); UNDOCARGS_1
-
-# define DOCARGS_3	std 5,96(1); DOCARGS_2
-# define UNDOCARGS_3	ld 5,96(1); UNDOCARGS_2
-
-# define DOCARGS_4	std 6,104(1); DOCARGS_3
-# define UNDOCARGS_4	ld 6,104(1); UNDOCARGS_3
-
-# define DOCARGS_5	std 7,112(1); DOCARGS_4
-# define UNDOCARGS_5	ld 7,112(1); UNDOCARGS_4
-
-# define DOCARGS_6	std 8,120(1); DOCARGS_5
-# define UNDOCARGS_6	ld 8,120(1); UNDOCARGS_5
-
-# ifdef IS_IN_libpthread
-#  define CENABLE	bl JUMPTARGET(__pthread_enable_asynccancel)
-#  define CDISABLE	bl JUMPTARGET(__pthread_disable_asynccancel)
-#  define __local_multiple_threads __pthread_multiple_threads
-# elif !defined NOT_IN_libc
-#  define CENABLE	bl JUMPTARGET(__libc_enable_asynccancel)
-#  define CDISABLE	bl JUMPTARGET(__libc_disable_asynccancel)
-#  define __local_multiple_threads __libc_multiple_threads
-# else
-#  define CENABLE	bl JUMPTARGET(__librt_enable_asynccancel); nop
-#  define CDISABLE	bl JUMPTARGET(__librt_disable_asynccancel); nop
-#  define __local_multiple_threads __librt_multiple_threads
-# endif
-
-# ifdef HAVE_TLS_SUPPORT
-#  ifndef __ASSEMBLER__
-#   define SINGLE_THREAD_P						\
-  __builtin_expect (THREAD_GETMEM (THREAD_SELF, p_multiple_threads) == 0, 1)
-#  else
-#   define SINGLE_THREAD_P						\
-  lwz 10,MULTIPLE_THREADS_OFFSET(13);					\
-  cmpwi 10,0
-#  endif
-# else /* !HAVE_TLS_SUPPORT */
-#  ifndef __ASSEMBLER__
-extern int __local_multiple_threads
-#   if !defined NOT_IN_libc || defined IS_IN_libpthread
-  attribute_hidden;
-#   else
-  ;
-#   endif
-#   define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
-#  else
-#   define SINGLE_THREAD_P						\
-	.section	".toc","aw";					\
-.LC__local_multiple_threads:;						\
-	.tc __local_multiple_threads[TC],__local_multiple_threads;	\
-  .previous;								\
-  ld    10,.LC__local_multiple_threads@toc(2);				\
-  lwz   10,0(10);							\
-  cmpwi 10,0
-#  endif
-# endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc64/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc64/vfork.S
deleted file mode 100644
index 47c91dfd4..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/powerpc64/vfork.S
+++ /dev/null
@@ -1,90 +0,0 @@
-/* Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep-cancel.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-#include <bits/kernel-features.h>
-
-/* Clone the calling process, but without copying the whole address space.
-   The calling process is suspended until the new process exits or is
-   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
-   and the process ID of the new process to the old process.  */
-
-#ifdef SHARED
-	.section	".toc","aw"
-.LC0:
-	.tc __libc_pthread_functions[TC],__libc_pthread_functions
-	.section	".text"
-	.align 2
-#endif
-
-ENTRY (__vfork)
-
-#ifdef __NR_vfork
-
-# ifdef SHARED
-  ld  10,.LC0@toc(2)
-  ld  10,0(10)
-  cmpwi  10,0
-  bne-  HIDDEN_JUMPTARGET(fork)
-# else
-  .weak  pthread_create
-	lis  10,pthread_create@highest
-	ori  10,10,pthread_create@higher
-  sldi 10,10,32
-  oris 10,10,pthread_create@h
-  ori  10,10,pthread_create@l
-  cmpwi  10,0
-  bne-  .Lhidden_fork
-# endif
-
-	DO_CALL (SYS_ify (vfork));
-
-# ifdef __ASSUME_VFORK_SYSCALL
-  PSEUDO_RET
-# else
-  bnslr+
-  /* Check if vfork syscall is known at all.  */
-  cmpdi	r3,ENOSYS
-# ifdef SHARED
-  bne	JUMPTARGET(__syscall_error)
-# else
-  bne-  .Lsyscall_error
-# endif
-
-# endif
-#endif
-
-#ifndef __ASSUME_VFORK_SYSCALL
-	/* If we don't have vfork, fork is close enough.  */
-
-	DO_CALL (SYS_ify (fork));
-	PSEUDO_RET
-#endif
-
-# ifndef SHARED
-.Lhidden_fork:
-	b	HIDDEN_JUMPTARGET(fork)
-.Lsyscall_error:
-	b	JUMPTARGET(__syscall_error)
-# endif
-
-PSEUDO_END (__vfork)
-libc_hidden_def (__vfork)
-
-weak_alias (__vfork, vfork)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/ptlongjmp.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/ptlongjmp.c
deleted file mode 100644
index 177256c7f..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/powerpc/ptlongjmp.c
+++ /dev/null
@@ -1,70 +0,0 @@
-/* Linuxthreads - a simple clone()-based implementation of Posix        */
-/* threads for Linux.                                                   */
-/* Copyright (C) 1998 Xavier Leroy (Xavier.Leroy@inria.fr)              */
-/*                                                                      */
-/* This program is free software; you can redistribute it and/or        */
-/* modify it under the terms of the GNU Library General Public License  */
-/* as published by the Free Software Foundation; either version 2       */
-/* of the License, or (at your option) any later version.               */
-/*                                                                      */
-/* This program is distributed in the hope that it will be useful,      */
-/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
-/* GNU Library General Public License for more details.                 */
-
-/* Redefine siglongjmp and longjmp so that they interact correctly
-   with cleanup handlers */
-/* Derived from linuxthreads/ptlongjmp.c & added AltiVec/VMX versioning. */
-#include "pthread.h"
-#include <setjmp.h>
-#include <bits/wordsize.h>
-#include <shlib-compat.h>
-#if defined SHARED
-# if SHLIB_COMPAT (libpthread, GLIBC_2_0, GLIBC_2_3_4)
-
-/* These functions are not declared anywhere since they shouldn't be
-   used at another place but here.  */
-extern void __novmx__libc_siglongjmp (sigjmp_buf env, int val)
-     __attribute__ ((noreturn));
-extern void __novmx__libc_longjmp (sigjmp_buf env, int val)
-     __attribute__ ((noreturn));
-
-
-void __novmx_siglongjmp (sigjmp_buf env, int val)
-{
-  __novmx__libc_siglongjmp (env, val);
-}
-
-void __novmx_longjmp (jmp_buf env, int val)
-{
-  __novmx__libc_longjmp (env, val);
-}
-
-#  if __WORDSIZE == 64
-symbol_version (__novmx_longjmp,longjmp,GLIBC_2.3);
-symbol_version (__novmx_siglongjmp,siglongjmp,GLIBC_2.3);
-#  else
-symbol_version (__novmx_longjmp,longjmp,GLIBC_2.0);
-symbol_version (__novmx_siglongjmp,siglongjmp,GLIBC_2.0);
-#  endif
-# endif  /* SHLIB_COMPAT (libpthread, GLIBC_2_0, GLIBC_2_3_4) ) */
-
-/* These functions are not declared anywhere since they shouldn't be
-   used at another place but here.  */
-extern void __vmx__libc_siglongjmp (sigjmp_buf env, int val)
-     __attribute__ ((noreturn));
-extern void __vmx__libc_longjmp (sigjmp_buf env, int val)
-     __attribute__ ((noreturn));
-
-void __vmx_siglongjmp (sigjmp_buf env, int val)
-{
-  __vmx__libc_siglongjmp (env, val);
-}
-
-void __vmx_longjmp (jmp_buf env, int val)
-{
-  __vmx__libc_longjmp (env, val);
-}
-default_symbol_version (__vmx_longjmp,longjmp,GLIBC_2.3.4);
-default_symbol_version (__vmx_siglongjmp,siglongjmp,GLIBC_2.3.4);
-#endif /* SHARED */
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/pt-sigsuspend.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/pt-sigsuspend.c
deleted file mode 100644
index 83f678c8b..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/pt-sigsuspend.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Internal sigsuspend system call for LinuxThreads.  Generic Linux version.
-   Copyright (C) 2003, 2006 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <signal.h>
-#include <unistd.h>
-
-#include <sys/syscall.h>
-#include <linuxthreads/internals.h>
-
-#include <bits/kernel-features.h>
-
-void
-__pthread_sigsuspend (const sigset_t *set)
-{
-  sigsuspend(set);
-}
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/raise.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/raise.c
deleted file mode 100644
index 1e11a4812..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/raise.c
+++ /dev/null
@@ -1,41 +0,0 @@
-/* Copyright (C) 1991, 1996, 2002, 2003, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <signal.h>
-#include <unistd.h>
-
-#ifndef IS_IN_rtld
-# include <bits/libc-lock.h>
-
-# ifndef SHARED
-weak_extern (__pthread_raise)
-# endif
-#endif
-
-/* Raise the signal SIG.  */
-int
-raise (sig)
-     int sig;
-{
-#ifdef IS_IN_rtld
-  return __kill (__getpid (), sig);
-#else
-  return __libc_maybe_call2 (pthread_raise, (sig),
-			     __kill (__getpid (), sig));
-#endif
-}
-libc_hidden_def (raise)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/register-atfork.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/register-atfork.c
deleted file mode 100644
index 338d421e3..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/register-atfork.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <stdlib.h>
-#include "fork.h"
-
-
-int
-__register_atfork (prepare, parent, child, dso_handle)
-     void (*prepare) (void);
-     void (*parent) (void);
-     void (*child) (void);
-     void *dso_handle;
-{
-  struct fork_handler *new_prepare = NULL;
-  struct fork_handler *new_parent = NULL;
-  struct fork_handler *new_child = NULL;
-
-  if (prepare != NULL)
-    {
-      new_prepare = (struct fork_handler *) malloc (sizeof (*new_prepare));
-      if (new_prepare == NULL)
-	goto out1;
-
-      new_prepare->handler = prepare;
-      new_prepare->dso_handle = dso_handle;
-    }
-
-  if (parent != NULL)
-    {
-      new_parent = (struct fork_handler *) malloc (sizeof (*new_parent));
-      if (new_parent == NULL)
-	goto out2;
-
-      new_parent->handler = parent;
-      new_parent->dso_handle = dso_handle;
-    }
-
-  if (child != NULL)
-    {
-      new_child = (struct fork_handler *) malloc (sizeof (*new_child));
-      if (new_child == NULL)
-	{
-	  free (new_parent);
-	out2:
-	  free (new_prepare);
-	out1:
-	  return errno;
-	}
-
-      new_child->handler = child;
-      new_child->dso_handle = dso_handle;
-    }
-
-  /* Get the lock to not conflict with running forks.  */
-  __libc_lock_lock (__fork_block.lock);
-
-  /* Now that we have all the handlers allocate enqueue them.  */
-  if (new_prepare != NULL)
-    list_add_tail (&new_prepare->list, &__fork_block.prepare_list);
-  if (new_parent != NULL)
-    list_add_tail (&new_parent->list, &__fork_block.parent_list);
-  if (new_child != NULL)
-    list_add_tail (&new_child->list, &__fork_block.child_list);
-
-  /* Release the lock.  */
-  __libc_lock_unlock (__fork_block.lock);
-
-  return 0;
-}
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/pt-initfini.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/pt-initfini.c
deleted file mode 100644
index 500fff091..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/pt-initfini.c
+++ /dev/null
@@ -1,142 +0,0 @@
-/* Special .init and .fini section support for SH. Linuxthread version.
-   Copyright (C) 2000, 2001, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   In addition to the permissions in the GNU Lesser General Public
-   License, the Free Software Foundation gives you unlimited
-   permission to link the compiled version of this file with other
-   programs, and to distribute those programs without any restriction
-   coming from the use of this file.  (The Lesser General Public
-   License restrictions do apply in other respects; for example, they
-   cover modification of the file, and distribution when not linked
-   into another program.)
-
-   The GNU C Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-/* This file is compiled into assembly code which is then munged by a sed
-   script into two files: crti.s and crtn.s.
-
-   * crti.s puts a function prologue at the beginning of the
-   .init and .fini sections and defines global symbols for
-   those addresses, so they can be called as functions.
-
-   * crtn.s puts the corresponding function epilogues
-   in the .init and .fini sections. */
-
-__asm__ ("\n\
-\n\
-#include \"defs.h\"\n\
-\n\
-/*@HEADER_ENDS*/\n\
-\n\
-/*@TESTS_BEGIN*/\n\
-\n\
-/*@TESTS_END*/\n\
-\n\
-/*@_init_PROLOG_BEGINS*/\n\
-	.section .init\n\
-	.align 5\n\
-	.global	_init\n\
-	.type	_init,@function\n\
-_init:\n\
-	mov.l	r12,@-r15\n\
-	mov.l	r14,@-r15\n\
-	sts.l	pr,@-r15\n\
-	mova	.L22,r0\n\
-	mov.l	.L22,r12\n\
-	add	r0,r12\n\
-	mova	.L24,r0\n\
-	mov.l	.L24,r1\n\
-	add	r0,r1\n\
-	jsr	@r1\n\
-	 nop\n\
-	mova	.L23,r0\n\
-	mov.l	.L23,r1\n\
-	add	r0,r1\n\
-	jsr	@r1\n\
-	 mov	r15,r14\n\
-	bra	1f\n\
-	 nop\n\
-	.align 2\n\
-.L22:\n\
-	.long	_GLOBAL_OFFSET_TABLE_\n\
-.L23:\n\
-	.long	__gmon_start__@PLT\n\
-.L24:\n\
-	.long	__pthread_initialize_minimal@PLT\n\
-1:\n\
-	ALIGN\n\
-	END_INIT\n\
-\n\
-/*@_init_PROLOG_ENDS*/\n\
-\n\
-/*@_init_EPILOG_BEGINS*/\n\
-	.section .init\n\
-	mov	r14,r15\n\
-	lds.l	@r15+,pr\n\
-	mov.l	@r15+,r14\n\
-	rts	\n\
-	mov.l	@r15+,r12\n\
-	END_INIT\n\
-	.section .text\n\
-	.align 5\n\
-	.weak	__gmon_start__\n\
-	.type	__gmon_start__,@function\n\
-__gmon_start__:\n\
-	mov.l	r14,@-r15\n\
-	mov	r15,r14\n\
-	mov	r14,r15\n\
-	rts	\n\
-	mov.l	@r15+,r14\n\
-	\n\
-/*@_init_EPILOG_ENDS*/\n\
-\n\
-/*@_fini_PROLOG_BEGINS*/\n\
-	.section .fini\n\
-	.align 5\n\
-	.global	_fini\n\
-	.type	_fini,@function\n\
-_fini:\n\
-	mov.l	r12,@-r15\n\
-	mov.l	r14,@-r15\n\
-	sts.l	pr,@-r15\n\
-	mova	.L27,r0\n\
-	mov.l	.L27,r12\n\
-	add	r0,r12\n\
-	mov	r15,r14\n\
-	ALIGN\n\
-	END_FINI\n\
-	bra	1f\n\
-	 nop\n\
-	.align	2\n\
-.L27:\n\
-	.long	_GLOBAL_OFFSET_TABLE_\n\
-1:\n\
-/*@_fini_PROLOG_ENDS*/\n\
-\n\
-/*@_fini_EPILOG_BEGINS*/\n\
-	.section .fini\n\
-	mov	r14,r15\n\
-	lds.l	@r15+,pr\n\
-	mov.l	@r15+,r14\n\
-	rts	\n\
-	mov.l	@r15+,r12\n\
-\n\
-	END_FINI\n\
-	\n\
-/*@_fini_EPILOG_ENDS*/\n\
-\n\
-/*@TRAILER_BEGINS*/\n\
-");
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/smp.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/smp.h
deleted file mode 100644
index 7d8ced7d7..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/smp.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/* Determine whether the host has multiple processors.  SH version.
-   Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-static __inline__ int
-is_smp_system (void)
-{
-  return 0;
-}
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/sysdep-cancel.h
deleted file mode 100644
index 58c726b20..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/sysdep-cancel.h
+++ /dev/null
@@ -1,226 +0,0 @@
-/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <tls.h>
-#include <pt-machine.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-
-# define _IMM12 #-12
-# define _IMM16 #-16
-# define _IMP16 #16
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args) \
-  .text; \
-  ENTRY (name); \
-    SINGLE_THREAD_P; \
-    bf .Lpseudo_cancel; \
-    DO_CALL (syscall_name, args); \
-    mov r0,r1; \
-    mov _IMM12,r2; \
-    shad r2,r1; \
-    not r1,r1; \
-    tst r1,r1; \
-    bt .Lsyscall_error; \
-    bra .Lpseudo_end; \
-     nop; \
- .Lpseudo_cancel: \
-    sts.l pr,@-r15; \
-    add _IMM16,r15; \
-    SAVE_ARGS_##args; \
-    CENABLE; \
-    LOAD_ARGS_##args; \
-    add _IMP16,r15; \
-    lds.l @r15+,pr; \
-    DO_CALL(syscall_name, args); \
-    SYSCALL_INST_PAD; \
-    sts.l pr,@-r15; \
-    mov.l r0,@-r15; \
-    CDISABLE; \
-    mov.l @r15+,r0; \
-    lds.l @r15+,pr; \
-    mov r0,r1; \
-    mov _IMM12,r2; \
-    shad r2,r1; \
-    not r1,r1; \
-    tst r1,r1; \
-    bf .Lpseudo_end; \
- .Lsyscall_error: \
-    SYSCALL_ERROR_HANDLER; \
- .Lpseudo_end:
-
-# undef PSEUDO_END
-# define PSEUDO_END(sym) \
-  END (sym)
-
-# define SAVE_ARGS_0	/* Nothing.  */
-# define SAVE_ARGS_1	SAVE_ARGS_0; mov.l r4,@(0,r15)
-# define SAVE_ARGS_2	SAVE_ARGS_1; mov.l r5,@(4,r15)
-# define SAVE_ARGS_3	SAVE_ARGS_2; mov.l r6,@(8,r15)
-# define SAVE_ARGS_4	SAVE_ARGS_3; mov.l r7,@(12,r15)
-# define SAVE_ARGS_5	SAVE_ARGS_4
-# define SAVE_ARGS_6	SAVE_ARGS_5
-
-# define LOAD_ARGS_0	/* Nothing.  */
-# define LOAD_ARGS_1	LOAD_ARGS_0; mov.l @(0,r15),r4
-# define LOAD_ARGS_2	LOAD_ARGS_1; mov.l @(4,r15),r5
-# define LOAD_ARGS_3	LOAD_ARGS_2; mov.l @(8,r15),r6
-# define LOAD_ARGS_4	LOAD_ARGS_3; mov.l @(12,r15),r7
-# define LOAD_ARGS_5	LOAD_ARGS_4
-# define LOAD_ARGS_6	LOAD_ARGS_5
-
-# ifdef IS_IN_libpthread
-#  define __local_enable_asynccancel	__pthread_enable_asynccancel
-#  define __local_disable_asynccancel	__pthread_disable_asynccancel
-#  define __local_multiple_threads	__pthread_multiple_threads
-# elif !defined NOT_IN_libc
-#  define __local_enable_asynccancel	__libc_enable_asynccancel
-#  define __local_disable_asynccancel	__libc_disable_asynccancel
-#  define __local_multiple_threads	__libc_multiple_threads
-# else
-#  define __local_enable_asynccancel	__librt_enable_asynccancel
-#  define __local_disable_asynccancel	__librt_disable_asynccancel
-#  define __local_multiple_threads	__librt_multiple_threads
-# endif
-
-# if defined IS_IN_librt && defined __PIC__
-#  define CENABLE \
-	mov.l r12,@-r15; \
-	mov.l 1f,r12; \
-	mova 1f,r0; \
-	add r0,r12; \
-	mov.l 2f,r0; \
-	bsrf r0; \
-	 nop; \
-     0: bra 3f; \
-	 mov r0,r2; \
-	.align 2; \
-     1: .long _GLOBAL_OFFSET_TABLE_; \
-     2: .long __local_enable_asynccancel@PLT - (0b-.); \
-     3: mov.l @r15+,r12
-
-#  define CDISABLE \
-	mov.l r12,@-r15; \
-	mov.l 1f,r12; \
-	mova 1f,r0; \
-	add r0,r12; \
-	mov.l 2f,r0; \
-	bsrf r0; \
-	 mov r2,r4; \
-     0: bra 3f; \
-	 nop; \
-	.align 2; \
-     1: .long _GLOBAL_OFFSET_TABLE_; \
-     2: .long __local_disable_asynccancel@PLT - (0b-.); \
-     3: mov.l @r15+,r12
-# else
-#  define CENABLE \
-	mov.l 1f,r0; \
-	bsrf r0; \
-	 nop; \
-     0: bra 2f; \
-	 mov r0,r2; \
-	.align 2; \
-     1: .long __local_enable_asynccancel - 0b; \
-     2:
-
-#  define CDISABLE \
-	mov.l 1f,r0; \
-	bsrf r0; \
-	 mov r2,r4; \
-     0: bra 2f; \
-	 nop; \
-	.align 2; \
-     1: .long __local_disable_asynccancel - 0b; \
-     2:
-# endif
-
-# ifndef __ASSEMBLER__
-#  if defined FLOATING_STACKS && defined __UCLIBC_HAS_TLS__ && defined __PIC__
-#   define SINGLE_THREAD_P \
-  __builtin_expect (THREAD_GETMEM (THREAD_SELF, p_multiple_threads) == 0, 1)
-#  else
-extern int __local_multiple_threads attribute_hidden;
-#   define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
-#  endif
-# else
-#  if !defined __PIC__
-#   define SINGLE_THREAD_P \
-	mov.l 1f,r0; \
-	mov.l @r0,r0; \
-	bra 2f; \
-	 tst r0,r0; \
-	.align 2; \
-     1: .long __local_multiple_threads; \
-     2:
-#  elif defined FLOATING_STACKS && defined __UCLIBC_HAS_TLS__
-#   define SINGLE_THREAD_P \
-	stc gbr,r0; \
-	mov.w 0f,r1; \
-	sub r1,r0; \
-	mov.l @(MULTIPLE_THREADS_OFFSET,r0),r0; \
-	bra 1f; \
-	 tst r0,r0; \
-     0: .word TLS_PRE_TCB_SIZE; \
-     1:
-
-#  else
-#   if !defined NOT_IN_libc || defined IS_IN_libpthread
-#    define SINGLE_THREAD_P \
-	mov r12,r2; \
-	mov.l 0f,r12; \
-	mova 0f,r0; \
-	add r0,r12; \
-	mov.l 1f,r0; \
-	mov.l @(r0,r12),r0; \
-	mov r2,r12; \
-	bra 2f; \
-	 tst r0,r0; \
-	.align 2; \
-     0: .long _GLOBAL_OFFSET_TABLE_; \
-     1: .long __local_multiple_threads@GOTOFF; \
-     2:
-#   else
-#    define SINGLE_THREAD_P \
-	mov r12,r2; \
-	mov.l 0f,r12; \
-	mova 0f,r0; \
-	add r0,r12; \
-	mov.l 1f,r0; \
-	mov.l @(r0,r12),r0; \
-	mov.l @r0,r0; \
-	mov r2,r12; \
-	bra 2f; \
-	 tst r0,r0; \
-	.align 2; \
-     0: .long _GLOBAL_OFFSET_TABLE_; \
-     1: .long __local_multiple_threads@GOT; \
-     2:
-#   endif
-#  endif
-# endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/vfork.S
deleted file mode 100644
index 90733119e..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sh/vfork.S
+++ /dev/null
@@ -1,77 +0,0 @@
-/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep-cancel.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-#include <sys/syscall.h>
-
-/* Clone the calling process, but without copying the whole address space.
-   The calling process is suspended until the new process exits or is
-   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
-   and the process ID of the new process to the old process.  */
-
-ENTRY (__vfork)
-#ifdef SHARED
-	mov.l	.Lgot, r1
-	mova	.Lgot, r0
-	add	r0, r1
-	mov.l	.Lpthread_func, r0
-	mov.l	@(r0,r1), r0
-#else
-	mov.l	.Lpthread_create, r0
-#endif
-	tst	r0, r0
-	bf	.Lhidden_fork
-
-	mov.w	.L1, r3
-	trapa	#__SH_SYSCALL_TRAP_BASE
-	mov     r0, r1
-	mov	#-12, r2
-	shad	r2, r1
-	not	r1, r1			/* r1=0 means r0 = -1 to -4095 */
-	tst	r1, r1			/* i.e. error in linux */
-	bf	.Lpseudo_end
-	SYSCALL_ERROR_HANDLER
-.Lpseudo_end:
-	rts
-	 nop
-.L1:	.word	__NR_vfork
-	.align	2
-#ifdef SHARED
-.Lgot:
-	.long	_GLOBAL_OFFSET_TABLE_
-.Lpthread_func:
-	.long	__libc_pthread_functions@GOTOFF
-#else
-.Lpthread_create:
-	.weak	pthread_create
-	.long	pthread_create
-#endif
-
-.Lhidden_fork:
-	mov.l	.L2, r1
-	braf	r1
-	 nop
-1:
-	.align 2
-.L2:	.long	HIDDEN_JUMPTARGET(fork)-1b
-
-PSEUDO_END (__vfork)
-libc_hidden_def (__vfork)
-
-weak_alias (__vfork, vfork)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sigwait.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sigwait.c
deleted file mode 100644
index 2e09d1ba5..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sigwait.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/* Copyright (C) 1997, 1998, 2000, 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <signal.h>
-#define __need_NULL
-#include <stddef.h>
-
-#include <sysdep-cancel.h>
-#include <sys/syscall.h>
-#include <bits/libc-lock.h>
-
-extern int __syscall_rt_sigtimedwait (const sigset_t *, siginfo_t *,
-				      const struct timespec *, size_t);
-
-
-/* Return any pending signal or wait for one for the given time.  */
-static __inline__ int
-do_sigwait (const sigset_t *set, int *sig)
-{
-  int ret;
-
-  /* XXX The size argument hopefully will have to be changed to the
-     real size of the user-level sigset_t.  */
-#ifdef INTERNAL_SYSCALL
-  INTERNAL_SYSCALL_DECL (err);
-  ret = INTERNAL_SYSCALL (rt_sigtimedwait, err, 4, set,
-			  NULL, NULL, _NSIG / 8);
-  if (! INTERNAL_SYSCALL_ERROR_P (ret, err))
-    {
-      *sig = ret;
-      ret = 0;
-    }
-  else
-    ret = INTERNAL_SYSCALL_ERRNO (ret, err);
-#else
-  ret = INLINE_SYSCALL (rt_sigtimedwait, 4, set,
-			NULL, NULL, _NSIG / 8);
-  if (ret != -1)
-    {
-      *sig = ret;
-      ret = 0;
-    }
-  else
-    ret = errno;
-#endif
-
-  return ret;
-}
-
-#ifndef SHARED
-weak_extern (__pthread_sigwait)
-#endif
-
-int
-sigwait (const sigset_t *set, int *sig)
-{
-#ifndef NOT_IN_libc
-  return __libc_maybe_call2 (pthread_sigwait, (set, sig),
-			     do_sigwait (set, sig));
-#else
-  return do_sigwait (set, sig);
-#endif
-}
-strong_alias(sigwait, __libc_sigwait)
-
-/* Cancellation is handled in __pthread_sigwait.  */
-LIBC_CANCEL_HANDLED ();
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/smp.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/smp.h
deleted file mode 100644
index 6f03b9d55..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/smp.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/* Determine whether the host has multiple processors.  Linux version.
-   Copyright (C) 1996, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public License as
-   published by the Free Software Foundation; either version 2 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If not,
-   see <http://www.gnu.org/licenses/>.  */
-
-#include <sys/sysctl.h>
-
-/* Test whether the machine has more than one processor.  This is not the
-   best test but good enough.  More complicated tests would require `malloc'
-   which is not available at that time.  */
-static __inline__ int
-is_smp_system (void)
-{
-  static const int sysctl_args[] = { CTL_KERN, KERN_VERSION };
-  char buf[512];
-  size_t reslen = sizeof (buf);
-
-  /* Try reading the number using `sysctl' first.  */
-  if (__sysctl ((int *) sysctl_args,
-		sizeof (sysctl_args) / sizeof (sysctl_args[0]),
-		buf, &reslen, NULL, 0) < 0)
-    {
-      /* This was not successful.  Now try reading the /proc filesystem.  */
-      int fd = __open ("/proc/sys/kernel/version", O_RDONLY);
-      if (__builtin_expect (fd, 0) == -1
-	  || (reslen = __read (fd, buf, sizeof (buf))) <= 0)
-	/* This also didn't work.  We give up and say it's a UP machine.  */
-	buf[0] = '\0';
-
-      __close (fd);
-    }
-
-  return strstr (buf, "SMP") != NULL;
-}
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/aio_cancel.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/aio_cancel.c
deleted file mode 100644
index 0d6da8291..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/aio_cancel.c
+++ /dev/null
@@ -1,33 +0,0 @@
-#include <shlib-compat.h>
-
-#define aio_cancel64 XXX
-#include <aio.h>
-#undef aio_cancel64
-#include <errno.h>
-
-extern __typeof (aio_cancel) __new_aio_cancel;
-extern __typeof (aio_cancel) __old_aio_cancel;
-
-#define aio_cancel	__new_aio_cancel
-
-#include <sysdeps/pthread/aio_cancel.c>
-
-#undef aio_cancel
-strong_alias (__new_aio_cancel, __new_aio_cancel64);
-versioned_symbol (librt, __new_aio_cancel, aio_cancel, GLIBC_2_3);
-versioned_symbol (librt, __new_aio_cancel64, aio_cancel64, GLIBC_2_3);
-
-#if SHLIB_COMPAT (librt, GLIBC_2_1, GLIBC_2_3)
-
-#undef ECANCELED
-#define aio_cancel	__old_aio_cancel
-#define ECANCELED	125
-
-#include <sysdeps/pthread/aio_cancel.c>
-
-#undef aio_cancel
-strong_alias (__old_aio_cancel, __old_aio_cancel64);
-compat_symbol (librt, __old_aio_cancel, aio_cancel, GLIBC_2_1);
-compat_symbol (librt, __old_aio_cancel64, aio_cancel64, GLIBC_2_1);
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/bits/local_lim.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/bits/local_lim.h
deleted file mode 100644
index 3f22f8ae3..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/bits/local_lim.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* Minimum guaranteed maximum values for system limits.  Linux/SPARC version.
-   Copyright (C) 1993-1998,2000,2002,2003,2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public License as
-   published by the Free Software Foundation; either version 2.1 of the
-   License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; see the file COPYING.LIB.  If
-   not, see <http://www.gnu.org/licenses/>.  */
-
-/* The kernel header pollutes the namespace with the NR_OPEN symbol
-   and defines LINK_MAX although filesystems have different maxima.  A
-   similar thing is true for OPEN_MAX: the limit can be changed at
-   runtime and therefore the macro must not be defined.  Remove this
-   after including the header if necessary.  */
-#ifndef NR_OPEN
-# define __undef_NR_OPEN
-#endif
-#ifndef LINK_MAX
-# define __undef_LINK_MAX
-#endif
-#ifndef OPEN_MAX
-# define __undef_OPEN_MAX
-#endif
-
-/* The kernel sources contain a file with all the needed information.  */
-#include <linux/limits.h>
-
-/* Have to remove NR_OPEN?  */
-#ifdef __undef_NR_OPEN
-# undef NR_OPEN
-# undef __undef_NR_OPEN
-#endif
-/* Have to remove LINK_MAX?  */
-#ifdef __undef_LINK_MAX
-# undef LINK_MAX
-# undef __undef_LINK_MAX
-#endif
-/* Have to remove OPEN_MAX?  */
-#ifdef __undef_OPEN_MAX
-# undef OPEN_MAX
-# undef __undef_OPEN_MAX
-#endif
-
-/* The number of data keys per process.  */
-#define _POSIX_THREAD_KEYS_MAX	128
-/* This is the value this implementation supports.  */
-#define PTHREAD_KEYS_MAX	1024
-
-/* Controlling the iterations of destructors for thread-specific data.  */
-#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
-/* Number of iterations this implementation does.  */
-#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
-
-/* The number of threads per process.  */
-#define _POSIX_THREAD_THREADS_MAX	64
-/* This is the value this implementation supports.  */
-#define PTHREAD_THREADS_MAX	16384
-
-/* Maximum amount by which a process can descrease its asynchronous I/O
-   priority level.  */
-#define AIO_PRIO_DELTA_MAX	20
-
-/* Minimum size for a thread.  We are free to choose a reasonable value.  */
-#define PTHREAD_STACK_MIN	24576
-
-/* Maximum number of POSIX timers available.  */
-#define TIMER_MAX	256
-
-/* Maximum number of timer expiration overruns.  */
-#define DELAYTIMER_MAX	2147483647
-
-/* Maximum tty name length.  */
-#define TTY_NAME_MAX		32
-
-/* Maximum login name length.  This is arbitrary.  */
-#define LOGIN_NAME_MAX		256
-
-/* Maximum host name length.  */
-#define HOST_NAME_MAX		64
-
-/* Maximum message queue priority level.  */
-#define MQ_PRIO_MAX		32768
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h
deleted file mode 100644
index 3efee0b8d..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* bits/typesizes.h -- underlying types for *_t.  Linux/SPARC version.
-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _BITS_TYPES_H
-# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
-#endif
-
-#ifndef	_BITS_TYPESIZES_H
-#define	_BITS_TYPESIZES_H	1
-
-/* See <bits/types.h> for the meaning of these macros.  This file exists so
-   that <bits/types.h> need not vary across different GNU platforms.  */
-
-#define __DEV_T_TYPE		__UQUAD_TYPE
-#define __UID_T_TYPE		__U32_TYPE
-#define __GID_T_TYPE		__U32_TYPE
-#define __INO_T_TYPE		__ULONGWORD_TYPE
-#define __INO64_T_TYPE		__UQUAD_TYPE
-#define __MODE_T_TYPE		__U32_TYPE
-#define __NLINK_T_TYPE		__U32_TYPE
-#define __OFF_T_TYPE		__SLONGWORD_TYPE
-#define __OFF64_T_TYPE		__SQUAD_TYPE
-#define __PID_T_TYPE		__S32_TYPE
-#define __RLIM_T_TYPE		__ULONGWORD_TYPE
-#define __RLIM64_T_TYPE		__UQUAD_TYPE
-#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
-#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
-#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
-#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
-#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
-#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
-#define	__ID_T_TYPE		__U32_TYPE
-#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
-#define __TIME_T_TYPE		__SLONGWORD_TYPE
-#define __USECONDS_T_TYPE	__U32_TYPE
-#define __SUSECONDS_T_TYPE	__S32_TYPE
-#define __DADDR_T_TYPE		__S32_TYPE
-#define __SWBLK_T_TYPE		__SLONGWORD_TYPE
-#define __KEY_T_TYPE		__S32_TYPE
-#define __CLOCKID_T_TYPE	__S32_TYPE
-#define __TIMER_T_TYPE		__S32_TYPE
-#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
-#define __FSID_T_TYPE		struct { int __val[2]; }
-#define __SSIZE_T_TYPE		__SWORD_TYPE
-
-/* Number of descriptors that can fit in an `fd_set'.  */
-#define	__FD_SETSIZE		1024
-
-
-#endif /* bits/typesizes.h */
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/fork.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/fork.h
deleted file mode 100644
index ce98a3bb9..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/fork.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include_next <fork.h>
-
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/sysdep-cancel.h
deleted file mode 100644
index bd9bb0d6a..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/sysdep-cancel.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <tls.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				      \
-	.text;								      \
-ENTRY(name)								      \
-	ld [%g7 + MULTIPLE_THREADS_OFFSET], %g1;			      \
-	cmp %g1, 0;							      \
-	bne 1f;								      \
-	 mov SYS_ify(syscall_name), %g1;				      \
-	ta 0x10;							      \
-	bcs __syscall_error_handler;					      \
-	 nop;								      \
-	.subsection 2;							      \
-1:	save %sp, -96, %sp;						      \
-	CENABLE;							      \
-	 nop;								      \
-	mov %o0, %l0;							      \
-	COPY_ARGS_##args						      \
-	mov SYS_ify(syscall_name), %g1;					      \
-	ta 0x10;							      \
-	bcs __syscall_error_handler2;					      \
-	 mov %o0, %l1;							      \
-	CDISABLE;							      \
-	 mov %l0, %o0;							      \
-	jmpl %i7 + 8, %g0;						      \
-	 restore %g0, %l1, %o0;						      \
-	.previous;							      \
-	SYSCALL_ERROR_HANDLER						      \
-	SYSCALL_ERROR_HANDLER2
-
-#define SYSCALL_ERROR_HANDLER2						      \
-SYSCALL_ERROR_HANDLER_ENTRY(__syscall_error_handler2)			      \
-	.global __errno_location;					      \
-        .type   __errno_location,@function;				      \
-	CDISABLE;							      \
-	 mov	%l0, %o0;						      \
-	call	__errno_location;					      \
-	 nop;								      \
-	st	%l1, [%o0];						      \
-	jmpl	%i7 + 8, %g0;						      \
-	 restore %g0, -1, %o0;						      \
-	.previous;
-
-# ifdef IS_IN_libpthread
-#  define CENABLE	call __pthread_enable_asynccancel
-#  define CDISABLE	call __pthread_disable_asynccancel
-# elif !defined NOT_IN_libc
-#  define CENABLE	call __libc_enable_asynccancel
-#  define CDISABLE	call __libc_disable_asynccancel
-# else
-#  define CENABLE	call __librt_enable_asynccancel
-#  define CDISABLE	call __librt_disable_asynccancel
-# endif
-
-#define COPY_ARGS_0	/* Nothing */
-#define COPY_ARGS_1	COPY_ARGS_0 mov %i0, %o0;
-#define COPY_ARGS_2	COPY_ARGS_1 mov %i1, %o1;
-#define COPY_ARGS_3	COPY_ARGS_2 mov %i2, %o2;
-#define COPY_ARGS_4	COPY_ARGS_3 mov %i3, %o3;
-#define COPY_ARGS_5	COPY_ARGS_4 mov %i4, %o4;
-#define COPY_ARGS_6	COPY_ARGS_5 mov %i5, %o5;
-
-# ifndef __ASSEMBLER__
-#  define SINGLE_THREAD_P \
-  __builtin_expect (THREAD_GETMEM (THREAD_SELF,				      \
-				   p_header.data.multiple_threads) == 0, 1)
-# else
-#  define SINGLE_THREAD_P ld [%g7 + MULTIPLE_THREADS_OFFSET], %g1
-# endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/vfork.S
deleted file mode 100644
index ab2286ee8..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/sparc/vfork.S
+++ /dev/null
@@ -1,64 +0,0 @@
-/* Copyright (C) 2003 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep-cancel.h>
-
-	.text
-#ifdef SHARED
-.LLGETPC0:
-	retl
-	 add	%o7, %o0, %o0
-#endif
-ENTRY(__vfork)
-#ifdef SHARED
-	mov	%o7, %o1
-	sethi	%hi(_GLOBAL_OFFSET_TABLE_-4), %o0
-	call	.LLGETPC0
-	 add	%o0, %lo(_GLOBAL_OFFSET_TABLE_+4), %o0
-	sethi	%hi(__libc_pthread_functions), %o2
-	mov	%o1, %o7
-	or	%o2, %lo(__libc_pthread_functions), %o2
-	ld	[%o0 + %o2], %o2
-	ld	[%o2], %o2
-	cmp	%o2, 0
-#else
-	.weak	pthread_create
-	sethi	%hi(pthread_create), %o0
-	orcc	%o0, %lo(pthread_create), %o0
-#endif
-#if defined SHARED && !defined BROKEN_SPARC_WDISP22
-	bne	HIDDEN_JUMPTARGET(fork)
-#else
-	bne	1f
-#endif
-	 mov	__NR_vfork, %g1
-	ta	0x10
-	bcs	__syscall_error_handler
-	 nop
-	sub	%o1, 1, %o1
-	retl
-	 and	%o0, %o1, %o0
-#if !defined SHARED || defined BROKEN_SPARC_WDISP22
-1:	mov	%o7, %g1
-	call	HIDDEN_JUMPTARGET(fork)
-	 mov	%g1, %o7
-#endif
-	SYSCALL_ERROR_HANDLER
-PSEUDO_END (__vfork)
-libc_hidden_def (__vfork)
-weak_alias (__vfork, vfork)
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/unregister-atfork.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/unregister-atfork.c
deleted file mode 100644
index 4bc83d6cc..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/unregister-atfork.c
+++ /dev/null
@@ -1,48 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <stdlib.h>
-#include "fork.h"
-
-
-void
-__unregister_atfork (dso_handle)
-     void *dso_handle;
-{
-  /* Get the lock to not conflict with running forks.  */
-  __libc_lock_lock (__fork_block.lock);
-
-  list_t *runp;
-  list_t *prevp;
-
-  list_for_each_prev_safe (runp, prevp, &__fork_block.prepare_list)
-    if (list_entry (runp, struct fork_handler, list)->dso_handle == dso_handle)
-      list_del (runp);
-
-  list_for_each_prev_safe (runp, prevp, &__fork_block.parent_list)
-    if (list_entry (runp, struct fork_handler, list)->dso_handle == dso_handle)
-      list_del (runp);
-
-  list_for_each_prev_safe (runp, prevp, &__fork_block.child_list)
-    if (list_entry (runp, struct fork_handler, list)->dso_handle == dso_handle)
-      list_del (runp);
-
-  /* Release the lock.  */
-  __libc_lock_unlock (__fork_block.lock);
-}
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/pt-sigsuspend.c b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/pt-sigsuspend.c
deleted file mode 100644
index 3a0c2afc0..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/pt-sigsuspend.c
+++ /dev/null
@@ -1 +0,0 @@
-#include "../ia64/pt-sigsuspend.c"
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/sysdep-cancel.h b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/sysdep-cancel.h
deleted file mode 100644
index 0b05c96f6..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/sysdep-cancel.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/* Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <tls.h>
-#include <pt-machine.h>
-#ifndef __ASSEMBLER__
-# include <linuxthreads/internals.h>
-#endif
-
-#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
-
-# undef PSEUDO
-# define PSEUDO(name, syscall_name, args)				      \
-  .text;								      \
-  ENTRY (name)								      \
-    SINGLE_THREAD_P;							      \
-    jne L(pseudo_cancel);						      \
-    DO_CALL (syscall_name, args);					      \
-    cmpq $-4095, %rax;							      \
-    jae SYSCALL_ERROR_LABEL;						      \
-    ret;								      \
-  L(pseudo_cancel):							      \
-    /* Save registers that might get destroyed.  */			      \
-    SAVESTK_##args							      \
-    PUSHARGS_##args							      \
-    CENABLE								      \
-    /* Restore registers.  */						      \
-    POPARGS_##args							      \
-    /* The return value from CENABLE is argument for CDISABLE.  */	      \
-    movq %rax, (%rsp);							      \
-    movl $SYS_ify (syscall_name), %eax;					      \
-    syscall;								      \
-    movq (%rsp), %rdi;							      \
-    /* Save %rax since it's the error code from the syscall.  */	      \
-    movq %rax, 8(%rsp);							      \
-    CDISABLE								      \
-    movq 8(%rsp), %rax;							      \
-    RESTSTK_##args							      \
-    cmpq $-4095, %rax;							      \
-    jae SYSCALL_ERROR_LABEL;						      \
-  L(pseudo_end):
-
-# define PUSHARGS_0	/* Nothing.  */
-# define PUSHARGS_1	PUSHARGS_0 movq %rdi, 8(%rsp);
-# define PUSHARGS_2	PUSHARGS_1 movq %rsi, 16(%rsp);
-# define PUSHARGS_3	PUSHARGS_2 movq %rdx, 24(%rsp);
-# define PUSHARGS_4	PUSHARGS_3 movq %rcx, 32(%rsp);
-# define PUSHARGS_5	PUSHARGS_4 movq %r8, 40(%rsp);
-# define PUSHARGS_6	PUSHARGS_5 movq %r9, 48(%rsp);
-
-# define POPARGS_0	/* Nothing.  */
-# define POPARGS_1	POPARGS_0 movq 8(%rsp), %rdi;
-# define POPARGS_2	POPARGS_1 movq 16(%rsp), %rsi;
-# define POPARGS_3	POPARGS_2 movq 24(%rsp), %rdx;
-# define POPARGS_4	POPARGS_3 movq 32(%rsp), %r10;
-# define POPARGS_5	POPARGS_4 movq 40(%rsp), %r8;
-# define POPARGS_6	POPARGS_5 movq 48(%rsp), %r9;
-
-/* We always have to align the stack before calling a function.  */
-# define SAVESTK_0	subq $24, %rsp;cfi_adjust_cfa_offset(24);
-# define SAVESTK_1	SAVESTK_0
-# define SAVESTK_2	SAVESTK_1
-# define SAVESTK_3	subq $40, %rsp;cfi_adjust_cfa_offset(40);
-# define SAVESTK_4	SAVESTK_3
-# define SAVESTK_5	subq $56, %rsp;cfi_adjust_cfa_offset(56);
-# define SAVESTK_6	SAVESTK_5
-
-# define RESTSTK_0	addq $24,%rsp;cfi_adjust_cfa_offset(-24);
-# define RESTSTK_1	RESTSTK_0
-# define RESTSTK_2	RESTSTK_1
-# define RESTSTK_3	addq $40, %rsp;cfi_adjust_cfa_offset(-40);
-# define RESTSTK_4	RESTSTK_3
-# define RESTSTK_5	addq $56, %rsp;cfi_adjust_cfa_offset(-56);
-# define RESTSTK_6	RESTSTK_5
-
-# ifdef IS_IN_libpthread
-#  define CENABLE	call __pthread_enable_asynccancel;
-#  define CDISABLE	call __pthread_disable_asynccancel;
-#  define __local_multiple_threads __pthread_multiple_threads
-# elif !defined NOT_IN_libc
-#  define CENABLE	call __libc_enable_asynccancel;
-#  define CDISABLE	call __libc_disable_asynccancel;
-#  define __local_multiple_threads __libc_multiple_threads
-# else
-#  define CENABLE	call __librt_enable_asynccancel@plt;
-#  define CDISABLE	call __librt_disable_asynccancel@plt;
-# endif
-
-# if defined IS_IN_libpthread || !defined NOT_IN_libc
-#  ifndef __ASSEMBLER__
-extern int __local_multiple_threads attribute_hidden;
-#   define SINGLE_THREAD_P \
-  __builtin_expect (__local_multiple_threads == 0, 1)
-#  else
-#   define SINGLE_THREAD_P cmpl $0, __local_multiple_threads(%rip)
-#  endif
-
-# else
-
-#  ifndef __ASSEMBLER__
-#   define SINGLE_THREAD_P \
-  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
-				   p_header.data.multiple_threads) == 0, 1)
-#  else
-#   define SINGLE_THREAD_P cmpl $0, %fs:MULTIPLE_THREADS_OFFSET
-#  endif
-
-# endif
-
-#elif !defined __ASSEMBLER__
-
-/* This code should never be used but we define it anyhow.  */
-# define SINGLE_THREAD_P (1)
-
-#endif
diff --git a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/vfork.S b/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/vfork.S
deleted file mode 100644
index 1a58077c4..000000000
--- a/libpthread/linuxthreads/sysdeps/unix/sysv/linux/x86_64/vfork.S
+++ /dev/null
@@ -1,61 +0,0 @@
-/* Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep-cancel.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-
-/* Clone the calling process, but without copying the whole address space.
-   The calling process is suspended until the new process exits or is
-   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
-   and the process ID of the new process to the old process.  */
-
-ENTRY (__vfork)
-
-#ifdef SHARED
-	cmpq	$0, __libc_pthread_functions(%rip)
-#else
-	.weak	pthread_create
-	movq	$pthread_create, %rax
-	testq	%rax, %rax
-#endif
-	jne	HIDDEN_JUMPTARGET (fork)
-
-	/* Pop the return PC value into RDI.  We need a register that
-	   is preserved by the syscall and that we're allowed to destroy. */
-	popq	%rdi
-	cfi_adjust_cfa_offset(-8)
-
-	/* Stuff the syscall number in RAX and enter into the kernel.  */
-	movl	$SYS_ify (vfork), %eax
-	syscall
-
-	/* Push back the return PC.  */
-	pushq	%rdi
-	cfi_adjust_cfa_offset(8)
-
-	cmpl	$-4095, %eax
-	jae SYSCALL_ERROR_LABEL		/* Branch forward if it failed.  */
-
-	/* Normal return.  */
-.Lpseudo_end:
-	ret
-
-PSEUDO_END (__vfork)
-libc_hidden_def (__vfork)
-
-weak_alias (__vfork, vfork)
diff --git a/libpthread/linuxthreads.old/sysdeps/v850/pt-machine.h b/libpthread/linuxthreads/sysdeps/v850/pt-machine.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/v850/pt-machine.h
rename to libpthread/linuxthreads/sysdeps/v850/pt-machine.h
diff --git a/libpthread/linuxthreads/sysdeps/x86_64/pspinlock.c b/libpthread/linuxthreads/sysdeps/x86_64/pspinlock.c
deleted file mode 100644
index 80c1b05a8..000000000
--- a/libpthread/linuxthreads/sysdeps/x86_64/pspinlock.c
+++ /dev/null
@@ -1,96 +0,0 @@
-/* POSIX spinlock implementation.  x86-64 version.
-   Copyright (C) 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <errno.h>
-#include <pthread.h>
-#include "internals.h"
-
-/* This implementation is similar to the one used in the Linux kernel.
-   But the kernel is byte instructions for the memory access.  This is
-   faster but unusable here.  The problem is that only 128
-   threads/processes could use the spinlock at the same time.  If (by
-   a design error in the program) a thread/process would hold the
-   spinlock for a time long enough to accumulate 128 waiting
-   processes, the next one will find a positive value in the spinlock
-   and assume it is unlocked.  We cannot accept that.  */
-
-int
-__pthread_spin_lock (pthread_spinlock_t *lock)
-{
-  __asm__ __volatile__
-    ("\n"
-     "1:\n\t"
-     "lock; decl %0\n\t"
-     "js 2f\n\t"
-     ".section .text.spinlock,\"ax\"\n"
-     "2:\n\t"
-     "cmpl $0,%0\n\t"
-     "rep; nop\n\t"
-     "jle 2b\n\t"
-     "jmp 1b\n\t"
-     ".previous"
-     : "=m" (*lock));
-  return 0;
-}
-weak_alias (__pthread_spin_lock, pthread_spin_lock)
-
-
-int
-__pthread_spin_trylock (pthread_spinlock_t *lock)
-{
-  int oldval;
-
-  __asm__ __volatile__
-    ("xchgl %0,%1"
-     : "=r" (oldval), "=m" (*lock)
-     : "0" (0));
-  return oldval > 0 ? 0 : EBUSY;
-}
-weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
-
-
-int
-__pthread_spin_unlock (pthread_spinlock_t *lock)
-{
-  __asm__ __volatile__
-    ("movl $1,%0"
-     : "=m" (*lock));
-  return 0;
-}
-weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
-
-
-int
-__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
-{
-  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
-     all processes which can access the memory location `lock' points
-     to can use the spinlock.  */
-  *lock = 1;
-  return 0;
-}
-weak_alias (__pthread_spin_init, pthread_spin_init)
-
-
-int
-__pthread_spin_destroy (pthread_spinlock_t *lock)
-{
-  /* Nothing to do.  */
-  return 0;
-}
-weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff --git a/libpthread/linuxthreads/sysdeps/x86_64/pt-machine.h b/libpthread/linuxthreads/sysdeps/x86_64/pt-machine.h
index 0e0851e1e..ed1fa30b1 100644
--- a/libpthread/linuxthreads/sysdeps/x86_64/pt-machine.h
+++ b/libpthread/linuxthreads/sysdeps/x86_64/pt-machine.h
@@ -20,7 +20,7 @@
 #ifndef _PT_MACHINE_H
 #define _PT_MACHINE_H   1
 
-# include <features.h>
+#include <features.h>
 
 #ifndef __ASSEMBLER__
 # include <stddef.h>	/* For offsetof.  */
@@ -32,6 +32,9 @@
 #  define PT_EI __extern_always_inline
 # endif
 
+extern long int testandset (int *);
+extern int __compare_and_swap (long int *, long int, long int);
+
 /* Get some notion of the current stack.  Need not be exactly the top
    of the stack, just something somewhere in the current frame.  */
 # define CURRENT_STACK_FRAME  stack_pointer
@@ -40,14 +43,14 @@ register char * stack_pointer __asm__ ("%rsp") __attribute_used__;
 
 /* Spinlock implementation; required.  */
 PT_EI long int
-testandset (int *spinlock)
+testandset (int *__spinlock)
 {
   long int ret;
 
   __asm__ __volatile__ (
 	"xchgl %k0, %1"
-	: "=r"(ret), "=m"(*spinlock)
-	: "0"(1), "m"(*spinlock)
+	: "=r"(ret), "=m"(*__spinlock)
+	: "0"(1), "m"(*__spinlock)
 	: "memory");
 
   return ret;
@@ -58,157 +61,18 @@ testandset (int *spinlock)
 # define HAS_COMPARE_AND_SWAP
 
 PT_EI int
-__compare_and_swap (long int *p, long int oldval, long int newval)
+__compare_and_swap (long int *__p, long int __oldval, long int __newval)
 {
   char ret;
   long int readval;
 
   __asm__ __volatile__ ("lock; cmpxchgq %3, %1; sete %0"
-			: "=q" (ret), "=m" (*p), "=a" (readval)
-			: "r" (newval), "m" (*p), "a" (oldval)
+			: "=q" (ret), "=m" (*__p), "=a" (readval)
+			: "r" (__newval), "m" (*__p), "a" (__oldval)
 			: "memory");
   return ret;
 }
 
-/* Return the thread descriptor for the current thread.
-
-   The contained asm must *not* be marked volatile since otherwise
-   assignments like
-	pthread_descr self = thread_self();
-   do not get optimized away.  */
-# define THREAD_SELF \
-({									      \
-  register pthread_descr __self;					      \
-  __asm__ ("movq %%fs:%c1,%0" : "=r" (__self)				      \
-	   : "i" (offsetof (struct _pthread_descr_struct,		      \
-			    p_header.data.self)));			      \
-  __self;								      \
-})
-
-/* Prototype for the system call.  */
-extern int arch_prctl (int __code, unsigned long __addr);
-
-/* Initialize the thread-unique value.  */
-# define INIT_THREAD_SELF(descr, nr) \
-{									      \
-  if (arch_prctl (ARCH_SET_FS, (unsigned long)descr) != 0)		      \
-    abort ();								      \
-}
-
-/* Read member of the thread descriptor directly.  */
-# define THREAD_GETMEM(descr, member) \
-({									      \
-  __typeof__ (descr->member) __value;					      \
-  if (sizeof (__value) == 1)						      \
-    __asm__ __volatile__ ("movb %%fs:%P2,%b0"				      \
-			  : "=q" (__value)				      \
-			  : "0" (0),					      \
-			    "i" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else if (sizeof (__value) == 4)					      \
-    __asm__ __volatile__ ("movl %%fs:%P2,%k0"				      \
-			  : "=r" (__value)				      \
-			  : "0" (0),					      \
-			    "i" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else									      \
-    {									      \
-      if (sizeof (__value) != 8)					      \
-	/* There should not be any value with a size other than 1, 4 or 8.  */\
-	abort ();							      \
-									      \
-      __asm__ __volatile__ ("movq %%fs:%P1,%0"				      \
-			    : "=r" (__value)				      \
-			    : "i" (offsetof (struct _pthread_descr_struct,    \
-					     member)));			      \
-    }									      \
-  __value;								      \
-})
-
-/* Same as THREAD_GETMEM, but the member offset can be non-constant.  */
-# define THREAD_GETMEM_NC(descr, member) \
-({									      \
-  __typeof__ (descr->member) __value;					      \
-  if (sizeof (__value) == 1)						      \
-    __asm__ __volatile__ ("movb %%fs:(%2),%b0"				      \
-			  : "=q" (__value)				      \
-			  : "0" (0),					      \
-			    "r" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else if (sizeof (__value) == 4)					      \
-    __asm__ __volatile__ ("movl %%fs:(%2),%k0"				      \
-			  : "=r" (__value)				      \
-			  : "0" (0),					      \
-			    "r" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else									      \
-    {									      \
-      if (sizeof (__value) != 8)					      \
-	/* There should not be any value with a size other than 1, 4 or 8.  */\
-	abort ();							      \
-									      \
-      __asm__ __volatile__ ("movq %%fs:(%1),%0"				      \
-			    : "=r" (__value)				      \
-			    : "r" (offsetof (struct _pthread_descr_struct,    \
-					     member)));			      \
-    }									      \
-  __value;								      \
-})
-
-/* Set member of the thread descriptor directly.  */
-# define THREAD_SETMEM(descr, member, value) \
-({									      \
-  __typeof__ (descr->member) __value = (value);				      \
-  if (sizeof (__value) == 1)						      \
-    __asm__ __volatile__ ("movb %0,%%fs:%P1" :				      \
-			  : "q" (__value),				      \
-			    "i" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else if (sizeof (__value) == 4)					      \
-    __asm__ __volatile__ ("movl %k0,%%fs:%P1" :				      \
-			  : "r" (__value),				      \
-			    "i" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else									      \
-    {									      \
-      if (sizeof (__value) != 8)					      \
-	/* There should not be any value with a size other than 1, 4 or 8.  */\
-	abort ();							      \
-									      \
-      __asm__ __volatile__ ("movq %0,%%fs:%P1" :			      \
-			    : "r" (__value),				      \
-			      "i" (offsetof (struct _pthread_descr_struct,    \
-					     member)));			      \
-    }									      \
-})
-
-/* Same as THREAD_SETMEM, but the member offset can be non-constant.  */
-# define THREAD_SETMEM_NC(descr, member, value) \
-({									      \
-  __typeof__ (descr->member) __value = (value);				      \
-  if (sizeof (__value) == 1)						      \
-    __asm__ __volatile__ ("movb %0,%%fs:(%1)" :				      \
-			  : "q" (__value),				      \
-			    "r" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else if (sizeof (__value) == 4)					      \
-    __asm__ __volatile__ ("movl %k0,%%fs:(%1)" :			      \
-			  : "r" (__value),				      \
-			    "r" (offsetof (struct _pthread_descr_struct,      \
-					   member)));			      \
-  else									      \
-    {									      \
-      if (sizeof (__value) != 8)					      \
-	/* There should not be any value with a size other than 1, 4 or 8.  */\
-	abort ();							      \
-									      \
-      __asm__ __volatile__ ("movq %0,%%fs:(%1)"	:			      \
-			    : "r" (__value),				      \
-			      "r" (offsetof (struct _pthread_descr_struct,    \
-					     member)));			      \
-    }									      \
-})
-
 #endif /* !__ASSEMBLER__ */
 
 /* We want the OS to assign stack addresses.  */
diff --git a/libpthread/linuxthreads/sysdeps/x86_64/tcb-offsets.sym b/libpthread/linuxthreads/sysdeps/x86_64/tcb-offsets.sym
deleted file mode 100644
index aee6be257..000000000
--- a/libpthread/linuxthreads/sysdeps/x86_64/tcb-offsets.sym
+++ /dev/null
@@ -1,4 +0,0 @@
-#include <sysdep.h>
-#include <tls.h>
-
-MULTIPLE_THREADS_OFFSET		offsetof (tcbhead_t, multiple_threads)
diff --git a/libpthread/linuxthreads.old/sysdeps/xtensa/pt-machine.h b/libpthread/linuxthreads/sysdeps/xtensa/pt-machine.h
similarity index 100%
rename from libpthread/linuxthreads.old/sysdeps/xtensa/pt-machine.h
rename to libpthread/linuxthreads/sysdeps/xtensa/pt-machine.h
diff --git a/libpthread/linuxthreads.old/wrapsyscall.c b/libpthread/linuxthreads/wrapsyscall.c
similarity index 100%
rename from libpthread/linuxthreads.old/wrapsyscall.c
rename to libpthread/linuxthreads/wrapsyscall.c
diff --git a/libpthread/linuxthreads_db/ChangeLog b/libpthread/linuxthreads_db/ChangeLog
deleted file mode 100644
index 9964b4dd4..000000000
--- a/libpthread/linuxthreads_db/ChangeLog
+++ /dev/null
@@ -1,467 +0,0 @@
-2006-04-25  Bernhard Fischer  <rep.nop@aon.at>
-
-	* td_init.c (__td_debug): Only declare when NDEBUG is undefined.
-
-2006-04-25  Bernhard Fischer  <rep.nop@aon.at>
-
-	* thread_dbP.h: Fix Indices typo in comment.
-
-2005-11-02  Daniel Jacobowitz  <dan@codesourcery.com>
-
-	* td_ta_clear_event.c (td_ta_clear_event): Correct arguments to
-	sizeof.
-	* td_ta_set_event.c (td_ta_set_event): Likewise.
-	* td_thr_clear_event.c (td_thr_clear_event): Likewise.
-	* td_thr_set_event.c (td_thr_set_event): Likewise.
-
-2005-01-09  Andreas Jaeger  <aj@suse.de>
-
-	* td_thr_tlsbase.c (td_thr_tlsbase): Adjust for dtv change.
-
-2004-05-01  Jakub Jelinek  <jakub@redhat.com>
-
-	* thread_dbP.h (LOG): Use write instead of __libc_write.
-
-2004-03-13  Jakub Jelinek  <jakub@redhat.com>
-
-	* td_thr_tlsbase.c: Remove dl-tls.h include.  Don't use
-	TLS_TP_OFFSET in the #if, but TLS_TCB_SIZE == 0 ?:.
-
-2004-03-12  Roland McGrath  <roland@redhat.com>
-
-	* td_thr_tlsbase.c [TLS_DTV_AT_TP && TLS_TP_OFFSET > 0]: Handle this
-	case (PowerPC) differently.
-
-2003-11-25  Roland McGrath  <roland@redhat.com>
-
-	* td_symbol_list.c (symbol_list_arr) [HAVE_ASM_GLOBAL_DOT_NAME]:
-	Prepend "." to symbol names for functions.
-
-2003-08-18  Daniel Jacobowitz  <drow@mvista.com>
-
-	* td_thr_getfpregs.c (td_thr_getfpregs): Use the main thread if
-	the descriptor is uninitialized.
-	* td_thr_getgregs.c (td_thr_getgregs): Likewise.
-
-2003-03-15  Roland McGrath  <roland@redhat.com>
-
-	* thread_db.h (td_err_e): Add TD_NOTLS and TD_TLSDEFER.
-	(td_thr_tlsbase): Declare it.
-	* td_thr_tlsbase.c: New file.
-	* Makefile (libthread_db-routines): Add it.
-	* Versions (libthread_db: GLIBC_2.3.3): New set, add td_thr_tlsbase.
-	* td_thr_tls_get_addr.c (td_thr_tls_get_addr): Use td_thr_tlsbase.
-
-2003-02-27  Roland McGrath  <roland@redhat.com>
-
-	* td_thr_tls_get_addr.c (td_thr_tls_get_addr): Handle TLS_DTV_AT_TP.
-
-	* td_ta_thr_iter.c (handle_descr) [!defined USE_TLS || !TLS_DTV_AT_TP]:
-	Conditionalize p_header use on this.
-
-2003-01-29  Roland McGrath  <roland@redhat.com>
-
-	* td_ta_new.c (td_ta_new): Cap the `sizeof_descr' value read from the
-	inferior at `sizeof (struct _pthread_descr_struct)', since we use it
-	as a length in copies to our own structures.
-
-2003-01-05  Ulrich Drepper  <drepper@redhat.com>
-
-	* Makefile (libthread_db.so-no-z-defs): Define.
-
-2002-09-29  Ulrich Drepper  <drepper@redhat.com>
-
-	* td_thr_tsd.c (td_thr_tsd): Read correct entry from pthread_keys
-	array.
-
-2002-09-28  Andreas Jaeger  <aj@suse.de>
-
-	* td_thr_tls_get_addr.c (td_thr_tls_get_addr): Fix reference to dtv.
-
-2002-09-24  Roland McGrath  <roland@redhat.com>
-
-	* td_thr_tls_get_addr.c (td_thr_tls_get_addr): Fetch just the
-	individual members we need, not the whole structures.
-
-2002-09-24  Ulrich Drepper  <drepper@redhat.com>
-
-	* td_thr_tls_get_addr.c (td_thr_tls_get_addr): Change second
-	parameter to be the address of the link map in the inferior process.
-	* thread_db.h: Update prototype for td_thr_tls_get_addr.
-
-2002-08-23  Ulrich Drepper  <drepper@redhat.com>
-
-	* thread_dbP.h: Define LINUXTHREADS_VERSION.
-	* td_symbol_list.c (symbol_list_arr): Add LINUXTHREADS_VERSION string.
-	* td_ta_new.c (td_ta_new): After verifying the thread library is
-	there check version.
-	* thread_db.h: Add new error TD_VERSION.
-
-2002-08-21  Roland McGrath  <roland@redhat.com>
-
-	* td_thr_tls_get_addr.c (td_thr_tls_get_addr): __attribute_used__ ->
-	__attribute__ ((unused)) for arguments.
-
-2002-08-07  Ulrich Drepper  <drepper@redhat.com>
-
-	* thread_dbP.h: Define LINUXTHREADS_INITIAL_REPORT_EVENTS.
-	* td_thr_event_enable.c (td_thr_event_enable): If th->th_unique is
-	null write to __linuxthreads_initial_report_events.
-	* td_symbol_list.c (symbol_list_arr): Add
-	__linuxthreads_initial_report_events.
-
-2002-07-16  Ulrich Drepper  <drepper@redhat.com>
-
-	* td_thr_clear_event.c: Yet more changes to help with TLS-enabled
-	libpthread.
-	* td_thr_event_enable.c: Likewise.
-	* td_thr_event_getmsg.c: Likewise.
-	* td_thr_set_event.c: Likewise.
-	* td_thr_setfpregs.c: Likewise.
-	* td_thr_setgregs.c: Likewise.
-	* td_thr_tsd.c: Likewise.
-	* td_thr_validate.c: Likewise.
-
-2002-07-15  Ulrich Drepper  <drepper@redhat.com>
-
-	* td_ta_thr_iter.c: Some more changes to enable using TLS-enabled
-	libpthread.
-	* td_thr_event_enable.c: Likewise.
-	* td_thr_getfpregs.c: Likewise.
-	* td_thr_getgregs.c: Likewise.
-
-2002-07-14  Ulrich Drepper  <drepper@redhat.com>
-
-	* td_ta_map_id2thr.c: Begin fixing implementation for libpthread with
-	TLS support.
-	* td_ta_map_lwp2thr.c: Likewise.
-	* td_ta_thr_iter.c: Likewise.
-	* td_thr_get_info.c: Likewise.
-
-2002-07-10  Ulrich Drepper  <drepper@redhat.com>
-
-	* Versions [libthread_db] (GLIBC_2.3): Add td_thr_tls_get_addr.
-
-2002-06-14  H.J. Lu  <hjl@gnu.org>
-
-	* td_thr_tls_get_addr.c (td_thr_tls_get_addr): Don't include
-	"tls.h". Return TD_ERR if USE_TLS is not defined.
-
-2002-06-12  Ulrich Drepper  <drepper@redhat.com>
-
-	* td_thr_tls_get_addr.c: New file.
-	* thread_db.h: Add prototype for td_thr_tls_get_addr.
-	* Makefile (libthread_db-routines): Add td_thr_tls_get_addr.
-
-2002-03-03  Andreas Jaeger  <aj@suse.de>
-
-	* thread_dbP.h: Include <unistd.h> for prototypes of __libc_write.
-
-2002-02-04  Ulrich Drepper  <drepper@redhat.com>
-
-	* thread_dbP.h: Include descr.h instead of internals.h.
-	* td_ta_event_getmsg.c: Also include <linuxthreads/internals.h>.
-	* td_ta_map_id2thr.c: Likewise.
-	* td_ta_map_lwp2thr.c: Likewise.
-	* td_ta_thr_iter.c: Likewise.
-	* td_ta_tsd_iter.c: Likewise.
-	* td_thr_tsd.c: Likewise.
-	* td_thr_validate.c: Likewise.
-
-2001-12-28  Andreas Jaeger  <aj@suse.de>
-
-	* td_init.c (td_init): Don't use __FUNCTION__ as literal.
-	* td_log.c (td_log): Likewise.
-	* td_ta_delete.c (td_ta_delete): Likewise.
-	* td_ta_get_nthreads.c (td_ta_get_nthreads): Likewise.
-	* td_ta_get_ph.c (td_ta_get_ph): Likewise.
-	* td_ta_map_id2thr.c (td_ta_map_id2thr): Likewise.
-	* td_ta_map_lwp2thr.c (td_ta_map_lwp2thr): Likewise.
-	* td_ta_new.c (td_ta_new): Likewise.
-	* td_ta_clear_event.c (td_ta_clear_event): Likewise.
-	* td_ta_enable_stats.c (td_ta_enable_stats): Likewise.
-	* td_ta_event_addr.c (td_ta_event_addr): Likewise.
-	* td_ta_event_getmsg.c (td_ta_event_getmsg): Likewise.
-	* td_ta_get_stats.c (td_ta_get_stats): Likewise.
-	* td_ta_reset_stats.c (td_ta_reset_stats): Likewise.
-	* td_ta_set_event.c (td_ta_set_event): Likewise.
-	* td_ta_setconcurrency.c (td_ta_setconcurrency): Likewise.
-	* td_ta_thr_iter.c (td_ta_thr_iter): Likewise.
-	* td_ta_tsd_iter.c (td_ta_tsd_iter): Likewise.
-	* td_thr_clear_event.c (td_thr_clear_event): Likewise.
-	* td_thr_dbresume.c (td_thr_dbresume): Likewise.
-	* td_thr_dbsuspend.c (td_thr_dbsuspend): Likewise.
-	* td_thr_event_enable.c (td_thr_event_enable): Likewise.
-	* td_thr_event_getmsg.c (td_thr_event_getmsg): Likewise.
-	* td_thr_get_info.c (td_thr_get_info): Likewise.
-	* td_thr_getfpregs.c (td_thr_getfpregs): Likewise.
-	* td_thr_getgregs.c (td_thr_getgregs): Likewise.
-	* td_thr_getxregs.c (td_thr_getxregs): Likewise.
-	* td_thr_getxregsize.c (td_thr_getxregsize): Likewise.
-	* td_thr_set_event.c (td_thr_set_event): Likewise.
-	* td_thr_setfpregs.c (td_thr_setfpregs): Likewise.
-	* td_thr_setgregs.c (td_thr_setgregs): Likewise.
-	* td_thr_setprio.c (td_thr_setprio): Likewise.
-	* td_thr_setsigpending.c (td_thr_setsigpending): Likewise.
-	* td_thr_setxregs.c (td_thr_setxregs): Likewise.
-	* td_thr_sigsetmask.c (td_thr_sigsetmask): Likewise.
-	* td_thr_tsd.c (td_thr_tsd): Likewise.
-	* td_thr_validate.c (td_thr_validate): Likewise.
-
-2001-04-12  Ulrich Drepper  <drepper@redhat.com>
-
-	* td_ta_map_id2thr.c: If thread terminated return TD_NOTHR.
-	* td_thr_validate.c: Likewise.
-
-2001-04-04  Ulrich Drepper  <drepper@redhat.com>
-
-	* td_thr_getfpregs.c: If p_pid is zero use ps_getpid().
-	* td_thr_getgregs.c: Likewise.
-	* td_thr_setfpregs.c: Likewise.
-	* td_thr_setgregs.c: Likewise.
-
-2001-03-20  Ulrich Drepper  <drepper@redhat.com>
-
-	* Makefile (libthread_db-routines): Add td_symbol_list.
-	* Versions [libthread_db] (GLIBC_2.2.3): Add td_symbol_list.
-	* td_symbol_list.c: New file.
-	* thread_db.h: Add prototype for td_symbol_list.
-	* thread_dbP.h: Define symbol name indices.
-	Add prototype for td_lookup.
-	* td_ta_event_addr.c: Use td_lookup instead of directly using
-	ps_pglobal_lookup to find symbol address.
-	* td_ta_get_nthreads.c: Likewise.
-	* td_ta_new.c: Likewise.
-
-2001-03-18  Ulrich Drepper  <drepper@redhat.com>
-
-	* Makefile: When generating DSO link with libc_nonshared.a.
-
-2000-08-01  Andreas Jaeger  <aj@suse.de>
-
-	* Makefile (distribute): Add missing files.
-
-2000-04-24  Mark Kettenis  <kettenis@gnu.org>
-
-	* td_thr_get_info.c (td_thr_get_info): Set ti_state to
-	TD_THR_ACTIVE instead of TD_THR_RUN.  If the thread is no longer
-	running but is still joinable, set it to TD_THR_ZOMBIE.  Otherwise
-	set it to TD_THR_UNKNOWN.
-
-2000-02-25  Andreas Jaeger  <aj@suse.de>
-
-	* td_ta_thr_iter.c: Include <alloca.h> for prototype declaration.
-	* td_ta_tsd_iter.c: Likewise.
-
-2000-01-20  Andreas Jaeger  <aj@suse.de>
-
-	* td_thr_getgregs.c (td_thr_getgregs): Fix typo.
-
-2000-01-19  Ulrich Drepper  <drepper@cygnus.com>
-
-	* td_thr_getgregs.c: Correct size parameter of memset call.
-
-1999-12-02  Ulrich Drepper  <drepper@cygnus.com>
-
-	* proc_service.h: Fix typos in last added declaractions.
-
-1999-12-01  Ulrich Drepper  <drepper@cygnus.com>
-
-	* proc_service.h: Add ps_pstop, ps_pcontinue, ps_lstop, and
-	ps_lcontinue prototypes.
-
-1999-11-23  Ulrich Drepper  <drepper@cygnus.com>
-
-	* Makefile: Correct dependency for shared object.
-
-1999-11-22  Ulrich Drepper  <drepper@cygnus.com>
-
-	* td_ta_map_lwp2thr.c: Add missing brace in comparison.
-
-	* thread_dbP.h (LOG): Only print message if __td_debug is nonzero.
-	* td_init.c: Add __td_debug.
-
-1999-11-12  Ulrich Drepper  <drepper@cygnus.com>
-
-	* td_ta_thr_iter.c: Start copying list of descriptors from right
-	position in target process.
-
-	* td_ta_thr_iter.c: Fix loop starting point over all but main and
-	manager thread.
-
-	* td_ta_thr_iter.c: Read descriptors for main and manager thread
-	special since after this we can assume that no new threads will be
-	created anymore (at least in the gdb implementation).
-
-	* Makefile: Define version correctly.
-
-1999-11-10  Ulrich Drepper  <drepper@cygnus.com>
-
-	* td_ta_map_lwp2thr.c: If p_pid field is zero, this is before the
-	thread library is initialized and we get the PID from the
-	debugger.
-
-1999-11-08  Ulrich Drepper  <drepper@cygnus.com>
-
-	* td_thr_get_info.c: Make sure ti_lid is never zero.
-
-	* proc_service.h: Add ps_getpid prototype.
-
-1999-11-03  Ulrich Drepper  <drepper@cygnus.com>
-
-	* thread_dbP.h (ta_ok): New function.
-	* td_ta_new.c: Add new handle to list.
-	* td_ta_delete.c: Remove handle from list.
-	* td_ta_clear_event.c: Use ta_ok to check for correct ta parameter.
-	* td_ta_enable_stats.c: Likewise.
-	* td_ta_event_addr.c: Likewise.
-	* td_ta_event_getmsg.c: Likewise.
-	* td_ta_get_nthreads.c: Likewise.
-	* td_ta_get_ph.c: Likewise.
-	* td_ta_get_stats.c: Likewise.
-	* td_ta_map_id2thr.c: Likewise.
-	* td_ta_map_lwp2thr.c: Likewise.
-	* td_ta_reset_stats.c: Likewise.
-	* td_ta_set_event.c: Likewise.
-	* td_ta_setconcurrency.c: Likewise.
-	* td_ta_thr_iter.c: Likewise.
-
-	* td_ta_tsd_iter.c: Optimize memory retrieving.
-
-	* Versions: New file.
-
-	* td_thr_get_info.c (td_thr_get_info): Initialize ti_traceme.
-
-1999-11-02  Ulrich Drepper  <drepper@cygnus.com>
-
-	* td_ta_thr_iter.c (td_ta_thr_iter): Optimize a bit.  Read all
-	handles at once.
-
-	* thread_dbP.h (struct th_thragent): Add pthread_handle_num.
-	* td_ta_new.c: Initialize pthread_handle_num.
-	* td_ta_event_getmsg.c: If last event was already reported search
-	for another unreported event.
-
-	* td_thr_get_info.c (td_thr_get_info): Initialize ti_events.
-
-	* Makefile (libthread_db-routines): Add td_ta_set_event,
-	td_ta_event_getmsg, and td_ta_clear_event.
-	* td_ta_clear_event.c: New file.
-	* td_ta_event_getmsg.c: New file.
-	* td_ta_new.c: Get address of __pthread_last_event in target.
-	* td_ta_set_event.c: Don't overwrite old mask, set additional bits.
-	* td_thr_set_event.c: Likewise.
-	* td_thr_clear_event.c: Implement.
-	* thread_db.h: Declare td_ta_clear_event and td_ta_event_getmsg.
-	* thread_dbP.h (struct td_thragent): Add pthread_last_event.
-
-	* td_ta_new.c: Don't test for __pthread_threads_debug.  Get address
-	of __pthread_threads_events and fail if this is not possible.
-	* td_ta_event_addr.c: Implement.
-	* td_thr_event_enable.c: Implement.
-	* td_thr_event_getmsg.c: Implement.
-	* td_thr_set_event.c: Implement.
-	* td_ta_set_event.c: New file.
-	* thread_db.h (td_eventbuf_t): Define.
-	Declare td_ta_set_event.
-	* thread_dbP.h (struct td_thragent): Add pthread_threads_eventsp.
-
-	* td_thr_getfpregs.c: For terminated threads return empty structure.
-	* td_thr_getgregs.c: Likewise.
-	* td_thr_setfpregs.c: Likewise.
-	* td_thr_setgregs.c: Likewise.
-
-1999-11-01  Ulrich Drepper  <drepper@cygnus.com>
-
-	* thread_db.h: Shuffle types around to make things work for gdb.
-	* thread_dbP.h: Include proc_service.h before thread_db.h.
-
-	* thread_db.h: It's TD_NOLIBTHREAD, not TD_LIBTHREAD.
-	* td_ta_new.c: Likewise.
-
-1999-10-14  Ulrich Drepper  <drepper@cygnus.com>
-
-	* td_ta_new.c: p_startfct does not exist anymore.
-
-	* td_thr_get_info.c: Always initialize start function.
-
-	* td_ta_thr_iter.c: Don't return threads which exited (but are not
-	joined).
-
-	* td_thr_validate.c: Don't skip manager thread.
-
-1999-10-13  Ulrich Drepper  <drepper@cygnus.com>
-
-	* td_ta_thr_iter.c: Use size of descriptor from *TA.
-	Don't return manager thread before it's actually running.
-	Actually use state parameter to distingusih at least a few states.
-
-	* td_thr_get_info.c: Handle manager thread special.  Fill in ti_lid,
-	ti_state, and ti_startfunc fields.
-
-1999-10-12  Andreas Jaeger  <aj@suse.de>
-
-	* thread_dbP.h: Include <string.h> for strlen declaration.  Remove
-	__libc_write prototype since this is already declared in
-	linuxthreads/internals.h.
-
-1999-10-11  Ulrich Drepper  <drepper@cygnus.com>
-
-	* thread_db.h: Fix comment for ti_type.
-
-	* td_thr_get_info.c: Initialize ti_type field.
-
-	* td_ta_thr_iter.c: Also report the manager thread.
-
-1999-10-08  Andreas Jaeger  <aj@suse.de>
-
-	* thread_db.h: Fix typos in comments.
-
-	* td_ta_get_nthreads.c (td_ta_get_nthreads): Don't hardcode
-	libpthread library name, get it from <gnu/lib-names.h> instead.
-	* td_ta_new.c (td_ta_new): Likewise.
-
-1999-10-08  Ulrich Drepper  <drepper@cygnus.com>
-
-	* shlib-versions: New file.
-
-1999-10-07  Ulrich Drepper  <drepper@cygnus.com>
-
-	* Makefile: New file.
-	* proc_service.h: New file.
-	* td_init.c: New file.
-	* td_log.c: New file.
-	* td_ta_delete.c: New file.
-	* td_ta_enable_stats.c: New file.
-	* td_ta_event_addr.c: New file.
-	* td_ta_get_nthreads.c: New file.
-	* td_ta_get_ph.c: New file.
-	* td_ta_get_stats.c: New file.
-	* td_ta_map_id2thr.c: New file.
-	* td_ta_map_lwp2thr.c: New file.
-	* td_ta_new.c: New file.
-	* td_ta_reset_stats.c: New file.
-	* td_ta_setconcurrency.c: New file.
-	* td_ta_thr_iter.c: New file.
-	* td_ta_tsd_iter.c: New file.
-	* td_thr_clear_event.c: New file.
-	* td_thr_dbresume.c: New file.
-	* td_thr_dbsuspend.c: New file.
-	* td_thr_event_enable.c: New file.
-	* td_thr_event_getmsg.c: New file.
-	* td_thr_get_info.c: New file.
-	* td_thr_getfpregs.c: New file.
-	* td_thr_getgregs.c: New file.
-	* td_thr_getxregs.c: New file.
-	* td_thr_getxregsize.c: New file.
-	* td_thr_set_event.c: New file.
-	* td_thr_setfpregs.c: New file.
-	* td_thr_setgregs.c: New file.
-	* td_thr_setprio.c: New file.
-	* td_thr_setsigpending.c: New file.
-	* td_thr_setxregs.c: New file.
-	* td_thr_sigsetmask.c: New file.
-	* td_thr_tsd.c: New file.
-	* td_thr_validate.c: New file.
-	* thread_db.h: New file.
-	* thread_dbP.h: New file.
diff --git a/libpthread/linuxthreads_db/Makefile.in b/libpthread/linuxthreads_db/Makefile.in
index 52cc7c838..cf0ceb394 100644
--- a/libpthread/linuxthreads_db/Makefile.in
+++ b/libpthread/linuxthreads_db/Makefile.in
@@ -5,10 +5,10 @@
 # Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
 #
 
-subdirs += libpthread/linuxthreads_db
+subdirs += libpthread/linuxthreads.old_db
 
 # Get the thread include dependencies and shared object name
-CFLAGS-libpthread/linuxthreads_db := -DNOT_IN_libc -DLIBPTHREAD_SO="\"libpthread.so.$(ABI_VERSION)\""
+CFLAGS-libpthread/linuxthreads.old_db := -DNOT_IN_libc -DLIBPTHREAD_SO="\"libpthread.so.$(ABI_VERSION)\""
 
 LDFLAGS-libthread_db.so := $(LDFLAGS_NOSTRIP) $(if $(call check_ld,--warn-unresolved-symbols),-Wl$(comma)--warn-unresolved-symbols)
 ifeq ($(DOSTRIP),y)
@@ -19,8 +19,8 @@ LIBS-libthread_db.so := $(LIBS)
 
 libthread_db_FULL_NAME := libthread_db-$(VERSION).so
 
-libthread_db_DIR := $(top_srcdir)libpthread/linuxthreads_db
-libthread_db_OUT := $(top_builddir)libpthread/linuxthreads_db
+libthread_db_DIR := $(top_srcdir)libpthread/linuxthreads.old_db
+libthread_db_OUT := $(top_builddir)libpthread/linuxthreads.old_db
 
 libthread_db_SRC := $(wildcard $(libthread_db_DIR)/*.c)
 
@@ -68,11 +68,11 @@ linuxthreads_db_headers := $(top_builddir)include/thread_db.h
 $(linuxthreads_db_headers): $(wildcard $(addprefix $(top_builddir)include/config/linuxthreads/,old.h new.h))
 headers-$(PTHREADS_DEBUG_SUPPORT) += $(linuxthreads_db_headers)
 
-objclean-y += CLEAN_libpthread/linuxthreads_db
-headers_clean-y += HEADERCLEAN_libpthread/linuxthreads_db
+objclean-y += CLEAN_libpthread/linuxthreads.old_db
+headers_clean-y += HEADERCLEAN_libpthread/linuxthreads.old_db
 
-HEADERCLEAN_libpthread/linuxthreads_db:
+HEADERCLEAN_libpthread/linuxthreads.old_db:
 	$(do_rm) $(linuxthreads_db_headers)
 
-CLEAN_libpthread/linuxthreads_db:
+CLEAN_libpthread/linuxthreads.old_db:
 	$(do_rm) $(addprefix $(libthread_db_OUT)/*., o os oS a)
diff --git a/libpthread/linuxthreads_db/Makefile.old b/libpthread/linuxthreads_db/Makefile.old
deleted file mode 100644
index 014ddf835..000000000
--- a/libpthread/linuxthreads_db/Makefile.old
+++ /dev/null
@@ -1,56 +0,0 @@
-# Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
-# This file is part of the GNU C Library.
-
-# The GNU C Library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation; either
-# version 2.1 of the License, or (at your option) any later version.
-
-# The GNU C Library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-
-# You should have received a copy of the GNU Lesser General Public
-# License along with the GNU C Library; see the file COPYING.LIB.  If
-# not, see <http://www.gnu.org/licenses/>.
-
-# Makefile for linuxthreads debug library subdirectory of GNU C Library.
-
-subdir		:= linuxthreads_db
-
-linuxthreads_db-version = 1.0
-
-extra-libs = libthread_db
-extra-libs-others := $(extra-libs)
-
-headers		= thread_db.h
-libthread_db-routines = td_init td_log td_ta_delete td_ta_get_nthreads      \
-			td_ta_get_ph td_ta_map_id2thr td_ta_map_lwp2thr     \
-			td_ta_new td_ta_thr_iter td_ta_tsd_iter		    \
-			td_thr_get_info td_thr_getfpregs td_thr_getgregs    \
-			td_thr_getxregs td_thr_getxregsize td_thr_setfpregs \
-			td_thr_setgregs td_thr_setprio td_thr_setsigpending \
-			td_thr_setxregs td_thr_sigsetmask td_thr_tsd	    \
-			td_thr_validate td_thr_dbsuspend td_thr_dbresume    \
-			td_ta_setconcurrency td_ta_enable_stats		    \
-			td_ta_reset_stats td_ta_get_stats td_ta_event_addr  \
-			td_thr_event_enable td_thr_set_event 		    \
-			td_thr_clear_event td_thr_event_getmsg		    \
-			td_ta_set_event td_ta_event_getmsg		    \
-			td_ta_clear_event td_symbol_list \
-			td_thr_tlsbase td_thr_tls_get_addr
-
-libthread_db-inhibit-o = $(filter-out .os,$(object-suffixes))
-
-# The ps_* callback functions are not defined.
-libthread_db.so-no-z-defs = yes
-
-distribute = thread_dbP.h shlib-versions proc_service.h
-include ../Rules
-
-# Depend on libc.so so a DT_NEEDED is generated in the shared objects.
-# This ensures they will load libc.so for needed symbols if loaded by
-# a statically-linked program that hasn't already loaded it.
-$(objpfx)libthread_db.so: $(common-objpfx)libc.so \
-			  $(common-objpfx)libc_nonshared.a
diff --git a/libpthread/linuxthreads_db/shlib-versions b/libpthread/linuxthreads_db/shlib-versions
deleted file mode 100644
index 592f7fa28..000000000
--- a/libpthread/linuxthreads_db/shlib-versions
+++ /dev/null
@@ -1,2 +0,0 @@
-# The thread debug library
-.*-.*-linux.*		libthread_db=1
diff --git a/libpthread/linuxthreads_db/td_init.c b/libpthread/linuxthreads_db/td_init.c
index 1edf53d3a..ecb0d3de2 100644
--- a/libpthread/linuxthreads_db/td_init.c
+++ b/libpthread/linuxthreads_db/td_init.c
@@ -1,5 +1,5 @@
 /* Initialization function of thread debugger support library.
-   Copyright (C) 1999, 2001, 2006 Free Software Foundation, Inc.
+   Copyright (C) 1999, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1999.
 
@@ -23,7 +23,6 @@
 int __td_debug;
 #endif
 
-
 td_err_e
 td_init (void)
 {
diff --git a/libpthread/linuxthreads_db/td_ta_clear_event.c b/libpthread/linuxthreads_db/td_ta_clear_event.c
index d912e4478..e827b46ae 100644
--- a/libpthread/linuxthreads_db/td_ta_clear_event.c
+++ b/libpthread/linuxthreads_db/td_ta_clear_event.c
@@ -21,7 +21,7 @@
 
 
 td_err_e
-td_ta_clear_event(const td_thragent_t *ta, td_thr_events_t *event)
+td_ta_clear_event(const td_thragent_t *ta,td_thr_events_t *event)
 {
   td_thr_events_t old_event;
   int i;
diff --git a/libpthread/linuxthreads_db/td_ta_event_getmsg.c b/libpthread/linuxthreads_db/td_ta_event_getmsg.c
index c23d9264f..b7c2fcd72 100644
--- a/libpthread/linuxthreads_db/td_ta_event_getmsg.c
+++ b/libpthread/linuxthreads_db/td_ta_event_getmsg.c
@@ -21,7 +21,6 @@
 #include <string.h>
 
 #include "thread_dbP.h"
-#include <linuxthreads/internals.h>
 
 
 td_err_e
diff --git a/libpthread/linuxthreads_db/td_ta_map_id2thr.c b/libpthread/linuxthreads_db/td_ta_map_id2thr.c
index a90286865..dc24533b8 100644
--- a/libpthread/linuxthreads_db/td_ta_map_id2thr.c
+++ b/libpthread/linuxthreads_db/td_ta_map_id2thr.c
@@ -18,7 +18,6 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include "thread_dbP.h"
-#include <linuxthreads/internals.h>
 
 
 td_err_e
diff --git a/libpthread/linuxthreads_db/td_ta_map_lwp2thr.c b/libpthread/linuxthreads_db/td_ta_map_lwp2thr.c
index d8f2254fe..00efc43d6 100644
--- a/libpthread/linuxthreads_db/td_ta_map_lwp2thr.c
+++ b/libpthread/linuxthreads_db/td_ta_map_lwp2thr.c
@@ -18,7 +18,6 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include "thread_dbP.h"
-#include <linuxthreads/internals.h>
 
 
 td_err_e
diff --git a/libpthread/linuxthreads_db/td_ta_set_event.c b/libpthread/linuxthreads_db/td_ta_set_event.c
index 25330b952..3a75e7b7f 100644
--- a/libpthread/linuxthreads_db/td_ta_set_event.c
+++ b/libpthread/linuxthreads_db/td_ta_set_event.c
@@ -21,7 +21,7 @@
 
 
 td_err_e
-td_ta_set_event(const td_thragent_t *ta, td_thr_events_t *event)
+td_ta_set_event(const td_thragent_t *ta,td_thr_events_t *event)
 {
   td_thr_events_t old_event;
   int i;
diff --git a/libpthread/linuxthreads_db/td_ta_thr_iter.c b/libpthread/linuxthreads_db/td_ta_thr_iter.c
index 35a2e7834..da230096f 100644
--- a/libpthread/linuxthreads_db/td_ta_thr_iter.c
+++ b/libpthread/linuxthreads_db/td_ta_thr_iter.c
@@ -18,7 +18,6 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include "thread_dbP.h"
-#include <linuxthreads/internals.h>
 #include <alloca.h>
 
 static int
@@ -39,9 +38,7 @@ handle_descr (const td_thragent_t *ta, td_thr_iter_f *callback,
 	  memset (&pds, '\0', sizeof (pds));
 
 	  /* Empty thread descriptor the thread library would create.  */
-#if !defined __UCLIBC_HAS_TLS__ || !TLS_DTV_AT_TP
-	  pds.p_header.data.self = &pds;
-#endif
+	  pds.p_self = &pds;
 	  pds.p_nextlive = pds.p_prevlive = &pds;
 	  pds.p_tid = PTHREAD_THREADS_MAX;
 	  /* The init code also sets up p_lock, p_errnop, p_herrnop, and
diff --git a/libpthread/linuxthreads_db/td_ta_tsd_iter.c b/libpthread/linuxthreads_db/td_ta_tsd_iter.c
index eb428bf12..758222cd7 100644
--- a/libpthread/linuxthreads_db/td_ta_tsd_iter.c
+++ b/libpthread/linuxthreads_db/td_ta_tsd_iter.c
@@ -18,7 +18,6 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include "thread_dbP.h"
-#include <linuxthreads/internals.h>
 #include <alloca.h>
 
 td_err_e
diff --git a/libpthread/linuxthreads_db/td_thr_clear_event.c b/libpthread/linuxthreads_db/td_thr_clear_event.c
index 9674f9f0f..67a592a10 100644
--- a/libpthread/linuxthreads_db/td_thr_clear_event.c
+++ b/libpthread/linuxthreads_db/td_thr_clear_event.c
@@ -23,7 +23,7 @@
 
 
 td_err_e
-td_thr_clear_event(const td_thrhandle_t *th, td_thr_events_t *event)
+td_thr_clear_event(const td_thrhandle_t *th,td_thr_events_t *event)
 {
   td_thr_events_t old_event;
   int i;
diff --git a/libpthread/linuxthreads_db/td_thr_tls_get_addr.c b/libpthread/linuxthreads_db/td_thr_tls_get_addr.c
index 892acba6b..ac4d706c4 100644
--- a/libpthread/linuxthreads_db/td_thr_tls_get_addr.c
+++ b/libpthread/linuxthreads_db/td_thr_tls_get_addr.c
@@ -20,24 +20,48 @@
 #include <link.h>
 #include "thread_dbP.h"
 
+/* Value used for dtv entries for which the allocation is delayed.  */
+# define TLS_DTV_UNALLOCATED	((void *) -1l)
+
+
 td_err_e
 td_thr_tls_get_addr (const td_thrhandle_t *th __attribute__ ((unused)),
 		     void *map_address __attribute__ ((unused)),
 		     size_t offset __attribute__ ((unused)),
 		     void **address __attribute__ ((unused)))
 {
-#ifdef __UCLIBC_HAS_TLS__
-  /* Read the module ID from the link_map.  */
+#if defined(USE_TLS) && USE_TLS
   size_t modid;
+  union dtv pdtv, *dtvp;
+
+  LOG ("td_thr_tls_get_addr");
+
+  /* Get the DTV pointer from the thread descriptor.  */
+  if (ps_pdread (th->th_ta_p->ph,
+		 &((struct _pthread_descr_struct *) th->th_unique)->p_header.data.dtvp,
+		 &dtvp, sizeof dtvp) != PS_OK)
+    return TD_ERR;	/* XXX Other error value?  */
+
+  /* Read the module ID from the link_map.  */
   if (ps_pdread (th->th_ta_p->ph,
 		 &((struct link_map *) map_address)->l_tls_modid,
 		 &modid, sizeof modid) != PS_OK)
     return TD_ERR;	/* XXX Other error value?  */
 
-  td_err_e result = td_thr_tlsbase (th, modid, address);
-  if (result == TD_OK)
-    *address += offset;
-  return result;
+  /* Get the corresponding entry in the DTV.  */
+  if (ps_pdread (th->th_ta_p->ph, dtvp + modid,
+		 &pdtv, sizeof (union dtv)) != PS_OK)
+    return TD_ERR;	/* XXX Other error value?  */
+
+  /* It could be that the memory for this module is not allocated for
+     the given thread.  */
+  if (pdtv.pointer == TLS_DTV_UNALLOCATED)
+    /* There is not much we can do.  */
+    return TD_NOTALLOC;
+
+  *address = (char *) pdtv.pointer + offset;
+
+  return TD_OK;
 #else
   return TD_ERR;
 #endif
diff --git a/libpthread/linuxthreads_db/td_thr_tlsbase.c b/libpthread/linuxthreads_db/td_thr_tlsbase.c
deleted file mode 100644
index ac86c42fe..000000000
--- a/libpthread/linuxthreads_db/td_thr_tlsbase.c
+++ /dev/null
@@ -1,70 +0,0 @@
-/* Locate TLS data for a thread.
-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "thread_dbP.h"
-
-/* Value used for dtv entries for which the allocation is delayed.  */
-# define TLS_DTV_UNALLOCATED	((void *) -1l)
-
-td_err_e
-td_thr_tlsbase (const td_thrhandle_t *th,
-		unsigned long int modid,
-		psaddr_t *base)
-{
-  if (modid < 1)
-    return TD_NOTLS;
-
-#ifdef __UCLIBC_HAS_TLS__
-  union dtv pdtv, *dtvp;
-
-  LOG ("td_thr_tlsbase");
-
-  psaddr_t dtvpp = th->th_unique;
-#if defined(TLS_TCB_AT_TP)
-  dtvpp += offsetof (struct _pthread_descr_struct, p_header.data.dtvp);
-#elif defined(TLS_DTV_AT_TP)
-/* Special case hack.  If TLS_TCB_SIZE == 0 (on PowerPC), there is no TCB
-   containing the DTV at the TP, but actually the TCB lies behind the TP,
-   i.e. at the very end of the area covered by TLS_PRE_TCB_SIZE.  */
-  dtvpp += TLS_PRE_TCB_SIZE + offsetof (tcbhead_t, dtv)
-	   - (TLS_TCB_SIZE == 0 ? sizeof (tcbhead_t) : 0);
-#else
-# error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined."
-#endif
-
-  /* Get the DTV pointer from the thread descriptor.  */
-  if (ps_pdread (th->th_ta_p->ph, dtvpp, &dtvp, sizeof dtvp) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* Get the corresponding entry in the DTV.  */
-  if (ps_pdread (th->th_ta_p->ph, dtvp + modid,
-		 &pdtv, sizeof (union dtv)) != PS_OK)
-    return TD_ERR;	/* XXX Other error value?  */
-
-  /* It could be that the memory for this module is not allocated for
-     the given thread.  */
-  if (pdtv.pointer.val == TLS_DTV_UNALLOCATED)
-    return TD_TLSDEFER;
-
-  *base = (char *) pdtv.pointer.val;
-
-  return TD_OK;
-#else
-  return TD_ERR;
-#endif
-}
diff --git a/libpthread/linuxthreads_db/td_thr_tsd.c b/libpthread/linuxthreads_db/td_thr_tsd.c
index 7b0db6b9d..f18832f46 100644
--- a/libpthread/linuxthreads_db/td_thr_tsd.c
+++ b/libpthread/linuxthreads_db/td_thr_tsd.c
@@ -18,7 +18,6 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include "thread_dbP.h"
-#include <linuxthreads/internals.h>
 
 
 td_err_e
diff --git a/libpthread/linuxthreads_db/td_thr_validate.c b/libpthread/linuxthreads_db/td_thr_validate.c
index 5108ea97d..ca82637b9 100644
--- a/libpthread/linuxthreads_db/td_thr_validate.c
+++ b/libpthread/linuxthreads_db/td_thr_validate.c
@@ -18,7 +18,6 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include "thread_dbP.h"
-#include <linuxthreads/internals.h>
 
 
 td_err_e
diff --git a/libpthread/linuxthreads_db/thread_dbP.h b/libpthread/linuxthreads_db/thread_dbP.h
index 407f30634..64fd2e511 100644
--- a/libpthread/linuxthreads_db/thread_dbP.h
+++ b/libpthread/linuxthreads_db/thread_dbP.h
@@ -6,7 +6,7 @@
 #include <unistd.h>
 #include "proc_service.h"
 #include "thread_db.h"
-#include "../linuxthreads/descr.h"
+#include "internals.h"
 
 
 /* Indices for the symbol names.  */