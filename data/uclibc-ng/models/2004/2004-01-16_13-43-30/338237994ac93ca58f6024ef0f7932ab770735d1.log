"2004-01-16 13:43:30 +0000"
diff --git a/Makefile b/Makefile
index 677e1642c..df2522395 100644
--- a/Makefile
+++ b/Makefile
@@ -121,7 +121,7 @@ include/bits/uClibc_config.h: .config
 	@./extra/config/conf -o extra/Configs/Config.in
 
 headers: include/bits/uClibc_config.h
-ifeq ($(strip $(UCLIBC_HAS_MMU)),y)
+ifeq ($(strip $(ARCH_HAS_MMU)),y)
 	@set -x; ./extra/scripts/fix_includes.sh -k $(KERNEL_SOURCE) -t $(TARGET_ARCH)
 else
 	@set -x; ./extra/scripts/fix_includes.sh -k $(KERNEL_SOURCE) -t $(TARGET_ARCH) -n
diff --git a/extra/Configs/Config.alpha b/extra/Configs/Config.alpha
index bf83798a5..64c2ad1d8 100644
--- a/extra/Configs/Config.alpha
+++ b/extra/Configs/Config.alpha
@@ -4,7 +4,7 @@
 #
 
 config HAVE_ELF
-	select UCLIBC_HAS_MMU
+	select ARCH_HAS_MMU
 	select HAVE_NO_SHARED
 	select ARCH_HAS_NO_LDSO
 	select HAS_NO_THREADS
diff --git a/extra/Configs/Config.cris b/extra/Configs/Config.cris
index 716f46841..956ee8e0f 100644
--- a/extra/Configs/Config.cris
+++ b/extra/Configs/Config.cris
@@ -34,7 +34,7 @@ choice
 		- CRIS  Generic support for Axis' CRIS architecture.
 
 config CONFIG_CRIS
-	select UCLIBC_HAS_MMU
+	select ARCH_HAS_MMU
 	bool "CRIS"
 
 endchoice
diff --git a/extra/Configs/Config.i386 b/extra/Configs/Config.i386
index cab2d332f..33e48ef7a 100644
--- a/extra/Configs/Config.i386
+++ b/extra/Configs/Config.i386
@@ -5,7 +5,7 @@
 
 config HAVE_ELF
 	bool
-	select UCLIBC_HAS_MMU
+	select ARCH_HAS_MMU
 	default y
 
 config TARGET_ARCH
diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
index e175a5909..8ad0073c3 100644
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -312,8 +312,8 @@ config UCLIBC_HAS_LFS
 
 choice
 	prompt "Malloc Implementation"
-	default MALLOC if ! UCLIBC_HAS_MMU
-	default MALLOC_STANDARD if UCLIBC_HAS_MMU
+	default MALLOC if ! ARCH_HAS_MMU
+	default MALLOC_STANDARD if ARCH_HAS_MMU
 	help
 	  "malloc" use mmap for all allocations and so works very well on MMU-less
 	  systems that do not support the brk() system call.   It is pretty smart
@@ -342,7 +342,7 @@ config MALLOC_SIMPLE
 
 config MALLOC_STANDARD
 	bool "malloc-standard"
-	depends on UCLIBC_HAS_MMU
+	depends on ARCH_HAS_MMU
 
 endchoice
 
diff --git a/extra/Configs/Config.in.arch b/extra/Configs/Config.in.arch
index 6e4044934..4a7a7abe7 100644
--- a/extra/Configs/Config.in.arch
+++ b/extra/Configs/Config.in.arch
@@ -23,7 +23,7 @@ config ARCH_HAS_NO_MMU
 	bool
 	default n
 
-config UCLIBC_HAS_MMU
+config ARCH_HAS_MMU
 	bool "Target CPU has a memory management unit (MMU)"
 	default y
 	depends !ARCH_HAS_NO_MMU
@@ -100,12 +100,12 @@ config KERNEL_SOURCE
 
 config UCLIBC_UCLINUX_BROKEN_MUNMAP
 	bool
-	depends on !UCLIBC_HAS_MMU
+	depends on !ARCH_HAS_MMU
 	default y
 
 config EXCLUDE_BRK
 	bool
-	depends on !UCLIBC_HAS_MMU
+	depends on !ARCH_HAS_MMU
 	default y
 
 config C_SYMBOL_PREFIX
diff --git a/extra/Configs/Config.powerpc b/extra/Configs/Config.powerpc
index 6c6911c42..e18caa002 100644
--- a/extra/Configs/Config.powerpc
+++ b/extra/Configs/Config.powerpc
@@ -8,7 +8,7 @@ config TARGET_ARCH
 
 config HAVE_ELF
 	bool
-	select UCLIBC_HAS_MMU
+	select ARCH_HAS_MMU
 	default y
 
 config ARCH_SUPPORTS_BIG_ENDIAN
diff --git a/extra/Configs/Config.sh b/extra/Configs/Config.sh
index 79a2ee442..a712539d3 100644
--- a/extra/Configs/Config.sh
+++ b/extra/Configs/Config.sh
@@ -53,16 +53,16 @@ config CONFIG_SH2
 	bool "SH2"
 
 config CONFIG_SH3
-	select UCLIBC_HAS_MMU
+	select ARCH_HAS_MMU
 	bool "SH3"
 
 config CONFIG_SH4
-	select UCLIBC_HAS_MMU
+	select ARCH_HAS_MMU
 	select FORCE_SHAREABLE_TEXT_SEGMENTS
 	bool "SH4"
 
 config CONFIG_SH5
-	select UCLIBC_HAS_MMU
+	select ARCH_HAS_MMU
 	select UCLIBC_HAS_LFS
 	bool "SH5"
 
diff --git a/libc/inet/rpc/rcmd.c b/libc/inet/rpc/rcmd.c
index f1c732d41..cf839f4c6 100644
--- a/libc/inet/rpc/rcmd.c
+++ b/libc/inet/rpc/rcmd.c
@@ -94,7 +94,7 @@ int rcmd(ahost, rport, locuser, remuser, cmd, fd2p)
 
 #ifdef __UCLIBC_HAS_THREADS__
 	hstbuflen = 1024;
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 	tmphstbuf = alloca (hstbuflen);
 #else
 	tmphstbuf = malloc (hstbuflen);
@@ -106,7 +106,7 @@ int rcmd(ahost, rport, locuser, remuser, cmd, fd2p)
 	    if (herr != NETDB_INTERNAL || errno != ERANGE)
 	    {
 		__set_h_errno (herr);
-#ifndef __UCLIBC_HAS_MMU__
+#ifndef __ARCH_HAS_MMU__
 		free(tmphstbuf);
 #endif
 		herror(*ahost);
@@ -116,7 +116,7 @@ int rcmd(ahost, rport, locuser, remuser, cmd, fd2p)
 	    {
 		/* Enlarge the buffer.  */
 		hstbuflen *= 2;
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 		tmphstbuf = alloca (hstbuflen);
 #else
 		if (tmphstbuf) {
@@ -126,7 +126,7 @@ int rcmd(ahost, rport, locuser, remuser, cmd, fd2p)
 #endif
 	    }
 	}
-#ifndef __UCLIBC_HAS_MMU__
+#ifndef __ARCH_HAS_MMU__
 	free(tmphstbuf);
 #endif
 #else /* call the non-reentrant version */
@@ -308,7 +308,7 @@ int ruserok(rhost, superuser, ruser, luser)
 
 #ifdef __UCLIBC_HAS_THREADS__
 	buflen = 1024;
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 	buffer = alloca (buflen);
 #else
 	buffer = malloc (buflen);
@@ -318,7 +318,7 @@ int ruserok(rhost, superuser, ruser, luser)
 		    buflen, &hp, &herr) != 0 || hp == NULL) 
 	{
 	    if (herr != NETDB_INTERNAL || errno != ERANGE) {
-#ifndef __UCLIBC_HAS_MMU__
+#ifndef __ARCH_HAS_MMU__
 		free(buffer);
 #endif
 		return -1;
@@ -326,7 +326,7 @@ int ruserok(rhost, superuser, ruser, luser)
 	    {
 		/* Enlarge the buffer.  */
 		buflen *= 2;
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 		buffer = alloca (buflen);
 #else
 		if (buffer) {
@@ -336,7 +336,7 @@ int ruserok(rhost, superuser, ruser, luser)
 #endif
 	    }
 	}
-#ifndef __UCLIBC_HAS_MMU__
+#ifndef __ARCH_HAS_MMU__
 	free(buffer);
 #endif
 #else
@@ -435,7 +435,7 @@ iruserok2 (raddr, superuser, ruser, luser, rhost)
 #ifdef __UCLIBC_HAS_THREADS__
 		size_t buflen = sysconf (_SC_GETPW_R_SIZE_MAX);
 		struct passwd pwdbuf;
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 		char *buffer = alloca (buflen);
 #else
 		char *buffer = malloc (buflen);
@@ -444,12 +444,12 @@ iruserok2 (raddr, superuser, ruser, luser, rhost)
 		if (getpwnam_r (luser, &pwdbuf, buffer, 
 			    buflen, &pwd) != 0 || pwd == NULL)
 		{
-#ifndef __UCLIBC_HAS_MMU__
+#ifndef __ARCH_HAS_MMU__
 			free(buffer);
 #endif
 			return -1;
 		}
-#ifndef __UCLIBC_HAS_MMU__
+#ifndef __ARCH_HAS_MMU__
 		free(buffer);
 #endif
 #else
diff --git a/libc/stdlib/malloc-simple/alloc.c b/libc/stdlib/malloc-simple/alloc.c
index 4c6edd1f9..c0f702676 100644
--- a/libc/stdlib/malloc-simple/alloc.c
+++ b/libc/stdlib/malloc-simple/alloc.c
@@ -31,7 +31,7 @@ void *malloc(size_t size)
 #endif
     }
 
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
     result = mmap((void *) 0, size + sizeof(size_t), PROT_READ | PROT_WRITE,
 	    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
     if (result == MAP_FAILED)
@@ -88,7 +88,7 @@ void *realloc(void *ptr, size_t size)
     newptr = malloc(size);
     if (newptr) {
 	memcpy(newptr, ptr,
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 		*((size_t *) (ptr - sizeof(size_t)))
 #else
 		size
@@ -111,7 +111,7 @@ void free(void *ptr)
 	    return;
 	}
     }
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
     ptr -= sizeof(size_t);
     munmap(ptr, * (size_t *) ptr + sizeof(size_t));
 #else
@@ -154,7 +154,7 @@ int __libc_free_aligned(void *ptr)
 	    /* Mark the block as free */
 	    l->aligned = NULL;
 	    ptr = l->exact;
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 	    ptr -= sizeof(size_t);
 	    munmap(ptr, * (size_t *) ptr + sizeof(size_t));
 #else
diff --git a/libc/stdlib/malloc/malloc.h b/libc/stdlib/malloc/malloc.h
index e5010d49b..37afe7299 100644
--- a/libc/stdlib/malloc/malloc.h
+++ b/libc/stdlib/malloc/malloc.h
@@ -43,7 +43,7 @@
    heap, instead of mmap/munmap.  This is a tradeoff -- sbrk is faster than
    mmap/munmap, and guarantees contiguous allocation, but is also less
    flexible, and causes the heap to only be shrinkable from the end.  */
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 # define MALLOC_USE_SBRK
 #endif
 
diff --git a/libc/sysdeps/linux/arm/crt0.S b/libc/sysdeps/linux/arm/crt0.S
index cbf81504b..84bc8cd74 100644
--- a/libc/sysdeps/linux/arm/crt0.S
+++ b/libc/sysdeps/linux/arm/crt0.S
@@ -69,7 +69,7 @@ _start:
 	/* clear the frame pointer */
 	mov     fp, #0
 
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 	/* Load register r0 (argc) from the stack to its final resting place */
 	ldr     r0, [sp], #4
 
diff --git a/libc/sysdeps/linux/common/bits/posix_opt.h b/libc/sysdeps/linux/common/bits/posix_opt.h
index 73fa007d2..9329dfc15 100644
--- a/libc/sysdeps/linux/common/bits/posix_opt.h
+++ b/libc/sysdeps/linux/common/bits/posix_opt.h
@@ -39,21 +39,21 @@
 #define	_POSIX_MAPPED_FILES	1
 
 /* Locking of all memory is supported.  */
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 # define	_POSIX_MEMLOCK	1
 #else
 # undef		_POSIX_MEMLOCK
 #endif
 
 /* Locking of ranges of memory is supported.  */
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 # define	_POSIX_MEMLOCK_RANGE	1
 #else
 # define	_POSIX_MEMLOCK_RANGE
 #endif
 
 /* Setting of memory protections is supported.  */
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 # define	_POSIX_MEMORY_PROTECTION	1
 #else
 # undef		_POSIX_MEMORY_PROTECTION
diff --git a/libc/sysdeps/linux/common/syscalls.c b/libc/sysdeps/linux/common/syscalls.c
index 327b30c56..882de8106 100644
--- a/libc/sysdeps/linux/common/syscalls.c
+++ b/libc/sysdeps/linux/common/syscalls.c
@@ -43,7 +43,7 @@
 //#define __NR_fork             2
 #ifdef L___libc_fork
 #include <unistd.h>
-#	ifdef __UCLIBC_HAS_MMU__
+#	ifdef __ARCH_HAS_MMU__
 #define __NR___libc_fork __NR_fork
 		_syscall0(pid_t, __libc_fork);
 #	else
@@ -1131,7 +1131,7 @@ _syscall2(int, fstatfs, int, fd, struct statfs *, buf);
 
 //#define __NR_ioperm           101
 #ifdef L_ioperm
-#	if defined __UCLIBC_HAS_MMU__ && defined __NR_ioperm
+#	if defined __ARCH_HAS_MMU__ && defined __NR_ioperm
 		_syscall3(int, ioperm, unsigned long, from, unsigned long, num, int, turn_on);
 #	else
 		int ioperm(unsigned long from, unsigned long num, int turn_on)
@@ -1256,7 +1256,7 @@ weak_alias(fstat, fstat64);
 /* For arm there is a totally different implementation */
 #if !defined(__arm__)
 /* Tuns out the m68k unistd.h kernel header is broken */
-#	if defined __UCLIBC_HAS_MMU__ && defined __NR_iopl && ( !defined(__mc68000__))
+#	if defined __ARCH_HAS_MMU__ && defined __NR_iopl && ( !defined(__mc68000__))
 		_syscall1(int, iopl, int, level);
 #	else
 		int iopl(int level)
@@ -1610,7 +1610,7 @@ int sysctl(int *name, int nlen, void *oldval, size_t *oldlenp,
 //#define __NR_mlock            150
 #ifdef L_mlock
 #include <sys/mman.h>
-#	if defined __UCLIBC_HAS_MMU__ && defined __NR_mlock
+#	if defined __ARCH_HAS_MMU__ && defined __NR_mlock
 		_syscall2(int, mlock, const void *, addr, size_t, len);
 #	endif	
 #endif	
@@ -1618,7 +1618,7 @@ int sysctl(int *name, int nlen, void *oldval, size_t *oldlenp,
 //#define __NR_munlock          151
 #ifdef L_munlock
 #include <sys/mman.h>
-#	if defined __UCLIBC_HAS_MMU__ && defined __NR_munlock
+#	if defined __ARCH_HAS_MMU__ && defined __NR_munlock
 		_syscall2(int, munlock, const void *, addr, size_t, len);
 #	endif	
 #endif	
@@ -1626,7 +1626,7 @@ int sysctl(int *name, int nlen, void *oldval, size_t *oldlenp,
 //#define __NR_mlockall         152
 #ifdef L_mlockall
 #include <sys/mman.h>
-#	if defined __UCLIBC_HAS_MMU__ && defined __NR_mlockall
+#	if defined __ARCH_HAS_MMU__ && defined __NR_mlockall
 		_syscall1(int, mlockall, int, flags);
 #	endif	
 #endif	
@@ -1634,7 +1634,7 @@ int sysctl(int *name, int nlen, void *oldval, size_t *oldlenp,
 //#define __NR_munlockall       153
 #ifdef L_munlockall
 #include <sys/mman.h>
-#	if defined __UCLIBC_HAS_MMU__ && defined L_munlockall
+#	if defined __ARCH_HAS_MMU__ && defined L_munlockall
 		_syscall0(int, munlockall);
 #	endif	
 #endif	
diff --git a/libc/sysdeps/linux/m68k/Makefile b/libc/sysdeps/linux/m68k/Makefile
index f4d6d1527..b769954e0 100644
--- a/libc/sysdeps/linux/m68k/Makefile
+++ b/libc/sysdeps/linux/m68k/Makefile
@@ -23,7 +23,7 @@ ASFLAGS=$(CFLAGS)
 # If you're looking for vfork(), it is defined in include/unistd.h
 
 
-ifeq ($(UCLIBC_HAS_MMU),y)
+ifeq ($(ARCH_HAS_MMU),y)
 CRT0_SRC = crt0.c
 else
 CRT0_SRC = crt0.S
diff --git a/libc/unistd/Makefile b/libc/unistd/Makefile
index 53ffb6a9c..290d71a52 100644
--- a/libc/unistd/Makefile
+++ b/libc/unistd/Makefile
@@ -27,7 +27,7 @@ CSRC=	sleep.c usleep.c getpass.c sysconf.c getlogin.c \
 	fpathconf.c confstr.c pathconf.c swab.c usershell.c \
 	getsubopt.c
 
-ifeq ($(strip $(UCLIBC_HAS_MMU)),y)
+ifeq ($(strip $(ARCH_HAS_MMU)),y)
 	CSRC += daemon.c
 else
 	MOBJ1 += __exec_alloc.o
diff --git a/libc/unistd/daemon.c b/libc/unistd/daemon.c
index d4c2e0448..91ae4056f 100644
--- a/libc/unistd/daemon.c
+++ b/libc/unistd/daemon.c
@@ -30,7 +30,7 @@
 #include <unistd.h>
 
 /* Note that this file should not be compiled in 
- * unless __UCLIBC_HAS_MMU__ is defined */
+ * unless __ARCH_HAS_MMU__ is defined */
 
 int daemon( int nochdir, int noclose )
 {
diff --git a/libc/unistd/exec.c b/libc/unistd/exec.c
index fa1eda2b9..666a8192b 100644
--- a/libc/unistd/exec.c
+++ b/libc/unistd/exec.c
@@ -41,7 +41,7 @@
 extern char *__strchrnul(const char *s, int c);
 
 /**********************************************************************/
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 
 /* We have an MMU, so use alloca() to grab space for buffers and
  * arg lists. */
@@ -69,7 +69,7 @@ extern void __exec_free(void *ptr, size_t size);
 /**********************************************************************/
 #ifdef L___exec_alloc
 
-#ifndef __UCLIBC_HAS_MMU__
+#ifndef __ARCH_HAS_MMU__
 
 void *__exec_alloc(size_t size)
 {
diff --git a/libpthread/linuxthreads/internals.h b/libpthread/linuxthreads/internals.h
index bce6b7efe..bd362642b 100644
--- a/libpthread/linuxthreads/internals.h
+++ b/libpthread/linuxthreads/internals.h
@@ -257,12 +257,12 @@ extern pthread_descr __pthread_main_thread;
  * the bounds a-priori. -StS */
 
 extern char *__pthread_initial_thread_bos;
-#ifndef __UCLIBC_HAS_MMU__
+#ifndef __ARCH_HAS_MMU__
 extern char *__pthread_initial_thread_tos;
 #define NOMMU_INITIAL_THREAD_BOUNDS(tos,bos) if ((tos)>=__pthread_initial_thread_bos && (bos)<=__pthread_initial_thread_tos) __pthread_initial_thread_bos = (tos)+1
 #else
 #define NOMMU_INITIAL_THREAD_BOUNDS(tos,bos) /* empty */
-#endif /* __UCLIBC_HAS_MMU__ */
+#endif /* __ARCH_HAS_MMU__ */
 
 
 /* Indicate whether at least one thread has a user-defined stack (if 1),
@@ -324,7 +324,7 @@ static inline int invalid_handle(pthread_handle h, pthread_t id)
    THREAD_SELF implementation is used, this must be a power of two and
    a multiple of PAGE_SIZE.  */
 #ifndef STACK_SIZE
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 #define STACK_SIZE  (2 * 1024 * 1024)
 #else
 #define STACK_SIZE  (4 * PAGE_SIZE)
@@ -381,7 +381,7 @@ static inline pthread_descr thread_self (void)
   return THREAD_SELF;
 #else
   char *sp = CURRENT_STACK_FRAME;
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
   if (sp >= __pthread_initial_thread_bos)
     return &__pthread_initial_thread;
   else if (sp >= __pthread_manager_thread_bos
@@ -414,7 +414,7 @@ static inline pthread_descr thread_self (void)
   else {
       return __pthread_find_self();
   }
-#endif /* __UCLIBC_HAS_MMU__ */
+#endif /* __ARCH_HAS_MMU__ */
 #endif
 }
 
diff --git a/libpthread/linuxthreads/manager.c b/libpthread/linuxthreads/manager.c
index f7301bc52..11ec6f18c 100644
--- a/libpthread/linuxthreads/manager.c
+++ b/libpthread/linuxthreads/manager.c
@@ -363,7 +363,7 @@ static int pthread_allocate_stack(const pthread_attr_t *attr,
     }
   else
     {
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
       stacksize = STACK_SIZE - pagesize;
       if (attr != NULL)
         stacksize = MIN (stacksize, roundup(attr->__stacksize, pagesize));
@@ -453,7 +453,7 @@ static int pthread_allocate_stack(const pthread_attr_t *attr,
       /* on non-MMU systems we always have non-standard stack frames */
       __pthread_nonstandard_stacks = 1;
       
-#endif /* __UCLIBC_HAS_MMU__ */
+#endif /* __ARCH_HAS_MMU__ */
     }
 
   /* Clear the thread data structure.  */
@@ -627,14 +627,14 @@ PDEBUG("cloning new_thread = %p\n", new_thread);
     /* Free the stack if we allocated it */
     if (attr == NULL || !attr->__stackaddr_set)
       {
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 	if (new_thread->p_guardsize != 0)
 	  munmap(new_thread->p_guardaddr, new_thread->p_guardsize);
 	munmap((caddr_t)((char *)(new_thread+1) - INITIAL_STACK_SIZE),
 	       INITIAL_STACK_SIZE);
 #else
 	free(new_thread_bottom);
-#endif /* __UCLIBC_HAS_MMU__ */
+#endif /* __ARCH_HAS_MMU__ */
       }
     __pthread_handles[sseg].h_descr = NULL;
     __pthread_handles[sseg].h_bottom = NULL;
@@ -711,7 +711,7 @@ static void pthread_free(pthread_descr th)
 
   /* If initial thread, nothing to free */
   if (th == &__pthread_initial_thread) return;
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
   if (!th->p_userstack)
     {
       /* Free the stack and thread descriptor area */
@@ -724,7 +724,7 @@ static void pthread_free(pthread_descr th)
   if (!th->p_userstack) {
       free(h_bottom_save);
   }
-#endif /* __UCLIBC_HAS_MMU__ */
+#endif /* __ARCH_HAS_MMU__ */
 }
 
 /* Handle threads that have exited */
diff --git a/libpthread/linuxthreads/ptfork.c b/libpthread/linuxthreads/ptfork.c
index 5ed380555..364db7e69 100644
--- a/libpthread/linuxthreads/ptfork.c
+++ b/libpthread/linuxthreads/ptfork.c
@@ -74,7 +74,7 @@ static inline void pthread_call_handlers(struct handler_list * list)
 {
   for (/*nothing*/; list != NULL; list = list->next) (list->handler)();
 }
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
 extern int __libc_fork(void);
 
 pid_t __fork(void)
diff --git a/libpthread/linuxthreads/pthread.c b/libpthread/linuxthreads/pthread.c
index 1c24cccd8..e9ca9aa32 100644
--- a/libpthread/linuxthreads/pthread.c
+++ b/libpthread/linuxthreads/pthread.c
@@ -175,9 +175,9 @@ char *__pthread_initial_thread_bos = NULL;
  * This is adapted when other stacks are malloc'ed since we don't know
  * the bounds a-priori. -StS */
 
-#ifndef __UCLIBC_HAS_MMU__
+#ifndef __ARCH_HAS_MMU__
 char *__pthread_initial_thread_tos = NULL;
-#endif /* __UCLIBC_HAS_MMU__ */
+#endif /* __ARCH_HAS_MMU__ */
 
 /* File descriptor for sending requests to the thread manager. */
 /* Initially -1, meaning that the thread manager is not running. */
@@ -336,7 +336,7 @@ static void pthread_initialize(void)
      beyond STACK_SIZE minus two pages (one page for the thread descriptor
      immediately beyond, and one page to act as a guard page). */
 
-#ifdef __UCLIBC_HAS_MMU__
+#ifdef __ARCH_HAS_MMU__
   /* We cannot allocate a huge chunk of memory to mmap all thread stacks later
    * on a non-MMU system. Thus, we don't need the rlimit either. -StS */
   getrlimit(RLIMIT_STACK, &limit);
@@ -355,7 +355,7 @@ static void pthread_initialize(void)
   __pthread_initial_thread_bos = (char *) 1; /* set it non-zero so we know we have been here */
   PDEBUG("initial thread stack bounds: bos=%p, tos=%p\n",
 	 __pthread_initial_thread_bos, __pthread_initial_thread_tos);
-#endif /* __UCLIBC_HAS_MMU__ */
+#endif /* __ARCH_HAS_MMU__ */
 
   /* Setup signal handlers for the initial thread.
      Since signal handlers are shared between threads, these settings
diff --git a/libutil/Makefile b/libutil/Makefile
index 7ae00f53c..4f819e73e 100644
--- a/libutil/Makefile
+++ b/libutil/Makefile
@@ -30,7 +30,7 @@ LIBUTIL_SHARED=libutil.so
 LIBUTIL_SHARED_FULLNAME=libutil-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so
 
 CSRC=login.c login_tty.c logout.c logwtmp.c openpty.c
-ifeq ($(strip $(UCLIBC_HAS_MMU)),y)
+ifeq ($(strip $(ARCH_HAS_MMU)),y)
     CSRC+=forkpty.c
 endif
 OBJS=$(patsubst %.c,%.o, $(CSRC))