"2004-07-16 11:09:34 +0000"
diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
index b61a1ebfd..b1624dafd 100644
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -44,6 +44,12 @@ config TARGET_microblaze
 config TARGET_mips
 	bool "mips"
 
+config TARGET_nios
+	bool "nios"
+
+config TARGET_nios2
+	bool "nios2"
+
 config TARGET_powerpc
 	bool "powerpc"
 
@@ -97,6 +103,14 @@ if TARGET_m68k
 source "extra/Configs/Config.m68k"
 endif
 
+if TARGET_nios
+source "extra/Configs/Config.nios"
+endif
+
+if TARGET_nios2
+source "extra/Configs/Config.nios2"
+endif
+
 if TARGET_microblaze
 source "extra/Configs/Config.microblaze"
 endif
diff --git a/extra/Configs/Config.nios b/extra/Configs/Config.nios
new file mode 100644
index 000000000..10a5f0a20
--- /dev/null
+++ b/extra/Configs/Config.nios
@@ -0,0 +1,31 @@
+#
+# For a description of the syntax of this configuration file,
+# see extra/config/Kconfig-language.txt
+#
+
+config TARGET_ARCH
+	default "nios"
+
+config HAVE_ELF
+	bool
+	select ARCH_HAS_NO_MMU
+	select ARCH_LITTLE_ENDIAN
+	select HAVE_NO_PIC
+	select HAVE_NO_SHARED
+	select ARCH_HAS_NO_LDSO
+	default y
+
+config ARCH_CFLAGS
+	string
+	default "-m32 -funaligned-struct-hack"
+
+config ARCH_LDFLAGS
+	string
+
+config LIBGCC_CFLAGS
+	string
+
+config CROSS
+        string
+	default nios-elf-
+
diff --git a/extra/Configs/Config.nios2 b/extra/Configs/Config.nios2
new file mode 100644
index 000000000..cc7caf17d
--- /dev/null
+++ b/extra/Configs/Config.nios2
@@ -0,0 +1,30 @@
+#
+# For a description of the syntax of this configuration file,
+# see extra/config/Kconfig-language.txt
+#
+
+config TARGET_ARCH
+	default "nios2"
+
+config HAVE_ELF
+	bool
+	select ARCH_HAS_NO_MMU
+	select ARCH_LITTLE_ENDIAN
+	select HAVE_NO_PIC
+	select HAVE_NO_SHARED
+	select ARCH_HAS_NO_LDSO
+	default y
+
+config ARCH_CFLAGS
+	string
+
+config ARCH_LDFLAGS
+	string
+
+config LIBGCC_CFLAGS
+	string
+
+config CROSS
+    string
+	default nios2-elf-
+
diff --git a/include/elf.h b/include/elf.h
index 7ce1b398e..75042ca94 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -258,6 +258,8 @@ typedef struct
 #define EM_CYGNUS_FRV	0x5441
 
 #define EM_ALPHA	0x9026
+#define EM_NIOS32	0xfebb		/* Altera Nios 32 */
+#define EM_ALTERA_NIOS2  0x9ee5	/* Altera Nios II */
 
 /* V850 backend magic number.  Written in the absense of an ABI.  */
 #define EM_CYGNUS_V850 0x9080
@@ -2554,6 +2556,56 @@ typedef Elf32_Addr Elf32_Conflict;
 #define R_H8_ABS32     65
 #define R_H8_ABS32A16 127
 
+/* Altera NIOS specific definitions.  */
+
+/* NIOS relocations. */
+#define R_NIOS_NONE				0
+#define R_NIOS_32				1	/* A 32 bit absolute relocation.*/
+#define R_NIOS_LO16_LO5			2	/* A LO-16 5 bit absolute relocation.  */
+#define R_NIOS_LO16_HI11		3	/* A LO-16 top 11 bit absolute relocation.  */
+#define R_NIOS_HI16_LO5			4	/* A HI-16 5 bit absolute relocation.  */
+#define R_NIOS_HI16_HI11		5	/* A HI-16 top 11 bit absolute relocation.  */
+#define R_NIOS_PCREL6			6	/* A 6 bit relative relocation.  */
+#define R_NIOS_PCREL8			7	/* An 8 bit relative relocation.  */
+#define R_NIOS_PCREL11			8	/* An 11 bit relative relocation.  */
+#define R_NIOS_16				9	/* A 16 bit absolute relocation.  */
+#define R_NIOS_H_LO5			10	/* Low 5-bits of absolute relocation in halfwords.  */
+#define R_NIOS_H_HI11			11	/* Top 11 bits of 16-bit absolute relocation in halfwords.  */
+#define R_NIOS_H_XLO5			12	/* Low 5 bits of top 16-bits of 32-bit absolute relocation in halfwords.  */
+#define R_NIOS_H_XHI11			13	/* Top 11 bits of top 16-bits of 32-bit absolute relocation in halfwords.  */
+#define R_NIOS_H_16				14	/* Half-word @h value */
+#define R_NIOS_H_32				15	/* Word @h value */
+#define R_NIOS_GNU_VTINHERIT	200	/* GNU extension to record C++ vtable hierarchy */
+#define R_NIOS_GNU_VTENTRY		201	/* GNU extension to record C++ vtable member usage */
+/* Keep this the last entry.  */
+#define R_NIOS_NUM				202
+
+/* NIOS II relocations */
+#define R_NIOS2_NONE			0
+#define R_NIOS2_S16				1
+#define R_NIOS2_U16				2
+#define R_NIOS2_PCREL16			3
+#define R_NIOS2_CALL26			4
+#define R_NIOS2_IMM5			5
+#define R_NIOS2_CACHE_OPX 		6
+#define R_NIOS2_IMM6			7
+#define R_NIOS2_IMM8			8
+#define R_NIOS2_HI16			9
+#define R_NIOS2_LO16			10
+#define R_NIOS2_HIADJ16 		11
+#define R_NIOS2_BFD_RELOC_32	12
+#define R_NIOS2_BFD_RELOC_16	13
+#define R_NIOS2_BFD_RELOC_8 	14
+#define R_NIOS2_GPREL			15
+#define R_NIOS2_GNU_VTINHERIT 	16
+#define R_NIOS2_GNU_VTENTRY  	17
+#define R_NIOS2_UJMP			18
+#define R_NIOS2_CJMP			19
+#define R_NIOS2_CALLR			20
+#define R_NIOS2_ALIGN			21
+/* Keep this the last entry.  */
+#define R_NIOS2_NUM				22
+
 __END_DECLS
 
 #endif	/* elf.h */
diff --git a/libc/sysdeps/linux/Makefile b/libc/sysdeps/linux/Makefile
index a95dd67ea..9aa585eec 100644
--- a/libc/sysdeps/linux/Makefile
+++ b/libc/sysdeps/linux/Makefile
@@ -19,7 +19,7 @@
 TOPDIR=../../../
 include $(TOPDIR)Rules.mak
 
-ALL_SUBDIRS = arm common cris h8300 i386 m68k mips powerpc sh sh64 sparc v850
+ALL_SUBDIRS = arm common cris h8300 i386 m68k mips nios nios2 powerpc sh sh64 sparc v850
 
 all: common $(TARGET_ARCH)
 
diff --git a/libc/sysdeps/linux/nios/Makefile b/libc/sysdeps/linux/nios/Makefile
new file mode 100644
index 000000000..ea56738dc
--- /dev/null
+++ b/libc/sysdeps/linux/nios/Makefile
@@ -0,0 +1,86 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2003 Erik Andersen <andersen@uclibc.org>
+#
+# This program is free software; you can redistribute it and/or modify it under
+# the terms of the GNU Library General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option) any
+# later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+# details.
+#
+# You should have received a copy of the GNU Library General Public License
+# along with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+TOPDIR=../../../../
+include $(TOPDIR)Rules.mak
+ASFLAGS=$(CFLAGS)
+
+CRT0_SRC = crt0.S
+CRT0_OBJ = crt0.o crt1.o
+CTOR_TARGETS=
+
+SSRC= __longjmp.S bsd-_setjmp.S bsd-setjmp.S setjmp.S clone.S vfork.S
+SOBJS=$(patsubst %.S,%.o, $(SSRC))
+
+CSRC= brk.c crtbegin.c crtend.c
+COBJS=$(patsubst %.c,%.o, $(CSRC))
+
+OBJS=$(SOBJS) $(MOBJ) $(COBJS)
+
+all: $(OBJS) $(LIBC)
+
+$(LIBC): ar-target 
+
+ar-target: $(OBJS) $(CRT0_OBJ) $(CTOR_TARGETS)
+	$(AR) $(ARFLAGS) $(LIBC) $(OBJS)
+	cp $(CRT0_OBJ) $(TOPDIR)lib/
+
+$(CRT0_OBJ): $(CRT0_SRC)
+	$(CC) $(CFLAGS) -DL_$* $< -c -o $*.o
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+$(SOBJS): %.o : %.S
+	$(CC) $(CFLAGS) -c $< -o $@
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+$(COBJS): %.o : %.c
+	$(CC) $(CFLAGS) -c $< -o $@
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+ifeq ($(strip $(UCLIBC_CTOR_DTOR)),y)
+crti.o: crti.S
+	$(CC) $(CFLAGS) -c crti.S -o crti.o
+
+$(TOPDIR)lib/crti.o: crti.o
+	$(INSTALL) -d $(TOPDIR)lib/
+	cp crti.o $(TOPDIR)lib/
+
+crtn.o: crtn.S
+	$(CC) $(CFLAGS) -c crtn.S -o crtn.o
+
+$(TOPDIR)lib/crtn.o: crtn.o
+	$(INSTALL) -d $(TOPDIR)lib/
+	cp crtn.o $(TOPDIR)lib/
+else
+$(TOPDIR)lib/crti.o:
+	$(INSTALL) -d $(TOPDIR)lib/
+	$(AR) $(ARFLAGS) $(TOPDIR)lib/crti.o
+$(TOPDIR)lib/crtn.o:
+	$(INSTALL) -d $(TOPDIR)lib/
+	$(AR) $(ARFLAGS) $(TOPDIR)lib/crtn.o
+endif
+
+
+headers:
+	$(LN) -fs ../libc/sysdeps/linux/nios/fpu_control.h $(TOPDIR)/include/
+
+clean:
+	$(RM) *.[oa] *~ core
+	$(RM) bits/sysnum.h
+	$(RM) $(TOPDIR)/include/fpu_control.h
+	
diff --git a/libc/sysdeps/linux/nios/NM_Macros.S b/libc/sysdeps/linux/nios/NM_Macros.S
new file mode 100644
index 000000000..da6136593
--- /dev/null
+++ b/libc/sysdeps/linux/nios/NM_Macros.S
@@ -0,0 +1,473 @@
+
+;------------------------------
+; Macros I: Faux Instructions
+;
+; The following "faux instructions" are
+; implemented here as macros:
+;
+; MOVIP register,constant		MOVI with optional PFX & MOVHI, or BGEN
+; ADDIP register,constant		PFX and ADDI with optional PFX
+; SUBIP register,constant		PFX and SUBI with optional PFX
+; CMPIP register,constant		PFX and CMPI with optional PFX
+;
+; MOVI16 register,constant		PFX and MOVI
+; MOVI32 register,constant		PFX, MOVI, PFX, and MOVHI
+; MOVIA  register,constant		PFX and MOVHI on Nios32, and PFX and MOVI
+;
+; ANDIP register,constant		PFX and ANDI
+; ANDNIP register,constant		PFX and ANDN
+; ORIP register,constant		PFX and ORI
+; XORIP register,constant		PFX and XORI
+;
+; _BSR address						MOVIP address to %g7, and CALL
+; _BR address						MOVIP address to %g7, and JMP
+;
+; BEQ address						SKPS cc_nz and BR, has delay slot
+; BNE address						SKPS cc_z and BR, has delay slot
+; BLE address						SKPS cc_gt and BR, has delay slot
+; BLT address						SKPS cc_ge and BR, has delay slot
+; RESTRET							RESTORE and JMP %i7 
+;
+;-------------------------------
+; Macros II: Printing
+;
+; These macros are guaranteed *not*
+; to have branch delay slot after them.
+;
+; NM_PrintChar char
+; NM_Print "string"
+; NM_PrintLn "string"			Follows it with a carriage return
+; NM_PrintRegister reg			For debugging, prints register name & value
+;
+;-------------------------------
+; Macros III: Inline Debugging
+;
+; These macros print various information
+; using large sections of expanded inline code.
+; They each use either few or no registers.
+; Thus, they may be safely used in interrupt handlers.
+;
+; NM_D_TxChar char			print char to UART, affects no registers
+; NM_D_TxRegister char,char,register	prints the two characters, and the hex register value
+
+; --------------------------------------
+
+
+		.macro	_pfx_op	OP,reg,val,pForce=0
+		.if		(\pForce) || ((\val) > (31)) || ((\val) < (0))
+		PFX		%hi(\val)
+		.endif
+		\OP		\reg,%lo(\val)
+		.endm
+
+		.macro	_bgen reg,val,bit
+		.if ((\val)==(1<<\bit))
+		BGEN	\reg,\bit
+		.equ	_bgenBit,1
+		.endif
+		.endm
+
+	;------------------------
+	; MOVIP %reg,32-bit-value
+		.macro	MOVIP reg,val
+		; Methodically test every BGEN possibility...
+		.equ	_bgenBit,0
+.if 1
+		_bgen \reg,\val,0
+		_bgen \reg,\val,1
+		_bgen \reg,\val,2
+		_bgen \reg,\val,3
+		_bgen \reg,\val,4
+		_bgen \reg,\val,5
+		_bgen \reg,\val,6
+		_bgen \reg,\val,7
+		_bgen \reg,\val,8
+		_bgen \reg,\val,9
+		_bgen \reg,\val,10
+		_bgen \reg,\val,11
+		_bgen \reg,\val,12
+		_bgen \reg,\val,13
+		_bgen \reg,\val,14
+		_bgen \reg,\val,15
+		_bgen \reg,\val,16
+		_bgen \reg,\val,17
+		_bgen \reg,\val,18
+		_bgen \reg,\val,19
+		_bgen \reg,\val,20
+		_bgen \reg,\val,21
+		_bgen \reg,\val,22
+		_bgen \reg,\val,23
+		_bgen \reg,\val,24
+		_bgen \reg,\val,25
+		_bgen \reg,\val,26
+		_bgen \reg,\val,27
+		_bgen \reg,\val,28
+		_bgen \reg,\val,29
+		_bgen \reg,\val,30
+		_bgen \reg,\val,31
+
+		; If no bgen fit...
+.endif
+		.if !_bgenBit
+			.if ((\val) & 0xFFE0)
+				PFX %hi(\val)
+			.endif
+			MOVI \reg,%lo(\val)
+			.if __nios32__
+				.if ((\val) & 0xffff0000)
+					.if ((\val) & 0xFFE00000)
+						PFX %xhi(\val)
+					.endif
+					MOVHI \reg,%xlo(\val)
+				.endif
+			.endif
+		.endif
+
+		.endm
+
+	; ADDIP %reg,16-bit-value
+		.macro	ADDIP reg,val
+		_pfx_op	ADDI,\reg,\val
+		.endm
+
+	; SUBIP %reg,16-bit-value
+		.macro	SUBIP reg,val
+		_pfx_op	SUBI,\reg,\val
+		.endm
+
+	; CMPIP %reg,16-bit-value
+		.macro	CMPIP reg,val
+		_pfx_op	CMPI,\reg,\val
+		.endm
+
+	; ANDIP %reg,16-bit-value
+		.macro	ANDIP reg,val
+		PFX		%hi(\val)
+		AND		\reg,%lo(\val)
+		.endm
+
+	; ANDNIP %reg,16-bit-value
+		.macro	ANDNIP reg,val
+		PFX		%hi(\val)
+		ANDN		\reg,%lo(\val)
+		.endm
+
+	; ORIP %reg,16-bit-value
+		.macro	ORIP reg,val
+		PFX		%hi(\val)
+		OR			\reg,%lo(\val)
+		.endm
+
+	; XORIP %reg,16-bit-value
+		.macro	XORIP reg,val
+		PFX		%hi(\val)
+		XOR		\reg,%lo(\val)
+		.endm
+
+	; BEQ addr
+		.macro	BEQ addr
+		IFS		cc_eq
+		BR			\addr
+		.endm
+
+	; BNE addr
+		.macro	BNE addr
+		IFS		cc_ne
+		BR			\addr
+		.endm
+
+	; BLE addr
+		.macro	BLE addr
+		SKPS		cc_gt
+		BR			\addr
+		.endm
+
+	; BLT addr
+		.macro	BLT addr
+		SKPS		cc_ge
+		BR			\addr
+		.endm
+
+		.macro	digitToChar reg
+		ANDIP	\reg,0x000f
+		CMPI	\reg,10
+		SKPS	cc_lt
+		ADDI	\reg,'A'-'0'-10
+		PFX		%hi('0')
+		ADDI	\reg,%lo('0')
+		.endm
+
+; PUSHRET == dec sp, and stash return addr
+	.macro	PUSHRET
+	SUBI		%sp,2
+	ST			[%sp],%o7
+	.endm
+; POPRET == pop and jump
+	.macro	POPRET
+	LD			%o7,[%sp]
+	JMP		%o7
+	ADDI		%sp,2		; branch delay slot
+	.endm
+
+; RESTRET = restore & return
+	.macro	RESTRET
+	JMP		%i7
+	RESTORE
+	.endm
+
+	;--------------------
+	; MOVI16 %reg,Address
+	;
+	.macro	MOVI16	reg,val
+	PFX	%hi(\val)
+	MOVI	\reg,%lo(\val)
+	.endm
+
+	;--------------------
+	; MOVI32 %reg,Address
+	;
+	.macro	MOVI32	reg,val
+	PFX	%hi(\val)
+	MOVI	\reg,%lo(\val)
+	PFX	%xhi(\val)
+	MOVHI	\reg,%xlo(\val)
+	.endm
+
+	;--------------------
+	; MOVIA %reg,Address
+	;
+	.macro	MOVIA		reg,val
+	.if __nios32__
+		MOVI32 \reg,\val
+	.else
+		MOVI16 \reg,\val
+	.endif
+	.endm
+
+	;--------------------
+	; _BR
+
+	.macro _BR target,viaRegister=%g7
+	MOVIA	\viaRegister,\target@h
+	JMP	\viaRegister
+	.endm
+
+	;--------------------
+	; _BSR
+
+	.macro _BSR target,viaRegister=%g7
+	MOVIA	\viaRegister,\target@h
+	CALL	\viaRegister
+	.endm
+
+	;---------------------
+	; NM_Print "Your String Here"
+	;
+	.macro	NM_Print	string
+
+	BR		pastStringData\@
+	NOP
+
+stringData\@:
+	.asciz	"\string"
+	.align 1		; aligns by 2^n
+pastStringData\@:
+	MOVIA		%o0,stringData\@
+	_BSR		NR_TxString
+	NOP
+	.endm
+
+	.macro	NM_PrintLn string
+	NM_Print	"\string"
+	_BSR		NR_TxCR
+	NOP
+	.endm
+
+	.macro	NM_PrintRegister reg	; affects %g0 & %g1 & %g7, but thrashes the CWP a bit
+	SAVE		%sp,-16
+	NM_Print	"\reg = "
+	RESTORE
+	MOV		%g0,\reg
+	SAVE		%sp,-16
+	MOV		%o0,%g0
+	_BSR		NR_TxHex
+	NOP
+	_BSR		NR_TxCR
+	NOP
+	RESTORE
+	.endm
+
+	.macro	NM_PrintChar char
+	MOVIP		%o0,\char
+	_BSR		NR_TxChar
+	NOP
+	.endm
+
+	.macro	NM_Print2Chars char1,char2
+	MOVIP		%o0,(\char2<<8)+\char1
+	_BSR		NR_TxChar
+	NOP
+	_BSR		NR_TxChar
+	LSRI		%o0,8
+	.endm
+
+
+
+; ---------------------------
+; Completely inline UART sends
+; Send the char, or %g7 if not there.
+; Trashes %g5 and %g6 and %g7...
+
+	.macro	NM_TxChar char=0
+;NM_D_Delay 1000
+	MOVIA	%g6,NA_UARTBase
+txCharLoop\@:
+	PFX	2
+.if \char
+	LD	%g7,[%g6]
+	SKP1	%g7,6
+.else
+	LD	%g5,[%g6]
+	SKP1	%g5,6
+.endif
+	BR	txCharLoop\@
+	NOP
+.if \char
+	MOVIP	%g7,\char
+.endif
+	PFX	1
+	ST	[%g6],%g7
+;NM_D_Delay 4
+	.endm
+
+		.macro NM_TxCR
+		NM_TxChar 13
+		NM_TxChar 10
+		.endm
+
+		.macro NM_TxHexDigit,reg,shift
+		MOV		%g7,\reg
+		LSRI		%g7,\shift
+		ANDIP		%g7,0x000f
+		CMPI		%g7,10
+		SKPS		cc_lt
+		ADDIP		%g7,'A'-'0'-10
+		ADDIP		%g7,'0'
+		NM_TxChar
+		.endm
+
+		.macro NM_TxHex
+
+	.if __nios32__
+		NM_TxHexDigit %g0,28
+		NM_TxHexDigit %g0,24
+		NM_TxHexDigit %g0,20
+		NM_TxHexDigit %g0,16
+	.endif
+
+		NM_TxHexDigit %g0,12
+		NM_TxHexDigit %g0,8
+		NM_TxHexDigit %g0,4
+		NM_TxHexDigit %g0,0
+		.endm
+
+
+
+
+
+
+
+
+
+
+; ----------------------
+; The following macros are
+; rather mighty. They expand
+; to large inline code for
+; printing various things to
+; the serial port. They are
+; useful for debugging
+; trap handlers, where you
+; can't just go and call
+; NR_TxChar and such, because,
+; well, the CWP might be
+; off limits!
+;
+; They do, however, presume
+; that the stack is in good
+; working order.
+
+
+.macro NM_D_PushGRegisters
+ 	SUBIP %sp,16+69				; oddball number so if we accidentally see it, it looks funny.
+	STS	[%sp,16+0],%g0
+	STS	[%sp,16+1],%g1
+	STS	[%sp,16+2],%g2
+	STS	[%sp,16+3],%g3
+	STS	[%sp,16+4],%g4
+	STS	[%sp,16+5],%g5
+	STS	[%sp,16+6],%g6
+	STS	[%sp,16+7],%g7
+	.endm
+
+.macro NM_D_PopGRegisters
+	LDS	%g0,[%sp,16+0]
+	LDS	%g1,[%sp,16+1]
+	LDS	%g2,[%sp,16+2]
+	LDS	%g3,[%sp,16+3]
+	LDS	%g4,[%sp,16+4]
+	LDS	%g5,[%sp,16+5]
+	LDS	%g6,[%sp,16+6]
+	LDS	%g7,[%sp,16+7]
+	ADDIP	%sp,16+69				; must match the push
+	.endm
+
+
+.macro NM_D_TxChar	c
+	SUBI	%sp,16+8		; 32 or 16 bit, that's enough space
+	STS	[%sp,16+0],%g6
+	STS	[%sp,16+0],%g7
+	NM_TxChar \c
+	LDS	%g6,[%sp,16+0]
+	LDS	%g7,[%sp,16+1]
+	ADDI	%sp,16+8
+	.endm
+
+.macro NM_D_TxChar3 c1,c2,c3
+ NM_D_TxChar '<'
+ NM_D_TxChar \c1
+ NM_D_TxChar \c2
+ NM_D_TxChar \c3
+ NM_D_TxChar '>'
+.endm
+
+.macro NM_D_TxRegister r,n,reg
+ NM_D_PushGRegisters
+ NM_TxChar '('
+ NM_TxChar \r
+ NM_TxChar \n
+ NM_TxChar ':'
+ MOV		%g0,\reg
+ NM_TxHex
+ NM_TxChar ')'
+ NM_D_PopGRegisters
+.endm
+
+.macro NM_D_TxReg r,n,reg
+	NM_D_TxRegister \r,\n,\reg
+.endm
+
+; Do a delay loop, affects no registers.
+
+.macro NM_D_Delay d
+	SUBI	%sp,16+4
+	STS	[%sp,16+0],%g0
+	MOVIP	%g0,\d
+NM_D_DelayLoop\@:
+	IFRnz	%g0
+	 BR	NM_D_DelayLoop\@
+	SUBI	%g0,1
+	LDS	%g0,[%sp,16+0]
+	ADDI	%sp,16+4
+.endm
+
diff --git a/libc/sysdeps/linux/nios/NR_Math1.S b/libc/sysdeps/linux/nios/NR_Math1.S
new file mode 100644
index 000000000..5d5169ba8
--- /dev/null
+++ b/libc/sysdeps/linux/nios/NR_Math1.S
@@ -0,0 +1,63 @@
+
+
+	.include "NM_Macros.S"
+
+	.file	"okmul.c"
+gcc2_compiled.:
+	.text
+	.p2align 1
+	.globl __mulsi3
+	.type	 __mulsi3,@function
+__mulsi3:
+
+	;SKP0	%o0,31
+	;NEG	%o1
+	;ABS	%o0
+
+		.MACRO ZSTEP bit
+		SKP0	%o0,\bit
+		ADD	%g0,%o1
+		LSLI	%o1,1
+		.ENDM
+
+	MOVI	%g0,0
+	ZSTEP	0
+	ZSTEP	1
+	ZSTEP	2
+	ZSTEP	3
+	ZSTEP	4
+	ZSTEP	5
+	ZSTEP	6
+	ZSTEP	7
+	ZSTEP	8
+	ZSTEP	9
+	ZSTEP	10
+	ZSTEP	11
+	ZSTEP	12
+	ZSTEP	13
+	ZSTEP	14
+	ZSTEP	15
+	ZSTEP	16
+	ZSTEP	17
+	ZSTEP	18
+	ZSTEP	19
+	ZSTEP	20
+	ZSTEP	21
+	ZSTEP	22
+	ZSTEP	23
+	ZSTEP	24
+	ZSTEP	25
+	ZSTEP	26
+	ZSTEP	27
+	ZSTEP	28
+	ZSTEP	29
+	ZSTEP	30
+	ZSTEP	31
+	; No bit 31: we already set %o0 to positive
+
+	JMP	%o7
+	MOV	%o0,%g0
+
+.Lfe1:
+	.size	 __mulsi3,.Lfe1-__mulsi3
+
diff --git a/libc/sysdeps/linux/nios/__longjmp.S b/libc/sysdeps/linux/nios/__longjmp.S
new file mode 100644
index 000000000..c2b1979cc
--- /dev/null
+++ b/libc/sysdeps/linux/nios/__longjmp.S
@@ -0,0 +1,108 @@
+/* Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#define _ASM
+#define _SETJMP_H
+#include <bits/setjmp.h>
+
+
+;----------------------------------------
+;         Name: __longjmp
+;  Description: Restore the current context
+;               as saved by a previous nr_setjmp
+;        Input: %o0: jmp_buf (ptr to) array to restore context from
+;               %o1: integer to return
+;       Output: %o0 = 0 the first time we're called, or
+;               whatever longjmp returns later
+; Side Effects: uses %g0, %g1 & %g2
+;    CWP Depth: 0
+;
+
+	.align 2
+	.global	__longjmp
+__longjmp:
+	;
+	; The way we'll do this is by executing
+	; RESTORE instructions until the old
+	; return address matches. Then we'll
+	; jump to where setjmp was called from.
+	;
+	; Since we're moving the window pointer
+	; all over the place, we'll naturally
+	; only use the %g registers.
+	;
+
+	mov	%g0,%o0		; %g0 -> jmp_buf
+	mov	%g1,%o1		; %g1 = return value
+	pfx	jmpbuf_callersret
+	ld	%g2,[%g0]	; %g2 = old return address
+__longjmp_loop:
+	cmp	%g2,%i7		; Are we there yet?
+	skps	cc_ne
+	 br	__longjmp_done
+	 nop			; (delay slot)
+
+	br	__longjmp_loop
+	restore			; (delay slot)
+	;
+	; One might put in a watchdog counter here, to
+	; prevent a runaway stack crawl... but what would that
+	; accomplish? What error can we throw? To whom?
+	;
+
+__longjmp_done:
+	pfx	jmpbuf_l0	; Restore local register l0
+	ld	%l0,[%g0]
+	pfx	jmpbuf_l1	; Restore local register l1
+	ld	%l1,[%g0]
+	pfx	jmpbuf_l2	; Restore local register l2
+	ld	%l2,[%g0]
+	pfx	jmpbuf_l3	; Restore local register l3
+	ld	%l3,[%g0]
+	pfx	jmpbuf_l4	; Restore local register l4
+	ld	%l4,[%g0]
+	pfx	jmpbuf_l5	; Restore local register l5
+	ld	%l5,[%g0]
+	pfx	jmpbuf_l6	; Restore local register l6
+	ld	%l6,[%g0]
+	pfx	jmpbuf_l7	; Restore local register l7
+	ld	%l7,[%g0]
+	pfx	jmpbuf_i0	; Restore input register i0
+	ld	%i0,[%g0]
+	pfx	jmpbuf_i1	; Restore input register i1
+	ld	%i1,[%g0]
+	pfx	jmpbuf_i2	; Restore input register i2
+	ld	%i2,[%g0]
+	pfx	jmpbuf_i3	; Restore input register i3
+	ld	%i3,[%g0]
+	pfx	jmpbuf_i4	; Restore input register i4
+	ld	%i4,[%g0]
+	pfx	jmpbuf_i5	; Restore input register i5
+	ld	%i5,[%g0]
+	pfx	jmpbuf_jmpret
+	ld	%o7,[%g0]	; set fake return address
+	jmp	%o7		; and kinda return there.
+	mov	%o0,%g1		; (delay slot) return value
+
+
+
+
+
+
+
+
diff --git a/libc/sysdeps/linux/nios/bits/endian.h b/libc/sysdeps/linux/nios/bits/endian.h
new file mode 100644
index 000000000..252597931
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/endian.h
@@ -0,0 +1,8 @@
+/* nios is little-endian.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+//mle
+#define __BYTE_ORDER __LITTLE_ENDIAN
diff --git a/libc/sysdeps/linux/nios/bits/fcntl.h b/libc/sysdeps/linux/nios/bits/fcntl.h
new file mode 100644
index 000000000..e2974b9f7
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/fcntl.h
@@ -0,0 +1,180 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+
+#include <sys/types.h>
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	  0003
+#define O_RDONLY	    00
+#define O_WRONLY	    01
+#define O_RDWR		    02
+#define O_CREAT		  0100	/* not fcntl */
+#define O_EXCL		  0200	/* not fcntl */
+#define O_NOCTTY	  0400	/* not fcntl */
+#define O_TRUNC		 01000	/* not fcntl */
+#define O_APPEND	 02000
+#define O_NONBLOCK	 04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		010000
+#define O_FSYNC		O_SYNC
+#define O_ASYNC		020000
+
+#ifdef __USE_GNU
+# define O_DIRECTORY	 040000	/* Must be a directory.	 */
+# define O_NOFOLLOW	0100000	/* Do not follow links.	 */
+# define O_DIRECT	0200000	/* Direct disk access.	*/
+# define O_STREAMING	04000000/* streaming access */
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0400000
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+#else
+# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+#endif
+#define F_GETLK64	12	/* Get record locking info.  */
+#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+# define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
+# define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+#endif
+
+/* For F_[GET|SET]FL.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* for old implementation of bsd flock () */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation */
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
diff --git a/libc/sysdeps/linux/nios/bits/kernel_types.h b/libc/sysdeps/linux/nios/bits/kernel_types.h
new file mode 100644
index 000000000..acbb0c592
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/kernel_types.h
@@ -0,0 +1,43 @@
+/* Note that we use the exact same include guard #define names
+ * as asm/posix_types.h.  This will avoid gratuitous conflicts 
+ * with the posix_types.h kernel header, and will ensure that 
+ * our private content, and not the kernel header, will win.
+ *  -Erik
+ */
+#ifndef __ARCH_NIOS_POSIX_TYPES_H
+#define __ARCH_NIOS_POSIX_TYPES_H
+
+typedef unsigned short	__kernel_dev_t;
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned short	__kernel_mode_t;
+typedef unsigned short	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned short	__kernel_ipc_pid_t;
+typedef unsigned short	__kernel_uid_t;
+typedef unsigned short	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+typedef unsigned short	__kernel_old_uid_t;
+typedef unsigned short	__kernel_old_gid_t;
+typedef long long	__kernel_loff_t;
+
+typedef struct {
+#ifdef __USE_ALL
+	int val[2];
+#else
+	int __val[2];
+#endif
+} __kernel_fsid_t;
+
+#endif /* __ARCH_NIOS2_POSIX_TYPES_H */
diff --git a/libc/sysdeps/linux/nios/bits/mathdef.h b/libc/sysdeps/linux/nios/bits/mathdef.h
new file mode 100644
index 000000000..44d7f0dde
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/mathdef.h
@@ -0,0 +1,48 @@
+/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _MATH_H && !defined _COMPLEX_H
+# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
+#endif
+
+#if defined  __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
+# define _MATH_H_MATHDEF	1
+
+/* GCC does not promote `float' values to `double'.  */
+typedef float float_t;		/* `float' expressions are evaluated as
+				   `float'.  */
+typedef double double_t;	/* `double' expressions are evaluated as
+				   `double'.  */
+
+/* Define `INFINITY' as value of type `float'.  */
+# define INFINITY	HUGE_VALF
+
+
+/* The values returned by `ilogb' for 0 and NaN respectively.  */
+# define FP_ILOGB0	(-2147483647)
+# define FP_ILOGBNAN	(2147483647)
+
+#endif	/* ISO C99 */
+
+#ifndef __NO_LONG_DOUBLE_MATH
+/* Signal that we do not really have a `long double'.  This disables the
+   declaration of all the `long double' function variants.  */
+/* XXX The FPA does support this but the patterns in GCC are currently
+   turned off.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/nios/bits/mman.h b/libc/sysdeps/linux/nios/bits/mman.h
new file mode 100644
index 000000000..34f14ee5b
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/mman.h
@@ -0,0 +1,75 @@
+/* Definitions for POSIX memory map interface.  Linux/m68k version.
+   Copyright (C) 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+#endif
diff --git a/libc/sysdeps/linux/nios/bits/resource.h b/libc/sysdeps/linux/nios/bits/resource.h
new file mode 100644
index 000000000..06ecca45a
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/resource.h
@@ -0,0 +1,209 @@
+/* Bit values & structures for resource limits.  Linux/x86 version.
+   Copyright (C) 1994,1996,1997,1998,1999,2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  RLIMIT_RSS = 5,
+#define	RLIMIT_RSS RLIMIT_RSS
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 7,
+  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+#define RLIMIT_NOFILE RLIMIT_NOFILE
+#define RLIMIT_OFILE RLIMIT_OFILE
+
+  /* Address space limit.  */
+  RLIMIT_AS = 9,
+#define RLIMIT_AS RLIMIT_AS
+
+  /* Number of processes.  */
+  RLIMIT_NPROC = 6,
+#define RLIMIT_NPROC RLIMIT_NPROC
+
+  /* Locked-in-memory address space.  */
+  RLIMIT_MEMLOCK = 8,
+#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
+
+  /* Maximum number of file locks.  */
+  RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS RLIMIT_LOCKS
+
+  RLIMIT_NLIMITS = 11,
+  RLIM_NLIMITS = RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS RLIMIT_NLIMITS
+#define RLIM_NLIMITS RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY ((unsigned long int)(~0UL))
+#else
+# define RLIM_INFINITY 0xffffffffffffffffuLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0xffffffffffffffffuLL
+#endif
+
+/* We can represent all limits.  */
+#define RLIM_SAVED_MAX	RLIM_INFINITY
+#define RLIM_SAVED_CUR	RLIM_INFINITY
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1,
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+
+  /* Both.  */
+  RUSAGE_BOTH = -2
+#define RUSAGE_BOTH RUSAGE_BOTH
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
diff --git a/libc/sysdeps/linux/nios/bits/setjmp.h b/libc/sysdeps/linux/nios/bits/setjmp.h
new file mode 100644
index 000000000..33467f7d7
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/setjmp.h
@@ -0,0 +1,74 @@
+/* Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* Define the machine-dependent type `jmp_buf'.  Nios version.  */
+
+#ifndef _SETJMP_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+#ifndef _ASM
+
+#include <signal.h>
+
+typedef struct
+  {
+    /* There are eight 4-byte local registers saved.  */
+    long int __lregs[8];
+
+    /* There are six 4-byte input registers saved.  */
+    long int __iregs[6];
+
+    /* The SP, return address to caller (also for longjmp)
+       and return address of caller are saved.  */
+    int *__sp;
+    int *__jmpret;
+    int *__callersret;
+
+  } __jmp_buf[1];
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *) (address) < (void *) (jmpbuf)->__sp)
+
+#else /* _ASM */
+
+#define jmpbuf_l0 0x00
+#define jmpbuf_l1 0x01
+#define jmpbuf_l2 0x02
+#define jmpbuf_l3 0x03
+#define jmpbuf_l4 0x04
+#define jmpbuf_l5 0x05
+#define jmpbuf_l6 0x06
+#define jmpbuf_l7 0x07
+
+#define jmpbuf_i0 0x08
+#define jmpbuf_i1 0x09
+#define jmpbuf_i2 0x0a
+#define jmpbuf_i3 0x0b
+#define jmpbuf_i4 0x0c
+#define jmpbuf_i5 0x0d
+
+#define jmpbuf_sp 0x0e
+#define jmpbuf_jmpret 0x0f
+#define jmpbuf_callersret 0x10
+
+#endif /* _ASM */
+
+
diff --git a/libc/sysdeps/linux/nios/bits/sigcontextinfo.h b/libc/sysdeps/linux/nios/bits/sigcontextinfo.h
new file mode 100644
index 000000000..caf1cf4ce
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/sigcontextinfo.h
@@ -0,0 +1,27 @@
+/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 1999.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define SIGCONTEXT struct sigcontext *
+#define SIGCONTEXT_EXTRA_ARGS
+#define GET_PC(ctx)	((void *) ((ctx)->regs.pc))
+
+/* now way for nios to do GET_FRAME(ctx), it is not saved in ctx */
+#define GET_STACK(ctx)	((void *) (ctx)->regs.u_regs[14])
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
diff --git a/libc/sysdeps/linux/nios/bits/stackinfo.h b/libc/sysdeps/linux/nios/bits/stackinfo.h
new file mode 100644
index 000000000..e7fbf5633
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/stackinfo.h
@@ -0,0 +1,28 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+/* On nios II the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+#endif	/* stackinfo.h */
diff --git a/libc/sysdeps/linux/nios/bits/stat.h b/libc/sysdeps/linux/nios/bits/stat.h
new file mode 100644
index 000000000..213dbe267
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/stat.h
@@ -0,0 +1,134 @@
+/* Copyright (C) 1992,95,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STAT_H
+# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+/* Versions of the `struct stat' data structure.  */
+#define _STAT_VER_LINUX_OLD	1
+#define _STAT_VER_KERNEL	1
+#define _STAT_VER_SVR4		2
+#define _STAT_VER_LINUX		3
+#define _STAT_VER		_STAT_VER_LINUX	/* The one defined below.  */
+
+/* Versions of the `xmknod' interface.  */
+#define _MKNOD_VER_LINUX	1
+#define _MKNOD_VER_SVR4		2
+#define _MKNOD_VER		_MKNOD_VER_LINUX /* The bits defined below.  */
+
+
+struct stat
+  {
+    __dev_t st_dev;			/* Device.  */
+    unsigned short int __pad1;
+#ifndef __USE_FILE_OFFSET64
+    __ino_t st_ino;			/* File serial number.	*/
+#else
+    __ino_t __st_ino;			/* 32bit file serial number.	*/
+#endif
+    __mode_t st_mode;			/* File mode.  */
+    __nlink_t st_nlink;			/* Link count.  */
+    __uid_t st_uid;			/* User ID of the file's owner.	*/
+    __gid_t st_gid;			/* Group ID of the file's group.*/
+    __dev_t st_rdev;			/* Device number, if device.  */
+    unsigned short int __pad2;
+#ifndef __USE_FILE_OFFSET64
+    __off_t st_size;			/* Size of file, in bytes.  */
+#else
+    __off64_t st_size;			/* Size of file, in bytes.  */
+#endif
+    __blksize_t st_blksize;		/* Optimal block size for I/O.  */
+
+#ifndef __USE_FILE_OFFSET64
+    __blkcnt_t st_blocks;		/* Number 512-byte blocks allocated. */
+#else
+    __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+#endif
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int __unused1;
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int __unused2;
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int __unused3;
+#ifndef __USE_FILE_OFFSET64
+    unsigned long int __unused4;
+    unsigned long int __unused5;
+#else
+    __ino64_t st_ino;			/* File serial number.	*/
+#endif
+  };
+
+#ifdef __USE_LARGEFILE64
+struct stat64
+  {
+    __dev_t st_dev;			/* Device.  */
+    unsigned short int __pad1;
+
+    __ino_t __st_ino;			/* 32bit file serial number.	*/
+    __mode_t st_mode;			/* File mode.  */
+    __nlink_t st_nlink;			/* Link count.  */
+    __uid_t st_uid;			/* User ID of the file's owner.	*/
+    __gid_t st_gid;			/* Group ID of the file's group.*/
+    __dev_t st_rdev;			/* Device number, if device.  */
+    unsigned short int __pad2;
+    __off64_t st_size;			/* Size of file, in bytes.  */
+    __blksize_t st_blksize;		/* Optimal block size for I/O.  */
+
+    __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int __unused1;
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int __unused2;
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int __unused3;
+    __ino64_t st_ino;			/* File serial number.		*/
+  };
+#endif
+
+/* Tell code we have these members.  */
+#define	_STATBUF_ST_BLKSIZE
+#define _STATBUF_ST_RDEV
+
+/* Encoding of the file mode.  */
+
+#define	__S_IFMT	0170000	/* These bits determine file type.  */
+
+/* File types.  */
+#define	__S_IFDIR	0040000	/* Directory.  */
+#define	__S_IFCHR	0020000	/* Character device.  */
+#define	__S_IFBLK	0060000	/* Block device.  */
+#define	__S_IFREG	0100000	/* Regular file.  */
+#define	__S_IFIFO	0010000	/* FIFO.  */
+#define	__S_IFLNK	0120000	/* Symbolic link.  */
+#define	__S_IFSOCK	0140000	/* Socket.  */
+
+/* POSIX.1b objects.  Note that these macros always evaluate to zero.  But
+   they do it by enforcing the correct use of the macros.  */
+#define __S_TYPEISMQ(buf)  ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSEM(buf) ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSHM(buf) ((buf)->st_mode - (buf)->st_mode)
+
+/* Protection bits.  */
+
+#define	__S_ISUID	04000	/* Set user ID on execution.  */
+#define	__S_ISGID	02000	/* Set group ID on execution.  */
+#define	__S_ISVTX	01000	/* Save swapped text after use (sticky).  */
+#define	__S_IREAD	0400	/* Read by owner.  */
+#define	__S_IWRITE	0200	/* Write by owner.  */
+#define	__S_IEXEC	0100	/* Execute by owner.  */
diff --git a/libc/sysdeps/linux/nios/bits/syscalls.h b/libc/sysdeps/linux/nios/bits/syscalls.h
new file mode 100644
index 000000000..21f4a370c
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/syscalls.h
@@ -0,0 +1,12 @@
+#ifndef _BITS_SYSCALLS_H
+#define _BITS_SYSCALLS_H
+#ifndef _SYSCALL_H
+# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
+#endif
+
+#include <features.h>
+/* Do something very evil for now.  Until we include our out syscall
+ * macros, short circuit bits/syscall.h  and use asm/unistd.h instead */
+#include <asm/unistd.h>
+#endif /* _BITS_SYSCALLS_H */
+
diff --git a/libc/sysdeps/linux/nios/bits/wordsize.h b/libc/sysdeps/linux/nios/bits/wordsize.h
new file mode 100644
index 000000000..ba643b60a
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bits/wordsize.h
@@ -0,0 +1,19 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __WORDSIZE	32
diff --git a/libc/sysdeps/linux/nios/brk.c b/libc/sysdeps/linux/nios/brk.c
new file mode 100644
index 000000000..6cacbfd5c
--- /dev/null
+++ b/libc/sysdeps/linux/nios/brk.c
@@ -0,0 +1,45 @@
+/* brk system call for Linux/Nios2.
+   Copyright (C) 1995, 1996, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <errno.h>
+
+
+/* This must be initialized data because commons can't have aliases.  */
+void *___brk_addr = 0;
+
+
+int brk (void *addr)
+{
+    void *newbrk;
+    register int g1 asm("%g1") = __NR_brk;
+    register void *o0 asm("%o0") = addr;
+
+    asm volatile ("trap 63\n\t" : "=r"(newbrk) : "0"(o0), "r"(g1));
+
+    ___brk_addr = newbrk;
+
+    if (newbrk < addr) {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+    return 0;
+}
diff --git a/libc/sysdeps/linux/nios/bsd-_setjmp.S b/libc/sysdeps/linux/nios/bsd-_setjmp.S
new file mode 100644
index 000000000..f2f0f2396
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bsd-_setjmp.S
@@ -0,0 +1 @@
+/* _setjmp in setjmp.S */
\ No newline at end of file
diff --git a/libc/sysdeps/linux/nios/bsd-setjmp.S b/libc/sysdeps/linux/nios/bsd-setjmp.S
new file mode 100644
index 000000000..36f2bab1c
--- /dev/null
+++ b/libc/sysdeps/linux/nios/bsd-setjmp.S
@@ -0,0 +1 @@
+/* setjmp in setjmp.S */
\ No newline at end of file
diff --git a/libc/sysdeps/linux/nios/clone.S b/libc/sysdeps/linux/nios/clone.S
new file mode 100644
index 000000000..a3098f5f8
--- /dev/null
+++ b/libc/sysdeps/linux/nios/clone.S
@@ -0,0 +1,91 @@
+/* Copyright (C) 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson (rth@tamu.edu).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <asm/errno.h>
+#include <asm/unistd.h>
+#include "NM_Macros.S"
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg); */
+
+	.text
+	.align	2
+	.globl	__clone
+	.type	__clone,@function
+
+__clone:
+	save	%sp,-16
+
+	MOVIP	%l0, -EINVAL
+	/* sanity check arguments */
+	skprnz	%i0				/* no NULL function pointers */
+	 br	CLONE_ERROR_LABEL
+	mov	%o0, %i2
+
+	skprnz  %i1				/* no NULL stack pointers */
+	 br	CLONE_ERROR_LABEL
+	mov	%o1, %i1
+
+	/* Do the system call */
+	MOVIP	%g1, __NR_clone
+	trap	63
+
+	/* if ret >=0? */
+	cmpi %o0, 0
+	skps cc_pl
+	 br CLONE_ERROR_LABEL
+	 mov %l0, %o0
+
+	/* Start thread */
+	skprz  %o1
+	 br __thread_start
+	 nop
+	mov %i0, %o0
+	ret
+	 restore
+
+CLONE_ERROR_LABEL:
+	neg %l0
+	MOVIA	%g1, __errno_location@h
+	call	%g1
+	 nop
+	st	[%o0], %l0		/* store errno */
+
+	xor %i0, %i0
+	dec %i0				/* retval=-1 */
+	ret
+	 restore
+
+	.size	__clone, .-__clone
+
+	.type	__thread_start,@function
+
+__thread_start:
+	call	%i0
+	 mov	%o0, %i3
+	MOVIA	%g1, _exit@h
+	call	%g1
+	 nop
+
+	.size	__thread_start, .-__thread_start
+
+.globl	clone;
+    clone = __clone
diff --git a/libc/sysdeps/linux/nios/crt0.S b/libc/sysdeps/linux/nios/crt0.S
new file mode 100644
index 000000000..bbf4ede6a
--- /dev/null
+++ b/libc/sysdeps/linux/nios/crt0.S
@@ -0,0 +1,57 @@
+/* Copyright (C) 1991, 1992 Free Software Foundation, Inc.
+
+This file is part of the GNU C Library.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+#include <features.h>
+#include <asm/unistd.h>
+#include "NM_Macros.S"
+#define __ASSEMBLY__
+#include <asm/ptrace.h>		/* for REGWIN_SZ */
+
+    .global _start
+    .type   __start,@function
+    .weak   _init
+    .weak   _fini
+    .type   __uClibc_start_main,@function
+    .type   __h_errno_location, @function
+    .type   _stdio_init, @function
+    .type   _stdio_term, @function
+
+	.text
+
+_start: 
+	nop
+	nop
+
+	lds	%o0,[%sp, (REGWIN_SZ / 4) + 0]	// main's argc
+	lds	%o1,[%sp, (REGWIN_SZ / 4) + 1]	// main's argv
+	lds	%o2,[%sp, (REGWIN_SZ / 4) + 2]	// main's envp
+
+	MOVIA	%o3, _init@h
+	MOVIA	%o4, _fini@h
+	MOVIA	%o5, __uClibc_start_main@h
+	
+	call	%o5
+	nop
+
+
+	/* If that didn't kill us, ... */
+__exit:
+	MOVIP	%g1, __NR_exit
+	trap	63
+	
\ No newline at end of file
diff --git a/libc/sysdeps/linux/nios/crt0.c b/libc/sysdeps/linux/nios/crt0.c
new file mode 100644
index 000000000..48b1a0f07
--- /dev/null
+++ b/libc/sysdeps/linux/nios/crt0.c
@@ -0,0 +1,73 @@
+/* Copyright (C) 1991, 1992 Free Software Foundation, Inc.
+
+This file is part of the GNU C Library.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+#include <asm/ptrace.h>
+
+#define nop() __asm__ __volatile__ ("nop")
+
+extern inline int _stack_frame_address(void)
+{
+	int retval;
+	__asm__ __volatile__(
+		"mov	%0, %%fp\n\t"
+		: "=r" (retval) );
+	return retval;
+}
+
+void __uClibc_main(int argc,void *argv,void *envp);
+
+void _start(void)
+{
+	void **p;
+
+	nop();				/* placeholder for breakpoint */
+	nop();
+
+	p =  (int *) (_stack_frame_address() + REGWIN_SZ);
+	__uClibc_main( (int) *p, *(p+1), *(p+2) );
+
+/* If that didn't kill us, ... */
+
+	asm("trap 0");
+}
+
+/*
+ *	this was needed for gcc/g++-builds,  atexit was not getting included
+ *	for some stupid reason,  this gets us a compiler
+ */
+// empty_func:
+// //	rts
+// 	.weak atexit
+// atexit = empty_func
+// 
+// /*
+//  *	a little bit of stuff to support C++
+//  */
+// 	.section .ctors,"aw"
+// 	.align 4
+// 	.global __CTOR_LIST__
+// __CTOR_LIST__:
+// 	.long -1
+// 
+// 	.section .dtors,"aw"
+// 	.align 4
+// 	.global __DTOR_LIST__
+// __DTOR_LIST__:
+// 	.long -1
+
diff --git a/libc/sysdeps/linux/nios/crtbegin.c b/libc/sysdeps/linux/nios/crtbegin.c
new file mode 100644
index 000000000..c52999027
--- /dev/null
+++ b/libc/sysdeps/linux/nios/crtbegin.c
@@ -0,0 +1,37 @@
+#include <errno.h>
+#include <stdlib.h>
+/*
+static void (*__CTOR_LIST__[1]) __P((void))
+    __attribute__((__unused__))
+    __attribute__((section(".ctors"))) = { (void *)0 };
+
+static void (*__DTOR_LIST__[1]) __P((void))
+    __attribute__((section(".dtors"))) = { (void *)-1 };
+*/
+extern void (*__DTOR_LIST__[]) __P((void));
+static void	__do_global_dtors_aux __P((void));
+
+static void
+__do_global_dtors_aux()
+{
+	void (**p)(void) = __DTOR_LIST__ + 1;
+
+	while (*p)
+		(**p++)();
+}
+
+static void dummy_fini(void) __attribute__((section(".trash")));
+
+void
+dummy_fini(void)
+{
+	static void (* volatile call__dtors)(void) = __do_global_dtors_aux;
+	/*
+	 * Call global destructors.
+	 */
+	/* prevent function pointer constant propagation */
+	__asm__ __volatile__ (".section .fini");
+	(*call__dtors)();
+	__asm__ __volatile__ (".section .trash");
+	
+}
diff --git a/libc/sysdeps/linux/nios/crtend.c b/libc/sysdeps/linux/nios/crtend.c
new file mode 100644
index 000000000..26af229af
--- /dev/null
+++ b/libc/sysdeps/linux/nios/crtend.c
@@ -0,0 +1,43 @@
+#include <errno.h>
+#include <stdlib.h>
+/*
+static void (*__CTOR_END__[1]) __P((void))
+    __attribute__((section(".ctors"))) = { (void *)-1 };
+
+static void (*__DTOR_END__[1]) __P((void))
+    __attribute__((__unused__))
+    __attribute__((section(".dtors"))) = { (void *)0 };
+*/
+extern void (*__CTOR_END__[]) __P((void));
+static void	__do_global_ctors_aux __P((void));
+
+static void
+__do_global_ctors_aux()
+{
+	void (**p)(void) = __CTOR_END__ - 1;
+
+	while (*p)
+		(**p--)();
+}
+
+static void dummy_init(void) __attribute__((section(".trash")));
+
+void
+dummy_init(void)
+{
+	static int initialized = 0;
+	static void (*volatile call__ctors)(void) = __do_global_ctors_aux;
+	/*
+	 * Call global constructors.
+	 * Arrange to call global destructors at exit.
+	 */
+	/* prevent function pointer constant propagation */
+	__asm__ __volatile__ (".section .init");
+	
+	if (!initialized) {
+		initialized = 1;
+		(*call__ctors)();
+	}
+	__asm__ __volatile__ (".section .trash");
+
+}
\ No newline at end of file
diff --git a/libc/sysdeps/linux/nios/fpu_control.h b/libc/sysdeps/linux/nios/fpu_control.h
new file mode 100644
index 000000000..b7cdf2f3e
--- /dev/null
+++ b/libc/sysdeps/linux/nios/fpu_control.h
@@ -0,0 +1,97 @@
+/* FPU control word bits.  Nios2 version.
+   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H
+
+/* MIPS FPU floating point control register bits.
+ *
+ * 31-25  -> floating point conditions code bits 7-1.  These bits are only
+ *           available in MIPS IV.
+ * 24     -> flush denormalized results to zero instead of
+ *           causing unimplemented operation exception.  This bit is only
+ *           available for MIPS III and newer.
+ * 23     -> Condition bit
+ * 22-18  -> reserved (read as 0, write with 0)
+ * 17     -> cause bit for unimplemented operation
+ * 16     -> cause bit for invalid exception
+ * 15     -> cause bit for division by zero exception
+ * 14     -> cause bit for overflow exception
+ * 13     -> cause bit for underflow exception
+ * 12     -> cause bit for inexact exception
+ * 11     -> enable exception for invalid exception
+ * 10     -> enable exception for division by zero exception
+ *  9     -> enable exception for overflow exception
+ *  8     -> enable exception for underflow exception
+ *  7     -> enable exception for inexact exception
+ *  6     -> flag invalid exception
+ *  5     -> flag division by zero exception
+ *  4     -> flag overflow exception
+ *  3     -> flag underflow exception
+ *  2     -> flag inexact exception
+ *  1-0   -> rounding control
+ *
+ *
+ * Rounding Control:
+ * 00 - rounding to nearest (RN)
+ * 01 - rounding toward zero (RZ)
+ * 10 - rounding (up) toward plus infinity (RP)
+ * 11 - rounding (down)toward minus infinity (RM)
+ */
+
+#include <features.h>
+
+/* masking of interrupts */
+#define _FPU_MASK_V     0x0800  /* Invalid operation */
+#define _FPU_MASK_Z     0x0400  /* Division by zero  */
+#define _FPU_MASK_O     0x0200  /* Overflow          */
+#define _FPU_MASK_U     0x0100  /* Underflow         */
+#define _FPU_MASK_I     0x0080  /* Inexact operation */
+
+/* flush denormalized numbers to zero */
+#define _FPU_FLUSH_TZ   0x1000000
+
+/* rounding control */
+#define _FPU_RC_NEAREST 0x0     /* RECOMMENDED */
+#define _FPU_RC_ZERO    0x1
+#define _FPU_RC_UP      0x2
+#define _FPU_RC_DOWN    0x3
+
+#define _FPU_RESERVED 0xfe3c0000  /* Reserved bits in cw */
+
+
+/* The fdlibm code requires strict IEEE double precision arithmetic,
+   and no interrupts for exceptions, rounding to nearest.  */
+
+#define _FPU_DEFAULT  0x00000000
+
+/* IEEE:  same as above, but exceptions */
+#define _FPU_IEEE     0x00000F80
+
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__SI__)));
+
+/* Macros for accessing the hardware control word.  */
+#define _FPU_GETCW(cw) __asm__ ("cfc1 %0,$31" : "=r" (cw))
+#define _FPU_SETCW(cw) __asm__ ("ctc1 %0,$31" : : "r" (cw))
+
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+
+#endif	/* fpu_control.h */
diff --git a/libc/sysdeps/linux/nios/setjmp.S b/libc/sysdeps/linux/nios/setjmp.S
new file mode 100644
index 000000000..70bd75c5d
--- /dev/null
+++ b/libc/sysdeps/linux/nios/setjmp.S
@@ -0,0 +1,101 @@
+/* Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#define _ASM
+#define _SETJMP_H
+#include <bits/setjmp.h>
+#include "NM_Macros.S"
+
+;----------------------------------------
+;         Name: __sigsetjmp
+;  Description: Save the current context so
+;               a nr_longjmp works later.
+;        Input: %o0: jmp_buf: (ptr to) array to store context in
+;       Output: %o0 = 0 the first time we're called, or
+;               whatever longjmp returns later
+; Side Effects: Uses %g0
+;    CWP Depth: 0
+;
+
+	.align	2
+	.global	_setjmp
+	
+_setjmp:
+	br	__sigsetjmp
+	 movi	%o1,0		; (Delay slot) Set signal mask to zero
+
+	.align	2
+	.global	setjmp
+	
+setjmp:
+	MOVIP	%o1,1		; Set signal mask to 1 to save mask
+
+	.align	2
+	.global	__sigsetjmp
+
+__sigsetjmp:
+	pfx	jmpbuf_callersret ; present return address
+	st	[%o0],%i7	
+	pfx	jmpbuf_jmpret	; where the longjmp will later execute from
+	st	[%o0],%o7	
+	pfx	jmpbuf_sp	; Save stack pointer
+	st	[%o0],%o6
+	pfx	jmpbuf_l0	; Save local register l0
+	st	[%o0],%l0
+	pfx	jmpbuf_l1	; Save local register l1
+	st	[%o0],%l1
+	pfx	jmpbuf_l2	; Save local register l2
+	st	[%o0],%l2
+	pfx	jmpbuf_l3	; Save local register l3
+	st	[%o0],%l3
+	pfx	jmpbuf_l4	; Save local register l4
+	st	[%o0],%l4
+	pfx	jmpbuf_l5	; Save local register l5
+	st	[%o0],%l5
+	pfx	jmpbuf_l6	; Save local register l6
+	st	[%o0],%l6
+	pfx	jmpbuf_l7	; Save local register l7
+	st	[%o0],%l7
+	pfx	jmpbuf_i0	; Save input register i0
+	st	[%o0],%i0
+	pfx	jmpbuf_i1	; Save input register i1
+	st	[%o0],%i1
+	pfx	jmpbuf_i2	; Save input register i2
+	st	[%o0],%i2
+	pfx	jmpbuf_i3	; Save input register i3
+	st	[%o0],%i3
+	pfx	jmpbuf_i4	; Save input register i4
+	st	[%o0],%i4
+	pfx	jmpbuf_i5	; Save input register i5
+	st	[%o0],%i5
+	pfx	%hi(__sigjmp_save@h)	  ; Load up %g0 with address
+	movi	%g0,%lo(__sigjmp_save@h)
+	pfx	%xhi(__sigjmp_save@h)
+	movhi	%g0,%xlo(__sigjmp_save@h)
+	jmp	%g0
+	 nop			; (delay slot)
+
+
+
+
+
+
+
+
+
+
diff --git a/libc/sysdeps/linux/nios/sys/procfs.h b/libc/sysdeps/linux/nios/sys/procfs.h
new file mode 100644
index 000000000..8cbaa41c5
--- /dev/null
+++ b/libc/sysdeps/linux/nios/sys/procfs.h
@@ -0,0 +1,123 @@
+/* Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somehow modelled after the file of the same name on SysVr4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  */
+
+#include <features.h>
+#include <signal.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/ucontext.h>
+#include <sys/user.h>
+#include <bits/wordsize.h>
+
+__BEGIN_DECLS
+
+#define ELF_NGREG		38
+
+typedef struct
+  {
+    union
+      {
+	unsigned long	pr_regs[32];
+	double		pr_dregs[16];
+      }			pr_fr;
+    unsigned long	__unused;
+    unsigned long	pr_fsr;
+    unsigned char	pr_qcnt;
+    unsigned char	pr_q_entrysize;
+    unsigned char	pr_en;
+    unsigned int	pr_q[64];
+  } elf_fpregset_t;
+
+typedef unsigned long elf_greg_t;
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   gdb doesn't really use excluded.  Fields present but not used are
+   marked with "XXX".  */
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __pid_t lwpid_t;
+
+
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff --git a/libc/sysdeps/linux/nios/sys/ucontext.h b/libc/sysdeps/linux/nios/sys/ucontext.h
new file mode 100644
index 000000000..1805b4eac
--- /dev/null
+++ b/libc/sysdeps/linux/nios/sys/ucontext.h
@@ -0,0 +1,104 @@
+/* Copyright (C) 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+/*
+ * Location of the users' stored registers relative to R0.
+ * Usage is as an index into a gregset_t array or as u.u_ar0[XX].
+ */
+#define REG_PSR (0)
+#define REG_PC  (1)
+#define REG_SPARE   (2)
+#define REG_WVALID  (3)
+#define REG_G1  (4)
+#define REG_G2  (5)
+#define REG_G3  (6)
+#define REG_G4  (7)
+#define REG_G5  (8)
+#define REG_G6  (9)
+#define REG_G7  (10)
+#define REG_O0  (11)
+#define REG_O1  (12)
+#define REG_O2  (13)
+#define REG_O3  (14)
+#define REG_O4  (15)
+#define REG_O5  (16)
+#define REG_O6  (17)
+#define REG_O7  (18)
+#define REG_GLOBALS (19)
+
+/*
+ * A gregset_t is defined as an array type for compatibility with the reference
+ * source. This is important due to differences in the way the C language
+ * treats arrays and structures as parameters.
+ *
+ * Note that NGREG is really (sizeof (struct regs) / sizeof (greg_t)),
+ * but that the ABI defines it absolutely to be 21 (resp. 19).
+ */
+
+#define NGREG   20
+typedef int greg_t;
+
+typedef greg_t  gregset_t[NGREG];
+
+/*
+ * The following structures define how a register window can appear on the
+ * stack. This structure is available (when required) through the `gwins'
+ * field of an mcontext (nested within ucontext). NIOS_MAXWINDOW is the
+ * maximum number of outstanding register windows defined in the NIOS
+ * architecture (*not* implementation).
+ */
+#define NIOS_MAXREGWINDOW	31	/* max windows in NIOS arch. */
+struct  rwindow
+  {
+    greg_t rw_local[8];			/* locals */
+    greg_t rw_in[8];			/* ins */
+  };
+
+#define rw_fp   rw_in[6]		/* frame pointer */
+#define rw_rtn  rw_in[7]		/* return address */
+
+typedef struct gwindows
+  {
+    int            wbcnt;
+    int           *spbuf[NIOS_MAXREGWINDOW];
+    struct rwindow wbuf[NIOS_MAXREGWINDOW];
+  } gwindows_t;
+
+typedef struct
+  {
+    gregset_t   gregs;		/* general register set */
+    gwindows_t  *gwins;		/* POSSIBLE pointer to register windows */
+  } mcontext_t;
+
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long   uc_flags;
+    struct ucontext *uc_link;
+    __sigset_t	    uc_sigmask;
+    stack_t         uc_stack;
+    mcontext_t      uc_mcontext;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff --git a/libc/sysdeps/linux/nios/vfork.S b/libc/sysdeps/linux/nios/vfork.S
new file mode 100644
index 000000000..22b3c30cd
--- /dev/null
+++ b/libc/sysdeps/linux/nios/vfork.S
@@ -0,0 +1,58 @@
+/*
+ * libc/sysdeps/linux/nios/vfork.S -- `vfork' syscall for linux/nios
+ *
+ *  Copyright (C) 2004  Microtronix Datacom Ltd
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License.  See the file COPYING.LIB in the main
+ * directory of this archive for more details.
+ * 
+ * Written by Wentao Xu <wentao@microtronix.com>
+ */
+#include <asm/unistd.h>
+#include "NM_Macros.S"
+
+#ifndef __NR_vfork
+#define __NR_vfork __NR_fork /* uClinux-2.0 only has fork which is vfork */
+#endif
+
+   .text
+   .align 2
+   .globl errno
+   .globl vfork
+   .globl __libc_vfork
+#if defined __HAVE_ELF__
+   .type    vfork,@function
+   .type    __libc_vfork,@function
+#endif
+vfork:
+__libc_vfork:
+	MOVIP	%g1, __NR_vfork
+	trap	63
+	
+	bgen	%g1, 12
+	not		%g1			/* (unsigned long) -4096 */
+	cmp		%o0, %g1
+	skps	cc_hi
+ 	  jmp	%o7
+	  nop
+	  
+fix_errno:
+	neg		%o0
+	save	%sp, -16
+	MOVIA	%g1, __errno_location@h
+	call	%g1
+	 nop
+	st	[%o0], %i0		/* store errno */
+	
+	xor %i0, %i0
+	subi %i0, 1		/* retval=-1 */
+	ret
+	 restore
+	
+		
+	
+
+
+
+
diff --git a/libc/sysdeps/linux/nios2/Makefile b/libc/sysdeps/linux/nios2/Makefile
new file mode 100644
index 000000000..59b2a8152
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/Makefile
@@ -0,0 +1,86 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2003 Erik Andersen <andersen@uclibc.org>
+#
+# This program is free software; you can redistribute it and/or modify it under
+# the terms of the GNU Library General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option) any
+# later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+# details.
+#
+# You should have received a copy of the GNU Library General Public License
+# along with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+TOPDIR=../../../../
+include $(TOPDIR)Rules.mak
+ASFLAGS=$(CFLAGS)
+
+CRT0_SRC = crt0.S
+CRT0_OBJ = crt0.o crt1.o
+CTOR_TARGETS=$(TOPDIR)lib/crti.o $(TOPDIR)lib/crtn.o
+
+SSRC= __longjmp.S bsd-_setjmp.S bsd-setjmp.S setjmp.S vfork.S clone.S
+SOBJS=$(patsubst %.S,%.o, $(SSRC))
+
+CSRC= brk.c syscall.c
+COBJS=$(patsubst %.c,%.o, $(CSRC))
+
+OBJS=$(SOBJS) $(MOBJ) $(COBJS)
+
+all: $(OBJS) $(LIBC)
+
+$(LIBC): ar-target 
+
+ar-target: $(OBJS) $(CRT0_OBJ) $(CTOR_TARGETS)
+	$(AR) $(ARFLAGS) $(LIBC) $(OBJS)
+	cp $(CRT0_OBJ) $(TOPDIR)lib/
+
+$(CRT0_OBJ): $(CRT0_SRC)
+	$(CC) $(CFLAGS) -DL_$* $< -c -o $*.o
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+$(SOBJS): %.o : %.S
+	$(CC) $(CFLAGS) -c $< -o $@
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+$(COBJS): %.o : %.c
+	$(CC) $(CFLAGS) -c $< -o $@
+	$(STRIPTOOL) -x -R .note -R .comment $*.o
+
+ifeq ($(strip $(UCLIBC_CTOR_DTOR)),y)
+crti.o: crti.S
+	$(CC) $(CFLAGS) -c crti.S -o crti.o
+
+$(TOPDIR)lib/crti.o: crti.o
+	$(INSTALL) -d $(TOPDIR)lib/
+	cp crti.o $(TOPDIR)lib/
+
+crtn.o: crtn.S
+	$(CC) $(CFLAGS) -c crtn.S -o crtn.o
+
+$(TOPDIR)lib/crtn.o: crtn.o
+	$(INSTALL) -d $(TOPDIR)lib/
+	cp crtn.o $(TOPDIR)lib/
+else
+$(TOPDIR)lib/crti.o:
+	$(INSTALL) -d $(TOPDIR)lib/
+	$(AR) $(ARFLAGS) $(TOPDIR)lib/crti.o
+$(TOPDIR)lib/crtn.o:
+	$(INSTALL) -d $(TOPDIR)lib/
+	$(AR) $(ARFLAGS) $(TOPDIR)lib/crtn.o
+endif
+
+
+headers:
+	$(LN) -fs ../libc/sysdeps/linux/nios2/fpu_control.h $(TOPDIR)/include/
+
+clean:
+	$(RM) *.[oa] *~ core
+	$(RM) bits/sysnum.h
+	$(RM) $(TOPDIR)/include/fpu_control.h
+	
diff --git a/libc/sysdeps/linux/nios2/__longjmp.S b/libc/sysdeps/linux/nios2/__longjmp.S
new file mode 100644
index 000000000..d15f040cd
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/__longjmp.S
@@ -0,0 +1,48 @@
+/*
+ * libc/sysdeps/linux/nios2/__longjmp.S
+ *
+ *  Copyright (C) 2004,05,06  Microtronix Datacom Ltd
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License.  See the file COPYING.LIB in the main
+ * directory of this archive for more details.
+ * 
+ * Written by Wentao Xu <wentao@microtronix.com>
+ * 
+ */
+
+#define _ASM
+#define _SETJMP_H
+#include <bits/setjmp.h>
+
+.globl __longjmp
+.type  __longjmp,@function
+.balign 4
+
+__longjmp:
+    /* return value is in r5*/
+    mov     r2,  r5
+  
+    /* jmp_buf in r4, restore regs.  */
+    ldw     r16, (JB_REGS+ 0)(r4)
+    ldw     r17, (JB_REGS+ 4)(r4)
+    ldw     r18, (JB_REGS+ 8)(r4)
+    ldw     r19, (JB_REGS+12)(r4)
+    ldw     r20, (JB_REGS+16)(r4)
+    ldw     r21, (JB_REGS+20)(r4)
+    ldw     r22, (JB_REGS+24)(r4)
+    ldw     r23, (JB_REGS+28)(r4)
+    
+    ldw     ra, JB_PC(r4)
+    ldw     fp, JB_FP(r4)
+    ldw     gp, JB_GP(r4)
+    ldw     sp, JB_SP(r4)
+    
+#if defined(__HAVE_FPU__)
+    RESTORE_FPU r4 JB_FPREGS
+#endif
+
+  /* return to saved RA */    
+    ret
+
+
diff --git a/libc/sysdeps/linux/nios2/bits/endian.h b/libc/sysdeps/linux/nios2/bits/endian.h
new file mode 100644
index 000000000..54bd9d14b
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/endian.h
@@ -0,0 +1,7 @@
+/* i386 is little-endian.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __LITTLE_ENDIAN
diff --git a/libc/sysdeps/linux/nios2/bits/fcntl.h b/libc/sysdeps/linux/nios2/bits/fcntl.h
new file mode 100644
index 000000000..4b41b4715
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/fcntl.h
@@ -0,0 +1,180 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+
+#include <sys/types.h>
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		 010000
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 020000
+
+#ifdef __USE_GNU
+# define O_DIRECTORY	 040000	/* Must be a directory.	 */
+# define O_NOFOLLOW	0100000	/* Do not follow links.	 */
+# define O_DIRECT	0200000	/* Direct disk access.	*/
+# define O_STREAMING	04000000/* streaming access */
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0400000
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+#else
+# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+#endif
+#define F_GETLK64	12	/* Get record locking info.  */
+#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+# define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
+# define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+#endif
+
+/* For F_[GET|SET]FL.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* For old implementation of bsd flock().  */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
diff --git a/libc/sysdeps/linux/nios2/bits/kernel_stat.h b/libc/sysdeps/linux/nios2/bits/kernel_stat.h
new file mode 100644
index 000000000..bfef64cea
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/kernel_stat.h
@@ -0,0 +1,56 @@
+#ifndef _BITS_STAT_STRUCT_H
+#define _BITS_STAT_STRUCT_H
+
+/* This file provides whatever this particular arch's kernel thinks 
+ * struct kernel_stat should look like...  It turns out each arch has a 
+ * different opinion on the subject... */
+
+struct kernel_stat {
+	unsigned short st_dev;
+	unsigned short __pad1;
+	unsigned long st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned short __pad2;
+	unsigned long  st_size;
+	unsigned long  st_blksize;
+	unsigned long  st_blocks;
+	unsigned long  st_atime;
+	unsigned long  __unused1;
+	unsigned long  st_mtime;
+	unsigned long  __unused2;
+	unsigned long  st_ctime;
+	unsigned long  __unused3;
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+struct kernel_stat64 {
+	unsigned short	st_dev;
+	unsigned char	__pad0[10];
+#define _HAVE_STAT64___ST_INO
+	unsigned long	__st_ino;
+	unsigned int	st_mode;
+	unsigned int	st_nlink;
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+	unsigned short	st_rdev;
+	unsigned char	__pad3[10];
+	long long	st_size;
+	unsigned long	st_blksize;
+	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
+	unsigned long	__pad4;		/* future possible st_blocks high bits */
+	unsigned long	st_atime;
+	unsigned long	__pad5;
+	unsigned long	st_mtime;
+	unsigned long	__pad6;
+	unsigned long	st_ctime;
+	unsigned long	__pad7;		/* will be high 32 bits of ctime someday */
+	unsigned long long	st_ino;
+};
+
+#endif	/*  _BITS_STAT_STRUCT_H */
+
diff --git a/libc/sysdeps/linux/nios2/bits/kernel_types.h b/libc/sysdeps/linux/nios2/bits/kernel_types.h
new file mode 100644
index 000000000..1fd1c4aaa
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/kernel_types.h
@@ -0,0 +1,44 @@
+/* Note that we use the exact same include guard #define names
+ * as asm/posix_types.h.  This will avoid gratuitous conflicts 
+ * with the posix_types.h kernel header, and will ensure that 
+ * our private content, and not the kernel header, will win.
+ *  -Erik
+ */
+#ifndef __ARCH_NIOS2_POSIX_TYPES_H
+#define __ARCH_NIOS2_POSIX_TYPES_H
+
+typedef unsigned long	__kernel_dev_t;
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned short	__kernel_mode_t;
+typedef unsigned short	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned short	__kernel_ipc_pid_t;
+typedef unsigned short	__kernel_uid_t;
+typedef unsigned short	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+typedef unsigned short	__kernel_old_uid_t;
+typedef unsigned short	__kernel_old_gid_t;
+typedef unsigned short	__kernel_old_dev_t;
+typedef long long	__kernel_loff_t;
+
+typedef struct {
+#ifdef __USE_ALL
+	int val[2];
+#else
+	int __val[2];
+#endif
+} __kernel_fsid_t;
+
+#endif /* __ARCH_NIOS2_POSIX_TYPES_H */
diff --git a/libc/sysdeps/linux/nios2/bits/mathdef.h b/libc/sysdeps/linux/nios2/bits/mathdef.h
new file mode 100644
index 000000000..44d7f0dde
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/mathdef.h
@@ -0,0 +1,48 @@
+/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _MATH_H && !defined _COMPLEX_H
+# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
+#endif
+
+#if defined  __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
+# define _MATH_H_MATHDEF	1
+
+/* GCC does not promote `float' values to `double'.  */
+typedef float float_t;		/* `float' expressions are evaluated as
+				   `float'.  */
+typedef double double_t;	/* `double' expressions are evaluated as
+				   `double'.  */
+
+/* Define `INFINITY' as value of type `float'.  */
+# define INFINITY	HUGE_VALF
+
+
+/* The values returned by `ilogb' for 0 and NaN respectively.  */
+# define FP_ILOGB0	(-2147483647)
+# define FP_ILOGBNAN	(2147483647)
+
+#endif	/* ISO C99 */
+
+#ifndef __NO_LONG_DOUBLE_MATH
+/* Signal that we do not really have a `long double'.  This disables the
+   declaration of all the `long double' function variants.  */
+/* XXX The FPA does support this but the patterns in GCC are currently
+   turned off.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff --git a/libc/sysdeps/linux/nios2/bits/mman.h b/libc/sysdeps/linux/nios2/bits/mman.h
new file mode 100644
index 000000000..34f14ee5b
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/mman.h
@@ -0,0 +1,75 @@
+/* Definitions for POSIX memory map interface.  Linux/m68k version.
+   Copyright (C) 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+#endif
diff --git a/libc/sysdeps/linux/nios2/bits/profil-counter.h b/libc/sysdeps/linux/nios2/bits/profil-counter.h
new file mode 100644
index 000000000..3aa3fc0ad
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/profil-counter.h
@@ -0,0 +1,26 @@
+/* Low-level statistical profiling support function.  Linux/SPARC version.
+   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <signal.h>
+
+void
+profil_counter (int signo, struct sigcontext *si)
+{
+  profil_count ((void *) si->regs.ea);
+}
diff --git a/libc/sysdeps/linux/nios2/bits/resource.h b/libc/sysdeps/linux/nios2/bits/resource.h
new file mode 100644
index 000000000..06ecca45a
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/resource.h
@@ -0,0 +1,209 @@
+/* Bit values & structures for resource limits.  Linux/x86 version.
+   Copyright (C) 1994,1996,1997,1998,1999,2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  RLIMIT_RSS = 5,
+#define	RLIMIT_RSS RLIMIT_RSS
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 7,
+  RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+#define RLIMIT_NOFILE RLIMIT_NOFILE
+#define RLIMIT_OFILE RLIMIT_OFILE
+
+  /* Address space limit.  */
+  RLIMIT_AS = 9,
+#define RLIMIT_AS RLIMIT_AS
+
+  /* Number of processes.  */
+  RLIMIT_NPROC = 6,
+#define RLIMIT_NPROC RLIMIT_NPROC
+
+  /* Locked-in-memory address space.  */
+  RLIMIT_MEMLOCK = 8,
+#define RLIMIT_MEMLOCK RLIMIT_MEMLOCK
+
+  /* Maximum number of file locks.  */
+  RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS RLIMIT_LOCKS
+
+  RLIMIT_NLIMITS = 11,
+  RLIM_NLIMITS = RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS RLIMIT_NLIMITS
+#define RLIM_NLIMITS RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY ((unsigned long int)(~0UL))
+#else
+# define RLIM_INFINITY 0xffffffffffffffffuLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0xffffffffffffffffuLL
+#endif
+
+/* We can represent all limits.  */
+#define RLIM_SAVED_MAX	RLIM_INFINITY
+#define RLIM_SAVED_CUR	RLIM_INFINITY
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1,
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+
+  /* Both.  */
+  RUSAGE_BOTH = -2
+#define RUSAGE_BOTH RUSAGE_BOTH
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
diff --git a/libc/sysdeps/linux/nios2/bits/setjmp.h b/libc/sysdeps/linux/nios2/bits/setjmp.h
new file mode 100644
index 000000000..ea7699d09
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/setjmp.h
@@ -0,0 +1,67 @@
+/* Define the machine-dependent type `jmp_buf'.  Nios2 version.
+   Copyright (C) 1992,93,95,97,2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SETJMP_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+#ifndef	_ASM
+typedef struct
+{
+    /* Callee-saved registers r16 through r23.  */
+    unsigned long __regs[8];
+
+    /* Program counter.  */
+    unsigned long __pc;
+
+    /* Stack pointer.  */
+    unsigned long __sp;
+
+    /* The frame pointer.  */
+    unsigned long __fp;
+
+    /* The global pointer.  */
+    unsigned long __gp;
+
+	/* floating point regs, if any */
+#if defined __HAVE_FPU__
+    unsigned long __fpregs[64];
+#endif	
+} __jmp_buf[1];
+
+#endif
+
+#define JB_REGS		0
+#define JB_PC		32
+#define JB_SP		36
+#define JB_FP		40
+#define JB_GP		44
+#define JB_FPREGS 	48
+
+#if defined __HAVE_FPU__
+# define JB_SIZE 304
+#else
+# define JB_SIZE 48
+#endif
+
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *) (address) < (void*)(jmpbuf)->__sp)
diff --git a/libc/sysdeps/linux/nios2/bits/sigcontextinfo.h b/libc/sysdeps/linux/nios2/bits/sigcontextinfo.h
new file mode 100644
index 000000000..d6383b970
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/sigcontextinfo.h
@@ -0,0 +1,26 @@
+/* Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define SIGCONTEXT struct sigcontext *
+#define SIGCONTEXT_EXTRA_ARGS
+#define GET_PC(ctx)	((void *) (ctx)->regs.ea)
+#define GET_FRAME(ctx)	((void *) (ctx)->regs.sp)
+#define GET_STACK(ctx)	((void *) (ctx)->regs.fp)
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
diff --git a/libc/sysdeps/linux/nios2/bits/stackinfo.h b/libc/sysdeps/linux/nios2/bits/stackinfo.h
new file mode 100644
index 000000000..e7fbf5633
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/stackinfo.h
@@ -0,0 +1,28 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+/* On nios II the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+#endif	/* stackinfo.h */
diff --git a/libc/sysdeps/linux/nios2/bits/stat.h b/libc/sysdeps/linux/nios2/bits/stat.h
new file mode 100644
index 000000000..f446a91db
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/stat.h
@@ -0,0 +1,134 @@
+/* Copyright (C) 1992,95,96,97,98,99,2000,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STAT_H
+# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+/* Versions of the `struct stat' data structure.  */
+#define _STAT_VER_LINUX_OLD	1
+#define _STAT_VER_KERNEL	1
+#define _STAT_VER_SVR4		2
+#define _STAT_VER_LINUX		3
+#define _STAT_VER		_STAT_VER_LINUX	/* The one defined below.  */
+
+/* Versions of the `xmknod' interface.  */
+#define _MKNOD_VER_LINUX	1
+#define _MKNOD_VER_SVR4		2
+#define _MKNOD_VER		_MKNOD_VER_LINUX /* The bits defined below.  */
+
+
+struct stat
+  {
+    __dev_t st_dev;			/* Device.  */
+    unsigned short int __pad1;
+#ifndef __USE_FILE_OFFSET64
+    __ino_t st_ino;			/* File serial number.	*/
+#else
+    __ino_t __st_ino;			/* 32bit file serial number.	*/
+#endif
+    __mode_t st_mode;			/* File mode.  */
+    __nlink_t st_nlink;			/* Link count.  */
+    __uid_t st_uid;			/* User ID of the file's owner.	*/
+    __gid_t st_gid;			/* Group ID of the file's group.*/
+    __dev_t st_rdev;			/* Device number, if device.  */
+    unsigned short int __pad2;
+#ifndef __USE_FILE_OFFSET64
+    __off_t st_size;			/* Size of file, in bytes.  */
+#else
+    __off64_t st_size;			/* Size of file, in bytes.  */
+#endif
+    __blksize_t st_blksize;		/* Optimal block size for I/O.  */
+
+#ifndef __USE_FILE_OFFSET64
+    __blkcnt_t st_blocks;		/* Number 512-byte blocks allocated. */
+#else
+    __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+#endif
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int __unused1;
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int __unused2;
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int __unused3;
+#ifndef __USE_FILE_OFFSET64
+    unsigned long int __unused4;
+    unsigned long int __unused5;
+#else
+    __ino64_t st_ino;			/* File serial number.	*/
+#endif
+  };
+
+#ifdef __USE_LARGEFILE64
+struct stat64
+  {
+    __dev_t st_dev;			/* Device.  */
+    unsigned int __pad1;
+
+    __ino_t __st_ino;			/* 32bit file serial number.	*/
+    __mode_t st_mode;			/* File mode.  */
+    __nlink_t st_nlink;			/* Link count.  */
+    __uid_t st_uid;			/* User ID of the file's owner.	*/
+    __gid_t st_gid;			/* Group ID of the file's group.*/
+    __dev_t st_rdev;			/* Device number, if device.  */
+    unsigned int __pad2;
+    __off64_t st_size;			/* Size of file, in bytes.  */
+    __blksize_t st_blksize;		/* Optimal block size for I/O.  */
+
+    __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int __unused1;
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int __unused2;
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int __unused3;
+    __ino64_t st_ino;			/* File serial number.		*/
+  };
+#endif
+
+/* Tell code we have these members.  */
+#define	_STATBUF_ST_BLKSIZE
+#define _STATBUF_ST_RDEV
+
+/* Encoding of the file mode.  */
+
+#define	__S_IFMT	0170000	/* These bits determine file type.  */
+
+/* File types.  */
+#define	__S_IFDIR	0040000	/* Directory.  */
+#define	__S_IFCHR	0020000	/* Character device.  */
+#define	__S_IFBLK	0060000	/* Block device.  */
+#define	__S_IFREG	0100000	/* Regular file.  */
+#define	__S_IFIFO	0010000	/* FIFO.  */
+#define	__S_IFLNK	0120000	/* Symbolic link.  */
+#define	__S_IFSOCK	0140000	/* Socket.  */
+
+/* POSIX.1b objects.  Note that these macros always evaluate to zero.  But
+   they do it by enforcing the correct use of the macros.  */
+#define __S_TYPEISMQ(buf)  ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSEM(buf) ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSHM(buf) ((buf)->st_mode - (buf)->st_mode)
+
+/* Protection bits.  */
+
+#define	__S_ISUID	04000	/* Set user ID on execution.  */
+#define	__S_ISGID	02000	/* Set group ID on execution.  */
+#define	__S_ISVTX	01000	/* Save swapped text after use (sticky).  */
+#define	__S_IREAD	0400	/* Read by owner.  */
+#define	__S_IWRITE	0200	/* Write by owner.  */
+#define	__S_IEXEC	0100	/* Execute by owner.  */
diff --git a/libc/sysdeps/linux/nios2/bits/syscalls.h b/libc/sysdeps/linux/nios2/bits/syscalls.h
new file mode 100644
index 000000000..62541b873
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/syscalls.h
@@ -0,0 +1,19 @@
+#ifndef _BITS_SYSCALLS_H
+#define _BITS_SYSCALLS_H
+#ifndef _SYSCALL_H
+# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
+#endif
+
+#include <features.h>
+
+/* Do something very evil for now.  Until we create our own syscall
+ * macros, short circuit bits/sysnum.h  and use asm/unistd.h instead */
+#include <asm/unistd.h>
+
+/* This includes the `__NR_<name>' syscall numbers taken from the Linux kernel
+ * header files.  It also defines the traditional `SYS_<name>' macros for older
+ * programs.  */
+#include <bits/sysnum.h>
+
+#endif /* _BITS_SYSCALLS_H */
+
diff --git a/libc/sysdeps/linux/nios2/bits/wordsize.h b/libc/sysdeps/linux/nios2/bits/wordsize.h
new file mode 100644
index 000000000..ba643b60a
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bits/wordsize.h
@@ -0,0 +1,19 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __WORDSIZE	32
diff --git a/libc/sysdeps/linux/nios2/brk.c b/libc/sysdeps/linux/nios2/brk.c
new file mode 100644
index 000000000..3b81e7018
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/brk.c
@@ -0,0 +1,46 @@
+/* brk system call for Linux/Nios2.
+   Copyright (C) 1995, 1996, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <errno.h>
+
+
+/* This must be initialized data because commons can't have aliases.  */
+void *___brk_addr = 0;
+
+
+int brk (void *addr)
+{
+    void *newbrk;
+    register int r2 asm("r2") = TRAP_ID_SYSCALL;
+    register int r3 asm("r3") = __NR_brk;
+    register void *r4 asm("r4") = addr;
+
+    asm volatile ("trap\n\t" : "=r"(newbrk) : "0"(r2), "r"(r3), "r"(r4));
+
+    ___brk_addr = newbrk;
+
+    if (newbrk < addr) {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+    return 0;
+}
diff --git a/libc/sysdeps/linux/nios2/bsd-_setjmp.S b/libc/sysdeps/linux/nios2/bsd-_setjmp.S
new file mode 100644
index 000000000..ed4061cd4
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bsd-_setjmp.S
@@ -0,0 +1,45 @@
+/*
+ * libc/sysdeps/linux/nios2/bsd-_setjmp.S
+ *
+ *  Copyright (C) 2004,05,06  Microtronix Datacom Ltd
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License.  See the file COPYING.LIB in the main
+ * directory of this archive for more details.
+ * 
+ * Written by Wentao Xu <wentao@microtronix.com>
+ * 
+ */
+
+#define _ASM
+#define _SETJMP_H
+#include <bits/setjmp.h>
+
+   .globl _setjmp
+   .type  _setjmp,@function
+   .balign 4
+
+_setjmp:
+    stw     r16, (JB_REGS+ 0)(r4)
+    stw     r17, (JB_REGS+ 4)(r4)
+    stw     r18, (JB_REGS+ 8)(r4)
+    stw     r19, (JB_REGS+12)(r4)
+    stw     r20, (JB_REGS+16)(r4)
+    stw     r21, (JB_REGS+20)(r4)
+    stw     r22, (JB_REGS+24)(r4)
+    stw     r23, (JB_REGS+28)(r4)
+    
+    stw     ra, JB_PC(r4)
+    stw     sp, JB_SP(r4)
+    stw     fp, JB_FP(r4)
+    stw     gp, JB_GP(r4)
+    
+#if defined(__HAVE_FPU__)
+    SAVE_FPU r4 JB_FPREGS
+#endif
+    stw     r0, JB_SIZE(r4) /* signal mask is not saved */
+    mov     r2, zero
+    ret
+
+
+
diff --git a/libc/sysdeps/linux/nios2/bsd-setjmp.S b/libc/sysdeps/linux/nios2/bsd-setjmp.S
new file mode 100644
index 000000000..ac99bfe0a
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/bsd-setjmp.S
@@ -0,0 +1,52 @@
+/*
+ * libc/sysdeps/linux/nios2/bsd-setjmp.S
+ *
+ *  Copyright (C) 2004,05,06  Microtronix Datacom Ltd
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License.  See the file COPYING.LIB in the main
+ * directory of this archive for more details.
+ * 
+ * Written by Wentao Xu <wentao@microtronix.com>
+ * 
+ */
+
+
+#define _ASM
+#define _SETJMP_H
+#include <bits/setjmp.h>
+
+   .globl setjmp
+   .type  setjmp,@function
+   .balign 4
+
+setjmp:
+    stw     r16, (JB_REGS+ 0)(r4)
+    stw     r17, (JB_REGS+ 4)(r4)
+    stw     r18, (JB_REGS+ 8)(r4)
+    stw     r19, (JB_REGS+12)(r4)
+    stw     r20, (JB_REGS+16)(r4)
+    stw     r21, (JB_REGS+20)(r4)
+    stw     r22, (JB_REGS+24)(r4)
+    stw     r23, (JB_REGS+28)(r4)
+    
+    stw     ra, JB_PC(r4)
+    stw     sp, JB_SP(r4)
+    stw     fp, JB_FP(r4)
+    stw     gp, JB_GP(r4)
+    
+#if defined(__HAVE_FPU__)
+    SAVE_FPU r4 JB_FPREGS
+#endif
+
+    movui r5, 1
+#ifdef __PIC__
+    /* just pray 16 bit offset is enough */
+    br __sigjmp_save
+#else
+    movhi r8, %hi(__sigjmp_save)
+    ori r8, r8, %lo(__sigjmp_save)    
+    jmp r8
+#endif
+
+
diff --git a/libc/sysdeps/linux/nios2/clone.S b/libc/sysdeps/linux/nios2/clone.S
new file mode 100644
index 000000000..4dd8745cd
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/clone.S
@@ -0,0 +1,66 @@
+/*
+ * libc/sysdeps/linux/nios2/clone.S -- `clone' syscall for linux/nios2
+ *
+ *  Copyright (C) 2004  Microtronix Datacom Ltd
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License.  See the file COPYING.LIB in the main
+ * directory of this archive for more details.
+ * 
+ * Written by Wentao Xu <wentao@microtronix.com>
+ */
+#include <asm/errno.h>
+#include <asm/unistd.h>
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg); */
+
+.text
+.balign 4
+.type	clone,@function
+.globl	clone;
+clone:
+.type	__clone,@function
+.globl	__clone;
+__clone:
+	addi    sp,sp,-8
+	mov     r8,r4
+	stw     ra,4(sp)
+	stw     r16,0(sp)
+
+	mov     r4,r6
+	movi    r2,-EINVAL
+	
+	/* sanity check */
+	beq     r8,zero,CLONE_ERROR_LABEL
+	beq     r5,zero,CLONE_ERROR_LABEL
+	
+	/* system call */
+	movi    r2,TRAP_ID_SYSCALL
+	movi    r3,__NR_clone
+	trap
+	
+	/* child call the function */
+	mov     r4,r7
+	bne     r2,zero,CLONE_ERROR_LABEL
+	callr   r8
+	
+	/* exit if it returns */
+	mov     r4,r2
+	movi    r3,__NR_exit
+	trap
+	
+CLONE_ERROR_LABEL: 
+	movi    r3,-4096
+	sub     r16,zero,r2
+	bgeu    r3,r2,CLONE_OK
+	
+	/* store errno */
+	call    __errno_location
+	stw     r16,0(r2)
+	movi    r2,-1
+
+CLONE_OK:
+	ldw     ra,4(sp)
+	ldw     r16,0(sp)
+	addi    sp,sp,8
+	ret
diff --git a/libc/sysdeps/linux/nios2/clone.c b/libc/sysdeps/linux/nios2/clone.c
new file mode 100644
index 000000000..0555658b4
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/clone.c
@@ -0,0 +1,49 @@
+/*
+ * libc/sysdeps/linux/nios2/clone.c -- `clone' syscall for linux/nios2
+ *
+ *  Copyright (C) 2004,05  Microtronix Datacom Ltd
+ *  Copyright (C) 2002,03  NEC Electronics Corporation
+ *  Copyright (C) 2002,03  Miles Bader <miles@gnu.org>
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License.  See the file COPYING.LIB in the main
+ * directory of this archive for more details.
+ *
+ * Written by Miles Bader <miles@gnu.org>
+ * Nios2 port by Wentao Xu
+ */
+
+#include <errno.h>
+#include <sys/syscall.h>
+
+int clone (int (*fn)(void *arg), void *child_stack, int flags, void *arg)
+{
+  register unsigned long rval asm ("r2") = -EINVAL;
+
+  if (fn && child_stack) {
+      register unsigned long syscall asm ("r3");
+      register unsigned long arg0 asm ("r4");
+      register unsigned long arg1 asm ("r5");
+
+      /* Clone this thread.  */
+      rval = TRAP_ID_SYSCALL;
+      syscall = __NR_clone;
+      arg0 = flags;
+      arg1 = (unsigned long)child_stack;
+      asm volatile ("trap "
+         : "=r" (rval), "=r" (syscall)
+         : "0" (rval),"1" (syscall), "r" (arg0), "r" (arg1)
+         );
+
+      if (rval == 0) {
+         /* In child thread, call fn and exit.  */
+         arg0 = (*fn) (arg);
+         syscall = __NR_exit;
+         asm volatile ("trap "
+          : "=r" (rval), "=r" (syscall)
+          : "1" (syscall), "r" (arg0));
+      }
+   }
+
+  __syscall_return (int, rval);
+}
diff --git a/libc/sysdeps/linux/nios2/crt0.S b/libc/sysdeps/linux/nios2/crt0.S
new file mode 100644
index 000000000..95c9450cd
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/crt0.S
@@ -0,0 +1,64 @@
+/*
+ * libc/sysdeps/linux/nios2/crt0.S -- entry point for linux/nios2
+ *
+ *  Copyright (C) 2004,05,06  Microtronix Datacom Ltd
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License.  See the file COPYING.LIB in the main
+ * directory of this archive for more details.
+ * 
+ * Written by Wentao Xu <wentao@microtronix.com>
+ * 
+ */
+
+#include <features.h>
+#include <asm/unistd.h>
+
+    .global _start
+    .type   __start,@function
+    .weak   _init
+    .weak   _fini
+    .type   __uClibc_start_main,@function
+    .type   __h_errno_location, @function
+    .type   _stdio_init, @function
+    .type   _stdio_term, @function
+    .text
+	.balign 4
+_start:
+    nop
+    br 0f
+	.long _stext	/* start address of .text + 4 */
+	.long _etext	/* start address of .data */
+	.long _edata	/* start address of .bss */
+0:
+    /* load gp */
+    movhi gp, %hiadj(_gp)
+    addi gp, gp, %lo(_gp)
+
+    /* load argc, argv, envp from stack */
+    ldw r4, 0(sp)
+    ldw r5, 4(sp)
+    ldw r6, 8(sp)
+    
+    /* load the 4th arg */
+    movhi r7, %hi(_init)
+    ori  r7, r7, %lo(_init)
+  
+    /* reuse the argc stack slot for the 5th arg */
+    movhi r8, %hi(_fini)
+    ori  r8, r8, %lo(_fini)
+    stw  r8, 0(sp)
+   
+    /* call uClibc_main, shouldn't return */
+#ifdef __PIC__
+    /* just pray 16 bit offset is enough */
+    br __uClibc_start_main
+#else
+    call __uClibc_start_main
+#endif
+
+    /* crash in the event of return */
+__exit:
+    movui r2, TRAP_ID_SYSCALL
+    movui r3, __NR_exit
+    trap
\ No newline at end of file
diff --git a/libc/sysdeps/linux/nios2/crti.S b/libc/sysdeps/linux/nios2/crti.S
new file mode 100644
index 000000000..7867c21c0
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/crti.S
@@ -0,0 +1,31 @@
+   .file   "initfini.c"
+#APP
+  
+   .section .init
+#NO_APP
+   .balign 4
+   .global __init
+   .type   __init, @function
+__init:
+    addi sp, sp, -8
+    stw  ra, 0(sp)
+    stw  fp, 4(sp)
+#APP
+  
+   .balign 4
+   
+   
+   .section .fini
+#NO_APP
+   .balign 4
+   .global __fini
+   .type   __fini, @function
+__fini:
+    addi sp, sp, -8
+    stw  ra, 0(sp)
+    stw  fp, 4(sp)
+#APP
+  .balign 4
+   
+   
+  .ident  "GCC: (GNU) 3.3.2"
diff --git a/libc/sysdeps/linux/nios2/crtn.S b/libc/sysdeps/linux/nios2/crtn.S
new file mode 100644
index 000000000..dfac2ab22
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/crtn.S
@@ -0,0 +1,30 @@
+   .file   "initfini.c"
+#APP
+  
+   .section .init
+#NO_APP
+   .balign  4
+   .globl  _init
+   .type   _init, @function
+#NO_APP
+    ldw ra, 0(sp)
+    ldw fp, 4(sp)
+    addi sp, sp, 8
+    ret
+   .size   _init, .-_init
+#APP
+    
+   .section .fini
+#NO_APP
+   .balign  4
+   .globl  _fini
+   .type   _fini, @function
+#NO_APP
+    ldw ra, 0(sp)
+    ldw fp, 4(sp)
+    addi sp, sp, 8
+    ret
+   .size   _fini, .-_fini
+#APP
+    
+   .ident  "GCC: (GNU) 3.3.2"
diff --git a/libc/sysdeps/linux/nios2/fpu_control.h b/libc/sysdeps/linux/nios2/fpu_control.h
new file mode 100644
index 000000000..b7cdf2f3e
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/fpu_control.h
@@ -0,0 +1,97 @@
+/* FPU control word bits.  Nios2 version.
+   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H
+
+/* MIPS FPU floating point control register bits.
+ *
+ * 31-25  -> floating point conditions code bits 7-1.  These bits are only
+ *           available in MIPS IV.
+ * 24     -> flush denormalized results to zero instead of
+ *           causing unimplemented operation exception.  This bit is only
+ *           available for MIPS III and newer.
+ * 23     -> Condition bit
+ * 22-18  -> reserved (read as 0, write with 0)
+ * 17     -> cause bit for unimplemented operation
+ * 16     -> cause bit for invalid exception
+ * 15     -> cause bit for division by zero exception
+ * 14     -> cause bit for overflow exception
+ * 13     -> cause bit for underflow exception
+ * 12     -> cause bit for inexact exception
+ * 11     -> enable exception for invalid exception
+ * 10     -> enable exception for division by zero exception
+ *  9     -> enable exception for overflow exception
+ *  8     -> enable exception for underflow exception
+ *  7     -> enable exception for inexact exception
+ *  6     -> flag invalid exception
+ *  5     -> flag division by zero exception
+ *  4     -> flag overflow exception
+ *  3     -> flag underflow exception
+ *  2     -> flag inexact exception
+ *  1-0   -> rounding control
+ *
+ *
+ * Rounding Control:
+ * 00 - rounding to nearest (RN)
+ * 01 - rounding toward zero (RZ)
+ * 10 - rounding (up) toward plus infinity (RP)
+ * 11 - rounding (down)toward minus infinity (RM)
+ */
+
+#include <features.h>
+
+/* masking of interrupts */
+#define _FPU_MASK_V     0x0800  /* Invalid operation */
+#define _FPU_MASK_Z     0x0400  /* Division by zero  */
+#define _FPU_MASK_O     0x0200  /* Overflow          */
+#define _FPU_MASK_U     0x0100  /* Underflow         */
+#define _FPU_MASK_I     0x0080  /* Inexact operation */
+
+/* flush denormalized numbers to zero */
+#define _FPU_FLUSH_TZ   0x1000000
+
+/* rounding control */
+#define _FPU_RC_NEAREST 0x0     /* RECOMMENDED */
+#define _FPU_RC_ZERO    0x1
+#define _FPU_RC_UP      0x2
+#define _FPU_RC_DOWN    0x3
+
+#define _FPU_RESERVED 0xfe3c0000  /* Reserved bits in cw */
+
+
+/* The fdlibm code requires strict IEEE double precision arithmetic,
+   and no interrupts for exceptions, rounding to nearest.  */
+
+#define _FPU_DEFAULT  0x00000000
+
+/* IEEE:  same as above, but exceptions */
+#define _FPU_IEEE     0x00000F80
+
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__SI__)));
+
+/* Macros for accessing the hardware control word.  */
+#define _FPU_GETCW(cw) __asm__ ("cfc1 %0,$31" : "=r" (cw))
+#define _FPU_SETCW(cw) __asm__ ("ctc1 %0,$31" : : "r" (cw))
+
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+
+#endif	/* fpu_control.h */
diff --git a/libc/sysdeps/linux/nios2/setjmp.S b/libc/sysdeps/linux/nios2/setjmp.S
new file mode 100644
index 000000000..b2ff52162
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/setjmp.S
@@ -0,0 +1,51 @@
+/*
+ * libc/sysdeps/linux/nios2/setjmp.S
+ *
+ *  Copyright (C) 2004,05,06  Microtronix Datacom Ltd
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License.  See the file COPYING.LIB in the main
+ * directory of this archive for more details.
+ * 
+ * Written by Wentao Xu <wentao@microtronix.com>
+ * 
+ */
+
+#define _ASM
+#define _SETJMP_H
+#include <bits/setjmp.h>
+
+.globl __sigsetjmp
+.type  __sigsetjmp,@function
+.balign 4
+
+__sigsetjmp:
+    stw     r16, (JB_REGS+ 0)(r4)
+    stw     r17, (JB_REGS+ 4)(r4)
+    stw     r18, (JB_REGS+ 8)(r4)
+    stw     r19, (JB_REGS+12)(r4)
+    stw     r20, (JB_REGS+16)(r4)
+    stw     r21, (JB_REGS+20)(r4)
+    stw     r22, (JB_REGS+24)(r4)
+    stw     r23, (JB_REGS+28)(r4)
+    
+    stw     ra, JB_PC(r4)
+    stw     sp, JB_SP(r4)
+    stw     fp, JB_FP(r4)
+    stw     gp, JB_GP(r4)
+    
+#if defined(__HAVE_FPU__)
+    SAVE_FPU r4 JB_FPREGS
+#endif
+
+#ifdef   __PIC__
+    /* just pray 16 bit offset is enough */
+    br __sigjmp_save
+#else
+    movhi r8, %hi(__sigjmp_save)
+    ori r8, r8, %lo(__sigjmp_save)    
+    jmp r8
+#endif
+
+
+
diff --git a/libc/sysdeps/linux/nios2/sys/procfs.h b/libc/sysdeps/linux/nios2/sys/procfs.h
new file mode 100644
index 000000000..8cbaa41c5
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/sys/procfs.h
@@ -0,0 +1,123 @@
+/* Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somehow modelled after the file of the same name on SysVr4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  */
+
+#include <features.h>
+#include <signal.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/ucontext.h>
+#include <sys/user.h>
+#include <bits/wordsize.h>
+
+__BEGIN_DECLS
+
+#define ELF_NGREG		38
+
+typedef struct
+  {
+    union
+      {
+	unsigned long	pr_regs[32];
+	double		pr_dregs[16];
+      }			pr_fr;
+    unsigned long	__unused;
+    unsigned long	pr_fsr;
+    unsigned char	pr_qcnt;
+    unsigned char	pr_q_entrysize;
+    unsigned char	pr_en;
+    unsigned int	pr_q[64];
+  } elf_fpregset_t;
+
+typedef unsigned long elf_greg_t;
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   gdb doesn't really use excluded.  Fields present but not used are
+   marked with "XXX".  */
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __pid_t lwpid_t;
+
+
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff --git a/libc/sysdeps/linux/nios2/sys/ucontext.h b/libc/sysdeps/linux/nios2/sys/ucontext.h
new file mode 100644
index 000000000..1805b4eac
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/sys/ucontext.h
@@ -0,0 +1,104 @@
+/* Copyright (C) 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+/*
+ * Location of the users' stored registers relative to R0.
+ * Usage is as an index into a gregset_t array or as u.u_ar0[XX].
+ */
+#define REG_PSR (0)
+#define REG_PC  (1)
+#define REG_SPARE   (2)
+#define REG_WVALID  (3)
+#define REG_G1  (4)
+#define REG_G2  (5)
+#define REG_G3  (6)
+#define REG_G4  (7)
+#define REG_G5  (8)
+#define REG_G6  (9)
+#define REG_G7  (10)
+#define REG_O0  (11)
+#define REG_O1  (12)
+#define REG_O2  (13)
+#define REG_O3  (14)
+#define REG_O4  (15)
+#define REG_O5  (16)
+#define REG_O6  (17)
+#define REG_O7  (18)
+#define REG_GLOBALS (19)
+
+/*
+ * A gregset_t is defined as an array type for compatibility with the reference
+ * source. This is important due to differences in the way the C language
+ * treats arrays and structures as parameters.
+ *
+ * Note that NGREG is really (sizeof (struct regs) / sizeof (greg_t)),
+ * but that the ABI defines it absolutely to be 21 (resp. 19).
+ */
+
+#define NGREG   20
+typedef int greg_t;
+
+typedef greg_t  gregset_t[NGREG];
+
+/*
+ * The following structures define how a register window can appear on the
+ * stack. This structure is available (when required) through the `gwins'
+ * field of an mcontext (nested within ucontext). NIOS_MAXWINDOW is the
+ * maximum number of outstanding register windows defined in the NIOS
+ * architecture (*not* implementation).
+ */
+#define NIOS_MAXREGWINDOW	31	/* max windows in NIOS arch. */
+struct  rwindow
+  {
+    greg_t rw_local[8];			/* locals */
+    greg_t rw_in[8];			/* ins */
+  };
+
+#define rw_fp   rw_in[6]		/* frame pointer */
+#define rw_rtn  rw_in[7]		/* return address */
+
+typedef struct gwindows
+  {
+    int            wbcnt;
+    int           *spbuf[NIOS_MAXREGWINDOW];
+    struct rwindow wbuf[NIOS_MAXREGWINDOW];
+  } gwindows_t;
+
+typedef struct
+  {
+    gregset_t   gregs;		/* general register set */
+    gwindows_t  *gwins;		/* POSSIBLE pointer to register windows */
+  } mcontext_t;
+
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long   uc_flags;
+    struct ucontext *uc_link;
+    __sigset_t	    uc_sigmask;
+    stack_t         uc_stack;
+    mcontext_t      uc_mcontext;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff --git a/libc/sysdeps/linux/nios2/syscall.c b/libc/sysdeps/linux/nios2/syscall.c
new file mode 100644
index 000000000..c6cce215a
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/syscall.c
@@ -0,0 +1,47 @@
+/* 
+ * libc/sysdeps/linux/nios2/syscall.c -- generic syscall function for linux/nios2
+ *
+ * Copyright (C) 2004 Microtronix Datacom Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <features.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+
+
+long syscall(long sysnum, long a, long b, long c, long d, long e, long f)
+{
+    register long _r2 asm("r2")=(long)TRAP_ID_SYSCALL;
+    register long _r3 asm("r3")=(long)sysnum;
+   
+    register long _r4 asm("r4")=(long)(a);
+    register long _r5 asm("r5")=(long)(b);
+    register long _r6 asm("r6")=(long)(c);
+    register long _r7 asm("r7")=(long)(d);
+    register long _r8 asm("r8")=(long)(e);
+    register long _r9 asm("r9")=(long)(f);
+    asm volatile(
+	    "trap "
+	    : "=r"(_r2), "=r"(_r3)
+	    : "0"(_r2), "1"(_r3),
+	      "r"(_r4), "r"(_r5), "r"(_r6), "r"(_r7), "r"(_r8), "r"(_r9)
+	    : "memory");
+
+  __syscall_return (long, _r2);
+}
+
diff --git a/libc/sysdeps/linux/nios2/vfork.S b/libc/sysdeps/linux/nios2/vfork.S
new file mode 100644
index 000000000..a19a90023
--- /dev/null
+++ b/libc/sysdeps/linux/nios2/vfork.S
@@ -0,0 +1,53 @@
+/*
+ * libc/sysdeps/linux/nios2/vfork.S -- `vfork' syscall for linux/nios2
+ *
+ *  Copyright (C) 2004  Microtronix Datacom Ltd
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License.  See the file COPYING.LIB in the main
+ * directory of this archive for more details.
+ * 
+ * Written by Wentao Xu <wentao@microtronix.com>
+ */
+#include <asm/unistd.h>
+
+#ifndef __NR_vfork
+#define __NR_vfork __NR_fork /* uClinux-2.0 only has fork which is vfork */
+#endif
+
+   .text
+   .balign 4
+   .globl errno
+   .globl vfork
+   .globl __libc_vfork
+#if defined __HAVE_ELF__
+   .type    vfork,@function
+   .type    __libc_vfork,@function
+#endif
+vfork:
+__libc_vfork:
+    movui   r2, TRAP_ID_SYSCALL
+    movui   r3, __NR_vfork
+    trap
+    movi    r8, -4096
+    bltu    r8, r2, fix_errno
+    ret
+fix_errno:
+    sub     r8, r0, r2
+    
+    addi    sp, sp, -8
+    stw     ra, 4(sp)
+    stw     r8, 0(sp)
+#ifndef __PIC__
+    call    __errno_location
+#else
+    
+#endif
+    ldw     ra, 4(sp)
+    ldw     r8, 0(sp)
+    stw     r8, 0(r2)
+    
+    addi    r2, r0, -1
+    addi  sp, sp, 8
+    ret
+
diff --git a/libpthread/linuxthreads/sysdeps/nios/pt-machine.h b/libpthread/linuxthreads/sysdeps/nios/pt-machine.h
new file mode 100644
index 000000000..5d82b8d16
--- /dev/null
+++ b/libpthread/linuxthreads/sysdeps/nios/pt-machine.h
@@ -0,0 +1,67 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   ARM version.
+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Philip Blundell <philb@gnu.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#ifndef PT_EI
+# define PT_EI extern inline
+#endif
+
+extern long int testandset (int *spinlock);
+/* Spinlock implementation; required.  */
+/* it is weird and dangerous to disable interrupt in userspace, but for nios
+   what else we can do before we have a swap like instruction?  This is better
+   than nothing
+ */
+PT_EI long int
+testandset (int *spinlock)
+{
+  unsigned int ret;
+
+  __asm__ __volatile__("pfx 8\n\t"
+  			"wrctl %1	; disable interrupt\n\t"
+			"nop\n\t"
+			"nop\n\t"
+  			"ld %0, [%2]\n\t"
+  			"st [%2], %1\n\t"
+  			"pfx 9\n\t"
+  			"wrctl %1	; enable interrupt\n\t"
+			"nop\n\t"
+			"nop\n\t"
+ 		       : "=&r"(ret)
+		       : "r"(1), "r"(spinlock)
+		       : "memory");
+
+  return ret;
+}
+
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("%sp");
+
+/* nios needs more because of reg windows */
+#define THREAD_MANAGER_STACK_SIZE (32*1024)
+#define STACK_SIZE	(32*1024)
+
+#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads/sysdeps/nios2/pt-machine.h b/libpthread/linuxthreads/sysdeps/nios2/pt-machine.h
new file mode 100644
index 000000000..484a77e14
--- /dev/null
+++ b/libpthread/linuxthreads/sysdeps/nios2/pt-machine.h
@@ -0,0 +1,58 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   nios2 version.
+   Copyright (C) 1996, 1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, write to the Free Software Foundation, Inc.,
+   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#ifndef PT_EI
+# define PT_EI extern inline
+#endif
+
+extern long int testandset (int *spinlock);
+
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+  unsigned int scratch;
+  long int ret=-2;
+
+  __asm__ __volatile__(
+         "rdctl %0, status\n\t"
+         "and	%0, %0, %1\n\t"
+         "wrctl status, %0   #disable interrupts\n\t"
+         "ldw %1, 0(%4)\n\t"
+         "stw %3, 0(%4)\n\t"
+         "ori	%0, %0, 1\n\t"
+         "wrctl status, %0   #enable interrupts\n\t"
+       : "=&r"(scratch), "=r"(ret)
+       : "1"(ret), "r"(1), "r"(spinlock)
+       : "memory");
+
+  return ret;
+}
+
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("%sp");
+
+#endif /* pt-machine.h */